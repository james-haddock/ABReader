<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" xml:lang="en-us" lang="en-us">
  <head>
    <title>Clean Architecture</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="h2f" id="ch33"><a id="page_297" class="calibre3"></a><span class="gray">33</span><br class="calibre12"/>C<small class="calibre7">ASE</small> S<small class="calibre7">TUDY</small>: V<small class="calibre7">IDEO</small> S<small class="calibre7">ALES</small></h2>
<div class="image1"><img src="../images/00114.jpeg" alt="Image" class="calibre2"/></div>
<p class="noindent1"><a id="page_298"></a>Now it’s time to put these rules and thoughts about architecture together into a case study. This case study will be short and simple, yet will depict both the process a good architect uses and the decisions that such an architect makes.</p>
<h3 class="h1" id="toclev_164">T<small class="calibre13">HE</small> P<small class="calibre13">RODUCT</small></h3>
<p class="noindent1">For this case study, I’ve chosen a product with which I am rather intimately familiar: the software for a website that sells videos. Of course, it is reminiscent of <code class="calibre11"><a href="http://cleancoders.com">cleancoders.com</a></code>, the site where I sell my software tutorial videos.</p>
<p class="noindent1">The basic idea is trivial. We have a batch of videos we want to sell. We sell them, on the web, to both individuals and businesses. Individuals can pay one price to stream the videos, and another, higher price to download those videos and own them permanently. Business licenses are streaming only, and are purchased in batches that allow quantity discounts.</p>
<p class="noindent1">Individuals typically act as both the viewers and the purchasers. Businesses, in contrast, often have people who buy the videos that other people will watch.</p>
<p class="noindent1">Video authors need to supply their video files, written descriptions, and ancillary files with exams, problems, solutions, source code, and other materials.</p>
<p class="noindent1">Administrators need to add new video series, add and delete videos to and from the series, and establish prices for various licenses.</p>
<p class="noindent1">Our first step in determining the initial architecture of the system is to identify the actors and use cases.</p>
<h3 class="h1" id="toclev_165">U<small class="calibre13">SE</small> C<small class="calibre13">ASE</small> A<small class="calibre13">NALYSIS</small></h3>
<p class="noindent1"><a href="part0048.html#ch33fig1">Figure 33.1</a> shows a typical use-case analysis.</p>
<div class="fig-heading">
<div class="image1"><a id="page_299"></a><img src="../images/00115.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch33fig1"></a><strong class="calibre8">Figure 33.1</strong> A typical use-case analysis</p>
</div>
<p class="noindent1">The four main actors are evident. According to the Single Responsibility Principle, these four actors will be the four primary sources of change for the system. Every time some new feature is added, or some existing feature is changed, that step will be taken to serve one of these actors. Therefore we want to partition the system such that a change to one actor does not affect any of the other actors.</p>
<p class="noindent1">The use cases shown in <a href="part0048.html#ch33fig1">Figure 33.1</a> are not a complete list. For example, you won’t find log-in or log-out use cases. The reason for this omission is simply to manage the size of the problem in this book. If I were to include all the different use cases, then this chapter would have to turn into a book in its own right.</p>
<p class="noindent1"><a id="page_300"></a>Note the dashed use cases in the center of <a href="part0048.html#ch33fig1">Figure 33.1</a>. They are <em class="calibre9">abstract</em><sup class="calibre10"><a id="ch33fn1"></a><a href="part0048.html#ch33fn-1">1</a></sup> use cases. An abstract use case is one that sets a general policy that another use case will flesh out. As you can see, the <em class="calibre9">View Catalog as Viewer</em> and <em class="calibre9">View Catalog as Purchaser</em> use cases both inherit from the <em class="calibre9">View Catalog</em> abstract use case.</p>
<p class="noindent1">On the one hand, it was not strictly necessary for me to create that abstraction. I could have left the abstract use case out of the diagram without compromising any of the features of the overall product. On the other hand, these two use cases are <em class="calibre9">so similar</em> that I thought it wise to recognize the similarity and find a way to unify it early in the analysis.</p>
<h3 class="h1" id="toclev_166">C<small class="calibre13">OMPONENT</small> A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">Now that we know the actors and use cases, we can create a preliminary component architecture (<a href="part0048.html#ch33fig2">Figure 33.2</a>).</p>
<p class="noindent1">The double lines in the drawing represent architectural boundaries as usual. You can see the typical partitioning of views, presenters, interactors, and controllers. You can also see that I’ve broken each of those categories up by their corresponding actors.</p>
<p class="noindent1">Each of the components in <a href="part0048.html#ch33fig2">Figure 33.2</a> represents a potential <code class="calibre11">.jar</code> file or <code class="calibre11">.dll</code> file. Each of those components will contain the views, presenters, interactors, and controllers that have been allocated to it.</p>
<p class="noindent1">Note the special components for the <code class="calibre11">Catalog View</code> and the <code class="calibre11">Catalog Presenter</code>. This is how I dealt with the abstract <em class="calibre9">View Catalog</em> use case. I assume that those views and presenters will be coded into abstract classes within those components, and that the inheriting components will contain view and presenter classes that will inherit from those abstract classes.</p>
<div class="fig-heading">
<div class="image1"><a id="page_301"></a><img src="../images/00116.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch33fig2"></a><strong class="calibre8">Figure 33.2</strong> A preliminary component architecture</p>
</div>
<p class="noindent1">Would I really break the system up into all these components, and deliver them as <code class="calibre11">.jar</code> or <code class="calibre11">.dll</code> files? Yes and no. I would certainly break the compile and build environment up this way, so that I <em class="calibre9">could</em> build independent deliverables like that. I would also reserve the right to combine all those deliverables into a smaller number of deliverables if necessary. For example, given the partitioning in <a href="part0048.html#ch33fig2">Figure 33.2</a>, it would be easy to combine them into five <code class="calibre11">.jar</code> files—one for views, presenters, interactors, controllers, and utilities, respectively. I could then independently deploy the components that are most likely to change independently of each other.</p>
<p class="noindent1">Another possible grouping would be to put the views and presenters together into the same <code class="calibre11">.jar</code> file, and put the interactors, controllers, and utilities in their own <code class="calibre11">.jar</code> file. Still another, even more primitive, grouping would be to create two <code class="calibre11">.jar</code> files, with views and presenters in one file, and everything else in the other.</p>
<p class="noindent1"><a id="page_302"></a>Keeping these options open will allow us to adapt the way we deploy the system based on how the system changes over time.</p>
<h3 class="h1" id="toclev_167">D<small class="calibre13">EPENDENCY</small> M<small class="calibre13">ANAGEMENT</small></h3>
<p class="noindent1">The flow of control in <a href="part0048.html#ch33fig2">Figure 33.2</a> proceeds from right to left. Input occurs at the controllers, and that input is processed into a result by the interactors. The presenters then format the results, and the views display those presentations.</p>
<p class="noindent1">Notice that the arrows do not all flow from the right to the left. In fact, most of them point from left to right. This is because the architecture is following the <em class="calibre9">Dependency Rule</em>. All dependencies cross the boundary lines in one direction, and they always point toward the components containing the higher-level policy.</p>
<p class="noindent1">Also notice that the <em class="calibre9">using</em> relationships (open arrows) point <em class="calibre9">with</em> the flow of control, and that the <em class="calibre9">inheritance</em> relationships (closed arrows) point <em class="calibre9">against</em> the flow of control. This depicts our use of the Open–Closed Principle to make sure that the dependencies flow in the right direction, and that changes to low-level details do not ripple upward to affect high-level policies.</p>
<h3 class="h1" id="toclev_168">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The architecture diagram in <a href="part0048.html#ch33fig2">Figure 33.2</a> includes two dimensions of separation. The first is the separation of actors based on the Single Responsibility Principle; the second is the Dependency Rule. The goal of both is to separate components that change for different reasons, and at different rates. The different reasons correspond to the actors; the different rates correspond to the different levels of policy.</p>
<p class="noindent1">Once you have structured the code this way, you can mix and match how you want to actually deploy the system. You can group the components into deployable deliverables in any way that makes sense, and easily change that grouping when conditions change.</p>
<p class="fn"><a id="ch33fn-1"></a><a href="part0048.html#ch33fn1">1</a>. This is my own notation for “abstract” use cases. It would have been more standard to use a UML stereotype such as &lt;&lt;abstract&gt;&gt;, but I don‘t find adhering to such standards very useful nowadays.</p>
</body></html>
