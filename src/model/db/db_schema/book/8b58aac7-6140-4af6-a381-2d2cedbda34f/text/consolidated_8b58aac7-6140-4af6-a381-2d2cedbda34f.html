<html><head><link href="../page_styles.css" rel="stylesheet"/><link href="../stylesheet.css" rel="stylesheet"/></head><body><body>
<div>
<svg height="100%" preserveaspectratio="none" version="1.1" viewbox="0 0 902 1186" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<image height="1186" width="902" xlink:href="../images/00178.jpeg"/>
</svg>
</div>
</body><body class="calibre">
<h2 class="calibre1" id="part0000_pref00">About This E-Book</h2>
<p class="indent">EPUB is an open, industry-standard format for e-books. However, support for EPUB and its many features varies across reading devices and applications. Use your device or app settings to customize the presentation to your liking. Settings that you can customize often include font, font size, single or double column, landscape or portrait mode, and figures that you can click or tap to enlarge. For additional information about the settings and features on your reading device or app, visit the device manufacturer’s Web site.</p>
<p class="indent">Many titles include programming code or configuration examples. To optimize the presentation of these elements, view the e-book in single-column, landscape mode and adjust the font size to the smallest setting. In addition to presenting code and configurations in the reflowable text format, we have included images of the code that mimic the presentation found in the print book; therefore, where the reflowable format may compromise the presentation of the code listing, you will see a “Click here to view code image” link. Click the link to view the print-fidelity code image. To return to the previous page viewed, click the Back button on your device or app.</p>
</body><body class="calibre">
<p class="image"><a id="part0001_page_i"></a><a id="part0001_page_ii"></a><img alt="images" class="calibre2" loading="lazy" src="../images/00001.jpeg"/></p>
</body><body class="calibre" id="part0002_1T140-5590eccca840400d9389878dd74e52fe">
<p class="hr"></p>
<h1 class="h" id="part0002_title"><a class="calibre3" id="part0002_page_iii"></a><strong class="calibre4">Clean Architecture</strong></h1>
<p class="subtitle"><strong class="calibre4">A C<small class="calibre5">RAFTSMAN’S</small> G<small class="calibre5">UIDE TO</small> S<small class="calibre5">OFTWARE</small> S<small class="calibre5">TRUCTURE AND DESIGN</small></strong></p>
<p class="hr1"></p>
<p class="author">Robert C. Martin</p>
<p class="publisher"><img alt="images" class="calibre2" loading="lazy" src="../images/00002.jpeg"/></p>
<p class="address">Boston • Columbus • Indianapolis • New York • San Francisco • Amsterdam • Cape Town Dubai • London • Madrid • Milan • Munich • Paris • Montreal • Toronto • Delhi • Mexico City São Paulo • Sydney • Hong Kong • Seoul • Singapore • Taipei • Tokyo</p>
</body><body class="calibre" id="part0003_2RHM0-5590eccca840400d9389878dd74e52fe">
<p class="copyrighttb" id="part0003_copyright"><a id="part0003_page_iv"></a>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and the publisher was aware of a trademark claim, the designations have been printed with initial capital letters or in all capitals.</p>
<p class="copyrightb">The author and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.</p>
<p class="copyrightb">For information about buying this title in bulk quantities, or for special sales opportunities (which may include electronic versions; custom cover designs; and content particular to your business, training goals, marketing focus, or branding interests), please contact our corporate sales department at <a href="mailto:corpsales@pearsoned.com">corpsales@pearsoned.com</a> or (800) 382-3419.</p>
<p class="copyrightb">For government sales inquiries, please contact <a href="mailto:governmentsales@pearsoned.com">governmentsales@pearsoned.com</a>.</p>
<p class="copyrightb">For questions about sales outside the U.S., please contact <a href="mailto:intlcs@pearson.com">intlcs@pearson.com</a>.</p>
<p class="copyrightb">Visit us on the Web: <a href="http://informit.com">informit.com</a></p>
<p class="copyrightb">Library of Congress Control Number: 2017945537</p>
<p class="copyrightb">Copyright © 2018 Pearson Education, Inc.</p>
<p class="copyrightb">All rights reserved. Printed in the United States of America. This publication is protected by copyright, and permission must be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, recording, or likewise. For information regarding permissions, request forms and the appropriate contacts within the Pearson Education Global Rights &amp; Permissions Department, please visit <a href="http://www.pearsoned.com/permissions/">www.pearsoned.com/permissions/</a>.</p>
<p class="copyrightb">ISBN-13: 978-0-13-449416-6<br class="calibre6"/>ISBN-10: 0-13-449416-4</p>
<p class="copyrightb">1 17</p>
</body><body class="calibre" id="part0004_3Q280-5590eccca840400d9389878dd74e52fe">
<p class="ded"><a id="part0004_page_v"></a>This book is dedicated to my lovely wife, my four spectacular children, and their families, including my quiver full of five grandchildren—who are the dessert of my life.<a id="part0004_page_vi"></a></p>
</body><body class="calibre" id="part0005_4OIQ0-5590eccca840400d9389878dd74e52fe">
<h2 class="h2f" id="part0005_contents"><a class="calibre3" id="part0005_page_vii"></a><strong class="calibre4">C<small class="calibre7">ONTENTS</small></strong></h2>
<p class="toc-fm"><a href="#part0006_foreword"><strong class="calibre8">Foreword</strong></a></p>
<p class="toc-fm"><a href="#part0007_preface"><strong class="calibre8">Preface</strong></a></p>
<p class="toc-fm"><a href="#part0008_ack"><strong class="calibre8">Acknowledgments</strong></a></p>
<p class="toc-fm"><a href="#part0009_about"><strong class="calibre8">About the Author</strong></a></p>
<p class="tocpart"><a href="#part0010_part1"><strong class="calibre8">PART I         Introduction</strong></a></p>
<p class="toc"><a href="#part0011_ch1"><strong class="calibre8">Chapter 1     What Is Design and Architecture?</strong></a></p>
<p class="toc1"><a href="#part0011_toclev_1">The Goal?</a></p>
<p class="toc1"><a href="#part0011_toclev_2">Case Study</a></p>
<p class="toc1"><a href="#part0011_toclev_3">Conclusion</a></p>
<p class="toc"><a href="#part0012_ch2"><strong class="calibre8">Chapter 2     A Tale of Two Values</strong></a></p>
<p class="toc1"><a href="#part0012_toclev_4">Behavior</a></p>
<p class="toc1"><a href="#part0012_toclev_5">Architecture</a></p>
<p class="toc1"><a href="#part0012_toclev_6">The Greater Value</a></p>
<p class="toc1"><a href="#part0012_toclev_7">Eisenhower’s Matrix</a></p>
<p class="toc1"><a href="#part0012_toclev_8">Fight for the Architecture</a></p>
<p class="tocpart"><a id="part0005_page_viii"></a><a href="#part0013_part2"><strong class="calibre8">PART II       Starting with the Bricks: Programming Paradigms</strong></a></p>
<p class="toc"><a href="#part0014_ch3"><strong class="calibre8">Chapter 3     Paradigm Overview</strong></a></p>
<p class="toc1"><a href="#part0014_toclev_9">Structured Programming</a></p>
<p class="toc1"><a href="#part0014_toclev_10">Object-Oriented Programming</a></p>
<p class="toc1"><a href="#part0014_toclev_11">Functional Programming</a></p>
<p class="toc1"><a href="#part0014_toclev_12">Food for Thought</a></p>
<p class="toc1"><a href="#part0014_toclev_13">Conclusion</a></p>
<p class="toc"><a href="#part0015_ch4"><strong class="calibre8">Chapter 4     Structured Programming</strong></a></p>
<p class="toc1"><a href="#part0015_toclev_14">Proof</a></p>
<p class="toc1"><a href="#part0015_toclev_15">A Harmful Proclamation</a></p>
<p class="toc1"><a href="#part0015_toclev_16">Functional Decomposition</a></p>
<p class="toc1"><a href="#part0015_toclev_17">No Formal Proofs</a></p>
<p class="toc1"><a href="#part0015_toclev_18">Science to the Rescue</a></p>
<p class="toc1"><a href="#part0015_toclev_19">Tests</a></p>
<p class="toc1"><a href="#part0015_toclev_20">Conclusion</a></p>
<p class="toc"><a href="#part0016_ch5"><strong class="calibre8">Chapter 5     Object-Oriented Programming</strong></a></p>
<p class="toc1"><a href="#part0016_toclev_21">Encapsulation?</a></p>
<p class="toc1"><a href="#part0016_toclev_22">Inheritance?</a></p>
<p class="toc1"><a href="#part0016_toclev_23">Polymorphism?</a></p>
<p class="toc1"><a href="#part0016_toclev_24">Conclusion</a></p>
<p class="toc"><a href="#part0017_ch6"><strong class="calibre8">Chapter 6     Functional Programming</strong></a></p>
<p class="toc1"><a href="#part0017_toclev_25">Squares of Integers</a></p>
<p class="toc1"><a href="#part0017_toclev_26">Immutability and Architecture</a></p>
<p class="toc1"><a href="#part0017_toclev_27">Segregation of Mutability</a></p>
<p class="toc1"><a href="#part0017_toclev_28">Event Sourcing</a></p>
<p class="toc1"><a href="#part0017_toclev_29">Conclusion</a></p>
<p class="tocpart"><a href="#part0018_part3"><strong class="calibre8">PART III      Design Principles</strong></a></p>
<p class="toc"><a href="#part0019_ch7"><strong class="calibre8">Chapter 7     SRP: The Single Responsibility Principle</strong></a></p>
<p class="toc1"><a href="#part0019_toclev_30">Symptom 1: Accidental Duplication</a></p>
<p class="toc1"><a href="#part0019_toclev_31">Symptom 2: Merges</a></p>
<p class="toc1"><a href="#part0019_toclev_32">Solutions</a></p>
<p class="toc1"><a href="#part0019_toclev_33">Conclusion</a></p>
<p class="toc"><a id="part0005_page_ix"></a><a href="#part0020_ch8"><strong class="calibre8">Chapter 8     OCP: The Open-Closed Principle</strong></a></p>
<p class="toc1"><a href="#part0020_toclev_35">A Thought Experiment</a></p>
<p class="toc1"><a href="#part0020_toclev_36">Directional Control</a></p>
<p class="toc1"><a href="#part0020_toclev_37">Information Hiding</a></p>
<p class="toc1"><a href="#part0020_toclev_38">Conclusion</a></p>
<p class="toc"><a href="#part0021_ch9"><strong class="calibre8">Chapter 9     LSP: The Liskov Substitution Principle</strong></a></p>
<p class="toc1"><a href="#part0021_toclev_39">Guiding the Use of Inheritance</a></p>
<p class="toc1"><a href="#part0021_toclev_40">The Square/Rectangle Problem</a></p>
<p class="toc1"><a href="#part0021_toclev_41">LSP and Architecture</a></p>
<p class="toc1"><a href="#part0021_toclev_42">Example LSP Violation</a></p>
<p class="toc1"><a href="#part0021_toclev_43">Conclusion</a></p>
<p class="toc1a"><a href="#part0022_ch10"><strong class="calibre8">Chapter 10   ISP: The Interface Segregation Principle</strong></a></p>
<p class="toc1"><a href="#part0022_toclev_44">ISP and Language</a></p>
<p class="toc1"><a href="#part0022_toclev_45">ISP and Architecture</a></p>
<p class="toc1"><a href="#part0022_toclev_46">Conclusion</a></p>
<p class="toc1a"><a href="#part0023_ch11"><strong class="calibre8">Chapter 11   DIP: The Dependency Inversion Principle</strong></a></p>
<p class="toc1"><a href="#part0023_toclev_47">Stable Abstractions</a></p>
<p class="toc1"><a href="#part0023_toclev_48">Factories</a></p>
<p class="toc1"><a href="#part0023_toclev_49">Concrete Components</a></p>
<p class="toc1"><a href="#part0023_toclev_50">Conclusion</a></p>
<p class="tocpart"><a href="#part0024_part4"><strong class="calibre8">PART IV      Component Principles</strong></a></p>
<p class="toc1a"><a href="#part0025_ch12"><strong class="calibre8">Chapter 12   Components</strong></a></p>
<p class="toc1"><a href="#part0025_toclev_51">A Brief History of Components</a></p>
<p class="toc1"><a href="#part0025_toclev_52">Relocatability</a></p>
<p class="toc1"><a href="#part0025_toclev_53">Linkers</a></p>
<p class="toc1"><a href="#part0025_toclev_54">Conclusion</a></p>
<p class="toc1a"><a href="#part0026_ch13"><strong class="calibre8">Chapter 13   Component Cohesion</strong></a></p>
<p class="toc1"><a href="#part0026_toclev_55">The Reuse/Release Equivalence Principle</a></p>
<p class="toc1"><a href="#part0026_toclev_56">The Common Closure Principle</a></p>
<p class="toc1"><a href="#part0026_toclev_57">The Common Reuse Principle</a></p>
<p class="toc1"><a href="#part0026_toclev_58">The Tension Diagram for Component Cohesion</a></p>
<p class="toc1"><a href="#part0026_toclev_59">Conclusion</a></p>
<p class="toc1a"><a id="part0005_page_x"></a><a href="#part0027_ch14"><strong class="calibre8">Chapter 14   Component Coupling</strong></a></p>
<p class="toc1"><a href="#part0027_toclev_60">The Acyclic Dependencies Principle</a></p>
<p class="toc1"><a href="#part0027_toclev_61">Top-Down Design</a></p>
<p class="toc1"><a href="#part0027_toclev_62">The Stable Dependencies Principle</a></p>
<p class="toc1"><a href="#part0027_toclev_63">The Stable Abstractions Principle</a></p>
<p class="toc1"><a href="#part0027_toclev_64">Conclusion</a></p>
<p class="tocpart"><a href="#part0028_part5"><strong class="calibre8">PART V       Architecture</strong></a></p>
<p class="toc1a"><a href="#part0029_ch15"><strong class="calibre8">Chapter 15   What Is Architecture?</strong></a></p>
<p class="toc1"><a href="#part0029_toclev_65">Development</a></p>
<p class="toc1"><a href="#part0029_toclev_66">Deployment</a></p>
<p class="toc1"><a href="#part0029_toclev_67">Operation</a></p>
<p class="toc1"><a href="#part0029_toclev_68">Maintenance</a></p>
<p class="toc1"><a href="#part0029_toclev_69">Keeping Options Open</a></p>
<p class="toc1"><a href="#part0029_toclev_70">Device Independence</a></p>
<p class="toc1"><a href="#part0029_toclev_71">Junk Mail</a></p>
<p class="toc1"><a href="#part0029_toclev_72">Physical Addressing</a></p>
<p class="toc1"><a href="#part0029_toclev_73">Conclusion</a></p>
<p class="toc1a"><a href="#part0030_ch16"><strong class="calibre8">Chapter 16   Independence</strong></a></p>
<p class="toc1"><a href="#part0030_toclev_74">Use Cases</a></p>
<p class="toc1"><a href="#part0030_toclev_75">Operation</a></p>
<p class="toc1"><a href="#part0030_toclev_76">Development</a></p>
<p class="toc1"><a href="#part0030_toclev_77">Deployment</a></p>
<p class="toc1"><a href="#part0030_toclev_78">Leaving Options Open</a></p>
<p class="toc1"><a href="#part0030_toclev_79">Decoupling Layers</a></p>
<p class="toc1"><a href="#part0030_toclev_80">Decoupling Use Cases</a></p>
<p class="toc1"><a href="#part0030_toclev_81">Decoupling Mode</a></p>
<p class="toc1"><a href="#part0030_toclev_82">Independent Develop-ability</a></p>
<p class="toc1"><a href="#part0030_toclev_83">Independent Deployability</a></p>
<p class="toc1"><a href="#part0030_toclev_84">Duplication</a></p>
<p class="toc1"><a href="#part0030_toclev_85">Decoupling Modes (Again)</a></p>
<p class="toc1"><a href="#part0030_toclev_86">Conclusion</a></p>
<p class="toc1a"><a id="part0005_page_xi"></a><a href="#part0031_ch17"><strong class="calibre8">Chapter 17   Boundaries: Drawing Lines</strong></a></p>
<p class="toc1"><a href="#part0031_toclev_87">A Couple of Sad Stories</a></p>
<p class="toc1"><a href="#part0031_toclev_88">FitNesse</a></p>
<p class="toc1"><a href="#part0031_toclev_89">Which Lines Do You Draw, and When Do You Draw Them?</a></p>
<p class="toc1"><a href="#part0031_toclev_90">What About Input and Output?</a></p>
<p class="toc1"><a href="#part0031_toclev_91">Plugin Architecture</a></p>
<p class="toc1"><a href="#part0031_toclev_92">The Plugin Argument</a></p>
<p class="toc1"><a href="#part0031_toclev_93">Conclusion</a></p>
<p class="toc1a"><a href="#part0032_ch18"><strong class="calibre8">Chapter 18   Boundary Anatomy</strong></a></p>
<p class="toc1"><a href="#part0032_toclev_94">Boundary Crossing</a></p>
<p class="toc1"><a href="#part0032_toclev_95">The Dreaded Monolith</a></p>
<p class="toc1"><a href="#part0032_toclev_96">Deployment Components</a></p>
<p class="toc1"><a href="#part0032_toclev_97">Threads</a></p>
<p class="toc1"><a href="#part0032_toclev_98">Local Processes</a></p>
<p class="toc1"><a href="#part0032_toclev_99">Services</a></p>
<p class="toc1"><a href="#part0032_toclev_100">Conclusion</a></p>
<p class="toc1a"><a href="#part0033_ch19"><strong class="calibre8">Chapter 19   Policy and Level</strong></a></p>
<p class="toc1"><a href="#part0033_toclev_101">Level</a></p>
<p class="toc1"><a href="#part0033_toclev_102">Conclusion</a></p>
<p class="toc1a"><a href="#part0034_ch20"><strong class="calibre8">Chapter 20   Business Rules</strong></a></p>
<p class="toc1"><a href="#part0034_toclev_103">Entities</a></p>
<p class="toc1"><a href="#part0034_toclev_104">Use Cases</a></p>
<p class="toc1"><a href="#part0034_toclev_105">Request and Response Models</a></p>
<p class="toc1"><a href="#part0034_toclev_106">Conclusion</a></p>
<p class="toc1a"><a href="#part0035_ch21"><strong class="calibre8">Chapter 21   Screaming Architecture</strong></a></p>
<p class="toc1"><a href="#part0035_toclev_107">The Theme of an Architecture</a></p>
<p class="toc1"><a href="#part0035_toclev_108">The Purpose of an Architecture</a></p>
<p class="toc1"><a href="#part0035_toclev_109">But What About the Web?</a></p>
<p class="toc1"><a href="#part0035_toclev_110">Frameworks Are Tools, Not Ways of Life</a></p>
<p class="toc1"><a href="#part0035_toclev_111">Testable Architectures</a></p>
<p class="toc1"><a href="#part0035_toclev_112">Conclusion</a></p>
<p class="toc1a"><a id="part0005_page_xii"></a><a href="#part0036_ch22"><strong class="calibre8">Chapter 22   The Clean Architecture</strong></a></p>
<p class="toc1"><a href="#part0036_toclev_113">The Dependency Rule</a></p>
<p class="toc1"><a href="#part0036_toclev_114">A Typical Scenario</a></p>
<p class="toc1"><a href="#part0036_toclev_115">Conclusion</a></p>
<p class="toc1a"><a href="#part0037_ch23"><strong class="calibre8">Chapter 23   Presenters and Humble Objects</strong></a></p>
<p class="toc1"><a href="#part0037_toclev_116">The Humble Object Pattern</a></p>
<p class="toc1"><a href="#part0037_toclev_117">Presenters and Views</a></p>
<p class="toc1"><a href="#part0037_toclev_118">Testing and Architecture</a></p>
<p class="toc1"><a href="#part0037_toclev_119">Database Gateways</a></p>
<p class="toc1"><a href="#part0037_toclev_120">Data Mappers</a></p>
<p class="toc1"><a href="#part0037_toclev_121">Service Listeners</a></p>
<p class="toc1"><a href="#part0037_toclev_122">Conclusion</a></p>
<p class="toc1a"><a href="#part0038_ch24"><strong class="calibre8">Chapter 24   Partial Boundaries</strong></a></p>
<p class="toc1"><a href="#part0038_toclev_123">Skip the Last Step</a></p>
<p class="toc1"><a href="#part0038_toclev_124">One-Dimensional Boundaries</a></p>
<p class="toc1"><a href="#part0038_toclev_125">Facades</a></p>
<p class="toc1"><a href="#part0038_toclev_126">Conclusion</a></p>
<p class="toc1a"><a href="#part0039_ch25"><strong class="calibre8">Chapter 25   Layers and Boundaries</strong></a></p>
<p class="toc1"><a href="#part0039_toclev_127">Hunt the Wumpus</a></p>
<p class="toc1"><a href="#part0039_toclev_128">Clean Architecture?</a></p>
<p class="toc1"><a href="#part0039_toclev_129">Crossing the Streams</a></p>
<p class="toc1"><a href="#part0039_toclev_130">Splitting the Streams</a></p>
<p class="toc1"><a href="#part0039_toclev_131">Conclusion</a></p>
<p class="toc1a"><a href="#part0040_ch26"><strong class="calibre8">Chapter 26   The Main Component</strong></a></p>
<p class="toc1"><a href="#part0040_toclev_132">The Ultimate Detail</a></p>
<p class="toc1"><a href="#part0040_toclev_133">Conclusion</a></p>
<p class="toc1a"><a href="#part0041_ch27"><strong class="calibre8">Chapter 27   Services: Great and Small</strong></a></p>
<p class="toc1"><a href="#part0041_toclev_134">Service Architecture?</a></p>
<p class="toc1"><a href="#part0041_toclev_135">Service Benefits?</a></p>
<p class="toc1"><a href="#part0041_toclev_136">The Kitty Problem</a></p>
<p class="toc1"><a href="#part0041_toclev_137">Objects to the Rescue</a></p>
<p class="toc1"><a id="part0005_page_xiii"></a><a href="#part0041_toclev_138">Component-Based Services</a></p>
<p class="toc1"><a href="#part0041_toclev_139">Cross-Cutting Concerns</a></p>
<p class="toc1"><a href="#part0041_toclev_140">Conclusion</a></p>
<p class="toc1a"><a href="#part0042_ch28"><strong class="calibre8">Chapter 28   The Test Boundary</strong></a></p>
<p class="toc1"><a href="#part0042_toclev_141">Tests as System Components</a></p>
<p class="toc1"><a href="#part0042_toclev_142">Design for Testability</a></p>
<p class="toc1"><a href="#part0042_toclev_143">The Testing API</a></p>
<p class="toc1"><a href="#part0042_toclev_144">Conclusion</a></p>
<p class="toc1a"><a href="#part0043_ch29"><strong class="calibre8">Chapter 29   Clean Embedded Architecture</strong></a></p>
<p class="toc1"><a href="#part0043_toclev_145">App-titude Test</a></p>
<p class="toc1"><a href="#part0043_toclev_146">The Target-Hardware Bottleneck</a></p>
<p class="toc1"><a href="#part0043_toclev_147">Conclusion</a></p>
<p class="tocpart"><a href="#part0044_part6"><strong class="calibre8">PART VI      Details</strong></a></p>
<p class="toc1a"><a href="#part0045_ch30"><strong class="calibre8">Chapter 30   The Database Is a Detail</strong></a></p>
<p class="toc1"><a href="#part0045_toclev_148">Relational Databases</a></p>
<p class="toc1"><a href="#part0045_toclev_149">Why Are Database Systems So Prevalent?</a></p>
<p class="toc1"><a href="#part0045_toclev_150">What If There Were No Disk?</a></p>
<p class="toc1"><a href="#part0045_toclev_151">Details</a></p>
<p class="toc1"><a href="#part0045_toclev_152">But What about Performance?</a></p>
<p class="toc1"><a href="#part0045_toclev_153">Anecdote</a></p>
<p class="toc1"><a href="#part0045_toclev_154">Conclusion</a></p>
<p class="toc1a"><a href="#part0046_ch31"><strong class="calibre8">Chapter 31   The Web Is a Detail</strong></a></p>
<p class="toc1"><a href="#part0046_toclev_155">The Endless Pendulum</a></p>
<p class="toc1"><a href="#part0046_toclev_156">The Upshot</a></p>
<p class="toc1"><a href="#part0046_toclev_157">Conclusion</a></p>
<p class="toc1a"><a href="#part0047_ch32"><strong class="calibre8">Chapter 32   Frameworks Are Details</strong></a></p>
<p class="toc1"><a href="#part0047_toclev_158">Framework Authors</a></p>
<p class="toc1"><a href="#part0047_toclev_159">Asymmetric Marriage</a></p>
<p class="toc1"><a href="#part0047_toclev_160">The Risks</a></p>
<p class="toc1"><a href="#part0047_toclev_161">The Solution</a></p>
<p class="toc1"><a id="part0005_page_xiv"></a><a href="#part0047_toclev_162">I Now Pronounce You …</a></p>
<p class="toc1"><a href="#part0047_toclev_163">Conclusion</a></p>
<p class="toc1a"><a href="#part0048_ch33"><strong class="calibre8">Chapter 33   Case Study: Video Sales</strong></a></p>
<p class="toc1"><a href="#part0048_toclev_164">The Product</a></p>
<p class="toc1"><a href="#part0048_toclev_165">Use Case Analysis</a></p>
<p class="toc1"><a href="#part0048_toclev_166">Component Architecture</a></p>
<p class="toc1"><a href="#part0048_toclev_167">Dependency Management</a></p>
<p class="toc1"><a href="#part0048_toclev_168">Conclusion</a></p>
<p class="toc1a"><a href="#part0049_ch34"><strong class="calibre8">Chapter 34   The Missing Chapter</strong></a></p>
<p class="toc1"><a href="#part0049_toclev_169">Package by Layer</a></p>
<p class="toc1"><a href="#part0049_toclev_170">Package by Feature</a></p>
<p class="toc1"><a href="#part0049_toclev_171">Ports and Adapters</a></p>
<p class="toc1"><a href="#part0049_toclev_172">Package by Component</a></p>
<p class="toc1"><a href="#part0049_toclev_173">The Devil Is in the Implementation Details</a></p>
<p class="toc1"><a href="#part0049_toclev_174">Organization versus Encapsulation</a></p>
<p class="toc1"><a href="#part0049_toclev_175">Other Decoupling Modes</a></p>
<p class="toc1"><a href="#part0049_toclev_176">Conclusion: The Missing Advice</a></p>
<p class="tocpart"><a href="#part0050_part7"><strong class="calibre8">PART VII     Appendix</strong></a></p>
<p class="toc-fm1"><a href="#part0051_appendixa"><strong class="calibre8">Appendix A   Architecture Archaeology</strong></a></p>
<p class="toc-fm1"><a href="#part0052_index"><strong class="calibre8">Index</strong></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0006_foreword"><a class="calibre3" id="part0006_page_xv"></a>F<small class="calibre7">OREWORD</small></h2>
<p class="noindent">What do we talk about when we talk about architecture?</p>
<p class="noindent">As with any metaphor, describing software through the lens of architecture can hide as much as it can reveal. It can both promise more than it can deliver and deliver more than it promises.</p>
<p class="noindent">The obvious appeal of architecture is structure, and structure is something that dominates the paradigms and discussions of software development—components, classes, functions, modules, layers, and services, micro or macro. But the gross structure of so many software systems often defies either belief or understanding—Enterprise Soviet schemes destined for legacy, improbable Jenga towers reaching toward the cloud, archaeological layers buried in a big-ball-of-mud slide. It’s not obvious that software structure obeys our intuition the way building structure does.</p>
<p class="noindent">Buildings have an obvious physical structure, whether rooted in stone or concrete, whether arching high or sprawling wide, whether large or small, whether magnificent or mundane. Their structures have little choice but to respect the physics of gravity and their materials. On the other hand—except in its sense of seriousness—software has little time for gravity. And what is software made of? Unlike buildings, which may be made of bricks, concrete, <a id="part0006_page_xvi"></a>wood, steel, and glass, software is made of software. Large software constructs are made from smaller software components, which are in turn made of smaller software components still, and so on. It’s coding turtles all the way down.</p>
<p class="noindent">When we talk about software architecture, software is recursive and fractal in nature, etched and sketched in code. Everything is details. Interlocking levels of detail also contribute to a building’s architecture, but it doesn’t make sense to talk about physical scale in software. Software has structure—many structures and many kinds of structures—but its variety eclipses the range of physical structure found in buildings. You can even argue quite convincingly that there is more design activity and focus in software than in building architecture—in this sense, it’s not unreasonable to consider software architecture more architectural than building architecture!</p>
<p class="noindent">But physical scale is something humans understand and look for in the world. Although appealing and visually obvious, the boxes on a PowerPoint diagram are not a software system’s architecture. There’s no doubt they represent a particular view of an architecture, but to mistake boxes for <em class="calibre9">the</em> big picture—for <em class="calibre9">the</em> architecture—is to miss the big picture and the architecture: Software architecture doesn’t look like anything. A particular visualization is a choice, not a given. It is a choice founded on a further set of choices: what to include; what to exclude; what to emphasize by shape or color; what to de-emphasize through uniformity or omission. There is nothing natural or intrinsic about one view over another.</p>
<p class="noindent">Although it might not make sense to talk about physics and physical scale in software architecture, we do appreciate and care about certain physical constraints. Processor speed and network bandwidth can deliver a harsh verdict on a system’s performance. Memory and storage can limit the ambitions of any code base. Software may be such stuff as dreams are made on, but it runs in the physical world.</p>
<p class="blockquotem"><em class="calibre9">This is the monstrosity in love, lady, that the will is infinite, and the execution confined; that the desire is boundless, and the act a slave to limit.</em></p>
<p class="right">—William Shakespeare</p>
<p class="noindent"><a id="part0006_page_xvii"></a>The physical world is where we and our companies and our economies live. This gives us another calibration we can understand software architecture by, other less physical forces and quantities through which we can talk and reason.</p>
<p class="blockquotem"><em class="calibre9">Architecture represents the significant design decisions that shape a system, where significant is measured by cost of change.</em></p>
<p class="right">—Grady Booch</p>
<p class="noindent">Time, money, and effort give us a sense of scale to sort between the large and the small, to distinguish the architectural stuff from the rest. This measure also tells us how we can determine whether an architecture is good or not: Not only does a good architecture meet the needs of its users, developers, and owners at a given point in time, but it also meets them over time.</p>
<p class="blockquotem"><em class="calibre9">If you think good architecture is expensive, try bad architecture.</em></p>
<p class="right">—Brian Foote and Joseph Yoder</p>
<p class="noindent">The kinds of changes a system’s development typically experiences should not be the changes that are costly, that are hard to make, that take managed projects of their own rather than being folded into the daily and weekly flow of work.</p>
<p class="noindent">That point leads us to a not-so-small physics-related problem: time travel. How do we know what those typical changes will be so that we can shape those significant decisions around them? How do we reduce future development effort and cost without crystal balls and time machines?</p>
<p class="blockquotem"><em class="calibre9">Architecture is the decisions that you wish you could get right early in a project, but that you are not necessarily more likely to get them right than any other.</em></p>
<p class="right">—Ralph Johnson</p>
<p class="noindent">Understanding the past is hard enough as it is; our grasp of the present is slippery at best; predicting the future is nontrivial.</p>
<p class="noindent">This is where the road forks many ways.</p>
<p class="noindent"><a id="part0006_page_xviii"></a>Down the darkest path comes the idea that strong and stable architecture comes from authority and rigidity. If change is expensive, change is eliminated—its causes subdued or headed off into a bureaucratic ditch. The architect’s mandate is total and totalitarian, with the architecture becoming a dystopia for its developers and a constant source of frustration for all.</p>
<p class="noindent">Down another path comes a strong smell of speculative generality. A route filled with hard-coded guesswork, countless parameters, tombs of dead code, and more accidental complexity than you can shake a maintenance budget at.</p>
<p class="noindent">The path we are most interested is the cleanest one. It recognizes the softness of software and aims to preserve it as a first-class property of the system. It recognizes that we operate with incomplete knowledge, but it also understands that, as humans, operating with incomplete knowledge is something we do, something we’re good at. It plays more to our strengths than to our weaknesses. We create things and we discover things. We ask questions and we run experiments. A good architecture comes from understanding it more as a journey than as a destination, more as an ongoing process of enquiry than as a frozen artifact.</p>
<p class="blockquotem"><em class="calibre9">Architecture is a hypothesis, that needs to be proven by implementation and measurement.</em></p>
<p class="right">—Tom Gilb</p>
<p class="noindent1">To walk this path requires care and attention, thought and observation, practice and principle. This might at first sound slow, but it’s all in the way that you walk.</p>
<p class="blockquotem"><em class="calibre9">The only way to go fast, is to go well.</em></p>
<p class="right">—Robert C. Martin</p>
<p class="noindent">Enjoy the journey.</p>
<p class="right">—<em class="calibre9">Kevlin Henney<br class="calibre6"/>May 2017</em></p>
</body><body class="calibre">
<h2 class="h2f" id="part0007_preface"><a class="calibre3" id="part0007_page_xix"></a>P<small class="calibre7">REFACE</small></h2>
<p class="noindent">The title of this book is <em class="calibre9">Clean Architecture</em>. That’s an audacious name. Some would even call it arrogant. So why did I choose that title, and why did I write this book?</p>
<p class="noindent">I wrote my very first line of code in 1964, at the age of 12. The year is now 2016, so I have been writing code for more than half a century. In that time, I have learned a few things about how to structure software systems—things that I believe others would likely find valuable.</p>
<p class="noindent">I learned these things by building many systems, both large and small. I have built small embedded systems and large batch processing systems. I have built real-time systems and web systems. I have built console apps, GUI apps, process control apps, games, accounting systems, telecommunications systems, design tools, drawing apps, and many, many others.</p>
<p class="noindent">I have built single-threaded apps, multithreaded apps, apps with few heavy-weight processes, apps with many light-weight processes, multiprocessor apps, database apps, mathematical apps, computational geometry apps, and many, many others.</p>
<p class="noindent"><a id="part0007_page_xx"></a>I’ve built a lot of apps. I’ve built a lot of systems. And from them all, and by taking them all into consideration, I’ve learned something startling.</p>
<p class="noindent"><em class="calibre9">The architecture rules are the same!</em></p>
<p class="noindent">This is startling because the systems that I have built have all been so radically different. Why should such different systems all share similar rules of architecture? My conclusion is that <em class="calibre9">the rules of software architecture are independent of every other variable</em>.</p>
<p class="noindent">This is even more startling when you consider the change that has taken place in hardware over the same half-century. I started programming on machines the size of kitchen refrigerators that had half-megahertz cycle times, 4K of core memory, 32K of disk memory, and a 10 character per second teletype interface. I am writing this preface on a bus while touring in South Africa. I am using a MacBook with four i7 cores running at 2.8 gigahertz each. It has 16 gigabytes of RAM, a terabyte of SSD, and a 2880×1800 retina display capable of showing extremely high-definition video. The difference in computational power is staggering. Any reasonable analysis will show that this MacBook is at least 10<sup class="calibre10">22</sup> more powerful than those early computers that I started using half a century ago.</p>
<p class="noindent">Twenty-two orders of magnitude is a very large number. It is the number of angstroms from Earth to Alpha-Centuri. It is the number of electrons in the change in your pocket or purse. And yet that number—that number <em class="calibre9">at least—</em>is the computational power increase that I have experienced in my own lifetime.</p>
<p class="noindent">And with all that vast change in computational power, what has been the effect on the software I write? It’s gotten bigger certainly. I used to think 2000 lines was a big program. After all, it was a full box of cards that weighed 10 pounds. Now, however, a program isn’t really big until it exceeds 100,000 lines.</p>
<p class="noindent">The software has also gotten much more performant. We can do things today that we could scarcely dream about in the 1960s. <em class="calibre9">The Forbin Project</em>, <em class="calibre9">The <a id="part0007_page_xxi"></a>Moon Is a Harsh Mistress</em>, and <em class="calibre9">2001: A Space Odyssey</em> all tried to imagine our current future, but missed the mark rather significantly. They all imagined huge machines that gained sentience. What we have instead are impossibly small machines that are still … just machines.{xx}</p>
<p class="noindent">And there is one thing more about the software we have now, compared to the software from back then: <em class="calibre9">It’s made of the same stuff.</em> It’s made of <code class="calibre11">if</code> statements, assignment statements, and <code class="calibre11">while</code> loops.</p>
<p class="noindent">Oh, you might object and say that we’ve got much better languages and superior paradigms. After all, we program in Java, or C#, or Ruby, and we use object-oriented design. True—and yet the code is still just an assemblage of sequence, selection, and iteration, just as it was back in the 1960s and 1950s.</p>
<p class="noindent">When you really look closely at the practice of programming computers, you realize that very little has changed in 50 years. The languages have gotten a little better. The tools have gotten fantastically better. But the basic building blocks of a computer program have not changed.</p>
<p class="noindent">If I took a computer programmer from 1966 forward in time to 2016 and put her<sup class="calibre10"><a id="part0007_prefacefn1"></a><a href="#part0007_prefacefn-1">1</a></sup> in front of my MacBook running IntelliJ and showed her Java, she might need 24 hours to recover from the shock. But then she would be able to write the code. Java just isn’t that different from C, or even from Fortran.</p>
<p class="noindent">And if I transported you back to 1966 and showed you how to write and edit PDP-8 code by punching paper tape on a 10 character per second teletype, you might need 24 hours to recover from the disappointment. But then you would be able to write the code. The code just hasn’t changed that much.</p>
<p class="noindent">That’s the secret: This changelessness of the code is the reason that the rules of software architecture are so consistent across system types. The rules of software architecture are the rules of ordering and assembling the building <a id="part0007_page_xxii"></a>blocks of programs. And since those building blocks are universal and haven’t changed, the rules for ordering them are likewise universal and changeless.</p>
<p class="noindent">Younger programmers might think this is nonsense. They might insist that everything is new and different nowadays, that the rules of the past are past and gone. If that is what they think, they are sadly mistaken. The rules have not changed. Despite all the new languages, and all the new frameworks, and all the paradigms, the rules are the same now as they were when Alan Turing wrote the first machine code in 1946.</p>
<p class="noindent">But one thing has changed: Back then, we didn’t know what the rules were. Consequently, we broke them, over and over again. Now, with half a century of experience behind us, we have a grasp of those rules.</p>
<p class="noindent">And it is those rules—those timeless, changeless, rules—that this book is all about.</p>
<div class="box">
<p class="noindent1">Register your copy of <em class="calibre9">Clean Architecture</em> on the InformIT site for convenient access to updates and/or corrections as they become available. To start the registration process, go to <a href="http://informit.com/register">informit.com/register</a> and log in or create an account. Enter the product ISBN (9780134494166) and click Submit. Look on the Registered Products tab for an Access Bonus Content link next to this product, and follow that link to access the bonus materials.</p>
</div>
<p class="fn"><a id="part0007_prefacefn-1"></a><a href="#part0007_prefacefn1">1</a>. And she very likely would be female since, back then, women made up a large fraction of programmers.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0008_ack"><a class="calibre3" id="part0008_page_xxiii"></a>A<small class="calibre7">CKNOWLEDGMENTS</small></h2>
<p class="noindent1">The people who played a part in the creation of this book—in no particular order:{xxiii}</p>
<p class="noindentn">Chris Guzikowski</p>
<p class="noindentn">Chris Zahn</p>
<p class="noindentn">Matt Heuser</p>
<p class="noindentn">Jeff Overbey</p>
<p class="noindentn">Micah Martin</p>
<p class="noindentn">Justin Martin</p>
<p class="noindentn">Carl Hickman</p>
<p class="noindentn">James Grenning</p>
<p class="noindentn">Simon Brown</p>
<p class="noindentn">Kevlin Henney</p>
<p class="noindentn">Jason Gorman</p>
<p class="noindentn">Doug Bradbury</p>
<p class="noindentn">Colin Jones</p>
<p class="noindentn">Grady Booch</p>
<p class="noindentn">Kent Beck</p>
<p class="noindentn"><a id="part0008_page_xxiv"></a>Martin Fowler</p>
<p class="noindentn">Alistair Cockburn</p>
<p class="noindentn">James O. Coplien</p>
<p class="noindentn">Tim Conrad</p>
<p class="noindentn">Richard Lloyd</p>
<p class="noindentn">Ken Finder</p>
<p class="noindentn">Kris Iyer (CK)</p>
<p class="noindentn">Mike Carew</p>
<p class="noindentn">Jerry Fitzpatrick</p>
<p class="noindentn">Jim Newkirk</p>
<p class="noindentn">Ed Thelen</p>
<p class="noindentn">Joe Mabel</p>
<p class="noindentn">Bill Degnan</p>
<p class="noindent">And many others too numerous to name.</p>
<p class="noindent">In my final review of this book, as I was reading the chapter on Screaming Architecture, Jim Weirich’s bright-eyed smile and melodic laugh echoed through my mind. Godspeed, Jim!</p>
</body><body class="calibre">
<h2 class="h2f" id="part0009_about"><a class="calibre3" id="part0009_page_xxv"></a>A<small class="calibre7">BOUT THE</small> A<small class="calibre7">UTHOR</small></h2>
<p class="image"><img alt="images" class="calibre2" loading="lazy" src="../images/00003.jpeg"/></p>
<p class="noindent"><strong class="calibre8">Robert C. Martin</strong> (Uncle Bob) has been a programmer since 1970. He is the co-founder of <a href="http://cleancoders.com">cleancoders.com</a>, which offers online video training for software developers, and is the founder of Uncle Bob Consulting LLC, which offers software consulting, training, and skill development services to major corporations worldwide. He served as the Master Craftsman at 8th Light, Inc., a Chicago-based software consulting firm. He has published dozens of articles in various trade journals and is a regular speaker at international conferences and trade shows. He served three years as the editor-in-chief of the <em class="calibre9">C++ Report</em> and served as the first chairman of the Agile Alliance.</p>
<p class="noindent">Martin has authored and edited many books, including <em class="calibre9">The Clean Coder</em>, <em class="calibre9">Clean Code</em>, <em class="calibre9">UML for Java Programmers</em>, <em class="calibre9">Agile Software Development</em>, <em class="calibre9">Extreme Programming in Practice</em>, <em class="calibre9">More C++ Gems</em>, <em class="calibre9">Pattern Languages of Program Design 3</em>, and <em class="calibre9">Designing Object Oriented C++ Applications Using the Booch Method</em>.<a id="part0009_page_xxvi"></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0010_part1"><a class="calibre3" id="part0010_page_1"></a><span class="gray">I</span><br class="calibre12"/>I<small class="calibre7">NTRODUCTION</small></h2>
<p class="noindent1">It doesn’t take a huge amount of knowledge and skill to get a program working. Kids in high school do it all the time. Young men and women in college start billion-dollar businesses based on scrabbling together a few lines of PHP or Ruby. Hoards of junior programmers in cube farms around the world slog through massive requirements documents held in huge issue tracking systems to get their systems to “work” by the sheer brute force of <em class="calibre9">will</em>. The code they produce may not be pretty; but it works. It works because getting something to work—once—just isn’t that hard.</p>
<p class="noindent1">Getting it right is another matter entirely. Getting software right is <em class="calibre9">hard</em>. It takes knowledge and skills that most young programmers haven’t yet acquired. It requires thought and insight that most programmers don’t take the time to develop. It requires a level of discipline and dedication that most programmers never dreamed they’d need. Mostly, it takes a passion for the craft and the desire to be a professional.</p>
<p class="noindent1">And when you get software right, something magical happens: You don’t need hordes of programmers to keep it working. You don’t need massive requirements documents and huge issue tracking systems. You don’t need global cube farms and 24/7 programming.</p>
<p class="noindent1"><a id="part0010_page_2"></a>When software is done right, it requires a fraction of the human resources to create and maintain. Changes are simple and rapid. Defects are few and far between. Effort is minimized, and functionality and flexibility are maximized.</p>
<p class="noindent1">Yes, this vision sounds a bit utopian. But I’ve been there; I’ve seen it happen. I’ve worked in projects where the design and architecture of the system made it easy to write and easy to maintain. I’ve experienced projects that required a fraction of the anticipated human resources. I’ve worked on systems that had extremely low defect rates. I’ve seen the extraordinary effect that good software architecture can have on a system, a project, and a team. I’ve been to the promised land.</p>
<p class="noindent1">But don’t take my word for it. Look at your own experience. Have you experienced the opposite? Have you worked on systems that are so interconnected and intricately coupled that every change, regardless of how trivial, takes weeks and involves huge risks? Have you experienced the impedance of bad code and rotten design? Has the design of the systems you’ve worked on had a huge negative effect on the morale of the team, the trust of the customers, and the patience of the managers? Have you seen teams, departments, and even companies that have been brought down by the rotten structure of their software? Have you been to programming hell?</p>
<p class="noindent1">I have—and to some extent, most of the rest of us have, too. It is far more common to fight your way through terrible software designs than it is to enjoy the pleasure of working with a good one.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0011_ch1"><a class="calibre3" id="part0011_page_3"></a><span class="gray">1</span><br class="calibre12"/>W<small class="calibre7">HAT</small> I<small class="calibre7">S</small> D<small class="calibre7">ESIGN AND</small> A<small class="calibre7">RCHITECTURE</small>?</h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00004.jpeg"/></div>
<p class="noindent1"><a id="part0011_page_4"></a>There has been a lot of confusion about design and architecture over the years. What is design? What is architecture? What are the differences between the two?</p>
<p class="noindent1">One of the goals of this book is to cut through all that confusion and to define, once and for all, what design and architecture are. For starters, I’ll assert that there is no difference between them. <em class="calibre9">None at all.</em></p>
<p class="noindent1">The word “architecture” is often used in the context of something at a high level that is divorced from the lower-level details, whereas “design” more often seems to imply structures and decisions at a lower level. But this usage is nonsensical when you look at what a real architect does.</p>
<p class="noindent1">Consider the architect who designed my new home. Does this home have an architecture? Of course it does. And what is that architecture? Well, it is the shape of the home, the outward appearance, the elevations, and the layout of the spaces and rooms. But as I look through the diagrams that my architect produced, I see an immense number of low-level details. I see where every outlet, light switch, and light will be placed. I see which switches control which lights. I see where the furnace is placed, and the size and placement of the water heater and the sump pump. I see detailed depictions of how the walls, roofs, and foundations will be constructed.</p>
<p class="noindent1">In short, I see all the little details that support all the high-level decisions. I also see that those low-level details and high-level decisions are part of the whole design of the house.</p>
<p class="noindent1">And so it is with software design. The low-level details and the high-level structure are all part of the same whole. They form a continuous fabric that defines the shape of the system. You can’t have one without the other; indeed, no clear dividing line separates them. There is simply a continuum of decisions from the highest to the lowest levels.</p>
<h3 class="h1" id="part0011_toclev_1">T<small class="calibre13">HE</small> G<small class="calibre13">OAL</small>?</h3>
<p class="noindent1">And the goal of those decisions? The goal of good software design? That goal is nothing less than my utopian description:</p>
<p class="blockquote"><a id="part0011_page_5"></a><em class="calibre9">The goal of software architecture is to minimize the human resources required to build and maintain the required system.</em></p>
<p class="noindent1">The measure of design quality is simply the measure of the effort required to meet the needs of the customer. If that effort is low, and stays low throughout the lifetime of the system, the design is good. If that effort grows with each new release, the design is bad. It’s as simple as that.</p>
<h3 class="h1" id="part0011_toclev_2">C<small class="calibre13">ASE</small> S<small class="calibre13">TUDY</small></h3>
<p class="noindent1">As an example, consider the following case study. It includes real data from a real company that wishes to remain anonymous.</p>
<p class="noindent1">First, let’s look at the growth of the engineering staff. I’m sure you’ll agree that this trend is very encouraging. Growth like that shown in <a href="#part0011_ch1fig1">Figure 1.1</a> must be an indication of significant success!</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00005.jpeg"/></div>
<p class="fig-caption"><a id="part0011_ch1fig1"></a><strong class="calibre8">Figure 1.1</strong> Growth of the engineering staff</p>
<p class="source"><em class="calibre9">Reproduced with permission from a slide presentation by Jason Gorman</em></p>
</div>
<p class="noindent1"><a id="part0011_page_6"></a>Now let’s look at the company’s productivity over the same time period, as measured by simple lines of code (<a href="#part0011_ch1fig2">Figure 1.2</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00006.jpeg"/></div>
<p class="fig-caption"><a id="part0011_ch1fig2"></a><strong class="calibre8">Figure 1.2</strong> Productivity over the same period of time</p>
</div>
<p class="noindent1">Clearly something is going wrong here. Even though every release is supported by an ever-increasing number of developers, the growth of the code looks like it is approaching an asymptote.</p>
<p class="noindent1">Now here’s the really scary graph: <a href="#part0011_ch1fig3">Figure 1.3</a> shows how the cost per line of code has changed over time.</p>
<p class="noindent1">These trends aren’t sustainable. It doesn’t matter how profitable the company might be at the moment: Those curves will catastrophically drain the profit from the business model and drive the company into a stall, if not into a downright collapse.</p>
<p class="noindent1">What caused this remarkable change in productivity? Why was the code 40 times more expensive to produce in release 8 as opposed to release 1?</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00007.jpeg"/></div>
<p class="fig-caption"><a id="part0011_ch1fig3"></a><strong class="calibre8">Figure 1.3</strong> Cost per line of code over time</p>
</div>
<h4 class="h2"><a class="calibre3" id="part0011_page_7"></a>T<small class="calibre13">HE</small> S<small class="calibre13">IGNATURE OF A</small> M<small class="calibre13">ESS</small></h4>
<p class="noindent1">What you are looking at is the signature of a mess. When systems are thrown together in a hurry, when the sheer number of programmers is the sole driver of output, and when little or no thought is given to the cleanliness of the code or the structure of the design, then you can bank on riding this curve to its ugly end.</p>
<p class="noindent1"><a href="#part0011_ch1fig4">Figure 1.4</a> shows what this curve looks like to the developers. They started out at nearly 100% productivity, but with each release their productivity declined. By the fourth release, it was clear that their productivity was going to bottom out in an asymptotic approach to zero.</p>
<div class="fig-heading">
<div class="image1"><a id="part0011_page_8"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00008.jpeg"/></div>
<p class="fig-caption"><a id="part0011_ch1fig4"></a><strong class="calibre8">Figure 1.4</strong> Productivity by release</p>
</div>
<p class="noindent1">From the developers’ point of view, this is tremendously frustrating, because everyone is working <em class="calibre9">hard</em>. Nobody has decreased their effort.</p>
<p class="noindent1">And yet, despite all their heroics, overtime, and dedication, they simply aren’t getting much of anything done anymore. All their effort has been diverted away from features and is now consumed with managing the mess. Their job, such as it is, has changed into moving the mess from one place to the next, and the next, and the next, so that they can add one more meager little feature.</p>
<h4 class="h2">T<small class="calibre13">HE</small> E<small class="calibre13">XECUTIVE</small> V<small class="calibre13">IEW</small></h4>
<p class="noindent1">If you think <em class="calibre9">that’s</em> bad, imagine what this picture looks like to the executives! Consider <a href="#part0011_ch1fig5">Figure 1.5</a>, which depicts monthly development payroll for the same period.</p>
<div class="fig-heading">
<div class="image1"><a id="part0011_page_9"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00009.jpeg"/></div>
<p class="fig-caption"><a id="part0011_ch1fig5"></a><strong class="calibre8">Figure 1.5</strong> Monthly development payroll by release</p>
</div>
<p class="noindent1">Release 1 was delivered with a monthly payroll of a few hundred thousand dollars. The second release cost a few hundred thousand more. By the eighth release monthly payroll was $20 million, and climbing.</p>
<p class="noindent1">Just this chart alone is scary. Clearly something startling is happening. One hopes that revenues are outpacing costs and therefore justifying the expense. But no matter how you look at this curve, it’s cause for concern.</p>
<p class="noindent1">But now compare the curve in <a href="#part0011_ch1fig5">Figure 1.5</a> with the lines of code written per release in <a href="#part0011_ch1fig2">Figure 1.2</a>. That initial few hundred thousand dollars per month bought a lot of functionality—but the final $20 million bought almost nothing! Any CFO would look at these two graphs and know that immediate action is necessary to stave off disaster.</p>
<p class="noindent1">But which action can be taken? What has gone wrong? What has caused this incredible decline in productivity? What can executives do, other than to stamp their feet and rage at the developers?</p>
<h4 class="h2">W<small class="calibre13">HAT</small> W<small class="calibre13">ENT</small> W<small class="calibre13">RONG</small>?</h4>
<p class="noindent1">Nearly 2600 years ago, Aesop told the story of the Tortoise and the Hare. The moral of that story has been stated many times in many different ways:</p>
<p class="indenthangingb"><a id="part0011_page_10"></a>• “Slow and steady wins the race.”</p>
<p class="indenthangingb">• “The race is not to the swift, nor the battle to the strong.”</p>
<p class="indenthangingb">• “The more haste, the less speed.”</p>
<p class="noindent1">The story itself illustrates the foolishness of overconfidence. The Hare, so confident in its intrinsic speed, does not take the race seriously, and so naps while the Tortoise crosses the finish line.</p>
<p class="noindent1">Modern developers are in a similar race, and exhibit a similar overconfidence. Oh, they don’t sleep—far from it. Most modern developers work their butts off. But a part of their brain <em class="calibre9">does</em> sleep—the part that knows that good, clean, well-designed code <em class="calibre9">matters</em>.</p>
<p class="noindent1">These developers buy into a familiar lie: “We can clean it up later; we just have to get to market first!” Of course, things never do get cleaned up later, because market pressures never abate. Getting to market first simply means that you’ve now got a horde of competitors on your tail, and you have to stay ahead of them by running as fast as you can.</p>
<p class="noindent1">And so the developers never switch modes. They can’t go back and clean things up because they’ve got to get the next feature done, and the next, and the next, and the next. And so the mess builds, and productivity continues its asymptotic approach toward zero.</p>
<p class="noindent1">Just as the Hare was overconfident in its speed, so the developers are overconfident in their ability to remain productive. But the creeping mess of code that saps their productivity never sleeps and never relents. If given its way, it will reduce productivity to zero in a matter of months.</p>
<p class="noindent1">The bigger lie that developers buy into is the notion that writing messy code makes them go fast in the short term, and just slows them down in the long term. Developers who accept this lie exhibit the hare’s overconfidence in their ability to switch modes from making messes to cleaning up messes sometime in the future, but they also make a simple error of fact. The fact is that <em class="calibre9">making messes is always slower than staying clean</em>, no matter which time scale you are using.</p>
<p class="noindent1"><a id="part0011_page_11"></a>Consider the results of a remarkable experiment performed by Jason Gorman depicted in <a href="#part0011_ch1fig6">Figure 1.6</a>. Jason conducted this test over a period of six days. Each day he completed a simple program to convert integers into Roman numerals. He knew his work was complete when his predefined set of acceptance tests passed. Each day the task took a little less than 30 minutes. Jason used a well-known cleanliness discipline named test-driven development (TDD) on the first, third, and fifth days. On the other three days, he wrote the code without that discipline.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00010.jpeg"/></div>
<p class="fig-caption"><a id="part0011_ch1fig6"></a><strong class="calibre8">Figure 1.6</strong> Time to completion by iterations and use/non-use of TDD</p>
</div>
<p class="noindent1">First, notice the learning curve apparent in <a href="#part0011_ch1fig6">Figure 1.6</a>. Work on the latter days is completed more quickly than the former days. Notice also that work on the TDD days proceeded approximately 10% faster than work on the non-TDD days, and that even the slowest TDD day was faster than the fastest non-TDD day.</p>
<p class="noindent1">Some folks might look at that result and think it’s a remarkable outcome. But to those who haven’t been deluded by the Hare’s overconfidence, the result is expected, because they know this simple truth of software development:</p>
<p class="blockquote"><em class="calibre9">The only way to go fast, is to go well.</em></p>
<p class="noindent1"><a id="part0011_page_12"></a>And that’s the answer to the executive’s dilemma. The only way to reverse the decline in productivity and the increase in cost is to get the developers to stop thinking like the overconfident Hare and start taking responsibility for the mess that they’ve made.</p>
<p class="noindent1">The developers may think that the answer is to start over from scratch and redesign the whole system—but that’s just the Hare talking again. The same overconfidence that led to the mess is now telling them that they can build it better if only they can start the race over. The reality is less rosy:</p>
<p class="blockquote"><em class="calibre9">Their overconfidence will drive the redesign into the same mess as the original project.</em></p>
<h3 class="h1" id="part0011_toclev_3">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">In every case, the best option is for the development organization to recognize and avoid its own overconfidence and to start taking the quality of its software architecture seriously.</p>
<p class="noindent1">To take software architecture seriously, you need to know what good software architecture is. To build a system with a design and an architecture that minimize effort and maximize productivity, you need to know which attributes of system architecture lead to that end.</p>
<p class="noindent1">That’s what this book is about. It describes what good clean architectures and designs look like, so that software developers can build systems that will have long profitable lifetimes.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0012_ch2"><a class="calibre3" id="part0012_page_13"></a><span class="gray">2</span><br class="calibre12"/>A T<small class="calibre7">ALE OF</small> T<small class="calibre7">WO</small> V<small class="calibre7">ALUES</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00011.jpeg"/></div>
<p class="noindent1"><a id="part0012_page_14"></a>Every software system provides two different values to the stakeholders: behavior and structure. Software developers are responsible for ensuring that both those values remain high. Unfortunately, they often focus on one to the exclusion of the other. Even more unfortunately, they often focus on the lesser of the two values, leaving the software system eventually valueless.</p>
<h3 class="h1" id="part0012_toclev_4">B<small class="calibre13">EHAVIOR</small></h3>
<p class="noindent1">The first value of software is its behavior. Programmers are hired to make machines behave in a way that makes or saves money for the stakeholders. We do this by helping the stakeholders develop a functional specification, or requirements document. Then we write the code that causes the stakeholder’s machines to satisfy those requirements.</p>
<p class="noindent1">When the machine violates those requirements, programmers get their debuggers out and fix the problem.</p>
<p class="noindent1">Many programmers believe that is the entirety of their job. They believe their job is to make the machine implement the requirements and to fix any bugs. They are sadly mistaken.</p>
<h3 class="h1" id="part0012_toclev_5">A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">The second value of software has to do with the word “software”—a compound word composed of “soft” and “ware.” The word “ware” means “product”; the word “soft”… Well, that’s where the second value lies.</p>
<p class="noindent1">Software was invented to be “soft.” It was intended to be a way to easily change the behavior of machines. If we’d wanted the behavior of machines to be hard to change, we would have called it <em class="calibre9">hard</em>ware.</p>
<p class="noindent1">To fulfill its purpose, software must be soft—that is, it must be easy to change. When the stakeholders change their minds about a feature, that change should be simple and easy to make. The difficulty in making such a change should be <a id="part0012_page_15"></a>proportional only to the scope of the change, and not to the <em class="calibre9">shape</em> of the change.</p>
<p class="noindent1">It is this difference between scope and shape that often drives the growth in software development costs. It is the reason that costs grow out of proportion to the size of the requested changes. It is the reason that the first year of development is much cheaper than the second, and the second year is much cheaper than the third.</p>
<p class="noindent1">From the stakeholders’ point of view, they are simply providing a stream of changes of roughly similar scope. From the developers’ point of view, the stakeholders are giving them a stream of jigsaw puzzle pieces that they must fit into a puzzle of ever-increasing complexity. Each new request is harder to fit than the last, because the shape of the system does not match the shape of the request.</p>
<p class="noindent1">I’m using the word “shape” here in a unconventional way, but I think the metaphor is apt. Software developers often feel as if they are forced to jam square pegs into round holes.</p>
<p class="noindent1">The problem, of course, is the architecture of the system. The more this architecture prefers one shape over another, the more likely new features will be harder and harder to fit into that structure. Therefore architectures should be as shape agnostic are practical.</p>
<h3 class="h1" id="part0012_toclev_6">T<small class="calibre13">HE</small> G<small class="calibre13">REATER</small> V<small class="calibre13">ALUE</small></h3>
<p class="noindent1">Function or architecture? Which of these two provides the greater value? Is it more important for the software system to work, or is it more important for the software system to be easy to change?</p>
<p class="noindent1">If you ask the business managers, they’ll often say that it’s more important for the software system to work. Developers, in turn, often go along with this attitude. <em class="calibre9">But it’s the wrong attitude.</em> I can prove that it is wrong with the simple logical tool of examining the extremes.</p>
<p class="indenthangingb"><a id="part0012_page_16"></a>• <em class="calibre9">If you give me a program that works perfectly but is impossible to change, then it won’t work when the requirements change, and I won’t be able to make it work. Therefore the program will become useless.</em></p>
<p class="indenthangingb">• <em class="calibre9">If you give me a program that does not work but is easy to change, then I can make it work, and keep it working as requirements change. Therefore the program will remain continually useful.</em></p>
<p class="noindent1">You may not find this argument convincing. After all, there’s no such thing as a program that is impossible to change. However, there are systems that are <em class="calibre9">practically</em> impossible to change, because the cost of change exceeds the benefit of change. Many systems reach that point in some of their features or configurations.</p>
<p class="noindent1">If you ask the business managers if they want to be able to make changes, they’ll say that of course they do, but may then qualify their answer by noting that the current functionality is more important than any later flexibility. In contrast, if the business managers ask you for a change, and your estimated costs for that change are unaffordably high, the business managers will likely be furious that you allowed the system to get to the point where the change was impractical.</p>
<h3 class="h1" id="part0012_toclev_7">E<small class="calibre13">ISENHOWER’S</small> M<small class="calibre13">ATRIX</small></h3>
<p class="noindent1">Consider President Dwight D. Eisenhower’s matrix of importance versus urgency (<a href="#part0012_ch2fig1">Figure 2.1</a>). Of this matrix, Eisenhower said:</p>
<p class="blockquote"><em class="calibre9">I have two kinds of problems, the urgent and the important. The urgent are not important, and the important are never urgent.<sup class="calibre14"><a href="#part0012_ch2fn1" id="part0012_ch2fn-1">1</a></sup></em></p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00012.jpeg"/></div>
<p class="fig-caption"><a id="part0012_ch2fig1"></a><strong class="calibre8">Figure 2.1</strong> Eisenhower matrix</p>
</div>
<p class="noindent1"><a id="part0012_page_17"></a>There is a great deal of truth to this old adage. Those things that are urgent are rarely of great importance, and those things that are important are seldom of great urgency.</p>
<p class="noindent1">The first value of software—behavior—is urgent but not always particularly important.</p>
<p class="noindent1">The second value of software—architecture—is important but never particularly urgent.</p>
<p class="noindent1">Of course, some things are both urgent and important. Other things are not urgent and not important. Ultimately, we can arrange these four couplets into priorities:</p>
<p class="indenthangingn"><strong class="calibre8">1.</strong> Urgent and important</p>
<p class="indenthangingn"><strong class="calibre8">2.</strong> Not urgent and important</p>
<p class="indenthangingn"><strong class="calibre8">3.</strong> Urgent and not important</p>
<p class="indenthangingn"><strong class="calibre8">4.</strong> Not urgent and not important</p>
<p class="noindent1">Note that the architecture of the code—the important stuff—is in the top two positions of this list, whereas the behavior of the code occupies the first and <em class="calibre9">third</em> positions.</p>
<p class="noindent1">The mistake that business managers and developers often make is to elevate items in position 3 to position 1. In other words, they fail to separate those features that are urgent but not important from those features that truly are urgent and important. This failure then leads to ignoring the important architecture of the system in favor of the unimportant features of the system.</p>
<p class="noindent1">The dilemma for software developers is that business managers are not equipped to evaluate the importance of architecture. <em class="calibre9">That’s what software developers were hired to do.</em> Therefore it is the responsibility of the software development team to assert the importance of architecture over the urgency of features.</p>
<h3 class="h1" id="part0012_toclev_8"><a class="calibre3" id="part0012_page_18"></a>F<small class="calibre13">IGHT FOR THE</small> A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">Fulfilling this responsibility means wading into a fight—or perhaps a better word is “struggle.” Frankly, that’s always the way these things are done. The development team has to struggle for what they believe to be best for the company, and so do the management team, and the marketing team, and the sales team, and the operations team. <em class="calibre9">It’s always a struggle</em>.</p>
<p class="noindent1">Effective software development teams tackle that struggle head on. They unabashedly squabble with all the other stakeholders as equals. Remember, as a software developer, <em class="calibre9">you are a stakeholder</em>. You have a stake in the software that you need to safeguard. That’s part of your role, and part of your duty. And it’s a big part of why you were hired.</p>
<p class="noindent1">This challenge is doubly important if you are a software architect. Software architects are, by virtue of their job description, more focused on the structure of the system than on its features and functions. Architects create an architecture that allows those features and functions to be easily developed, easily modified, and easily extended.</p>
<p class="noindent1">Just remember: If architecture comes last, then the system will become ever more costly to develop, and eventually change will become practically impossible for part or all of the system. If that is allowed to happen, it means the software development team did not fight hard enough for what they knew was necessary.</p>
<p class="fn"><a href="#part0012_ch2fn-1" id="part0012_ch2fn1">1</a>. From a speech at Northwestern University in 1954.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0013_part2"><a class="calibre3" id="part0013_page_19"></a><span class="gray">II</span><br class="calibre12"/>S<small class="calibre7">TARTING WITH THE</small> B<small class="calibre7">RICKS</small>: P<small class="calibre7">ROGRAMMING</small> P<small class="calibre7">ARADIGMS</small></h2>
<p class="noindent1">Software architecture begins with the code—and so we will begin our discussion of architecture by looking at what we’ve learned about code since code was first written.</p>
<p class="noindent1">In 1938, Alan Turing laid the foundations of what was to become computer programming. He was not the first to conceive of a programmable machine, but he was the first to understand that programs were simply data. By 1945, Turing was writing real programs on real computers in code that we would recognize (if we squinted enough). Those programs used loops, branches, assignment, subroutines, stacks, and other familiar structures. Turing’s language was binary.</p>
<p class="noindent1">Since those days, a number of revolutions in programming have occurred. One revolution with which we are all very familiar is the revolution of languages. First, in the late 1940s, came assemblers. These “languages” relieved the programmers of the drudgery of translating their programs into binary. In 1951, Grace Hopper invented A0, the first compiler. In fact, she coined the term <em class="calibre9">compiler</em>. Fortran was invented in 1953 (the year after I was <a id="part0013_page_20"></a>born). What followed was an unceasing flood of new programming languages—COBOL, PL/1, SNOBOL, C, Pascal, C++, Java, ad infinitum.</p>
<p class="noindent1">Another, probably more significant, revolution was in programming <em class="calibre9">paradigms</em>. Paradigms are ways of programming, relatively unrelated to languages. A paradigm tells you which programming structures to use, and when to use them. To date, there have been three such paradigms. For reasons we shall discuss later, there are unlikely to be any others.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0014_ch3"><a class="calibre3" id="part0014_page_21"></a><span class="gray">3</span><br class="calibre12"/>P<small class="calibre7">ARADIGM</small> O<small class="calibre7">VERVIEW</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00013.jpeg"/></div>
<p class="noindent1">The three paradigms included in this overview chapter are structured programming, object-orient programming, and functional programming.</p>
<h3 class="h1" id="part0014_toclev_9"><a class="calibre3" id="part0014_page_22"></a>S<small class="calibre13">TRUCTURED</small> P<small class="calibre13">ROGRAMMING</small></h3>
<p class="noindent1">The first paradigm to be adopted (but not the first to be invented) was structured programming, which was discovered by Edsger Wybe Dijkstra in 1968. Dijkstra showed that the use of unrestrained jumps (<code class="calibre11">goto</code> statements) is harmful to program structure. As we’ll see in the chapters that follow, he replaced those jumps with the more familiar <code class="calibre11">if/then/else</code> and <code class="calibre11">do/while/until</code> constructs.</p>
<p class="noindent1">We can summarize the structured programming paradigm as follows:</p>
<p class="blockquote"><em class="calibre9">Structured programming imposes discipline on direct transfer of control.</em></p>
<h3 class="h1" id="part0014_toclev_10">O<small class="calibre13">BJECT</small>-O<small class="calibre13">RIENTED</small> P<small class="calibre13">ROGRAMMING</small></h3>
<p class="noindent1">The second paradigm to be adopted was actually discovered two years earlier, in 1966, by Ole Johan Dahl and Kristen Nygaard. These two programmers noticed that the function call stack frame in the <code class="calibre11">ALGOL</code> language could be moved to a heap, thereby allowing local variables declared by a function to exist long after the function returned. The function became a constructor for a class, the local variables became instance variables, and the nested functions became methods. This led inevitably to the discovery of polymorphism through the disciplined use of function pointers.</p>
<p class="noindent1">We can summarize the object-oriented programming paradigm as follows:</p>
<p class="blockquote"><em class="calibre9">Object-oriented programming imposes discipline on indirect transfer of control.</em></p>
<h3 class="h1" id="part0014_toclev_11">F<small class="calibre13">UNCTIONAL</small> P<small class="calibre13">ROGRAMMING</small></h3>
<p class="noindent1">The third paradigm, which has only recently begun to be adopted, was the first to be invented. Indeed, its invention predates computer programming <a id="part0014_page_23"></a>itself. Functional programming is the direct result of the work of Alonzo Church, who in 1936 invented l-calculus while pursuing the same mathematical problem that was motivating Alan Turing at the same time. His l-calculus is the foundation of the LISP language, invented in 1958 by John McCarthy. A foundational notion of l-calculus is immutability—that is, the notion that the values of symbols do not change. This effectively means that a functional language has no assignment statement. Most functional languages do, in fact, have some means to alter the value of a variable, but only under very strict discipline.</p>
<p class="noindent1">We can summarize the functional programming paradigm as follows:</p>
<p class="blockquote"><em class="calibre9">Functional programming imposes discipline upon assignment.</em></p>
<h3 class="h1" id="part0014_toclev_12">F<small class="calibre13">OOD FOR</small> T<small class="calibre13">HOUGHT</small></h3>
<p class="noindent1">Notice the pattern that I’ve quite deliberately set up in introducing these three programming paradigms: Each of the paradigms <em class="calibre9">removes</em> capabilities from the programmer. None of them adds new capabilities. Each imposes some kind of extra discipline that is <em class="calibre9">negative</em> in its intent. The paradigms tell us what <em class="calibre9">not</em> to do, more than they tell us what <em class="calibre9">to</em> do.</p>
<p class="noindent1">Another way to look at this issue is to recognize that each paradigm takes something away from us. The three paradigms together remove <code class="calibre11">goto</code> statements, function pointers, and assignment. Is there anything left to take away?</p>
<p class="noindent1">Probably not. Thus these three paradigms are likely to be the only three we will see—at least the only three that are negative. Further evidence that there are no more such paradigms is that they were all discovered within the ten years between 1958 and 1968. In the many decades that have followed, no new paradigms have been added.</p>
<h3 class="h1" id="part0014_toclev_13"><a class="calibre3" id="part0014_page_24"></a>C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">What does this history lesson on paradigms have to do with architecture? Everything. We use polymorphism as the mechanism to cross architectural boundaries; we use functional programming to impose discipline on the location of and access to data; and we use structured programming as the algorithmic foundation of our modules.</p>
<p class="noindent1">Notice how well those three align with the three big concerns of architecture: function, separation of components, and data management.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0015_ch4"><a class="calibre3" id="part0015_page_25"></a><span class="gray">4</span><br class="calibre12"/>S<small class="calibre7">TRUCTURED</small> P<small class="calibre7">ROGRAMMING</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00014.jpeg"/></div>
<p class="noindent1"><a id="part0015_page_26"></a>Edsger Wybe Dijkstra was born in Rotterdam in 1930. He survived the bombing of Rotterdam during World War II, along with the German occupation of the Netherlands, and in 1948 graduated from high school with the highest possible marks in math, physics, chemistry, and biology. In March 1952, at the age of 21 (and just 9 months before I was born), Dijkstra took a job with the Mathematical Center of Amsterdam as the Netherlands’ very first programmer.</p>
<p class="noindent1">In 1955, having been a programmer for three years, and while still a student, Dijkstra concluded that the intellectual challenge of programming was greater than the intellectual challenge of theoretical physics. As a result, he chose programming as his long-term career.</p>
<p class="noindent1">In 1957, Dijkstra married Maria Debets. At the time, you had to state your profession as part of the marriage rites in the Netherlands. The Dutch authorities were unwilling to accept “programmer” as Dijkstra’s profession; they had never heard of such a profession. To satisfy them, Dijkstra settled for “theoretical physicist” as his job title.</p>
<p class="noindent1">As part of deciding to make programming his career, Dijkstra conferred with his boss, Adriaan van Wijngaarden. Dijkstra was concerned that no one had identified a discipline, or science, of programming, and that he would therefore not be taken seriously. His boss replied that Dijkstra might very well be one of the people who would discover such disciplines, thereby evolving software into a science.</p>
<p class="noindent1">Dijkstra started his career in the era of vacuum tubes, when computers were huge, fragile, slow, unreliable, and (by today’s standards) extremely limited. In those early years, programs were written in binary, or in very crude assembly language. Input took the physical form of paper tape or punched cards. The edit/compile/test loop was hours—if not days—long.</p>
<p class="noindent1">It was in this primitive environment that Dijkstra made his great discoveries.</p>
<h3 class="h1" id="part0015_toclev_14"><a class="calibre3" id="part0015_page_27"></a>P<small class="calibre13">ROOF</small></h3>
<p class="noindent1">The problem that Dijkstra recognized, early on, was that programming is <em class="calibre9">hard</em>, and that programmers don’t do it very well. A program of any complexity contains too many details for a human brain to manage without help. Overlooking just one small detail results in programs that may <em class="calibre9">seem</em> to work, but fail in surprising ways.</p>
<p class="noindent1">Dijkstra’s solution was to apply the mathematical discipline of <em class="calibre9">proof</em>. His vision was the construction of a Euclidian hierarchy of postulates, theorems, corollaries, and lemmas. Dijkstra thought that programmers could use that hierarchy the way mathematicians do. In other words, programmers would use proven structures, and tie them together with code that they would then prove correct themselves.</p>
<p class="noindent1">Of course, to get this going, Dijkstra realized that he would have to demonstrate the technique for writing basic proofs of simple algorithms. This he found to be quite challenging.</p>
<p class="noindent1">During his investigation, Dijkstra discovered that certain uses of <code class="calibre11">goto</code> statements prevent modules from being decomposed recursively into smaller and smaller units, thereby preventing use of the divide-and-conquer approach necessary for reasonable proofs.</p>
<p class="noindent1">Other uses of <code class="calibre11">goto</code>, however, did not have this problem. Dijkstra realized that these “good” uses of <code class="calibre11">goto</code> corresponded to simple selection and iteration control structures such as <code class="calibre11">if/then/else</code> and <code class="calibre11">do/while</code>. Modules that used only those kinds of control structures <em class="calibre9">could</em> be recursively subdivided into provable units.</p>
<p class="noindent1">Dijkstra knew that those control structures, when combined with sequential execution, were special. They had been identified two years before by Böhm and Jacopini, who proved that all programs can be constructed from just three structures: sequence, selection, and iteration.</p>
<p class="noindent1"><a id="part0015_page_28"></a>This discovery was remarkable: The very control structures that made a module provable were the same minimum set of control structures from which all programs can be built. Thus structured programming was born.</p>
<p class="noindent1">Dijkstra showed that sequential statements could be proved correct through simple enumeration. The technique mathematically traced the inputs of the sequence to the outputs of the sequence. This approach was no different from any normal mathematical proof.</p>
<p class="noindent1">Dijkstra tackled selection through reapplication of enumeration. Each path through the selection was enumerated. If both paths eventually produced appropriate mathematical results, then the proof was solid.</p>
<p class="noindent1">Iteration was a bit different. To prove an iteration correct, Dijkstra had to use <em class="calibre9">induction</em>. He proved the case for 1 by enumeration. Then he proved the case that if <em class="calibre9">N</em> was assumed correct, <em class="calibre9">N</em> + 1 was correct, again by enumeration. He also proved the starting and ending criteria of the iteration by enumeration.</p>
<p class="noindent1">Such proofs were laborious and complex—but they were proofs. With their development, the idea that a Euclidean hierarchy of theorems could be constructed seemed reachable.</p>
<h3 class="h1" id="part0015_toclev_15">A H<small class="calibre13">ARMFUL</small> P<small class="calibre13">ROCLAMATION</small></h3>
<p class="noindent1">In 1968, Dijkstra wrote a letter to the editor of <em class="calibre9">CACM</em>, which was published in the March issue. The title of this letter was “Go To Statement Considered Harmful.” The article outlined his position on the three control structures.</p>
<p class="noindent1"><em class="calibre9">And the programming world caught fire</em>. Back then we didn’t have an Internet, so people couldn’t post nasty memes of Dijkstra, and they couldn’t flame him online. But they could, and they did, write letters to the editors of many published journals.</p>
<p class="noindent1"><a id="part0015_page_29"></a>Those letters weren’t necessarily all polite. Some were intensely negative; others voiced strong support for his position. And so the battle was joined, ultimately to last about a decade.</p>
<p class="noindent1">Eventually the argument petered out. The reason was simple: Dijkstra had won. As computer languages evolved, the <code class="calibre11">goto</code> statement moved ever rearward, until it all but disappeared. Most modern languages do not have a <code class="calibre11">goto</code> statement—and, of course, LISP <em class="calibre9">never</em> did.</p>
<p class="noindent1">Nowadays we are all structured programmers, though not necessarily by choice. It’s just that our languages don’t give us the option to use undisciplined direct transfer of control.</p>
<p class="noindent1">Some may point to named <code class="calibre11">break</code>s in Java or exceptions as <code class="calibre11">goto</code> analogs. In fact, these structures are not the utterly unrestricted transfers of control that older languages like Fortran or COBOL once had. Indeed, even languages that still support the <code class="calibre11">goto</code> keyword often restrict the target to within the scope of the current function.</p>
<h3 class="h1" id="part0015_toclev_16">F<small class="calibre13">UNCTIONAL</small> D<small class="calibre13">ECOMPOSITION</small></h3>
<p class="noindent1">Structured programming allows modules to be recursively decomposed into provable units, which in turn means that modules can be functionally decomposed. That is, you can take a large-scale problem statement and decompose it into high-level functions. Each of those functions can then be decomposed into lower-level functions, ad infinitum. Moreover, each of those decomposed functions can be represented using the restricted control structures of structured programming.</p>
<p class="noindent1">Building on this foundation, disciplines such as structured analysis and structured design became popular in the late 1970s and throughout the 1980s. Men like Ed Yourdon, Larry Constantine, Tom DeMarco, and Meilir Page-Jones promoted and popularized these techniques throughout that period. By following these disciplines, programmers could break down large proposed systems into modules and components that could be further broken down into tiny provable functions.</p>
<h3 class="h1" id="part0015_toclev_17"><a class="calibre3" id="part0015_page_30"></a>N<small class="calibre13">O</small> F<small class="calibre13">ORMAL</small> P<small class="calibre13">ROOFS</small></h3>
<p class="noindent1">But the proofs never came. The Euclidean hierarchy of theorems was never built. And programmers at large never saw the benefits of working through the laborious process of formally proving each and every little function correct. In the end, Dijkstra’s dream faded and died. Few of today’s programmers believe that formal proofs are an appropriate way to produce high-quality software.</p>
<p class="noindent1">Of course, formal, Euclidian style, mathematical proofs are not the only strategy for proving something correct. Another highly successful strategy is the <em class="calibre9">scientific method</em>.</p>
<h3 class="h1" id="part0015_toclev_18">S<small class="calibre13">CIENCE TO THE</small> R<small class="calibre13">ESCUE</small></h3>
<p class="noindent1">Science is fundamentally different from mathematics, in that scientific theories and laws cannot be proven correct. I cannot prove to you that Newton’s second law of motion, <em class="calibre9">F</em> = <em class="calibre9">ma</em>, or law of gravity, <em class="calibre9">F</em> = <em class="calibre9">Gm</em><sub class="calibre15">1</sub><em class="calibre9">m</em><sub class="calibre15">2</sub>/<em class="calibre9">r</em><sup class="calibre10">2,</sup> are correct. I can demonstrate these laws to you, and I can make measurements that show them correct to many decimal places, but I cannot prove them in the sense of a mathematical proof. No matter how many experiments I conduct or how much empirical evidence I gather, there is always the chance that some experiment will show that those laws of motion and gravity are incorrect.</p>
<p class="noindent1">That is the nature of scientific theories and laws: They are <em class="calibre9">falsifiable</em> but not provable.</p>
<p class="noindent1">And yet we bet our lives on these laws every day. Every time you get into a car, you bet your life that <em class="calibre9">F</em> = <em class="calibre9">ma</em> is a reliable description of the way the world works. Every time you take a step, you bet your health and safety that <em class="calibre9">F</em> = <em class="calibre9">Gm</em><sub class="calibre15">1</sub><em class="calibre9">m</em><sub class="calibre15">2</sub>/<em class="calibre9">r</em><sup class="calibre10">2</sup> is correct.</p>
<p class="noindent1">Science does not work by proving statements true, but rather by <em class="calibre9">proving statements false</em>. Those statements that we cannot prove false, after much effort, we deem to be true enough for our purposes.</p>
<p class="noindent1"><a id="part0015_page_31"></a>Of course, not all statements are provable. The statement “This is a lie” is neither true nor false. It is one of the simplest examples of a statement that is not provable.</p>
<p class="noindent1">Ultimately, we can say that mathematics is the discipline of proving provable statements true. Science, in contrast, is the discipline of proving provable statements false.</p>
<h3 class="h1" id="part0015_toclev_19">T<small class="calibre13">ESTS</small></h3>
<p class="noindent1">Dijkstra once said, “Testing shows the presence, not the absence, of bugs.” In other words, a program can be proven incorrect by a test, but it cannot be proven correct. All that tests can do, after sufficient testing effort, is allow us to deem a program to be correct enough for our purposes.</p>
<p class="noindent1">The implications of this fact are stunning. Software development is not a mathematical endeavor, even though it seems to manipulate mathematical constructs. Rather, software is like a science. We show correctness by failing to prove incorrectness, despite our best efforts.</p>
<p class="noindent1">Such proofs of incorrectness can be applied only to <em class="calibre9">provable</em> programs. A program that is not provable—due to unrestrained use of <code class="calibre11">goto</code>, for example—cannot be deemed correct no matter how many tests are applied to it.</p>
<p class="noindent1">Structured programming forces us to recursively decompose a program into a set of small provable functions. We can then use tests to try to prove those small provable functions incorrect. If such tests fail to prove incorrectness, then we deem the functions to be correct enough for our purposes.</p>
<h3 class="h1" id="part0015_toclev_20">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">It is this ability to create falsifiable units of programming that makes structured programming valuable today. This is the reason that modern languages do not typically support unrestrained <code class="calibre11">goto</code> statements. Moreover, <a id="part0015_page_32"></a>at the architectural level, this is why we still consider <em class="calibre9">functional decomposition</em> to be one of our best practices.</p>
<p class="noindent1">At every level, from the smallest function to the largest component, software is like a science and, therefore, is driven by falsifiability. Software architects strive to define modules, components, and services that are easily falsifiable (testable). To do so, they employ restrictive disciplines similar to structured programming, albeit at a much higher level.</p>
<p class="noindent1">It is those restrictive disciplines that we will study in some detail in the chapters to come.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0016_ch5"><a class="calibre3" id="part0016_page_33"></a><span class="gray">5</span><br class="calibre12"/>O<small class="calibre7">BJECT-ORIENTED</small> P<small class="calibre7">ROGRAMMING</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00015.jpeg"/></div>
<p class="noindent1"><a id="part0016_page_34"></a>As we will see, the basis of a good architecture is the understanding and application of the principles of object-oriented design (OO). But just what is OO?</p>
<p class="noindent1">One answer to this question is “The combination of data and function.” Although often cited, this is a very unsatisfying answer because it implies that <code class="calibre11">o.f()</code> is somehow different from <code class="calibre11">f(o)</code>. This is absurd. Programmers were passing data structures into functions long before 1966, when Dahl and Nygaard moved the function call stack frame to the heap and invented OO.</p>
<p class="noindent1">Another common answer to this question is “A way to model the real world.” This is an evasive answer at best. What does “modeling the real world” actually mean, and why is it something we would want to do? Perhaps this statement is intended to imply that OO makes software easier to understand because it has a closer relationship to the real world—but even that statement is evasive and too loosely defined. It does not tell us what OO is.</p>
<p class="noindent1">Some folks fall back on three magic words to explain the nature of OO: <em class="calibre9">encapsulation</em>, <em class="calibre9">inheritance</em>, and <em class="calibre9">polymorphism</em>. The implication is that OO is the proper admixture of these three things, or at least that an OO language must support these three things.</p>
<p class="noindent1">Let’s examine each of these concepts in turn.</p>
<h3 class="h1" id="part0016_toclev_21">E<small class="calibre13">NCAPSULATION</small>?</h3>
<p class="noindent1">The reason encapsulation is cited as part of the definition of OO is that OO languages provide easy and effective encapsulation of data and function. As a result, a line can be drawn around a cohesive set of data and functions. Outside of that line, the data is hidden and only some of the functions are known. We see this concept in action as the private data members and the public member functions of a class.</p>
<p class="noindent1">This idea is certainly not unique to OO. Indeed, we had perfect encapsulation in C. Consider this simple C program:</p>
<p class="codelink"><a id="part0016_page_35"></a><a href="#part0054_split_001_pch5ex01a" id="part0016_pch5ex01">Click here to view code image</a></p>
<p class="pre-ex">point.h</p>
<p class="pre">struct Point;<br class="calibre6"/>
struct Point* makePoint(double x, double y);<br class="calibre6"/>
double distance (struct Point *p1, struct Point *p2);</p>
<p class="codelink"><a href="#part0054_split_002_pch5ex02a" id="part0016_pch5ex02">Click here to view code image</a></p>
<p class="pre-ex1">point.c</p>
<p class="pre1">#include "point.h"<br class="calibre6"/>
#include &lt;stdlib.h&gt;<br class="calibre6"/>
#include &lt;math.h&gt;<br class="calibre6"/>
 <br class="calibre6"/>
struct Point {<br class="calibre6"/>
  double x,y;<br class="calibre6"/>
};<br class="calibre6"/>
 <br class="calibre6"/>
struct Point* makepoint(double x, double y) {<br class="calibre6"/>
  struct Point* p = malloc(sizeof(struct Point));<br class="calibre6"/>
  p-&gt;x = x;<br class="calibre6"/>
  p-&gt;y = y;<br class="calibre6"/>
  return p;<br class="calibre6"/>
}<br class="calibre6"/>
 <br class="calibre6"/>
double distance(struct Point* p1, struct Point* p2) {<br class="calibre6"/>
  double dx = p1-&gt;x - p2-&gt;x;<br class="calibre6"/>
  double dy = p1-&gt;y - p2-&gt;y;<br class="calibre6"/>
  return sqrt(dx*dx+dy*dy);<br class="calibre6"/>
}</p>
<p class="noindent1">The users of <code class="calibre11">point.h</code> have no access whatsoever to the members of <code class="calibre11">struct Point</code>. They can call the <code class="calibre11">makePoint()</code> function, and the <code class="calibre11">distance()</code> function, but they have absolutely no knowledge of the implementation of either the <code class="calibre11">Point</code> data structure or the functions.</p>
<p class="noindent1">This is perfect encapsulation—in a non-OO language. C programmers used to do this kind of thing all the time. We would forward declare data structures and functions in header files, and then implement them in <a id="part0016_page_36"></a>implementation files. Our users never had access to the elements in those implementation files.</p>
<p class="noindent1">But then came OO in the form of C++—and the perfect encapsulation of C was broken.</p>
<p class="noindent1">The C++ compiler, for technical reasons,<sup class="calibre10"><a href="#part0016_ch5fn1" id="part0016_ch5fn-1">1</a></sup> needed the member variables of a class to be declared in the header file of that class. So our <code class="calibre11">Point</code> program changed to look like this:</p>
<p class="codelink"><a href="#part0054_split_003_pch5ex03a" id="part0016_pch5ex03">Click here to view code image</a></p>
<p class="pre-ex">point.h</p>
<p class="pre">class Point {<br class="calibre6"/>
public:<br class="calibre6"/>
  Point(double x, double y);<br class="calibre6"/>
  double distance(const Point&amp; p) const;<br class="calibre6"/>
 <br class="calibre6"/>
private:<br class="calibre6"/>
  double x;<br class="calibre6"/>
  double y;<br class="calibre6"/>
};</p>
<p class="codelink"><a href="#part0054_split_004_pch5ex04a" id="part0016_pch5ex04">Click here to view code image</a></p>
<p class="pre-ex1">point.cc</p>
<p class="pre1">#include "point.h"<br class="calibre6"/>
#include &lt;math.h&gt;<br class="calibre6"/>
 <br class="calibre6"/>
Point::Point(double x, double y)<br class="calibre6"/>
: x(x), y(y)<br class="calibre6"/>
{}<br class="calibre6"/>
<br class="calibre6"/>
double Point::distance(const Point&amp; p) const {<br class="calibre6"/>
  double dx = x-p.x;<br class="calibre6"/>
  double dy = y-p.y;<br class="calibre6"/>
  return sqrt(dx*dx + dy*dy);<br class="calibre6"/>
}</p>
<p class="noindent1"><a id="part0016_page_37"></a>Clients of the header file <code class="calibre11">point.h</code> know about the member variables <code class="calibre11">x</code> and <code class="calibre11">y</code>! The compiler will prevent access to them, but the client still knows they exist. For example, if those member names are changed, the <code class="calibre11">point.cc</code> file must be recompiled! Encapsulation has been broken.</p>
<p class="noindent1">Indeed, the way encapsulation is partially repaired is by introducing the <code class="calibre11">public</code>, <code class="calibre11">private</code>, and <code class="calibre11">protected</code> keywords into the language. This, however, was a <em class="calibre9">hack</em> necessitated by the technical need for the compiler to see those variables in the header file.</p>
<p class="noindent1">Java and C# simply abolished the header/implementation split altogether, thereby weakening encapsulation even more. In these languages, it is impossible to separate the declaration and definition of a class.</p>
<p class="noindent1">For these reasons, it is difficult to accept that OO depends on strong encapsulation. Indeed, many OO languages<sup class="calibre10"><a href="#part0016_ch5fn2" id="part0016_ch5fn-2">2</a></sup> have little or no enforced encapsulation.</p>
<p class="noindent1">OO certainly does depend on the idea that programmers are well-behaved enough to not circumvent encapsulated data. Even so, the languages that claim to provide OO have only weakened the once perfect encapsulation we enjoyed with C.</p>
<h3 class="h1" id="part0016_toclev_22">I<small class="calibre13">NHERITANCE</small>?</h3>
<p class="noindent1">If OO languages did not give us better encapsulation, then they certainly gave us inheritance.</p>
<p class="noindent1">Well—sort of. Inheritance is simply the redeclaration of a group of variables and functions within an enclosing scope. This is something C programmers<sup class="calibre10"><a href="#part0016_ch5fn3" id="part0016_ch5fn-3">3</a></sup> were able to do manually long before there was an OO language.</p>
<p class="noindent1"><a id="part0016_page_38"></a>Consider this addition to our original <code class="calibre11">point.h</code> <code class="calibre11">C</code> program:</p>
<p class="codelink"><a href="#part0054_split_005_pch5ex05a" id="part0016_pch5ex05">Click here to view code image</a></p>
<p class="pre-ex">namedPoint.h</p>
<p class="pre">struct NamedPoint;<br class="calibre6"/>
 <br class="calibre6"/>
struct NamedPoint* makeNamedPoint(double x, double y, char* name);<br class="calibre6"/>
void setName(struct NamedPoint* np, char* name);<br class="calibre6"/>
char* getName(struct NamedPoint* np);</p>
<p class="codelink"><a href="#part0054_split_006_pch5ex06a" id="part0016_pch5ex06">Click here to view code image</a></p>
<p class="pre-ex">namedPoint.c</p>
<p class="pre">#include "namedPoint.h"<br class="calibre6"/>
#include &lt;stdlib.h&gt;<br class="calibre6"/>
 <br class="calibre6"/>
struct NamedPoint {<br class="calibre6"/>
  double x,y;<br class="calibre6"/>
  char* name;<br class="calibre6"/>
};<br class="calibre6"/>
 <br class="calibre6"/>
struct NamedPoint* makeNamedPoint(double x, double y, char* name) {<br class="calibre6"/>
  struct NamedPoint* p = malloc(sizeof(struct NamedPoint));<br class="calibre6"/>
  p-&gt;x = x;<br class="calibre6"/>
  p-&gt;y = y;<br class="calibre6"/>
  p-&gt;name = name;<br class="calibre6"/>
  return p;<br class="calibre6"/>
}<br class="calibre6"/>
 <br class="calibre6"/>
void setName(struct NamedPoint* np, char* name) {<br class="calibre6"/>
  np-&gt;name = name;<br class="calibre6"/>
}<br class="calibre6"/>
 <br class="calibre6"/>
char* getName(struct NamedPoint* np) {<br class="calibre6"/>
  return np-&gt;name;<br class="calibre6"/>
}</p>
<p class="codelink"><a id="part0016_page_39"></a><a href="#part0054_split_007_pch5ex07a" id="part0016_pch5ex07">Click here to view code image</a></p>
<p class="pre-ex1">main.c</p>
<p class="pre1">#include "point.h"<br class="calibre6"/>
#include "namedPoint.h"<br class="calibre6"/>
#include &lt;stdio.h&gt;<br class="calibre6"/>
 <br class="calibre6"/>
int main(int ac, char** av) {<br class="calibre6"/>
  struct NamedPoint* origin = makeNamedPoint(0.0, 0.0, "origin");<br class="calibre6"/>
  struct NamedPoint* upperRight = makeNamedPoint  (1.0, 1.0, "upperRight");<br class="calibre6"/>
  printf("distance=%f\n",<br class="calibre6"/>
    distance(<br class="calibre6"/>
             (struct Point*) origin, <br class="calibre6"/>
             (struct Point*) upperRight));<br class="calibre6"/>
}</p>
<p class="noindent1">If you look carefully at the <code class="calibre11">main</code> program, you’ll see that the <code class="calibre11">NamedPoint</code> data structure acts as though it is a derivative of the <code class="calibre11">Point</code> data structure. This is because the order of the first two fields in <code class="calibre11">NamedPoint</code> is the same as <code class="calibre11">Point</code>. In short, <code class="calibre11">NamedPoint</code> can masquerade as <code class="calibre11">Point</code> because <code class="calibre11">NamedPoint</code> is a pure superset of <code class="calibre11">Point</code> and maintains the ordering of the members that correspond to <code class="calibre11">Point</code>.</p>
<p class="noindent1">This kind of trickery was a common practice<sup class="calibre10"><a href="#part0016_ch5fn4" id="part0016_ch5fn-4">4</a></sup> of programmers prior to the advent of OO. In fact, such trickery is how C++ implements single inheritance.</p>
<p class="noindent1">Thus we might say that we had a kind of inheritance long before OO languages were invented. That statement wouldn’t quite be true, though. We had a trick, but it’s not nearly as convenient as true inheritance. Moreover, multiple inheritance is a considerably more difficult to achieve by such trickery.</p>
<p class="noindent1"><a id="part0016_page_40"></a>Note also that in <code class="calibre11">main.c</code>, I was forced to cast the <code class="calibre11">NamedPoint</code> arguments to <code class="calibre11">Point</code>. In a real OO language, such upcasting would be implicit.</p>
<p class="noindent1">It’s fair to say that while OO languages did not give us something completely brand new, it did make the masquerading of data structures significantly more convenient.</p>
<p class="noindent1">To recap: We can award no point to OO for encapsulation, and perhaps a half-point for inheritance. So far, that’s not such a great score.</p>
<p class="noindent1">But there’s one more attribute to consider.</p>
<h3 class="h1" id="part0016_toclev_23">P<small class="calibre13">OLYMORPHISM</small>?</h3>
<p class="noindent1">Did we have polymorphic behavior before OO languages? Of course we did. Consider this simple C <code class="calibre11">copy</code> program.</p>
<p class="codelink"><a href="#part0054_split_008_pch5ex08a" id="part0016_pch5ex08">Click here to view code image</a></p>
<p class="pre2">#include &lt;stdio.h&gt;<br class="calibre6"/>
<br class="calibre6"/>
void copy() {<br class="calibre6"/>
  int c;<br class="calibre6"/>
  while ((c=getchar()) != EOF)<br class="calibre6"/>
    putchar(c);<br class="calibre6"/>
}</p>
<p class="noindent1">The function <code class="calibre11">getchar()</code> reads from <code class="calibre11">STDIN</code>. But which device is <code class="calibre11">STDIN</code>? The <code class="calibre11">putchar()</code> function writes to <code class="calibre11">STDOUT</code>. But which device is that? These functions are <em class="calibre9">polymorphic</em>—their behavior depends on the type of <code class="calibre11">STDIN</code> and <code class="calibre11">STDOUT</code>.</p>
<p class="noindent1">It’s as though <code class="calibre11">STDIN</code> and <code class="calibre11">STDOUT</code> are Java-style interfaces that have implementations for each device. Of course, there are no interfaces in the example C program—so how does the call to <code class="calibre11">getchar()</code> actually get delivered to the device driver that reads the character?</p>
<p class="noindent1"><a id="part0016_page_41"></a>The answer to that question is pretty straightforward. The UNIX operating system requires that every IO device driver provide five standard functions:<sup class="calibre10"><a href="#part0016_ch5fn5" id="part0016_ch5fn-5">5</a></sup> <code class="calibre11">open</code>, <code class="calibre11">close</code>, <code class="calibre11">read</code>, <code class="calibre11">write</code>, and <code class="calibre11">seek</code>. The signatures of those functions must be identical for every IO driver.</p>
<p class="noindent1">The <code class="calibre11">FILE</code> data structure contains five pointers to functions. In our example, it might look like this:</p>
<p class="codelink"><a href="#part0054_split_009_pch5ex09a" id="part0016_pch5ex09">Click here to view code image</a></p>
<p class="pre2">struct FILE {<br class="calibre6"/>
  void (*open)(char* name, int mode);<br class="calibre6"/>
  void (*close)();<br class="calibre6"/>
  int (*read)();<br class="calibre6"/>
  void (*write)(char);<br class="calibre6"/>
  void (*seek)(long index, int mode);<br class="calibre6"/>
};</p>
<p class="noindent1">The IO driver for the console will define those functions and load up a <code class="calibre11">FILE</code> data structure with their addresses—something like this:</p>
<p class="codelink"><a href="#part0054_split_010_pch5ex010a" id="part0016_pch5ex010">Click here to view code image</a></p>
<p class="pre2">#include "file.h"<br class="calibre6"/>
 <br class="calibre6"/>
void open(char* name, int mode) {/*...*/}<br class="calibre6"/>
void close() {/*...*/};<br class="calibre6"/>
int read() {int c;/*...*/ return c;}<br class="calibre6"/>
void write(char c) {/*...*/}<br class="calibre6"/>
void seek(long index, int mode) {/*...*/}<br class="calibre6"/>
 <br class="calibre6"/>
struct FILE console = {open, close, read, write, seek};</p>
<p class="noindent1">Now if <code class="calibre11">STDIN</code> is defined as a <code class="calibre11">FILE*</code>, and if it points to the console data structure, then <code class="calibre11">getchar()</code> might be implemented this way:</p>
<p class="codelink"><a id="part0016_page_42"></a><a href="#part0054_split_011_pch5ex011a" id="part0016_pch5ex011">Click here to view code image</a></p>
<p class="pre2">extern struct FILE* STDIN;<br class="calibre6"/>
 <br class="calibre6"/>
int getchar() {<br class="calibre6"/>
  return STDIN-&gt;read();<br class="calibre6"/>
}</p>
<p class="noindent1">In other words, <code class="calibre11">getchar()</code> simply calls the function pointed to by the <code class="calibre11">read</code> pointer of the <code class="calibre11">FILE</code> data structure pointed to by <code class="calibre11">STDIN</code>.</p>
<p class="noindent1">This simple trick is the basis for all polymorphism in OO. In C++, for example, every virtual function within a class has a pointer in a table called a <code class="calibre11">vtable</code>, and all calls to virtual functions go through that table. Constructors of derivatives simply load their versions of those functions into the <code class="calibre11">vtable</code> of the object being created.</p>
<p class="noindent1">The bottom line is that polymorphism is an application of pointers to functions. Programmers have been using pointers to functions to achieve polymorphic behavior since Von Neumann architectures were first implemented in the late 1940s. In other words, OO has provided nothing new.</p>
<p class="noindent1">Ah, but that’s not quite correct. OO languages may not have given us polymorphism, but they have made it much safer and much more convenient.</p>
<p class="noindent1">The problem with explicitly using pointers to functions to create polymorphic behavior is that pointers to functions are <em class="calibre9">dangerous</em>. Such use is driven by a set of manual conventions. You have to remember to follow the convention to initialize those pointers. You have to remember to follow the convention to call all your functions through those pointers. If any programmer fails to remember these conventions, the resulting bug can be devilishly hard to track down and eliminate.</p>
<p class="noindent1">OO languages eliminate these conventions and, therefore, these dangers. Using an OO language makes polymorphism trivial. That fact provides an enormous power that old C programmers could only dream of. On this <a id="part0016_page_43"></a>basis, we can conclude that OO imposes discipline on indirect transfer of control.</p>
<h4 class="h2">T<small class="calibre13">HE</small> P<small class="calibre13">OWER OF</small> P<small class="calibre13">OLYMORPHISM</small></h4>
<p class="noindent1">What’s so great about polymorphism? To better appreciate its charms, let’s reconsider the example <code class="calibre11">copy</code> program. What happens to that program if a new IO device is created? Suppose we want to use the <code class="calibre11">copy</code> program to copy data from a handwriting recognition device to a speech synthesizer device: How do we need to change the <code class="calibre11">copy</code> program to get it to work with those new devices?</p>
<p class="noindent1">We don’t need any changes at all! Indeed, we don’t even need to recompile the <code class="calibre11">copy</code> program. Why? Because the source code of the <code class="calibre11">copy</code> program does not depend on the source code of the IO drivers. As long as those IO drivers implement the five standard functions defined by <code class="calibre11">FILE</code>, the <code class="calibre11">copy</code> program will be happy to use them.</p>
<p class="noindent1">In short, the IO devices have become plugins to the <code class="calibre11">copy</code> program.</p>
<p class="noindent1">Why did the UNIX operating system make IO devices plugins? Because we learned, in the late 1950s, that our programs should be <em class="calibre9">device independent</em>. Why? Because we wrote lots of programs that were device <em class="calibre9">dependent</em>, only to discover that we really wanted those programs to do the same job but use a different device.</p>
<p class="noindent1">For example, we often wrote programs that read input data from decks of cards,<sup class="calibre10"><a href="#part0016_ch5fn6" id="part0016_ch5fn-6">6</a></sup> and then punched new decks of cards as output. Later, our customers stopped giving us decks of cards and started giving us reels of magnetic tape. This was very inconvenient, because it meant rewriting large portions of the original program. It would be very convenient if the same program worked interchangeably with cards or tape.</p>
<p class="noindent1"><a id="part0016_page_44"></a>The plugin architecture was invented to support this kind of IO device independence, and has been implemented in almost every operating system since its introduction. Even so, most programmers did not extend the idea to their own programs, because using pointers to functions was dangerous.</p>
<p class="noindent1">OO allows the plugin architecture to be used anywhere, for anything.</p>
<h4 class="h2">D<small class="calibre13">EPENDENCY</small> I<small class="calibre13">NVERSION</small></h4>
<p class="noindent1">Imagine what software was like before a safe and convenient mechanism for polymorphism was available. In the typical calling tree, main functions called high-level functions, which called mid-level functions, which called low-level functions. In that calling tree, however, source code dependencies inexorably followed the flow of control (<a href="#part0016_ch5fig1">Figure 5.1</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00016.jpeg"/></div>
<p class="fig-caption"><a id="part0016_ch5fig1"></a><strong class="calibre8">Figure 5.1</strong> Source code dependencies versus flow of control</p>
</div>
<p class="noindent1">For <code class="calibre11">main</code> to call one of the high-level functions, it had to mention the name of the module that contained that function In C, this was a <code class="calibre11">#include</code>. In Java, it was an <code class="calibre11">import</code> statement. In C#, it was a <code class="calibre11">using</code> statement. Indeed, every caller was forced to mention the name of the module that contained the callee.</p>
<p class="noindent1"><a id="part0016_page_45"></a>This requirement presented the software architect with few, if any, options. The flow of control was dictated by the behavior of the system, and the source code dependencies were dictated by that flow of control.</p>
<p class="noindent1">When polymorphism is brought into play, however, something very different can happen (<a href="#part0016_ch5fig2">Figure 5.2</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00017.jpeg"/></div>
<p class="fig-caption"><a id="part0016_ch5fig2"></a><strong class="calibre8">Figure 5.2</strong> Dependency inversion</p>
</div>
<p class="noindent1">In <a href="#part0016_ch5fig2">Figure 5.2</a>, module <code class="calibre11">HL1</code> calls the <code class="calibre11">F()</code> function in module <code class="calibre11">ML1</code>. The fact that it calls this function through an interface is a source code contrivance. At runtime, the interface doesn’t exist. <code class="calibre11">HL1</code> simply calls <code class="calibre11">F()</code> within <code class="calibre11">ML1</code>.<sup class="calibre10"><a href="#part0016_ch5fn7" id="part0016_ch5fn-7">7</a></sup></p>
<p class="noindent1">Note, however, that the source code dependency (the inheritance relationship) between <code class="calibre11">ML1</code> and the interface <code class="calibre11">I</code> points in the opposite direction compared to the flow of control. This is called <em class="calibre9">dependency inversion</em>, and its implications for the software architect are profound.</p>
<p class="noindent1">The fact that OO languages provide safe and convenient polymorphism means that <em class="calibre9">any source code dependency, no matter where it is, can be inverted</em>.</p>
<p class="noindent1">Now look back at that calling tree in <a href="#part0016_ch5fig1">Figure 5.1</a>, and its many source code dependencies. Any of those source code dependencies can be turned around by inserting an interface between them.</p>
<p class="noindent1"><a id="part0016_page_46"></a>With this approach, software architects working in systems written in OO languages have <em class="calibre9">absolute control</em> over the direction of all source code dependencies in the system. They are not constrained to align those dependencies with the flow of control. No matter which module does the calling and which module is called, the software architect can point the source code dependency in either direction.</p>
<p class="noindent1">That is power! That is the power that OO provides. That’s what OO is really all about—at least from the architect’s point of view.</p>
<p class="noindent1">What can you do with that power? As an example, you can rearrange the source code dependencies of your system so that the database and the user interface (UI) depend on the business rules (<a href="#part0016_ch5fig3">Figure 5.3</a>), rather than the other way around.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00018.jpeg"/></div>
<p class="fig-caption"><a id="part0016_ch5fig3"></a><strong class="calibre8">Figure 5.3</strong> The database and the user interface depend on the business rules</p>
</div>
<p class="noindent1">This means that the UI and the database can be plugins to the business rules. It means that the source code of the business rules never mentions the UI or the database.</p>
<p class="noindent1">As a consequence, the business rules, the UI, and the database can be compiled into three separate components or deployment units (e.g., jar files, DLLs, or Gem files) that have the same dependencies as the source code. The component containing the business rules will not depend on the components containing the UI and database.</p>
<p class="noindent1">In turn, the business rules can be <em class="calibre9">deployed independently</em> of the UI and the database. Changes to the UI or the database need not have any effect on the business rules. Those components can be deployed separately and independently.</p>
<p class="noindent1"><a id="part0016_page_47"></a>In short, when the source code in a component changes, only that component needs to be redeployed. This is <em class="calibre9">independent deployability</em>.</p>
<p class="noindent1">If the modules in your system can be deployed independently, then they can be developed independently by different teams. That’s <em class="calibre9">independent developability</em>.</p>
<h3 class="h1" id="part0016_toclev_24">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">What is OO? There are many opinions and many answers to this question. To the software architect, however, the answer is clear: OO is the ability, through the use of polymorphism, to gain absolute control over every source code dependency in the system. It allows the architect to create a plugin architecture, in which modules that contain high-level policies are independent of modules that contain low-level details. The low-level details are relegated to plugin modules that can be deployed and developed independently from the modules that contain high-level policies.</p>
<p class="fn"><a id="part0016_page_48"></a><a href="#part0016_ch5fn-1" id="part0016_ch5fn1">1</a>. The C++ compiler needs to know the size of the instances of each class.</p>
<p class="fn"><a href="#part0016_ch5fn-2" id="part0016_ch5fn2">2</a>. For example, Smalltalk, Python, JavaScript, Lua, and Ruby.</p>
<p class="fn"><a href="#part0016_ch5fn-3" id="part0016_ch5fn3">3</a>. Not just C programmers: Most languages of that era had the capability to masquerade one data structure as another.</p>
<p class="fn"><a href="#part0016_ch5fn-4" id="part0016_ch5fn4">4</a>. Indeed it still is.</p>
<p class="fn"><a href="#part0016_ch5fn-5" id="part0016_ch5fn5">5</a>. UNIX systems vary; this is just an example.</p>
<p class="fn"><a href="#part0016_ch5fn-6" id="part0016_ch5fn6">6</a>. Punched cards—IBM Hollerith cards, 80 columns wide. I’m sure many of you have never even seen one of these, but they were commonplace in the 1950s, 1960s, and even 1970s.</p>
<p class="fn"><a href="#part0016_ch5fn-7" id="part0016_ch5fn7">7</a>. Albeit indirectly.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0017_ch6"><a class="calibre3" id="part0017_page_49"></a><span class="gray">6</span><br class="calibre12"/>F<small class="calibre7">UNCTIONAL</small> P<small class="calibre7">ROGRAMMING</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00019.jpeg"/></div>
<p class="noindent1"><a id="part0017_page_50"></a>In many ways, the concepts of functional programming predate programming itself. This paradigm is strongly based on the l-calculus invented by Alonzo Church in the 1930s.</p>
<h3 class="h1" id="part0017_toclev_25">S<small class="calibre13">QUARES OF</small> I<small class="calibre13">NTEGERS</small></h3>
<p class="noindent1">To explain what functional programming is, it’s best to examine some examples. Let’s investigate a simple problem: printing the squares of the first 25 integers.</p>
<p class="noindent1">In a language like Java, we might write the following:</p>
<p class="codelink"><a href="#part0055_split_001_pch6ex01a" id="part0017_pch6ex01">Click here to view code image</a></p>
<p class="pre2">public class Squint {<br class="calibre6"/>
  public static void main(String args[]) {<br class="calibre6"/>
    for (int i=0; i&lt;25; i++)<br class="calibre6"/>
      System.out.println(i*i);<br class="calibre6"/>
  }<br class="calibre6"/>
}</p>
<p class="noindent1">In a language like Clojure, which is a derivative of Lisp, and is functional, we might implement this same program as follows:</p>
<p class="codelink"><a href="#part0055_split_002_pch6ex02a" id="part0017_pch6ex02">Click here to view code image</a></p>
<p class="pre2">(println (take 25 (map (fn [x] (* x x)) (range))))</p>
<p class="noindent1">If you don’t know Lisp, then this might look a little strange. So let me reformat it a bit and add some comments.</p>
<p class="codelink"><a href="#part0055_split_003_pch6ex03a" id="part0017_pch6ex03">Click here to view code image</a></p>
<p class="pre2">(println ;___________________ Print<br class="calibre6"/>
  (take 25 ;_________________ the first 25<br class="calibre6"/>
    (map (fn [x] (* x x)) ;__ squares<br class="calibre6"/>
      (range)))) ;___________ of Integers</p>
<p class="noindent1">It should be clear that <code class="calibre11">println</code>, <code class="calibre11">take</code>, <code class="calibre11">map</code>, and <code class="calibre11">range</code> are all functions. In Lisp, you call a function by putting it in parentheses. For example, <code class="calibre11">(range)</code> calls the range function.</p>
<p class="noindent1"><a id="part0017_page_51"></a>The expression <code class="calibre11">(fn [x] (* x x))</code> is an anonymous function that calls the multiply function, passing its input argument in twice. In other words, it computes the square of its input.</p>
<p class="noindent1">Looking at the whole thing again, it’s best to start with the innermost function call.</p>
<p class="indenthangingb">• The <code class="calibre11">range</code> function returns a never-ending list of integers starting with 0.</p>
<p class="indenthangingb">• This list is passed into the <code class="calibre11">map</code> function, which calls the anonymous squaring function on each element, producing a new never-ending list of all the squares.</p>
<p class="indenthangingb">• The list of squares is passed into the <code class="calibre11">take</code> function, which returns a new list with only the first 25 elements.</p>
<p class="indenthangingb">• The <code class="calibre11">println</code> function prints its input, which is a list of the first 25 squares of integers.</p>
<p class="noindent1">If you find yourself terrified by the concept of never-ending lists, don’t worry. Only the first 25 elements of those never-ending lists are actually created. That’s because no element of a never-ending list is evaluated until it is accessed.</p>
<p class="noindent1">If you found all of that confusing, then you can look forward to a glorious time learning all about Clojure and functional programming. It is not my goal to teach you about these topics here.</p>
<p class="noindent1">Instead, my goal here is to point out something very dramatic about the difference between the Clojure and Java programs. The Java program uses a <em class="calibre9">mutable variable</em>—a variable that changes state during the execution of the program. That variable is <code class="calibre11">i</code>—the loop control variable. No such mutable variable exists in the Clojure program. In the Clojure program, variables like <code class="calibre11">x</code> are initialized, but they are never modified.</p>
<p class="noindent1">This leads us to a surprising statement: Variables in functional languages <em class="calibre9">do not vary</em>.</p>
<h3 class="h1" id="part0017_toclev_26"><a class="calibre3" id="part0017_page_52"></a>I<small class="calibre13">MMUTABILITY AND</small> A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">Why is this point important as an architectural consideration? Why would an architect be concerned with the mutability of variables? The answer is absurdly simple: All race conditions, deadlock conditions, and concurrent update problems are due to mutable variables. You cannot have a race condition or a concurrent update problem if no variable is ever updated. You cannot have deadlocks without mutable locks.</p>
<p class="noindent1">In other words, all the problems that we face in concurrent applications—all the problems we face in applications that require multiple threads, and multiple processors—cannot happen if there are no mutable variables.</p>
<p class="noindent1">As an architect, you should be very interested in issues of concurrency. You want to make sure that the systems you design will be robust in the presence of multiple threads and processors. The question you must be asking yourself, then, is whether immutability is practicable.</p>
<p class="noindent1">The answer to that question is affirmative, if you have infinite storage and infinite processor speed. Lacking those infinite resources, the answer is a bit more nuanced. Yes, immutability can be practicable, if certain compromises are made.</p>
<p class="noindent1">Let’s look at some of those compromises.</p>
<h3 class="h1" id="part0017_toclev_27">S<small class="calibre13">EGREGATION OF</small> M<small class="calibre13">UTABILITY</small></h3>
<p class="noindent1">One of the most common compromises in regard to immutability is to segregate the application, or the services within the application, into mutable and immutable components. The immutable components perform their tasks in a purely functional way, without using any mutable variables. The immutable components communicate with one or more other components that are not purely functional, and allow for the state of variables to be mutated (<a href="#part0017_ch6fig1">Figure 6.1</a>).</p>
<div class="fig-heading">
<div class="image1"><a id="part0017_page_53"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00020.jpeg"/></div>
<p class="fig-caption"><a id="part0017_ch6fig1"></a><strong class="calibre8">Figure 6.1</strong> Mutating state and transactional memory</p>
</div>
<p class="noindent1">Since mutating state exposes those components to all the problems of concurrency, it is common practice to use some kind of <em class="calibre9">transactional memory</em> to protect the mutable variables from concurrent updates and race conditions.</p>
<p class="noindent1">Transactional memory simply treats variables in memory the same way a database treats records on disk.<sup class="calibre10"><a href="#part0017_ch6fn1" id="part0017_ch6fn-1">1</a></sup> It protects those variables with a transaction- or retry-based scheme.</p>
<p class="noindent1">A simple example of this approach is Clojure’s <code class="calibre11">atom</code> facility:</p>
<p class="codelink"><a href="#part0055_split_004_pch6ex04a" id="part0017_pch6ex04">Click here to view code image</a></p>
<p class="pre2">(def counter (atom 0)) ; initialize counter to 0<br class="calibre6"/>
(swap! counter inc)    ; safely increment counter.</p>
<p class="noindent1">In this code, the <code class="calibre11">counter</code> variable is defined as an <code class="calibre11">atom</code>. In Clojure, an <code class="calibre11">atom</code> is a special kind of variable whose value is allowed to mutate under very disciplined conditions that are enforced by the <code class="calibre11">swap!</code> function.</p>
<p class="noindent1">The <code class="calibre11">swap!</code> function, shown in the preceding code, takes two arguments: the <code class="calibre11">atom</code> to be mutated, and a function that computes the new value to be stored <a id="part0017_page_54"></a>in the <code class="calibre11">atom</code>. In our example code, the <code class="calibre11">counter</code> <code class="calibre11">atom</code> will be changed to the value computed by the <code class="calibre11">inc</code> function, which simply increments its argument.</p>
<p class="noindent1">The strategy used by <code class="calibre11">swap!</code> is a traditional <em class="calibre9">compare and swap</em> algorithm. The value of <code class="calibre11">counter</code> is read and passed to <code class="calibre11">inc</code>. When <code class="calibre11">inc</code> returns, the value of <code class="calibre11">counter</code> is locked and compared to the value that was passed to <code class="calibre11">inc</code>. If the value is the same, then the value returned by <code class="calibre11">inc</code> is stored in <code class="calibre11">counter</code> and the lock is released. Otherwise, the lock is released, and the strategy is retried from the beginning.</p>
<p class="noindent1">The <code class="calibre11">atom</code> facility is adequate for simple applications. Unfortunately, it cannot completely safeguard against concurrent updates and deadlocks when multiple dependent variables come into play. In those instances, more elaborate facilities can be used.</p>
<p class="noindent1">The point is that well-structured applications will be segregated into those components that do not mutate variables and those that do. This kind of segregation is supported by the use of appropriate disciplines to protect those mutated variables.</p>
<p class="noindent1">Architects would be wise to push as much processing as possible into the immutable components, and to drive as much code as possible out of those components that must allow mutation.</p>
<h3 class="h1" id="part0017_toclev_28">E<small class="calibre13">VENT</small> S<small class="calibre13">OURCING</small></h3>
<p class="noindent1">The limits of storage and processing power have been rapidly receding from view. Nowadays it is common for processors to execute billions of instructions per second and to have billions of bytes of RAM. The more memory we have, and the faster our machines are, the less we need mutable state.</p>
<p class="noindent1">As a simple example, imagine a banking application that maintains the account balances of its customers. It mutates those balances when deposit and withdrawal transactions are executed.</p>
<p class="noindent1"><a id="part0017_page_55"></a>Now imagine that instead of storing the account balances, we store only the transactions. Whenever anyone wants to know the balance of an account, we simply add up all the transactions for that account, from the beginning of time. This scheme requires no mutable variables.</p>
<p class="noindent1">Obviously, this approach sounds absurd. Over time, the number of transactions would grow without bound, and the processing power required to compute the totals would become intolerable. To make this scheme work forever, we would need infinite storage and infinite processing power.</p>
<p class="noindent1">But perhaps we don’t have to make the scheme work forever. And perhaps we have enough storage and enough processing power to make the scheme work for the reasonable lifetime of the application.</p>
<p class="noindent1">This is the idea behind <em class="calibre9">event sourcing</em>.<sup class="calibre10"><a href="#part0017_ch6fn2" id="part0017_ch6fn-2">2</a></sup> Event sourcing is a strategy wherein we store the transactions, but not the state. When state is required, we simply apply all the transactions from the beginning of time.</p>
<p class="noindent1">Of course, we can take shortcuts. For example, we can compute and save the state every midnight. Then, when the state information is required, we need compute only the transactions since midnight.</p>
<p class="noindent1">Now consider the data storage required for this scheme: We would need a lot of it. Realistically, offline data storage has been growing so fast that we now consider trillions of bytes to be small—so we have a lot of it.</p>
<p class="noindent1">More importantly, nothing ever gets deleted or updated from such a data store. As a consequence, our applications are not CRUD; they are just CR. Also, because neither updates nor deletions occur in the data store, there cannot be any concurrent update issues.</p>
<p class="noindent1">If we have enough storage and enough processor power, we can make our applications entirely immutable—and, therefore, <em class="calibre9">entirely functional</em>.</p>
<p class="noindent1">If this still sounds absurd, it might help if you remembered that this is precisely the way your source code control system works.</p>
<h3 class="h1" id="part0017_toclev_29"><a class="calibre3" id="part0017_page_56"></a>C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">To summarize:</p>
<p class="indenthangingb">• Structured programming is discipline imposed upon direct transfer of control.</p>
<p class="indenthangingb">• Object-oriented programming is discipline imposed upon indirect transfer of control.</p>
<p class="indenthangingb">• Functional programming is discipline imposed upon variable assignment.</p>
<p class="noindent1">Each of these three paradigms has taken something away from us. Each restricts some aspect of the way we write code. None of them has added to our power or our capabilities.</p>
<p class="noindent1">What we have learned over the last half-century is <em class="calibre9">what not to do</em>.</p>
<p class="noindent1">With that realization, we have to face an unwelcome fact: Software is not a rapidly advancing technology. The rules of software are the same today as they were in 1946, when Alan Turing wrote the very first code that would execute in an electronic computer. The tools have changed, and the hardware has changed, but the essence of software remains the same.</p>
<p class="noindent1">Software—the stuff of computer programs—is composed of sequence, selection, iteration, and indirection. Nothing more. Nothing less.</p>
<p class="fn"><a href="#part0017_ch6fn-1" id="part0017_ch6fn1">1</a>. I know... What’s a disk?</p>
<p class="fn"><a href="#part0017_ch6fn-2" id="part0017_ch6fn2">2</a>. Thanks to Greg Young for teaching me about this concept.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0018_part3"><a class="calibre3" id="part0018_page_57"></a><span class="gray">III</span><br class="calibre12"/>D<small class="calibre7">ESIGN</small> P<small class="calibre7">RINCIPLES</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00021.jpeg"/></div>
<p class="noindent1">Good software systems begin with clean code. On the one hand, if the bricks aren’t well made, the architecture of the building doesn’t matter much. On the other hand, you can make a substantial mess with well-made bricks. This is where the SOLID principles come in.</p>
<p class="noindent1"><a id="part0018_page_58"></a>The SOLID principles tell us how to arrange our functions and data structures into classes, and how those classes should be interconnected. The use of the word “class” does not imply that these principles are applicable only to object-oriented software. A class is simply a coupled grouping of functions and data. Every software system has such groupings, whether they are called classes or not. The SOLID principles apply to those groupings.</p>
<p class="noindent1">The goal of the principles is the creation of mid-level software structures that:</p>
<p class="indenthangingb">• Tolerate change,</p>
<p class="indenthangingb">• Are easy to understand, and</p>
<p class="indenthangingb">• Are the basis of components that can be used in many software systems.</p>
<p class="noindent1">The term “mid-level” refers to the fact that these principles are applied by programmers working at the module level. They are applied just above the level of the code and help to define the kinds of software structures used within modules and components.</p>
<p class="noindent1">Just as it is possible to create a substantial mess with well-made bricks, so it is also possible to create a system-wide mess with well-designed mid-level components. For this reason, once we have covered the SOLID principles, we will move on to their counterparts in the component world, and then to the principles of high-level architecture.</p>
<p class="noindent1">The history of the SOLID principles is long. I began to assemble them in the late 1980s while debating software design principles with others on USENET (an early kind of Facebook). Over the years, the principles have shifted and changed. Some were deleted. Others were merged. Still others were added. The final grouping stabilized in the early 2000s, although I presented them in a different order.</p>
<p class="noindent1">In 2004 or thereabouts, Michael Feathers sent me an email saying that if I rearranged the principles, their first words would spell the word SOLID—and thus the SOLID principles were born.</p>
<p class="noindent1"><a id="part0018_page_59"></a>The chapters that follow describe each principle more thoroughly. Here is the executive summary:</p>
<p class="indenthangingb">• <strong class="calibre8">SRP:</strong> The Single Responsibility Principle</p>
<p class="indenthangingbp">An active corollary to Conway’s law: The best structure for a software system is heavily influenced by the social structure of the organization that uses it so that each software module has one, and only one, reason to change.</p>
<p class="indenthangingb">• <strong class="calibre8">OCP:</strong> The Open-Closed Principle</p>
<p class="indenthangingbp">Bertrand Meyer made this principle famous in the 1980s. The gist is that for software systems to be easy to change, they must be designed to allow the behavior of those systems to be changed by adding new code, rather than changing existing code.</p>
<p class="indenthangingb">• <strong class="calibre8">LSP:</strong> The Liskov Substitution Principle</p>
<p class="indenthangingbp">Barbara Liskov’s famous definition of subtypes, from 1988. In short, this principle says that to build software systems from interchangeable parts, those parts must adhere to a contract that allows those parts to be substituted one for another.</p>
<p class="indenthangingb">• <strong class="calibre8">ISP:</strong> The Interface Segregation Principle</p>
<p class="indenthangingbp">This principle advises software designers to avoid depending on things that they don’t use.</p>
<p class="indenthangingb">• <strong class="calibre8">DIP:</strong> The Dependency Inversion Principle</p>
<p class="indenthangingbp">The code that implements high-level policy should not depend on the code that implements low-level details. Rather, details should depend on policies.</p>
<p class="noindent1">These principles have been described in detail in many different publications<sup class="calibre10"><a href="#part0018_part3fn1" id="part0018_part3fn-1">1</a></sup> over the years. The chapters that follow will focus on the architectural implications of these principles instead of repeating those detailed discussions. If you are not already familiar with these principles, what follows is insufficient to understand them in detail and you would be well advised to study them in the footnoted documents.<a id="part0018_page_60"></a></p>
<p class="fn"><a href="#part0018_part3fn-1" id="part0018_part3fn1">1</a>. For example, <em class="calibre9">Agile Software Development, Principles</em>, Patterns, and Practices, Robert C. Martin, Prentice Hall, 2002, <a href="http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</a>, and <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)</a> (or just google SOLID).</p>
</body><body class="calibre">
<h2 class="h2f" id="part0019_ch7"><a class="calibre3" id="part0019_page_61"></a><span class="gray">7</span><br class="calibre12"/>SRP: T<small class="calibre7">HE</small> S<small class="calibre7">INGLE</small> R<small class="calibre7">ESPONSIBILITY</small> P<small class="calibre7">RINCIPLE</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00022.jpeg"/></div>
<p class="noindent1"><a id="part0019_page_62"></a>Of all the SOLID principles, the Single Responsibility Principle (SRP) might be the least well understood. That’s likely because it has a particularly inappropriate name. It is too easy for programmers to hear the name and then assume that it means that every module should do just one thing.</p>
<p class="noindent1">Make no mistake, there <em class="calibre9">is</em> a principle like that. A <em class="calibre9">function</em> should do one, and only one, thing. We use that principle when we are refactoring large functions into smaller functions; we use it at the lowest levels. But it is not one of the SOLID principles—it is not the SRP.</p>
<p class="noindent1">Historically, the SRP has been described this way:</p>
<p class="blockquote"><em class="calibre9">A module should have one, and only one, reason to change.</em></p>
<p class="noindent1">Software systems are changed to satisfy users and stakeholders; those users and stakeholders <em class="calibre9">are</em> the “reason to change” that the principle is talking about. Indeed, we can rephrase the principle to say this:</p>
<p class="blockquote"><em class="calibre9">A module should be responsible to one, and only one, user or stakeholder.</em></p>
<p class="noindent1">Unfortunately, the words “user” and “stakeholder” aren’t really the right words to use here. There will likely be more than one user or stakeholder who wants the system changed in the same way. Instead, we’re really referring to a group—one or more people who require that change. We’ll refer to that group as an <em class="calibre9">actor</em>.</p>
<p class="noindent1">Thus the final version of the SRP is:</p>
<p class="blockquote"><em class="calibre9">A module should be responsible to one, and only one, actor.</em></p>
<p class="noindent1">Now, what do we mean by the word “module”? The simplest definition is just a source file. Most of the time that definition works fine. Some languages and development environments, though, don’t use source files to contain their code. In those cases a module is just a cohesive set of functions and data structures.</p>
<p class="noindent1"><a id="part0019_page_63"></a>That word “cohesive” implies the SRP. Cohesion is the force that binds together the code responsible to a single actor.</p>
<p class="noindent1">Perhaps the best way to understand this principle is by looking at the symptoms of violating it.</p>
<h3 class="h1" id="part0019_toclev_30">S<small class="calibre13">YMPTOM</small> 1: A<small class="calibre13">CCIDENTAL</small> D<small class="calibre13">UPLICATION</small></h3>
<p class="noindent1">My favorite example is the <code class="calibre11">Employee</code> class from a payroll application. It has three methods: <code class="calibre11">calculatePay()</code>, <code class="calibre11">reportHours()</code>, and <code class="calibre11">save()</code> (<a href="#part0019_ch7fig1">Figure 7.1</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00023.jpeg"/></div>
<p class="fig-caption"><a id="part0019_ch7fig1"></a><strong class="calibre8">Figure 7.1</strong> The <code class="calibre11">Employee</code> class</p>
</div>
<p class="noindent1">This class violates the SRP because those three methods are responsible to three very different actors.</p>
<p class="indenthangingb">• The <code class="calibre11">calculatePay()</code> method is specified by the accounting department, which reports to the CFO.</p>
<p class="indenthangingb">• The <code class="calibre11">reportHours()</code> method is specified and used by the human resources department, which reports to the COO.</p>
<p class="indenthangingb">• The <code class="calibre11">save()</code> method is specified by the database administrators (DBAs), who report to the CTO.</p>
<p class="noindent1">By putting the source code for these three methods into a single <code class="calibre11">Employee</code> class, the developers have coupled each of these actors to the others. This <a id="part0019_page_64"></a>coupling can cause the actions of the CFO’s team to affect something that the COO’s team depends on.</p>
<p class="noindent1">For example, suppose that the <code class="calibre11">calculatePay()</code> function and the <code class="calibre11">reportHours()</code> function share a common algorithm for calculating non-overtime hours. Suppose also that the developers, who are careful not to duplicate code, put that algorithm into a function named <code class="calibre11">regularHours()</code> (<a href="#part0019_ch7fig2">Figure 7.2</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00024.jpeg"/></div>
<p class="fig-caption"><a id="part0019_ch7fig2"></a><strong class="calibre8">Figure 7.2</strong> Shared algorithm</p>
</div>
<p class="noindent1">Now suppose that the CFO’s team decides that the way non-overtime hours are calculated needs to be tweaked. In contrast, the COO’s team in HR does not want that particular tweak because they use non-overtime hours for a different purpose.</p>
<p class="noindent1">A developer is tasked to make the change, and sees the convenient <code class="calibre11">regularHours()</code> function called by the <code class="calibre11">calculatePay()</code> method. Unfortunately, that developer does not notice that the function is also called by the <code class="calibre11">reportHours()</code> function.</p>
<p class="noindent1">The developer makes the required change and carefully tests it. The CFO’s team validates that the new function works as desired, and the system is deployed.</p>
<p class="noindent1">Of course, the COO’s team doesn’t know that this is happening. The HR personnel continue to use the reports generated by the <code class="calibre11">reportHours()</code> function—but now they contain incorrect numbers. Eventually the problem is discovered, and the COO is livid because the bad data has cost his budget millions of dollars.</p>
<p class="noindent1"><a id="part0019_page_65"></a>We’ve all seen things like this happen. These problems occur because we put code that different actors depend on into close proximity. The SRP says to <em class="calibre9">separate the code that different actors depend on</em>.</p>
<h3 class="h1" id="part0019_toclev_31">S<small class="calibre13">YMPTOM</small> 2: M<small class="calibre13">ERGES</small></h3>
<p class="noindent1">It’s not hard to imagine that merges will be common in source files that contain many different methods. This situation is especially likely if those methods are responsible to different actors.</p>
<p class="noindent1">For example, suppose that the CTO’s team of DBAs decides that there should be a simple schema change to the <code class="calibre11">Employee</code> table of the database. Suppose also that the COO’s team of HR clerks decides that they need a change in the format of the hours report.</p>
<p class="noindent1">Two different developers, possibly from two different teams, check out the <code class="calibre11">Employee</code> class and begin to make changes. Unfortunately their changes collide. The result is a merge.</p>
<p class="noindent1">I probably don’t need to tell you that merges are risky affairs. Our tools are pretty good nowadays, but no tool can deal with every merge case. In the end, there is always risk.</p>
<p class="noindent1">In our example, the merge puts both the CTO and the COO at risk. It’s not inconceivable that the CFO could be affected as well.</p>
<p class="noindent1">There are many other symptoms that we could investigate, but they all involve multiple people changing the same source file for different reasons.</p>
<p class="noindent1">Once again, the way to avoid this problem is to <em class="calibre9">separate code that supports different actors</em>.</p>
<h3 class="h1" id="part0019_toclev_32"><a class="calibre3" id="part0019_page_66"></a>S<small class="calibre13">OLUTIONS</small></h3>
<p class="noindent1">There are many different solutions to this problem. Each moves the functions into different classes.</p>
<p class="noindent1">Perhaps the most obvious way to solve the problem is to separate the data from the functions. The three classes share access to <code class="calibre11">EmployeeData</code>, which is a simple data structure with no methods (<a href="#part0019_ch7fig3">Figure 7.3</a>). Each class holds only the source code necessary for its particular function. The three classes are not allowed to know about each other. Thus any accidental duplication is avoided.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00025.jpeg"/>
<p class="fig-caption"><a id="part0019_ch7fig3"></a><strong class="calibre8">Figure 7.3</strong> The three classes do not know about each other</p>
</div>
</div>
<p class="noindent1">The downside of this solution is that the developers now have three classes that they have to instantiate and track. A common solution to this dilemma is to use the <em class="calibre9">Facade</em> pattern (<a href="#part0019_ch7fig4">Figure 7.4</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00026.jpeg"/>
<p class="fig-caption"><a id="part0019_ch7fig4"></a><strong class="calibre8">Figure 7.4</strong> The <code class="calibre11">Facade</code> pattern</p>
</div>
</div>
<p class="noindent1">The <code class="calibre11">EmployeeFacade</code> contains very little code. It is responsible for instantiating and delegating to the classes with the functions.</p>
<p class="noindent1"><a id="part0019_page_67"></a>Some developers prefer to keep the most important business rules closer to the data. This can be done by keeping the most important method in the original <code class="calibre11">Employee</code> class and then using that class as a <em class="calibre9">Facade</em> for the lesser functions (<a href="#part0019_ch7fig5">Figure 7.5</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00027.jpeg"/>
<p class="fig-caption"><a id="part0019_ch7fig5"></a><strong class="calibre8">Figure 7.5</strong> The most important method is kept in the original <code class="calibre11">Employee</code> class and used as a <em class="calibre9">Facade</em> for the lesser functions</p>
</div>
</div>
<p class="noindent1">You might object to these solutions on the basis that every class would contain just one function. This is hardly the case. The number of functions required to calculate pay, generate a report, or save the data is likely to be large in each case. Each of those classes would have many <em class="calibre9">private</em> methods in them.</p>
<p class="noindent1">Each of the classes that contain such a family of methods is a scope. Outside of that scope, no one knows that the private members of the family exist.</p>
<h3 class="h1" id="part0019_toclev_33">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The Single Responsibility Principle is about functions and classes—but it reappears in a different form at two more levels. At the level of components, it becomes the Common Closure Principle. At the architectural level, it becomes the Axis of Change responsible for the creation of Architectural Boundaries. We’ll be studying all of these ideas in the chapters to come.<a id="part0019_page_68"></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0020_ch8"><a class="calibre3" id="part0020_page_69"></a><span class="gray">8</span><br class="calibre12"/>OCP: T<small class="calibre7">HE</small> O<small class="calibre7">PEN</small>-C<small class="calibre7">LOSED</small> P<small class="calibre7">RINCIPLE</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00028.jpeg"/></div>
<p class="noindent1"><a id="part0020_page_70"></a>The Open-Closed Principle (OCP) was coined in 1988 by Bertrand Meyer.<sup class="calibre10"><a href="#part0020_ch8fn1" id="part0020_ch8fn-1">1</a></sup> It says:</p>
<p class="blockquote"><em class="calibre9">A software artifact should be open for extension but closed for modification.</em></p>
<p class="noindent1">In other words, the behavior of a software artifact ought to be extendible, without having to modify that artifact.</p>
<p class="noindent1">This, of course, is the most fundamental reason that we study software architecture. Clearly, if simple extensions to the requirements force massive changes to the software, then the architects of that software system have engaged in a spectacular failure.</p>
<p class="noindent1">Most students of software design recognize the OCP as a principle that guides them in the design of classes and modules. But the principle takes on even greater significance when we consider the level of architectural components.</p>
<p class="noindent1">A thought experiment will make this clear.</p>
<h3 class="h1" id="part0020_toclev_35">A T<small class="calibre13">HOUGHT</small> E<small class="calibre13">XPERIMENT</small></h3>
<p class="noindent1">Imagine, for a moment, that we have a system that displays a financial summary on a web page. The data on the page is scrollable, and negative numbers are rendered in red.</p>
<p class="noindent1">Now imagine that the stakeholders ask that this same information be turned into a report to be printed on a black-and-white printer. The report should be properly paginated, with appropriate page headers, page footers, and column labels. Negative numbers should be surrounded by parentheses.</p>
<p class="noindent1">Clearly, some new code must be written. But how much old code will have to change?</p>
<p class="noindent1"><a id="part0020_page_71"></a>A good software architecture would reduce the amount of changed code to the barest minimum. Ideally, zero.</p>
<p class="noindent1">How? By properly separating the things that change for different reasons (the Single Responsibility Principle), and then organizing the dependencies between those things properly (the Dependency Inversion Principle).</p>
<p class="noindent1">By applying the SRP, we might come up with the data-flow view shown in <a href="#part0020_ch8fig1">Figure 8.1</a>. Some analysis procedure inspects the financial data and produces reportable data, which is then formatted appropriately by the two reporter processes.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00029.jpeg"/></div>
<p class="fig-caption"><a id="part0020_ch8fig1"></a><strong class="calibre8">Figure 8.1</strong> Applying the SRP</p>
</div>
<p class="noindent1">The essential insight here is that generating the report involves two separate responsibilities: the calculation of the reported data, and the presentation of that data into a web- and printer-friendly form.</p>
<p class="noindent1">Having made this separation, we need to organize the source code dependencies to ensure that changes to one of those responsibilities do not cause changes in the other. Also, the new organization should ensure that the behavior can be extended without undo modification.</p>
<p class="noindent1">We accomplish this by partitioning the processes into classes, and separating those classes into components, as shown by the double lines in the diagram in <a href="#part0020_ch8fig2">Figure 8.2</a>. In this figure, the component at the upper left is the <em class="calibre9">Controller</em>. At the upper right, we have the <em class="calibre9">Interactor</em>. At the lower right, there is the <em class="calibre9">Database</em>. Finally, at the lower left, there are four components that represent the <em class="calibre9">Presenters</em> and the <em class="calibre9">Views</em>.</p>
<div class="fig-heading">
<div class="image1"><a id="part0020_page_72"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00030.jpeg"/></div>
<p class="fig-caption"><a id="part0020_ch8fig2"></a><strong class="calibre8">Figure 8.2</strong> Partitioning the processes into classes and separating the classes into components</p>
</div>
<p class="noindent1">Classes marked with <code class="calibre11">&lt;I&gt;</code> are interfaces; those marked with <code class="calibre11">&lt;DS&gt;</code> are data structures. Open arrowheads are <em class="calibre9">using</em> relationships. Closed arrowheads are <em class="calibre9">implements</em> or <em class="calibre9">inheritance</em> relationships.</p>
<p class="noindent1">The first thing to notice is that all the dependencies are <em class="calibre9">source code</em> dependencies. An arrow pointing from class A to class B means that the source code of class A mentions the name of class B, but class B mentions nothing about class A. Thus, in <a href="#part0020_ch8fig2">Figure 8.2</a>, <code class="calibre11">FinancialDataMapper</code> knows about <code class="calibre11">FinancialDataGateway</code> through an <em class="calibre9">implements</em> relationship, but <code class="calibre11">FinancialGateway</code> knows nothing at all about <code class="calibre11">FinancialDataMapper</code>.</p>
<p class="noindent1">The next thing to notice is that each double line is crossed <em class="calibre9">in one direction only</em>. This means that all component relationships are unidirectional, as <a id="part0020_page_73"></a>shown in the component graph in <a href="#part0020_ch8fig3">Figure 8.3</a>. These arrows point toward the components that we want to protect from change.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00031.jpeg"/></div>
<p class="fig-caption"><a id="part0020_ch8fig3"></a><strong class="calibre8">Figure 8.3</strong> The component relationships are unidirectional</p>
</div>
<p class="noindent1">Let me say that again: If component A should be protected from changes in component B, then component B should depend on component A.</p>
<p class="noindent1">We want to protect the <em class="calibre9">Controller</em> from changes in the <em class="calibre9">Presenters</em>. We want to protect the <em class="calibre9">Presenters</em> from changes in the <em class="calibre9">Views</em>. We want to protect the <em class="calibre9">Interactor</em> from changes in—well, <em class="calibre9">anything</em>.</p>
<p class="noindent1">The <em class="calibre9">Interactor</em> is in the position that best conforms to the OCP. Changes to the <em class="calibre9">Database</em>, or the <em class="calibre9">Controller</em>, or the <em class="calibre9">Presenters</em>, or the <em class="calibre9">Views</em>, will have no impact on the <em class="calibre9">Interactor</em>.</p>
<p class="noindent1">Why should the <em class="calibre9">Interactor</em> hold such a privileged position? Because it contains the business rules. The <em class="calibre9">Interactor</em> contains the highest-level policies <a id="part0020_page_74"></a>of the application. All the other components are dealing with peripheral concerns. The <em class="calibre9">Interactor</em> deals with the central concern.</p>
<p class="noindent1">Even though the <em class="calibre9">Controller</em> is peripheral to the <em class="calibre9">Interactor</em>, it is nevertheless central to the <em class="calibre9">Presenters</em> and <em class="calibre9">Views</em>. And while the <em class="calibre9">Presenters</em> might be peripheral to the <em class="calibre9">Controller</em>, they are central to the <em class="calibre9">Views</em>.</p>
<p class="noindent1">Notice how this creates a hierarchy of protection based on the notion of “level.” <em class="calibre9">Interactors</em> are the highest-level concept, so they are the most protected. <em class="calibre9">Views</em> are among the lowest-level concepts, so they are the least protected. <em class="calibre9">Presenters</em> are higher level than <em class="calibre9">Views</em>, but lower level than the <em class="calibre9">Controller</em> or the <em class="calibre9">Interactor</em>.</p>
<p class="noindent1">This is how the OCP works at the architectural level. Architects separate functionality based on how, why, and when it changes, and then organize that separated functionality into a hierarchy of components. Higher-level components in that hierarchy are protected from the changes made to lower-level components.</p>
<h3 class="h1" id="part0020_toclev_36">D<small class="calibre13">IRECTIONAL</small> C<small class="calibre13">ONTROL</small></h3>
<p class="noindent1">If you recoiled in horror from the class design shown earlier, look again. Much of the complexity in that diagram was intended to make sure that the dependencies between the components pointed in the correct direction.</p>
<p class="noindent1">For example, the <code class="calibre11">FinancialDataGateway</code> interface between the <code class="calibre11">FinancialReportGenerator</code> and the <code class="calibre11">FinancialDataMapper</code> exists to invert the dependency that would otherwise have pointed from the <em class="calibre9">Interactor</em> component to the <em class="calibre9">Database</em> component. The same is true of the <code class="calibre11">FinancialReportPresenter</code> interface, and the two <em class="calibre9">View</em> interfaces.</p>
<h3 class="h1" id="part0020_toclev_37">I<small class="calibre13">NFORMATION</small> H<small class="calibre13">IDING</small></h3>
<p class="noindent1">The <code class="calibre11">FinancialReportRequester</code> interface serves a different purpose. It is there to protect the <code class="calibre11">FinancialReportController</code> from knowing too much <a id="part0020_page_75"></a>about the internals of the <em class="calibre9">Interactor</em>. If that interface were not there, then the <em class="calibre9">Controller</em> would have transitive dependencies on the <code class="calibre11">FinancialEntities</code>.</p>
<p class="noindent1">Transitive dependencies are a violation of the general principle that software entities should not depend on things they don’t directly use. We’ll encounter that principle again when we talk about the Interface Segregation Principle and the Common Reuse Principle.</p>
<p class="noindent1">So, even though our first priority is to protect the <em class="calibre9">Interactor</em> from changes to the <em class="calibre9">Controller</em>, we also want to protect the <em class="calibre9">Controller</em> from changes to the <em class="calibre9">Interactor</em> by hiding the internals of the <em class="calibre9">Interactor</em>.</p>
<h3 class="h1" id="part0020_toclev_38">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The OCP is one of the driving forces behind the architecture of systems. The goal is to make the system easy to extend without incurring a high impact of change. This goal is accomplished by partitioning the system into components, and arranging those components into a dependency hierarchy that protects higher-level components from changes in lower-level components.<a id="part0020_page_76"></a></p>
<p class="fn"><a href="#part0020_ch8fn-1" id="part0020_ch8fn1">1</a>. Bertrand Meyer. <em class="calibre9">Object Oriented Software Construction</em>, Prentice Hall, 1988, p. 23.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0021_ch9"><a class="calibre3" id="part0021_page_77"></a><span class="gray">9</span><br class="calibre12"/>LSP: T<small class="calibre7">HE</small> L<small class="calibre7">ISKOV</small> S<small class="calibre7">UBSTITUTION</small> P<small class="calibre7">RINCIPLE</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00032.jpeg"/></div>
<p class="noindent1"><a id="part0021_page_78"></a>In 1988, Barbara Liskov wrote the following as a way of defining subtypes.</p>
<p class="blockquote"><em class="calibre9">What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T</em>.<sup class="calibre14"><a href="#part0021_ch9fn1" id="part0021_ch9fn-1">1</a></sup></p>
<p class="noindent1">To understand this idea, which is known as the Liskov Substitution Principle (LSP), let’s look at some examples.</p>
<h3 class="h1" id="part0021_toclev_39">G<small class="calibre13">UIDING THE</small> U<small class="calibre13">SE OF</small> I<small class="calibre13">NHERITANCE</small></h3>
<p class="noindent1">Imagine that we have a class named <code class="calibre11">License</code>, as shown in <a href="#part0021_ch9fig1">Figure 9.1</a>. This class has a method named <code class="calibre11">calcFee()</code>, which is called by the <code class="calibre11">Billing</code> application. There are two “subtypes” of <code class="calibre11">License</code>: <code class="calibre11">PersonalLicense</code> and <code class="calibre11">BusinessLicense</code>. They use different algorithms to calculate the license fee.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00033.jpeg"/></div>
<p class="fig-caption"><a id="part0021_ch9fig1"></a><strong class="calibre8">Figure 9.1</strong> <code class="calibre11">License</code>, and its derivatives, conform to LSP</p>
</div>
<p class="noindent1">This design conforms to the LSP because the behavior of the <code class="calibre11">Billing</code> application does not depend, in any way, on which of the two subtypes it uses. Both of the subtypes are substitutable for the <code class="calibre11">License</code> type.</p>
<h3 class="h1" id="part0021_toclev_40"><a class="calibre3" id="part0021_page_79"></a>T<small class="calibre13">HE</small> S<small class="calibre13">QUARE</small>/R<small class="calibre13">ECTANGLE</small> P<small class="calibre13">ROBLEM</small></h3>
<p class="noindent1">The canonical example of a violation of the LSP is the famed (or infamous, depending on your perspective) square/rectangle problem (<a href="#part0021_ch9fig2">Figure 9.2</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00034.jpeg"/></div>
<p class="fig-caption"><a id="part0021_ch9fig2"></a><strong class="calibre8">Figure 9.2</strong> The infamous square/rectangle problem</p>
</div>
<p class="noindent1">In this example, <code class="calibre11">Square</code> is not a proper subtype of <code class="calibre11">Rectangle</code> because the height and width of the <code class="calibre11">Rectangle</code> are independently mutable; in contrast, the height and width of the <code class="calibre11">Square</code> must change together. Since the <code class="calibre11">User</code> believes it is communicating with a <code class="calibre11">Rectangle</code>, it could easily get confused. The following code shows why:</p>
<p class="codelink"><a href="#part0056_split_001_pch9ex01a" id="part0021_pch9ex01">Click here to view code image</a></p>
<p class="pre2">Rectangle r = …<br class="calibre6"/>
<br class="calibre6"/>
r.setW(5);<br class="calibre6"/>
<br class="calibre6"/>
r.setH(2);<br class="calibre6"/>
<br class="calibre6"/>
assert(r.area() == 10);</p>
<p class="noindent1">If the … code produced a <code class="calibre11">Square</code>, then the assertion would fail.</p>
<p class="noindent1">The only way to defend against this kind of LSP violation is to add mechanisms to the <code class="calibre11">User</code> (such as an <code class="calibre11">if</code> statement) that detects whether the <code class="calibre11">Rectangle</code> is, in fact, a <code class="calibre11">Square</code>. Since the behavior of the <code class="calibre11">User</code> depends on the types it uses, those types are not substitutable.</p>
<h3 class="h1" id="part0021_toclev_41"><a class="calibre3" id="part0021_page_80"></a>L<small class="calibre13">SP AND</small> A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">In the early years of the object-oriented revolution, we thought of the LSP as a way to guide the use of inheritance, as shown in the previous sections. However, over the years the LSP has morphed into a broader principle of software design that pertains to interfaces and implementations.</p>
<p class="noindent1">The interfaces in question can be of many forms. We might have a Java-style interface, implemented by several classes. Or we might have several Ruby classes that share the same method signatures. Or we might have a set of services that all respond to the same REST interface.</p>
<p class="noindent1">In all of these situations, and more, the LSP is applicable because there are users who depend on well-defined interfaces, and on the substitutability of the implementations of those interfaces.</p>
<p class="noindent1">The best way to understand the LSP from an architectural viewpoint is to look at what happens to the architecture of a system when the principle is violated.</p>
<h3 class="h1" id="part0021_toclev_42">E<small class="calibre13">XAMPLE</small> L<small class="calibre13">SP</small> V<small class="calibre13">IOLATION</small></h3>
<p class="noindent1">Assume that we are building an aggregator for many taxi dispatch services. Customers use our website to find the most appropriate taxi to use, regardless of taxi company. Once the customer makes a decision, our system dispatches the chosen taxi by using a restful service.</p>
<p class="noindent1">Now assume that the URI for the restful dispatch service is part of the information contained in the driver database. Once our system has chosen a driver appropriate for the customer, it gets that URI from the driver record and then uses it to dispatch the driver.</p>
<p class="noindent1">Suppose Driver Bob has a dispatch URI that looks like this:</p>
<p class="codelink"><a href="#part0056_split_002_pch9ex02a" id="part0021_pch9ex02">Click here to view code image</a></p>
<p class="pre3"><a href="http://purplecab.com/driver/Bob">purplecab.com/driver/Bob</a></p>
<p class="noindent1"><a id="part0021_page_81"></a>Our system will append the dispatch information onto this URI and send it with a PUT, as follows:</p>
<p class="codelink"><a href="#part0056_split_003_pch9ex03a" id="part0021_pch9ex03">Click here to view code image</a></p>
<p class="pre3"><a href="http://purplecab.com/driver/Bob">purplecab.com/driver/Bob</a>
<br class="calibre6"/>
       /pickupAddress/24 Maple St.<br class="calibre6"/>
       /pickupTime/153<br class="calibre6"/>
       /destination/ORD</p>
<p class="noindent1">Clearly, this means that all the dispatch services, for all the different companies, must conform to the same REST interface. They must treat the <code class="calibre11">pickupAddress</code>, <code class="calibre11">pickupTime</code>, and <code class="calibre11">destination</code> fields identically.</p>
<p class="noindent1">Now suppose the Acme taxi company hired some programmers who didn’t read the spec very carefully. They abbreviated the destination field to just <code class="calibre11">dest</code>. Acme is the largest taxi company in our area, and Acme’s CEO’s ex-wife is our CEO’s new wife, and … Well, you get the picture. What would happen to the architecture of our system?</p>
<p class="noindent1">Obviously, we would need to add a special case. The dispatch request for any Acme driver would have to be constructed using a different set of rules from all the other drivers.</p>
<p class="noindent1">The simplest way to accomplish this goal would be to add an <code class="calibre11">if</code> statement to the module that constructed the dispatch command:</p>
<p class="codelink"><a href="#part0056_split_004_pch9ex04a" id="part0021_pch9ex04">Click here to view code image</a></p>
<p class="pre2">if (driver.getDispatchUri().startsWith("acme.com"))…</p>
<p class="noindent1">But, of course, no architect worth his or her salt would allow such a construction to exist in the system. Putting the word “acme” into the code itself creates an opportunity for all kinds of horrible and mysterious errors, not to mention security breaches.</p>
<p class="noindent1">For example, what if Acme became even more successful and bought the Purple Taxi company. What if the merged company maintained the separate <a id="part0021_page_82"></a>brands and the separate websites, but unified all of the original companies’ systems? Would we have to add another if statement for “purple”?</p>
<p class="noindent1">Our architect would have to insulate the system from bugs like this by creating some kind of dispatch command creation module that was driven by a configuration database keyed by the dispatch URI. The configuration data might look something like this:</p>
<p class="codelink"><a href="#part0056_split_005_pch9ex05a" id="part0021_pch9ex05">Click here to view code image</a></p>
<div class="code">
<table class="calibre16">
<thead class="calibre17">
<tr class="calibre18">
<td class="calibre19"><p class="noindentnv"><strong class="calibre8">URI</strong></p></td>
<td class="calibre19"><p class="noindentnv"><strong class="calibre8">Dispatch Format</strong></p></td>
</tr>
</thead>
<tbody class="calibre20">
<tr class="calibre18">
<td class="calibre19"><p class="noindentnv"><code class="calibre11"><a href="http://Acme.com">Acme.com</a>    </code></p></td>
<td class="calibre19"><p class="noindentnv"><code class="calibre11">/pickupAddress/%s/pickupTime/%s/dest/%s</code></p></td>
</tr>
<tr class="calibre18">
<td class="calibre19"><p class="noindentnv"><code class="calibre11">*.*    </code></p></td>
<td class="calibre19"><p class="noindentnv"><code class="calibre11">/pickupAddress/%s/pickupTime/%s/destination/%s</code></p></td>
</tr>
</tbody>
</table>
</div>
<p class="noindent1">And so our architect has had to add a significant and complex mechanism to deal with the fact that the interfaces of the restful services are not all substitutable.</p>
<h3 class="h1" id="part0021_toclev_43">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The LSP can, and should, be extended to the level of architecture. A simple violation of substitutability, can cause a system’s architecture to be polluted with a significant amount of extra mechanisms.</p>
<p class="fn"><a href="#part0021_ch9fn-1" id="part0021_ch9fn1">1</a>. Barbara Liskov, “Data Abstraction and Hierarchy,” <em class="calibre9">SIGPLAN Notices 23</em>, 5 (May 1988).</p>
</body><body class="calibre">
<h2 class="h2f" id="part0022_ch10"><a class="calibre3" id="part0022_page_83"></a><span class="gray">10</span><br class="calibre12"/>ISP: T<small class="calibre7">HE</small> I<small class="calibre7">NTERFACE</small> S<small class="calibre7">EGREGATION</small> P<small class="calibre7">RINCIPLE</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00035.jpeg"/></div>
<p class="noindent1"><a id="part0022_page_84"></a>The Interface Segregation Principle (ISP) derives its name from the diagram shown in <a href="#part0022_ch10fig1">Figure 10.1</a>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00036.jpeg"/></div>
<p class="fig-caption"><a id="part0022_ch10fig1"></a><strong class="calibre8">Figure 10.1</strong> The Interface Segregation Principle</p>
</div>
<p class="noindent1">In the situation illustrated in <a href="#part0022_ch10fig1">Figure 10.1</a>, there are several users who use the operations of the <code class="calibre11">OPS</code> class. Let’s assume that <code class="calibre11">User1</code> uses only <code class="calibre11">op1</code>, <code class="calibre11">User2</code> uses only <code class="calibre11">op2</code>, and <code class="calibre11">User3</code> uses only <code class="calibre11">op3</code>.</p>
<p class="noindent1">Now imagine that <code class="calibre11">OPS</code> is a class written in a language like Java. Clearly, in that case, the source code of <code class="calibre11">User1</code> will inadvertently depend on <code class="calibre11">op2</code> and <code class="calibre11">op3</code>, even though it doesn’t call them. This dependence means that a change to the source code of <code class="calibre11">op2</code> in <code class="calibre11">OPS</code> will force <code class="calibre11">User1</code> to be recompiled and redeployed, even though nothing that it cared about has actually changed.</p>
<p class="noindent1">This problem can be resolved by segregating the operations into interfaces as shown in <a href="#part0022_ch10fig2">Figure 10.2</a>.</p>
<p class="noindent1">Again, if we imagine that this is implemented in a statically typed language like Java, then the source code of <code class="calibre11">User1</code> will depend on <code class="calibre11">U1Ops</code>, and <code class="calibre11">op1</code>, but will not depend on <code class="calibre11">OPS</code>. Thus a change to <code class="calibre11">OPS</code> that <code class="calibre11">User1</code> does not care about will not cause <code class="calibre11">User1</code> to be recompiled and redeployed.</p>
<div class="fig-heading">
<div class="image1"><a id="part0022_page_85"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00037.jpeg"/></div>
<p class="fig-caption"><a id="part0022_ch10fig2"></a><strong class="calibre8">Figure 10.2</strong> Segregated operations</p>
</div>
<h3 class="h1" id="part0022_toclev_44">ISP <small class="calibre13">AND</small> L<small class="calibre13">ANGUAGE</small></h3>
<p class="noindent1">Clearly, the previously given description depends critically on language type. Statically typed languages like Java force programmers to create declarations that users must <code class="calibre11">import</code>, or <code class="calibre11">use</code>, or otherwise <code class="calibre11">include</code>. It is these <code class="calibre11">included</code> declarations in source code that create the source code dependencies that force recompilation and redeployment.</p>
<p class="noindent1">In dynamically typed languages like Ruby and Python, such declarations don’t exist in source code. Instead, they are inferred at runtime. Thus there are no source code dependencies to force recompilation and redeployment. This is the primary reason that dynamically typed languages create systems that are more flexible and less tightly coupled than statically typed languages.</p>
<p class="noindent1">This fact could lead you to conclude that the ISP is a language issue, rather than an architecture issue.</p>
<h3 class="h1" id="part0022_toclev_45"><a class="calibre3" id="part0022_page_86"></a>ISP <small class="calibre13">AND</small> A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">If you take a step back and look at the root motivations of the ISP, you can see a deeper concern lurking there. In general, it is harmful to depend on modules that contain more than you need. This is obviously true for source code dependencies that can force unnecessary recompilation and redeployment—but it is also true at a much higher, architectural level.</p>
<p class="noindent1">Consider, for example, an architect working on a system, S. He wants to include a certain framework, F, into the system. Now suppose that the authors of F have bound it to a particular database, D. So S depends on F. which depends on D (<a href="#part0022_ch10fig3">Figure 10.3</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00038.jpeg"/></div>
<p class="fig-caption"><a id="part0022_ch10fig3"></a><strong class="calibre8">Figure 10.3</strong> A problematic architecture</p>
</div>
<p class="noindent1">Now suppose that D contains features that F does not use and, therefore, that S does not care about. Changes to those features within D may well force the redeployment of F and, therefore, the redeployment of S. Even worse, a failure of one of the features within D may cause failures in F and S.</p>
<h3 class="h1" id="part0022_toclev_46">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The lesson here is that depending on something that carries baggage that you don’t need can cause you troubles that you didn’t expect.</p>
<p class="noindent1">We’ll explore this idea in more detail when we discuss the Common Reuse Principle in <a href="#part0026_ch13">Chapter 13</a>, “Component Cohesion.”</p>
</body><body class="calibre">
<h2 class="h2f" id="part0023_ch11"><a class="calibre3" id="part0023_page_87"></a><span class="gray">11</span><br class="calibre12"/>DIP: T<small class="calibre7">HE</small> D<small class="calibre7">EPENDENCY</small> I<small class="calibre7">NVERSION</small> P<small class="calibre7">RINCIPLE</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00039.jpeg"/></div>
<p class="noindent1">The Dependency Inversion Principle (DIP) tells us that the most flexible systems are those in which source code dependencies refer only to abstractions, not to concretions.</p>
<p class="noindent1">In a statically typed language, like Java, this means that the <code class="calibre11">use</code>, <code class="calibre11">import</code>, and <code class="calibre11">include</code> statements should refer only to source modules containing interfaces, abstract classes, or some other kind of abstract declaration. Nothing concrete should be depended on.</p>
<p class="noindent1"><a id="part0023_page_88"></a>The same rule applies for dynamically typed languages, like Ruby and Python. Source code dependencies should not refer to concrete modules. However, in these languages it is a bit harder to define what a concrete module is. In particular, it is any module in which the functions being called are implemented.</p>
<p class="noindent1">Clearly, treating this idea as a rule is unrealistic, because software systems must depend on many concrete facilities. For example, the <code class="calibre11">String</code> class in Java is concrete, and it would be unrealistic to try to force it to be abstract. The source code dependency on the concrete <code class="calibre11">java.lang.string</code> cannot, and should not, be avoided.</p>
<p class="noindent1">By comparison, the <code class="calibre11">String</code> class is very stable. Changes to that class are very rare and tightly controlled. Programmers and architects do not have to worry about frequent and capricious changes to <code class="calibre11">String</code>.</p>
<p class="noindent1">For these reasons, we tend to ignore the stable background of operating system and platform facilities when it comes to DIP. We tolerate those concrete dependencies because we know we can rely on them not to change.</p>
<p class="noindent1">It is the <em class="calibre9">volatile</em> concrete elements of our system that we want to avoid depending on. Those are the modules that we are actively developing, and that are undergoing frequent change.</p>
<h3 class="h1" id="part0023_toclev_47">S<small class="calibre13">TABLE</small> A<small class="calibre13">BSTRACTIONS</small></h3>
<p class="noindent1">Every change to an abstract interface corresponds to a change to its concrete implementations. Conversely, changes to concrete implementations do not always, or even usually, require changes to the interfaces that they implement. Therefore interfaces are less volatile than implementations.</p>
<p class="noindent1">Indeed, good software designers and architects work hard to reduce the volatility of interfaces. They try to find ways to add functionality to implementations without making changes to the interfaces. This is Software Design 101.</p>
<p class="noindent1"><a id="part0023_page_89"></a>The implication, then, is that stable software architectures are those that avoid depending on volatile concretions, and that favor the use of stable abstract interfaces. This implication boils down to a set of very specific coding practices:</p>
<p class="indenthangingb">• <strong class="calibre8">Don’t refer to volatile concrete classes.</strong> Refer to abstract interfaces instead. This rule applies in all languages, whether statically or dynamically typed. It also puts severe constraints on the creation of objects and generally enforces the use of <em class="calibre9">Abstract Factories</em>.</p>
<p class="indenthangingb">• <strong class="calibre8">Don’t derive from volatile concrete classes.</strong> This is a corollary to the previous rule, but it bears special mention. In statically typed languages, inheritance is the strongest, and most rigid, of all the source code relationships; consequently, it should be used with great care. In dynamically typed languages, inheritance is less of a problem, but it is still a dependency—and caution is always the wisest choice.</p>
<p class="indenthangingb">• <strong class="calibre8">Don’t override concrete functions.</strong> Concrete functions often require source code dependencies. When you override those functions, you do not eliminate those dependencies—indeed, you <em class="calibre9">inherit</em> them. To manage those dependencies, you should make the function abstract and create multiple implementations.</p>
<p class="indenthangingb">• <strong class="calibre8">Never mention the name of anything concrete and volatile.</strong> This is really just a restatement of the principle itself.</p>
<h3 class="h1" id="part0023_toclev_48">F<small class="calibre13">ACTORIES</small></h3>
<p class="noindent1">To comply with these rules, the creation of volatile concrete objects requires special handling. This caution is warranted because, in virtually all languages, the creation of an object requires a source code dependency on the concrete definition of that object.</p>
<p class="noindent1">In most object-oriented languages, such as Java, we would use an <em class="calibre9">Abstract Factory</em> to manage this undesirable dependency.</p>
<p class="noindent1">The diagram in <a href="#part0023_ch11fig1">Figure 11.1</a> shows the structure. The <code class="calibre11">Application</code> uses the <code class="calibre11">ConcreteImpl</code> through the <code class="calibre11">Service</code> interface. However, the <code class="calibre11">Application</code> <a id="part0023_page_90"></a>must somehow create instances of the <code class="calibre11">ConcreteImpl</code>. To achieve this without creating a source code dependency on the <code class="calibre11">ConcreteImpl</code>, the <code class="calibre11">Application</code> calls the <code class="calibre11">makeSvc</code> method of the <code class="calibre11">ServiceFactory</code> interface. This method is implemented by the <code class="calibre11">ServiceFactoryImpl</code> class, which derives from <code class="calibre11">ServiceFactory</code>. That implementation instantiates the <code class="calibre11">ConcreteImpl</code> and returns it as a <code class="calibre11">Service</code>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00040.jpeg"/></div>
<p class="fig-caption"><a id="part0023_ch11fig1"></a><strong class="calibre8">Figure 11.1</strong> Use of the Abstract Factory pattern to manage the dependency</p>
</div>
<p class="noindent1">The curved line in <a href="#part0023_ch11fig1">Figure 11.1</a> is an architectural boundary. It separates the abstract from the concrete. All source code dependencies cross that curved line pointing in the same direction, toward the abstract side.</p>
<p class="noindent1">The curved line divides the system into two components: one abstract and the other concrete. The abstract component contains all the high-level business rules of the application. The concrete component contains all the implementation details that those business rules manipulate.</p>
<p class="noindent1">Note that the flow of control crosses the curved line in the opposite direction of the source code dependencies. The source code dependencies are inverted against the flow of control—which is why we refer to this principle as Dependency Inversion.</p>
<h3 class="h1" id="part0023_toclev_49"><a class="calibre3" id="part0023_page_91"></a>C<small class="calibre13">ONCRETE</small> C<small class="calibre13">OMPONENTS</small></h3>
<p class="noindent1">The concrete component in <a href="#part0023_ch11fig1">Figure 11.1</a> contains a single dependency, so it violates the DIP. This is typical. DIP violations cannot be entirely removed, but they can be gathered into a small number of concrete components and kept separate from the rest of the system.</p>
<p class="noindent1">Most systems will contain at least one such concrete component—often called <code class="calibre11">main</code> because it contains the <code class="calibre11">main</code><sup class="calibre10"><a href="#part0023_ch11fn1" id="part0023_ch11fn-1">1</a></sup> function. In the case illustrated in <a href="#part0023_ch11fig1">Figure 11.1</a>, the <code class="calibre11">main</code> function would instantiate the <code class="calibre11">ServiceFactoryImpl</code> and place that instance in a global variable of type <code class="calibre11">ServiceFactory</code>. The <code class="calibre11">Application</code> would then access the factory through that global variable.</p>
<h3 class="h1" id="part0023_toclev_50">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">As we move forward in this book and cover higher-level architectural principles, the DIP will show up again and again. It will be the most visible organizing principle in our architecture diagrams. The curved line in <a href="#part0023_ch11fig1">Figure 11.1</a> will become the architectural boundaries in later chapters. The way the dependencies cross that curved line in one direction, and toward more abstract entities, will become a new rule that we will call the <em class="calibre9">Dependency Rule</em>.<a id="part0023_page_92"></a></p>
<p class="fn"><a href="#part0023_ch11fn-1" id="part0023_ch11fn1">1</a>. In other words, the function that is invoked by the operating system when the application is first started up.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0024_part4"><a class="calibre3" id="part0024_page_93"></a><span class="gray">IV</span><br class="calibre12"/>C<small class="calibre7">OMPONENT</small> P<small class="calibre7">RINCIPLES</small></h2>
<p class="noindent1">If the SOLID principles tell us how to arrange the bricks into walls and rooms, then the component principles tell us how to arrange the rooms into buildings. Large software systems, like large buildings, are built out of smaller components.</p>
<p class="noindent1">In <a href="#part0024_part4">Part IV</a>, we will discuss what software components are, which elements should compose them, and how they should be composed together into systems.<a id="part0024_page_94"></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0025_ch12"><a class="calibre3" id="part0025_page_95"></a><span class="gray">12</span><br class="calibre12"/>C<small class="calibre7">OMPONENTS</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00041.jpeg"/></div>
<p class="noindent1"><a id="part0025_page_96"></a>Components are the units of deployment. They are the smallest entities that can be deployed as part of a system. In Java, they are jar files. In Ruby, they are gem files. In .Net, they are DLLs. In compiled languages, they are aggregations of binary files. In interpreted languages, they are aggregations of source files. In all languages, they are the granule of deployment.</p>
<p class="noindent1">Components can be linked together into a single executable. Or they can be aggregated together into a single archive, such as a <code class="calibre11">.war</code> file. Or they can be independently deployed as separate dynamically loaded plugins, such as<code class="calibre11">.jar</code> or <code class="calibre11">.dll</code> or <code class="calibre11">.exe</code> files. Regardless of how they are eventually deployed, well-designed components always retain the ability to be independently deployable and, therefore, independently developable.</p>
<h3 class="h1" id="part0025_toclev_51">A B<small class="calibre13">RIEF</small> H<small class="calibre13">ISTORY OF</small> C<small class="calibre13">OMPONENTS</small></h3>
<p class="noindent1">In the early years of software development, programmers controlled the memory location and layout of their programs. One of the first lines of code in a program would be the <em class="calibre9">origin</em> statement, which declared the address at which the program was to be loaded.</p>
<p class="noindent1">Consider the following simple PDP-8 program. It consists of a subroutine named <code class="calibre11">GETSTR</code> that inputs a string from the keyboard and saves it in a buffer. It also has a little unit test program to exercise <code class="calibre11">GETSTR</code>.</p>
<p class="codelink"><a href="#part0057_split_001_pch12ex01a" id="part0025_pch12ex01">Click here to view code image</a></p>
<p class="pre2">                *200<br class="calibre6"/>
                TLS<br class="calibre6"/>
     START,     CLA<br class="calibre6"/>
                TAD BUFR<br class="calibre6"/>
                JMS GETSTR<br class="calibre6"/>
                CLA<br class="calibre6"/>
                TAD BUFR<br class="calibre6"/>
                JMS PUTSTR<br class="calibre6"/>
                JMP START<br class="calibre6"/>
<a id="part0025_page_97"></a>
     BUFR,      3000<br class="calibre6"/>
 <br class="calibre6"/>
     GETSTR,    0<br class="calibre6"/>
                DCA PTR<br class="calibre6"/>
     NXTCH,     KSF<br class="calibre6"/>
                JMP -1<br class="calibre6"/>
                KRB<br class="calibre6"/>
                DCA I PTR<br class="calibre6"/>
                TAD I PTR<br class="calibre6"/>
                AND K177<br class="calibre6"/>
                ISZ PTR<br class="calibre6"/>
                TAD MCR<br class="calibre6"/>
                SZA<br class="calibre6"/>
                JMP NXTCH<br class="calibre6"/>
 <br class="calibre6"/>
     K177,      177<br class="calibre6"/>
     MCR,       -15</p>
<p class="noindent1">Note the <code class="calibre11">*200</code> command at the start of this program. It tells the compiler to generate code that will be loaded at address 200<sub class="calibre15">8</sub>.</p>
<p class="noindent1">This kind of programming is a foreign concept for most programmers today. They rarely have to think about where a program is loaded in the memory of the computer. But in the early days, this was one of the first decisions a programmer needed to make. In those days, programs were not relocatable.</p>
<p class="noindent1">How did you access a library function in those olden days? The preceding code illustrates the approach used. Programmers included the source code of the library functions with their application code, and compiled them all as a single program.<sup class="calibre10"><a href="#part0025_ch12fn1" id="part0025_ch12fn-1">1</a></sup> Libraries were kept in source, not in binary.</p>
<p class="noindent1"><a id="part0025_page_98"></a>The problem with this approach was that, during this era, devices were slow and memory was expensive and, therefore, limited. Compilers needed to make several passes over the source code, but memory was too limited to keep all the source code resident. Consequently, the compiler had to read in the source code several times using the slow devices.</p>
<p class="noindent1">This took a long time—and the larger your function library, the longer the compiler took. Compiling a large program could take hours.</p>
<p class="noindent1">To shorten the compile times, programmers separated the source code of the function library from the applications. They compiled the function library separately and loaded the binary at a known address—say, 2000<sub class="calibre15">8</sub>. They created a symbol table for the function library and compiled that with their application code. When they wanted to run an application, they would load the binary function library,<sup class="calibre10"><a href="#part0025_ch12fn2" id="part0025_ch12fn-2">2</a></sup> and then load the application. Memory looked like the layout shown in <a href="#part0025_ch12fig1">Figure 12.1</a>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00042.jpeg"/></div>
<p class="fig-caption"><a id="part0025_ch12fig1"></a><strong class="calibre8">Figure 12.1</strong> Early memory layout</p>
</div>
<p class="noindent1">This worked fine so long as the application could fit between addresses 0000<sub class="calibre15">8</sub> and 1777<sub class="calibre15">8</sub>. But soon applications grew to be larger than the space allotted <a id="part0025_page_99"></a>for them. At that point, programmers had to split their applications into two address segments, jumping around the function library (<a href="#part0025_ch12fig2">Figure 12.2</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00043.jpeg"/></div>
<p class="fig-caption"><a id="part0025_ch12fig2"></a><strong class="calibre8">Figure 12.2</strong> Splitting the application into two address segments</p>
</div>
<p class="noindent1">Obviously, this was not a sustainable situation. As programmers added more functions to the function library, it exceeded its bounds, and they had to allocate more space for it (in this example, near 7000<sub class="calibre15">8</sub>). This fragmentation of programs and libraries necessarily continued as computer memory grew.</p>
<p class="noindent1">Clearly, something had to be done.</p>
<h3 class="h1" id="part0025_toclev_52">R<small class="calibre13">ELOCATABILITY</small></h3>
<p class="noindent1">The solution was relocatable binaries. The idea behind them was very simple. The compiler was changed to output binary code that could be relocated in memory by a smart loader. The loader would be told where to load the relocatable code. The relocatable code was instrumented with flags that told the loader which parts of the loaded data had to be altered to be loaded at the selected address. Usually this just meant adding the starting address to any memory reference addresses in the binary.</p>
<p class="noindent1"><a id="part0025_page_100"></a>Now the programmer could tell the loader where to load the function library, and where to load the application. In fact, the loader would accept several binary inputs and simply load them in memory one right after the other, relocating them as it loaded them. This allowed programmers to load only those functions that they needed.</p>
<p class="noindent1">The compiler was also changed to emit the names of the functions as metadata in the relocatable binary. If a program called a library function, the compiler would emit that name as an <em class="calibre9">external reference</em>. If a program defined a library function, the compiler would emit that name as an <em class="calibre9">external definition</em>. Then the loader could <em class="calibre9">link</em> the external references to the external definitions once it had determined where it had loaded those definitions.</p>
<p class="noindent1">And the linking loader was born.</p>
<h3 class="h1" id="part0025_toclev_53">L<small class="calibre13">INKERS</small></h3>
<p class="noindent1">The linking loader allowed programmers to divide their programs up onto separately compilable and loadable segments. This worked well when relatively small programs were being linked with relatively small libraries. However, in the late 1960s and early 1970s, programmers got more ambitious, and their programs got a lot bigger.</p>
<p class="noindent1">Eventually, the linking loaders were too slow to tolerate. Function libraries were stored on slow devices such a magnetic tape. Even the disks, back then, were quite slow. Using these relatively slow devices, the linking loaders had to read dozens, if not hundreds, of binary libraries to resolve the external references. As programs grew larger and larger, and more library functions accumulated in libraries, a linking loader could take more than an hour just to load the program.</p>
<p class="noindent1">Eventually, the loading and the linking were separated into two phases. Programmers took the slow part—the part that did that linking—and put it into a separate application called the <em class="calibre9">linker</em>. The output of the linker was a linked relocatable that a relocating loader could load very quickly. This <a id="part0025_page_101"></a>allowed programmers to prepare an executable using the slow linker, but then they could load it quickly, at any time.</p>
<p class="noindent1">Then came the 1980s. Programmers were working in C or some other high-level language. As their ambitions grew, so did their programs. Programs that numbered hundreds of thousands of lines of code were not unusual.</p>
<p class="noindent1">Source modules were compiled from <code class="calibre11">.c</code> files into <code class="calibre11">.o</code> files, and then fed into the linker to create executable files that could be quickly loaded. Compiling each individual module was relatively fast, but compiling <em class="calibre9">all</em> the modules took a bit of time. The linker would then take even more time. Turnaround had again grown to an hour or more in many cases.</p>
<p class="noindent1">It seemed as if programmers were doomed to endlessly chase their tails. Throughout the 1960s, 1970s, and 1980s, all the changes made to speed up workflow were thwarted by programmers’ ambitions, and the size of the programs they wrote. They could not seem to escape from the hour-long turnaround times. Loading time remained fast, but compile-link times were the bottleneck.</p>
<p class="noindent1">We were, of course, experiencing Murphy’s law of program size:</p>
<p class="blockquote"><em class="calibre9">Programs will grow to fill all available compile and link time.</em></p>
<p class="noindent1">But Murphy was not the only contender in town. Along came Moore,<sup class="calibre10"><a href="#part0025_ch12fn3" id="part0025_ch12fn-3">3</a></sup> and in the late 1980s, the two battled it out. Moore won that battle. Disks started to shrink and got significantly faster. Computer memory started to get so ridiculously cheap that much of the data on disk could be cached in RAM. Computer clock rates increased from 1 MHz to 100 MHz.</p>
<p class="noindent1">By the mid-1990s, the time spent linking had begun to shrink faster than our ambitions could make programs grow. In many cases, link time decreased to a matter of <em class="calibre9">seconds</em>. For small jobs, the idea of a linking loader became feasible again.</p>
<p class="noindent1"><a id="part0025_page_102"></a>This was the era of Active-X, shared libraries, and the beginnings of <code class="calibre11">.jar</code> files. Computers and devices had gotten so fast that we could, once again, do the linking at load time. We could link together several <code class="calibre11">.jar</code> files, or several shared libraries in a matter of seconds, and execute the resulting program. And so the component plugin architecture was born.</p>
<p class="noindent1">Today we routinely ship <code class="calibre11">.jar</code> files or DLLs or shared libraries as plugins to existing applications. If you want to create a mod to <em class="calibre9">Minecraft</em>, for example, you simply include your custom <code class="calibre11">.jar</code> files in a certain folder. If you want to plug <em class="calibre9">Resharper</em> into <em class="calibre9">Visual Studio</em>, you simply include the appropriate DLLs.</p>
<h3 class="h1" id="part0025_toclev_54">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">These dynamically linked files, which can be plugged together at runtime, are the software components of our architectures. It has taken 50 years, but we have arrived at a place where component plugin architecture can be the casual default as opposed to the herculean effort it once was.</p>
<p class="fn"><a href="#part0025_ch12fn-1" id="part0025_ch12fn1">1</a>. My first employer kept several dozen decks of the subroutine library source code on a shelf. When you wrote a new program, you simply grabbed one of those decks and slapped it onto the end of your deck.</p>
<p class="fn"><a href="#part0025_ch12fn-2" id="part0025_ch12fn2">2</a>. Actually, most of those old machines used core memory, which did not get erased when you powered the computer down. We often left the function library loaded for days at a time.</p>
<p class="fn"><a href="#part0025_ch12fn-3" id="part0025_ch12fn3">3</a>. Moore’s law: Computer speed, memory, and density double every 18 months. This law held from the 1950s to 2000, but then, at least for clock rates, stopped cold.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0026_ch13"><a class="calibre3" id="part0026_page_103"></a><span class="gray">13</span><br class="calibre12"/>C<small class="calibre7">OMPONENT</small> C<small class="calibre7">OHESION</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00044.jpeg"/></div>
<p class="noindent1"><a id="part0026_page_104"></a>Which classes belong in which components? This is an important decision, and requires guidance from good software engineering principles. Unfortunately, over the years, this decision has been made in an ad hoc manner based almost entirely on context.</p>
<p class="noindent1">In this chapter we will discuss the three principles of component cohesion:</p>
<p class="indenthangingb">• <strong class="calibre8">REP:</strong> The Reuse/Release Equivalence Principle</p>
<p class="indenthangingb">• <strong class="calibre8">CCP:</strong> The Common Closure Principle</p>
<p class="indenthangingb">• <strong class="calibre8">CRP:</strong> The Common Reuse Principle</p>
<h3 class="h1" id="part0026_toclev_55">T<small class="calibre13">HE</small> R<small class="calibre13">EUSE</small>/R<small class="calibre13">ELEASE</small> E<small class="calibre13">QUIVALENCE</small> P<small class="calibre13">RINCIPLE</small></h3>
<p class="blockquote"><em class="calibre9">The granule of reuse is the granule of release</em>.</p>
<p class="noindent1">The last decade has seen the rise of a menagerie of module management tools, such as Maven, Leiningen, and RVM. These tools have grown in importance because, during that time, a vast number of reusable components and component libraries have been created. We are now living in the age of software reuse—a fulfillment of one of the oldest promises of the object-oriented model.</p>
<p class="noindent1">The Reuse/Release Equivalence Principle (REP) is a principle that seems obvious, at least in hindsight. People who want to reuse software components cannot, and will not, do so unless those components are tracked through a release process and are given release numbers.</p>
<p class="noindent1">This is not simply because, without release numbers, there would be no way to ensure that all the reused components are compatible with each other. Rather, it also reflects the fact that software developers need to know when new releases are coming, and which changes those new releases will bring.</p>
<p class="noindent1">It is not uncommon for developers to be alerted about a new release and decide, based on the changes made in that release, to continue to use the old <a id="part0026_page_105"></a>release instead. Therefore the release process must produce the appropriate notifications and release documentation so that users can make informed decisions about when and whether to integrate the new release.</p>
<p class="noindent1">From a software design and architecture point of view, this principle means that the classes and modules that are formed into a component must belong to a cohesive group. The component cannot simply consist of a random hodgepodge of classes and modules; instead, there must be some overarching theme or purpose that those modules all share.</p>
<p class="noindent1">Of course, this should be obvious. However, there is another way to look at this issue that is perhaps not quite so obvious. Classes and modules that are grouped together into a component should be <em class="calibre9">releasable</em> together. The fact that they share the same version number and the same release tracking, and are included under the same release documentation, should make sense both to the author and to the users.</p>
<p class="noindent1">This is weak advice: Saying that something should “make sense” is just a way of waving your hands in the air and trying to sound authoritative. The advice is weak because it is hard to precisely explain the glue that holds the classes and modules together into a single component. Weak though the advice may be, the principle itself is important, because violations are easy to detect—they don’t “make sense.” If you violate the REP, your users will know, and they won’t be impressed with your architectural skills.</p>
<p class="noindent1">The weakness of this principle is more than compensated for by the strength of the next two principles. Indeed, the CCP and the CRP strongly define the this principle, but in a negative sense.</p>
<h3 class="h1" id="part0026_toclev_56">T<small class="calibre13">HE</small> C<small class="calibre13">OMMON</small> C<small class="calibre13">LOSURE</small> P<small class="calibre13">RINCIPLE</small></h3>
<p class="blockquote"><em class="calibre9">Gather into components those classes that change for the same reasons and at the same times. Separate into different components those classes that change at different times and for different reasons</em>.</p>
<p class="noindent1"><a id="part0026_page_106"></a>This is the Single Responsibility Principle restated for components. Just as the SRP says that a <em class="calibre9">class</em> should not contain multiples reasons to change, so the Common Closure Principle (CCP) says that a <em class="calibre9">component</em> should not have multiple reasons to change.</p>
<p class="noindent1">For most applications, maintainability is more important than reusability. If the code in an application must change, you would rather that all of the changes occur in one component, rather than being distributed across many components.<sup class="calibre10"><a href="#part0026_ch13fn1" id="part0026_ch13fn-1">1</a></sup> If changes are confined to a single component, then we need to redeploy only the one changed component. Other components that don’t depend on the changed component do not need to be revalidated or redeployed.</p>
<p class="noindent1">The CCP prompts us to gather together in one place all the classes that are likely to change for the same reasons. If two classes are so tightly bound, either physically or conceptually, that they always change together, then they belong in the same component. This minimizes the workload related to releasing, revalidating, and redeploying the software.</p>
<p class="noindent1">This principle is closely associated with the Open Closed Principle (OCP). Indeed, it is “closure” in the OCP sense of the word that the CCP addresses. The OCP states that classes should be closed for modification but open for extension. Because 100% closure is not attainable, closure must be strategic. We design our classes such that they are closed to the most common kinds of changes that we expect or have experienced.</p>
<p class="noindent1">The CCP amplifies this lesson by gathering together into the same component those classes that are closed to the same types of changes. Thus, when a change in requirements comes along, that change has a good chance of being restricted to a minimal number of components.</p>
<h4 class="h2"><a class="calibre3" id="part0026_page_107"></a>S<small class="calibre13">IMILARITY WITH</small> SRP</h4>
<p class="noindent1">As stated earlier, the CCP is the component form of the SRP. The SRP tells us to separate methods into different classes, if they change for different reasons. The CCP tells us to separate classes into different components, if they change for different reasons. Both principles can be summarized by the following sound bite:</p>
<p class="blockquote"><em class="calibre9">Gather together those things that change at the same times and for the same reasons. Separate those things that change at different times or for different reasons.</em></p>
<h3 class="h1" id="part0026_toclev_57">T<small class="calibre13">HE</small> C<small class="calibre13">OMMON</small> R<small class="calibre13">EUSE</small> P<small class="calibre13">RINCIPLE</small></h3>
<p class="blockquote"><em class="calibre9">Don’t force users of a component to depend on things they don’t need.</em></p>
<p class="noindent1">The Common Reuse Principle (CRP) is yet another principle that helps us to decide which classes and modules should be placed into a component. It states that classes and modules that tend to be reused together belong in the same component.</p>
<p class="noindent1">Classes are seldom reused in isolation. More typically, reusable classes collaborate with other classes that are part of the reusable abstraction. The CRP states that these classes belong together in the same component. In such a component we would expect to see classes that have lots of dependencies on each other.</p>
<p class="noindent1">A simple example might be a container class and its associated iterators. These classes are reused together because they are tightly coupled to each other. Thus they ought to be in the same component.</p>
<p class="noindent1">But the CRP tells us more than just which classes to put together into a component: It also tells us which classes <em class="calibre9">not</em> to keep together in a component. When one component uses another, a dependency is created between the components. Perhaps the <em class="calibre9">using</em> component uses only one class within the <em class="calibre9">used</em> <a id="part0026_page_108"></a>component—but that still doesn’t weaken the dependency. The <em class="calibre9">using</em> component still depends on the <em class="calibre9">used</em> component.</p>
<p class="noindent1">Because of that dependency, every time the <em class="calibre9">used</em> component is changed, the <em class="calibre9">using</em> component will likely need corresponding changes. Even if no changes are necessary to the <em class="calibre9">using</em> component, it will likely still need to be recompiled, revalidated, and redeployed. This is true even if the <em class="calibre9">using</em> component doesn’t care about the change made in the <em class="calibre9">used</em> component.</p>
<p class="noindent1">Thus when we depend on a component, we want to make sure we depend on every class in that component. Put another way, we want to make sure that the classes that we put into a component are inseparable—that it is impossible to depend on some and not on the others. Otherwise, we will be redeploying more components than is necessary, and wasting significant effort.</p>
<p class="noindent1">Therefore the CRP tells us more about which classes <em class="calibre9">shouldn’t</em> be together than about which classes <em class="calibre9">should</em> be together. The CRP says that classes that are not tightly bound to each other should not be in the same component.</p>
<h4 class="h2">R<small class="calibre13">ELATION TO</small> ISP</h4>
<p class="noindent1">The CRP is the generic version of the ISP. The ISP advises us not to depend on classes that have methods we don’t use. The CRP advises us not to depend on components that have classes we don’t use.</p>
<p class="noindent1">All of this advice can be reduced to a single sound bite:</p>
<p class="blockquote"><em class="calibre9">Don’t depend on things you don’t need</em>.</p>
<h3 class="h1" id="part0026_toclev_58">T<small class="calibre13">HE</small> T<small class="calibre13">ENSION</small> D<small class="calibre13">IAGRAM FOR</small> C<small class="calibre13">OMPONENT</small> C<small class="calibre13">OHESION</small></h3>
<p class="noindent1">You may have already realized that the three cohesion principles tend to fight each other. The REP and CCP are <em class="calibre9">inclusive</em> principles: Both tend to make <a id="part0026_page_109"></a>components larger. The CRP is an <em class="calibre9">exclusive</em> principle, driving components to be smaller. It is the tension between these principles that good architects seek to resolve.</p>
<p class="noindent1"><a href="#part0026_ch13fig1">Figure 13.1</a> is a tension diagram<sup class="calibre10"><a href="#part0026_ch13fn2" id="part0026_ch13fn-2">2</a></sup> that shows how the three principles of cohesion interact with each other. The edges of the diagram describe the <em class="calibre9">cost</em> of abandoning the principle on the opposite vertex.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00045.jpeg"/></div>
<p class="fig-caption"><a id="part0026_ch13fig1"></a><strong class="calibre8">Figure 13.1</strong> Cohesion principles tension diagram</p>
</div>
<p class="noindent1">An architect who focuses on just the REP and CRP will find that too many components are impacted when simple changes are made. In contrast, an architect who focuses too strongly on the CCP and REP will cause too many unneeded releases to be generated.</p>
<p class="noindent1"><a id="part0026_page_110"></a>A good architect finds a position in that tension triangle that meets the <em class="calibre9">current</em> concerns of the development team, but is also aware that those concerns will change over time. For example, early in the development of a project, the CCP is much more important than the REP, because develop-ability is more important than reuse.</p>
<p class="noindent1">Generally, projects tend to start on the right hand side of the triangle, where the only sacrifice is reuse. As the project matures, and other projects begin to draw from it, the project will slide over to the left. This means that the component structure of a project can vary with time and maturity. It has more to do with the way that project is developed and used, than with what the project actually does.</p>
<h3 class="h1" id="part0026_toclev_59">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">In the past, our view of cohesion was much simpler than the REP, CCP, and CRP implied. We once thought that cohesion was simply the attribute that a module performs one, and only one, function. However, the three principles of component cohesion describe a much more complex variety of cohesion. In choosing the classes to group together into components, we must consider the opposing forces involved in reusability and develop-ability. Balancing these forces with the needs of the application is nontrivial. Moreover, the balance is almost always dynamic. That is, the partitioning that is appropriate today might not be appropriate next year. As a consequence, the composition of the components will likely jitter and evolve with time as the focus of the project changes from develop-ability to reusability.</p>
<p class="fn"><a href="#part0026_ch13fn-1" id="part0026_ch13fn1">1</a>. See the section on “The Kitty Problem” in <a href="#part0041_ch27">Chapter 27</a>, “Services: Great and Small.“</p>
<p class="fn"><a href="#part0026_ch13fn-2" id="part0026_ch13fn2">2</a>. Thanks to Tim Ottinger for this idea.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0027_ch14"><a class="calibre3" id="part0027_page_111"></a><span class="gray">14</span><br class="calibre12"/>C<small class="calibre7">OMPONENT</small> C<small class="calibre7">OUPLING</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00046.jpeg"/></div>
<p class="noindent1">The next three principles deal with the relationships between components. Here again we will run into the tension between develop-ability and logical design. The forces that impinge upon the architecture of a component structure are technical, political, and volatile.</p>
<h3 class="h1" id="part0027_toclev_60"><a class="calibre3" id="part0027_page_112"></a>T<small class="calibre13">HE</small> A<small class="calibre13">CYCLIC</small> D<small class="calibre13">EPENDENCIES</small> P<small class="calibre13">RINCIPLE</small></h3>
<p class="blockquote"><em class="calibre9">Allow no cycles in the component dependency graph.</em></p>
<p class="noindent1">Have you ever worked all day, gotten some stuff working, and then gone home, only to arrive the next morning to find that your stuff no longer works? Why doesn’t it work? Because somebody stayed later than you and changed something you depend on! I call this “the morning after syndrome.”</p>
<p class="noindent1">The “morning after syndrome” occurs in development environments where many developers are modifying the same source files. In relatively small projects with just a few developers, it isn’t too big a problem. But as the size of the project and the development team grow, the mornings after can get pretty nightmarish. It is not uncommon for weeks to go by without the team being able to build a stable version of the project. Instead, everyone keeps on changing and changing their code trying to make it work with the last changes that someone else made.</p>
<p class="noindent1">Over the last several decades, two solutions to this problem have evolved, both of which came from the telecommunications industry. The first is “the weekly build,” and the second is the Acyclic Dependencies Principle (ADP).</p>
<h4 class="h2">T<small class="calibre13">HE</small> W<small class="calibre13">EEKLY</small> B<small class="calibre13">UILD</small></h4>
<p class="noindent1">The weekly build used to be common in medium-sized projects. It works like this: All the developers ignore each other for the first four days of the week. They all work on private copies of the code, and don’t worry about integrating their work on a collective basis. Then, on Friday, they integrate all their changes and build the system.</p>
<p class="noindent1">This approach has the wonderful advantage of allowing the developers to live in an isolated world for four days out of five. The disadvantage, of course, is the large integration penalty that is paid on Friday.</p>
<p class="noindent1">Unfortunately, as the project grows, it becomes less feasible to finish integrating the project on Friday. The integration burden grows until it starts <a id="part0027_page_113"></a>to overflow into Saturday. A few such Saturdays are enough to convince the developers that integration should really begin on Thursday—and so the start of integration slowly creeps toward the middle of the week.</p>
<p class="noindent1">As the duty cycle of development versus integration decreases, the efficiency of the team decreases, too. Eventually this situation becomes so frustrating that the developers, or the project managers, declare that the schedule should be changed to a biweekly build. This suffices for a time, but the integration time continues to grow with project size.</p>
<p class="noindent1">Eventually, this scenario leads to a crisis. To maintain efficiency, the build schedule has to be continually lengthened—but lengthening the build schedule increases project risks. Integration and testing become increasingly harder to do, and the team loses the benefit of rapid feedback.</p>
<h4 class="h2">E<small class="calibre13">LIMINATING</small> D<small class="calibre13">EPENDENCY</small> C<small class="calibre13">YCLES</small></h4>
<p class="noindent1">The solution to this problem is to partition the development environment into releasable components. The components become units of work that can be the responsibility of a single developer, or a team of developers. When developers get a component working, they release it for use by the other developers. They give it a release number and move it into a directory for other teams to use. They then continue to modify their component in their own private areas. Everyone else uses the released version.</p>
<p class="noindent1">As new releases of a component are made available, other teams can decide whether they will immediately adopt the new release. If they decide not to, they simply continue using the old release. Once they decide that they are ready, they begin to use the new release.</p>
<p class="noindent1">Thus no team is at the mercy of the others. Changes made to one component do not need to have an immediate affect on other teams. Each team can decide for itself when to adapt its own components to new releases of the components. Moreover, integration happens in small increments. There is no single point in time when all developers must come together and integrate everything they are doing.</p>
<p class="noindent1"><a id="part0027_page_114"></a>This is a very simple and rational process, and it is widely used. To make it work successfully, however, you must <em class="calibre9">manage</em> the dependency structure of the components. <em class="calibre9">There can be no cycles</em>. If there are cycles in the dependency structure, then the “morning after syndrome” cannot be avoided.</p>
<p class="noindent1">Consider the component diagram in <a href="#part0027_ch14fig1">Figure 14.1</a>. It shows a rather typical structure of components assembled into an application. The function of this application is unimportant for the purpose of this example. What <em class="calibre9">is</em> important is the dependency structure of the components. Notice that this structure is a <em class="calibre9">directed graph</em>. The components are the <em class="calibre9">nodes</em>, and the dependency relationships are the <em class="calibre9">directed edges</em>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00047.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig1"></a><strong class="calibre8">Figure 14.1</strong> Typical component diagram</p>
</div>
<p class="noindent1">Notice one more thing: Regardless of which component you begin at, it is impossible to follow the dependency relationships and wind up back at that component. This structure has no cycles. It is a <em class="calibre9">directed acyclic graph</em> (DAG).</p>
<p class="noindent1">Now consider what happens when the team responsible for <code class="calibre11">Presenters</code> makes a new release of their component. It is easy to find out who is affected <a id="part0027_page_115"></a>by this release; you just follow the dependency arrows backward. Thus <code class="calibre11">View</code> and <code class="calibre11">Main</code> will both be affected. The developers currently working on those components will have to decide when they should integrate their work with the new release of <code class="calibre11">Presenters</code>.</p>
<p class="noindent1">Notice also that when <code class="calibre11">Main</code> is released, it has utterly no effect on any of the other components in the system. They don’t know about <code class="calibre11">Main</code>, and they don’t care when it changes. This is nice. It means that the impact of releasing <code class="calibre11">Main</code> is relatively small.</p>
<p class="noindent1">When the developers working on the <code class="calibre11">Presenters</code> component would like to run a test of that component, they just need to build their version of <code class="calibre11">Presenters</code> with the versions of the <code class="calibre11">Interactors</code> and <code class="calibre11">Entities</code> components that they are currently using. None of the other components in the system need be involved. This is nice. It means that the developers working on <code class="calibre11">Presenters</code> have relatively little work to do to set up a test, and that they have relatively few variables to consider.</p>
<p class="noindent1">When it is time to release the whole system, the process proceeds from the bottom up. First the <code class="calibre11">Entities</code> component is compiled, tested, and released. Then the same is done for <code class="calibre11">Database</code> and <code class="calibre11">Interactors</code>. These components are followed by <code class="calibre11">Presenters</code>, <code class="calibre11">View</code>, <code class="calibre11">Controllers</code>, and then <code class="calibre11">Authorizer</code>. <code class="calibre11">Main</code> goes last. This process is very clear and easy to deal with. We know how to build the system because we understand the dependencies between its parts.</p>
<h4 class="h2">T<small class="calibre13">HE</small> E<small class="calibre13">FFECT OF</small> A C<small class="calibre13">YCLE IN THE</small> C<small class="calibre13">OMPONENT</small> D<small class="calibre13">EPENDENCY</small> G<small class="calibre13">RAPH</small></h4>
<p class="noindent1">Suppose that a new requirement forces us to change one of the classes in <code class="calibre11">Entities</code> such that it makes use of a class in <code class="calibre11">Authorizer</code>. For example, let’s say that the <code class="calibre11">User</code> class in <code class="calibre11">Entities</code> uses the <code class="calibre11">Permissions</code> class in <code class="calibre11">Authorizer</code>. This creates a dependency cycle, as shown in <a href="#part0027_ch14fig2">Figure 14.2</a>.</p>
<p class="noindent1">This cycle creates some immediate problems. For example, the developers working on the <code class="calibre11">Database</code> component know that to release it, the component <a id="part0027_page_116"></a>must be compatible with <code class="calibre11">Entities</code>. However, with the cycle in place, the <code class="calibre11">Database</code> component must now <em class="calibre9">also</em> be compatible with <code class="calibre11">Authorizer</code>. But <code class="calibre11">Authorizer</code> depends on <code class="calibre11">Interactors</code>. This makes <code class="calibre11">Database</code> much more difficult to release. <code class="calibre11">Entities</code>, <code class="calibre11">Authorizer</code>, and <code class="calibre11">Interactors</code> have, in effect, become one large component—which means that all of the developers working on any of those components will experience the dreaded “morning after syndrome.” They will be stepping all over one another because they must all use exactly the same release of one another’s components.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00048.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig2"></a><strong class="calibre8">Figure 14.2</strong> A dependency cycle</p>
</div>
<p class="noindent1">But this is just part of the trouble. Consider what happens when we want to test the <code class="calibre11">Entities</code> component. To our chagrin, we find that we must build and integrate with <code class="calibre11">Authorizer</code> and <code class="calibre11">Interactors</code>. This level of coupling between components is troubling, if not intolerable.</p>
<p class="noindent1">You may have wondered why you have to include so many different libraries, and so much of everybody else’s stuff, just to run a simple unit test of one of your classes. If you investigate the matter a bit, you will probably discover that there are cycles in the dependency graph. Such cycles make it very difficult to isolate components. Unit testing and releasing become very difficult and error prone. In addition, build issues grow geometrically with the number of modules.</p>
<p class="noindent1"><a id="part0027_page_117"></a>Moreover, when there are cycles in the dependency graph, it can be very difficult to work out the order in which you must build the components. Indeed, there probably is no correct order. This can lead to some very nasty problems in languages like Java that read their declarations from compiled binary files.</p>
<h4 class="h2">B<small class="calibre13">REAKING THE</small> C<small class="calibre13">YCLE</small></h4>
<p class="noindent1">It is always possible to break a cycle of components and reinstate the dependency graph as a DAG. There are two primary mechanisms for doing so:</p>
<p class="indenthangingn"><strong class="calibre8">1.</strong> Apply the Dependency Inversion Principle (DIP). In the case in <a href="#part0027_ch14fig3">Figure 14.3</a>, we could create an interface that has the methods that <code class="calibre11">User</code> needs. We could then put that interface into <code class="calibre11">Entities</code> and inherit it into <code class="calibre11">Authorizer</code>. This inverts the dependency between <code class="calibre11">Entities</code> and <code class="calibre11">Authorizer</code>, thereby breaking the cycle.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00049.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig3"></a><strong class="calibre8">Figure 14.3</strong> Inverting the dependency between <code class="calibre11">Entities</code> and <code class="calibre11">Authorizer</code></p>
<p class="indenthangingn"><strong class="calibre8">2.</strong> Create a new component that both <code class="calibre11">Entities</code> and <code class="calibre11">Authorizer</code> depend on. Move the class(es) that they both depend on into that new component (<a href="#part0027_ch14fig4">Figure 14.4</a>).</p>
<div class="fig-heading">
<div class="image1"><a id="part0027_page_118"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00050.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig4"></a><strong class="calibre8">Figure 14.4</strong> The new component that both <code class="calibre11">Entities</code> and <code class="calibre11">Authorizer</code> depend on</p>
</div>
</div>
<h4 class="h2">T<small class="calibre13">HE</small> “J<small class="calibre13">ITTERS”</small></h4>
<p class="noindent1">The second solution implies that the component structure is volatile in the presence of changing requirements. Indeed, as the application grows, the component dependency structure jitters and grows. Thus the dependency structure must always be monitored for cycles. When cycles occur, they must be broken somehow. Sometimes this will mean creating new components, making the dependency structure grow.</p>
<h3 class="h1" id="part0027_toclev_61">T<small class="calibre13">OP</small>-D<small class="calibre13">OWN</small> D<small class="calibre13">ESIGN</small></h3>
<p class="noindent1">The issues we have discussed so far lead to an inescapable conclusion: The component structure cannot be designed from the top down. It is not one of the first things about the system that is designed, but rather evolves as the system grows and changes.</p>
<p class="noindent1">Some readers may find this point to be counterintuitive. We have come to expect that large-grained decompositions, like components, will also be high-level <em class="calibre9">functional</em> decompositions.</p>
<p class="noindent1"><a id="part0027_page_119"></a>When we see a large-grained grouping such as a component dependency structure, we believe that the components ought to somehow represent the functions of the system. Yet this does not seem to be an attribute of component dependency diagrams.</p>
<p class="noindent1">In fact, component dependency diagrams have very little do to with describing the function of the application. Instead, they are a map to the <em class="calibre9">buildability</em> and <em class="calibre9">maintainability</em> of the application. This is why they aren’t designed at the beginning of the project. There is no software to build or maintain, so there is no need for a build and maintenance map. But as more and more modules accumulate in the early stages of implementation and design, there is a growing need to manage the dependencies so that the project can be developed without the “morning after syndrome.” Moreover, we want to keep changes as localized as possible, so we start paying attention to the SRP and CCP and collocate classes that are likely to change together.</p>
<p class="noindent1">One of the overriding concerns with this dependency structure is the isolation of volatility. We don’t want components that change frequently and for capricious reasons to affect components that otherwise ought to be stable. For example, we don’t want cosmetic changes to the GUI to have an impact on our business rules. We don’t want the addition or modification of reports to have an impact on our highest-level policies. Consequently, the component dependency graph is created and molded by architects to protect stable high-value components from volatile components.</p>
<p class="noindent1">As the application continues to grow, we start to become concerned about creating reusable elements. At this point, the CRP begins to influence the composition of the components. Finally, as cycles appear, the ADP is applied and the component dependency graph jitters and grows.</p>
<p class="noindent1">If we tried to design the component dependency structure before we designed any classes, we would likely fail rather badly. We would not know much about common closure, we would be unaware of any reusable elements, and we would almost certainly create components that produced dependency cycles. Thus the component dependency structure grows and evolves with the logical design of the system.</p>
<h3 class="h1" id="part0027_toclev_62"><a class="calibre3" id="part0027_page_120"></a>T<small class="calibre13">HE</small> S<small class="calibre13">TABLE</small> D<small class="calibre13">EPENDENCIES</small> P<small class="calibre13">RINCIPLE</small></h3>
<p class="blockquote"><em class="calibre9">Depend in the direction of stability.</em></p>
<p class="noindent1">Designs cannot be completely static. Some volatility is necessary if the design is to be maintained. By conforming to the Common Closure Principle (CCP), we create components that are sensitive to certain kinds of changes but immune to others. Some of these components are <em class="calibre9">designed</em> to be volatile. We <em class="calibre9">expect</em> them to change.</p>
<p class="noindent1">Any component that we expect to be volatile should not be depended on by a component that is difficult to change. Otherwise, the volatile component will also be difficult to change.</p>
<p class="noindent1">It is the perversity of software that a module that you have designed to be easy to change can be made difficult to change by someone else who simply hangs a dependency on it. Not a line of source code in your module need change, yet your module will suddenly become more challenging to change. By conforming to the Stable Dependencies Principle (SDP), we ensure that modules that are intended to be easy to change are not depended on by modules that are harder to change.</p>
<h4 class="h2">S<small class="calibre13">TABILITY</small></h4>
<p class="noindent1">What is meant by “stability”? Stand a penny on its side. Is it stable in that position? You would likely say “no.” However, unless disturbed, it will remain in that position for a very long time. Thus stability has nothing directly to do with frequency of change. The penny is not changing, but it is difficult to think of it as stable.</p>
<p class="noindent1"><em class="calibre9">Webster’s Dictionary</em> says that something is stable if it is “not easily moved.” Stability is related to the amount of work required to make a change. On the one hand, the standing penny is not stable because it requires very little work to topple it. On the other hand, a table is very stable because it takes a considerable amount of effort to turn it over.</p>
<p class="noindent1">How does this relate to software? Many factors may make a software component hard to change—for example, its size, complexity, and clarity, among <a id="part0027_page_121"></a>other characteristics. We will ignore all those factors and focus on something different here. One sure way to make a software component difficult to change, is to make lots of other software components depend on it. A component with lots of incoming dependencies is very stable because it requires a great deal of work to reconcile any changes with all the dependent components.</p>
<p class="noindent1">The diagram in <a href="#part0027_ch14fig5">Figure 14.5</a> shows <code class="calibre11">X</code>, which is a stable component. Three components depend on <code class="calibre11">X</code>, so it has three good reasons not to change. We say that <code class="calibre11">X</code> is <em class="calibre9">responsible</em> to those three components. Conversely, <code class="calibre11">X</code> depends on nothing, so it has no external influence to make it change. We say it is <em class="calibre9">independent</em>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00051.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig5"></a><strong class="calibre8">Figure 14.5</strong> <code class="calibre11">X</code>: a stable component</p>
</div>
<p class="noindent1"><a href="#part0027_ch14fig6">Figure 14.6</a> shows <code class="calibre11">Y</code>, which is a very unstable component. No other components depend on <code class="calibre11">Y</code>, so we say that it is irresponsible. <code class="calibre11">Y</code> also has three components that it depends on, so changes may come from three external sources. We say that <code class="calibre11">Y</code> is dependent.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00052.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig6"></a><strong class="calibre8">Figure 14.6</strong> <code class="calibre11">Y</code>: a very unstable component</p>
</div>
<h4 class="h2"><a class="calibre3" id="part0027_page_122"></a>S<small class="calibre13">TABILITY</small> M<small class="calibre13">ETRICS</small></h4>
<p class="noindent1">How can we measure the stability of a component? One way is to count the number of dependencies that enter and leave that component. These counts will allow us to calculate the <em class="calibre9">positional</em> stability of the component.</p>
<p class="indenthangingb">• <em class="calibre9">Fan-in</em>: Incoming dependencies. This metric identifies the number of classes outside this component that depend on classes within the component.</p>
<p class="indenthangingb">• <em class="calibre9">Fan-out</em>: Outgoing depenencies. This metric identifies the number of classes inside this component that depend on classes outside the component.</p>
<p class="indenthangingb">• <em class="calibre9">I</em>: Instability: <em class="calibre9">I</em> = <em class="calibre9">Fan-out</em> , (<em class="calibre9">Fan-in</em> + <em class="calibre9">Fan-out</em>). This metric has the range [0, 1]. <em class="calibre9">I</em> = 0 indicates a maximally stable component. <em class="calibre9">I</em> = 1 indicates a maximally unstable component.</p>
<p class="noindent1">The <em class="calibre9">Fan-in</em> and <em class="calibre9">Fan-out</em> metrics<sup class="calibre10"><a href="#part0027_ch14fn1" id="part0027_ch14fn-1">1</a></sup> are calculated by counting the number of <em class="calibre9">classes</em> outside the component in question that have dependencies with the classes inside the component in question. Consider the example in <a href="#part0027_ch14fig7">Figure 14.7</a>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00053.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig7"></a><strong class="calibre8">Figure 14.7</strong> Our example</p>
</div>
<p class="noindent1">Let’s say we want to calculate the stability of the component <code class="calibre11">Cc</code>. We find that there are three classes outside <code class="calibre11">Cc</code> that depend on classes in <code class="calibre11">Cc</code>. Thus, <em class="calibre9">Fan-in</em> = 3. Moreover, there is one class outside <code class="calibre11">Cc</code> that classes in <code class="calibre11">Cc</code> depend on. Thus, <em class="calibre9">Fan-out</em> = 1 and <em class="calibre9">I</em> = 1/4.</p>
<p class="noindent1"><a id="part0027_page_123"></a>In C++, these dependencies are typically represented by <code class="calibre11">#include</code> statements. Indeed, the <em class="calibre9">I</em> metric is easiest to calculate when you have organized your source code such that there is one class in each source file. In Java, the <em class="calibre9">I</em> metric can be calculated by counting <code class="calibre11">import</code> statements and qualified names.</p>
<p class="noindent1">When the <em class="calibre9">I</em> metric is equal to 1, it means that no other component depends on this component (<em class="calibre9">Fan-in</em> = 0), and this component depends on other components (<em class="calibre9">Fan-ou</em>t &gt; 0). This situation is as unstable as a component can get; it is irresponsible and dependent. Its lack of dependents gives the component no reason not to change, and the components that it depends on may give it ample reason to change.</p>
<p class="noindent1">In contrast, when the <em class="calibre9">I</em> metric is equal to 0, it means that the component is depended on by other components (<em class="calibre9">Fan-in</em> &gt; 0), but does not itself depend on any other components (<em class="calibre9">Fan-ou</em>t = 0). Such a component is <em class="calibre9">responsible</em> and <em class="calibre9">independent</em>. It is as stable as it can get. Its dependents make it hard to change the component, and its has no dependencies that might force it to change.</p>
<p class="noindent1">The SDP says that the <em class="calibre9">I</em> metric of a component should be larger than the <em class="calibre9">I</em> metrics of the components that it depends on. That is, <em class="calibre9">I</em> metrics should <em class="calibre9">decrease</em> in the direction of dependency.</p>
<h4 class="h2">N<small class="calibre13">OT</small> A<small class="calibre13">LL</small> C<small class="calibre13">OMPONENTS</small> S<small class="calibre13">HOULD</small> B<small class="calibre13">E</small> S<small class="calibre13">TABLE</small></h4>
<p class="noindent1">If all the components in a system were maximally stable, the system would be unchangeable. This is not a desirable situation. Indeed, we want to design our component structure so that some components are unstable and some are stable. The diagram in <a href="#part0027_ch14fig8">Figure 14.8</a> shows an ideal configuration for a system with three components.</p>
<p class="noindent1">The changeable components are on top and depend on the stable component at the bottom. Putting the unstable components at the top of the diagram is a useful convention because any arrow that points <em class="calibre9">up</em> is violating the SDP (and, as we shall see later, the ADP).</p>
<div class="fig-heading">
<div class="image1"><a id="part0027_page_124"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00054.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig8"></a><strong class="calibre8">Figure 14.8</strong> An ideal configuration for a system with three components</p>
</div>
<p class="noindent1">The diagram in <a href="#part0027_ch14fig9">Figure 14.9</a> shows how the SDP can be violated.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00055.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig9"></a><strong class="calibre8">Figure 14.9</strong> SDP violation</p>
</div>
<p class="noindent1"><code class="calibre11">Flexible</code> is a component that we have designed to be easy to change. We want <code class="calibre11">Flexible</code> to be unstable. However, some developer, working in the component named <code class="calibre11">Stable</code>, has hung a dependency on <code class="calibre11">Flexible</code>. This violates the SDP because the <em class="calibre9">I</em> metric for <code class="calibre11">Stable</code> is much smaller than the <em class="calibre9">I</em> metric for <code class="calibre11">Flexible</code>. As a result, <code class="calibre11">Flexible</code> will no longer be easy to change. A change to <code class="calibre11">Flexible</code> will force us to deal with <code class="calibre11">Stable</code> and all its dependents.</p>
<p class="noindent1">To fix this problem, we somehow have to break the dependence of <code class="calibre11">Stable</code> on <code class="calibre11">Flexible</code>. Why does this dependency exist? Let’s assume that there is a <a id="part0027_page_125"></a>class <code class="calibre11">C</code> within <code class="calibre11">Flexible</code> that another class <code class="calibre11">U</code> within <code class="calibre11">Stable</code> needs to use (<a href="#part0027_ch14fig10">Figure 14.10</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00056.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig10"></a><strong class="calibre8">Figure 14.10</strong> <code class="calibre11">U</code> within <code class="calibre11">Stable</code> uses <code class="calibre11">C</code> within <code class="calibre11">Flexible</code></p>
</div>
<p class="noindent1">We can fix this by employing the DIP. We create an interface class called <code class="calibre11">US</code> and put it in a component named <code class="calibre11">UServer</code>. We make sure that this interface declares all the methods that <code class="calibre11">U</code> needs to use. We then make <code class="calibre11">C</code> implement this interface as shown in <a href="#part0027_ch14fig11">Figure 14.11</a>. This breaks the dependency of <code class="calibre11">Stable</code> on <code class="calibre11">Flexible</code>, and forces both components to depend on <code class="calibre11">UServer</code>. <code class="calibre11">UServer</code> is very stable (<em class="calibre9">I</em> = 0), and <code class="calibre11">Flexible</code> retains its necessary instability (<em class="calibre9">I</em> = 1). All the dependencies now flow in the direction of <em class="calibre9">decreasing I</em>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00057.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig11"></a><strong class="calibre8">Figure 14.11</strong> <code class="calibre11">C</code> implements the interface class <code class="calibre11">US</code></p>
</div>
<h5 class="h3">Abstract Components</h5>
<p class="noindent1">You may find it strange that we would create a component—in this example, <code class="calibre11">UService</code>—that contains nothing but an interface. Such a component contains no executable code! It turns out, however, that this is a very common, and necessary, tactic when using statically typed languages like Java and C#. These abstract components are very stable and, therefore, are ideal targets for less stable components to depend on.</p>
<p class="noindent1">When using dynamically typed languages like Ruby and Python, these abstract components don’t exist at all, nor do the dependencies that would <a id="part0027_page_126"></a>have targeted them. Dependency structures in these languages are much simpler because dependency inversion does not require either the declaration or the inheritance of interfaces.</p>
<h3 class="h1" id="part0027_toclev_63">T<small class="calibre13">HE</small> S<small class="calibre13">TABLE</small> A<small class="calibre13">BSTRACTIONS</small> P<small class="calibre13">RINCIPLE</small></h3>
<p class="blockquote"><em class="calibre9">A component should be as abstract as it is stable.</em></p>
<h4 class="h2">W<small class="calibre13">HERE</small> D<small class="calibre13">O</small> W<small class="calibre13">E</small> P<small class="calibre13">UT THE</small> H<small class="calibre13">IGH</small>-L<small class="calibre13">EVEL</small> P<small class="calibre13">OLICY</small>?</h4>
<p class="noindent1">Some software in the system should not change very often. This software represents high-level architecture and policy decisions. We don’t want these business and architectural decisions to be volatile. Thus the software that encapsulates the high-level policies of the system should be placed into stable components (<em class="calibre9">I</em> = 0). Unstable components (<em class="calibre9">I</em> = 1) should contain only the software that is volatile—software that we want to be able to quickly and easily change.</p>
<p class="noindent1">However, if the high-level policies are placed into stable components, then the source code that represents those policies will be difficult to change. This could make the overall architecture inflexible. How can a component that is maximally stable (<em class="calibre9">I</em> = 0) be flexible enough to withstand change? The answer is found in the OCP. This principle tells us that it is possible and desirable to create classes that are flexible enough to be extended without requiring modification. Which kind of classes conform to this principle? <em class="calibre9">Abstract</em> classes.</p>
<h4 class="h2">I<small class="calibre13">NTRODUCING THE</small> S<small class="calibre13">TABLE</small> A<small class="calibre13">BSTRACTIONS</small> P<small class="calibre13">RINCIPLE</small></h4>
<p class="noindent1">The Stable Abstractions Principle (SAP) sets up a relationship between stability and abstractness. On the one hand, it says that a stable component should also be abstract so that its stability does not prevent it from being extended. On the other hand, it says that an unstable component should be concrete since it its instability allows the concrete code within it to be easily changed.</p>
<p class="noindent1"><a id="part0027_page_127"></a>Thus, if a component is to be stable, it should consist of interfaces and abstract classes so that it can be extended. Stable components that are extensible are flexible and do not overly constrain the architecture.</p>
<p class="noindent1">The SAP and the SDP combined amount to the DIP for components. This is true because the SDP says that dependencies should run in the direction of stability, and the SAP says that stability implies abstraction. Thus <em class="calibre9">dependencies run in the direction of abstraction.</em></p>
<p class="noindent1">The DIP, however, is a principle that deals with classes—and with classes there are no shades of gray. Either a class is abstract or it is not. The combination of the SDP and the SAP deals with components, and allows that a component can be partially abstract and partially stable.</p>
<h4 class="h2">M<small class="calibre13">EASURING</small> A<small class="calibre13">BSTRACTION</small></h4>
<p class="noindent1">The <em class="calibre9">A</em> metric is a measure of the abstractness of a component. Its value is simply the ratio of interfaces and abstract classes in a component to the total number of classes in the component.</p>
<p class="indenthangingb">• <em class="calibre9">Nc:</em> The number of classes in the component.</p>
<p class="indenthangingb">• <em class="calibre9">Na:</em> The number of abstract classes and interfaces in the component.</p>
<p class="indenthangingb">• <em class="calibre9">A:</em> Abstractness. <em class="calibre9">A</em> = <em class="calibre9">Na</em> ÷ <em class="calibre9">Nc.</em></p>
<p class="noindent1">The <em class="calibre9">A</em> metric ranges from 0 to 1. A value of 0 implies that the component has no abstract classes at all. A value of 1 implies that the component contains nothing but abstract classes.</p>
<h4 class="h2">T<small class="calibre13">HE</small> M<small class="calibre13">AIN</small> S<small class="calibre13">EQUENCE</small></h4>
<p class="noindent1">We are now in a position to define the relationship between stability (<em class="calibre9">I</em>) and abstractness (<em class="calibre9">A</em>). To do so, we create a graph with <em class="calibre9">A</em> on the vertical axis and <em class="calibre9">I</em> on the horizontal axis (<a href="#part0027_ch14fig12">Figure 14.12</a>). If we plot the two “good” kinds of components on this graph, we will find the components that are maximally stable and abstract at the upper left at (0, 1). The components that are maximally unstable and concrete are at the lower right at (1, 0).</p>
<div class="fig-heading">
<div class="image1"><a id="part0027_page_128"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00058.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig12"></a><strong class="calibre8">Figure 14.12</strong> The I/A graph</p>
</div>
<p class="noindent1">Not all components fall into one of these two positions, because components often have <em class="calibre9">degrees</em> of abstraction and stability. For example, it is very common for one abstract class to derive from another abstract class. The derivative is an abstraction that has a dependency. Thus, though it is maximally abstract, it will not be maximally stable. Its dependency will decrease its stability.</p>
<p class="noindent1">Since we cannot enforce a rule that all components sit at either (0, 1) or (1, 0), we must assume that there is a locus of points on the <em class="calibre9">A</em>/<em class="calibre9">I</em> graph that defines reasonable positions for components. We can infer what that locus is by finding the areas where components should <em class="calibre9">not</em> be—in other words, by determining the zones of <em class="calibre9">exclusion</em> (Figure 11.13).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00059.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig13"></a><strong class="calibre8">Figure 14.13</strong> Zones of exclusion</p>
</div>
<h5 class="h3"><a id="part0027_page_129"></a>The Zone of Pain</h5>
<p class="noindent1">Consider a component in the area of (0, 0). This is a highly stable and concrete component. Such a component is not desirable because it is rigid. It cannot be extended because it is not abstract, and it is very difficult to change because of its stability. Thus we do not normally expect to see well-designed components sitting near (0, 0). The area around (0, 0) is a zone of exclusion called the <em class="calibre9">Zone of Pain</em>.</p>
<p class="noindent1">Some software entities do, in fact, fall within the Zone of Pain. An example would be a database schema. Database schemas are notoriously volatile, extremely concrete, and highly depended on. This is one reason why the interface between OO applications and databases is so difficult to manage, and why schema updates are generally painful.</p>
<p class="noindent1">Another example of software that sits near the area of (0, 0) is a concrete utility library. Although such a library has an <em class="calibre9">I</em> metric of 1, it may actually be nonvolatile. Consider the <code class="calibre11">String</code> component, for example. Even though all the classes within it are concrete, it is so commonly used that changing it would create chaos. Therefore <code class="calibre11">String</code> is nonvolatile.</p>
<p class="noindent1">Nonvolatile components are harmless in the (0, 0) zone since they are not likely to be changed. For that reason, it is only volatile software components that are problematic in the Zone of Pain. The more volatile a component in the Zone of Pain, the more “painful” it is. Indeed, we might consider volatility to be a third axis of the graph. With this understanding, <a href="#part0027_ch14fig13">Figure 14.13</a> shows only the most painful plane, where volatility = 1.</p>
<h5 class="h3">The Zone of Uselessness</h5>
<p class="noindent1">Consider a component near (1, 1). This location is undesirable because it is maximally abstract, yet has no dependents. Such components are useless. Thus this area is called the <em class="calibre9">Zone of Uselessness</em>.</p>
<p class="noindent1">The software entities that inhabit this region are a kind of detritus. They are often leftover abstract classes that no one ever implemented. We find them in systems from time to time, sitting in the code base, unused.</p>
<p class="noindent1"><a id="part0027_page_130"></a>A component that has a position deep within the Zone of Uselessness must contain a significant fraction of such entities. Clearly, the presence of such useless entities is undesirable.</p>
<h4 class="h2">A<small class="calibre13">VOIDING THE</small> Z<small class="calibre13">ONES OF</small> E<small class="calibre13">XCLUSION</small></h4>
<p class="noindent1">It seems clear that our most volatile components should be kept as far from both zones of exclusion as possible. The locus of points that are maximally distant from each zone is the line that connects (1, 0) and (0, 1). I call this line the <em class="calibre9">Main Sequence</em>.<sup class="calibre10"><a href="#part0027_ch14fn2" id="part0027_ch14fn-2">2</a></sup></p>
<p class="noindent1">A component that sits on the Main Sequence is not “too abstract” for its stability, nor is it “too unstable” for its abstractness. It is neither useless nor particularly painful. It is depended on to the extent that it is abstract, and it depends on others to the extent that it is concrete.</p>
<p class="noindent1">The most desirable position for a component is at one of the two endpoints of the Main Sequence. Good architects strive to position the majority of their components at those endpoints. However, in my experience, some small fraction of the components in a large system are neither perfectly abstract nor perfectly stable. Those components have the best characteristics if they are on, <em class="calibre9">or close</em>, to the Main Sequence.</p>
<h4 class="h2">D<small class="calibre13">ISTANCE FROM THE</small> M<small class="calibre13">AIN</small> S<small class="calibre13">EQUENCE</small></h4>
<p class="noindent1">This leads us to our last metric. If it is desirable for components to be on, or close, to the Main Sequence, then we can create a metric that measures how far away a component is from this ideal.</p>
<p class="indenthangingb">• <em class="calibre9">D</em><sup class="calibre10"><a href="#part0027_ch14fn3" id="part0027_ch14fn-3">3</a></sup>: Distance. <em class="calibre9">D</em> = |<em class="calibre9">A</em>+<em class="calibre9">I</em>–1| . The range of this metric is [0, 1]. A value of 0 indicates that the component is directly on the Main Sequence. A value of 1 indicates that the component is as far away as possible from the Main Sequence.</p>
<p class="noindent1"><a id="part0027_page_131"></a>Given this metric, a design can be analyzed for its overall conformance to the Main Sequence. The <em class="calibre9">D</em> metric for each component can be calculated. Any component that has a <em class="calibre9">D</em> value that is not near zero can be reexamined and restructured.</p>
<p class="noindent1">Statistical analysis of a design is also possible. We can calculate the mean and variance of all the <em class="calibre9">D</em> metrics for the components within a design. We would expect a conforming design to have a mean and variance that are close to zero. The variance can be used to establish “control limits” so as to identify components that are “exceptional” in comparison to all the others.</p>
<p class="noindent1">In the scatterplot in <a href="#part0027_ch14fig14">Figure 14.14</a>, we see that the bulk of the components lie along the Main Sequence, but some of them are more than one standard deviation (<em class="calibre9">Z</em> = 1) away from the mean. These aberrant components are worth examining more closely. For some reason, they are either very abstract with few dependents or very concrete with many dependents.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00060.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig14"></a><strong class="calibre8">Figure 14.14</strong> Scatterplot of the components</p>
</div>
<p class="noindent1">Another way to use the metrics is to plot the <em class="calibre9">D</em> metric of each component over time. The graph in <a href="#part0027_ch14fig15">Figure 14.15</a> is a mock-up of such a plot. You can see <a id="part0027_page_132"></a>that some strange dependencies have been creeping into the <code class="calibre11">Payroll</code> component over the last few releases. The plot shows a control threshold at <em class="calibre9">D</em> = 0.1. The R2.1 point has exceeded this control limit, so it would be worth our while to find out why this component is so far from the main sequence.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00061.jpeg"/></div>
<p class="fig-caption"><a id="part0027_ch14fig15"></a><strong class="calibre8">Figure 14.15</strong> Plot of D for a single component over time</p>
</div>
<h3 class="h1" id="part0027_toclev_64">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The <em class="calibre9">dependency management metrics</em> described in this chapter measure the conformance of a design to a pattern of dependency and abstraction that I think is a “good” pattern. Experience has shown that certain dependencies are good and others are bad. This pattern reflects that experience. However, a metric is not a god; it is merely a measurement against an arbitrary standard. These metrics are imperfect, at best, but it is my hope that you find them useful.</p>
<p class="fn"><a href="#part0027_ch14fn-1" id="part0027_ch14fn1">1</a>. In previous publications, I used the names <em class="calibre9">Efferent</em> and <em class="calibre9">Afferent</em> couplings (Ce and Ca) for <em class="calibre9">Fan-out</em> and Fan-in, respectively. That was just hubris on my part: I liked the metaphor of the central nervous system.</p>
<p class="fn"><a href="#part0027_ch14fn-2" id="part0027_ch14fn2">2</a>. The author begs the reader’s indulgence for the arrogance of borrowing such an important term from astronomy.</p>
<p class="fn"><a href="#part0027_ch14fn-3" id="part0027_ch14fn3">3</a>. In previous publications, I called this metric D′. I see no reason to continue that practice.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0028_part5"><a class="calibre3" id="part0028_page_133"></a><span class="gray">V</span><br class="calibre12"/>A<small class="calibre7">RCHITECTURE</small><a class="calibre3" id="part0028_page_134"></a></h2>
</body><body class="calibre">
<h2 class="h2f" id="part0029_ch15"><a class="calibre3" id="part0029_page_135"></a><span class="gray">15</span><br class="calibre12"/>W<small class="calibre7">HAT</small> I<small class="calibre7">S</small> A<small class="calibre7">RCHITECTURE</small>?</h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00062.jpeg"/></div>
<p class="noindent1"><a id="part0029_page_136"></a>The word “architecture” conjures visions of power and mystery. It makes us think of weighty decisions and deep technical prowess. Software architecture is at the pinnacle of technical achievement. When we think of a software architect, we think of someone who has power, and who commands respect. What young aspiring software developer has not dreamed of one day becoming a software architect?</p>
<p class="noindent1">But what is software architecture? What does a software architect do, and when does he or she do it?</p>
<p class="noindent1">First of all, a software architect is a programmer; and continues to be a programmer. Never fall for the lie that suggests that software architects pull back from code to focus on higher-level issues. They do not! Software architects are the best programmers, and they continue to take programming tasks, while they also guide the rest of the team toward a design that maximizes productivity. Software architects may not write as much code as other programmers do, but they continue to engage in programming tasks. They do this because they cannot do their jobs properly if they are not experiencing the problems that they are creating for the rest of the programmers.</p>
<p class="noindent1">The architecture of a software system is the shape given to that system by those who build it. The form of that shape is in the division of that system into components, the arrangement of those components, and the ways in which those components communicate with each other.</p>
<p class="noindent1">The purpose of that shape is to facilitate the development, deployment, operation, and maintenance of the software system contained within it.</p>
<p class="blockquote"><em class="calibre9">The strategy behind that facilitation is to leave as many options open as possible, for as long as possible</em>.</p>
<p class="noindent1">Perhaps this statement has surprised you. Perhaps you thought that the goal of software architecture was to make the system work properly. Certainly we want the system to work properly, and certainly the architecture of the system must support that as one of its highest priorities.</p>
<p class="noindent1"><a id="part0029_page_137"></a>However, the architecture of a system has very little bearing on whether that system works. There are many systems out there, with terrible architectures, that work just fine. Their troubles do not lie in their operation; rather, they occur in their deployment, maintenance, and ongoing development.</p>
<p class="noindent1">This is not to say that architecture plays no role in supporting the proper behavior of the system. It certainly does, and that role is critical. But the role is passive and cosmetic, not active or essential. There are few, if any, <em class="calibre9">behavioral</em> options that the architecture of a system can leave open.</p>
<p class="noindent1">The primary purpose of architecture is to support the life cycle of the system. Good architecture makes the system easy to understand, easy to develop, easy to maintain, and easy to deploy. The ultimate goal is to minimize the lifetime cost of the system and to maximize programmer productivity.</p>
<h3 class="h1" id="part0029_toclev_65">D<small class="calibre13">EVELOPMENT</small></h3>
<p class="noindent1">A software system that is hard to develop is not likely to have a long and healthy lifetime. So the architecture of a system should make that system easy to develop, for the team(s) who develop it.</p>
<p class="noindent1">Different team structures imply different architectural decisions. On the one hand, a small team of five developers can quite effectively work together to develop a monolithic system without well-defined components or interfaces. In fact, such a team would likely find the strictures of an architecture something of an impediment during the early days of development. This is likely the reason why so many systems lack good architecture: They were begun with none, because the team was small and did not want the impediment of a superstructure.</p>
<p class="noindent1">On the other hand, a system being developed by five different teams, each of which includes seven developers, cannot make progress unless the system is divided into well-defined components with reliably stable interfaces. If no other factors are considered, the architecture of that system will likely evolve into five components—one for each team.</p>
<p class="noindent1"><a id="part0029_page_138"></a>Such a component-per-team architecture is not likely to be the best architecture for deployment, operation, and maintenance of the system. Nevertheless, it is the architecture that a group of teams will gravitate toward if they are driven solely by development schedule.</p>
<h3 class="h1" id="part0029_toclev_66">D<small class="calibre13">EPLOYMENT</small></h3>
<p class="noindent1">To be effective, a software system must be deployable. The higher the cost of deployment, the less useful the system is. A goal of a software architecture, then, should be to make a system that can be easily deployed <em class="calibre9">with a single action</em>.</p>
<p class="noindent1">Unfortunately, deployment strategy is seldom considered during initial development. This leads to architectures that may make the system easy to develop, but leave it very difficult to deploy.</p>
<p class="noindent1">For example, in the early development of a system, the developers may decide to use a “micro-service architecture.” They may find that this approach makes the system very easy to develop since the component boundaries are very firm and the interfaces relatively stable. However, when it comes time to deploy the system, they may discover that the number of micro-services has become daunting; configuring the connections between them, and the timing of their initiation, may also turn out to be a huge source of errors.</p>
<p class="noindent1">Had the architects considered deployment issues early on, they might have decided on fewer services, a hybrid of services and in-process components, and a more integrated means of managing the interconnections.</p>
<h3 class="h1" id="part0029_toclev_67">O<small class="calibre13">PERATION</small></h3>
<p class="noindent1">The impact of architecture on system operation tends to be less dramatic than the impact of architecture on development, deployment, and maintenance. Almost any operational difficulty can be resolved by throwing more hardware at the system without drastically impacting the software architecture.</p>
<p class="noindent1"><a id="part0029_page_139"></a>Indeed, we have seen this happen over and over again. Software systems that have inefficient architectures can often be made to work effectively simply by adding more storage and more servers. The fact that hardware is cheap and people are expensive means that architectures that impede operation are not as costly as architectures that impede development, deployment, and maintenance.</p>
<p class="noindent1">This is not to say that an architecture that is well tuned to the operation of the system is not desirable. It is! It’s just that the cost equation leans more toward development, deployment, and maintenance.</p>
<p class="noindent1">Having said that, there is another role that architecture plays in the operation of the system: A good software architecture communicates the operational needs of the system.</p>
<p class="noindent1">Perhaps a better way to say this is that the architecture of a system makes the operation of the system readily apparent to the developers. Architecture should reveal operation. The architecture of the system should elevate the use cases, the features, and the required behaviors of the system to first-class entities that are visible landmarks for the developers. This simplifies the understanding of the system and, therefore, greatly aids in development and maintenance.</p>
<h3 class="h1" id="part0029_toclev_68">M<small class="calibre13">AINTENANCE</small></h3>
<p class="noindent1">Of all the aspects of a software system, maintenance is the most costly. The never-ending parade of new features and the inevitable trail of defects and corrections consume vast amounts of human resources.</p>
<p class="noindent1">The primary cost of maintenance is in <em class="calibre9">spelunking</em> and risk. Spelunking is the cost of digging through the existing software, trying to determine the best place and the best strategy to add a new feature or to repair a defect. While making such changes, the likelihood of creating inadvertent defects is always there, adding to the cost of risk.</p>
<p class="noindent1"><a id="part0029_page_140"></a>A carefully thought-through architecture vastly mitigates these costs. By separating the system into components, and isolating those components through stable interfaces, it is possible to illuminate the pathways for future features and greatly reduce the risk of inadvertent breakage.</p>
<h3 class="h1" id="part0029_toclev_69">K<small class="calibre13">EEPING</small> O<small class="calibre13">PTIONS</small> O<small class="calibre13">PEN</small></h3>
<p class="noindent1">As we described in an earlier chapter, software has two types of value: the value of its behavior and the value of its structure. The second of these is the greater of the two because it is this value that makes software <em class="calibre9">soft</em>.</p>
<p class="noindent1">Software was invented because we needed a way to quickly and easily change the behavior of machines. But that flexibility depends critically on the shape of the system, the arrangement of its components, and the way those components are interconnected.</p>
<p class="noindent1">The way you keep software soft is to leave as many options open as possible, for as long as possible. What are the options that we need to leave open? <em class="calibre9">They are the details that don’t matter.</em></p>
<p class="noindent1">All software systems can be decomposed into two major elements: policy and details. The policy element embodies all the business rules and procedures. The policy is where the true value of the system lives.</p>
<p class="noindent1">The details are those things that are necessary to enable humans, other systems, and programmers to communicate with the policy, but that do not impact the behavior of the policy at all. They include IO devices, databases, web systems, servers, frameworks, communication protocols, and so forth.</p>
<p class="noindent1">The goal of the architect is to create a shape for the system that recognizes policy as the most essential element of the system while making the details <em class="calibre9">irrelevant</em> to that policy. This allows decisions about those details to be <em class="calibre9">delayed</em> and <em class="calibre9">deferred</em>.</p>
<p class="noindent1"><a id="part0029_page_141"></a>For example:</p>
<p class="indenthangingb">• It is not necessary to choose a database system in the early days of development, because the high-level policy should not care which kind of database will be used. Indeed, if the architect is careful, the high-level policy will not care if the database is relational, distributed, hierarchical, or just plain flat files.</p>
<p class="indenthangingb">• It is not necessary to choose a web server early in development, because the high-level policy should not know that it is being delivered over the web. If the high-level policy is unaware of HTML, AJAX, JSP, JSF, or any of the rest of the alphabet soup of web development, then you don’t need to decide which web system to use until much later in the project. Indeed, <em class="calibre9">you don’t even have to decide if the system will be delivered over the web</em>.</p>
<p class="indenthangingb">• It is not necessary to adopt REST early in development, because the high-level policy should be agnostic about the interface to the outside world. Nor is it necessary to adopt a micro-services framework, or a SOA framework. Again, the high-level policy should not care about these things.</p>
<p class="indenthangingb">• It is not necessary to adopt a dependency injection framework early in development, because the high-level policy should not care how dependencies are resolved.</p>
<p class="noindent1">I think you get the point. If you can develop the high-level policy without committing to the details that surround it, you can delay and defer decisions about those details for a long time. And the longer you wait to make those decisions, <em class="calibre9">the more information you have with which to make them properly</em>.</p>
<p class="noindent1">This also leaves you the option to try different experiments. If you have a portion of the high-level policy working, and it is agnostic about the database, you could try connecting it to several different databases to check applicability and performance. The same is true with web systems, web frameworks, or even the web itself.</p>
<p class="noindent1">The longer you leave options open, the more experiments you can run, the more things you can try, and the more information you will have when you reach the point at which those decisions can no longer be deferred.</p>
<p class="noindent1"><a id="part0029_page_142"></a>What if the decisions have already been made by someone else? What if your company has made a commitment to a certain database, or a certain web server, or a certain framework? <em class="calibre9">A good architect pretends that the decision has not been made</em>, and shapes the system such that those decisions can still be deferred or changed for as long as possible.</p>
<p class="blockquote"><em class="calibre9">A good architect maximizes the number of decisions not made.</em></p>
<h3 class="h1" id="part0029_toclev_70">D<small class="calibre13">EVICE</small> I<small class="calibre13">NDEPENDENCE</small></h3>
<p class="noindent1">As an example of this kind of thinking, let’s take a trip back to the 1960s, when computers were teenagers and most programmers were mathematicians or engineers from other disciplines (and-one third or more were women).</p>
<p class="noindent1">In those days we made a lot of mistakes. We didn’t know they were mistakes at the time, of course. How could we?</p>
<p class="noindent1">One of those mistakes was to bind our code directly to the IO devices. If we needed to print something on a printer, we wrote code that used the IO instructions that would control the printer. Our code was <em class="calibre9">device dependent</em>.</p>
<p class="noindent1">For example, when I wrote PDP-8 programs that printed on the teleprinter, I used a set of machine instructions that looked like this:</p>
<p class="codelink"><a href="#part0058_split_001_pch15ex01a" id="part0029_pch15ex01">Click here to view code image</a></p>
<p class="pre2">PRTCHR, 0<br class="calibre6"/>
        TSF<br class="calibre6"/>
        JMP .-1<br class="calibre6"/>
        TLS<br class="calibre6"/>
        JMP I PRTCHR</p>
<p class="noindent1"><code class="calibre11">PRTCHR</code> is a subroutine that prints one character on the teleprinter. The beginning zero was used as the storage for the return address. (Don’t ask.) The <code class="calibre11">TSF</code> instruction skipped the next instruction if the teleprinter was ready to print a character. If the teleprinter was busy, then <code class="calibre11">TSF</code> just fell through to <a id="part0029_page_143"></a>the <code class="calibre11">JMP .-1</code> instruction, which just jumped back to the <code class="calibre11">TSF</code> instruction. If the teleprinter was ready, then <code class="calibre11">TSF</code> would skip to the <code class="calibre11">TLS</code> instruction, which sent the character in the <code class="calibre11">A</code> register to the teleprinter. Then the <code class="calibre11">JMP I PRTCHR</code> instruction returned to the caller.</p>
<p class="noindent1">At first this strategy worked fine. If we needed to read cards from the card reader, we used code that talked directly to the card reader. If we needed to punch cards, we wrote code that directly manipulated the punch. The programs worked perfectly. How could we know this was a mistake?</p>
<p class="noindent1">But big batches of punched cards are difficult to manage. They can be lost, mutilated, spindled, shuffled, or dropped. Individual cards can be lost and extra cards can be inserted. So data integrity became a significant problem.</p>
<p class="noindent1">Magnetic tape was the solution. We could move the card images to tape. If you drop a magnetic tape, the records don’t get shuffled. You can’t accidentally lose a record, or insert a blank record simply by handing the tape. The tape is much more secure. It’s also faster to read and write, and it is very easy to make backup copies.</p>
<p class="noindent1">Unfortunately, all our software was written to manipulate card readers and card punches. Those programs had to be rewritten to use magnetic tape. That was a big job.</p>
<p class="noindent1">By the late 1960s, we had learned our lesson—and we invented <em class="calibre9">device independence</em>. The operating systems of the day abstracted the IO devices into software functions that handled unit records that looked like cards. The programs would invoke operating system services that dealt with abstract unit-record devices. Operators could tell the operating system whether those abstract services should be connected to card readers, magnetic tape, or any other unit-record device.</p>
<p class="noindent1">Now the same program could read and write cards, or read and write tape, <em class="calibre9">without any change</em>. The Open–Closed Principle was born (but not yet named).</p>
<h3 class="h1" id="part0029_toclev_71"><a class="calibre3" id="part0029_page_144"></a>J<small class="calibre13">UNK</small> M<small class="calibre13">AIL</small></h3>
<p class="noindent1">In the late 1960s, I worked for a company that printed junk mail for clients. The clients would send us magnetic tapes with unit records containing the names and addresses of their customers, and we would write programs that printed nice personalized advertisements.</p>
<p class="noindent1">You know the kind:</p>
<p class="noindentn">Hello Mr. Martin,</p>
<p class="noindentn">Congratulations!</p>
<p class="noindentn">We chose YOU from everyone else who lives on Witchwood Lane to participate in our new fantastic one-time-only offering…</p>
<p class="noindent1">The clients would send us huge rolls of form letters with all the words except the name and address, and any other element they wanted us to print. We wrote programs that extracted the names, addresses, and other elements from the magnetic tape, and printed those elements exactly where they needed to appear on the forms.</p>
<p class="noindent1">These rolls of form letters weighed 500 pounds and contained thousands of letters. Clients would send us hundreds of these rolls. We would print each one individually.</p>
<p class="noindent1">At first, we had an IBM 360 doing the printing on its sole line printer. We could print a few thousand letters per shift. Unfortunately, this tied up a very expensive machine for a very long time. In those days, IBM 360s rented for tens of thousands of dollars per month.</p>
<p class="noindent1">So we told the operating system to use magnetic tape instead of the line printer. Our programs didn’t care, because they had been written to use the IO abstractions of the operating system.</p>
<p class="noindent1">The 360 could pump out a full tape in 10 minutes or so—enough to print several rolls of form letters. The tapes were taken outside of the computer <a id="part0029_page_145"></a>room and mounted on tape drives connected to offline printers. We had five of them, and we ran those five printers 24 hours per day, seven days per week, printing hundreds of thousands of pieces of junk mail every week.</p>
<p class="noindent1">The value of device independence was enormous! We could write our programs without knowing or caring which device would be used. We could test those programs using the local line printer connected to the computer. Then we could tell the operating system to “print” to magnetic tape and run off hundreds of thousands of forms.</p>
<p class="noindent1">Our programs had a shape. That shape disconnected policy from detail. The policy was the formatting of the name and address records. The detail was the device. We deferred the decision about which device we would use.</p>
<h3 class="h1" id="part0029_toclev_72">P<small class="calibre13">HYSICAL</small> A<small class="calibre13">DDRESSING</small></h3>
<p class="noindent1">In the early 1970s, I worked on a large accounting system for a local truckers union. We had a 25MB disk drive on which we stored records for <code class="calibre11">Agents</code>, <code class="calibre11">Employers</code>, and <code class="calibre11">Members</code>. The different records had different sizes, so we formatted the first few cylinders of the disk so that each sector was just the size of an <code class="calibre11">Agent</code> record. The next few cylinders were formatted to have sectors that fit the <code class="calibre11">Employer</code> records. The last few cylinders were formatted to fit the <code class="calibre11">Member</code> records.</p>
<p class="noindent1">We wrote our software to know the detailed structure of the disk. It knew that the disk had 200 cylinders and 10 heads, and that each cylinder had several dozen sectors per head. It knew which cylinders held the <code class="calibre11">Agents</code>, <code class="calibre11">Employers</code>, and <code class="calibre11">Members</code>. All this was hard-wired into the code.</p>
<p class="noindent1">We kept an index on the disk that allowed us to look up each of the <code class="calibre11">Agents</code>, <code class="calibre11">Employers</code>, and <code class="calibre11">Members</code>. This index was in yet another specially formatted set of cylinders on the disk. The <code class="calibre11">Agent</code> index was composed of records that contained the ID of an agent, and the cylinder number, head number, and sector number of that <code class="calibre11">Agent</code> record. <code class="calibre11">Employers</code> and <code class="calibre11">Members</code> had similar indices. <code class="calibre11">Members</code> were also kept in a doubly linked list on the disk. Each <a id="part0029_page_146"></a><code class="calibre11">Member</code> record held the cylinder, head, and sector number of the next <code class="calibre11">Member</code> record, and of the previous <code class="calibre11">Member</code> record.</p>
<p class="noindent1">What would happen if we needed to upgrade to a new disk drive—one with more heads, or one with more cylinders, or one with more sectors per cylinder? We had to write a special program to read in the old data from the old disk, and then write it out to the new disk, translating all of the cylinder/head/sector numbers. We also had to change all the hard-wiring in our code—and that hard-wiring was <em class="calibre9">everywhere</em>! All the business rules knew the cylinder/head/sector scheme in detail.</p>
<p class="noindent1">One day a more experienced programmer joined our ranks. When he saw what we had done, the blood drained from his face, and he stared aghast at us, as if we were aliens of some kind. Then he gently advised us to change our addressing scheme to use relative addresses.</p>
<p class="noindent1">Our wiser colleague suggested that we consider the disk to be one huge linear array of sectors, each addressable by a sequential integer. Then we could write a little conversion routine that knew the physical structure of the disk, and could translate the relative address to a cylinder/head/sector number on the fly.</p>
<p class="noindent1">Fortunately for us, we took his advice. We changed the high-level policy of the system to be agnostic about the physical structure of the disk. That allowed us to decouple the decision about disk drive structure from the application.</p>
<h3 class="h1" id="part0029_toclev_73">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The two stories in this chapter are examples, in the small, of a principle that architects employ in the large. Good architects carefully separate details from policy, and then decouple the policy from the details so thoroughly that the policy has no knowledge of the details and does not depend on the details in any way. Good architects design the policy so that decisions about the details can be delayed and deferred for as long as possible.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0030_ch16"><a class="calibre3" id="part0030_page_147"></a><span class="gray">16</span><br class="calibre12"/>I<small class="calibre7">NDEPENDENCE</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00063.jpeg"/></div>
<p class="noindent1"><a id="part0030_page_148"></a>As we previously stated, a good architecture must support:</p>
<p class="indenthangingb">• The use cases and operation of the system.</p>
<p class="indenthangingb">• The maintenance of the system.</p>
<p class="indenthangingb">• The development of the system.</p>
<p class="indenthangingb">• The deployment of the system.</p>
<h3 class="h1" id="part0030_toclev_74">U<small class="calibre13">SE</small> C<small class="calibre13">ASES</small></h3>
<p class="noindent1">The first bullet—use cases—means that the architecture of the system must support the intent of the system. If the system is a shopping cart application, then the architecture must support shopping cart use cases. Indeed, this is the first concern of the architect, and the first priority of the architecture. The architecture must support the use cases.</p>
<p class="noindent1">However, as we discussed previously, architecture does not wield much influence over the behavior of the system. There are very few behavioral options that the architecture can leave open. But influence isn’t everything. The most important thing a good architecture can do to support behavior is to clarify and expose that behavior so that the intent of the system is visible at the architectural level.</p>
<p class="noindent1">A shopping cart application with a good architecture will <em class="calibre9">look</em> like a shopping cart application. The use cases of that system will be plainly visible within the structure of that system. Developers will not have to hunt for behaviors, because those behaviors will be first-class elements visible at the top level of the system. Those elements will be classes or functions or modules that have prominent positions within the architecture, and they will have names that clearly describe their function.</p>
<p class="noindent1"><a href="#part0035_ch21">Chapter 21</a>, “Screaming Architecture,” will make this point much clearer.</p>
<h3 class="h1" id="part0030_toclev_75"><a class="calibre3" id="part0030_page_149"></a>O<small class="calibre13">PERATION</small></h3>
<p class="noindent1">Architecture plays a more substantial, and less cosmetic, role in supporting the operation of the system. If the system must handle 100,000 customers per second, the architecture must support that kind of throughput and response time for each use case that demands it. If the system must query big data cubes in milliseconds, then the architecture must be structured to allow this kind of operation.</p>
<p class="noindent1">For some systems, this will mean arranging the processing elements of the system into an array of little services can be run in parallel on many different servers. For other systems, it will mean a plethora of little lightweight threads sharing the address space of a single process within a single processor. Still other systems will need just a few processes running in isolated address spaces. And some systems can even survive as simple monolithic programs running in a single process.</p>
<p class="noindent1">As strange as it may seem, this decision is one of the options that a good architect leaves open. A system that is written as a monolith, and that depends on that monolithic structure, cannot easily be upgraded to multiple processes, multiple threads, or micro-services should the need arise. By comparison, an architecture that maintains the proper isolation of its components, and does not assume the means of communication between those components, will be much easier to transition through the spectrum of threads, processes, and services as the operational needs of the system change over time.</p>
<h3 class="h1" id="part0030_toclev_76">D<small class="calibre13">EVELOPMENT</small></h3>
<p class="noindent1">Architecture plays a significant role in supporting the development environment. This is where Conway’s law comes into play. Conway’s law says:</p>
<p class="blockquote"><em class="calibre9">Any organization that designs a system will produce a design whose structure is a copy of the organization’s communication structure.</em></p>
<p class="noindent1"><a id="part0030_page_150"></a>A system that must be developed by an organization with many teams and many concerns must have an architecture that facilitates independent actions by those teams, so that the teams do not interfere with each other during development. This is accomplished by properly partitioning the system into well-isolated, independently developable components. Those components can then be allocated to teams that can work independently of each other.</p>
<h3 class="h1" id="part0030_toclev_77">D<small class="calibre13">EPLOYMENT</small></h3>
<p class="noindent1">The architecture also plays a huge role in determining the ease with which the system is deployed. The goal is “immediate deployment.” A good architecture does not rely on dozens of little configuration scripts and property file tweaks. It does not require manual creation of directories or files that must be arranged just so. A good architecture helps the system to be immediately deployable after build.</p>
<p class="noindent1">Again, this is achieved through the proper partitioning and isolation of the components of the system, including those master components that tie the whole system together and ensure that each component is properly started, integrated, and supervised.</p>
<h3 class="h1" id="part0030_toclev_78">L<small class="calibre13">EAVING</small> O<small class="calibre13">PTIONS</small> O<small class="calibre13">PEN</small></h3>
<p class="noindent1">A good architecture balances all of these concerns with a component structure that mutually satisfies them all. Sounds easy, right? Well, it’s easy for me to write that.</p>
<p class="noindent1">The reality is that achieving this balance is pretty hard. The problem is that most of the time we don’t know what all the use cases are, nor do we know the operational constraints, the team structure, or the deployment requirements. Worse, even if we did know them, they will inevitably change as the system moves through its life cycle. In short, the goals we must meet are indistinct and inconstant. Welcome to the real world.</p>
<p class="noindent1"><a id="part0030_page_151"></a>But all is not lost: Some principles of architecture are relatively inexpensive to implement and can help balance those concerns, even when you don’t have a clear picture of the targets you have to hit. Those principles help us partition our systems into well-isolated components that allow us to leave as many options open as possible, for as long as possible.</p>
<p class="noindent1">A good architecture makes the system easy to change, in all the ways that it must change, by leaving options open.</p>
<h3 class="h1" id="part0030_toclev_79">D<small class="calibre13">ECOUPLING</small> L<small class="calibre13">AYERS</small></h3>
<p class="noindent1">Consider the use cases. The architect wants the structure of the system to support all the necessary use cases, but does not know what all those use cases are. However, the architect <em class="calibre9">does</em> know the basic intent of the system. It’s a shopping cart system, or it’s a bill of materials system, or it’s an order processing system. So the architect can employ the Single Responsibility Principle and the Common Closure Principle to separate those things that change for different reasons, and to collect those things that change for the same reasons—given the context of the intent of the system.</p>
<p class="noindent1">What changes for different reasons? There are some obvious things. User interfaces change for reasons that have nothing to do with business rules. Use cases have elements of both. Clearly, then, a good architect will want to separate the UI portions of a use case from the business rule portions in such a way that they can be changed independently of each other, while keeping those use cases visible and clear.</p>
<p class="noindent1">Business rules themselves may be closely tied to the application, or they may be more general. For example, the validation of input fields is a business rule that is closely tied to the application itself. In contrast, the calculation of interest on an account and the counting of inventory are business rules that are more closely associated with the domain. These two different kinds of rules will change at different rates, and for different reasons—so they should be separated so that they can be independently changed.</p>
<p class="noindent1"><a id="part0030_page_152"></a>The database, the query language, and even the schema are technical details that have nothing to do with the business rules or the UI. They will change at rates, and for reasons, that are independent of other aspects of the system. Consequently, the architecture should separate them from the rest of the system so that they can be independently changed.</p>
<p class="noindent1">Thus we find the system divided into decoupled horizontal layers—the UI, application-specific business rules, application-independent business rules, and the database, just to mention a few.</p>
<h3 class="h1" id="part0030_toclev_80">D<small class="calibre13">ECOUPLING</small> U<small class="calibre13">SE</small> C<small class="calibre13">ASES</small></h3>
<p class="noindent1">What else changes for different reasons? The use cases themselves! The use case for adding an order to an order entry system almost certainly will change at a different rate, and for different reasons, than the use case that deletes an order from the system. Use cases are a very natural way to divide the system.</p>
<p class="noindent1">At the same time, use cases are narrow vertical slices that cut through the horizontal layers of the system. Each use case uses some UI, some application-specific business rules, some application-independent business rules, and some database functionality. Thus, as we are dividing the system in to horizontal layers, we are also dividing the system into thin vertical use cases that cut through those layers.</p>
<p class="noindent1">To achieve this decoupling, we separate the UI of the add-order use case from the UI of the delete-order use case. We do the same with the business rules, and with the database. We keep the use cases separate down the vertical height of the system.</p>
<p class="noindent1">You can see the pattern here. If you decouple the elements of the system that change for different reasons, then you can continue to add new use cases without interfering with old ones. If you also group the UI and database in support of those use cases, so that each use case uses a different aspect of the UI and database, then adding new use cases will be unlikely to affect older ones.</p>
<h3 class="h1" id="part0030_toclev_81"><a class="calibre3" id="part0030_page_153"></a>D<small class="calibre13">ECOUPLING</small> M<small class="calibre13">ODE</small></h3>
<p class="noindent1">Now think of what all that decoupling means for the second bullet: operations. If the different aspects of the use cases are separated, then those that must run at a high throughput are likely already separated from those that must run at a low throughput. If the UI and the database have been separated from the business rules, then they can run in different servers. Those that require higher bandwidth can be replicated in many servers.</p>
<p class="noindent1">In short, the decoupling that we did for the sake of the use cases also helps with operations. However, to take advantage of the operational benefit, the decoupling must have the appropriate mode. To run in separate servers, the separated components cannot depend on being together in the same address space of a processor. They must be independent services, which communicate over a network of some kind.</p>
<p class="noindent1">Many architects call such components “services” or “micro-services,” depending upon some vague notion of line count. Indeed, an architecture based on services is often called a service-oriented architecture.</p>
<p class="noindent1">If that nomenclature set off some alarm bells in your mind, don’t worry. I’m not going to tell you that SoA is the best possible architecture, or that micro-services are the wave of the future. The point being made here is that sometimes we have to separate our components all the way to the service level.</p>
<p class="noindent1">Remember, a good architecture leaves options open. <em class="calibre9">The decoupling mode is one of those options.</em></p>
<p class="noindent1">Before we explore that topic further, let’s look to the other two bullets.</p>
<h3 class="h1" id="part0030_toclev_82">I<small class="calibre13">NDEPENDENT</small> D<small class="calibre13">EVELOP-ABILITY</small></h3>
<p class="noindent1">The third bullet was development. Clearly when components are strongly decoupled, the interference between teams is mitigated. If the business rules <a id="part0030_page_154"></a>don’t know about the UI, then a team that focuses on the UI cannot much affect a team that focuses on the business rules. If the use cases themselves are decoupled from one another, then a team that focuses on the <code class="calibre11">addOrder</code> use case is not likely to interfere with a team that focuses on the <code class="calibre11">deleteOrder</code> use case.</p>
<p class="noindent1">So long as the layers and use cases are decoupled, the architecture of the system will support the organization of the teams, irrespective of whether they are organized as feature teams, component teams, layer teams, or some other variation.</p>
<h3 class="h1" id="part0030_toclev_83">I<small class="calibre13">NDEPENDENT</small> D<small class="calibre13">EPLOYABILITY</small></h3>
<p class="noindent1">The decoupling of the use cases and layers also affords a high degree of flexibility in deployment. Indeed, if the decoupling is done well, then it should be possible to hot-swap layers and use cases in running systems. Adding a new use case could be a simple as adding a few new jar files or services to the system while leaving the rest alone.</p>
<h3 class="h1" id="part0030_toclev_84">D<small class="calibre13">UPLICATION</small></h3>
<p class="noindent1">Architects often fall into a trap—a trap that hinges on their fear of duplication.</p>
<p class="noindent1">Duplication is generally a bad thing in software. We don’t like duplicated code. When code is truly duplicated, we are honor-bound as professionals to reduce and eliminate it.</p>
<p class="noindent1">But there are different kinds of duplication. There is true duplication, in which every change to one instance necessitates the same change to every duplicate of that instance. Then there is false or accidental duplication. If two apparently duplicated sections of code evolve along different paths—if they change at different rates, and for different reasons—<em class="calibre9">then they are not</em> <a id="part0030_page_155"></a><em class="calibre9">true duplicates.</em> Return to them in a few years, and you’ll find that they are very different from each other.</p>
<p class="noindent1">Now imagine two use cases that have very similar screen structures. The architects will likely be strongly tempted to share the code for that structure. But should they? Is that true duplication? Or it is accidental?</p>
<p class="noindent1">Most likely it is accidental. As time goes by, the odds are that those two screens will diverge and eventually look very different. For this reason, care must be taken to avoid unifying them. Otherwise, separating them later will be a challenge.</p>
<p class="noindent1">When you are vertically separating use cases from one another, you will run into this issue, and your temptation will be to couple the use cases because they have similar screen structures, or similar algorithms, or similar database queries and/or schemas. Be careful. Resist the temptation to commit the sin of knee-jerk elimination of duplication. Make sure the duplication is real.</p>
<p class="noindent1">By the same token, when you are separating layers horizontally, you might notice that the data structure of a particular database record is very similar to the data structure of a particular screen view. You may be tempted to simply pass the database record up to the UI, rather than to create a view model that looks the same and copy the elements across. Be careful: This duplication is almost certainly accidental. Creating the separate view model is not a lot of effort, and it will help you keep the layers properly decoupled.</p>
<h3 class="h1" id="part0030_toclev_85">D<small class="calibre13">ECOUPLING</small> M<small class="calibre13">ODES</small> (A<small class="calibre13">GAIN</small>)</h3>
<p class="noindent1">Back to modes. There are many ways to decouple layers and use cases. They can be decoupled at the source code level, at the binary code (deployment) level, and at the execution unit (service) level.</p>
<p class="indenthangingb">• <strong class="calibre8">Source level.</strong> We can control the dependencies between source code modules so that changes to one module do not force changes or recompilation of others (e.g., Ruby Gems).</p>
<p class="indenthangingbp"><a id="part0030_page_156"></a>In this decoupling mode the components all execute in the same address space, and communicate with each other using simple function calls. There is a single executable loaded into computer memory. People often call this a monolithic structure.</p>
<p class="indenthangingb">• <strong class="calibre8">Deployment level.</strong> We can control the dependencies between deployable units such as jar files, DLLs, or shared libraries, so that changes to the source code in one module do not force others to be rebuilt and redeployed.</p>
<p class="indenthangingbp">Many of the components may still live in the same address space, and communicate through function calls. Other components may live in other processes in the same processor, and communicate through interprocess communications, sockets, or shared memory. The important thing here is that the decoupled components are partitioned into independently deployable units such as jar files, Gem files, or DLLs.</p>
<p class="indenthangingb">• <strong class="calibre8">Service level</strong>. We can reduce the dependencies down to the level of data structures, and communicate solely through network packets such that every execution unit is entirely independent of source and binary changes to others (e.g., services or micro-services).</p>
<p class="noindent1">What is the best mode to use?</p>
<p class="noindent1">The answer is that it’s hard to know which mode is best during the early phases of a project. Indeed, as the project matures, the optimal mode may change.</p>
<p class="noindent1">For example, it’s not difficult to imagine that a system that runs comfortably on one server right now might grow to the point where some of its components ought to run on separate servers. While the system runs on a single server, the source-level decoupling might be sufficient. Later, however, it might require decoupling into deployable units, or even services.</p>
<p class="noindent1">One solution (which seems to be popular at the moment) is to simply decouple at the service level by default. A problem with this approach is that it is expensive and encourages coarse-grained decoupling. No matter how “micro” the micro-services get, the decoupling is not likely to be fine-grained enough.</p>
<p class="noindent1"><a id="part0030_page_157"></a>Another problem with service-level decoupling is that it is expensive, both in development time and in system resources. Dealing with service boundaries where none are needed is a waste of effort, memory, and cycles. And, yes, I know that the last two are cheap—but the first is not.</p>
<p class="noindent1">My preference is to push the decoupling to the point where a service <em class="calibre9">could</em> be formed. should it become necessary; but then to leave the components in the same address space as long as possible. This leaves the option for a service open.</p>
<p class="noindent1">With this approach, initially the components are separated at the source code level. That may be good enough for the duration of the project’s lifetime. If, however, deployment or development issues arise, driving some of the decoupling to a deployment level may be sufficient—at least for a while.</p>
<p class="noindent1">As the development, deployment, and operational issues increase, I carefully choose which deployable units to turn into services, and gradually shift the system in that direction.</p>
<p class="noindent1">Over time, the operational needs of the system may decline. What once required decoupling at the service level may now require only deployment-level or even source-level decoupling.</p>
<p class="noindent1">A good architecture will allow a system to be born as a monolith, deployed in a single file, but then to grow into a set of independently deployable units, and then all the way to independent services and/or micro-services. Later, as things change, it should allow for reversing that progression and sliding all the way back down into a monolith.</p>
<p class="noindent1">A good architecture protects the majority of the source code from those changes. It leaves the decoupling mode open as an option so that large deployments can use one mode, whereas small deployments can use another.</p>
<h3 class="h1" id="part0030_toclev_86"><a class="calibre3" id="part0030_page_158"></a>C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">Yes, this is tricky. And I’m not saying that the change of decoupling modes should be a trivial configuration option (though sometimes that <em class="calibre9">is</em> appropriate). What I’m saying is that the decoupling mode of a system is one of those things that is likely to change with time, and a good architect foresees and <em class="calibre9">appropriately</em> facilitates those changes.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0031_ch17"><a class="calibre3" id="part0031_page_159"></a><span class="gray">17</span><br class="calibre12"/>B<small class="calibre7">OUNDARIES</small>: D<small class="calibre7">RAWING</small> L<small class="calibre7">INES</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00064.jpeg"/></div>
<p class="noindent1"><a id="part0031_page_160"></a>Software architecture is the art of drawing lines that I call <em class="calibre9">boundaries</em>. Those boundaries separate software elements from one another, and restrict those on one side from knowing about those on the other. Some of those lines are drawn very early in a project’s life—even before any code is written. Others are drawn much later. Those that are drawn early are drawn for the purposes of deferring decisions for as long as possible, and of keeping those decisions from polluting the core business logic.</p>
<p class="noindent1">Recall that the goal of an architect is to minimize the human resources required to build and maintain the required system. What it is that saps this kind of people-power? <em class="calibre9">Coupling</em>—and especially coupling to premature decisions.</p>
<p class="noindent1">Which kinds of decisions are premature? Decisions that have nothing to do with the business requirements—the use cases—of the system. These include decisions about frameworks, databases, web servers, utility libraries, dependency injection, and the like. A good system architecture is one in which decisions like these are rendered ancillary and deferrable. A good system architecture does not depend on those decisions. A good system architecture allows those decisions to be made at the latest possible moment, without significant impact.</p>
<h3 class="h1" id="part0031_toclev_87">A C<small class="calibre13">OUPLE OF</small> S<small class="calibre13">AD</small> S<small class="calibre13">TORIES</small></h3>
<p class="noindent1">Here’s the sad story of company P, which serves as a warning about making premature decisions. In the 1980s the founders of P wrote a simple monolithic desktop application. They enjoyed a great deal of success and grew the product through the 1990s into a popular and successful desktop GUI application.</p>
<p class="noindent1">But then, in the late 1990s, the web emerged as a force. Suddenly everybody had to have a web solution, and P was no exception. P’s customers clamored for a version of the product on the web. To meet this demand, the company hired a bunch of hotshot twenty-something Java programmers and embarked upon a project to webify their product.</p>
<p class="noindent1"><a id="part0031_page_161"></a>The Java guys had dreams of server farms dancing in their heads, so they adopted a rich three-tiered “architecture”<sup class="calibre10"><a href="#part0031_ch17fn1" id="part0031_ch17fn-1">1</a></sup> that they could distribute through such farms. There would be servers for the GUI, servers for the middleware, and servers for the database. Of course.</p>
<p class="noindent1">The programmers decided, very early on, that all domain objects would have three instantiations: one in the GUI tier, one in the middleware tier, and one in the database tier. Since these instantiations lived on different machines, a rich system of interprocessor and inter-tier communications was set up. Method invocations between tiers were converted to objects, serialized, and marshaled across the wire.</p>
<p class="noindent1">Now imagine what it took to implement a simple feature like adding a new field to an existing record. That field had to be added to the classes in all three tiers, and to several of the inter-tier messages. Since data traveled in both directions, four message protocols needed to be designed. Each protocol had a sending and receiving side, so eight protocol handlers were required. Three executables had to be built, each with three updated business objects, four new messages, and eight new handlers.</p>
<p class="noindent1">And think of what those executables had to do to implement the simplest of features. Think of all the object instantiations, all the serializations, all the marshaling and de-marshaling, all the building and parsing of messages, all the socket communications, timeout managers, retry scenarios, and all the other extra stuff that you have to do just to get one simple thing done.</p>
<p class="noindent1">Of course, during development the programmers did not have a server farm. Indeed, they simply ran all three executables in three different processes on a single machine. They developed this way for several years. But they were convinced that their architecture was right. And so, even though they were executing in a single machine, they continued all the object instantiations, all the serializations, all the marshaling and de-marshaling, all the building and parsing of messages, all the socket communications, and all the extra stuff in a single machine.</p>
<p class="noindent1"><a id="part0031_page_162"></a>The irony is that company P never sold a system that required a server farm. Every system they ever deployed was a single server. And in that single server all three executables continued all the object instantiations, all the serializations, all the marshaling and de-marshaling, all the building and parsing of messages, all the socket communications, and all the extra stuff, in anticipation of a server farm that never existed, and never would.</p>
<p class="noindent1">The tragedy is that the architects, by making a premature decision, multiplied the development effort enormously.</p>
<p class="noindent1">The story of P is not isolated. I’ve seen it many times and in many places. Indeed, P is a superposition of all those places.</p>
<p class="noindent1">But there are worse fates than P.</p>
<p class="noindent1">Consider W, a local business that manages fleets of company cars. They recently hired an “Architect” to get their rag-tag software effort under control. And, let me tell you, control was this guy’s middle name. He quickly realized that what this little operation needed was a full-blown, <em class="calibre9">enterprise-scale</em>, <strong class="calibre8"><em class="calibre9">service-oriented</em> “ARCHITECTURE.”</strong> He created a huge domain model of all the different “objects” in the business, designed a suite of services to manage these domain objects, and put all the developers on a path to <em class="calibre9">Hell</em>. As a simple example, suppose you wanted to add the name, address, and phone number of a contact person to a sales record. You had to go to the <code class="calibre11">ServiceRegistry</code> and ask for the service ID of the <code class="calibre11">ContactService</code>. Then you had to send a <code class="calibre11">CreateContact</code> message to the <code class="calibre11">ContactService</code>. Of course, this message had dozens of fields that all had to have valid data in them—data to which the programmer had no access, since all the programmer had was a name, address, and phone number. After faking the data, the programmer had to jam the ID of the newly created contact into the sales record and send the <code class="calibre11">UpdateContact</code> message to the <code class="calibre11">SaleRecordService</code>.</p>
<p class="noindent1">Of course, to test anything you had to fire up all the necessary services, one by one, and fire up the message bus, and the BPel server, and … And then, there were the propagation delays as these messages bounced from service to service, and waited in queue after queue.</p>
<p class="noindent1"><a id="part0031_page_163"></a>And then if you wanted to add a new feature—well, you can imagine the coupling between all those services, and the sheer volume of WSDLs that needed changing, and all the redeployments those changes necessitated …</p>
<p class="noindent1">Hell starts to seem like a nice place by comparison.</p>
<p class="noindent1">There’s nothing intrinsically wrong with a software system that is structured around services. The error at W was the premature adoption and enforcement of a suite of tools that promised SoA—that is, the premature adoption of a massive suite of domain object services. The cost of those errors was sheer person-hours—person-hours in droves—flushed down the SoA vortex.</p>
<p class="noindent1">I could go on describing one architectural failure after another. But let’s talk about an architectural success instead.</p>
<h3 class="h1" id="part0031_toclev_88">F<small class="calibre13">IT</small>N<small class="calibre13">ESSE</small></h3>
<p class="noindent1">My Son, Micah, and I started work on <code class="calibre11">FitNesse</code> in 2001. The idea was to create a simple wiki that wrapped Ward Cunningham’s FIT tool for writing acceptance tests.</p>
<p class="noindent1">This was back in the days before Maven “solved” the jar file problem. I was adamant that anything we produced should not require people to download more than one jar file. I called this rule, “Download and Go.” This rule drove many of our decisions.</p>
<p class="noindent1">One of the first decisions was to write our own web server, specific to the needs of <code class="calibre11">FitNesse</code>. This might sound absurd. Even in 2001 there were plenty of open source web servers that we could have used. Yet writing our own turned out to be a really good decision because a bare-bones web server is a very simple piece of software to write and it allowed us to postpone any web framework decision until much later.<sup class="calibre10"><a href="#part0031_ch17fn2" id="part0031_ch17fn-2">2</a></sup></p>
<p class="noindent1"><a id="part0031_page_164"></a>Another early decision was to avoid thinking about a database. We had MySQL in the back of our minds, but we purposely delayed that decision by employing a design that made the decision irrelevant. That design was simply to put an interface between all data accesses and the data repository itself.</p>
<p class="noindent1">We put the data access methods into an interface named <code class="calibre11">WikiPage</code>. Those methods provided all the functionality we needed to find, fetch, and save pages. Of course, we didn’t implement those methods at first; we simply stubbed them out while we worked on features that didn’t involve fetching and saving the data.</p>
<p class="noindent1">Indeed, for three months we simply worked on translating wiki text into HTML. This didn’t require any kind of data storage, so we created a class named <code class="calibre11">MockWikiPage</code> that simply left the data access methods stubbed.</p>
<p class="noindent1">Eventually, those stubs became insufficient for the features we wanted to write. We needed real data access, not stubs. So we created a new derivative of <code class="calibre11">WikiPage</code> named <code class="calibre11">InMemoryPage</code>. This derivative implemented the data access method to manage a hash table of wiki pages, which we kept in RAM.</p>
<p class="noindent1">This allowed us to write feature after feature for a full year. In fact, we got the whole first version of the <code class="calibre11">FitNesse</code> program working this way. We could create pages, link to other pages, do all the fancy wiki formatting, and even run tests with FIT. What we couldn’t do was save any of our work.</p>
<p class="noindent1">When it came time to implement persistence, we thought again about MySQL, but decided that wasn’t necessary in the short term, because it would be really easy to write the hash tables out to flat files. So we implemented <code class="calibre11">FileSystemWikiPage</code>, which just moved the functionality out to flat files, and then we continued developing more features.</p>
<p class="noindent1">Three months later, we reached the conclusion that the flat file solution was good enough; we decided to abandon the idea of MySQL altogether. We deferred that decision into nonexistence and never looked back.</p>
<p class="noindent1">That would be the end of the story if it weren’t for one of our customers who decided that he needed to put the wiki into MySQL for his own purposes. We <a id="part0031_page_165"></a>showed him the architecture of <code class="calibre11">WikiPages</code> that had allowed us to defer the decision. He came back <em class="calibre9">a day later</em> with the whole system working in MySQL. He simply wrote a <code class="calibre11">MySqlWikiPage</code> derivative and got it working.</p>
<p class="noindent1">We used to bundle that option with <code class="calibre11">FitNesse</code>, but nobody else ever used it, so eventually we dropped it. Even the customer who wrote the derivative eventually dropped it.</p>
<p class="noindent1">Early in the development of <code class="calibre11">FitNesse</code>, we drew a <em class="calibre9">boundary line</em> between business rules and databases. That line prevented the business rules from knowing anything at all about the database, other than the simple data access methods. That decision allowed us to defer the choice and implementation of the database for well over a year. It allowed us to try the file system option, and it allowed us to change direction when we saw a better solution. Yet it did not prevent, or even impede, moving in the original direction (MySQL) when someone wanted it.</p>
<p class="noindent1">The fact that we did not have a database running for 18 months of development meant that, for 18 months, we did not have schema issues, query issues, database server issues, password issues, connection time issues, and all the other nasty issues that raise their ugly heads when you fire up a database. It also meant that all our tests ran fast, because there was no database to slow them down.</p>
<p class="noindent1">In short, drawing the boundary lines helped us delay and defer decisions, and it ultimately saved us an enormous amount of time and headaches. And that’s what a good architecture should do.</p>
<h3 class="h1" id="part0031_toclev_89">W<small class="calibre13">HICH</small> L<small class="calibre13">INES</small> D<small class="calibre13">O</small> Y<small class="calibre13">OU</small> D<small class="calibre13">RAW, AND</small> W<small class="calibre13">HEN</small> D<small class="calibre13">O</small> Y<small class="calibre13">OU</small> D<small class="calibre13">RAW</small> T<small class="calibre13">HEM</small>?</h3>
<p class="noindent1">You draw lines between things that matter and things that don’t. The GUI doesn’t matter to the business rules, so there should be a line between them. The database doesn’t matter to the GUI, so there should be a line between <a id="part0031_page_166"></a>them. The database doesn’t matter to the business rules, so there should be a line between them.</p>
<p class="noindent1">Some of you may have rejected one or more of those statements, especially the part about the business rules not caring about the database. Many of us have been taught to believe that the database is inextricably connected to the business rules. Some of us have even been convinced that the database is the embodiment of the business rules.</p>
<p class="noindent1">But, as we shall see in another chapter, this idea is misguided. The database is a tool that the business rules can use <em class="calibre9">indirectly</em>. The business rules don’t need to know about the schema, or the query language, or any of the other details about the database. All the business rules need to know is that there is a set of functions that can be used to fetch or save data. This allows us to put the database behind an interface.</p>
<p class="noindent1">You can see this clearly in <a href="#part0031_ch17fig1">Figure 17.1</a>. The <code class="calibre11">BusinessRules</code> use the <code class="calibre11">DatabaseInterface</code> to load and save data. The <code class="calibre11">DatabaseAccess</code> implements the interface and directs the operation of the actual <code class="calibre11">Database</code>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00065.jpeg"/></div>
<p class="fig-caption"><a id="part0031_ch17fig1"></a><strong class="calibre8">Figure 17.1</strong> The database behind an interface</p>
</div>
<p class="noindent1"><a id="part0031_page_167"></a>The classes and interfaces in this diagram are symbolic. In a real application, there would be many business rule classes, many database interface classes, and many database access implementations. All of them, though, would follow roughly the same pattern.</p>
<p class="noindent1">Where is the boundary line? The boundary is drawn across the inheritance relationship, just below the <code class="calibre11">DatabaseInterface</code> (<a href="#part0031_ch17fig2">Figure 17.2</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00066.jpeg"/></div>
<p class="fig-caption"><a id="part0031_ch17fig2"></a><strong class="calibre8">Figure 17.2</strong> The boundary line</p>
</div>
<p class="noindent1">Note the two arrows leaving the <code class="calibre11">DatabaseAccess</code> class. Those two arrows point away from the <code class="calibre11">DatabaseAccess</code> class. That means that none of these classes knows that the <code class="calibre11">DatabaseAccess</code> class exists.</p>
<p class="noindent1">Now let’s pull back a bit. We’ll look at the component that contains many business rules, and the component that contains the database and all its access classes (<a href="#part0031_ch17fig3">Figure 17.3</a>).</p>
<div class="fig-heading">
<div class="image1"><a id="part0031_page_168"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00067.jpeg"/></div>
<p class="fig-caption"><a id="part0031_ch17fig3"></a><strong class="calibre8">Figure 17.3</strong> The business rules and database components</p>
</div>
<p class="noindent1">Note the direction of the arrow. The <code class="calibre11">Database</code> knows about the <code class="calibre11">BusinessRules</code>. The <code class="calibre11">BusinessRules</code> do not know about the <code class="calibre11">Database</code>. This implies that the <code class="calibre11">DatabaseInterface</code> classes live in the <code class="calibre11">BusinessRules</code> component, while the <code class="calibre11">DatabaseAccess</code> classes live in the <code class="calibre11">Database</code> component.</p>
<p class="noindent1">The direction of this line is important. It shows that the <code class="calibre11">Database</code> does not matter to the <code class="calibre11">BusinessRules</code>, but the <code class="calibre11">Database</code> cannot exist without the <code class="calibre11">BusinessRules</code>.</p>
<p class="noindent1">If that seems strange to you, just remember this point: The <code class="calibre11">Database</code> component contains the code that translates the calls made by the <code class="calibre11">BusinessRules</code> into the query language of the database. It is that translation code that knows about the <code class="calibre11">BusinessRules</code>.</p>
<p class="noindent1">Having drawn this boundary line between the two components, and having set the direction of the arrow toward the <code class="calibre11">BusinessRules</code>, we can now see that the <code class="calibre11">BusinessRules</code> could use <em class="calibre9">any</em> kind of database. The <code class="calibre11">Database</code> component could be replaced with many different implementations—the <code class="calibre11">BusinessRules</code> don’t care.</p>
<p class="noindent1"><a id="part0031_page_169"></a>The database could be implemented with Oracle, or MySQL, or Couch, or Datomic, or even flat files. The business rules don’t care at all. And that means that the database decision can be deferred and you can focus on getting the business rules written and tested before you have to make the database decision.</p>
<h3 class="h1" id="part0031_toclev_90">W<small class="calibre13">HAT</small> A<small class="calibre13">BOUT</small> I<small class="calibre13">NPUT AND</small> O<small class="calibre13">UTPUT</small>?</h3>
<p class="noindent1">Developers and customers often get confused about what the system is. They see the GUI, and think that the GUI is the system. They define a system in terms of the GUI, so they believe that they should see the GUI start working immediately. They fail to realize a critically important principle: <em class="calibre9">The IO is irrelevant</em>.</p>
<p class="noindent1">This may be hard to grasp at first. We often think about the behavior of the system in terms of the behavior of the IO. Consider a video game, for example. Your experience is dominated by the interface: the screen, the mouse, the buttons, and the sounds. You forget that behind that interface there is a model—a sophisticated set of data structures and functions—driving it. More importantly, that model does not need the interface. It would happily execute its duties, modeling all the events in the game, without the game ever being displayed on the screen. The interface does not matter to the model—the business rules.</p>
<p class="noindent1">And so, once again, we see the <code class="calibre11">GUI</code> and <code class="calibre11">BusinessRules</code> components separated by a boundary line (<a href="#part0031_ch17fig4">Figure 17.4</a>). Once again, we see that the less relevant component depends on the more relevant component. The arrows show which component knows about the other and, therefore, which component cares about the other. The <code class="calibre11">GUI</code> cares about the <code class="calibre11">BusinessRules</code>.</p>
<div class="fig-heading">
<div class="image1"><a id="part0031_page_170"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00068.jpeg"/></div>
<p class="fig-caption"><a id="part0031_ch17fig4"></a><strong class="calibre8">Figure 17.4</strong> The boundary between <code class="calibre11">GUI</code> and <code class="calibre11">BusinessRules</code> components</p>
</div>
<p class="noindent1">Having drawn this boundary and this arrow, we can now see that the <code class="calibre11">GUI</code> could be replaced with any other kind of interface—and the <code class="calibre11">BusinessRules</code> would not care.</p>
<h3 class="h1" id="part0031_toclev_91">P<small class="calibre13">LUGIN</small> A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">Taken together, these two decisions about the database and the GUI create a kind of pattern for the addition of other components. That pattern is the same pattern that is used by systems that allow third-party plugins.</p>
<p class="noindent1">Indeed, the history of software development technology is the story of how to conveniently create plugins to establish a scalable and maintainable system architecture. The core business rules are kept separate from, and independent of, those components that are either optional or that can be implemented in many different forms (<a href="#part0031_ch17fig5">Figure 17.5</a>).</p>
<div class="fig-heading">
<div class="image1"><a id="part0031_page_171"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00069.jpeg"/></div>
<p class="fig-caption"><a id="part0031_ch17fig5"></a><strong class="calibre8">Figure 17.5</strong> Plugging in to the business rules</p>
</div>
<p class="noindent1">Because the user interface in this design is considered to be a plugin, we have made it possible to plug in many different kinds of user interfaces. They could be web based, client/server based, SOA based, Console based, or based on any other kind of user interface technology.</p>
<p class="noindent1">The same is true of the database. Since we have chosen to treat it as a plugin, we can replace it with any of the various SQL databases, or a NOSQL database, or a file system-based database, or any other kind of database technology we might deem necessary in the future.</p>
<p class="noindent1">These replacements might not be trivial. If the initial deployment of our system was web-based, then writing the plugin for a client-server UI could be challenging. It is likely that some of the communications between the business rules and the new UI would have to be reworked. Even so, by starting with the presumption of a plugin structure, we have at very least made such a change practical.</p>
<h3 class="h1" id="part0031_toclev_92"><a class="calibre3" id="part0031_page_172"></a>T<small class="calibre13">HE</small> P<small class="calibre13">LUGIN</small> A<small class="calibre13">RGUMENT</small></h3>
<p class="noindent1">Consider the relationship between ReSharper and Visual Studio. These components are produced by completely different development teams in completely different companies. Indeed, JetBrains, the maker of ReSharper, lives in Russia. Microsoft, of course, resides in Redmond, Washington. It’s hard to imagine two development teams that are more separate.</p>
<p class="noindent1">Which team can damage the other? Which team is immune to the other? The dependency structure tells the story (<a href="#part0031_ch17fig6">Figure 17.6</a>). The source code of ReSharper depends on the source code of Visual Studio. Thus there is nothing that the ReSharper team can do to disturb the Visual Studio team. But the Visual Studio team could completely disable the ReSharper team if they so desired.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00070.jpeg"/></div>
<p class="fig-caption"><a id="part0031_ch17fig6"></a><strong class="calibre8">Figure 17.6</strong> ReSharper depends on Visual Studio</p>
</div>
<p class="noindent1">That’s a deeply asymmetric relationship, and it is one that we desire to have in our own systems. We want certain modules to be immune to others. For example, we don’t want the business rules to break when someone changes the format of a web page, or changes the schema of the database. We don’t <a id="part0031_page_173"></a>want changes in one part of the system to cause other unrelated parts of the system to break. We don’t want our systems to exhibit that kind of fragility.</p>
<p class="noindent1">Arranging our systems into a plugin architecture creates firewalls across which changes cannot propagate. If the GUI plugs in to the business rules, then changes in the GUI cannot affect those business rules.</p>
<p class="noindent1">Boundaries are drawn where there is an <em class="calibre9">axis of change</em>. The components on one side of the boundary change at different rates, and for different reasons, than the components on the other side of the boundary.</p>
<p class="noindent1">GUIs change at different times and at different rates than business rules, so there should be a boundary between them. Business rules change at different times and for different reasons than dependency injection frameworks, so there should be a boundary between them.</p>
<p class="noindent1">This is simply the Single Responsibility Principle again. The SRP tells us where to draw our boundaries.</p>
<h3 class="h1" id="part0031_toclev_93">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">To draw boundary lines in a software architecture, you first partition the system into components. Some of those components are core business rules; others are plugins that contain necessary functions that are not directly related to the core business. Then you arrange the code in those components such that the arrows between them point in one direction—toward the core business.</p>
<p class="noindent1">You should recognize this as an application of the Dependency Inversion Principle and the Stable Abstractions Principle. Dependency arrows are arranged to point from lower-level details to higher-level abstractions.<a id="part0031_page_174"></a></p>
<p class="fn"><a href="#part0031_ch17fn-1" id="part0031_ch17fn1">1</a>. The word “architecture” appears in quotes here because three-tier is not an architecture; it’s a topology. It’s exactly the kind of decision that a good architecture strives to defer.</p>
<p class="fn"><a href="#part0031_ch17fn-2" id="part0031_ch17fn2">2</a>. Many years later we were able to slip the Velocity framework into <code class="calibre11">FitNesse</code>.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0032_ch18"><a class="calibre3" id="part0032_page_175"></a><span class="gray">18</span><br class="calibre12"/>B<small class="calibre7">OUNDARY</small> A<small class="calibre7">NATOMY</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00071.jpeg"/></div>
<p class="noindent1"><a id="part0032_page_176"></a>The architecture of a system is defined by a set of software components and the boundaries that separate them. Those boundaries come in many different forms. In this chapter we’ll look at some of the most common.</p>
<h3 class="h1" id="part0032_toclev_94">B<small class="calibre13">OUNDARY</small> C<small class="calibre13">ROSSING</small></h3>
<p class="noindent1">At runtime, a boundary crossing is nothing more than a function on one side of the boundary calling a function on the other side and passing along some data. The trick to creating an appropriate boundary crossing is to manage the source code dependencies.</p>
<p class="noindent1">Why source code? Because when one source code module changes, other source code modules may have to be changed or recompiled, and then redeployed. Managing and building firewalls against this change is what boundaries are all about.</p>
<h3 class="h1" id="part0032_toclev_95">T<small class="calibre13">HE</small> D<small class="calibre13">READED</small> M<small class="calibre13">ONOLITH</small></h3>
<p class="noindent1">The simplest and most common of the architectural boundaries has no strict physical representation. It is simply a disciplined segregation of functions and data within a single processor and a single address space. In a previous chapter, I called this the source-level decoupling mode.</p>
<p class="noindent1">From a deployment point of view, this amounts to nothing more than a single executable file—the so-called monolith. This file might be a statically linked C or C++ project, a set of Java class files bound together into an executable jar file, a set of .NET binaries bound into a single <code class="calibre11">.EXE</code> file, and so on.</p>
<p class="noindent1">The fact that the boundaries are not visible during the deployment of a monolith does not mean that they are not present and meaningful. Even when statically linked into a single executable, the ability to independently develop and marshal the various components for final assembly is immensely valuable.</p>
<p class="noindent1"><a id="part0032_page_177"></a>Such architectures almost always depend on some kind of dynamic polymorphism<sup class="calibre10"><a href="#part0032_ch18fn1" id="part0032_ch18fn-1">1</a></sup> to manage their internal dependencies. This is one of the reasons that object-oriented development has become such an important paradigm in recent decades. Without OO, or an equivalent form of polymorphism, architects must fall back on the dangerous practice of using pointers to functions to achieve the appropriate decoupling. Most architects find prolific use of pointers to functions to be too risky, so they are forced to abandon any kind of component partitioning.</p>
<p class="noindent1">The simplest possible boundary crossing is a function call from a low-level client to a higher-level service. Both the runtime dependency and the compile-time dependency point in the same direction, toward the higher-level component.</p>
<p class="noindent1">In <a href="#part0032_ch18fig1">Figure 18.1</a>, the flow of control crosses the boundary from left to right. The <code class="calibre11">Client</code> calls function <code class="calibre11">f()</code> on the <code class="calibre11">Service</code>. It passes along an instance of <code class="calibre11">Data</code>. The <code class="calibre11">&lt;DS&gt;</code> marker simply indicates a data structure. The <code class="calibre11">Data</code> may be passed as a function argument or by some other more elaborate means. Note that the definition of the <code class="calibre11">Data</code> is on the <em class="calibre9">called</em> side of the boundary.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00072.jpeg"/></div>
<p class="fig-caption"><a id="part0032_ch18fig1"></a><strong class="calibre8">Figure 18.1</strong> Flow of control crosses the boundary from a lower level to a higher level</p>
</div>
<p class="noindent1">When a high-level client needs to invoke a lower-level service, dynamic polymorphism is used to invert the dependency against the flow of control. The runtime dependency opposes the compile-time dependency.</p>
<p class="noindent1"><a id="part0032_page_178"></a>In <a href="#part0032_ch18fig2">Figure 18.2</a>, the flow of control crosses the boundary from left to right as before. The high-level <code class="calibre11">Client</code> calls the <code class="calibre11">f()</code> function of the lower-level <code class="calibre11">ServiceImpl</code> through the <code class="calibre11">Service</code> interface. Note, however, that all dependencies cross the boundary from right to left <em class="calibre9">toward the higher-level component</em>. Note, also, that the definition of the data structure is on the calling side of the boundary.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00073.jpeg"/></div>
<p class="fig-caption"><a id="part0032_ch18fig2"></a><strong class="calibre8">Figure 18.2</strong> Crossing the boundary against the flow of control</p>
</div>
<p class="noindent1">Even in a monolithic, statically linked executable, this kind of disciplined partitioning can greatly aid the job of developing, testing, and deploying the project. Teams can work independently of each other on their own components without treading on each other’s toes. High-level components remain independent of lower-level details.</p>
<p class="noindent1">Communications between components in a monolith are very fast and inexpensive. They are typically just function calls. Consequently, communications across source-level decoupled boundaries can be very chatty.</p>
<p class="noindent1">Since the deployment of monoliths usually requires compilation and static linking, components in these systems are typically delivered as source code.</p>
<h3 class="h1" id="part0032_toclev_96">D<small class="calibre13">EPLOYMENT</small> C<small class="calibre13">OMPONENTS</small></h3>
<p class="noindent1">The simplest physical representation of an architectural boundary is a dynamically linked library like a .Net DLL, a Java jar file, a Ruby Gem, or a UNIX shared library. Deployment does not involve compilation. Instead, the <a id="part0032_page_179"></a>components are delivered in binary, or some equivalent deployable form. This is the deployment-level decoupling mode. The act of deployment is simply the gathering of these deployable units together in some convenient form, such as a WAR file, or even just a directory.</p>
<p class="noindent1">With that one exception, deployment-level components are the same as monoliths. The functions generally all exist in the same processor and address space. The strategies for segregating the components and managing their dependencies are the same.<sup class="calibre10"><a href="#part0032_ch18fn2" id="part0032_ch18fn-2">2</a></sup></p>
<p class="noindent1">As with monoliths, communications across deployment component boundaries are just function calls and, therefore, are very inexpensive. There may be a one-time hit for dynamic linking or runtime loading, but communications across these boundaries can still be very chatty.</p>
<h3 class="h1" id="part0032_toclev_97">T<small class="calibre13">HREADS</small></h3>
<p class="noindent1">Both monoliths and deployment components can make use of threads. Threads are not architectural boundaries or units of deployment, but rather a way to organize the schedule and order of execution. They may be wholly contained within a component, or spread across many components.</p>
<h3 class="h1" id="part0032_toclev_98">L<small class="calibre13">OCAL</small> P<small class="calibre13">ROCESSES</small></h3>
<p class="noindent1">A much stronger physical architectural boundary is the local process. A local process is typically created from the command line or an equivalent system call. Local processes run in the same processor, or in the same set of processors within a multicore, but run in separate address spaces. Memory protection generally prevents such processes from sharing memory, although shared memory partitions are often used.</p>
<p class="noindent1"><a id="part0032_page_180"></a>Most often, local processes communicate with each other using sockets, or some other kind of operating system communications facility such as mailboxes or message queues.</p>
<p class="noindent1">Each local process may be a statically linked monolith, or it may be composed of dynamically linked deployment components. In the former case, several monolithic processes may have the same components compiled and linked into them. In the latter, they may share the same dynamically linked deployment components.</p>
<p class="noindent1">Think of a local process as a kind of uber-component: The process consists of lower-level components that manage their dependencies through dynamic polymorphism.</p>
<p class="noindent1">The segregation strategy between local processes is the same as for monoliths and binary components. Source code dependencies point in the same direction across the boundary, and always toward the higher-level component.</p>
<p class="noindent1">For local processes, this means that the source code of the higher-level processes must not contain the names, or physical addresses, or registry lookup keys of lower-level processes. Remember that the architectural goal is for lower-level processes to be plugins to higher-level processes.</p>
<p class="noindent1">Communication across local process boundaries involve operating system calls, data marshaling and decoding, and interprocess context switches, which are moderately expensive. Chattiness should be carefully limited.</p>
<h3 class="h1" id="part0032_toclev_99">S<small class="calibre13">ERVICES</small></h3>
<p class="noindent1">The strongest boundary is a service. A service is a process, generally started from the command line or through an equivalent system call. Services do not depend on their physical location. Two communicating services may, or may not, operate in the same physical processor or multicore. The services assume that all communications take place over the network.</p>
<p class="noindent1"><a id="part0032_page_181"></a>Communications across service boundaries are very slow compared to function calls. Turnaround times can range from tens of milliseconds to seconds. Care must be taken to avoid chatting where possible. Communications at this level must deal with high levels of latency.</p>
<p class="noindent1">Otherwise, the same rules apply to services as apply to local processes. Lower-level services should “plug in” to higher-level services. The source code of higher-level services must not contain any specific physical knowledge (e.g., a URI) of any lower-level service.</p>
<h3 class="h1" id="part0032_toclev_100">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">Most systems, other than monoliths, use more than one boundary strategy. A system that makes use of service boundaries may also have some local process boundaries. Indeed, a service is often just a facade for a set of interacting local processes. A service, or a local process, will almost certainly be either a monolith composed of source code components or a set of dynamically linked deployment components.</p>
<p class="noindent1">This means that the boundaries in a system will often be a mixture of local chatty boundaries and boundaries that are more concerned with latency.<a id="part0032_page_182"></a></p>
<p class="fn"><a href="#part0032_ch18fn-1" id="part0032_ch18fn1">1</a>. Static polymorphism (e.g., generics or templates) can sometimes be a viable means of dependency management in monolithic systems, especially in languages like C++. However, the decoupling afforded by generics cannot protect you from the need for recompilation and redeployment the way dynamic polymorphism can.</p>
<p class="fn"><a href="#part0032_ch18fn-2" id="part0032_ch18fn2">2</a>. Although static polymorphism is not an option in this case.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0033_ch19"><a class="calibre3" id="part0033_page_183"></a><span class="gray">19</span><br class="calibre12"/>P<small class="calibre7">OLICY AND</small> L<small class="calibre7">EVEL</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00074.jpeg"/></div>
<p class="noindent1">Software systems are statements of policy. Indeed, at its core, that’s all a computer program actually is. A computer program is a detailed description of the policy by which inputs are transformed into outputs.</p>
<p class="noindent1"><a id="part0033_page_184"></a>In most nontrivial systems, that policy can be broken down into many different smaller statements of policy. Some of those statements will describe how particular business rules are to be calculated. Others will describe how certain reports are to be formatted. Still others will describe how input data are to be validated.</p>
<p class="noindent1">Part of the art of developing a software architecture is carefully separating those policies from one another, and regrouping them based on the ways that they change. Policies that change for the same reasons, and at the same times, are at the same level and belong together in the same component. Policies that change for different reasons, or at different times, are at different levels and should be separated into different components.</p>
<p class="noindent1">The art of architecture often involves forming the regrouped components into a directed acyclic graph. The nodes of the graph are the components that contain policies at the same level. The directed edges are the dependencies between those components. They connect components that are at different levels.</p>
<p class="noindent1">Those dependencies are source code, compile-time dependencies. In Java, they are <code class="calibre11">import</code> statements. In C#, they are <code class="calibre11">using</code> statements. In Ruby, they are <code class="calibre11">require</code> statements. They are the dependencies that are necessary for the compiler to function.</p>
<p class="noindent1">In a good architecture, the direction of those dependencies is based on the level of the components that they connect. In every case, low-level components are designed so that they depend on high-level components.</p>
<h3 class="h1" id="part0033_toclev_101">L<small class="calibre13">EVEL</small></h3>
<p class="noindent1">A strict definition of “level” is “the distance from the inputs and outputs.” The farther a policy is from both the inputs and the outputs of the system, the higher its level. The policies that manage input and output are the lowest-level policies in the system.</p>
<p class="noindent1">The data flow diagram in <a href="#part0033_ch19fig1">Figure 19.1</a> depicts a simple encryption program that reads characters from an input device, translates the characters using a <a id="part0033_page_185"></a>table, and then writes the translated characters to an output device. The data flows are shown as curved solid arrows. The properly designed source code dependencies are shown as straight dashed lines.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00075.jpeg"/></div>
<p class="fig-caption"><a id="part0033_ch19fig1"></a><strong class="calibre8">Figure 19.1</strong> A simple encryption program</p>
</div>
<p class="noindent1">The <code class="calibre11">Translate</code> component is the highest-level component in this system because it is the component that is farthest from the inputs and outputs.<sup class="calibre10"><a href="#part0033_ch19fn1" id="part0033_ch19fn-1">1</a></sup></p>
<p class="noindent1">Note that the data flows and the source code dependencies do not always point in the same direction. This, again, is part of the art of software architecture. We want source code dependencies to be decoupled from data flow and <em class="calibre9">coupled to level</em>.</p>
<p class="noindent1">It would be easy to create an incorrect architecture by writing the encryption program like this:</p>
<p class="codelink"><a href="#part0059_split_001_pch19ex01a" id="part0033_pch19ex01">Click here to view code image</a></p>
<p class="pre2">function encrypt() {<br class="calibre6"/>
  while(true)<br class="calibre6"/>
    writeChar(translate(readChar()));<br class="calibre6"/>
}</p>
<p class="noindent1"><a id="part0033_page_186"></a>This is incorrect architecture because the high-level <code class="calibre11">encrypt</code> function depends on the lower-level <code class="calibre11">readChar</code> and <code class="calibre11">writeChar</code> functions.</p>
<p class="noindent1">A better architecture for this system is shown in the class diagram in <a href="#part0033_ch19fig2">Figure 19.2</a>. Note the dashed border surrounding the <code class="calibre11">Encrypt</code> class, and the <code class="calibre11">CharWriter</code> and <code class="calibre11">CharReader</code> interfaces. All dependencies crossing that border point inward. This unit is the highest-level element in the system.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00076.jpeg"/></div>
<p class="fig-caption"><a id="part0033_ch19fig2"></a><strong class="calibre8">Figure 19.2</strong> Class diagram showing a better architecture for the system</p>
</div>
<p class="noindent1"><code class="calibre11">ConsoleReader</code> and <code class="calibre11">ConsoleWriter</code> are shown here as classes. They are low level because they are close to the inputs and outputs.</p>
<p class="noindent1">Note how this structure decouples the high-level encryption policy from the lower-level input/output policies. This makes the encryption policy usable in a wide range of contexts. When changes are made to the input and output policies, they are not likely to affect the encryption policy.</p>
<p class="noindent1">Recall that policies are grouped into components based on the way that they change. Policies that change for the same reasons and at the same times are grouped together by the SRP and CCP. Higher-level policies—those that are farthest from the inputs and outputs—tend to change less frequently, and for <a id="part0033_page_187"></a>more important reasons, than lower-level policies. Lower-level policies—those that are closest to the inputs and outputs—tend to change frequently, and with more urgency, but for less important reasons.</p>
<p class="noindent1">For example, even in the trivial example of the encryption program, it is far more likely that the IO devices will change than that the encryption algorithm will change. If the encryption algorithm does change, it will likely be for a more substantive reason than a change to one of the IO devices.</p>
<p class="noindent1">Keeping these policies separate, with all source code dependencies pointing in the direction of the higher-level policies, reduces the impact of change. Trivial but urgent changes at the lowest levels of the system have little or no impact on the higher, more important, levels.</p>
<p class="noindent1">Another way to look at this issue is to note that lower-level components should be plugins to the higher-level components. The component diagram in <a href="#part0033_ch19fig3">Figure 19.3</a> shows this arrangement. The <code class="calibre11">Encryption</code> component knows nothing of the <code class="calibre11">IODevices</code> component; the <code class="calibre11">IODevices</code> component depends on the <code class="calibre11">Encryption</code> component.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00077.jpeg"/></div>
<p class="fig-caption"><a id="part0033_ch19fig3"></a><strong class="calibre8">Figure 19.3</strong> Lower-level components should plug in to higher-level components</p>
</div>
<h3 class="h1" id="part0033_toclev_102">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">At this point, this discussion of policies has involved a mixture of the Single Responsibility Principle, the Open-Closed Principle, the Common Closure Principle, the Dependency Inversion Principle, the Stable Dependencies Principle, and the Stable Abstractions Principle. Look back and see if you can identify where each principle was used, and why.<a id="part0033_page_188"></a></p>
<p class="fn"><a href="#part0033_ch19fn-1" id="part0033_ch19fn1">1</a>. Meilir Page-Jones called this component the “Central Transform” in his book <em class="calibre9">The Practical Guide to Structured Systems Design</em>, 2nd ed. (Yourdon Press, 1988).</p>
</body><body class="calibre">
<h2 class="h2f" id="part0034_ch20"><a class="calibre3" id="part0034_page_189"></a><span class="gray">20</span><br class="calibre12"/>B<small class="calibre7">USINESS</small> R<small class="calibre7">ULES</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00078.jpeg"/></div>
<p class="noindent1"><a id="part0034_page_190"></a>If we are going to divide our application into business rules and plugins, we’d better get a good grasp on just what business rules actually are. It turns out there are several different kinds.</p>
<p class="noindent1">Strictly speaking, business rules are rules or procedures that make or save the business money. Very strictly speaking, these rules would make or save the business money, irrespective of whether they were implemented on a computer. They would make or save money even if they were executed manually.</p>
<p class="noindent1">The fact that a bank charges <em class="calibre9">N</em>% interest for a loan is a business rule that makes the bank money. It doesn’t matter if a computer program calculates the interest, or if a clerk with an abacus calculates the interest.</p>
<p class="noindent1">We shall call these rules <em class="calibre9">Critical Business Rules</em>, because they are critical to the business itself, and would exist even if there were no system to automate them.</p>
<p class="noindent1">Critical Business Rules usually require some data to work with. For example, our loan requires a loan balance, an interest rate, and a payment schedule.</p>
<p class="noindent1">We shall call this data <em class="calibre9">Critical Business Data</em>. This is the data that would exist even if the system were not automated.</p>
<p class="noindent1">The critical rules and critical data are inextricably bound, so they are a good candidate for an object. We’ll call this kind of object an <em class="calibre9">Entity</em>.<sup class="calibre10"><a href="#part0034_ch20fn1" id="part0034_ch20fn-1">1</a></sup></p>
<h3 class="h1" id="part0034_toclev_103">E<small class="calibre13">NTITIES</small></h3>
<p class="noindent1">An Entity is an object within our computer system that embodies a small set of critical business rules operating on Critical Business Data. The Entity object either contains the Critical Business Data or has very easy access to that data. The interface of the Entity consists of the functions that implement the Critical Business Rules that operate on that data.</p>
<p class="noindent1"><a id="part0034_page_191"></a>For example, <a href="#part0034_ch20fig1">Figure 20.1</a> shows what our Loan entity might look like as a class in UML. It has three pieces of Critical Business Data, and presents three related Critical Business Rules at its interface.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00079.jpeg"/></div>
<p class="fig-caption"><a id="part0034_ch20fig1"></a><strong class="calibre8">Figure 20.1</strong> Loan entity as a class in UML</p>
</div>
<p class="noindent1">When we create this kind of class, we are gathering together the software that implements a concept that is critical to the business, and separating it from every other concern in the automated system we are building. This class stands alone as a representative of the business. It is unsullied with concerns about databases, user interfaces, or third-party frameworks. It could serve the business in any system, irrespective of how that system was presented, or how the data was stored, or how the computers in that system were arranged. The Entity is pure business and <em class="calibre9">nothing else</em>.</p>
<p class="noindent1">Some of you may be concerned that I called it a class. Don’t be. You don’t need to use an object-oriented language to create an Entity. All that is required is that you bind the Critical Business Data and the Critical Business Rules together in a single and separate software module.</p>
<h3 class="h1" id="part0034_toclev_104">U<small class="calibre13">SE</small> C<small class="calibre13">ASES</small></h3>
<p class="noindent1">Not all business rules are as pure as Entities. Some business rules make or save money for the business by defining and constraining the way that an <em class="calibre9">automated</em> system operates. These rules would not be used in a manual environment, because they make sense only as part of an automated system.</p>
<p class="noindent1"><a id="part0034_page_192"></a>For example, imagine an application that is used by bank officers to create a new loan. The bank may decide that it does not want the loan officers to offer loan payment estimates until they have first gathered, and validated, contact information and ensured that the candidate’s credit score is 500 or higher. For this reason, the bank may specify that the system will not proceed to the payment estimation screen until the contact information screen has been filled out and verified, and the credit score has been confirmed to be greater than the cutoff.</p>
<p class="noindent1">This is a <em class="calibre9">use case</em>.<sup class="calibre10"><a href="#part0034_ch20fn2" id="part0034_ch20fn-2">2</a></sup> A use case is a description of the way that an automated system is used. It specifies the input to be provided by the user, the output to be returned to the user, and the processing steps involved in producing that output. A use case describes <em class="calibre9">application-specific</em> business rules as opposed to the Critical Business Rules within the Entities.</p>
<p class="noindent1"><a href="#part0034_ch20fig2">Figure 20.2</a> shows an example of a use case. Notice that in the last line it mentions the Customer. This is a reference to the Customer entity, which contains the Critical Business Rules that govern the relationship between the bank and its customers.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00080.jpeg"/></div>
<p class="fig-caption"><a id="part0034_ch20fig2"></a><strong class="calibre8">Figure 20.2</strong> Example use case</p>
</div>
<p class="noindent1"><a id="part0034_page_193"></a>Use cases contain the rules that specify how and when the Critical Business Rules within the Entities are invoked. Use cases control the dance of the Entities.</p>
<p class="noindent1">Notice also that the use case does not describe the user interface other than to informally specify the data coming in from that interface, and the data going back out through that interface. From the use case, it is impossible to tell whether the application is delivered on the web, or on a thick client, or on a console, or is a pure service.</p>
<p class="noindent1">This is very important. Use cases do not describe how the system appears to the user. Instead, they describe the application-specific rules that govern the interaction between the users and the Entities. How the data gets in and out of the system is irrelevant to the use cases.</p>
<p class="noindent1">A use case is an object. It has one or more functions that implement the application-specific business rules. It also has data elements that include the input data, the output data, and the references to the appropriate Entities with which it interacts.</p>
<p class="noindent1">Entities have no knowledge of the use cases that control them. This is another example of the direction of the dependencies following the Dependency Inversion Principle. High-level concepts, such as Entities, know nothing of lower-level concepts, such as use cases. Instead, the lower-level use cases know about the higher-level Entities.</p>
<p class="noindent1">Why are Entities high level and use cases lower level? Because use cases are specific to a single application and, therefore, are closer to the inputs and outputs of that system. Entities are generalizations that can be used in many different applications, so they are farther from the inputs and outputs of the system. Use cases depend on Entities; Entities do not depend on use cases.</p>
<h3 class="h1" id="part0034_toclev_105">R<small class="calibre13">EQUEST AND</small> R<small class="calibre13">ESPONSE</small> M<small class="calibre13">ODELS</small></h3>
<p class="noindent1">Use cases expect input data, and they produce output data. However, a well-formed use case object should have no inkling about the way that data is <a id="part0034_page_194"></a>communicated to the user, or to any other component. We certainly don’t want the code within the use case class to know about HTML or SQL!</p>
<p class="noindent1">The use case class accepts simple request data structures for its input, and returns simple response data structures as its output. These data structures are not dependent on anything. They do not derive from standard framework interfaces such as <code class="calibre11">HttpRequest</code> and <code class="calibre11">HttpResponse</code>. They know nothing of the web, nor do they share any of the trappings of whatever user interface might be in place.</p>
<p class="noindent1">This lack of dependencies is critical. If the request and response models are not independent, then the use cases that depend on them will be indirectly bound to whatever dependencies the models carry with them.</p>
<p class="noindent1">You might be tempted to have these data structures contain references to Entity objects. You might think this makes sense because the Entities and the request/response models share so much data. Avoid this temptation! The purpose of these two objects is very different. Over time they will change for very different reasons, so tying them together in any way violates the Common Closure and Single Responsibility Principles. The result would be lots of tramp data, and lots of conditionals in your code.</p>
<h3 class="h1" id="part0034_toclev_106">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">Business rules are the reason a software system exists. They are the core functionality. They carry the code that makes, or saves, money. They are the family jewels.</p>
<p class="noindent1">The business rules should remain pristine, unsullied by baser concerns such as the user interface or database used. Ideally, the code that represents the business rules should be the heart of the system, with lesser concerns being plugged in to them. The business rules should be the most independent and reusable code in the system.</p>
<p class="fn"><a href="#part0034_ch20fn-1" id="part0034_ch20fn1">1</a>. This is Ivar Jacobson’s name for this concept (I. Jacobson et al., <em class="calibre9">Object Oriented Software Engineering</em>, Addison-Wesley, 1992).</p>
<p class="fn"><a href="#part0034_ch20fn-2" id="part0034_ch20fn2">2</a>. Ibid.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0035_ch21"><a class="calibre3" id="part0035_page_195"></a><span class="gray">21</span><br class="calibre12"/>S<small class="calibre7">CREAMING</small> A<small class="calibre7">RCHITECTURE</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00081.jpeg"/></div>
<p class="noindent1"><a id="part0035_page_196"></a>Imagine that you are looking at the blueprints of a building. This document, prepared by an architect, provides the plans for the building. What do these plans tell you?</p>
<p class="noindent1">If the plans you are viewing are for a single-family residence, then you’ll likely see a front entrance, a foyer leading to a living room, and perhaps a dining room. There will likely be a kitchen a short distance away, close to the dining room. Perhaps there is a dinette area next to the kitchen, and probably a family room close to that. When you looked at those plans, there would be no question that you were looking at a single family home. The architecture would scream: “HOME.”</p>
<p class="noindent1">Now suppose you were looking at the architecture of a library. You would likely see a grand entrance, an area for check-in/out clerks, reading areas, small conference rooms, and gallery after gallery capable of holding bookshelves for all the books in the library. That architecture would scream: “LIBRARY.”</p>
<p class="noindent1">So what does the architecture of your application scream? When you look at the top-level directory structure, and the source files in the highest-level package, do they scream “Health Care System,” or “Accounting System,” or “Inventory Management System”? Or do they scream “Rails,” or “Spring/Hibernate,” or “ASP”?</p>
<h3 class="h1" id="part0035_toclev_107">T<small class="calibre13">HE</small> T<small class="calibre13">HEME OF AN</small> A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">Go back and read Ivar Jacobson’s seminal work on software architecture: <em class="calibre9">Object Oriented Software Engineering</em>. Notice the subtitle of the book: <em class="calibre9">A Use Case Driven Approach</em>. In this book Jacobson makes the point that software architectures are structures that support the use cases of the system. Just as the plans for a house or a library scream about the use cases of those buildings, so should the architecture of a software application scream about the use cases of the application.</p>
<p class="noindent1"><a id="part0035_page_197"></a>Architectures are not (or should not be) about frameworks. Architectures should not be supplied by frameworks. Frameworks are tools to be used, not architectures to be conformed to. If your architecture is based on frameworks, then it cannot be based on your use cases.</p>
<h3 class="h1" id="part0035_toclev_108">T<small class="calibre13">HE</small> P<small class="calibre13">URPOSE OF AN</small> A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">Good architectures are centered on use cases so that architects can safely describe the structures that support those use cases without committing to frameworks, tools, and environments. Again, consider the plans for a house. The first concern of the architect is to make sure that the house is usable—not to ensure that the house is made of bricks. Indeed, the architect takes pains to ensure that the homeowner can make decisions about the exterior material (bricks, stone, or cedar) later, after the plans ensure that the use cases are met.</p>
<p class="noindent1">A good software architecture allows decisions about frameworks, databases, web servers, and other environmental issues and tools to be deferred and delayed. <em class="calibre9">Frameworks are options to be left open.</em> A good architecture makes it unnecessary to decide on Rails, or Spring, or Hibernate, or Tomcat, or MySQL, until much later in the project. A good architecture makes it easy to change your mind about those decisions, too. A good architecture emphasizes the use cases and decouples them from peripheral concerns.</p>
<h3 class="h1" id="part0035_toclev_109">B<small class="calibre13">UT</small> W<small class="calibre13">HAT</small> A<small class="calibre13">BOUT THE</small> W<small class="calibre13">EB</small>?</h3>
<p class="noindent1">Is the web an architecture? Does the fact that your system is delivered on the web dictate the architecture of your system? Of course not! The web is a delivery mechanism—an IO device—and your application architecture should treat it as such. The fact that your application is delivered over the web is a detail and should not dominate your system structure. Indeed, the decision that your application will be delivered over the web is one that you should defer. Your system architecture should be as ignorant as possible about how it <a id="part0035_page_198"></a>will be delivered. You should be able to deliver it as a console app, or a web app, or a thick client app, or even a web service app, without undue complication or change to the fundamental architecture.</p>
<h3 class="h1" id="part0035_toclev_110">F<small class="calibre13">RAMEWORKS</small> A<small class="calibre13">RE</small> T<small class="calibre13">OOLS</small>, N<small class="calibre13">OT</small> W<small class="calibre13">AYS OF</small> L<small class="calibre13">IFE</small></h3>
<p class="noindent1">Frameworks can be very powerful and very useful. Framework authors often believe very deeply in their frameworks. The examples they write for how to use their frameworks are told from the point of view of a true believer. Other authors who write about the framework also tend to be disciples of the true belief. They show you the way to use the framework. Often they assume an all-encompassing, all-pervading, let-the-framework-do-everything position.</p>
<p class="blockquote"><em class="calibre9">This is not the position you want to take.</em></p>
<p class="noindent1">Look at each framework with a jaded eye. View it skeptically. Yes, it might help, but at what cost? Ask yourself how you should use it, and how you should protect yourself from it. Think about how you can preserve the use-case emphasis of your architecture. Develop a strategy that prevents the framework from taking over that architecture.</p>
<h3 class="h1" id="part0035_toclev_111">T<small class="calibre13">ESTABLE</small> A<small class="calibre13">RCHITECTURES</small></h3>
<p class="noindent1">If your system architecture is all about the use cases, and if you have kept your frameworks at arm’s length, then you should be able to unit-test all those use cases without any of the frameworks in place. You shouldn’t need the web server running to run your tests. You shouldn’t need the database connected to run your tests. Your Entity objects should be plain old objects that have no dependencies on frameworks or databases or other complications. Your use case objects should coordinate your Entity objects. Finally, all of them together should be testable in situ, without any of the complications of frameworks.</p>
<h3 class="h1" id="part0035_toclev_112"><a class="calibre3" id="part0035_page_199"></a>C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">Your architecture should tell readers about the system, not about the frameworks you used in your system. If you are building a health care system, then when new programmers look at the source repository, their first impression should be, “Oh, this is a heath care system.” Those new programmers should be able to learn all the use cases of the system, yet still not know how the system is delivered. They may come to you and say:</p>
<p class="noindent1">“We see some things that look like models—but where are the views and controllers?”</p>
<p class="noindent1">And you should respond:</p>
<p class="noindent1">“Oh, those are details that needn’t concern us at the moment. We’ll decide about them later.”<a id="part0035_page_200"></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0036_ch22"><a class="calibre3" id="part0036_page_201"></a><span class="gray">22</span><br class="calibre12"/>T<small class="calibre7">HE</small> C<small class="calibre7">LEAN</small> A<small class="calibre7">RCHITECTURE</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00082.jpeg"/></div>
<p class="noindent1"><a id="part0036_page_202"></a>Over the last several decades we’ve seen a whole range of ideas regarding the architecture of systems. These include:</p>
<p class="indenthangingb">• Hexagonal Architecture (also known as Ports and Adapters), developed by Alistair Cockburn, and adopted by Steve Freeman and Nat Pryce in their wonderful book <em class="calibre9">Growing Object Oriented Software with Tests</em></p>
<p class="indenthangingb">• DCI from James Coplien and Trygve Reenskaug</p>
<p class="indenthangingb">• BCE, introduced by Ivar Jacobson from his book <em class="calibre9">Object Oriented Software Engineering: A Use-Case Driven Approach</em></p>
<p class="noindent1">Although these architectures all vary somewhat in their details, they are very similar. They all have the same objective, which is the separation of concerns. They all achieve this separation by dividing the software into layers. Each has at least one layer for business rules, and another layer for user and system interfaces.</p>
<p class="noindent1">Each of these architectures produces systems that have the following characteristics:</p>
<p class="indenthangingb">• <em class="calibre9">Independent of frameworks.</em> The architecture does not depend on the existence of some library of feature-laden software. This allows you to use such frameworks as tools, rather than forcing you to cram your system into their limited constraints.</p>
<p class="indenthangingb">• <em class="calibre9">Testable.</em> The business rules can be tested without the UI, database, web server, or any other external element.</p>
<p class="indenthangingb">• <em class="calibre9">Independent of the UI.</em> The UI can change easily, without changing the rest of the system. A web UI could be replaced with a console UI, for example, without changing the business rules.</p>
<p class="indenthangingb">• <em class="calibre9">Independent of the database.</em> You can swap out Oracle or SQL Server for Mongo, BigTable, CouchDB, or something else. Your business rules are not bound to the database.</p>
<p class="indenthangingb">• <em class="calibre9">Independent of any external agency.</em> In fact, your business rules don’t know anything at all about the interfaces to the outside world.</p>
<p class="noindent1">The diagram in <a href="#part0036_ch22fig1">Figure 22.1</a> is an attempt at integrating all these architectures into a single actionable idea.</p>
<div class="fig-heading">
<div class="image1"><a id="part0036_page_203"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00083.jpeg"/></div>
<p class="fig-caption"><a id="part0036_ch22fig1"></a><strong class="calibre8">Figure 22.1</strong> The clean architecture</p>
</div>
<h3 class="h1" id="part0036_toclev_113">T<small class="calibre13">HE</small> D<small class="calibre13">EPENDENCY</small> R<small class="calibre13">ULE</small></h3>
<p class="noindent1">The concentric circles in <a href="#part0036_ch22fig1">Figure 22.1</a> represent different areas of software. In general, the further in you go, the higher level the software becomes. The outer circles are mechanisms. The inner circles are policies.</p>
<p class="noindent1">The overriding rule that makes this architecture work is the <em class="calibre9">Dependency Rule</em>:</p>
<p class="blockquote"><em class="calibre9">Source code dependencies must point only inward, toward higher-level policies.</em></p>
<p class="noindent1">Nothing in an inner circle can know anything at all about something in an outer circle. In particular, the name of something declared in an outer circle must not be mentioned by the code in an inner circle. That includes functions, classes, variables, or any other named software entity.</p>
<p class="noindent1"><a id="part0036_page_204"></a>By the same token, data formats declared in an outer circle should not be used by an inner circle, especially if those formats are generated by a framework in an outer circle. We don’t want anything in an outer circle to impact the inner circles.</p>
<h4 class="h2">E<small class="calibre13">NTITIES</small></h4>
<p class="noindent1">Entities encapsulate enterprise-wide Critical Business Rules. An entity can be an object with methods, or it can be a set of data structures and functions. It doesn’t matter so long as the entities can be used by many different applications in the enterprise.</p>
<p class="noindent1">If you don’t have an enterprise and are writing just a single application, then these entities are the business objects of the application. They encapsulate the most general and high-level rules. They are the least likely to change when something external changes. For example, you would not expect these objects to be affected by a change to page navigation or security. No operational change to any particular application should affect the entity layer.</p>
<h4 class="h2">U<small class="calibre13">SE</small> C<small class="calibre13">ASES</small></h4>
<p class="noindent1">The software in the use cases layer contains <em class="calibre9">application-specific</em> business rules. It encapsulates and implements all of the use cases of the system. These use cases orchestrate the flow of data to and from the entities, and direct those entities to use their Critical Business Rules to achieve the goals of the use case.</p>
<p class="noindent1">We do not expect changes in this layer to affect the entities. We also do not expect this layer to be affected by changes to externalities such as the database, the UI, or any of the common frameworks. The use cases layer is isolated from such concerns.</p>
<p class="noindent1">We do, however, expect that changes to the operation of the application will affect the use cases and, therefore, the software in this layer. If the details of a use case change, then some code in this layer will certainly be affected.</p>
<h4 class="h2"><a class="calibre3" id="part0036_page_205"></a>I<small class="calibre13">NTERFACE</small> A<small class="calibre13">DAPTERS</small></h4>
<p class="noindent1">The software in the interface adapters layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency such as the database or the web. It is this layer, for example, that will wholly contain the MVC architecture of a GUI. The presenters, views, and controllers all belong in the interface adapters layer. The models are likely just data structures that are passed from the controllers to the use cases, and then back from the use cases to the presenters and views.</p>
<p class="noindent1">Similarly, data is converted, in this layer, from the form most convenient for entities and use cases, to the form most convenient for whatever persistence framework is being used (i.e., the database). No code inward of this circle should know anything at all about the database. If the database is a SQL database, then all SQL should be restricted to this layer—and in particular to the parts of this layer that have to do with the database.</p>
<p class="noindent1">Also in this layer is any other adapter necessary to convert data from some external form, such as an external service, to the internal form used by the use cases and entities.</p>
<h4 class="h2">F<small class="calibre13">RAMEWORKS AND</small> D<small class="calibre13">RIVERS</small></h4>
<p class="noindent1">The outermost layer of the model in <a href="#part0036_ch22fig1">Figure 22.1</a> is generally composed of frameworks and tools such as the database and the web framework. Generally you don’t write much code in this layer, other than glue code that communicates to the next circle inward.</p>
<p class="noindent1">The frameworks and drivers layer is where all the details go. The web is a detail. The database is a detail. We keep these things on the outside where they can do little harm.</p>
<h4 class="h2">O<small class="calibre13">NLY</small> F<small class="calibre13">OUR</small> C<small class="calibre13">IRCLES</small>?</h4>
<p class="noindent1">The circles in <a href="#part0036_ch22fig1">Figure 22.1</a> are intended to be schematic: You may find that you need more than just these four. There’s no rule that says you must always have <a id="part0036_page_206"></a>just these four. However, the Dependency Rule always applies. Source code dependencies always point inward. As you move inward, the level of abstraction and policy increases. The outermost circle consists of low-level concrete details. As you move inward, the software grows more abstract and encapsulates higher-level policies. The innermost circle is the most general and highest level.</p>
<h4 class="h2">C<small class="calibre13">ROSSING</small> B<small class="calibre13">OUNDARIES</small></h4>
<p class="noindent1">At the lower right of the diagram in <a href="#part0036_ch22fig1">Figure 22.1</a> is an example of how we cross the circle boundaries. It shows the controllers and presenters communicating with the use cases in the next layer. Note the flow of control: It begins in the controller, moves through the use case, and then winds up executing in the presenter. Note also the source code dependencies: Each points inward toward the use cases.</p>
<p class="noindent1">We usually resolve this apparent contradiction by using the Dependency Inversion Principle. In a language like Java, for example, we would arrange interfaces and inheritance relationships such that the source code dependencies oppose the flow of control at just the right points across the boundary.</p>
<p class="noindent1">For example, suppose the use case needs to call the presenter. This call must not be direct because that would violate the Dependency Rule: No name in an outer circle can be mentioned by an inner circle. So we have the use case call an interface (shown in <a href="#part0036_ch22fig1">Figure 22.1</a> as “use case output port”) in the inner circle, and have the presenter in the outer circle implement it.</p>
<p class="noindent1">The same technique is used to cross all the boundaries in the architectures. We take advantage of dynamic polymorphism to create source code dependencies that oppose the flow of control so that we can conform to the Dependency Rule, no matter which direction the flow of control travels.</p>
<h4 class="h2"><a class="calibre3" id="part0036_page_207"></a>W<small class="calibre13">HICH</small> D<small class="calibre13">ATA</small> C<small class="calibre13">ROSSES THE</small> B<small class="calibre13">OUNDARIES</small></h4>
<p class="noindent1">Typically the data that crosses the boundaries consists of simple data structures. You can use basic structs or simple data transfer objects if you like. Or the data can simply be arguments in function calls. Or you can pack it into a hashmap, or construct it into an object. The important thing is that isolated, simple data structures are passed across the boundaries. We don’t want to cheat and pass Entity objects or database rows. We don’t want the data structures to have any kind of dependency that violates the Dependency Rule.</p>
<p class="noindent1">For example, many database frameworks return a convenient data format in response to a query. We might call this a “row structure.” We don’t want to pass that row structure inward across a boundary. Doing so would violate the Dependency Rule because it would force an inner circle to know something about an outer circle.</p>
<p class="noindent1">Thus, when we pass data across a boundary, it is always in the form that is most convenient for the inner circle.</p>
<h3 class="h1" id="part0036_toclev_114">A T<small class="calibre13">YPICAL</small> S<small class="calibre13">CENARIO</small></h3>
<p class="noindent1">The diagram in <a href="#part0036_ch22fig2">Figure 22.2</a> shows a typical scenario for a web-based Java system using a database. The web server gathers input data from the user and hands it to the <code class="calibre11">Controller</code> on the upper left. The <code class="calibre11">Controller</code> packages that data into a plain old Java object and passes this object through the <code class="calibre11">InputBoundary</code> to the <code class="calibre11">UseCaseInteractor</code>. The <code class="calibre11">UseCaseInteractor</code> interprets that data and uses it to control the dance of the <code class="calibre11">Entities</code>. It also uses the <code class="calibre11">DataAccessInterface</code> to bring the data used by those <code class="calibre11">Entities</code> into memory from the <code class="calibre11">Database</code>. Upon completion, the <code class="calibre11">UseCaseInteractor</code> gathers data from the <code class="calibre11">Entities</code> and constructs the <code class="calibre11">OutputData</code> as another plain old Java object. The <code class="calibre11">OutputData</code> is then passed through the <code class="calibre11">OutputBoundary</code> interface to the <code class="calibre11">Presenter</code>.</p>
<div class="fig-heading">
<div class="image1"><a id="part0036_page_208"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00084.jpeg"/></div>
<p class="fig-caption"><a id="part0036_ch22fig2"></a><strong class="calibre8">Figure 22.2</strong> A typical scenario for a web-based Java system utilizing a database</p>
</div>
<p class="noindent1">The job of the <code class="calibre11">Presenter</code> is to repackage the <code class="calibre11">OutputData</code> into viewable form as the <code class="calibre11">ViewModel</code>, which is yet another plain old Java object. The <code class="calibre11">ViewModel</code> contains mostly <code class="calibre11">Strings</code> and flags that the <code class="calibre11">View</code> uses to display the data. Whereas the <code class="calibre11">OutputData</code> may contain <code class="calibre11">Date</code> objects, the <code class="calibre11">Presenter</code> will load the <code class="calibre11">ViewModel</code> with corresponding <code class="calibre11">Strings</code> already formatted properly for the user. The same is true of <code class="calibre11">Currency</code> objects or any other business-related data. <code class="calibre11">Button</code> and <code class="calibre11">MenuItem</code> names are placed in the <code class="calibre11">ViewModel</code>, as are flags that tell the <code class="calibre11">View</code> whether those <code class="calibre11">Buttons</code> and <code class="calibre11">MenuItems</code> should be gray.</p>
<p class="noindent1">This leaves the <code class="calibre11">View</code> with almost nothing to do other than to move the data from the <code class="calibre11">ViewModel</code> into the <code class="calibre11">HTML</code> page.</p>
<p class="noindent1">Note the directions of the dependencies. All dependencies cross the boundary lines pointing inward, following the Dependency Rule.</p>
<h3 class="h1" id="part0036_toclev_115"><a class="calibre3" id="part0036_page_209"></a>C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">Conforming to these simple rules is not difficult, and it will save you a lot of headaches going forward. By separating the software into layers and conforming to the Dependency Rule, you will create a system that is intrinsically testable, with all the benefits that implies. When any of the external parts of the system become obsolete, such as the database, or the web framework, you can replace those obsolete elements with a minimum of fuss.<a id="part0036_page_210"></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0037_ch23"><a class="calibre3" id="part0037_page_211"></a><span class="gray">23</span><br class="calibre12"/>P<small class="calibre7">RESENTERS AND</small> H<small class="calibre7">UMBLE</small> O<small class="calibre7">BJECTS</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00085.jpeg"/></div>
<p class="noindent1"><a id="part0037_page_212"></a>In <a href="#part0036_ch22">Chapter 22</a>, we introduced the notion of presenters. Presenters are a form of the <em class="calibre9">Humble Object</em> pattern, which helps us identify and protect architectural boundaries. Actually, the Clean Architecture in the last chapter was full of <em class="calibre9">Humble Object</em> implementations.</p>
<h3 class="h1" id="part0037_toclev_116">T<small class="calibre13">HE</small> H<small class="calibre13">UMBLE</small> O<small class="calibre13">BJECT</small> P<small class="calibre13">ATTERN</small></h3>
<p class="noindent1">The <em class="calibre9">Humble Object</em> pattern<sup class="calibre10"><a href="#part0037_ch23fn1" id="part0037_ch23fn-1">1</a></sup> is a design pattern that was originally identified as a way to help unit testers to separate behaviors that are hard to test from behaviors that are easy to test. The idea is very simple: Split the behaviors into two modules or classes. One of those modules is humble; it contains all the hard-to-test behaviors stripped down to their barest essence. The other module contains all the testable behaviors that were stripped out of the humble object.</p>
<p class="noindent1">For example, GUIs are hard to unit test because it is very difficult to write tests that can see the screen and check that the appropriate elements are displayed there. However, most of the behavior of a GUI is, in fact, easy to test. Using the <em class="calibre9">Humble Object</em> pattern, we can separate these two kinds of behaviors into two different classes called the Presenter and the View.</p>
<h3 class="h1" id="part0037_toclev_117">P<small class="calibre13">RESENTERS AND</small> V<small class="calibre13">IEWS</small></h3>
<p class="noindent1">The View is the humble object that is hard to test. The code in this object is kept as simple as possible. It moves data into the GUI but does not process that data.</p>
<p class="noindent1">The Presenter is the testable object. Its job is to accept data from the application and format it for presentation so that the View can simply move it to the screen. For example, if the application wants a date displayed in a field, it will hand the Presenter a <code class="calibre11">Date</code> object. The Presenter will then format that <a id="part0037_page_213"></a>data into an appropriate string and place it in a simple data structure called the View Model, where the View can find it.</p>
<p class="noindent1">If the application wants to display money on the screen, it might pass a <code class="calibre11">Currency</code> object to the Presenter. The Presenter will format that object with the appropriate decimal places and currency markers, creating a string that it can place in the View Model. If that currency value should be turned red if it is negative, then a simple boolean flag in the View model will be set appropriately.</p>
<p class="noindent1">Every button on the screen will have a name. That name will be a string in the View Model, placed there by the presenter. If those buttons should be grayed out, the Presenter will set an appropriate boolean flag in the View model. Every menu item name is a string in the View model, loaded by the Presenter. The names for every radio button, check box, and text field are loaded, by the Presenter, into appropriate strings and booleans in the View model. Tables of numbers that should be displayed on the screen are loaded, by the Presenter, into tables of properly formatted strings in the View model.</p>
<p class="noindent1">Anything and everything that appears on the screen, and that the application has some kind of control over, is represented in the View Model as a string, or a boolean, or an enum. Nothing is left for the View to do other than to load the data from the View Model into the screen. Thus the View is humble.</p>
<h3 class="h1" id="part0037_toclev_118">T<small class="calibre13">ESTING AND</small> A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">It has long been known that testability is an attribute of good architectures. The <em class="calibre9">Humble Object</em> pattern is a good example, because the separation of the behaviors into testable and non-testable parts often defines an architectural boundary. The Presenter/View boundary is one of these boundaries, but there are many others.</p>
<h3 class="h1" id="part0037_toclev_119"><a class="calibre3" id="part0037_page_214"></a>D<small class="calibre13">ATABASE</small> G<small class="calibre13">ATEWAYS</small></h3>
<p class="noindent1">Between the use case interactors and the database are the database gateways.<sup class="calibre10"><a href="#part0037_ch23fn2" id="part0037_ch23fn-2">2</a></sup> These gateways are polymorphic interfaces that contain methods for every create, read, update, or delete operation that can be performed by the application on the database. For example, if the application needs to know the last names of all the users who logged in yesterday, then the <code class="calibre11">UserGateway</code> interface will have a method named <code class="calibre11">getLastNamesOfUsersWhoLoggedInAfter</code> that takes a <code class="calibre11">Date</code> as its argument and returns a list of last names.</p>
<p class="noindent1">Recall that we do not allow SQL in the use cases layer; instead, we use gateway interfaces that have appropriate methods. Those gateways are implemented by classes in the database layer. That implementation is the humble object. It simply uses SQL, or whatever the interface to the database is, to access the data required by each of the methods. The interactors, in contrast, are not humble because they encapsulate application-specific business rules. Although they are not humble, those interactors are <em class="calibre9">testable</em>, because the gateways can be replaced with appropriate stubs and test-doubles.</p>
<h3 class="h1" id="part0037_toclev_120">D<small class="calibre13">ATA</small> M<small class="calibre13">APPERS</small></h3>
<p class="noindent1">Going back to the topic of databases, in which layer do you think ORMs like Hibernate belong?</p>
<p class="noindent1">First, let’s get something straight: There is no such thing as an object relational mapper (ORM). The reason is simple: Objects are not data structures. At least, they are not data structures from their users’ point of view. The users of an object cannot see the data, since it is all private. Those users see only the public methods of that object. So, from the user’s point of view, an object is simply a set of operations.</p>
<p class="noindent1"><a id="part0037_page_215"></a>A data structure, in contrast, is a set of public data variables that have no implied behavior. ORMs would be better named “data mappers,” because they load data into data structures from relational database tables.</p>
<p class="noindent1">Where should such ORM systems reside? In the database layer of course. Indeed, ORMs form another kind of <em class="calibre9">Humble Object</em> boundary between the gateway interfaces and the database.</p>
<h3 class="h1" id="part0037_toclev_121">S<small class="calibre13">ERVICE</small> L<small class="calibre13">ISTENERS</small></h3>
<p class="noindent1">What about services? If your application must communicate with other services, or if your application provides a set of services, will we find the <em class="calibre9">Humble Object</em> pattern creating a service boundary?</p>
<p class="noindent1">Of course! The application will load data into simple data structures and then pass those structures across the boundary to modules that properly format the data and send it to external services. On the input side, the service listeners will receive data from the service interface and format it into a simple data structure that can be used by the application. That data structure is then passed across the service boundary.</p>
<h3 class="h1" id="part0037_toclev_122">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">At each architectural boundary, we are likely to find the <em class="calibre9">Humble Object</em> pattern lurking somewhere nearby. The communication across that boundary will almost always involve some kind of simple data structure, and the boundary will frequently divide something that is hard to test from something that is easy to test. The use of this pattern at architectural boundaries vastly increases the testability of the entire system.</p>
<p class="fn"><a id="part0037_page_216"></a><a href="#part0037_ch23fn-1" id="part0037_ch23fn1">1</a>. <em class="calibre9">xUnit Patterns</em>, Meszaros, Addison-Wesley, 2007, p. 695.</p>
<p class="fn"><a href="#part0037_ch23fn-2" id="part0037_ch23fn2">2</a>. <em class="calibre9">Patterns of Enterprise Application Architecture</em>, Martin Fowler, et. al., Addison-Wesley, 2003, p. 466.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0038_ch24"><a class="calibre3" id="part0038_page_217"></a><span class="gray">24</span><br class="calibre12"/>P<small class="calibre7">ARTIAL</small> B<small class="calibre7">OUNDARIES</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00086.jpeg"/></div>
<p class="noindent1"><a id="part0038_page_218"></a>Full-fledged architectural boundaries are expensive. They require reciprocal polymorphic <code class="calibre11">Boundary</code> interfaces, <code class="calibre11">Input</code> and <code class="calibre11">Output</code> data structures, and all of the dependency management necessary to isolate the two sides into independently compilable and deployable components. That takes a lot of work. It’s also a lot of work to maintain.</p>
<p class="noindent1">In many situations, a good architect might judge that the expense of such a boundary is too high—but might still want to hold a place for such a boundary in case it is needed later.</p>
<p class="noindent1">This kind of anticipatory design is often frowned upon by many in the Agile community as a violation of YAGNI: “You Aren’t Going to Need It.” Architects, however, sometimes look at the problem and think, “Yeah, but I might.” In that case, they may implement a partial boundary.</p>
<h3 class="h1" id="part0038_toclev_123">S<small class="calibre13">KIP THE</small> L<small class="calibre13">AST</small> S<small class="calibre13">TEP</small></h3>
<p class="noindent1">One way to construct a partial boundary is to do all the work necessary to create independently compilable and deployable components, and then simply keep them together in the same component. The reciprocal interfaces are there, the input/output data structures are there, and everything is all set up—but we compile and deploy all of them as a single component.</p>
<p class="noindent1">Obviously, this kind of partial boundary requires the same amount of code and preparatory design work as a full boundary. However, it does not require the administration of multiple components. There’s no version number tracking or release management burden. That difference should not be taken lightly.</p>
<p class="noindent1">This was the early strategy behind <code class="calibre11">FitNesse</code>. The web server component of <code class="calibre11">FitNesse</code> was designed to be separable from the wiki and testing part of <code class="calibre11">FitNesse</code>. The idea was that we might want to create other web-based applications by using that web component. At the same, we did not want users to have to download two components. Recall that one of our design goals was “<em class="calibre9">download and go</em>.” It was our intent that users would download <a id="part0038_page_219"></a>one jar file and execute it without having to hunt for other jar files, work out version compatibilities, and so on.</p>
<p class="noindent1">The story of <code class="calibre11">FitNesse</code> also points out one of the dangers of this approach. Over time, as it became clear that there would never be a need for a separate web component, the separation between the web component and the wiki component began to weaken. Dependencies started to cross the line in the wrong direction. Nowadays, it would be something of a chore to re-separate them.</p>
<h3 class="h1" id="part0038_toclev_124">O<small class="calibre13">NE</small>-D<small class="calibre13">IMENSIONAL</small> B<small class="calibre13">OUNDARIES</small></h3>
<p class="noindent1">The full-fledged architectural boundary uses reciprocal boundary interfaces to maintain isolation in both directions. Maintaining separation in both directions is expensive both in initial setup and in ongoing maintenance.</p>
<p class="noindent1">A simpler structure that serves to hold the place for later extension to a full-fledged boundary is shown in <a href="#part0038_ch24fig1">Figure 24.1</a>. It exemplifies the traditional <em class="calibre9">Strategy</em> pattern. A <code class="calibre11">ServiceBoundary</code> interface is used by clients and implemented by <code class="calibre11">ServiceImpl</code> classes.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00087.jpeg"/></div>
<p class="fig-caption"><a id="part0038_ch24fig1"></a><strong class="calibre8">Figure 24.1</strong> The Strategy pattern</p>
</div>
<p class="noindent1">It should be clear that this sets the stage for a future architectural boundary. The necessary dependency inversion is in place in an attempt to isolate the <code class="calibre11">Client</code> from the <code class="calibre11">ServiceImpl</code>. It should also be clear that the separation can degrade pretty rapidly, as shown by the nasty dotted arrow in the diagram. Without reciprocal interfaces, nothing prevents this kind of backchannel other than the diligence and discipline of the developers and architects.</p>
<h3 class="h1" id="part0038_toclev_125"><a class="calibre3" id="part0038_page_220"></a>F<small class="calibre13">ACADES</small></h3>
<p class="noindent1">An even simpler boundary is the <em class="calibre9">Facade</em> pattern, illustrated in <a href="#part0038_ch24fig2">Figure 24.2</a>. In this case, even the dependency inversion is sacrificed. The boundary is simply defined by the <code class="calibre11">Facade</code> class, which lists all the services as methods, and deploys the service calls to classes that the client is not supposed to access.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00088.jpeg"/></div>
<p class="fig-caption"><a id="part0038_ch24fig2"></a><strong class="calibre8">Figure 24.2</strong> The Facade pattern</p>
</div>
<p class="noindent1">Note, however, that the <code class="calibre11">Client</code> has a transitive dependency on all those service classes. In static languages, a change to the source code in one of the <code class="calibre11">Service</code> classes will force the <code class="calibre11">Client</code> to recompile. Also, you can imagine how easy backchannels are to create with this structure.</p>
<h3 class="h1" id="part0038_toclev_126">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">We’ve seen three simple ways to partially implement an architectural boundary. There are, of course, many others. These three strategies are simply offered as examples.</p>
<p class="noindent1">Each of these approaches has its own set of costs and benefits. Each is appropriate, in certain contexts, as a placeholder for an eventual full-fledged boundary. Each can also be degraded if that boundary never materializes.</p>
<p class="noindent1">It is one of the functions of an architect to decide where an architectural boundary might one day exist, and whether to fully or partially implement that boundary.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0039_ch25"><a class="calibre3" id="part0039_page_221"></a><span class="gray">25</span><br class="calibre12"/>L<small class="calibre7">AYERS AND</small> B<small class="calibre7">OUNDARIES</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00089.jpeg"/></div>
<p class="noindent1"><a id="part0039_page_222"></a>It is easy to think of systems as being composed of three components: UI, business rules, and database. For some simple systems, this is sufficient. For most systems, though, the number of components is larger than that.</p>
<p class="noindent1">Consider, for example, a simple computer game. It is easy to imagine the three components. The UI handles all messages from the player to the game rules. The game rules store the state of the game in some kind of persistent data structure. But is that all there is?</p>
<h3 class="h1" id="part0039_toclev_127">H<small class="calibre13">UNT THE</small> W<small class="calibre13">UMPUS</small></h3>
<p class="noindent1">Let’s put some flesh on these bones. Let’s assume that the game is the venerable Hunt the Wumpus adventure game from 1972. This text-based game uses very simple commands like GO EAST and SHOOT WEST. The player enters a command, and the computer responds with what the player sees, smells, hears, and experiences. The player is hunting for a Wumpus in a system of caverns, and must avoid traps, pits, and other dangers lying in wait. If you are interested, the rules of the game are easy to find on the web.</p>
<p class="noindent1">Let’s assume that we’ll keep the text-based UI, but decouple it from the game rules so that our version can use different languages in different markets. The game rules will communicate with the UI component using a language-independent API, and the UI will translate the API into the appropriate human language.</p>
<p class="noindent1">If the source code dependencies are properly managed, as shown in <a href="#part0039_ch25fig1">Figure 25.1</a>, then any number of UI components can reuse the same game rules. The game rules do not know, nor do they care, which human language is being used.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00090.jpeg"/></div>
<p class="fig-caption"><a id="part0039_ch25fig1"></a><strong class="calibre8">Figure 25.1</strong> Any number of UI components can reuse the game rules</p>
</div>
<p class="noindent1"><a id="part0039_page_223"></a>Let’s also assume that the state of the game is maintained on some persistent store—perhaps in flash, or perhaps in the cloud, or maybe just in RAM. In any of those cases, we don’t want the game rules to know the details. So, again, we’ll create an API that the game rules can use to communicate with the data storage component.</p>
<p class="noindent1">We don’t want the game rules to know anything about the different kinds of data storage, so the dependencies have to be properly directed following the Dependency Rule, as shown in <a href="#part0039_ch25fig2">Figure 25.2</a>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00091.jpeg"/></div>
<p class="fig-caption"><a id="part0039_ch25fig2"></a><strong class="calibre8">Figure 25.2</strong> Following the Dependency Rule</p>
</div>
<h3 class="h1" id="part0039_toclev_128">C<small class="calibre13">LEAN</small> A<small class="calibre13">RCHITECTURE</small>?</h3>
<p class="noindent1">It should be clear that we could easily apply the clean architecture approach in this context,<sup class="calibre10"><a id="part0039_ch25fn1"></a><a href="#part0039_ch25fn-1">1</a></sup> with all the use cases, boundaries, entities, and corresponding data structures. But have we really found all the significant architectural boundaries?</p>
<p class="noindent1">For example, language is not the only axis of change for the UI. We also might want to vary the mechanism by which we communicate the text. For example, we might want to use a normal shell window, or text messages, or a chat application. There are many different possibilities.</p>
<p class="noindent1">That means that there is a potential architectural boundary defined by this axis of change. Perhaps we should construct an API that crosses that boundary and isolates the language from the communications mechanism; that idea is illustrated in <a href="#part0039_ch25fig3">Figure 25.3</a>.</p>
<div class="fig-heading">
<div class="image1"><a id="part0039_page_224"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00092.jpeg"/></div>
<p class="fig-caption"><a id="part0039_ch25fig3"></a><strong class="calibre8">Figure 25.3</strong> The revised diagram</p>
</div>
<p class="noindent1">The diagram in <a href="#part0039_ch25fig3">Figure 25.3</a> has gotten a little complicated, but should contain no surprises. The dashed outlines indicate abstract components that define an API that is implemented by the components above or below them. For example, the <code class="calibre11">Language</code> API is implemented by <code class="calibre11">English</code> and <code class="calibre11">Spanish</code>.</p>
<p class="noindent1"><code class="calibre11">GameRules</code> communicates with <code class="calibre11">Language</code> through an API that <code class="calibre11">GameRules</code> defines and <code class="calibre11">Language</code> implements. <code class="calibre11">Language</code> communicates with <code class="calibre11">TextDelivery</code> using an API that <code class="calibre11">Language</code> defines but <code class="calibre11">TextDelivery</code> implements. The API is defined and owned by the user, rather than by the implementer.</p>
<p class="noindent1">If we were to look inside <code class="calibre11">GameRules</code>, we would find polymorphic <code class="calibre11">Boundary</code> interfaces used by the code inside <code class="calibre11">GameRules</code> and implemented by the code inside the <code class="calibre11">Language</code> component. We would also find polymorphic <code class="calibre11">Boundary</code> interfaces used by <code class="calibre11">Language</code> and implemented by code inside <code class="calibre11">GameRules</code>.</p>
<p class="noindent1">If we were to look inside of <code class="calibre11">Language</code>, we would find the same thing: Polymorphic <code class="calibre11">Boundary</code> interfaces implemented by the code inside <code class="calibre11">TextDelivery</code>, and polymorphic <code class="calibre11">Boundary</code> interfaces used by <code class="calibre11">TextDelivery</code> and implemented by <code class="calibre11">Language</code>.</p>
<p class="noindent1">In each case, the API defined by those <code class="calibre11">Boundary</code> interfaces is owned by the upstream component.</p>
<p class="noindent1"><a id="part0039_page_225"></a>The variations, such as <code class="calibre11">English</code>, <code class="calibre11">SMS</code>, and <code class="calibre11">CloudData</code>, are provided by polymorphic interfaces defined in the abstract API component, and implemented by the concrete components that serve them. For example, we would expect polymorphic interfaces defined in <code class="calibre11">Language</code> to be implemented by <code class="calibre11">English</code> and <code class="calibre11">Spanish</code>.</p>
<p class="noindent1">We can simplify this diagram by eliminating all the variations and focusing on just the API components. <a href="#part0039_ch25fig4">Figure 25.4</a> shows this diagram.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00093.jpeg"/></div>
<p class="fig-caption"><a id="part0039_ch25fig4"></a><strong class="calibre8">Figure 25.4</strong> Simplified diagram</p>
</div>
<p class="noindent1">Notice that the diagram is oriented in <a href="#part0039_ch25fig4">Figure 25.4</a> so that all the arrows point up. This puts <code class="calibre11">GameRules</code> at the top. This orientation makes sense because <code class="calibre11">GameRules</code> is the component that contains the highest-level policies.</p>
<p class="noindent1">Consider the direction of information flow. All input comes from the user through the <code class="calibre11">TextDelivery</code> component at the bottom left. That information rises through the <code class="calibre11">Language</code> component, getting translated into commands to <code class="calibre11">GameRules</code>. <code class="calibre11">GameRules</code> processes the user input and sends appropriate data down to <code class="calibre11">DataStorage</code> at the lower right.</p>
<p class="noindent1"><a id="part0039_page_226"></a><code class="calibre11">GameRules</code> then sends output back down to <code class="calibre11">Language</code>, which translates the API back to the appropriate language and then delivers that language to the user through <code class="calibre11">TextDelivery</code>.</p>
<p class="noindent1">This organization effectively divides the flow of data into two streams.<sup class="calibre10"><a id="part0039_ch25fn2"></a><a href="#part0039_ch25fn-2">2</a></sup> The stream on the left is concerned with communicating with the user, and the stream on the right is concerned with data persistence. Both streams meet at the top<sup class="calibre10"><a id="part0039_ch25fn3"></a><a href="#part0039_ch25fn-3">3</a></sup> at <code class="calibre11">GameRules</code>, which is the ultimate processor of the data that goes through both streams.</p>
<h3 class="h1" id="part0039_toclev_129">C<small class="calibre13">ROSSING THE</small> S<small class="calibre13">TREAMS</small></h3>
<p class="noindent1">Are there always two data streams as in this example? No, not at all. Imagine that we would like to play Hunt the Wumpus on the net with multiple players. In this case, we would need a network component, like that shown in <a href="#part0039_ch25fig5">Figure 25.5</a>. This organization divides the data flow into three streams, all controlled by the <code class="calibre11">GameRules</code>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00094.jpeg"/></div>
<p class="fig-caption"><a id="part0039_ch25fig5"></a><strong class="calibre8">Figure 25.5</strong> Adding a network component</p>
</div>
<p class="noindent1">So, as systems become more complex, the component structure may split into many such streams.</p>
<h3 class="h1" id="part0039_toclev_130"><a class="calibre3" id="part0039_page_227"></a>S<small class="calibre13">PLITTING THE</small> S<small class="calibre13">TREAMS</small></h3>
<p class="noindent1">At this point you may be thinking that all the streams eventually meet at the top in a single component. If only life were so simple! The reality, of course, is much more complex.</p>
<p class="noindent1">Consider the <code class="calibre11">GameRules</code> component for Hunt the Wumpus. Part of the game rules deal with the mechanics of the map. They know how the caverns are connected, and which objects are located in each cavern. They know how to move the player from cavern to cavern, and how to determine the events that the player must deal with.</p>
<p class="noindent1">But there is another set of policies at an even higher level—policies that know the health of the player, and the cost or benefit of a particular event. These policies could cause the player to gradually lose health, or to gain health by discovering food. The lower-level mechanics policy would declare events to this higher-level policy, such as <code class="calibre11">FoundFood</code> or <code class="calibre11">FellInPit</code>. The higher-level policy would then manage the state of the player (as shown in <a href="#part0039_ch25fig6">Figure 25.6</a>). Eventually that policy would decide whether the player wins or loses.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00095.jpeg"/></div>
<p class="fig-caption"><a id="part0039_ch25fig6"></a><strong class="calibre8">Figure 25.6</strong> The higher-level policy manages the player</p>
</div>
<p class="noindent1"><a id="part0039_page_228"></a>Is this an architectural boundary? Do we need an API that separates <code class="calibre11">MoveManagement</code> from <code class="calibre11">PlayerManagement</code>? Well, let’s make this a bit more interesting and add micro-services.</p>
<p class="noindent1">Let’s assume that we’ve got a massive multiplayer version of Hunt the Wumpus. <code class="calibre11">MoveManagement</code> is handled locally within the player’s computer, but <code class="calibre11">PlayerManagement</code> is handled by a server. <code class="calibre11">PlayerManagement</code> offers a micro-service API to all the connected <code class="calibre11">MoveManagement</code> components.</p>
<p class="noindent1">The diagram in <a href="#part0039_ch25fig7">Figure 25.7</a> depicts this scenario in a somewhat abbreviated fashion. The <code class="calibre11">Network</code> elements are a bit more complex than depicted—but you can probably still get the idea. A full-fledged architectural boundary exists between <code class="calibre11">MoveManagement</code> and <code class="calibre11">PlayerManagement</code> in this case.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00096.jpeg"/></div>
<p class="fig-caption"><a id="part0039_ch25fig7"></a><strong class="calibre8">Figure 25.7</strong> Adding a micro-service API</p>
</div>
<h3 class="h1" id="part0039_toclev_131">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">What does all this mean? Why have I taken this absurdly simply program, which could be implemented in 200 lines of Kornshell, and extrapolated it out with all these crazy architectural boundaries?</p>
<p class="noindent1">This example is intended to show that architectural boundaries exist everywhere. We, as architects, must be careful to recognize when they are needed. We also have to be aware that such boundaries, when fully implemented, are expensive. <a id="part0039_page_229"></a>At the same time, we have to recognize that when such boundaries are ignored, they are very expensive to add in later—even in the presence of comprehensive test-suites and refactoring discipline.</p>
<p class="noindent1">So what do we do, we architects? The answer is dissatisfying. On the one hand, some very smart people have told us, over the years, that we should not anticipate the need for abstraction. This is the philosophy of YAGNI: “You aren’t going to need it.” There is wisdom in this message, since over-engineering is often much worse than under-engineering. On the other hand, when you discover that you truly do need an architectural boundary where none exists, the costs and risks can be very high to add such a boundary.</p>
<p class="noindent1">So there you have it. O Software Architect, you must see the future. You must guess—intelligently. You must weigh the costs and determine where the architectural boundaries lie, and which should be fully implemented, and which should be partially implemented, and which should be ignored.</p>
<p class="noindent1">But this is not a one-time decision. You don’t simply decide at the start of a project which boundaries to implement and which to ignore. Rather, you <em class="calibre9">watch</em>. You pay attention as the system evolves. You note where boundaries may be required, and then carefully watch for the first inkling of friction because those boundaries don’t exist.</p>
<p class="noindent1">At that point, you weigh the costs of implementing those boundaries versus the cost of ignoring them—and you review that decision frequently. Your goal is to implement the boundaries right at the inflection point where the cost of implementing becomes less than the cost of ignoring.</p>
<p class="noindent1">It takes a watchful eye.<a id="part0039_page_230"></a></p>
<p class="fn"><a id="part0039_ch25fn-1"></a><a href="#part0039_ch25fn1">1</a>. It should be just as clear that we would not apply the clean architecture approach to something as trivial as this game. After all, the entire program can probably be written in 200 lines of code or less. In this case, we’re using a simple program as a proxy for a much larger system with significant architectural boundaries.</p>
<p class="fn"><a id="part0039_ch25fn-2"></a><a href="#part0039_ch25fn2">2</a>. If you are confused by the direction of the arrows, remember that they point in the direction of source code dependencies, not in the direction of data flow.</p>
<p class="fn"><a id="part0039_ch25fn-3"></a><a href="#part0039_ch25fn3">3</a>. In days long past, we would have called that top component the Central Transform. <em class="calibre9">See Practical Guide to Structured Systems Design</em>, 2nd ed., Meilir Page-Jones, 1988.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0040_ch26"><a class="calibre3" id="part0040_page_231"></a><span class="gray">26</span><br class="calibre12"/>T<small class="calibre7">HE</small> M<small class="calibre7">AIN</small> C<small class="calibre7">OMPONENT</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00097.jpeg"/></div>
<p class="noindent1"><a id="part0040_page_232"></a>In every system, there is at least one component that creates, coordinates, and oversees the others. I call this component <code class="calibre11">Main</code>.</p>
<h3 class="h1" id="part0040_toclev_132">T<small class="calibre13">HE</small> U<small class="calibre13">LTIMATE</small> D<small class="calibre13">ETAIL</small></h3>
<p class="noindent1">The <code class="calibre11">Main</code> component is the ultimate detail—the lowest-level policy. It is the initial entry point of the system. Nothing, other than the operating system, depends on it. Its job is to create all the Factories, Strategies, and other global facilities, and then hand control over to the high-level abstract portions of the system.</p>
<p class="noindent1">It is in this <code class="calibre11">Main</code> component that dependencies should be injected by a Dependency Injection framework. Once they are injected into <code class="calibre11">Main</code>, <code class="calibre11">Main</code> should distribute those dependencies normally, without using the framework.</p>
<p class="noindent1">Think of <code class="calibre11">Main</code> as the dirtiest of all the dirty components.</p>
<p class="noindent1">Consider the following <code class="calibre11">Main</code> component from a recent version of Hunt the Wumpus. Notice how it loads up all the strings that we don’t want the main body of the code to know about.</p>
<p class="codelink"><a href="#part0060_split_001_pch26ex01a" id="part0040_pch26ex01">Click here to view code image</a></p>
<p class="pre2">public class Main implements HtwMessageReceiver {<br class="calibre6"/>
  private static HuntTheWumpus game;<br class="calibre6"/>
  private static int hitPoints = 10;<br class="calibre6"/>
  private static final List&lt;String&gt; caverns = new   ArrayList&lt;&gt;();<br class="calibre6"/>
  private static final String[] environments = new String[]{<br class="calibre6"/>
    "bright",<br class="calibre6"/>
    "humid",<br class="calibre6"/>
    "dry",<br class="calibre6"/>
    "creepy",<br class="calibre6"/>
    "ugly",<br class="calibre6"/>
    "foggy",<br class="calibre6"/>
    "hot",<br class="calibre6"/>
<a id="part0040_page_233"></a>
    "cold",<br class="calibre6"/>
    "drafty",<br class="calibre6"/>
    "dreadful"<br class="calibre6"/>
  };<br class="calibre6"/>
 <br class="calibre6"/>
  private static final String[] shapes = new String[] {<br class="calibre6"/>
    "round",<br class="calibre6"/>
    "square",<br class="calibre6"/>
    "oval",<br class="calibre6"/>
    "irregular",<br class="calibre6"/>
    "long",<br class="calibre6"/>
    "craggy",<br class="calibre6"/>
    "rough",<br class="calibre6"/>
    "tall",<br class="calibre6"/>
    "narrow"<br class="calibre6"/>
  };<br class="calibre6"/>
 <br class="calibre6"/>
  private static final String[] cavernTypes = new String[] {<br class="calibre6"/>
    "cavern",<br class="calibre6"/>
    "room",<br class="calibre6"/>
    "chamber",<br class="calibre6"/>
    "catacomb",<br class="calibre6"/>
    "crevasse",<br class="calibre6"/>
    "cell",<br class="calibre6"/>
    "tunnel",<br class="calibre6"/>
    "passageway",<br class="calibre6"/>
    "hall",<br class="calibre6"/>
    "expanse"<br class="calibre6"/>
  };<br class="calibre6"/>
 <br class="calibre6"/>
  private static final String[] adornments = new String[] {<br class="calibre6"/>
<a id="part0040_page_234"></a>
   "smelling of sulfur",<br class="calibre6"/>
    "with engravings on the walls",<br class="calibre6"/>
    "with a bumpy floor",<br class="calibre6"/>
    "",<br class="calibre6"/>
    "littered with garbage",<br class="calibre6"/>
    "spattered with guano",<br class="calibre6"/>
    "with piles of Wumpus droppings",<br class="calibre6"/>
    "with bones scattered around",<br class="calibre6"/>
    "with a corpse on the floor",<br class="calibre6"/>
    "that seems to vibrate",<br class="calibre6"/>
    "that feels stuffy",<br class="calibre6"/>
    "that fills you with dread"<br class="calibre6"/>
  };</p>
<p class="noindent1">Now here’s the <code class="calibre11">main</code> function. Notice how it uses the <code class="calibre11">HtwFactory</code> to create the game. It passes in the name of the class, <code class="calibre11">htw.game.HuntTheWumpusFacade</code>, because that class is even dirtier than <code class="calibre11">Main</code>. This prevents changes in that class from causing <code class="calibre11">Main</code> to recompile/redeploy.</p>
<p class="codelink"><a href="#part0060_split_005_pch26ex02a" id="part0040_pch26ex02">Click here to view code image</a></p>
<p class="pre2">public static void main(String[] args) throws IOException {<br class="calibre6"/>
   game = HtwFactory.makeGame("htw.game.HuntTheWumpusFacade",<br class="calibre6"/>
                                 new Main());<br class="calibre6"/>
   createMap();<br class="calibre6"/>
   BufferedReader br = <br class="calibre6"/>
     new BufferedReader(new InputStreamReader(System.in));<br class="calibre6"/>
   game.makeRestCommand().execute();<br class="calibre6"/>
   while (true) {<br class="calibre6"/>
     System.out.println(game.getPlayerCavern());<br class="calibre6"/>
     System.out.println("Health: " + hitPoints + " arrows: " + <br class="calibre6"/>
                           game.getQuiver());<br class="calibre6"/>
     HuntTheWumpus.Command c = game.makeRestCommand();<br class="calibre6"/>
<a id="part0040_page_235"></a>
      System.out.println("&gt;");<br class="calibre6"/>
      String command = br.readLine();<br class="calibre6"/>
      if (command.equalsIgnoreCase("e"))<br class="calibre6"/>
        c = game.makeMoveCommand(EAST);<br class="calibre6"/>
      else if (command.equalsIgnoreCase("w"))<br class="calibre6"/>
        c = game.makeMoveCommand(WEST);<br class="calibre6"/>
      else if (command.equalsIgnoreCase("n"))<br class="calibre6"/>
        c = game.makeMoveCommand(NORTH);<br class="calibre6"/>
      else if (command.equalsIgnoreCase("s"))<br class="calibre6"/>
        c = game.makeMoveCommand(SOUTH);<br class="calibre6"/>
      else if (command.equalsIgnoreCase("r"))<br class="calibre6"/>
        c = game.makeRestCommand();<br class="calibre6"/>
      else if (command.equalsIgnoreCase("sw"))<br class="calibre6"/>
        c = game.makeShootCommand(WEST);<br class="calibre6"/>
      else if (command.equalsIgnoreCase("se"))<br class="calibre6"/>
        c = game.makeShootCommand(EAST);<br class="calibre6"/>
      else if (command.equalsIgnoreCase("sn"))<br class="calibre6"/>
        c = game.makeShootCommand(NORTH);<br class="calibre6"/>
      else if (command.equalsIgnoreCase("ss"))<br class="calibre6"/>
        c = game.makeShootCommand(SOUTH);<br class="calibre6"/>
      else if (command.equalsIgnoreCase("q"))<br class="calibre6"/>
        return;<br class="calibre6"/>
 <br class="calibre6"/>
      c.execute();<br class="calibre6"/>
    }<br class="calibre6"/>
  }</p>
<p class="noindent1">Notice also that <code class="calibre11">main</code> creates the input stream and contains the main loop of the game, interpreting the simple input commands, but then defers all processing to other, higher-level components.</p>
<p class="noindent1"><a id="part0040_page_236"></a>Finally, notice that <code class="calibre11">main</code> creates the map.</p>
<p class="codelink"><a href="#part0060_split_007_pch26ex03a" id="part0040_pch26ex03">Click here to view code image</a></p>
<p class="pre2"> private static void createMap() {<br class="calibre6"/>
   int nCaverns = (int) (Math.random() * 30.0 + 10.0);<br class="calibre6"/>
   while (nCaverns-- &gt; 0)<br class="calibre6"/>
     caverns.add(makeName());<br class="calibre6"/>
 <br class="calibre6"/>
    for (String cavern : caverns) {<br class="calibre6"/>
      maybeConnectCavern(cavern, NORTH);<br class="calibre6"/>
      maybeConnectCavern(cavern, SOUTH);<br class="calibre6"/>
      maybeConnectCavern(cavern, EAST);<br class="calibre6"/>
      maybeConnectCavern(cavern, WEST);<br class="calibre6"/>
    }<br class="calibre6"/>
 <br class="calibre6"/>
    String playerCavern = anyCavern();<br class="calibre6"/>
    game.setPlayerCavern(playerCavern);<br class="calibre6"/>
    game.setWumpusCavern(anyOther(playerCavern));<br class="calibre6"/>
    game.addBatCavern(anyOther(playerCavern));<br class="calibre6"/>
    game.addBatCavern(anyOther(playerCavern));<br class="calibre6"/>
    game.addBatCavern(anyOther(playerCavern));<br class="calibre6"/>
 <br class="calibre6"/>
    game.addPitCavern(anyOther(playerCavern));<br class="calibre6"/>
    game.addPitCavern(anyOther(playerCavern));<br class="calibre6"/>
    game.addPitCavern(anyOther(playerCavern));<br class="calibre6"/>
 <br class="calibre6"/>
    game.setQuiver(5);<br class="calibre6"/>
  }<br class="calibre6"/>
 <br class="calibre6"/>
  // much code removed…<br class="calibre6"/>
}</p>
<p class="noindent1"><a id="part0040_page_237"></a>The point is that <code class="calibre11">Main</code> is a dirty low-level module in the outermost circle of the clean architecture. It loads everything up for the high level system, and then hands control over to it.</p>
<h3 class="h1" id="part0040_toclev_133">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">Think of <code class="calibre11">Main</code> as a plugin to the application—a plugin that sets up the initial conditions and configurations, gathers all the outside resources, and then hands control over to the high-level policy of the application. Since it is a plugin, it is possible to have many <code class="calibre11">Main</code> components, one for each configuration of your application.</p>
<p class="noindent1">For example, you could have a <code class="calibre11">Main</code> plugin for <em class="calibre9">Dev</em>, another for <em class="calibre9">Test</em>, and yet another for <em class="calibre9">Production</em>. You could also have a <code class="calibre11">Main</code> plugin for each country you deploy to, or each jurisdiction, or each customer.</p>
<p class="noindent1">When you think about <code class="calibre11">Main</code> as a plugin component, sitting behind an architectural boundary, the problem of configuration becomes a lot easier to solve.<a id="part0040_page_238"></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0041_ch27"><a class="calibre3" id="part0041_page_239"></a><span class="gray">27</span><br class="calibre12"/>S<small class="calibre7">ERVICES:</small> G<small class="calibre7">REAT AND</small> S<small class="calibre7">MALL</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00098.jpeg"/></div>
<p class="noindent1">Service-oriented “architectures” and micro-service “architectures” have become very popular of late. The reasons for their current popularity include the following:</p>
<p class="indenthangingb">• Services seem to be strongly decoupled from each other. As we shall see, this is only partially true.</p>
<p class="indenthangingb">• Services appear to support independence of development and deployment. Again, as we shall see, this is only partially true.</p>
<h3 class="h1" id="part0041_toclev_134"><a class="calibre3" id="part0041_page_240"></a>S<small class="calibre13">ERVICE</small> A<small class="calibre13">RCHITECTURE</small>?</h3>
<p class="noindent1">First, let’s consider the notion that using services, by their nature, is an architecture. This is patently untrue. The architecture of a system is defined by boundaries that separate high-level policy from low-level detail and follow the Dependency Rule. Services that simply separate application behaviors are little more than expensive function calls, and are not necessarily architecturally significant.</p>
<p class="noindent1">This is not to say that all services <em class="calibre9">should</em> be architecturally significant. There are often substantial benefits to creating services that separate functionality across processes and platforms—whether they obey the Dependency Rule or not. It’s just that services, in and of themselves, do not define an architecture.</p>
<p class="noindent1">A helpful analogy is the organization of functions. The architecture of a monolithic or component-based system is defined by certain function calls that cross architectural boundaries and follow the Dependency Rule. Many other functions in those systems, however, simply separate one behavior from another and are not architecturally significant.</p>
<p class="noindent1">So it is with services. Services are, after all, just function calls across process and/or platform boundaries. Some of those services are architecturally significant, and some aren’t. Our interest, in this chapter, is with the former.</p>
<h3 class="h1" id="part0041_toclev_135">S<small class="calibre13">ERVICE</small> B<small class="calibre13">ENEFITS</small>?</h3>
<p class="noindent1">The question mark in the preceding heading indicates that this section is going to challenge the current popular orthodoxy of service architecture. Let’s tackle the benefits one at a time.</p>
<h4 class="h2">T<small class="calibre13">HE</small> D<small class="calibre13">ECOUPLING</small> F<small class="calibre13">ALLACY</small></h4>
<p class="noindent1">One of the big supposed benefits of breaking a system up into services is that services are strongly decoupled from each other. After all, each service runs in a different process, or even a different processor; therefore those services do not have access to each other’s variables. What’s more, the interface of each service must be well defined.</p>
<p class="noindent1"><a id="part0041_page_241"></a>There is certainly some truth to this—but not very much truth. Yes, services are decoupled at the level of individual variables. However, they can still be coupled by shared resources within a processor, or on the network. What’s more, they are strongly coupled by the data they share.</p>
<p class="noindent1">For example, if a new field is added to a data record that is passed between services, then every service that operates on the new field must be changed. The services must also strongly agree about the interpretation of the data in that field. Thus those services are strongly coupled to the data record and, therefore, indirectly coupled to each other.</p>
<p class="noindent1">As for interfaces being well defined, that’s certainly true—but it is no less true for functions. Service interfaces are no more formal, no more rigorous, and no better defined than function interfaces. Clearly, then, this benefit is something of an illusion.</p>
<h4 class="h2">T<small class="calibre13">HE</small> F<small class="calibre13">ALLACY OF</small> I<small class="calibre13">NDEPENDENT</small> D<small class="calibre13">EVELOPMENT AND</small> D<small class="calibre13">EPLOYMENT</small></h4>
<p class="noindent1">Another of the supposed benefits of services is that they can be owned and operated by a dedicated team. That team can be responsible for writing, maintaining, and operating the service as part of a dev-ops strategy. This independence of development and deployment is presumed to be <em class="calibre9">scalable</em>. It is believed that large enterprise systems can be created from dozens, hundreds, or even thousands of independently developable and deployable services. Development, maintenance, and operation of the system can be partitioned between a similar number of independent teams.</p>
<p class="noindent1">There is some truth to this belief—but only some. First, history has shown that large enterprise systems can be built from monoliths and component-based systems as well as service-based systems. Thus services are not the only option for building scalable systems.</p>
<p class="noindent1">Second, the decoupling fallacy means that services cannot always be independently developed, deployed, and operated. To the extent that they are coupled by data or behavior, the development, deployment, and operation must be coordinated.</p>
<h3 class="h1" id="part0041_toclev_136"><a class="calibre3" id="part0041_page_242"></a>T<small class="calibre13">HE</small> K<small class="calibre13">ITTY</small> P<small class="calibre13">ROBLEM</small></h3>
<p class="noindent1">As an example of these two fallacies, let’s look at our taxi aggregator system again. Remember, this system knows about many taxi providers in a given city, and allows customers to order rides. Let’s assume that the customers select taxis based on a number of criteria, such as pickup time, cost, luxury, and driver experience.</p>
<p class="noindent1">We wanted our system to be scalable, so we chose to build it out of lots of little micro-services. We subdivided our development staff into many small teams, each of which is responsible for developing, maintaining, and operating a correspondingly<sup class="calibre10"><a id="part0041_ch27fn1"></a><a href="#part0041_ch27fn-1">1</a></sup> small number of services.</p>
<p class="noindent1">The diagram in <a href="#part0041_ch27fig1">Figure 27.1</a> shows how our fictitious architects arranged services to implement this application. The <code class="calibre11">TaxiUI</code> service deals with the customers, who use mobile devices to order taxis. The <code class="calibre11">TaxiFinder</code> service examines the inventories of the various <code class="calibre11">TaxiSuppliers</code> and determines which taxies are possible candidates for the user. It deposits these into a short-term data record attached to that user. The <code class="calibre11">TaxiSelector</code> service takes the user’s criteria of cost, time, luxury, and so forth, and chooses an appropriate taxi from among the candidates. It hands that taxi off to the <code class="calibre11">TaxiDispatcher</code> service, which orders the appropriate taxi.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00099.jpeg"/></div>
<p class="fig-caption"><a id="part0041_ch27fig1"></a><strong class="calibre8">Figure 27.1</strong> Services arranged to implement the taxi aggregator system</p>
</div>
<p class="noindent1"><a id="part0041_page_243"></a>Now let us suppose that this system has been in operation for more than a year. Our staff of developers have been happily developing new features while maintaining and operating all these services.</p>
<p class="noindent1">One bright and cheerful day, the marketing department holds a meeting with the development team. In this meeting, they announce their plans to offer a kitten delivery service to the city. Users can order kittens to be delivered to their homes or to their places of business.</p>
<p class="noindent1">The company will set up several kitten collection points across the city. When a kitten order is placed, a nearby taxi will be selected to collect a kitten from one of those collection points, and then deliver it to the appropriate address.</p>
<p class="noindent1">One of the taxi suppliers has agreed to participate in this program. Others are likely to follow. Still others may decline.</p>
<p class="noindent1">Of course, some drivers may be allergic to cats, so those drivers should never be selected for this service. Also, some customers will undoubtedly have similar allergies, so a vehicle that has been used to deliver kittens within the last 3 days should not be selected for customers who declare such allergies.</p>
<p class="noindent1">Look at that diagram of services. How many of those services will have to change to implement this feature? <em class="calibre9">All of them</em>. Clearly, the development and deployment of the kitty feature will have to be very carefully coordinated.</p>
<p class="noindent1">In other words, the services are all coupled, and cannot be independently developed, deployed, and maintained.</p>
<p class="noindent1">This is the problem with cross-cutting concerns. Every software system must face this problem, whether service oriented or not. Functional decompositions, of the kind depicted in the service diagram in <a href="#part0041_ch27fig1">Figure 27.1</a>, are very vulnerable to new features that cut across all those functional behaviors.</p>
<h3 class="h1" id="part0041_toclev_137"><a class="calibre3" id="part0041_page_244"></a>O<small class="calibre13">BJECTS TO THE</small> R<small class="calibre13">ESCUE</small></h3>
<p class="noindent1">How would we have solved this problem in a component-based architecture? Careful consideration of the SOLID design principles would have prompted us to create a set of classes that could be polymorphically extended to handle new features.</p>
<p class="noindent1">The diagram in <a href="#part0041_ch27fig2">Figure 27.2</a> shows the strategy. The classes in this diagram roughly correspond to the services shown in <a href="#part0041_ch27fig1">Figure 27.1</a>. However, note the boundaries. Note also that the dependencies follow the Dependency Rule.</p>
<p class="noindent1">Much of the logic of the original services is preserved within the base classes of the object model. However, that portion of the logic that was specific to <em class="calibre9">rides</em> has been extracted into a <code class="calibre11">Rides</code> component. The new feature for kittens has been placed into a <code class="calibre11">Kittens</code> component. These two components override the abstract base classes in the original components using a pattern such as <em class="calibre9">Template Method or Strategy</em>.</p>
<p class="noindent1">Note again that the two new components, <code class="calibre11">Rides</code> and <code class="calibre11">Kittens</code>, follow the Dependency Rule. Note also that the classes that implement those features are created by factories under the control of the UI.</p>
<p class="noindent1">Clearly, in this scheme, when the Kitty feature is implemented, the <code class="calibre11">TaxiUI</code> must change. But nothing else needs to be changed. Rather, a new jar file, or Gem, or DLL is added to the system and dynamically loaded at runtime.</p>
<p class="noindent1">Thus the Kitty feature is decoupled, and independently developable and deployable.</p>
<div class="fig-heading">
<div class="image1"><a id="part0041_page_245"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00100.jpeg"/></div>
<p class="fig-caption"><a id="part0041_ch27fig2"></a><strong class="calibre8">Figure 27.2</strong> Using an object-oriented approach to deal with cross-cutting concerns</p>
</div>
<h3 class="h1" id="part0041_toclev_138">C<small class="calibre13">OMPONENT</small>-B<small class="calibre13">ASED</small> S<small class="calibre13">ERVICES</small></h3>
<p class="noindent1">The obvious question is: Can we do that for services? And the answer is, of course: Yes! Services do not need to be little monoliths. Services can, instead, be designed using the SOLID principles, and given a component structure so that new components can be added to them without changing the existing components within the service.</p>
<p class="noindent1"><a id="part0041_page_246"></a>Think of a service in Java as a set of abstract classes in one or more jar files. hink of each new feature or feature extension as another jar file that contains classes that extend the abstract classes in the first jar files. Deploying a new feature then becomes not a matter of redeploying the services, but rather a matter of simply <em class="calibre9">adding</em> the new jar files to the load paths of those services. In other words, adding new features conforms to the Open-Closed Principle.</p>
<p class="noindent1">The service diagram in <a href="#part0041_ch27fig3">Figure 27.3</a> shows the structure. The services still exist as before, but each has its own internal component design, allowing new features to be added as new derivative classes. Those derivative classes live within their own components.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00101.jpeg"/></div>
<p class="fig-caption"><a id="part0041_ch27fig3"></a><strong class="calibre8">Figure 27.3</strong> Each service has its own internal component design, enabling new features to be added as new derivative classes</p>
</div>
<h3 class="h1" id="part0041_toclev_139">C<small class="calibre13">ROSS</small>-C<small class="calibre13">UTTING</small> C<small class="calibre13">ONCERNS</small></h3>
<p class="noindent1">What we have learned is that architectural boundaries do not fall <em class="calibre9">between</em> services. Rather, those boundaries run <em class="calibre9">through</em> the services, dividing them into components.</p>
<p class="noindent1"><a id="part0041_page_247"></a>To deal with the cross-cutting concerns that all significant systems face, services must be designed with internal component architectures that follow the Dependency Rule, as shown in the diagram in <a href="#part0041_ch27fig4">Figure 27.4</a>. Those services do not define the architectural boundaries of the system; instead, the components within the services do.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00102.jpeg"/></div>
<p class="fig-caption"><a id="part0041_ch27fig4"></a><strong class="calibre8">Figure 27.4</strong> Services must be designed with internal component architectures that follow the Dependency Rule</p>
</div>
<h3 class="h1" id="part0041_toclev_140">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">As useful as services are to the scalability and develop-ability of a system, they are not, in and of themselves, architecturally significant elements. The architecture of a system is defined by the boundaries drawn within that system, and by the dependencies that cross those boundaries. That architecture is not defined by the physical mechanisms by which elements communicate and execute.</p>
<p class="noindent1">A service might be a single component, completely surrounded by an architectural boundary. Alternatively, a service might be composed of several components separated by architectural boundaries. In rare<sup class="calibre10"><a id="part0041_ch27fn2"></a><a href="#part0041_ch27fn-2">2</a></sup> cases, clients and services may be so coupled as to have no architectural significance whatever.</p>
<p class="fn"><a id="part0041_page_248"></a><a id="part0041_ch27fn-1"></a><a href="#part0041_ch27fn1">1</a>. Therefore the number of micro-services will be roughly equal to the number of programmers.</p>
<p class="fn"><a id="part0041_ch27fn-2"></a><a href="#part0041_ch27fn2">2</a>. We hope they are rare. Unfortunately, experience suggests otherwise.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0042_ch28"><a class="calibre3" id="part0042_page_249"></a><span class="gray">28</span><br class="calibre12"/>T<small class="calibre7">HE</small> T<small class="calibre7">EST</small> B<small class="calibre7">OUNDARY</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00103.jpeg"/></div>
<p class="noindent1"><a id="part0042_page_250"></a>Yes, that’s right: <em class="calibre9">The tests are part of the system</em>, and they participate in the architecture just like every other part of the system does. In some ways, that participation is pretty normal. In other ways, it can be pretty unique.</p>
<h3 class="h1" id="part0042_toclev_141">T<small class="calibre13">ESTS AS</small> S<small class="calibre13">YSTEM</small> C<small class="calibre13">OMPONENTS</small></h3>
<p class="noindent1">There is a great deal of confusion about tests. Are they part of the system? Are they separate from the system? Which kinds of tests are there? Are unit tests and integration tests different things? What about acceptance tests, functional tests, Cucumber tests, TDD tests, BDD tests, component tests, and so on?</p>
<p class="noindent1">It is not the role of this book to get embroiled in that particular debate, and fortunately it isn’t necessary. From an architectural point of view, all tests are the same. Whether they are the tiny little tests created by TDD, or large FitNesse, Cucumber, SpecFlow, or JBehave tests, they are architecturally equivalent.</p>
<p class="noindent1">Tests, by their very nature, follow the Dependency Rule; they are very detailed and concrete; and they always depend inward toward the code being tested. In fact, you can think of the tests as the outermost circle in the architecture. Nothing within the system depends on the tests, and the tests always depend inward on the components of the system.</p>
<p class="noindent1">Tests are also independently deployable. In fact, most of the time they are deployed in test systems, rather than in production systems. So, even in systems where independent deployment is not otherwise necessary, the tests will still be independently deployed.</p>
<p class="noindent1">Tests are the most isolated system component. They are not necessary for system operation. No user depends on them. Their role is to support development, not operation. And yet, they are no less a system component than any other. In fact, in many ways they represent the model that all other system components should follow.</p>
<h3 class="h1" id="part0042_toclev_142"><a class="calibre3" id="part0042_page_251"></a>D<small class="calibre13">ESIGN FOR</small> T<small class="calibre13">ESTABILITY</small></h3>
<p class="noindent1">The extreme isolation of the tests, combined with the fact that they are not usually deployed, often causes developers to think that tests fall outside of the design of the system. This is a catastrophic point of view. Tests that are not well integrated into the design of the system tend to be fragile, and they make the system rigid and difficult to change.</p>
<p class="noindent1">The issue, of course, is coupling. Tests that are strongly coupled to the system must change along with the system. Even the most trivial change to a system component can cause many coupled tests to break or require changes.</p>
<p class="noindent1">This situation can become acute. Changes to common system components can cause hundreds, or even thousands, of tests to break. This is known as the <em class="calibre9">Fragile Tests Problem</em>.</p>
<p class="noindent1">It is not hard to see how this can happen. Imagine, for example, a suite of tests that use the GUI to verify business rules. Such tests may start on the login screen and then navigate through the page structure until they can check particular business rules. Any change to the login page, or the navigation structure, can cause an enormous number of tests to break.</p>
<p class="noindent1">Fragile tests often have the perverse effect of making the system rigid. When developers realize that simple changes to the system can cause massive test failures, they may resist making those changes. For example, imagine the conversation between the development team and a marketing team that requests a simple change to the page navigation structure that will cause 1000 tests to break.</p>
<p class="noindent1">The solution is to design for testability. The first rule of software design—whether for testability or for any other reason—is always the same: <em class="calibre9">Don’t depend on volatile things</em>. GUIs are volatile. Test suites that operate the system through the GUI <em class="calibre9">must be fragile</em>. Therefore design the system, and the tests, so that business rules can be tested without using the GUI.</p>
<h3 class="h1" id="part0042_toclev_143"><a class="calibre3" id="part0042_page_252"></a>T<small class="calibre13">HE</small> T<small class="calibre13">ESTING</small> API</h3>
<p class="noindent1">The way to accomplish this goal is to create a specific API that the tests can use to verify all the business rules. This API should have superpowers that allow the tests to avoid security constraints, bypass expensive resources (such as databases), and force the system into particular testable states. This API will be a superset of the suite of <em class="calibre9">interactors</em> and <em class="calibre9">interface adapters</em> that are used by the user interface.</p>
<p class="noindent1">The purpose of the testing API is to decouple the tests from the application. This decoupling encompasses more than just detaching the tests from the UI: The goal is to decouple the <em class="calibre9">structure</em> of the tests from the <em class="calibre9">structure</em> of the application.</p>
<h4 class="h2">S<small class="calibre13">TRUCTURAL</small> C<small class="calibre13">OUPLING</small></h4>
<p class="noindent1">Structural coupling is one of the strongest, and most insidious, forms of test coupling. Imagine a test suite that has a test class for every production class, and a set of test methods for every production method. Such a test suite is deeply coupled to the structure of the application.</p>
<p class="noindent1">When one of those production methods or classes changes, a large number of tests must change as well. Consequently, the tests are fragile, and they make the production code rigid.</p>
<p class="noindent1">The role of the testing API is to hide the structure of the application from the tests. This allows the production code to be refactored and evolved in ways that don’t affect the tests. It also allows the tests to be refactored and evolved in ways that don’t affect the production code.</p>
<p class="noindent1">This separation of evolution is necessary because as time passes, the tests tend to become increasingly more concrete and specific. In contrast, the production code tends to become increasingly more abstract and general. Strong structural coupling prevents—or at least impedes—this necessary evolution, and prevents the production code from being as general, and flexible, as it could be.</p>
<h4 class="h2"><a class="calibre3" id="part0042_page_253"></a>S<small class="calibre13">ECURITY</small></h4>
<p class="noindent1">The superpowers of the testing API could be dangerous if they were deployed in production systems. If this is a concern, then the testing API, and the dangerous parts of its implementation, should be kept in a separate, independently deployable component.</p>
<h3 class="h1" id="part0042_toclev_144">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">Tests are not outside the system; rather, they are parts of the system that must be well designed if they are to provide the desired benefits of stability and regression. Tests that are not designed as part of the system tend to be fragile and difficult to maintain. Such tests often wind up on the maintenance room floor—discarded because they are too difficult to maintain.<a id="part0042_page_254"></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0043_ch29"><a class="calibre3" id="part0043_page_255"></a><span class="gray">29</span><br class="calibre12"/>C<small class="calibre7">LEAN</small> E<small class="calibre7">MBEDDED</small> A<small class="calibre7">RCHITECTURE</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00104.jpeg"/></div>
<p class="caption"><em class="calibre9">By James Grenning</em></p>
<p class="noindent1"><a id="part0043_page_256"></a>A while ago I read an article entitled “The Growing Importance of Sustaining Software for the DoD”<sup class="calibre10"><a id="part0043_ch29fn1"></a><a href="#part0043_ch29fn-1">1</a></sup> on Doug Schmidt’s blog. Doug made the following claim:</p>
<p class="blockquote"><em class="calibre9">“Although software does not wear out, firmware and hardware become obsolete, thereby requiring software modifications.”</em></p>
<p class="noindent1">It was a clarifying moment for me. Doug mentioned two terms that I would have thought to be obvious—but maybe not. <em class="calibre9">Software</em> is this thing that can have a long useful life, but <em class="calibre9">firmware</em> will become obsolete as hardware evolves. If you have spent any time in embedded systems development, you know the hardware is continually evolving and being improved. At the same time, features are added to the new “software,” and it continually grows in complexity.</p>
<p class="noindent1">I’d like to add to Doug’s statement:</p>
<p class="blockquote"><em class="calibre9">Although software does not wear out, it can be destroyed from within by unmanaged dependencies on firmware and hardware.</em></p>
<p class="noindent1">It is not uncommon for embedded software to be denied a potentially long life due to being infected with dependencies on hardware.</p>
<p class="noindent1">I like Doug’s definition of firmware, but let’s see which other definitions are out there. I found these alternatives:</p>
<p class="indenthangingb">• “Firmware is held in non-volatile memory devices such as ROM, EPROM, or flash memory.” (<a href="https://en.wikipedia.org/wiki/Firmware">https://en.wikipedia.org/wiki/Firmware</a>)</p>
<p class="indenthangingb">• “Firmware is a software program or set of instructions programmed on a hardware device.” (<a href="https://techterms.com/definition/firmware">https://techterms.com/definition/firmware</a>)</p>
<p class="indenthangingb">• “Firmware is software that is embedded in a piece of hardware.” (<a href="https://www.lifewire.com/what-is-firmware-2625881">https://www.lifewire.com/what-is-firmware-2625881</a>)</p>
<p class="indenthangingb">• Firmware is “Software (programs or data) that has been written onto read-only memory (ROM).” (<a href="http://www.webopedia.com/TERM/F/firmware.html">http://www.webopedia.com/TERM/F/firmware.html</a>)</p>
<p class="noindent1"><a id="part0043_page_257"></a>Doug’s statement makes me realize that these accepted definitions of firmware are wrong, or at least obsolete. Firmware does not mean code lives in ROM. It’s not firmware because of where it is stored; rather, it is firmware because of what it depends on and how hard it is to change as hardware evolves. Hardware does evolve (pause and look at your for phone for evidence), so we should structure our embedded code with that reality in mind.</p>
<p class="noindent1">I have nothing against firmware, or firmware engineers (I’ve been known to write some firmware myself). But what we really need is less firmware and more software. Actually, I am disappointed that firmware engineers write so much firmware!</p>
<p class="noindent1">Non-embedded engineers also write firmware! You non-embedded developers essentially write firmware whenever you bury SQL in your code or when you spread platform dependencies throughout your code. Android app developers write firmware when they don’t separate their business logic from the Android API.</p>
<p class="noindent1">I’ve been involved in a lot of efforts where the line between the product code (the software) and the code that interacts with the product’s hardware (the firmware) is fuzzy to the point of nonexistence. For example, in the late 1990s I had the fun of helping redesign a communications subsystem that was transitioning from time-division multiplexing (TDM) to voice over IP (VOIP). VOIP is how things are done now, but TDM was considered the state of the art from the 1950s and 1960s, and was widely deployed in the 1980s and 1990s.</p>
<p class="noindent1">Whenever we had a question for the systems engineer about how a call should react to a given situation, he would disappear and a little later emerge with a very detailed answer. “Where did he get that answer?” we asked. “From the current product’s code,” he’d answer. The tangled legacy code was the spec for the new product! The existing implementation had no separation between TDM and the business logic of making calls. The whole product was hardware/technology dependent from top to bottom and could not be untangled. The whole product had essentially become firmware.</p>
<p class="noindent1">Consider another example: Command messages arrive to this system via serial port. Unsurprisingly, there is a message processor/dispatcher. The message <a id="part0043_page_258"></a>processor knows the format of messages, is able to parse them, and can then dispatch the message to the code that can handle the request. None of this is surprising, except that the message processor/dispatcher resides in the same file as code that interacts with a UART<sup class="calibre10"><a id="part0043_ch29fn2"></a><a href="#part0043_ch29fn-2">2</a></sup> hardware. The message processor is polluted with UART details. The message processor could have been software with a potentially long useful life, but instead it is firmware. The message processor is denied the opportunity to become software—and that is just not right!</p>
<p class="noindent1">I’ve known and understood the need for separating software from hardware for a long time, but Doug’s words clarified how to use the terms <em class="calibre9">software</em> and <em class="calibre9">firmware</em> in relationship to each other.</p>
<p class="noindent1">For engineers and programmers, the message is clear: Stop writing so much firmware and give your code a chance at a long useful life. Of course, demanding it won’t make it so. Let’s look at how we can keep embedded software architecture clean to give the software a fighting chance of having a long and useful life.</p>
<h3 class="h1" id="part0043_toclev_145">A<small class="calibre13">PP-TITUDE</small> T<small class="calibre13">EST</small></h3>
<p class="noindent1">Why does so much potential embedded software become firmware? It seems that most of the emphasis is on getting the embedded code to work, and not so much emphasis is placed on structuring it for a long useful life. Kent Beck describes three activities in building software (the quoted text is Kent’s words and the italics are my commentary):</p>
<p class="indenthangingn"><strong class="calibre8">1.</strong> “First make it work.” <em class="calibre9">You are out of business if it doesn’t work</em>.</p>
<p class="indenthangingn"><strong class="calibre8">2.</strong> “Then make it right.” <em class="calibre9">Refactor the code so that you and others can understand it and evolve it as needs change or are better understood</em>.</p>
<p class="indenthangingn"><strong class="calibre8">3.</strong> “Then make it fast.” <em class="calibre9">Refactor the code for “needed” performance.</em></p>
<p class="noindent1">Much of the embedded systems software that I see in the wild seems to have been written with “Make it work” in mind—and perhaps also with an <a id="part0043_page_259"></a>obsession for the “Make it fast” goal, achieved by adding micro-optimizations at every opportunity. In <em class="calibre9">The Mythical Man-Month</em>, Fred Brooks suggests we “plan to throw one away.” Kent and Fred are giving virtually the same advice: Learn what works, then make a better solution.</p>
<p class="noindent1">Embedded software is not special when it comes to these problems. Most non-embedded apps are built just to work, with little regard to making the code right for a long useful life.</p>
<p class="noindent1">Getting an app to work is what I call the <em class="calibre9">App-titude test</em> for a programmer. Programmers, embedded or not, who just concern themselves with getting their app to work are doing their products and employers a disservice. There is much more to programming than just getting an app to work.</p>
<p class="noindent1">As an example of code produced while passing the App-titude test, check out these functions located in one file of a small embedded system:</p>
<p class="codelink"><a href="#part0061_split_001_pch29ex01a" id="part0043_pch29ex01">Click here to view code image</a></p>
<p class="pre2">ISR(TIMER1_vect) { ... }<br class="calibre6"/>
ISR(INT2_vect) { ... }<br class="calibre6"/>
void btn_Handler(void) { ... }<br class="calibre6"/>
float calc_RPM(void) { ... }<br class="calibre6"/>
static char Read_RawData(void) { ... }<br class="calibre6"/>
void Do_Average(void) { ... }<br class="calibre6"/>
void Get_Next_Measurement(void) { ... }<br class="calibre6"/>
void Zero_Sensor_1(void) { ... }<br class="calibre6"/>
void Zero_Sensor_2(void) { ... }<br class="calibre6"/>
void Dev_Control(char Activation) { ... }<br class="calibre6"/>
char Load_FLASH_Setup(void) { ... }<br class="calibre6"/>
void Save_FLASH_Setup(void) { ... }<br class="calibre6"/>
void Store_DataSet(void) { ... }<br class="calibre6"/>
float bytes2float(char bytes[4]) { ... }<br class="calibre6"/>
void Recall_DataSet(void) { ... }<br class="calibre6"/>
void Sensor_init(void) { ... }<br class="calibre6"/>
void uC_Sleep(void) { ... }</p>
<p class="noindent1"><a id="part0043_page_260"></a>That list of functions is in the order I found them in the source file. Now I’ll separate them and group them by concern:</p>
<p class="indenthangingb1">• Functions that have domain logic</p>
<p class="codelink"><a href="#part0061_split_002_pch29ex02a" id="part0043_pch29ex02">Click here to view code image</a></p>
<p class="bull"><code class="calibre11">float calc_RPM(void) { ... }</code></p>
<p class="bull"><code class="calibre11">void Do_Average(void) { ... }</code></p>
<p class="bull"><code class="calibre11">void Get_Next_Measurement(void) { ... }</code></p>
<p class="bull"><code class="calibre11">void Zero_Sensor_1(void) { ... }</code></p>
<p class="bull"><code class="calibre11">void Zero_Sensor_2(void) { ... }</code></p>
<p class="indenthangingb1">• Functions that set up the hardware platform</p>
<p class="codelink"><a href="#part0061_split_003_pch29ex03a" id="part0043_pch29ex03">Click here to view code image</a></p>
<p class="bull"><code class="calibre11">ISR(TIMER1_vect) { ... }*</code></p>
<p class="bull"><code class="calibre11">ISR(INT2_vect) { ... }</code></p>
<p class="bull"><code class="calibre11">void uC_Sleep(void) { ... }</code></p>
<p class="bull"><code class="calibre11">Functions that react to the on off button press</code></p>
<p class="bull"><code class="calibre11">void btn_Handler(void) { ... }</code></p>
<p class="bull"><code class="calibre11">void Dev_Control(char Activation) { ... }</code></p>
<p class="bull"><code class="calibre11">A Function that can get A/D input readings from the hardware</code></p>
<p class="bull"><code class="calibre11">static char Read_RawData(void) { ... }</code></p>
<p class="indenthangingb1">• Functions that store values to the persistent storage</p>
<p class="codelink"><a href="#part0061_split_004_pch29ex04a" id="part0043_pch29ex04">Click here to view code image</a></p>
<p class="bull"><code class="calibre11">char Load_FLASH_Setup(void) { ... }</code></p>
<p class="bull"><code class="calibre11">void Save_FLASH_Setup(void) { ... }</code></p>
<p class="bull"><code class="calibre11">void Store_DataSet(void) { ... }</code></p>
<p class="bull"><code class="calibre11">float bytes2float(char bytes[4]) { ... }</code></p>
<p class="bull"><code class="calibre11">void Recall_DataSet(void) { ... }</code></p>
<p class="indenthangingb1">• Function that does not do what its name implies</p>
<p class="codelink"><a href="#part0061_split_005_pch29ex05a" id="part0043_pch29ex05">Click here to view code image</a></p>
<p class="bull"><code class="calibre11">void Sensor_init(void) { ... }</code></p>
<p class="noindent1"><a id="part0043_page_261"></a>Looking at some of the other files in this application, I found many impediments to understanding the code. I also found a file structure that implied that the only way to test any of this code is in the embedded target. Virtually every bit of this code knows it is in a special microprocessor architecture, using “extended” C constructs<sup class="calibre10"><a id="part0043_ch29fn3"></a><a href="#part0043_ch29fn-3">3</a></sup> that tie the code to a particular tool chain and microprocessor. There is no way for this code to have a long useful life unless the product never needs to be moved to a different hardware environment.</p>
<p class="noindent1">This application works: The engineer passed the App-titude test. But the application can’t be said to have a clean embedded architecture.</p>
<h3 class="h1" id="part0043_toclev_146">T<small class="calibre13">HE</small> T<small class="calibre13">ARGET</small>-H<small class="calibre13">ARDWARE</small> B<small class="calibre13">OTTLENECK</small></h3>
<p class="noindent1">There are many special concerns that embedded developers have to deal with that non-embedded developers do not—for example, limited memory space, real-time constraints and deadlines, limited IO, unconventional user interfaces, and sensors and connections to the real world. Most of the time the hardware is concurrently developed with the software and firmware. As an engineer developing code for this kind of system, you may have no place to run the code. If that’s not bad enough, once you get the hardware, it is likely that the hardware will have its own defects, making software development progress even slower than usual.</p>
<p class="noindent1">Yes, embedded is special. Embedded engineers are special. But embedded development is not <em class="calibre9">so</em> special that the principles in this book are not applicable to embedded systems.</p>
<p class="noindent1">One of the special embedded problems is <em class="calibre9">the target-hardware bottleneck</em>. When embedded code is structured without applying clean architecture principles and practices, you will often face the scenario in which you can test your code only on the target. If the target is the only place where testing is possible, the target-hardware bottleneck will slow you down.</p>
<h4 class="h2"><a class="calibre3" id="part0043_page_262"></a>A C<small class="calibre13">LEAN</small> E<small class="calibre13">MBEDDED</small> A<small class="calibre13">RCHITECTURE</small> I<small class="calibre13">S A</small> T<small class="calibre13">ESTABLE</small> E<small class="calibre13">MBEDDED</small> A<small class="calibre13">RCHITECTURE</small></h4>
<p class="noindent1">Let’s see how to apply some of the architectural principles to embedded software and firmware to help you eliminate the target-hardware bottleneck.</p>
<h5 class="h3">Layers</h5>
<p class="noindent1">Layering comes in many flavors. Let’s start with three layers, as shown in <a href="#part0043_ch29fig1">Figure 29.1</a>. At the bottom, there is the hardware. As Doug warns us, due to technology advances and Moore’s law, the hardware will change. Parts become obsolete, and new parts use less power or provide better performance or are cheaper. Whatever the reason, as an embedded engineer, I don’t want to have a bigger job than is necessary when the inevitable hardware change finally happens.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00105.jpeg"/></div>
<p class="fig-caption"><a id="part0043_ch29fig1"></a><strong class="calibre8">Figure 29.1</strong> Three layers</p>
</div>
<p class="noindent1">The separation between hardware and the rest of the system is a given—at least once the hardware is defined (<a href="#part0043_ch29fig2">Figure 29.2</a>). Here is where the problems often begin when you are trying to pass the App-titude test. There is nothing that keeps hardware knowledge from polluting all the code. If you are not careful about where you put things and what one module is allowed to know about another module, the code will be very hard to change. I’m not just talking about when the hardware changes, but when the user asks for a change, or when a bug needs to be fixed.</p>
<div class="fig-heading">
<div class="image1"><a id="part0043_page_263"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00106.jpeg"/></div>
<p class="fig-caption"><a id="part0043_ch29fig2"></a><strong class="calibre8">Figure 29.2</strong> Hardware must be separated from the rest of the system</p>
</div>
<p class="noindent1">Software and firmware intermingling is an anti-pattern. Code exhibiting this anti-pattern will resist changes. In addition, changes will be dangerous, often leading to unintended consequences. Full regression tests of the whole system will be needed for minor changes. If you have not created externally instrumented tests, expect to get bored with manual tests—and then you can expect new bug reports.</p>
<h5 class="h3">The Hardware Is a Detail</h5>
<p class="noindent1">The line between software and firmware is typically not so well defined as the line between code and hardware, as shown in <a href="#part0043_ch29fig3">Figure 29.3</a>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00107.jpeg"/></div>
<p class="fig-caption"><a id="part0043_ch29fig3"></a><strong class="calibre8">Figure 29.3</strong> The line between software and firmware is a bit fuzzier than the line between code and hardware</p>
</div>
<p class="noindent1"><a id="part0043_page_264"></a>One of your jobs as an embedded software developer is to firm up that line. The name of the boundary between the software and the firmware is the hardware abstraction layer (HAL) (<a href="#part0043_ch29fig4">Figure 29.4</a>). This is not a new idea: It has been in PCs since the days before Windows.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00108.jpeg"/></div>
<p class="fig-caption"><a id="part0043_ch29fig4"></a><strong class="calibre8">Figure 29.4</strong> The hardware abstraction layer</p>
</div>
<p class="noindent1">The HAL exists for the software that sits on top of it, and its API should be tailored to that software’s needs. As an example, the firmware can store bytes and arrays of bytes into flash memory. In contrast, the application needs to store and read name/value pairs to some persistence mechanism. The software should not be concerned that the name/value pairs are stored in flash memory, a spinning disk, the cloud, or core memory. The HAL provides a service, and it does not reveal to the software how it does it. The flash implementation is a detail that should be hidden from software.</p>
<p class="noindent1">As another example, an LED is tied to a GPIO bit. The firmware could provide access to the GPIO bits, where a HAL might provide <code class="calibre11">Led_TurnOn(5)</code>. That is a pretty low-level hardware abstraction layer. Let’s consider raising the level of abstraction from a hardware perspective to the software/product perspective. What is the LED indicating? Suppose that it indicated low battery power. At some level, the firmware (or a board support package) could provide <code class="calibre11">Led_TurnOn(5)</code>, while the HAL provides <code class="calibre11">Indicate_LowBattery()</code>. You can see the HAL expressing services needed by the application. You can also see that layers may contain layers. It is more of a repeating fractal pattern than a limited set of predefined layers. The GPIO assignments are details that should be hidden from the software.</p>
<h4 class="h2"><a class="calibre3" id="part0043_page_265"></a>D<small class="calibre13">ON’T</small> R<small class="calibre13">EVEAL</small> H<small class="calibre13">ARDWARE</small> D<small class="calibre13">ETAILS TO THE</small> U<small class="calibre13">SER OF THE</small> HAL</h4>
<p class="noindent1">A clean embedded architecture’s software is testable <em class="calibre9">off</em> the target hardware. A successful HAL provides that seam or set of substitution points that facilitate off-target testing.</p>
<h5 class="h3">The Processor Is a Detail</h5>
<p class="noindent1">When your embedded application uses a specialized tool chain, it will often provide header files to <code class="calibre11">&lt;i&gt;</code>help you<code class="calibre11">&lt;/i&gt;</code>.<sup class="calibre10"><a id="part0043_ch29fn4"></a><a href="#part0043_ch29fn-4">4</a></sup> These compilers often take liberties with the C language, adding new keywords to access their processor features. The code will look like C, but it is no longer C.</p>
<p class="noindent1">Sometimes vendor-supplied C compilers provide what look like global variables to give access directly to processor registers, IO ports, clock timers, IO bits, interrupt controllers, and other processor functions. It is helpful to get access to these things easily, but realize that any of your code that uses these helpful facilities is no longer C. It won’t compile for another processor, or maybe even with a different compiler for the same processor.</p>
<p class="noindent1">I would hate to think that the silicon and tool provider is being cynical, tying your product to the compiler. Let’s give the provider the benefit of a doubt by assuming that it is truly trying to help. But now it’s up to you to use that help in a way that does not hurt in the future. You will have to limit which files are allowed to know about the C extensions.</p>
<p class="noindent1">Let’s look at this header file designed for the ACME family of DSPs—you know, the ones used by Wile E. Coyote:</p>
<p class="codelink"><a href="#part0061_split_006_pch29ex06a" id="part0043_pch29ex06">Click here to view code image</a></p>
<p class="pre2"><a id="part0043_page_266"></a>#ifndef _ACME_STD_TYPES<br class="calibre6"/>
#define _ACME_STD_TYPES<br class="calibre6"/>
 <br class="calibre6"/>
</p>
<p class="codelink"><a href="#part0061_split_007_pch29ex07a" id="part0043_pch29ex07">Click here to view code image</a></p>
<p class="pre2">#if defined(_ACME_X42)<br class="calibre6"/>
    typedef unsigned int        Uint_32;<br class="calibre6"/>
    typedef unsigned short      Uint_16;<br class="calibre6"/>
    typedef unsigned char       Uint_8;<br class="calibre6"/>
 <br class="calibre6"/>
    typedef int                 Int_32;<br class="calibre6"/>
    typedef short               Int_16;<br class="calibre6"/>
    typedef char                Int_8;<br class="calibre6"/>
 <br class="calibre6"/>
#elif defined(_ACME_A42)<br class="calibre6"/>
    typedef unsigned long       Uint_32;<br class="calibre6"/>
    typedef unsigned int        Uint_16;<br class="calibre6"/>
    typedef unsigned char       Uint_8;<br class="calibre6"/>
 <br class="calibre6"/>
    typedef long                Int_32;<br class="calibre6"/>
    typedef int                 Int_16;<br class="calibre6"/>
    typedef char                Int_8;<br class="calibre6"/>
#else<br class="calibre6"/>
    #error &lt;acmetypes.h&gt; is not supported for this environment<br class="calibre6"/>
#endif<br class="calibre6"/>
 <br class="calibre6"/>
#endif</p>
<p class="noindent1">The <code class="calibre11">acmetypes.h</code> header file should not be used directly. If you do, your code gets tied to one of the ACME DSPs. You are using an ACME DSP, you say, so what is the harm? You can’t compile your code unless you include this header. If you use the header and define <code class="calibre11">_ACME_X42</code> or <code class="calibre11">_ACME_A42</code>, your integers will be the wrong size if you try to test your code off-target. If that is not bad enough, one day you’ll want to port your application to another processor, and you will have made that task much more difficult by not choosing portability and by not limiting what files know about ACME.</p>
<p class="noindent1"><a id="part0043_page_267"></a>Instead of using <code class="calibre11">acmetypes.h</code>, you should try to follow a more standardized path and use <code class="calibre11">stdint.h</code>. But what if the target compiler does not provide <code class="calibre11">stdint.h</code>? You can write this header file. The <code class="calibre11">stdint.h</code> you write for target builds uses the <code class="calibre11">acmetypes.h</code> for target compiles like this:</p>
<p class="codelink"><a href="#part0061_split_008_pch29ex08a" id="part0043_pch29ex08">Click here to view code image</a></p>
<p class="pre2">#ifndef _STDINT_H_<br class="calibre6"/>
#define _STDINT_H_<br class="calibre6"/>
 <br class="calibre6"/>
#include &lt;acmetypes.h&gt;<br class="calibre6"/>
 <br class="calibre6"/>
typedef Uint_32 uint32_t;<br class="calibre6"/>
typedef Uint_16 uint16_t;<br class="calibre6"/>
typedef Uint_8  uint8_t;<br class="calibre6"/>
 <br class="calibre6"/>
typedef Int_32  int32_t;<br class="calibre6"/>
typedef Int_16  int16_t;<br class="calibre6"/>
typedef Int_8   int8_t;<br class="calibre6"/>
 <br class="calibre6"/>
#endif</p>
<p class="noindent1">Having your embedded software and firmware use <code class="calibre11">stdint.h</code> helps keep your code clean and portable. Certainly, all of the <em class="calibre9">software</em> should be processor independent, but not all of the <em class="calibre9">firmware</em> can be. This next code snippet takes advantage of special extensions to C that gives your code access to the peripherals in the micro-controller. It’s likely your product uses this micro-controller so that you can use its integrated peripherals. This function outputs a line that says <code class="calibre11">"hi"</code> to the serial output port. (This example is based on real code from the wild.)</p>
<p class="codelink"><a href="#part0061_split_009_pch29ex09a" id="part0043_pch29ex09">Click here to view code image</a></p>
<p class="pre2">void say_hi()<br class="calibre6"/>
{<br class="calibre6"/>
<a id="part0043_page_268"></a>
  IE = 0b11000000;<br class="calibre6"/>
  SBUF0 = (0x68);<br class="calibre6"/>
  while(TI_0 == 0);<br class="calibre6"/>
  TI_0 = 0;<br class="calibre6"/>
  SBUF0 = (0x69);<br class="calibre6"/>
  while(TI_0 == 0);<br class="calibre6"/>
  TI_0 = 0;<br class="calibre6"/>
  SBUF0 = (0x0a);<br class="calibre6"/>
  while(TI_0 == 0);<br class="calibre6"/>
  TI_0 = 0;<br class="calibre6"/>
  SBUF0 = (0x0d);<br class="calibre6"/>
  while(TI_0 == 0);<br class="calibre6"/>
  TI_0 = 0;<br class="calibre6"/>
  IE = 0b11010000;<br class="calibre6"/>
}</p>
<p class="noindent1">There are lots of problems with this small function. One thing that might jump out at you is the presence of <code class="calibre11">0b11000000</code>. This binary notation is cool; can C do that? Unfortunately, no. A few other problems relate to this code directly using the custom C extensions:</p>
<p class="noindent1"><code class="calibre11">IE</code>: Interrupt enable bits.</p>
<p class="noindent1"><code class="calibre11">SBUF0</code>: Serial output buffer.</p>
<p class="noindent1"><code class="calibre11">TI_0</code>: Serial transmit buffer empty interrupt. Reading a 1 indicates the buffer is empty.</p>
<p class="noindent1">The uppercase variables actually access micro-controller built-in peripherals. If you want to control interrupts and output characters, you must use these peripherals. Yes, this is convenient—but it’s not C.</p>
<p class="noindent1"><a id="part0043_page_269"></a>A clean embedded architecture would use these device access registers directly in very few places and confine them totally to the <em class="calibre9">firmware</em>. Anything that knows about these registers becomes <em class="calibre9">firmware</em> and is consequently bound to the silicon. Tying code to the processor will hurt you when you want to get code working before you have stable hardware. It will also hurt you when you move your embedded application to a new processor.</p>
<p class="noindent1">If you use a micro-controller like this, your firmware could isolate these low-level functions with some form of a <em class="calibre9">processor abstraction layer</em> (PAL). Firmware above the PAL could be tested off-target, making it a little less firm.</p>
<h5 class="h3">The Operating System Is a Detail</h5>
<p class="noindent1">A HAL is necessary, but is it sufficient? In bare-metal embedded systems, a HAL may be all you need to keep your code from getting too addicted to the operating environment. But what about embedded systems that use a real-time operating system (RTOS) or some embedded version of Linux or Windows?</p>
<p class="noindent1">To give your embedded code a good chance at a long life, you have to treat the operating system as a detail and protect against OS dependencies.</p>
<p class="noindent1">The software accesses the services of the operating environment through the OS. The OS is a layer separating the software from firmware (<a href="#part0043_ch29fig5">Figure 29.5</a>). Using an OS directly can cause problems. For example, what if your RTOS supplier is bought by another company and the royalties go up, or the quality goes down? What if your needs change and your RTOS does not have the capabilities that you now require? You’ll have to change lots of code. These won’t just be simple syntactical changes due to the new OS’s API, but will likely have to adapt semantically to the new OS’s different capabilities and primitives.</p>
<div class="fig-heading">
<div class="image1"><a id="part0043_page_270"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00109.jpeg"/></div>
<p class="fig-caption"><a id="part0043_ch29fig5"></a><strong class="calibre8">Figure 29.5</strong> Adding in an operating system</p>
</div>
<p class="noindent1">A clean embedded architecture isolates software from the operating system, through an <em class="calibre9">operating system abstraction layer</em> (OSAL) (<a href="#part0043_ch29fig6">Figure 29.6</a>). In some cases, implementing this layer might be as simple as changing the name of a function. In other cases, it might involve wrapping several functions together.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00110.jpeg"/></div>
<p class="fig-caption"><a id="part0043_ch29fig6"></a><strong class="calibre8">Figure 29.6</strong> The operating system abstraction layer</p>
</div>
<p class="noindent1"><a id="part0043_page_271"></a>If you have ever moved your software from one RTOS to another, you know it is painful. If your software depended on an OSAL instead of the OS directly, you would largely be writing a new OSAL that is compatible with the old OSAL. Which would you rather do: modify a bunch of complex existing code, or write new code to a defined interface and behavior? This is not a trick question. I choose the latter.</p>
<p class="noindent1">You might start worrying about code bloat about now. Really, though, the layer becomes the place where much of the duplication around using an OS is isolated. This duplication does not have to impose a big overhead. If you define an OSAL, you can also encourage your applications to have a common structure. You might provide message passing mechanisms, rather than having every thread handcraft its concurrency model.</p>
<p class="noindent1">The OSAL can help provide test points so that the valuable application code in the software layer can be tested off-target and off-OS. A clean embedded architecture’s software is testable off the target operating system. A successful OSAL provides that seam or set of substitution points that facilitate off-target testing.</p>
<h4 class="h2">P<small class="calibre13">ROGRAMMING TO</small> I<small class="calibre13">NTERFACES AND</small> S<small class="calibre13">UBSTITUTABILITY</small></h4>
<p class="noindent1">In addition to adding a HAL and potentially an OSAL inside each of the major layers (software, OS, firmware, and hardware), you can—and should—apply the principles described throughout this book. These principles encourage separation of concerns, programming to interfaces, and substitutability.</p>
<p class="noindent1">The idea of a layered architecture is built on the idea of programming to interfaces. When one module interacts with another though an interface, you can substitute one service provider for another. Many readers will have written their own small version of <code class="calibre11">printf</code> for deployment in the target. As long as the interface to your <code class="calibre11">printf</code> is the same as the standard version of <code class="calibre11">printf</code>, you can override the service one for the other.</p>
<p class="noindent1"><a id="part0043_page_272"></a>One basic rule of thumb is to use header files as interface definitions. When you do so, however, you have to be careful about what goes in the header file. Limit header file contents to function declarations as well as the constants and struct names that are needed by the function.</p>
<p class="noindent1">Don’t clutter the interface header files with data structures, constants, and typedefs that are needed by only the implementation. It’s not just a matter of clutter: That clutter will lead to unwanted dependencies. Limit the visibility of the implementation details. Expect the implementation details to change. The fewer places where code knows the details, the fewer places where code will have to be tracked down and modified.</p>
<p class="noindent1">A clean embedded architecture is testable within the layers because modules interact through interfaces. Each interface provides that seam or substitution point that facilitates off-target testing.</p>
<h4 class="h2">DRY C<small class="calibre13">ONDITIONAL</small> C<small class="calibre13">OMPILATION</small> D<small class="calibre13">IRECTIVES</small></h4>
<p class="noindent1">One use of substitutability that is often overlooked relates to how embedded C and C++ programs handle different targets or operating systems. There is a tendency to use conditional compilation to turn on and off segments of code. I recall one especially problematic case where the statement <code class="calibre11">#ifdef BOARD_V2</code> was mentioned several thousand times in a telecom application.</p>
<p class="noindent1">This repetition of code violates the Don’t Repeat Yourself (DRY) principle.<sup class="calibre10"><a id="part0043_ch29fn5"></a><a href="#part0043_ch29fn-5">5</a></sup> If I see <code class="calibre11">#ifdef BOARD_V2</code> once, it’s not really a problem. <em class="calibre9">Six thousand times</em> is an extreme problem. Conditional compilation identifying the target-hardware’s type is often repeated in embedded systems. But what else can we do?</p>
<p class="noindent1">What if there is a hardware abstraction layer? The hardware type would become a detail hidden under the HAL. If the HAL provides a set of interfaces, instead of using conditional compilation, we could use the linker or some form of runtime binding to connect the software to the hardware.</p>
<h3 class="h1" id="part0043_toclev_147"><a class="calibre3" id="part0043_page_273"></a>C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">People who are developing embedded software have a lot to learn from experiences outside of embedded software. If you are an embedded developer who has picked up this book, you will find a wealth of software development wisdom in the words and ideas.</p>
<p class="noindent1">Letting all code become firmware is not good for your product’s long-term health. Being able to test only in the target hardware is not good for your product’s long-term health. A clean embedded architecture is good for your product’s long-term health.</p>
<p class="fn"><a id="part0043_page_274"></a><a id="part0043_ch29fn-1"></a><a href="#part0043_ch29fn1">1</a>. <a href="https://insights.sei.cmu.edu/sei_blog/2011/08/the-growing-importance-of-sustaining-software-for-thedod.html">https://insights.sei.cmu.edu/sei_blog/2011/08/the-growing-importance-of-sustaining-software-for-thedod.html</a></p>
<p class="fn"><a id="part0043_ch29fn-2"></a><a href="#part0043_ch29fn2">2</a>. The hardware device that controls the serial port.</p>
<p class="fn"><a id="part0043_ch29fn-3"></a><a href="#part0043_ch29fn3">3</a>. Some silicon providers add keywords to the C language to make accessing the registers and IO ports simple from C. Unfortunately, once that is done, the code is no longer C.</p>
<p class="fn"><a id="part0043_ch29fn-4"></a><a href="#part0043_ch29fn4">4</a>. This statement intentionally uses HTML.</p>
<p class="fn"><a id="part0043_ch29fn-5"></a><a href="#part0043_ch29fn5">5</a>. Hunt and Thomas, The <em class="calibre9">Pragmatic Programmer</em>.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0044_part6"><a class="calibre3" id="part0044_page_275"></a><span class="gray">VI</span><br class="calibre12"/>D<small class="calibre7">ETAILS</small><a class="calibre3" id="part0044_page_276"></a></h2>
</body><body class="calibre">
<h2 class="h2f" id="part0045_ch30"><a class="calibre3" id="part0045_page_277"></a><span class="gray">30</span><br class="calibre12"/>T<small class="calibre7">HE</small> D<small class="calibre7">ATABASE</small> I<small class="calibre7">S A</small> D<small class="calibre7">ETAIL</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00111.jpeg"/></div>
<p class="noindent1"><a id="part0045_page_278"></a>From an architectural point of view, the database is a non-entity—it is a detail that does not rise to the level of an architectural element. Its relationship to the architecture of a software system is rather like the relationship of a doorknob to the architecture of your home.</p>
<p class="noindent1">I realize that these are fighting words. Believe me, I’ve had the fight. So let me be clear: I am not talking about the data model. The structure you give to the data within your application is highly significant to the architecture of your system. But the database is not the data model. The database is piece of software. The database is a utility that provides access to the data. From the architecture’s point of view, that utility is irrelevant because it’s a low-level detail—a mechanism. And a good architect does not allow low-level mechanisms to pollute the system architecture.</p>
<h3 class="h1" id="part0045_toclev_148">R<small class="calibre13">ELATIONAL</small> D<small class="calibre13">ATABASES</small></h3>
<p class="noindent1">Edgar Codd defined the principles of relational databases in 1970. By the mid-1980s, the relational model had grown to become the dominant form of data storage. There was a good reason for this popularity: The relational model is elegant, disciplined, and robust. It is an excellent data storage and access technology.</p>
<p class="noindent1">But no matter how brilliant, useful, and mathematically sound a technology it is, it is still just a technology. And that means it’s a detail.</p>
<p class="noindent1">While relational tables may be convenient for certain forms of data access, there is nothing architecturally significant about arranging data into rows within tables. The use cases of your application should neither know nor care about such matters. Indeed, knowledge of the tabular structure of the data should be restricted to the lowest-level utility functions in the outer circles of the architecture.</p>
<p class="noindent1">Many data access frameworks allow database rows and tables to be passed around the system as objects. Allowing this is an architectural error. It couples the use cases, business rules, and in some cases even the UI to the relational structure of the data.</p>
<h3 class="h1" id="part0045_toclev_149"><a class="calibre3" id="part0045_page_279"></a>W<small class="calibre13">HY</small> A<small class="calibre13">RE</small> D<small class="calibre13">ATABASE</small> S<small class="calibre13">YSTEMS</small> S<small class="calibre13">O</small> P<small class="calibre13">REVALENT</small>?</h3>
<p class="noindent1">Why are software systems and software enterprises dominated by database systems? What accounts for the preeminence of Oracle, MySQL, and SQL Server? In a word: disks.</p>
<p class="noindent1">The rotating magnetic disk was the mainstay of data storage for five decades. Several generations of programmers have known no other form of data storage. Disk technology has grown from huge stacks of massive platters 48 inches in diameter that weighed thousands of pounds and held 20 megabytes, to single thin circles, 3 inches in diameter, that weigh just a few grams and hold a terabyte or more. <em class="calibre9">It’s been a wild ride.</em> And throughout that ride programmers have been plagued by one fatal trait of disk technology: Disks are <em class="calibre9">slow</em>.</p>
<p class="noindent1">On a disk, data is stored within circular tracks. Those tracks are divided into sectors that hold a convenient number of bytes, often 4K. Each platter may have hundreds of tracks, and there can be a dozen or so platters. If you want to read a particular byte off the disk, you have to move the head to the proper track, wait for the disk to rotate to the proper sector, read all 4K of that sector into RAM, and then index into that RAM buffer to get the byte you want. And all that takes time—milliseconds of times.</p>
<p class="noindent1">Milliseconds might not seem like a lot, but a millisecond is a million times longer than the cycle time of most processors. If that data was not on a disk, it could be accessed in nanoseconds, instead of milliseconds.</p>
<p class="noindent1">To mitigate the time delay imposed by disks, you need indexes, caches, and optimized query schemes; and you need some kind of regular means of representing the data so that these indexes, caches, and query schemes know what they are working with. In short, you need a data access and management system. Over the years these systems have split into two distinct kinds: file systems and relational database management systems (RDBMS).</p>
<p class="noindent1">File systems are document based. They provide a natural and convenient way to store whole documents. They work well when you need to save and retrieve <a id="part0045_page_280"></a>a set of documents by name, but they don’t offer a lot of help when you’re searching the content of those documents. It’s easy to find a file named <code class="calibre11">login.c</code>, but it’s hard, and slow, to find every <code class="calibre11">.c</code> file that has a variable named <code class="calibre11">x</code> in it.</p>
<p class="noindent1">Database systems are content based. They provide a natural and convenient way to find records based on their content. They are very good at associating multiple records based on some bit of content that they all share. Unfortunately, they are rather poor at storing and retrieving opaque documents.</p>
<p class="noindent1">Both of these systems organize the data on disk so that it can be stored and retrieved in as efficient a way as possible, given their particular access needs. Each has their own scheme for indexing and arranging the data. In addition, each eventually brings the relevant data into RAM, where it can be quickly manipulated.</p>
<h3 class="h1" id="part0045_toclev_150">W<small class="calibre13">HAT</small> I<small class="calibre13">F</small> T<small class="calibre13">HERE</small> W<small class="calibre13">ERE</small> N<small class="calibre13">O</small> D<small class="calibre13">ISK</small>?</h3>
<p class="noindent1">As prevalent as disks once were, they are now a dying breed. Soon they will have gone the way of tape drives, floppy drives, and CDs. They are being replaced by RAM.</p>
<p class="noindent1">Ask yourself this question: When all the disks are gone, and all your data is stored in RAM, how will you organize that data? Will you organize it into tables and access it with SQL? Will you organize it into files and access it through a directory?</p>
<p class="noindent1">Of course not. You’ll organize it into linked lists, trees, hash tables, stacks, queues, or any of the other myriad data structures, and you’ll access it using pointers or references—because <em class="calibre9">that’s what programmers do</em>.</p>
<p class="noindent1">In fact, if you think carefully about this issue, you’ll realize that this is what you already do. Even though the data is kept in a database or a file system, you read it into RAM and then you reorganize it, for your own convenience, <a id="part0045_page_281"></a>into lists, sets, stacks, queues, trees, or whatever data structure meets your fancy. It is very unlikely that you leave the data in the form of files or tables.</p>
<h3 class="h1" id="part0045_toclev_151">D<small class="calibre13">ETAILS</small></h3>
<p class="noindent1">This reality is why I say that the database is a detail. It’s just a mechanism we use to move the data back and forth between the surface of the disk and RAM. The database is really nothing more than a big bucket of bits where we store our data on a long-term basis. But we seldom use the data in that form.</p>
<p class="noindent1">Thus, from an architectural viewpoint, we should not care about the form that the data takes while it is on the surface of a rotating magnetic disk. Indeed, we should not acknowledge that the disk exists at all.</p>
<h3 class="h1" id="part0045_toclev_152">B<small class="calibre13">UT</small> W<small class="calibre13">HAT ABOUT</small> P<small class="calibre13">ERFORMANCE</small>?</h3>
<p class="noindent1">Isn’t performance an architectural concern? Of course it is—but when it comes to data storage, it’s a concern that can be entirely encapsulated and separated from the business rules. Yes, we need to get the data in and out of the data store quickly, but that’s a low-level concern. We can address that concern with low-level data access mechanisms. It has nothing whatsoever to do with the overall architecture of our systems.</p>
<h3 class="h1" id="part0045_toclev_153">A<small class="calibre13">NECDOTE</small></h3>
<p class="noindent1">In the late 1980s, I led a team of software engineers at a startup company that was trying to build and market a network management system that measured the communications integrity of T1 telecommunication lines. The system retrieved data from the devices at the endpoints of those lines, and then ran a series of predictive algorithms to detect and report problems.</p>
<p class="noindent1">We were using UNIX platforms, and we stored our data in simple random access files. We had no need of a relational database because our data had few content-based relationships. It was better kept in trees and linked lists in <a id="part0045_page_282"></a>those random access files. In short, we kept the data in a form that was most convenient to load into RAM where it could be manipulated.</p>
<p class="noindent1">We hired a marketing manager for this startup—a nice and knowledgeable guy. But he immediately told me that we had to have a relational database in the system. It wasn’t an option and it wasn’t an engineering issue—it was a marketing issue.</p>
<p class="noindent1">This made no sense to me. Why in the world would I want to rearrange my linked lists and trees into a bunch of rows and tables accessed through SQL? Why would I introduce all the overhead and expense of a massive RDBMS when a simple random access file system was more than sufficient? So I fought him, tooth and nail.</p>
<p class="noindent1">We had a hardware engineer at this company who took up the RDBMS chant. He became convinced that our software system needed an RDBMS for technical reasons. He held meetings behind my back with the executives of the company, drawing stick figures on the whiteboard of a house balancing on a pole, and he would ask the executives, “Would you build a house on a pole?” His implied message was that an RDBMS that keeps its tables in random access files was somehow more reliable than the random access files that we were using.</p>
<p class="noindent1">I fought him. I fought the marketing guy. I stuck to my engineering principles in the face of incredible ignorance. I fought, and fought, and fought.</p>
<p class="noindent1">In the end, the hardware developer was promoted over my head to become the software manager. In the end, they put a RDBMS into that poor system. And, in the end, they were absolutely right and I was wrong.</p>
<p class="noindent1">Not for engineering reasons, mind you: I was right about that. I was right to fight against putting an RDBMS into the architectural core of the system. The reason I was wrong was because our customers expected us to have a relational database. They didn’t know what they would do with it. They didn’t have any realistic way of using the relational data in our system. But it didn’t matter: Our customers fully expected an RDBMS. It had become a <a id="part0045_page_283"></a>check box item that all the software purchasers had on their list. There was no engineering rationale—rationality had nothing to do with it. It was an irrational, external, and entirely baseless need, but it was no less real.</p>
<p class="noindent1">Where did that need come from? It originated from the highly effective marketing campaigns employed by the database vendors at the time. They had managed to convince high-level executives that their corporate “data assets” needed protection, and that the database systems they offered were the ideal means of providing that protection.</p>
<p class="noindent1">We see the same kind of marketing campaigns today. The word “enterprise” and the notion of “Service-Oriented Architecture” have much more to do with marketing than with reality.</p>
<p class="noindent1">What <em class="calibre9">should</em> I have done in that long-ago scenario? I should have bolted an RDBMS on the side of the system and provided some narrow and safe data access channel to it, while maintaining the random access files in the core of the system. What <em class="calibre9">did</em> I do? I quit and became a consultant.</p>
<h3 class="h1" id="part0045_toclev_154">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The organizational structure of data, the data model, is architecturally significant. The technologies and systems that move data on and off a rotating magnetic surface are not. Relational database systems that force the data to be organized into tables and accessed with SQL have much more to do with the latter than with the former. The data is significant. The database is a detail.<a id="part0045_page_284"></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0046_ch31"><a class="calibre3" id="part0046_page_285"></a><span class="gray">31</span><br class="calibre12"/>T<small class="calibre7">HE</small> W<small class="calibre7">EB</small> I<small class="calibre7">S</small> <small class="calibre7">A</small> D<small class="calibre7">ETAIL</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00112.jpeg"/></div>
<p class="noindent1"><a id="part0046_page_286"></a>Were you a developer in the 1990s? Do you remember how the web changed everything? Do you remember how we looked at our old client–server architectures with disdain in the face of the shiny new technology of The Web?</p>
<p class="noindent1">Actually the web didn’t change anything. Or, at least, it shouldn’t have. The web is just the latest in a series of oscillations that our industry has gone through since the 1960s. These oscillations move back and forth between putting all the computer power in central servers and putting all computer power out at the terminals.</p>
<p class="noindent1">We’ve seen several of these oscillations just in the last decade or so since the web became prominent. At first we thought all the computer power would be in server farms, and the browsers would be stupid. Then we started putting applets in the browsers. But we didn’t like that, so we moved dynamic content back to the servers. But then we didn’t like that, so we invented Web 2.0 and moved lots of processing back into the browser with Ajax and JavaScript. We went so far as to create whole huge applications written to execute in the browsers. And now we’re all excited about pulling that JavaScript back into the server with Node.</p>
<p class="noindent1">(Sigh.)</p>
<h3 class="h1" id="part0046_toclev_155">T<small class="calibre13">HE</small> E<small class="calibre13">NDLESS</small> P<small class="calibre13">ENDULUM</small></h3>
<p class="noindent1">Of course, it would be incorrect to think that those oscillations started with the web. Before the web, there was client–server architecture. Before that, there were central minicomputers with arrays of dumb terminals. Before that, there were mainframes with smart green-screen terminals (that were very much analogous to modern-day browsers). Before that, there were computer rooms and punched cards …</p>
<p class="noindent1">And so the story goes. We can’t seem to figure out where we want the computer power. We go back and forth between centralizing it and distributing it. And, I imagine, those oscillations will continue for some time to come.</p>
<p class="noindent1"><a id="part0046_page_287"></a>When you look at it in the overall scope of IT history, the web didn’t change anything at all. The web was simply one of many oscillations in a struggle that began before most of us were born and will continue well after most of us have retired.</p>
<p class="noindent1">As architects, though, we have to look at the long term. Those oscillations are just short-term issues that we want to push away from the central core of our business rules.</p>
<p class="noindent1">Let me tell you the story of company Q. Company Q built a very popular personal finance system. It was a desktop app with a very useful GUI. I loved using it.</p>
<p class="noindent1">Then came the web. In its next release, company Q changed the GUI to look, and behave, like a browser. I was thunderstruck! What marketing genius decided that personal finance software, running on a desktop, should have the look and feel of a web browser?</p>
<p class="noindent1">Of course, I hated the new interface. Apparently everyone else did, too—because after a few releases, company Q gradually removed the browser-like feel and turned its personal finance system back into a regular desktop GUI.</p>
<p class="noindent1">Now imagine you were a software architect at Q. Imagine that some marketing genius convinces upper management that the whole UI has to change to look more like the web. What do you do? Or, rather, what should you have done before this point to protect your application from that marketing genius?</p>
<p class="noindent1">You should have decoupled your business rules from your UI. I don’t know whether the Q architects had done that. One day I’d love to hear their story. Had I been there at the time, I certainly would have lobbied very hard to isolate the business rules from the GUI, because you never know what the marketing geniuses will do next.</p>
<p class="noindent1">Now consider company A, which makes a lovely smartphone. Recently it released an upgraded version of its “operating system” (it’s so strange that we <a id="part0046_page_288"></a>can talk about the operating system inside a phone). Among other things, that “operating system” upgrade completely changed the look and feel of all the applications. Why? Some marketing genius said so, I suppose.</p>
<p class="noindent1">I’m not an expert on the software within that device, so I don’t know if that change caused any significant difficulties for the programmers of the apps that run in company A’s phone. I do hope the architects at A, and the architects of the apps, keep their UI and business rules isolated from each other, because there are always marketing geniuses out there just waiting to pounce on the next little bit of coupling you create.</p>
<h3 class="h1" id="part0046_toclev_156">T<small class="calibre13">HE</small> U<small class="calibre13">PSHOT</small></h3>
<p class="noindent1">The upshot is simply this: The GUI is a detail. The web is a GUI. So the web is a detail. And, as an architect, you want to put details like that behind boundaries that keep them separate from your core business logic.</p>
<p class="noindent1">Think about it this way: <em class="calibre9">The WEB is an IO device</em>. In the 1960s, we learned the value of writing applications that were device independent. The motivation for that independence has not changed. The web is not an exception to that rule.</p>
<p class="noindent1">Or is it? The argument can be made that a GUI, like the web, is so unique and rich that it is absurd to pursue a device-independent architecture. When you think about the intricacies of JavaScript validation or drag-and-drop AJAX calls, or any of the plethora of other widgets and gadgets you can put on a web page, it’s easy to argue that device independence is impractical.</p>
<p class="noindent1">To some extent, this is true. The interaction between the application and the GUI is “chatty” in ways that are quite specific to the kind of GUI you have. The dance between a browser and a web application is different from the dance between a desktop GUI and its application. Trying to abstract out that dance, the way devices are abstracted out of UNIX, seems unlikely to be possible.</p>
<p class="noindent1"><a id="part0046_page_289"></a>But another boundary between the UI and the application <em class="calibre9">can</em> be abstracted. The business logic can be thought of as a suite of use cases, each of which performs some function on behalf of a user. Each use case can be described based on the input data, the processing preformed, and the output data.</p>
<p class="noindent1">At some point in the dance between the UI and the application, the input data can be said to be complete, allowing the use case to be executed. Upon completion, the resultant data can be fed back into the dance between the UI and the application.</p>
<p class="noindent1">The complete input data and the resultant output data can be placed into data structures and used as the input values and output values for a process that executes the use case. With this approach, we can consider each use case to be operating the IO device of the UI in a device-independent manner.</p>
<h3 class="h1" id="part0046_toclev_157">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">This kind of abstraction is not easy, and it will likely take several iterations to get just right. But it is possible. And since the world is full of marketing geniuses, it’s not hard to make the case that it’s often very necessary.<a id="part0046_page_290"></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0047_ch32"><a class="calibre3" id="part0047_page_291"></a><span class="gray">32</span><br class="calibre12"/>F<small class="calibre7">RAMEWORKS</small> A<small class="calibre7">RE</small> D<small class="calibre7">ETAILS</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00113.jpeg"/></div>
<p class="noindent1"><a id="part0047_page_292"></a>Frameworks have become quite popular. Generally speaking, this is a good thing. There are many frameworks out there that are free, powerful, and useful.</p>
<p class="noindent1">However, frameworks are not architectures—though some try to be.</p>
<h3 class="h1" id="part0047_toclev_158">F<small class="calibre13">RAMEWORK</small> A<small class="calibre13">UTHORS</small></h3>
<p class="noindent1">Most framework authors offer their work for free because they want to be helpful to the community. They want to give back. This is laudable. However, regardless of their high-minded motives, those authors do not have <em class="calibre9">your</em> best interests at heart. They can’t, because they don’t know you, and they don’t know your problems.</p>
<p class="noindent1">Framework authors know their own problems, and the problems of their coworkers and friends. And they write their frameworks to solve <em class="calibre9">those</em> problems—not yours.</p>
<p class="noindent1">Of course, your problems will likely overlap with those other problems quite a bit. If this were not the case, frameworks would not be so popular. To the extent that such overlap exists, frameworks can be very useful indeed.</p>
<h3 class="h1" id="part0047_toclev_159">A<small class="calibre13">SYMMETRIC</small> M<small class="calibre13">ARRIAGE</small></h3>
<p class="noindent1">The relationship between you and the framework author is extraordinarily asymmetric. You must make a huge commitment to the framework, but the framework author makes no commitment to you whatsoever.</p>
<p class="noindent1">Think about this point carefully. When you use a framework, you read through the documentation that the author of that framework provides. In that documentation, the author, and other users of that framework, advise you on how to integrate your software with the framework. Typically, this means wrapping your architecture around that framework. The author recommends that you derive from the framework’s base classes, and <a id="part0047_page_293"></a>import the framework’s facilities into your business objects. The author urges you to <em class="calibre9">couple</em> your application to the framework as tightly as possible.</p>
<p class="noindent1">For the framework author, coupling to his or her own framework is not a risk. The author <em class="calibre9">wants</em> to couple to that framework, because the author has absolute control over that framework.</p>
<p class="noindent1">What’s more, the author wants <em class="calibre9">you</em> to couple to the framework, because once coupled in this way, it is very hard to break away. Nothing feels more validating to a framework author than a bunch of users willing to inextricably derive from the author’s base classes.</p>
<p class="noindent1">In effect, the author is asking you to marry the framework—to make a huge, long-term commitment to that framework. And yet, under no circumstances will the author make a corresponding commitment to you. It’s a one-directional marriage. You take on all the risk and burden; the framework author takes on nothing at all.</p>
<h3 class="h1" id="part0047_toclev_160">T<small class="calibre13">HE</small> R<small class="calibre13">ISKS</small></h3>
<p class="noindent1">What are the risks? Here are just a few for you to consider.</p>
<p class="indenthangingb">• The architecture of the framework is often not very clean. Frameworks tend to violate he Dependency Rule. They ask you to inherit their code into your business objects—your Entities! They want their framework coupled into that innermost circle. Once in, that framework isn’t coming back out. The wedding ring is on your finger; and it’s going to stay there.</p>
<p class="indenthangingb">• The framework may help you with some early features of your application. However, as your product matures, it may outgrow the facilities of the framework. If you’ve put on that wedding ring, you’ll find the framework fighting you more and more as time passes.</p>
<p class="indenthangingb">• The framework may evolve in a direction that you don’t find helpful. You may be stuck upgrading to new versions that don’t help you. You may even find old features, which you made use of, disappearing or changing in ways that are difficult for you to keep up with.</p>
<p class="indenthangingb"><a id="part0047_page_294"></a>• A new and better framework may come along that you wish you could switch to.</p>
<h3 class="h1" id="part0047_toclev_161">T<small class="calibre13">HE</small> S<small class="calibre13">OLUTION</small></h3>
<p class="noindent1">What is the solution?</p>
<p class="blockquote"><em class="calibre9">Don’t marry the framework!</em></p>
<p class="noindent1">Oh, you can <em class="calibre9">use</em> the framework—just don’t couple to it. Keep it at arm’s length. Treat the framework as a detail that belongs in one of the outer circles of the architecture. Don’t let it into the inner circles.</p>
<p class="noindent1">If the framework wants you to derive your business objects from its base classes, say no! Derive proxies instead, and keep those proxies in components that are <em class="calibre9">plugins</em> to your business rules.</p>
<p class="noindent1">Don’t let frameworks into your core code. Instead, integrate them into components that plug in to your core code, following the Dependency Rule.</p>
<p class="noindent1">For example, maybe you like Spring. Spring is a good dependency injection framework. Maybe you use Spring to auto-wire your dependencies. That’s fine, but you should not sprinkle <code class="calibre11">@autowired</code> annotations all throughout your business objects. Your business objects should not know about Spring.</p>
<p class="noindent1">Instead, you can use Spring to inject dependencies into your <code class="calibre11">Main</code> component. It’s OK for <code class="calibre11">Main</code> to know about Spring since <code class="calibre11">Main</code> is the dirtiest, lowest-level component in the architecture.</p>
<h3 class="h1" id="part0047_toclev_162"><a class="calibre3" id="part0047_page_295"></a>I N<small class="calibre13">OW</small> P<small class="calibre13">RONOUNCE</small> Y<small class="calibre13">OU</small> …</h3>
<p class="noindent1">There are some frameworks that you simply must marry. If you are using C++, for example, you will likely have to marry STL—it’s hard to avoid. If you are using Java, you will almost certainly have to marry the standard library.</p>
<p class="noindent1">That’s normal—but it should still be a <em class="calibre9">decision</em>. You must understand that when you marry a framework to your application, you will be stuck with that framework for the rest of the life cycle of that application. For better or for worse, in sickness and in health, for richer, for poorer, forsaking all others, you <em class="calibre9">will</em> be using that framework. This is not a commitment to be entered into lightly.</p>
<h3 class="h1" id="part0047_toclev_163">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">When faced with a framework, try not to marry it right away. See if there aren’t ways to date it for a while before you take the plunge. Keep the framework behind an architectural boundary if at all possible, for as long as possible. Perhaps you can find a way to get the milk without buying the cow.<a id="part0047_page_296"></a></p>
</body><body class="calibre">
<h2 class="h2f" id="part0048_ch33"><a class="calibre3" id="part0048_page_297"></a><span class="gray">33</span><br class="calibre12"/>C<small class="calibre7">ASE</small> S<small class="calibre7">TUDY</small>: V<small class="calibre7">IDEO</small> S<small class="calibre7">ALES</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00114.jpeg"/></div>
<p class="noindent1"><a id="part0048_page_298"></a>Now it’s time to put these rules and thoughts about architecture together into a case study. This case study will be short and simple, yet will depict both the process a good architect uses and the decisions that such an architect makes.</p>
<h3 class="h1" id="part0048_toclev_164">T<small class="calibre13">HE</small> P<small class="calibre13">RODUCT</small></h3>
<p class="noindent1">For this case study, I’ve chosen a product with which I am rather intimately familiar: the software for a website that sells videos. Of course, it is reminiscent of <code class="calibre11"><a href="http://cleancoders.com">cleancoders.com</a></code>, the site where I sell my software tutorial videos.</p>
<p class="noindent1">The basic idea is trivial. We have a batch of videos we want to sell. We sell them, on the web, to both individuals and businesses. Individuals can pay one price to stream the videos, and another, higher price to download those videos and own them permanently. Business licenses are streaming only, and are purchased in batches that allow quantity discounts.</p>
<p class="noindent1">Individuals typically act as both the viewers and the purchasers. Businesses, in contrast, often have people who buy the videos that other people will watch.</p>
<p class="noindent1">Video authors need to supply their video files, written descriptions, and ancillary files with exams, problems, solutions, source code, and other materials.</p>
<p class="noindent1">Administrators need to add new video series, add and delete videos to and from the series, and establish prices for various licenses.</p>
<p class="noindent1">Our first step in determining the initial architecture of the system is to identify the actors and use cases.</p>
<h3 class="h1" id="part0048_toclev_165">U<small class="calibre13">SE</small> C<small class="calibre13">ASE</small> A<small class="calibre13">NALYSIS</small></h3>
<p class="noindent1"><a href="#part0048_ch33fig1">Figure 33.1</a> shows a typical use-case analysis.</p>
<div class="fig-heading">
<div class="image1"><a id="part0048_page_299"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00115.jpeg"/></div>
<p class="fig-caption"><a id="part0048_ch33fig1"></a><strong class="calibre8">Figure 33.1</strong> A typical use-case analysis</p>
</div>
<p class="noindent1">The four main actors are evident. According to the Single Responsibility Principle, these four actors will be the four primary sources of change for the system. Every time some new feature is added, or some existing feature is changed, that step will be taken to serve one of these actors. Therefore we want to partition the system such that a change to one actor does not affect any of the other actors.</p>
<p class="noindent1">The use cases shown in <a href="#part0048_ch33fig1">Figure 33.1</a> are not a complete list. For example, you won’t find log-in or log-out use cases. The reason for this omission is simply to manage the size of the problem in this book. If I were to include all the different use cases, then this chapter would have to turn into a book in its own right.</p>
<p class="noindent1"><a id="part0048_page_300"></a>Note the dashed use cases in the center of <a href="#part0048_ch33fig1">Figure 33.1</a>. They are <em class="calibre9">abstract</em><sup class="calibre10"><a id="part0048_ch33fn1"></a><a href="#part0048_ch33fn-1">1</a></sup> use cases. An abstract use case is one that sets a general policy that another use case will flesh out. As you can see, the <em class="calibre9">View Catalog as Viewer</em> and <em class="calibre9">View Catalog as Purchaser</em> use cases both inherit from the <em class="calibre9">View Catalog</em> abstract use case.</p>
<p class="noindent1">On the one hand, it was not strictly necessary for me to create that abstraction. I could have left the abstract use case out of the diagram without compromising any of the features of the overall product. On the other hand, these two use cases are <em class="calibre9">so similar</em> that I thought it wise to recognize the similarity and find a way to unify it early in the analysis.</p>
<h3 class="h1" id="part0048_toclev_166">C<small class="calibre13">OMPONENT</small> A<small class="calibre13">RCHITECTURE</small></h3>
<p class="noindent1">Now that we know the actors and use cases, we can create a preliminary component architecture (<a href="#part0048_ch33fig2">Figure 33.2</a>).</p>
<p class="noindent1">The double lines in the drawing represent architectural boundaries as usual. You can see the typical partitioning of views, presenters, interactors, and controllers. You can also see that I’ve broken each of those categories up by their corresponding actors.</p>
<p class="noindent1">Each of the components in <a href="#part0048_ch33fig2">Figure 33.2</a> represents a potential <code class="calibre11">.jar</code> file or <code class="calibre11">.dll</code> file. Each of those components will contain the views, presenters, interactors, and controllers that have been allocated to it.</p>
<p class="noindent1">Note the special components for the <code class="calibre11">Catalog View</code> and the <code class="calibre11">Catalog Presenter</code>. This is how I dealt with the abstract <em class="calibre9">View Catalog</em> use case. I assume that those views and presenters will be coded into abstract classes within those components, and that the inheriting components will contain view and presenter classes that will inherit from those abstract classes.</p>
<div class="fig-heading">
<div class="image1"><a id="part0048_page_301"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00116.jpeg"/></div>
<p class="fig-caption"><a id="part0048_ch33fig2"></a><strong class="calibre8">Figure 33.2</strong> A preliminary component architecture</p>
</div>
<p class="noindent1">Would I really break the system up into all these components, and deliver them as <code class="calibre11">.jar</code> or <code class="calibre11">.dll</code> files? Yes and no. I would certainly break the compile and build environment up this way, so that I <em class="calibre9">could</em> build independent deliverables like that. I would also reserve the right to combine all those deliverables into a smaller number of deliverables if necessary. For example, given the partitioning in <a href="#part0048_ch33fig2">Figure 33.2</a>, it would be easy to combine them into five <code class="calibre11">.jar</code> files—one for views, presenters, interactors, controllers, and utilities, respectively. I could then independently deploy the components that are most likely to change independently of each other.</p>
<p class="noindent1">Another possible grouping would be to put the views and presenters together into the same <code class="calibre11">.jar</code> file, and put the interactors, controllers, and utilities in their own <code class="calibre11">.jar</code> file. Still another, even more primitive, grouping would be to create two <code class="calibre11">.jar</code> files, with views and presenters in one file, and everything else in the other.</p>
<p class="noindent1"><a id="part0048_page_302"></a>Keeping these options open will allow us to adapt the way we deploy the system based on how the system changes over time.</p>
<h3 class="h1" id="part0048_toclev_167">D<small class="calibre13">EPENDENCY</small> M<small class="calibre13">ANAGEMENT</small></h3>
<p class="noindent1">The flow of control in <a href="#part0048_ch33fig2">Figure 33.2</a> proceeds from right to left. Input occurs at the controllers, and that input is processed into a result by the interactors. The presenters then format the results, and the views display those presentations.</p>
<p class="noindent1">Notice that the arrows do not all flow from the right to the left. In fact, most of them point from left to right. This is because the architecture is following the <em class="calibre9">Dependency Rule</em>. All dependencies cross the boundary lines in one direction, and they always point toward the components containing the higher-level policy.</p>
<p class="noindent1">Also notice that the <em class="calibre9">using</em> relationships (open arrows) point <em class="calibre9">with</em> the flow of control, and that the <em class="calibre9">inheritance</em> relationships (closed arrows) point <em class="calibre9">against</em> the flow of control. This depicts our use of the Open–Closed Principle to make sure that the dependencies flow in the right direction, and that changes to low-level details do not ripple upward to affect high-level policies.</p>
<h3 class="h1" id="part0048_toclev_168">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The architecture diagram in <a href="#part0048_ch33fig2">Figure 33.2</a> includes two dimensions of separation. The first is the separation of actors based on the Single Responsibility Principle; the second is the Dependency Rule. The goal of both is to separate components that change for different reasons, and at different rates. The different reasons correspond to the actors; the different rates correspond to the different levels of policy.</p>
<p class="noindent1">Once you have structured the code this way, you can mix and match how you want to actually deploy the system. You can group the components into deployable deliverables in any way that makes sense, and easily change that grouping when conditions change.</p>
<p class="fn"><a id="part0048_ch33fn-1"></a><a href="#part0048_ch33fn1">1</a>. This is my own notation for “abstract” use cases. It would have been more standard to use a UML stereotype such as &lt;&lt;abstract&gt;&gt;, but I don‘t find adhering to such standards very useful nowadays.</p>
</body><body class="calibre">
<h2 class="h2f" id="part0049_ch34"><a class="calibre3" id="part0049_page_303"></a><span class="gray">34</span><br class="calibre12"/>T<small class="calibre7">HE</small> M<small class="calibre7">ISSING</small> C<small class="calibre7">HAPTER</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00117.jpeg"/></div>
<p class="caption"><em class="calibre9">By Simon Brown</em></p>
<p class="noindent1"><a id="part0049_page_304"></a>All of the advice you’ve read so far will certainly help you design better software, composed of classes and components with well-defined boundaries, clear responsibilities, and controlled dependencies. But it turns out that the devil is in the implementation details, and it’s really easy to fall at the last hurdle if you don’t give that some thought, too.</p>
<p class="noindent1">Let’s imagine that we’re building an online book store, and one of the use cases we’ve been asked to implement is about customers being able to view the status of their orders. Although this is a Java example, the principles apply equally to other programming languages. Let’s put the Clean Architecture to one side for a moment and look at a number of approaches to design and code organization.</p>
<h3 class="h1" id="part0049_toclev_169">P<small class="calibre13">ACKAGE BY</small> L<small class="calibre13">AYER</small></h3>
<p class="noindent1">The first, and perhaps simplest, design approach is the traditional horizontal layered architecture, where we separate our code based on what it does from a technical perspective. This is often called “package by layer.” <a href="#part0049_ch34fig1">Figure 34.1</a> shows what this might look like as a UML class diagram.</p>
<p class="noindent1">In this typical layered architecture, we have one layer for the web code, one layer for our “business logic,” and one layer for persistence. In other words, code is sliced horizontally into layers, which are used as a way to group similar types of things. In a “strict layered architecture,” layers should depend only on the next adjacent lower layer. In Java, layers are typically implemented as packages. As you can see in <a href="#part0049_ch34fig1">Figure 34.1</a>, all of the dependencies between layers (packages) point downward. In this example, we have the following Java types:</p>
<p class="indenthangingb">• <code class="calibre11">OrdersController</code>: A web controller, something like a Spring MVC controller, that handles requests from the web.</p>
<p class="indenthangingb">• <code class="calibre11">OrdersService</code>: An interface that defines the “business logic” related to orders.</p>
<p class="indenthangingb">• <code class="calibre11">OrdersServiceImpl</code>: The implementation of the orders service.<sup class="calibre10"><a id="part0049_ch34fn1"></a><a href="#part0049_ch34fn-1">1</a></sup></p>
<p class="indenthangingb"><a id="part0049_page_305"></a>• <code class="calibre11">OrdersRepository</code>: An interface that defines how we get access to persistent order information.</p>
<p class="indenthangingb">• <code class="calibre11">JdbcOrdersRepository</code>: An implementation of the repository interface.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00118.jpeg"/></div>
<p class="fig-caption"><a id="part0049_ch34fig1"></a><strong class="calibre8">Figure 34.1</strong> Package by layer</p>
</div>
<p class="noindent1">In “Presentation Domain Data Layering,”<sup class="calibre10"><a id="part0049_ch34fn2"></a><a href="#part0049_ch34fn-2">2</a></sup> Martin Fowler says that adopting such a layered architecture is a good way to get started. He’s not alone. Many of the books, tutorials, training courses, and sample code you’ll find will also <a id="part0049_page_306"></a>point you down the path of creating a layered architecture. It’s a very quick way to get something up and running without a huge amount of complexity. The problem, as Martin points out, is that once your software grows in scale and complexity, you will quickly find that having three large buckets of code isn’t sufficient, and you will need to think about modularizing further.</p>
<p class="noindent1">Another problem is that, as Uncle Bob has already said, a layered architecture doesn’t scream anything about the business domain. Put the code for two layered architectures, from two very different business domains, side by side and they will likely look eerily similar: web, services, and repositories. There’s also another huge problem with layered architectures, but we’ll get to that later.</p>
<h3 class="h1" id="part0049_toclev_170">P<small class="calibre13">ACKAGE BY</small> F<small class="calibre13">EATURE</small></h3>
<p class="noindent1">Another option for organizing your code is to adopt a “package by feature” style. This is a vertical slicing, based on related features, domain concepts, or aggregate roots (to use domain-driven design terminology). In the typical implementations that I’ve seen, all of the types are placed into a single Java package, which is named to reflect the concept that is being grouped.</p>
<p class="noindent1">With this approach, as shown in <a href="#part0049_ch34fig2">Figure 34.2</a>, we have the same interfaces and classes as before, but they are all placed into a single Java package rather than being split among three packages. This is a very simple refactoring from the “package by layer” style, but the top-level organization of the code now screams something about the business domain. We can now see that this code base has something to do with orders rather than the web, services, and repositories. Another benefit is that it’s potentially easier to find all of the code that you need to modify in the event that the “view orders” use case changes. It’s all sitting in a single Java package rather than being spread out.<sup class="calibre10"><a id="part0049_ch34fn3"></a><a href="#part0049_ch34fn-3">3</a></sup></p>
<p class="noindent1">I often see software development teams realize that they have problems with horizontal layering (“package by layer”) and switch to vertical layering <a id="part0049_page_307"></a>(“package by feature”) instead. In my opinion, both are suboptimal. If you’ve read this book so far, you might be thinking that we can do much better—and you’re right.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00119.jpeg"/></div>
<p class="fig-caption"><a id="part0049_ch34fig2"></a><strong class="calibre8">Figure 34.2</strong> Package by feature</p>
</div>
<h3 class="h1" id="part0049_toclev_171"><a class="calibre3" id="part0049_page_308"></a>P<small class="calibre13">ORTS AND</small> A<small class="calibre13">DAPTERS</small></h3>
<p class="noindent1">As Uncle Bob has said, approaches such as “ports and adapters,” the “hexagonal architecture,” “boundaries, controllers, entities,” and so on aim to create architectures where business/domain-focused code is independent and separate from the technical implementation details such as frameworks and databases. To summarize, you often see such code bases being composed of an “inside” (domain) and an “outside” (infrastructure), as suggested in <a href="#part0049_ch34fig3">Figure 34.3</a>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00120.jpeg"/></div>
<p class="fig-caption"><a id="part0049_ch34fig3"></a><strong class="calibre8">Figure 34.3</strong> A code base with an inside and an outside</p>
</div>
<p class="noindent1">The “inside” region contains all of the domain concepts, whereas the “outside” region contains the interactions with the outside world (e.g., UIs, databases, third-party integrations). The major rule here is that the “outside” depends on the “inside”—never the other way around. <a href="#part0049_ch34fig4">Figure 34.4</a> shows a version of how the “view orders” use case might be implemented.</p>
<p class="noindent1">The <code class="calibre11">com.mycompany.myapp.domain</code> package here is the “inside,” and the other packages are the “outside.” Notice how the dependencies flow toward the “inside.” The keen-eyed reader will notice that the <code class="calibre11">OrdersRepository</code> from previous diagrams has been renamed to simply be <code class="calibre11">Orders</code>. This comes <a id="part0049_page_309"></a>from the world of domain-driven design, where the advice is that the naming of everything on the “inside” should be stated in terms of the “ubiquitous domain language.” To put that another way, we talk about “orders” when we’re having a discussion about the domain, not the “orders repository.”</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00121.jpeg"/></div>
<p class="fig-caption"><a id="part0049_ch34fig4"></a><strong class="calibre8">Figure 34.4</strong> View orders use case</p>
</div>
<p class="noindent1"><a id="part0049_page_310"></a>It’s also worth pointing out that this is a simplified version of what the UML class diagram might look like, because it’s missing things like interactors and objects to marshal the data across the dependency boundaries.</p>
<h3 class="h1" id="part0049_toclev_172">P<small class="calibre13">ACKAGE BY</small> C<small class="calibre13">OMPONENT</small></h3>
<p class="noindent1">Although I agree wholeheartedly with the discussions about SOLID, REP, CCP, and CRP and most of the advice in this book, I come to a slightly different conclusion about how to organize code. So I’m going to present another option here, which I call “package by component.” To give you some background, I’ve spent most of my career building enterprise software, primarily in Java, across a number of different business domains. Those software systems have varied immensely, too. A large number have been web-based, but others have been client–server<sup class="calibre10"><a id="part0049_ch34fn4"></a><a href="#part0049_ch34fn-4">4</a></sup>, distributed, message-based, or something else. Although the technologies differed, the common theme was that the architecture for most of these software systems was based on a traditional layered architecture.</p>
<p class="noindent1">I’ve already mentioned a couple of reasons why layered architectures should be considered bad, but that’s not the whole story. The purpose of a layered architecture is to separate code that has the same sort of function. Web stuff is separated from business logic, which is in turn separated from data access. As we saw from the UML class diagram, from an implementation perspective, a layer typically equates to a Java package. From a code accessibility perspective, for the <code class="calibre11">OrdersController</code> to be able to have a dependency on the <code class="calibre11">OrdersService</code> interface, the <code class="calibre11">OrdersService</code> interface needs to be marked as <code class="calibre11">public</code>, because they are in different packages. Likewise, the <code class="calibre11">OrdersRepository</code> interface needs to be marked as <code class="calibre11">public</code> so that it can be seen outside of the repository package, by the <code class="calibre11">OrdersServiceImpl</code> class.</p>
<p class="noindent1"><a id="part0049_page_311"></a>In a strict layered architecture, the dependency arrows should always point downward, with layers depending only on the next adjacent lower layer. This comes back to creating a nice, clean, acyclic dependency graph, which is achieved by introducing some rules about how elements in a code base should depend on each other. The big problem here is that we can cheat by introducing some undesirable dependencies, yet still create a nice, acyclic dependency graph.</p>
<p class="noindent1">Suppose that you hire someone new who joins your team, and you give the newcomer another <code class="calibre11">orders</code>-related use case to implement. Since the person is new, he wants to make a big impression and get this use case implemented as quickly as possible. After sitting down with a cup of coffee for a few minutes, the newcomer discovers an existing <code class="calibre11">OrdersController</code> class, so he decides that’s where the code for the new <code class="calibre11">orders</code>-related web page should go. But it needs some <code class="calibre11">orders</code> data from the database. The newcomer has an epiphany: “Oh, there’s an <code class="calibre11">OrdersRepository</code> interface already built, too. I can simply dependency-inject the implementation into my controller. Perfect!” After a few more minutes of hacking, the web page is working. But the resulting UML diagram looks like <a href="#part0049_ch34fig5">Figure 34.5</a>.</p>
<p class="noindent1">The dependency arrows still point downward, but the <code class="calibre11">OrdersController</code> is now additionally bypassing the <code class="calibre11">OrdersService</code> for some use cases. This organization is often called a <em class="calibre9">relaxed layered architecture</em>, as layers are allowed to skip around their adjacent neighbor(s). In some situations, this is the intended outcome—if you’re trying to follow the CQRS<sup class="calibre10"><a id="part0049_ch34fn5"></a><a href="#part0049_ch34fn-5">5</a></sup> pattern, for example. In many other cases, bypassing the business logic layer is undesirable, especially if that business logic is responsible for ensuring authorized access to individual records, for example.</p>
<p class="noindent1">While the new use case works, it’s perhaps not implemented in the way that we were expecting. I see this happen a lot with teams that I visit as a consultant, and it’s usually revealed when teams start to visualize what their code base really looks like, often for the first time.</p>
<div class="fig-heading">
<div class="image1"><a id="part0049_page_312"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00122.jpeg"/></div>
<p class="fig-caption"><a id="part0049_ch34fig5"></a><strong class="calibre8">Figure 34.5</strong> Relaxed layered architecture</p>
</div>
<p class="noindent1">What we need here is a guideline—an architectural principle—that says something like, “Web controllers should never access repositories directly.” The question, of course, is enforcement. Many teams I’ve met simply say, “We enforce this principle through good discipline and code reviews, because we <a id="part0049_page_313"></a>trust our developers.” This confidence is great to hear, but we all know what happens when budgets and deadlines start looming ever closer.</p>
<p class="noindent1">A far smaller number of teams tell me that they use static analysis tools (e.g., NDepend, Structure101, Checkstyle) to check and automatically enforce architecture violations at build time. You may have seen such rules yourself; they usually manifest themselves as regular expressions or wildcard strings that state “types in package <code class="calibre11">**/web</code> should not access types in <code class="calibre11">**/data</code>”; and they are executed after the compilation step.</p>
<p class="noindent1">This approach is a little crude, but it can do the trick, reporting violations of the architecture principles that you’ve defined as a team and (you hope) failing the build. The problem with both approaches is that they are fallible, and the feedback loop is longer than it should be. If left unchecked, this practice can turn a code base into a “big ball of mud.”<sup class="calibre10"><a id="part0049_ch34fn6"></a><a href="#part0049_ch34fn-6">6</a></sup> I’d personally like to use the compiler to enforce my architecture if at all possible.</p>
<p class="noindent1">This brings us to the “package by component” option. It’s a hybrid approach to everything we’ve seen so far, with the goal of bundling all of the responsibilities related to a single coarse-grained component into a single Java package. It’s about taking a service-centric view of a software system, which is something we’re seeing with micro-service architectures as well. In the same way that ports and adapters treat the web as just another delivery mechanism, “package by component” keeps the user interface separate from these coarse-grained components. <a href="#part0049_ch34fig6">Figure 34.6</a> shows what the “view orders” use case might look like.</p>
<p class="noindent1">In essence, this approach bundles up the “business logic” and persistence code into a single thing, which I’m calling a “component.” Uncle Bob presented his definition of “component” earlier in the book, saying:</p>
<p class="blockquote"><em class="calibre9">Components are the units of deployment. They are the smallest entities that can be deployed as part of a system. In Java, they are jar files.</em></p>
<div class="fig-heading">
<div class="image1"><a id="part0049_page_314"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00123.jpeg"/></div>
<p class="fig-caption"><a id="part0049_ch34fig6"></a><strong class="calibre8">Figure 34.6</strong> View orders use case</p>
</div>
<p class="noindent1">My definition of a component is slightly different: “A grouping of related functionality behind a nice clean interface, which resides inside an execution environment like an application.” This definition comes from my “C4 software <a id="part0049_page_315"></a>architecture model,”<sup class="calibre10"><a id="part0049_ch34fn7"></a><a href="#part0049_ch34fn-7">7</a></sup> which is a simple hierarchical way to think about the static structures of a software system in terms of containers, components, and classes (or code). It says that a software system is made up of one or more containers (e.g., web applications, mobile apps, stand-alone applications, databases, file systems), each of which contains one or more components, which in turn are implemented by one or more classes (or code). Whether each component resides in a separate jar file is an orthogonal concern.</p>
<p class="noindent1">A key benefit of the “package by component” approach is that if you’re writing code that needs to do something with <code class="calibre11">orders</code>, there’s just one place to go—the <code class="calibre11">OrdersComponent</code>. Inside the component, the separation of concerns is still maintained, so the business logic is separate from data persistence, but that’s a component implementation detail that consumers don’t need to know about. This is akin to what you might end up with if you adopted a micro-services or Service-Oriented Architecture—a separate <code class="calibre11">OrdersService</code> that encapsulates everything related to handling orders. The key difference is the decoupling mode. You can think of well-defined components in a monolithic application as being a stepping stone to a micro-services architecture.</p>
<h3 class="h1" id="part0049_toclev_173">T<small class="calibre13">HE</small> D<small class="calibre13">EVIL</small> I<small class="calibre13">S IN THE</small> I<small class="calibre13">MPLEMENTATION</small> D<small class="calibre13">ETAILS</small></h3>
<p class="noindent1">On the face of it, the four approaches do all look like different ways to organize code and, therefore, could be considered different architectural styles. This perception starts to unravel very quickly if you get the implementation details wrong, though.</p>
<p class="noindent1">Something I see on a regular basis is an overly liberal use of the <code class="calibre11">public</code> access modifier in languages such as Java. It’s almost as if we, as developers, instinctively use the <code class="calibre11">public</code> keyword without thinking. It’s in our muscle memory. If you don’t believe me, take a look at the code samples for books, tutorials, and open source frameworks on GitHub. This tendency is apparent, regardless of which architectural style a code base is aiming to adopt—horizontal layers, vertical layers, ports and adapters, or something else. <a id="part0049_page_316"></a>Marking all of your types as <code class="calibre11">public</code> means you’re not taking advantage of the facilities that your programming language provides with regard to encapsulation. In some cases, there’s literally nothing preventing somebody from writing some code to instantiate a concrete implementation class directly, violating the intended architecture style.</p>
<h3 class="h1" id="part0049_toclev_174">O<small class="calibre13">RGANIZATION VERSUS</small> E<small class="calibre13">NCAPSULATION</small></h3>
<p class="noindent1">Looking at this issue another way, if you make all types in your Java application <code class="calibre11">public</code>, the packages are simply an organization mechanism (a grouping, like folders), rather than being used for encapsulation. Since public types can be used from anywhere in a code base, you can effectively ignore the packages because they provide very little real value. The net result is that if you ignore the packages (because they don’t provide any means of encapsulation and hiding), it doesn’t really matter which architectural style you’re aspiring to create. If we look back at the example UML diagrams, the Java packages become an irrelevant detail if all of the types are marked as <code class="calibre11">public</code>. In essence, all four architectural approaches presented earlier in this chapter are exactly the same when we overuse this designation (<a href="#part0049_ch34fig7">Figure 34.7</a>).</p>
<p class="noindent1">Take a close look at the arrows between each of the types in <a href="#part0049_ch34fig7">Figure 34.7</a>: They’re all identical regardless of which architectural approach you’re trying to adopt. Conceptually the approaches are very different, but syntactically they are identical. Furthermore, you could argue that when you make all of the types <code class="calibre11">public</code>, what you really have are just four ways to describe a traditional horizontally layered architecture. This is a neat trick, and of course nobody would ever make all of their Java types <code class="calibre11">public</code>. Except when they do. And I’ve seen it.</p>
<p class="noindent1">The access modifiers in Java are not perfect,<sup class="calibre10"><a id="part0049_ch34fn8"></a><a href="#part0049_ch34fn-8">8</a></sup> but ignoring them is just asking for trouble. The way Java types are placed into packages can actually make a huge difference to how accessible (or inaccessible) those types can be when <a id="part0049_page_317"></a>Java’s access modifiers are applied appropriately. If I bring the packages back and mark (by graphically fading) those types where the access modifier can be made more restrictive, the picture becomes pretty interesting (<a href="#part0049_ch34fig8">Figure 34.8</a>).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00124.jpeg"/></div>
<p class="fig-caption"><a id="part0049_ch34fig7"></a><strong class="calibre8">Figure 34.7</strong> All four architectural approaches are the same</p>
</div>
<p class="noindent1">Moving from left to right, in the “package by layer” approach, the <code class="calibre11">OrdersService</code> and <code class="calibre11">OrdersRepository</code> interfaces need to be <code class="calibre11">public</code>, because they have inbound dependencies from classes outside of their defining package. In contrast, the implementation classes (<code class="calibre11">OrdersServiceImpl</code> and <code class="calibre11">JdbcOrdersRepository</code>) can be made more restrictive (package protected). Nobody needs to know about them; they are an implementation detail.</p>
<p class="noindent1">In the “package by feature” approach, the <code class="calibre11">OrdersController</code> provides the sole entry point into the package, so everything else can be made package protected. The big caveat here is that nothing else in the code base, outside of this package, can access information related to orders unless they go through the controller. This may or may not be desirable.</p>
<p class="noindent1"><a id="part0049_page_318"></a>In the ports and adapters approach, the <code class="calibre11">OrdersService</code> and <code class="calibre11">Orders</code> interfaces have inbound dependencies from other packages, so they need to be made <code class="calibre11">public</code>. Again, the implementation classes can be made package protected and dependency injected at runtime.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00125.jpeg"/></div>
<p class="fig-caption"><a id="part0049_ch34fig8"></a><strong class="calibre8">Figure 34.8</strong> Grayed-out types are where the access modifier can be made more restrictive</p>
</div>
<p class="noindent1">Finally, in the “package by component” approach, the <code class="calibre11">OrdersComponent</code> interface has an inbound dependency from the controller, but everything else can be made package protected. The fewer <code class="calibre11">public</code> types you have, the smaller the number of potential dependencies. There’s now no way<sup class="calibre10"><a id="part0049_ch34fn9"></a><a href="#part0049_ch34fn-9">9</a></sup> that code outside this package can use the <code class="calibre11">OrdersRepository</code> interface or implementation directly, so we can rely on the compiler to enforce this architectural principle. You can do the same thing in .NET with the <code class="calibre11">internal</code> keyword, although you would need to create a separate assembly for every component.</p>
<p class="noindent1"><a id="part0049_page_319"></a>Just to be absolutely clear, what I’ve described here relates to a monolithic application, where all of the code resides in a single source code tree. If you are building such an application (and many people are), I would certainly encourage you to lean on the compiler to enforce your architectural principles, rather than relying on self-discipline and post-compilation tooling.</p>
<h3 class="h1" id="part0049_toclev_175">O<small class="calibre13">THER</small> D<small class="calibre13">ECOUPLING</small> M<small class="calibre13">ODES</small></h3>
<p class="noindent1">In addition to the programming language you’re using, there are often other ways that you can decouple your source code dependencies. With Java, you have module frameworks like OSGi and the new Java 9 module system. With module systems, when used properly, you can make a distinction between types that are <code class="calibre11">public</code> and types that are <em class="calibre9">published</em>. For example, you could create an <code class="calibre11">Orders</code> module where all of the types are marked as <code class="calibre11">public</code>, but publish only a small subset of those types for external consumption. It’s been a long time coming, but I’m enthusiastic that the Java 9 module system will give us another tool to build better software, and spark people’s interest in design thinking once again.</p>
<p class="noindent1">Another option is to decouple your dependencies at the source code level, by splitting code across <em class="calibre9">different source code trees</em>. If we take the ports and adapters example, we could have three source code trees:</p>
<p class="indenthangingb">• The source code for the business and domain (i.e., everything that is independent of technology and framework choices): <code class="calibre11">OrdersService</code>, <code class="calibre11">OrdersServiceImpl</code>, and <code class="calibre11">Orders</code></p>
<p class="indenthangingb">• The source code for the web: <code class="calibre11">OrdersController</code></p>
<p class="indenthangingb">• The source code for the data persistence: <code class="calibre11">JdbcOrdersRepository</code></p>
<p class="noindent1">The latter two source code trees have a compile-time dependency on the business and domain code, which itself doesn’t know anything about the web or the data persistence code. From an implementation perspective, you can do this by configuring separate modules or projects in your build tool (e.g., Maven, Gradle, MSBuild). Ideally you would repeat this pattern, having a separate source code tree for each and every component in your application. <a id="part0049_page_320"></a>This is very much an idealistic solution, though, because there are real-world performance, complexity, and maintenance issues associated with breaking up your source code in this way.</p>
<p class="noindent1">A simpler approach that some people follow for their ports and adapters code is to have just two source code trees:</p>
<p class="indenthangingb">• Domain code (the “inside”)</p>
<p class="indenthangingb">• Infrastructure code (the “outside”)</p>
<p class="noindent1">This maps on nicely to the diagram (<a href="#part0049_ch34fig9">Figure 34.9</a>) that many people use to summarize the ports and adapters architecture, and there is a compile-time dependency from the infrastructure to the domain.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00126.jpeg"/></div>
<p class="fig-caption"><a id="part0049_ch34fig9"></a><strong class="calibre8">Figure 34.9</strong> Domain and infrastructure code</p>
</div>
<p class="noindent1">This approach to organizing source code will also work, but be aware of the potential trade-off. It’s what I call the “Périphérique anti-pattern of ports and adapters.” The city of Paris, France, has a ring road called the Boulevard Périphérique, which allows you to circumnavigate Paris without entering the <a id="part0049_page_321"></a>complexities of the city. Having all of your infrastructure code in a single source code tree means that it’s potentially possible for infrastructure code in one area of your application (e.g., a web controller) to directly call code in another area of your application (e.g., a database repository), without navigating through the domain. This is especially true if you’ve forgotten to apply appropriate access modifiers to that code.</p>
<h3 class="h1" id="part0049_toclev_176">C<small class="calibre13">ONCLUSION</small>: T<small class="calibre13">HE</small> M<small class="calibre13">ISSING</small> A<small class="calibre13">DVICE</small></h3>
<p class="noindent1">The whole point of this chapter is to highlight that your best design intentions can be destroyed in a flash if you don’t consider the intricacies of the implementation strategy. Think about how to map your desired design on to code structures, how to organize that code, and which decoupling modes to apply during runtime and compile-time. Leave options open where applicable, but be pragmatic, and take into consideration the size of your team, their skill level, and the complexity of the solution in conjunction with your time and budgetary constraints. Also think about using your compiler to help you enforce your chosen architectural style, and watch out for coupling in other areas, such as data models. The devil is in the implementation details.</p>
<p class="fn"><a id="part0049_page_322"></a><a id="part0049_ch34fn-1"></a><a href="#part0049_ch34fn1">1</a>. This is arguably a horrible way to name a class, but as we’ll see later, perhaps it doesn’t really matter.</p>
<p class="fn"><a id="part0049_ch34fn-2"></a><a href="#part0049_ch34fn2">2</a>. <a href="https://martinfowler.com/bliki/PresentationDomainDataLayering.html">https://martinfowler.com/bliki/PresentationDomainDataLayering.html</a>.</p>
<p class="fn"><a id="part0049_ch34fn-3"></a><a href="#part0049_ch34fn3">3</a>. This benefit is much less relevant with the navigation facilities of modern IDEs, but it seems there has been a renaissance moving back to lightweight text editors, for reasons I am clearly too old to understand.</p>
<p class="fn"><a id="part0049_ch34fn-4"></a><a href="#part0049_ch34fn4">4</a>. My first job after graduating from university in 1996 was building client–server desktop applications with a technology called PowerBuilder, a super-productive 4GL that exceled at building database-driven applications. A couple of years later, I was building client–server applications with Java, where we had to build our own database connectivity (this was pre-JDBC) and our own GUI toolkits on top of AWT. That’s “progress“ for you!</p>
<p class="fn"><a id="part0049_ch34fn-5"></a><a href="#part0049_ch34fn5">5</a>. In the <em class="calibre9">Command Query Responsibility Segregation</em> pattern, you have separate patterns for updating and reading data.</p>
<p class="fn"><a id="part0049_ch34fn-6"></a><a href="#part0049_ch34fn6">6</a>. <a href="http://www.laputan.org/mud/">http://www.laputan.org/mud/</a></p>
<p class="fn"><a id="part0049_ch34fn-7"></a><a href="#part0049_ch34fn7">7</a>. See <a href="https://www.structurizr.com/help/c4">https://www.structurizr.com/help/c4</a> for more information.</p>
<p class="fn"><a id="part0049_ch34fn-8"></a><a href="#part0049_ch34fn8">8</a>. In Java, for example, although we tend to think of packages as being hierarchical, it’s not possible to create access restrictions based on a package and subpackage relationship. Any hierarchy that you create is in the name of those packages, and the directory structure on disk, only.</p>
<p class="fn"><a id="part0049_ch34fn-9"></a><a href="#part0049_ch34fn9">9</a>. Unless you cheat and use Java’s reflection mechanism, but please don’t do that!</p>
</body><body class="calibre">
<h2 class="h2f" id="part0050_part7"><a class="calibre3" id="part0050_page_323"></a><span class="gray">VII</span><br class="calibre12"/>Appendix <a class="calibre3" id="part0050_page_324"></a></h2>
</body><body class="calibre">
<h2 class="h2f" id="part0051_appendixa"><a class="calibre3" id="part0051_page_325"></a><span class="gray">A</span><br class="calibre12"/>A<small class="calibre7">RCHITECTURE</small> A<small class="calibre7">RCHAEOLOGY</small></h2>
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00127.jpeg"/></div>
<p class="noindent1"><a id="part0051_page_326"></a>To unearth the principles of good architecture, let’s take a 45-year journey through some of the projects I have worked on since 1970. Some of these projects are interesting from an architectural point of view. Others are interesting because of the lessons learned and because of how they fed into subsequent projects.</p>
<p class="noindent1">This appendix is somewhat autobiographical. I’ve tried to keep the discussion relevant to the topic of architecture; but, as in anything autobiographical, other factors sometimes intrude. <code class="calibre11">;-)</code></p>
<h3 class="h1">U<small class="calibre13">NION</small> A<small class="calibre13">CCOUNTING</small> S<small class="calibre13">YSTEM</small></h3>
<p class="noindent1">In the late 1960s, a company by the name of ASC Tabulating signed a contract with Local 705 of the Teamsters Union to provide an accounting system. The computer ASC chose to implement this system on was a GE Datanet 30, as shown in <a href="#part0051_chAfig1">Figure A.1</a>.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00128.jpeg"/></div>
<p class="fig-caption"><a id="part0051_chAfig1"></a><strong class="calibre8">Figure A.1</strong> GE Datanet 30</p>
<p class="source"><em class="calibre9">Courtesy Ed Thelen, ed-thelen.org</em></p>
</div>
<p class="noindent1"><a id="part0051_page_327"></a>As you can see from the picture, this was a huge<sup class="calibre10"><a id="part0051_appendixafn1"></a><a href="#part0051_appendixafn-1">1</a></sup> machine. It filled a room, and the room needed strict environmental controls.</p>
<p class="noindent1">This computer was built in the days before integrated circuits. It was built out of discrete transistors. There were even some vacuum tubes in it (albeit only in the sense amplifiers of the tape drives).</p>
<p class="noindent1">By today’s standards the machine was huge, slow, small, and primitive. It had 16K × 18 bits of core, with a cycle time of about 7 microseconds.<sup class="calibre10"><a id="part0051_appendixafn2"></a><a href="#part0051_appendixafn-2">2</a></sup> It filled a big, environmentally controlled room. It had 7 track magnetic tape drives and a disk drive with a capacity of 20 megabytes or so.</p>
<p class="noindent1">That disk was a monster. You can see it in the picture in <a href="#part0051_chAfig2">Figure A.2</a>—but that doesn’t quite give you the scale of the beast. The top of that cabinet was over my head. The platters were 36 inches in diameter, and 3/8 of an inch thick. One of the platters is pictured in <a href="#part0051_chAfig3">Figure A.3</a>.</p>
<p class="noindent1">Now count the platters in that first picture. There are more than a dozen. Each one had its own individual seek arm that was driven by pneumatic actuators. You could watch those seek heads move across the platters. The seek time was probably about half a second to a second.</p>
<p class="noindent1">When this beast was turned on, it sounded like a jet engine. The floor would rumble and shake until it got up to speed.<sup class="calibre10"><a id="part0051_appendixafn3"></a><a href="#part0051_appendixafn-3">3</a></sup></p>
<div class="fig-heading">
<div class="image1"><a id="part0051_page_328"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00129.jpeg"/></div>
<p class="fig-caption"><a id="part0051_chAfig2"></a><strong class="calibre8">Figure A.2</strong> The data storage unit with its platters</p>
<p class="source"><em class="calibre9">Courtesy Ed Thelen, ed-thelen.org</em></p>
</div>
<p class="noindent1">The great claim to fame of the Datanet 30 was its capability to drive a large number of asynchronous terminals at relatively high speed. That’s exactly what ASC needed.</p>
<p class="noindent1">ASC was based in Lake Bluff, Illinois, 30 miles north of Chicago. The Local 705 office was in downtown Chicago. The union wanted a dozen or so of their data entry clerks to use CRT<sup class="calibre10"><a id="part0051_appendixafn4"></a><a href="#part0051_appendixafn-4">4</a></sup> terminals (<a href="#part0051_chAfig4">Figure A.4</a>) to enter data into the system. They would print reports on ASR35 teletypes (<a href="#part0051_chAfig5">Figure A.5</a>).</p>
<div class="fig-heading">
<div class="image1"><a id="part0051_page_329"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00130.jpeg"/></div>
<p class="fig-caption"><a id="part0051_chAfig3"></a><strong class="calibre8">Figure A.3</strong> One platter of that disk: 3/8 inch thick, 36 inches in diameter</p>
<p class="source"><em class="calibre9">Courtesy, Ed Thelen, ed-thelen.org</em></p>
</div>
<p class="noindent1">The CRT terminals ran at 30 characters per second. This was a pretty good rate for the late 1960s because modems were relatively unsophisticated in those days.</p>
<p class="noindent1">ASC leased a dozen or so dedicated phone lines and twice that number of 300 baud modems from the phone company to connect the Datanet 30 to these terminals.</p>
<p class="noindent1">These computers did not come with operating systems. They didn’t even come with file systems. What you got was an assembler.</p>
<p class="noindent1">If you needed to store data on the disk, you stored data on the disk. Not in a file. Not in a directory. You figured out which track, platter, and sector to put the data into, and then you operated the disk to put the data there. Yes, that means we wrote our own disk driver.</p>
<div class="fig-heading">
<div class="image1"><a id="part0051_page_330"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00131.jpeg"/></div>
<p class="fig-caption"><a id="part0051_chAfig4"></a><strong class="calibre8">Figure A.4</strong> Datapoint CRT terminal</p>
<p class="source"><em class="calibre9">Courtesy of Bill Degnan, vintagecomputer.net</em></p>
</div>
<p class="noindent1">The Union Accounting system had three kinds of records: Agents, Employers, and Members. The system was a CRUD system for these records, but also included operations for posting dues, computing changes in the general ledger, and so on.</p>
<p class="noindent1">The original system was written in assembler by a consultant who somehow managed to cram the whole thing into 16K.</p>
<p class="noindent1">As you might imagine, that big Datanet 30 was an expensive machine to operate and maintain. The software consultant who kept the software <a id="part0051_page_331"></a>running was expensive, too. What’s more, minicomputers were becoming popular, and were much cheaper.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00132.jpeg"/></div>
<p class="fig-caption"><a id="part0051_chAfig5"></a><strong class="calibre8">Figure A.5</strong> ASR35 teletype</p>
<p class="source"><em class="calibre9">Joe Mabel, with permission</em></p>
</div>
<p class="noindent1">In 1971, when I was 18 years old, ASC hired me and two of my geeky friends to replace the whole union accounting system with one that was based on a Varian 620/f minicomputer (<a href="#part0051_chAfig6">Figure A.6</a>). The computer was cheap. We were cheap. So it seemed like a good deal for ASC.</p>
<p class="noindent1">The Varian machine had a 16-bit bus and 32K * 16 core memory. It had a cycle time of about 1 microsecond. It was much more powerful than the Datanet 30. It used IBM’s wildly successful 2314 disk technology, allowing us to store 30 megabytes on platters that were only 14 inches in diameter and could not explode through concrete block walls!</p>
<p class="noindent1">Of course, we still had no operating system. No file system. No high-level language. All we had was an assembler. But we made do.</p>
<div class="fig-heading">
<div class="image1"><a id="part0051_page_332"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00133.jpeg"/></div>
<p class="fig-caption"><a id="part0051_chAfig6"></a><strong class="calibre8">Figure A.6</strong> Varian 620/f minicomputer</p>
<p class="source"><em class="calibre9">The Minicomputer Orphanage</em></p>
</div>
<p class="noindent1">Instead of trying to cram the whole system into 32K, we created an overlay system. Applications would be loaded from disk into a block of memory dedicated to overlays. They would be executed in that memory, and preemptively swapped back out onto disk, with their local RAM, to allow other programs to execute.</p>
<p class="noindent1">Programs would get swapped into the overlay area, execute enough to fill the output buffers, and then get swapped out so that another program could be swapped in.</p>
<p class="noindent1">Of course, when your UI runs at 30 characters per second, your programs spend a lot of time waiting. We had plenty of time to swap the programs in and off the disk to keep all of the terminals running as fast as they could go. Nobody ever complained of response time issues.</p>
<p class="noindent1">We wrote a preemptive supervisor that managed the interrupts and IO. We wrote the applications; we wrote the disk drivers, the terminal drivers, the tape drivers, and everything else in that system. There was not a single bit in that <a id="part0051_page_333"></a>system that we did not write. Though it was a struggle involving far too many 80-hour weeks, we got the beast up and running in a matter of 8 or 9 months.</p>
<p class="noindent1">The architecture of the system was simple (<a href="#part0051_chAfig7">Figure A.7</a>). When an application was started, it would generate output until its particular terminal buffer was full. Then the supervisor would swap the application out, and swap a new application in. The supervisor would continue to dribble out the contents of the terminal buffer at 30 cps until it was nearly empty. Then it would swap the application back in to fill the buffer again.</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00134.jpeg"/></div>
<p class="fig-caption"><a id="part0051_chAfig7"></a><strong class="calibre8">Figure A.7</strong> The system architecture</p>
</div>
<p class="noindent1">There are two boundaries in this system. The first is the character output boundary. The applications had no idea that their output was going to a 30-cps terminal. Indeed, the character output was entirely abstract from the applications’ point of view. The applications simply passed strings to the supervisor, and the supervisor took care of loading the buffers, sending the characters to the terminals, and swapping the applications in and out of memory.</p>
<p class="noindent1"><a id="part0051_page_334"></a>This boundary was dependency normal—that is, dependencies pointed <em class="calibre9">with</em> the flow of control. The applications had compile-time dependencies on the supervisor, and the flow of control passed from the applications to the supervisor. The boundary prevented the applications from knowing which kind of device the output was going to.</p>
<p class="noindent1">The second boundary was dependency inverted. The supervisor could start the applications, but had no compile-time dependencies upon them. The flow of control passed from the supervisor to the applications. The polymorphic interface that inverted the dependency was simply this: Every application was started by jumping to the exact same memory address within the overlay area. The boundary prevented the supervisor from knowing anything about the applications other than the starting point.</p>
<h3 class="h1">L<small class="calibre13">ASER</small> T<small class="calibre13">RIM</small></h3>
<p class="noindent1">In 1973, I joined a company in Chicago called Teradyne Applied Systems (TAS). This was a division of Teradyne Inc., which was headquartered in Boston. Our product was a system that used relatively high-powered lasers to trim electronic components to very fine tolerances.</p>
<p class="noindent1">Back in those days, manufacturers would silk-screen electronic components onto ceramic substrates. Those substrates were on the order of 1 inch square. The components were typically resistors—devices that resist the flow of current.</p>
<p class="noindent1">The resistance of a resistor depends on a number of factors, including its composition and its geometry. The wider the resistor, the less resistance it has.</p>
<p class="noindent1">Our system would position the ceramic substrate in a harness that had probes that made contact with the resistors. The system would measure the resistance of the resistors, and then use a laser to burn off parts of the resistor, making it thinner and thinner until it reached the desired resistance value within a tenth of a percent or so.</p>
<p class="noindent1"><a id="part0051_page_335"></a>We sold these systems to manufacturers. We also used some in-house systems to trim relatively small batches for small manufacturers.</p>
<p class="noindent1">The computer was an M365. This was in the days when many companies built their own computers: Teradyne built the M365 and supplied it to all its divisions. The M365 was an enhanced version of a PDP-8—a popular minicomputer of the day.</p>
<p class="noindent1">The M365 controlled the positioning table, which moved the ceramic substrates under the probes. It controlled the measurement system and the laser. The laser was positioned using <em class="calibre9">X</em>-<em class="calibre9">Y</em> mirrors that could rotate under program control. The computer could also control the power setting of the laser.</p>
<p class="noindent1">The development environment of the M365 was relatively primitive. There was no disk. Mass storage was on tape cartridges that looked like old 8-track audio tape cassettes. The tapes and drives were made by Tri-Data.</p>
<p class="noindent1">Like the 8-track audio cassettes of the day, the tape was oriented in a loop. The drive moved the tape in only one direction—there was no rewind! If you wanted to position the tape at the beginning, you had to send it forward to its “load point.”</p>
<p class="noindent1">The tape moved at a speed of approximately 1 foot per second. Thus, if the tape loop was 25 feet long, it could take as long as 25 seconds to send it to the load point. For this reason Tridata made cartridges in several lengths, ranging from 10 feet to 100 feet.</p>
<p class="noindent1">The M365 had a button on the front that would load memory with a little bootstrap program and execute it. This program would read the first block of data from the tape, and execute that. Typically this block held a loader that loaded the operating system that lived on the rest of the tape.</p>
<p class="noindent1">The operating system would prompt the user for the name of a program to run. Those programs were stored on the tape, just after the operating system. We would type in the name of the program—for example, the ED-402 <a id="part0051_page_336"></a>Editor—and the operating system would search the tape for that program, load it, and execute it.</p>
<p class="noindent1">The console was an ASCII CRT with green phosphors, 72 characters wide<sup class="calibre10"><a id="part0051_appendixafn5"></a><a href="#part0051_appendixafn-5">5</a></sup> by 24 lines. The characters were all uppercase.</p>
<p class="noindent1">To edit a program, you would load the ED-402 Editor, and then insert the tape that held your source code. You would read one tape block of that source code into memory, and it would be displayed on the screen. The tape block might hold 50 lines of code. You would make your edits by moving the cursor around on the screen and typing in a manner similar to <code class="calibre11">vi</code>. When you were done, you would write that block onto a different tape, and read the next block from the source tape. You kept on doing this until you were done.</p>
<p class="noindent1">There was no scrolling back to previous blocks. You edited your program in a straight line, from beginning to end. Going back to the beginning forced you to finish copying the source code onto the output tape and then start a new editing session on that tape. Perhaps not surprisingly, given these constraints, we printed our programs out on paper, marked all the edits by hand in red ink, and then edited our programs block by block by consulting our markups on the listing.</p>
<p class="noindent1">Once the program was edited, we returned to the OS and invoked the assembler. The assembler read the source code tape, and wrote a binary tape, while also producing a listing on our data products line printer.</p>
<p class="noindent1">The tapes weren’t 100% reliable, so we always wrote two tapes at the same time. That way, at least one of them had a high probability of being free of errors.</p>
<p class="noindent1">Our program was approximately 20,000 lines of code, and took nearly 30 minutes to compile. The odds that we would get a tape read error during that time were roughly 1 in 10. If the assembler got a tape error, it would ring the <a id="part0051_page_337"></a>bell on the console and then start printing a stream of errors on the printer. You could hear this maddening bell all across the lab. You could also hear the cursing of the poor programmer who just learned that the 30-minute compile needed to start over.</p>
<p class="noindent1">The architecture of the program was typical for those days. There was a Master Operating Program, appropriately called “the MOP.” Its job was to manage basic IO functions and provide the rudiments of a console “shell.” Many of the divisions of Teradyne shared the MOP source code, but each had forked it for its own uses. Consequently, we would send source code updates around to each other in the form of marked-up listings that we would then integrate manually (and very carefully).</p>
<p class="noindent1">A special-purpose utility layer controlled the measurement hardware, the positioning tables, and the laser. The boundary between this layer and the MOP was muddled at best. While the utility layer called the MOP, the MOP had been specifically modified for that layer, and often called back into it. Indeed, we didn’t really think of these two as separate layers. To us, it was just some code that we added to the MOP in a highly coupled way.</p>
<p class="noindent1">Next came the isolation layer. This layer provided a virtual machine interface for the application programs, which were written in a completely different domain-specific data-driven language (DSL). The language had operations for moving the laser, moving the table, making cuts, making measurements, and so on. Our customers would write their laser trimming application programs in this language, and the isolation layer would execute them.</p>
<p class="noindent1">This approach was not intended to create a machine-independent laser trim language. Indeed, the language had many idiosyncrasies that were deeply coupled to the layers below. Rather, this approach gave the application programmers a “simpler” language than M356 assembler in which to program their trim jobs.</p>
<p class="noindent1">Trim jobs could be loaded from tape and executed by the system. Essentially, our system was an operating system for trim applications.</p>
<p class="noindent1"><a id="part0051_page_338"></a>The system was written in M365 assembler and compiled in a single compilation unit that produced absolute binary code.</p>
<p class="noindent1">The boundaries in this application were soft at best. Even the boundary between the system code and the applications written in the DSL was not well enforced. There were couplings everywhere.</p>
<p class="noindent1">But that was typical of software in the early 1970s.</p>
<h3 class="h1">A<small class="calibre13">LUMINUM</small> D<small class="calibre13">IE</small>-C<small class="calibre13">AST</small> M<small class="calibre13">ONITORING</small></h3>
<p class="noindent1">In the middle of the 1970s, while OPEC was placing an embargo on oil, and gasoline shortages were causing angry drivers to get into fights at gas stations, I began working at Outboard Marine Corporation (OMC). This is the parent company of Johnson Motors and Lawnboy lawnmowers.</p>
<p class="noindent1">OMC maintained a huge facility in Waukegan, Illinois, for creating die-cast aluminum parts for all of the company’s motors and products. Aluminum was melted down in huge furnaces, and then carried in large buckets to dozens upon dozens of individually operated aluminum die-cast machines. Each machine had a human operator responsible for setting the molds, cycling the machine, and extracting the newly cast parts. These operators were paid based on how many parts they produced.</p>
<p class="noindent1">I was hired to work on a shop-floor automation project. OMC had purchased an IBM System/7—which was IBM’s answer to the minicomputer. They tied this computer to all the die-cast machines on the floor, so that we could count, and time, the cycles of each machine. Our role was to gather all that information and present it on 3270 green-screen displays.</p>
<p class="noindent1">The language was assembler. And, again, every bit of code that executed in this computer was code that we wrote. There was no operating system, no subroutine libraries, and no framework. It was just raw code.</p>
<p class="noindent1"><a id="part0051_page_339"></a>It was also interrupt-driven real-time code. Every time a die-cast machine cycled, we had to update a batch of statistics, and send messages to a great IBM 370 in-the-sky, running a CICS-COBOL program that presented those statistics on the green screens.</p>
<p class="noindent1">I hated this job. Oh, boy, did I. Oh, the <em class="calibre9">work</em> was <em class="calibre9">fun</em>! But the culture … Suffice it to say that I was <em class="calibre9">required</em> to wear a tie.</p>
<p class="noindent1">Oh, I tried. I really did. But I was clearly unhappy working there, and my colleagues knew it. They knew it because I couldn’t remember critical dates or manage to get up early enough to attend important meetings. This was the only programming job I was ever fired from—and I deserved it.</p>
<p class="noindent1">From an architectural point of view, there’s not a lot to learn here except for one thing. The System/7 had a very interesting instruction called <em class="calibre9">set program interrupt</em> (<code class="calibre11">SPI</code>). This allowed you to trigger an interrupt of the processor, allowing it to handle any other queued lower-priority interrupts. Nowadays, in Java we call this <code class="calibre11">Thread.yield()</code>.</p>
<h3 class="h1"><small class="calibre13">4</small>-TEL</h3>
<p class="noindent1">In October 1976, having been fired from OMC, I returned to a different division of Teradyne—a division I would stay with for 12 years. The product I worked on was named 4-TEL. Its purpose was to test every telephone line in a telephone service area, every night, and produce a report of all lines requiring repair. It also allowed telephone test personnel to test specific telephone lines in detail.</p>
<p class="noindent1">This system started its life with the same kind of architecture as the Laser Trim system. It was a monolithic application written in assembly language without any significant boundaries. But at the time I joined the company, that was about to change.</p>
<p class="noindent1">The system was used by testers located in a service center (SC). A service center covered many central offices (CO), each of which could handle as <a id="part0051_page_340"></a>many as 10,000 phone lines. The dialing and measurement hardware had to be located inside the CO. So that’s where the M365 computers were put. We called those computers the central office line testers (COLTs). Another M365 was placed at the SC; it was called the service area computer (SAC). The SAC had several modems that it could use to dial up the COLTs and communicate at 300 baud (30 cps).</p>
<p class="noindent1">At first, the COLT computers did everything, including all the console communication, menus, and reports. The SAC was just a simple multiplexor that took the output from the COLTs and put it on a screen.</p>
<p class="noindent1">The problem with this setup was that 30 cps is really slow. The testers didn’t like watching the characters trickle across the screen, especially since they were only interested in a few key bits of data. Also, in those days, the core memory in the M365 was expensive, and the program was big.</p>
<p class="noindent1">The solution was to separate the part of the software that dialed and measured lines from the part that analyzed the results and printed the reports. The latter would be moved into the SAC, and the former would remain behind in the COLTs. This would allow the COLT to be a smaller machine, with much less memory, and would greatly speed up the response at the terminal, since the reports would be generated in the SAC.</p>
<p class="noindent1">The result was remarkably successful. Screen updates were very fast (once the appropriate COLT had been dialed), and the memory footprint of the COLTs shrank a lot.</p>
<p class="noindent1">The boundary was very clean and highly decoupled. Very short packets of data were exchanged between the SAC and COLT. These packets were a very simple form of DSL, representing primitive commands like “DIAL XXXX” or “MEASURE.”</p>
<p class="noindent1">The M365 was loaded from tape. Those tape drives were expensive and weren’t very reliable—especially in the industrial environment of a telephone central office. Also, the M365 was an expensive machine relative to the rest of <a id="part0051_page_341"></a>the electronics within the COLT. So we embarked upon a project to replace the M365 with a microcomputer based on an 8085 µprocessor.</p>
<p class="noindent1">The new computer was composed of a processor board that held the 8085, a RAM board that held 32K of RAM, and three ROM boards that held 12K of read-only memory apiece. All these boards fit into the same chassis as the measurement hardware, thereby eliminating the bulky extra chassis that had housed the M365.</p>
<p class="noindent1">The ROM boards held 12 Intel 2708 EPROM (Erasable Programmable Read-Only Memory) chips.<sup class="calibre10"><a id="part0051_appendixafn6"></a><a href="#part0051_appendixafn-6">6</a></sup> <a href="#part0051_chAfig8">Figure A.8</a> shows an example of such a chip. We loaded those chips with software by inserting them into special devices called PROM burners that were driven by our development environment. The chips could be erased by exposing them to high-intensity ultraviolet light.<sup class="calibre10"><a id="part0051_appendixafn7"></a><a href="#part0051_appendixafn-7">7</a></sup></p>
<p class="noindent1">My buddy CK and I translated the M365 assembly language program for the COLT into 8085 assembly language. This translation was done by hand and took us about 6 months. The end result was approximately 30K of 8085 code.</p>
<p class="noindent1">Our development environment had 64K of RAM and no ROM, so we could quickly download our compiled binaries into RAM and test them.</p>
<p class="noindent1">Once we got the program working, we switched to using the EPROMs. We burned 30 chips and inserted them into just the right slots in the three ROM boards. Each chip was labeled so we could tell which chip went into which slot.</p>
<p class="noindent1">The 30K program was a single binary, 30K long. To burn the chips, we simply divided that binary image into 30 different 1K segments, and burned each segment onto the appropriately labeled chip.</p>
<div class="fig-heading">
<div class="image1"><a id="part0051_page_342"></a><img alt="Image" class="calibre2" loading="lazy" src="../images/00135.jpeg"/></div>
<p class="fig-caption"><a id="part0051_chAfig8"></a><strong class="calibre8">Figure A.8</strong> EPROM chip</p>
</div>
<p class="noindent1">This worked very well, and we began to mass-produce the hardware and deploy the system into the field.</p>
<p class="noindent1">But software is soft.<sup class="calibre10"><a id="part0051_appendixafn8"></a><a href="#part0051_appendixafn-8">8</a></sup> Features needed to be added. Bugs needed to be fixed. And as the installed base grew, the logistics of updating the software by burning 30 chips per installation, and having field service people replace all 30 chips at each site became a nightmare.</p>
<p class="noindent1">There were all kinds of problems. Sometimes chips would be mislabeled, or the labels would fall off. Sometimes the field service engineer would mistakenly replace the wrong chip. Sometimes the field service engineer would <a id="part0051_page_343"></a>inadvertently break a pin off one of the new chips. Consequently, the field engineers had to carry extras of all 30 chips with them.</p>
<p class="noindent1">Why did we have to change all 30 chips? Every time we added or removed code from our 30K executable, it changed the addresses in which each instruction was loaded. It also changed the addresses of the subroutines and functions that we called. So every chip was affected, no matter how trivial the change.</p>
<p class="noindent1">One day, my boss came to me and asked me to solve that problem. He said we needed a way to make a change to the firmware without replacing all 30 chips every time. We brainstormed this issue for a while, and then embarked upon the “Vectorization” project. It took me three months.</p>
<p class="noindent1">The idea was beautifully simple. We divided the 30K program into 32 independently compilable source files, each less than 1K. At the beginning of each source file, we told the compiler in which address to load the resulting program (e.g., ORG C400 for the chip that was to be inserted into the C4 position).</p>
<p class="noindent1">Also at the beginning of each source file, we created a simple, fixed-size data structure that contained all the addresses of all the subroutines on that chip. This data structure was 40 bytes long, so it could hold no more than 20 addresses. This meant that no chip could have more than 20 subroutines.</p>
<p class="noindent1">Next, we created a special area in RAM known as the vectors. It contained 32 tables of 40 bytes—exactly enough RAM to hold the pointers at the start of each chip.</p>
<p class="noindent1">Finally, we changed every call to every subroutine on every chip into an indirect call through the appropriate RAM vector.</p>
<p class="noindent1">When our processor booted, it would scan each chip and load the vector table at the start of each chip into the RAM vectors. Then it would jump into the main program.</p>
<p class="noindent1"><a id="part0051_page_344"></a>This worked very well. Now, when we fixed a bug, or added a feature, we could simply recompile one or two chips, and send just those chips to the field service engineers.</p>
<p class="noindent1">We had made the chips <em class="calibre9">independently deployable</em>. We had invented polymorphic dispatch. We had invented objects.</p>
<p class="noindent1">This was a plugin architecture, quite literally. We plugged those chips in. We eventually engineered it so that a feature could be installed into our products by plugging the chip with that feature into one of the open chip sockets. The menu control would automatically appear, and the binding into the main application would happen automatically.</p>
<p class="noindent1">Of course, we didn’t know about object-oriented principles at the time, and we knew nothing about separating user interface from business rules. But the rudiments were there, and they were very powerful.</p>
<p class="noindent1">One unexpected side benefit of the approach was that we could patch the firmware over a dial-up connection. If we found a bug in the firmware, we could dial up our devices and use the on-board monitor program to alter the RAM vector for the faulty subroutine to point to a bit of empty RAM. Then we’d enter the repaired subroutine into that RAM area, by typing it in machine code, in hexadecimal.</p>
<p class="noindent1">This was a great boon to our field service operation, and to our customers. If they had a problem, they didn’t need us to ship new chips and schedule an urgent field service call. The system could be patched, and a new chip could be installed at the next regularly scheduled maintenance visit.</p>
<h3 class="h1">T<small class="calibre13">HE</small> S<small class="calibre13">ERVICE</small> A<small class="calibre13">REA</small> C<small class="calibre13">OMPUTER</small></h3>
<p class="noindent1">The 4-TEL service area computer (SAC) was based on an M365 minicomputer. This system communicated with all the COLTs out in the field, through either dedicated or dial-up modems. It would command those COLTs to measure telephone lines, would receive back the raw results, and would then perform a complex analysis of those results to identify and locate any faults.</p>
<h4 class="h2"><a class="calibre3" id="part0051_page_345"></a>D<small class="calibre13">ISPATCH</small> D<small class="calibre13">ETERMINATION</small></h4>
<p class="noindent1">One of the economic foundations for this system was based on the correct allocation of repair craftsmen. Repair craft were separated, by union rules, into three categories: central office, cable, and drop. CO craftsmen fixed problems inside the central office. Cable craftsmen fixed problems in the cable plant that connected the CO to the customer. Drop craftsmen fixed problems inside the customer’s premises, and in the lines connecting the external cable to that premises (the “drop”).</p>
<p class="noindent1">When a customer complained about a problem, our system could diagnose that problem and determine which kind of craftsman to dispatch. This saved the phone companies lots of money because incorrect dispatches meant delays for the customer and wasted trips for the craftsmen.</p>
<p class="noindent1">The code that made this dispatch determination was designed and written by someone who was very bright, but a terrible communicator. The process of writing the code has been described as “Three weeks of staring at the ceiling and two days of code pouring out of every orifice of his body—after which he quit.”</p>
<p class="noindent1">Nobody understood this code. Every time we tried to add a feature or fix a defect, we broke it in some way. And since it was upon this code that one of the primary economic benefits our system rested, every new defect was deeply embarrassing to the company.</p>
<p class="noindent1">In the end, our management simply told us to lock that code down and never modify it. That code became <em class="calibre9">officially rigid</em>.</p>
<p class="noindent1">This experience impressed upon me the value of good, clean code.</p>
<h4 class="h2">A<small class="calibre13">RCHITECTURE</small></h4>
<p class="noindent1">The system was written in 1976 in M365 assembler. It was a single, monolithic program of roughly 60,000 lines. The operating system was a home-grown, nonpreemptive, task-switcher based on polling. We called it MPS for <em class="calibre9">multiprocessing system.</em> The M365 computer had no built-in stack, <a id="part0051_page_346"></a>so task-specific variables were kept in a special area of memory and swapped out at every context switch. Shared variables were managed with locks and semaphores. Reentrancy issues and race conditions were constant problems.</p>
<p class="noindent1">There was no isolation of device control logic, or UI logic, from the business rules of the system. For example, modem control code could be found smeared throughout the bulk of the business rules and UI code. There was no attempt to gather it into a module or abstract the interface. The modems were controlled, at the bit level, by code that was scattered everywhere around the system.</p>
<p class="noindent1">The same was true for the terminal UI. Messages and formatting control code were not isolated. They ranged far and wide throughout the 60,000-line code base.</p>
<p class="noindent1">The modem modules we were using were designed to be mounted on PC boards. We bought those units from a third party, and integrated them with other circuitry onto a board that fit into our custom backplane. These units were expensive. So, after a few years, we decided to design our own modems. We, in the software group, begged the hardware designer to use the same bit formats for controlling the new modem. We explained that the modem control code was smeared everywhere, and that our system would have to deal with both kinds of modems in the future. So, we begged and cajoled, “Please make the new modem look just like the old modem from a software control point of view.”</p>
<p class="noindent1">But when we got the new modem, the control structured was entirely different. It was not just a little different. It was entirely, and completely, different.</p>
<p class="noindent1">Thanks, hardware engineer.</p>
<p class="noindent1">What were we to do? We were not simply replacing all the old modems with new modems. Instead, we were mixing old and new modems in our systems. The software needed to be able to handle both kinds of modems at the same time. Were we doomed to surround every place in the code that manipulated the modems with flags and special cases? There were hundreds of such places!</p>
<p class="noindent1"><a id="part0051_page_347"></a>In the end, we opted for an even worse solution.</p>
<p class="noindent1">One particular subroutine wrote data to the serial communication bus that was used to control all our devices, including our modems. We modified that subroutine to recognize the bit patterns that were specific to the old modem, and translate them into the bit patterns needed by the new modem.</p>
<p class="noindent1">This was not straightforward. Commands to the modem consisted of sequences of writes to different IO addresses on the serial bus. Our hack had to interpret these commands, in sequence, and translate them into a different sequence using different IO addresses, timings, and bit positions.</p>
<p class="noindent1">We got it to work, but it was the worst hack imaginable. It was because of this fiasco that I learned the value of isolating hardware from business rules, and of abstracting interfaces.</p>
<h4 class="h2">T<small class="calibre13">HE</small> G<small class="calibre13">RAND</small> R<small class="calibre13">EDESIGN IN THE</small> S<small class="calibre13">KY</small></h4>
<p class="noindent1">By the time the 1980s rolled around, the idea of producing your own minicomputer and your own computer architecture was beginning to fall out of fashion. There were many microcomputers on the market, and getting them to work was cheaper and more standard then continuing to rely on proprietary computer architectures from the late 1960s. That, plus the horrible architecture of the SAC software, induced our technical management to start a complete re-architecture of the SAC system.</p>
<p class="noindent1">The new system was to be written in C using a UNIX O/S on disk, running on an Intel 8086 microcomputer. Our hardware guys started working on the new computer hardware, and a select group of software developers, “The Tiger Team,” was commissioned with the rewrite.</p>
<p class="noindent1">I won’t bore you with the details of the initial fiasco. Suffice it to say that the first Tiger Team failed entirely after burning two or three man-years on a software project that never delivered anything.</p>
<p class="noindent1">A year or two later, probably 1982, the process was started again. The goal was the total and complete redesign of the SAC in C and UNIX on our own, <a id="part0051_page_348"></a>newly designed, impressively powerful 80286 hardware. We called that computer “Deep Thought.”</p>
<p class="noindent1">It took years, then more years, and then even more years. I don’t know when the first UNIX-based SAC was finally deployed; I believe I had left the company by then (1988). Indeed, I’m not at all sure it ever was deployed.</p>
<p class="noindent1">Why the delay? In short, it is very difficult for a redesign team to catch up with a large staff of programmers who are actively maintaining the old system. Here’s just one example of the difficulties they encountered.</p>
<h4 class="h2">E<small class="calibre13">UROPE</small></h4>
<p class="noindent1">At about the same time that the SAC was being redesigned in C, the company started to expand sales into Europe. They could not wait for the redesigned software to be finished, so of course, they deployed the old M365 systems into Europe.</p>
<p class="noindent1">The problem was that the phone systems in Europe were very different from the phone systems in the United States. The organization of the craft and of the bureaucracies were different as well. So one of our best programmers was sent to the United Kingdom to lead a team of U.K. developers to modify the SAC software to deal with all these European issues.</p>
<p class="noindent1">Of course, no serious attempt was made to integrate these changes into the U.S.-based software. This was long before networks made it feasible to transmit large code bases across the ocean. These U.K. developers simply forked the U.S.-based code and modified it as needed.</p>
<p class="noindent1">This, of course, caused difficulties. Bugs were found on both sides of the Atlantic that needed repair on the other side. But the modules had changed significantly, so it was very difficult to determine whether the fix made in the United States would work in the United Kingdom.</p>
<p class="noindent1">After a few years of heartburn, and the installation of a high-throughput line connecting the U.S. and U.K. offices, a serious attempt was made to integrate <a id="part0051_page_349"></a>these two forks back together again, making the differences a matter of configuration. This effort failed the first, second, and third times it was tried. The two code bases, though remarkably similar, were still too different to reintegrate—especially in the rapidly changing market environment that existed at that time.</p>
<p class="noindent1">Meanwhile, the “Tiger Team,” trying to rewrite everything in C and UNIX, realized that it also had to deal with this European/US dichotomy. And, of course, that did nothing to accelerate their progress.</p>
<h4 class="h2">SAC C<small class="calibre13">ONCLUSION</small></h4>
<p class="noindent1">There are many other stories I could tell you about this system, but it’s just too depressing for me to continue. Suffice it to say that many of the hard lessons of my software life were learned while immersed in the horrible assembler code of the SAC.</p>
<h3 class="h1">C L<small class="calibre13">ANGUAGE</small></h3>
<p class="noindent1">The 8085 computer hardware that we used in the 4-Tel Micro project gave us a relatively low-cost computing platform for many different projects that could be embedded into industrial environments. We could load it up with 32K of RAM and another 32K of ROM, and we had an extremely flexible and powerful scheme for controlling peripherals. What we did not have was a flexible and convenient language with which to program the machine. The 8085 assembler was simply not fun to write code in.</p>
<p class="noindent1">On top of that, the assembler we were using was written by our own programmers. It ran on our M365 computers, using the cartridge tape operating system described in the “Laser Trim” section.</p>
<p class="noindent1">As fate would have it, our lead <em class="calibre9">hardware</em> engineer convinced our CEO that we needed a <em class="calibre9">real</em> computer. He didn’t actually know what he would do with it, but he had a lot of political clout. So we purchased a PDP-11/60.</p>
<p class="noindent1"><a id="part0051_page_350"></a>I, a lowly software developer at the time, was ecstatic. I knew <em class="calibre9">precisely</em> what I wanted to do with that computer. I was determined that this was going to be <em class="calibre9">my</em> machine.</p>
<p class="noindent1">When the manuals arrived, many months before the delivery of the machine, I took them home and devoured them. By the time the computer was delivered, I knew how to operate both the hardware and the software at an intimate level—at least, as intimate as home study can make it.</p>
<p class="noindent1">I helped to write the purchase order. In particular, I specified the disk storage that the new computer would have. I decided we should buy two disk drives that could take removable disk packs that held 25 megabytes each.<sup class="calibre10"><a id="part0051_appendixafn9"></a><a href="#part0051_appendixafn-9">9</a></sup></p>
<p class="noindent1">Fifty megabytes! The number seemed infinite! I remember walking through the halls of the office, late at night, cackling like the Wicked Witch of the West: “Fifty megabytes! Hahahahahahahahahah!”</p>
<p class="noindent1">I had the facilities manager build a little room that would house six VT100 terminals. I decorated it with pictures from space. Our software developers would use this room to write and compile code.</p>
<p class="noindent1">When the machine arrived, I spent several days setting it up, wiring all the terminals, and getting everything to work. It was a joy—a labor of love.</p>
<p class="noindent1">We purchased standard assemblers for the 8085 from Boston Systems Office, and we translated the 4-Tel Micro code into that syntax. We built a cross-compilation system that allowed us to download compiled binaries from the PDP-11 to our 8085 development environments, and ROM burners. And—Bob’s your Uncle—it all worked like a champ.</p>
<h4 class="h2">C</h4>
<p class="noindent1">But that left us with the problem of still using 8085 assembler. That was not a situation that I was happy with. I had heard that there was this “new” <a id="part0051_page_351"></a>language that was heavily used at Bell Labs. They called it “C.” So I purchased a copy of <em class="calibre9">The C Programming Language</em> by Kernighan and Ritchie. Like the PDP-11 manuals a few months before, I <em class="calibre9">inhaled</em> this book.</p>
<p class="noindent1">I was astounded by the simple elegance of this language. It sacrificed none of the power of assembly language, and provided access to that power with a much more convenient syntax. I was sold.</p>
<p class="noindent1">I purchased a C compiler from Whitesmiths, and got it running on the PDP-11. The output of the compiler was assembler syntax that was compatible with the Boston Systems Office 8085 compiler. So we had a pathway to go from C to the 8085 hardware! We were in business.</p>
<p class="noindent1">Now the only problem was convincing a group of embedded assembly language programmers that they should be using C. But that’s a nightmare tale for another time …</p>
<h3 class="h1">BOSS</h3>
<p class="noindent1">Our 8085 platform had no operating system. My experience with the MPS system of the M365, and the primitive interrupt mechanisms of the IBM System 7, convinced me that we needed a simple task switcher for the 8085. So I conceived of BOSS: Basic Operating System and Scheduler.<sup class="calibre10"><a id="part0051_appendixafn10"></a><a href="#part0051_appendixafn-10">10</a></sup></p>
<p class="noindent1">The vast majority of BOSS was written in C. It provided the ability to create concurrent tasks. Those tasks were not preemptive—task switching did not take place based on interrupts. Instead, and just like with the MPS system on the M365, tasks were switched based on a simple polling mechanism. The polling happened whenever a task blocked for an event.</p>
<p class="noindent1">The BOSS call to block a task looked like this:</p>
<p class="pre-ex1">block(eventCheckFunction);</p>
<p class="noindent1"><a id="part0051_page_352"></a>This call suspended the current task, placed the <code class="calibre11">eventCheckFunction</code> in the polling list, and associated it with the newly blocked task. It then waited in the polling loop, calling each of the functions in the polling list until one of them returned <code class="calibre11">true</code>. The task associated with that function was then allowed to run.</p>
<p class="noindent1">In other words, as I said before, it was a simple, nonpreemptive task switcher.</p>
<p class="noindent1">This software became the basis for a vast number of projects over the following years. But one of the first was the pCCU.</p>
<h3 class="h1"><small class="calibre13">p</small>CCU</h3>
<p class="noindent1">The late 1970s and early 1980s were a tumultuous time for telephone companies. One of the sources of that tumult was the digital revolution.</p>
<p class="noindent1">For the preceding century, the connection between the central switching office and the customer’s telephone had been a pair of copper wires. These wires were bundled into cables that spread in a huge network across the countryside. They were sometimes carried on poles, and sometimes buried underground.</p>
<p class="noindent1">Copper is a precious metal, and the phone company had tons (literally tons) of it covering the country. The capital investment was enormous. Much of that capital could be reclaimed by transporting the telephone conversation over digital connections. A single pair of copper wires could carry hundreds of conversations in digital form.</p>
<p class="noindent1">In response, the phone companies embarked upon the process of replacing their old analog central switching equipment with modern digital switches.</p>
<p class="noindent1">Our 4-Tel product tested copper wires, not digital connections. There were still plenty of copper wires in a digital environment, but they were much shorter than before, and they were localized near the customer’s telephones. The signal would be carried digitally from the central office to a local <a id="part0051_page_353"></a>distribution point, where it would be converted back to an analog signal and distributed to the customer over standard copper wires. This meant that our measurement device needed to be located out where the copper wires began, but our dialing device needed to remain at the central office. The problem was that all our COLTs embodied both dialing and measurement in the same device. (We could have saved ourselves a fortune had we recognized that obvious architectural boundary a few years earlier!)</p>
<p class="noindent1">Thus we conceived of a new product architecture: the CCU/CMU (the COLT control unit and the COLT measurement unit). The CCU would be located at the central switching office, and would handle the dialing of the phone lines to be tested. The CMU would be located at the local distribution points, and would measure the copper wires that led to the customer’s phone.</p>
<p class="noindent1">The problem was that for each CCU, there were many CMUs. The information about which CMU should be used for each phone number was held by the digital switch itself. Thus the CCU had to interrogate the digital switch to determine which CMU to communicate with and control.</p>
<p class="noindent1">We promised the phone companies that we would have this new architecture working in time for their transition. We knew they were months, if not years away, so we did not feel rushed. We also knew that it would take several man-years to develop this new CCU/CMU hardware and software.</p>
<h4 class="h2">T<small class="calibre13">HE</small> S<small class="calibre13">CHEDULE</small> T<small class="calibre13">RAP</small></h4>
<p class="noindent1">As time went on, we found that there were always urgent matters that required us to postpone development of the CCU/CMU architecture. We felt safe about this decision because the phone companies were consistently delaying the deployment of digital switches. As we looked at their schedules, we felt confident that we had plenty of time, so we consistently delayed our development.</p>
<p class="noindent1">Then came the day that my boss called me into his office and said: “<em class="calibre9">One of our customers is deploying a digital switch next month. We have to have a working CCU/CMU by then.</em>”</p>
<p class="noindent1"><a id="part0051_page_354"></a>I was aghast! How could we possibly do man-years of development in a month? But my boss had a plan …</p>
<p class="noindent1">We did not, in fact, need a full CCU/CMU architecture. The phone company that was deploying the digital switch was tiny. They had only one central office, and only two local distribution points. More importantly, the “local” distribution points were not particularly local. They actually had regular-old analog switches in them that switched to several hundred customers. Better yet, those switches were of a kind that could be dialed by a normal COLT. Better even still, the customer’s phone number contained all the information necessary to decide which local distribution point to use. If the phone number had a 5, 6, or 7 in a certain position, it went to distribution point 1; otherwise, it went to distribution point 2.</p>
<p class="noindent1">So, as my boss explained to me, we did not actually need a CCU/CMU. What we needed was a simple computer at the central office connected by modem lines to two standard COLTs at the distribution points. The SAC would communicate with our computer at the central office, and that computer would decode the phone number and then relay the dialing and measurement commands to the COLT at the appropriate distribution point.</p>
<p class="noindent1">Thus was born the pCCU.</p>
<p class="noindent1">This was the first product written in C and using BOSS that was deployed to a customer. It took me about a week to develop. There is no deep architectural significance to this tale, but it makes a nice preface to the next project.</p>
<h3 class="h1">DLU/DRU</h3>
<p class="noindent1">In the early 1980s, one of our customers was a telephone company in Texas. They had large geographic areas to cover. In fact, the areas were so large that a single service area required several different offices from which to dispatch craftsmen. Those offices had test craftspeople who needed terminals into our SAC.</p>
<p class="noindent1"><a id="part0051_page_355"></a>You might think that this was a simple problem to solve—but remember that this story takes place in the early 1980s. Remote terminals were not very common. To make matters worse, the hardware of the SAC presumed that all the terminals were local. Our terminals actually sat on a proprietary, high-speed, serial bus.</p>
<p class="noindent1">We had remote terminal capability, but it was based on modems, and in the early 1980s modems were generally limited to 300 bits per second. Our customers were not happy with that slow speed.</p>
<p class="noindent1">High-speed modems were available, but they were very expensive, and they needed to run on “conditioned” permanent connections. Dial-up quality was definitely not good enough.</p>
<p class="noindent1">Our customers demanded a solution. Our response was DLU/DRU.</p>
<p class="noindent1">DLU/DRU stood for “Display Local Unit” and “Display Remote Unit.” The DLU was a computer board that plugged into the SAC computer chassis and pretended to be a terminal manager board. Instead of controlling the serial bus for local terminals, however, it took the character stream and multiplexed it over a single 9600-bps conditioned modem link.</p>
<p class="noindent1">The DRU was a box placed at the customer’s remote location. It connected to the other end of the 9600-bps link, and had the hardware to control the terminals on our proprietary serial bus. It demultiplexed the characters received from the 9600-bps link and sent them to the appropriate local terminals.</p>
<p class="noindent1">Strange, isn’t it? We had to engineer a solution that nowadays is so ubiquitous we never even think about it. But back then …</p>
<p class="noindent1">We even had to invent our own communications protocol because, in those days, standard communications protocols were not open source shareware. Indeed, this was long before we had any kind of Internet connection.</p>
<h4 class="h2"><a class="calibre3" id="part0051_page_356"></a>A<small class="calibre13">RCHITECTURE</small></h4>
<p class="noindent1">The architecture of this system was very simple, but there are some interesting quirks I want to highlight. First, both units used our 8085 technology, and both were written in C and used BOSS. But that’s where the similarity ended.</p>
<p class="noindent1">There were two of us on the project. I was the project lead, and Mike Carew was my close associate. I took on the design and coding of the DLU; Mike did the DRU.</p>
<p class="noindent1">The architecture of the DLU was based on a dataflow model. Each task did a small and focused job, and then passed its output to the next task in line, using a queue. Think of a pipes and filters model in UNIX. The architecture was intricate. One task might feed a queue that many others would service. Other tasks would feed a queue that just one task would service.</p>
<p class="noindent1">Think of an assembly line. Each position on the assembly line has a single, simple, highly focused job to perform. Then the product moves to the next position in line. Sometimes the assembly line splits into many lines. Sometimes those lines merge back into a single line. That was the DLU.</p>
<p class="noindent1">Mike’s DRU used a remarkably different scheme. He created one task per terminal, and simply did the entire job for that terminal in that task. No queues. No data flow. Just many identical large tasks, each managing its own terminal.</p>
<p class="noindent1">This is the opposite of an assembly line. In this case the analogy is many expert builders, each of whom builds an entire product.</p>
<p class="noindent1">At the time I thought my architecture was superior. Mike, of course, thought his was better. We had many entertaining discussions about this. In the end, of course, both worked quite well. And I was left with the realization that software architectures can be wildly different, yet equally effective.</p>
<h3 class="h1"><a class="calibre3" id="part0051_page_357"></a><small class="calibre13">VRS</small></h3>
<p class="noindent1">As the 1980s progressed, newer and newer technologies appeared. One of those technologies was the computer control of <em class="calibre9">voice</em>.</p>
<p class="noindent1">One of the features of the 4-Tel system was the ability of the craftsman to locate a fault in a cable. The procedure was as follows:</p>
<p class="indenthangingb">• The tester, in the central office, would use our system to determine the approximate distance, in feet, to the fault. This would be accurate to within 20% or so. The tester would dispatch a cable repair craftsman to an appropriate access point near that position.</p>
<p class="indenthangingb">• The cable repair craftsman, upon arrival, would call the tester and ask to begin the fault location process. The tester would invoke the fault location feature of the 4-Tel system. The system would begin measuring the electronic characteristics of that faulty line, and would print messages on the screen requesting that certain operations be performed, such as opening the cable or shorting the cable.</p>
<p class="indenthangingb">• The tester would tell the craftsman which operations the system wanted, and the craftsman would tell the tester when the operation was complete. The tester would then tell the system that the operation was complete, and the system would continue with the test.</p>
<p class="indenthangingb">• After two or three such interactions, the system would calculate a new distance to the fault. The cable craftsman would then drive to that location and begin the process again.</p>
<p class="noindent1">Imagine how much better that would be if the cable craftsmen, up on the pole or standing at a pedestal, could operate the system themselves. And that is exactly what the new voice technologies allowed us to do. The cable craftsmen could call directly into our system, direct the system with touch tones, and listen to the results being read back to them in a pleasant voice.</p>
<h4 class="h2">T<small class="calibre13">HE</small> N<small class="calibre13">AME</small></h4>
<p class="noindent1">The company held a little contest to select a name for the new system. One of the most creative of the names suggested was SAM CARP. This stood for <a id="part0051_page_358"></a>“Still Another Manifestation of Capitalist Avarice Repressing the Proletariat.” Needless to say, that wasn’t selected.</p>
<p class="noindent1">Another was the Teradyne Interactive Test System. That one was also not selected.</p>
<p class="noindent1">Still another was Service Area Test Access Network. That, too, was not selected.</p>
<p class="noindent1">The winner, in the end, was VRS: Voice Response System.</p>
<h4 class="h2">A<small class="calibre13">RCHITECTURE</small></h4>
<p class="noindent1">I did not work on this system, but I heard about what happened. The story I am going to relate to you is second-hand, but for the most part, I believe it to be correct.</p>
<p class="noindent1">These were the heady days of microcomputers, UNIX operating systems, C, and SQL databases. We were determined to use them all.</p>
<p class="noindent1">From the many database vendors out there, we eventually chose UNIFY. UNIFY was a database system that worked with UNIX, which was perfect for us.</p>
<p class="noindent1">UNIFY also supported a new technology called <em class="calibre9">Embedded SQL</em>. This technology allowed us to embed SQL commands, as strings, right into our C code. And so we did—everywhere.</p>
<p class="noindent1">I mean, it was just so cool that you could put your SQL right into your code, anywhere you wanted. And where did we want to? Everywhere! And so there was SQL smeared throughout the body of that code.</p>
<p class="noindent1">Of course, in those days SQL was hardly a solid standard. There were lots of special vendor-specific quirks. So the special SQL and special UNIFY API calls were also smeared throughout the code.</p>
<p class="noindent1">This worked great! The system was a success. The craftsmen used it, and the telephone companies loved it. Life was all smiles.</p>
<p class="noindent1"><a id="part0051_page_359"></a>Then the UNIFY product we were using was cancelled.</p>
<p class="noindent1">Oh. Oh.</p>
<p class="noindent1">So we decided to switch to SyBase. Or was it Ingress? I don’t remember. Suffice it to say, we had to search through all that C code, find all the embedded SQL and special API calls, and replace them with corresponding gestures for the new vendor.</p>
<p class="noindent1">After three months of effort or so, we gave up. We couldn’t make it work. We were so coupled to UNIFY that there was no serious hope of restructuring the code at any practical expense.</p>
<p class="noindent1">So, we hired a third party to maintain UNIFY for us, based on a maintenance contract. And, of course, the maintenance rates went up year after year after year.</p>
<h4 class="h2">VRS C<small class="calibre13">ONCLUSION</small></h4>
<p class="noindent1">This is one of the ways that I learned that databases are details that should be isolated from the overall business purpose of the system. This is also one of the reasons that I don’t like strongly coupling to third-party software systems.</p>
<h3 class="h1">T<small class="calibre13">HE</small> E<small class="calibre13">LECTRONIC</small> R<small class="calibre13">ECEPTIONIST</small></h3>
<p class="noindent1">In 1983, our company sat at the confluence of computer systems, telecommunications systems, and voice systems. Our CEO thought this might be a fertile position from which to develop new products. To address this goal, he commissioned a team of three (which included me) to conceive, design, and implement a new product for the company.</p>
<p class="noindent1">It didn’t take us long to come up with <em class="calibre9">The Electronic Receptionist</em> (ER).</p>
<p class="noindent1">The idea was simple. When you called a company, ER would answer and ask you who you wanted to speak with. You would use touch tones to spell the name of that person, and ER would then connect you. The users of ER could <a id="part0051_page_360"></a>dial in and, by using simple touch-tone commands, tell it which phone number the desired person could be reached at, anywhere in the world. In fact, the system could list several alternate numbers.</p>
<p class="noindent1">When you called ER and dialed RMART (my code), ER would call the first number on my list. If I failed to answer and identify myself, it would call the next number, and the next. If I still wasn’t reached, ER would record a message from the caller.</p>
<p class="noindent1">ER would then, periodically, try to find me to deliver that message, and any other message left for me by anyone else.</p>
<p class="noindent1">This was the first voice mail system ever, and we<sup class="calibre10"><a id="part0051_appendixafn11"></a><a href="#part0051_appendixafn-11">11</a></sup> held the patent to it.</p>
<p class="noindent1">We built all the hardware for this system—the computer board, the memory board, the voice/telecom boards, everything. The main computer board was <em class="calibre9">Deep Thought</em>, the Intel 80286 processor that I mentioned earlier.</p>
<p class="noindent1">The voice boards each supported one telephone line. They consisted of a telephone interface, a voice encoder/decoder, some memory, and an Intel 80186 microcomputer.</p>
<p class="noindent1">The software for the main computer board was written in C. The operating system was MP/M-86, an early command-line–driven, multiprocessing, disk operating system. MP/M was the poor man’s UNIX.</p>
<p class="noindent1">The software for the voice boards was written in assembler, and had no operating system. Communication between Deep Thought and the voice boards occurred through shared memory.</p>
<p class="noindent1">The architecture of this system would today be called <em class="calibre9">service oriented</em>. Each telephone line was monitored by a listener process running under MP/M. <a id="part0051_page_361"></a>When a call came in, an initial handler process was started and the call was passed to it. As the call proceeded from state to state, the appropriate handler process would be started and take control.</p>
<p class="noindent1">Messages were passed between these services through disk files. The currently running service would determine what the next service should be; would write the necessary state information into a disk file; would issue the command line to start that service; and then would exit.</p>
<p class="noindent1">This was the first time I had built a system like this. Indeed, this was the first time I had been the principal architect of an entire product. Everything having to do with software was mine—and it worked like a champ.</p>
<p class="noindent1">I would not say that the architecture of this system was “clean” in the sense of this book; it was not a “plugin” architecture. However, it definitely showed signs of true boundaries. The services were independently deployable, and lived within their own domain of responsibility. There were high-level processes and low-level processes, and many of the dependencies ran in the right direction.</p>
<h4 class="h2">ER D<small class="calibre13">EMISE</small></h4>
<p class="noindent1">Unfortunately, the marketing of this product did not go very well. Teradyne was a company that sold test equipment. We did not understand how to break into the office equipment market.</p>
<p class="noindent1">After repeated attempts over two years, our CEO gave up and—unfortunately—dropped the patent application. The patent was picked up by the company that filed three months after we filed; thus we surrendered the entire voice mail and electronic call-forwarding market.</p>
<p class="noindent1">Ouch!</p>
<p class="noindent1">On the other hand, you can’t blame me for those annoying machines that now plague our existence.</p>
<h3 class="h1"><a class="calibre3" id="part0051_page_362"></a>C<small class="calibre13">RAFT</small> D<small class="calibre13">ISPATCH</small> S<small class="calibre13">YSTEM</small></h3>
<p class="noindent1">ER had failed as a product, but we still had all this hardware and software that we could use to enhance our existing product lines. Moreover, our marketing success with VRS convinced us that we should offer a voice response system for interacting with telephone craftsmen that did not depend on our test systems.</p>
<p class="noindent1">Thus was born CDS, the Craft Dispatch System. CDS was essentially ER, but specifically focused on the very narrow domain of managing the deployment of telephone repairmen in the field.</p>
<p class="noindent1">When a problem was discovered in a phone line, a trouble ticket was created in the service center. Trouble tickets were kept in an automated system. When a repairman in the field finished a job, he would call the service center for the next assignment. The service center operator would pull up the next trouble ticket and read it off to the repairman.</p>
<p class="noindent1">We set about to automate that process. Our goal was for the repairman in the field to call into CDS and ask for the next assignment. CDS would consult the trouble ticket system, and read off the results. CDS would keep track of which repairman was assigned to which trouble ticket, and would inform the trouble ticket system of the status of the repair.</p>
<p class="noindent1">There were quite a few interesting features of this system having to do with interacting with the trouble ticket system, the plant management system, and any automated testing systems.</p>
<p class="noindent1">The experience with the service-oriented architecture of ER made me want to try the same idea more aggressively. The state machine for a trouble ticket was much more involved than the state machine for handling a call with ER. I set about to create what would now be called a <em class="calibre9">micro-service architecture</em>.</p>
<p class="noindent1">Every state transition of any call, no matter how insignificant, caused the system to start up a new service. Indeed, the state machine was externalized into a text file that the system read. Each event coming into the system from a <a id="part0051_page_363"></a>phone line turned into a transition in that finite state machine. The existing process would start a new process dictated by the state machine to handle that event; then the existing process would either exit or wait on a queue.</p>
<p class="noindent1">This externalized state machine allowed us to change the flow of the application without changing any code (the Open-Closed Principle). We could easily add a new service, independently of any of the others, and wire it into the flow by modifying the text file that contained the state machine. We could even do this while the system was running. In other words we had <em class="calibre9">hot-swapping</em> and an effective BPEL (Business Process Execution Language).</p>
<p class="noindent1">The old ER approach of using disk files to communicate between services was too slow for this much more rapid flip-flopping of services, so we invented a shared memory mechanism that we called the 3DBB.<sup class="calibre10"><a id="part0051_appendixafn12"></a><a href="#part0051_appendixafn-12">12</a></sup> The 3DBB allowed data to be accessed by name; the names we used were names assigned to each state machine instance.</p>
<p class="noindent1">The 3DBB was great for storing strings and constants, but couldn’t be used for holding complex data structures. The reason for this is technical but easy to understand. Each process in MP/M lived in its own memory partition. Pointers to data in one memory partition had no meaning in another memory partition. As a consequence, the data in the 3DBB could not contain pointers. Strings were fine, but trees, linked lists, or any data structure with pointers would not work.</p>
<p class="noindent1">The trouble tickets in the trouble ticket system came from many different sources. Some were automated, and some were manual. The manual entries were created by operators who were talking to customers about their troubles. As the customers described their problems, the operators would type in their complaints and observations in a structured text stream. It looked something like this:</p>
<p class="codelink"><a href="#part0062_split_001_pappaex01a" id="part0051_pappaex01">Click here to view code image</a></p>
<p class="pre-ex1">/pno 8475551212 /noise /dropped-calls</p>
<p class="noindent1"><a id="part0051_page_364"></a>You get the idea. The <code class="calibre11">/</code> character started a new topic. Following the slash was a code, and following the code were parameters. There were <em class="calibre9">thousands</em> of codes, and an individual trouble ticket could have dozens of them in the description. Worse, since they were manually entered, they were often misspelled or improperly formatted. They were meant for humans to interpret, not for machines to process.</p>
<p class="noindent1">Our problem was to decode these semi-free-form strings, interpret and fix any errors, and then turn them into voice output so we could read them to the repairman, up on a pole, listening with a handset. This required, among other things, a very flexible parsing and data representation technique. That data representation had to be passed through the 3DBB, which could handle only strings.</p>
<p class="noindent1">And so, on an airplane, flying between customer visits, I invented a scheme that I called FLD: <em class="calibre9">Field Labeled Data</em>. Nowadays we would call this XML or JSON. The format was different, but the idea was the same. FLDs were binary trees that associated names with data in a recursive hierarchy. FLDs could be queried by a simple API, and could be translated to and from a convenient string format that was ideal for the 3DBB.</p>
<p class="noindent1">So, micro-services communicating through shared memory analog of sockets using an XML analog—in 1985.</p>
<p class="noindent1">There is nothing new under the Sun.</p>
<h3 class="h1">C<small class="calibre13">LEAR</small> C<small class="calibre13">OMMUNICATIONS</small></h3>
<p class="noindent1">In 1988, a group of Teradyne employees left the company to form a startup named Clear Communications. I joined them a few months later. Our mission was to build the software for a system that would monitor the communications quality of T1 lines—the digital lines that carried long-distance communications across the country. The vision was a huge monitor with a map of the United States crisscrossed by T1 lines flashing red if they were degrading.</p>
<p class="noindent1"><a id="part0051_page_365"></a>Remember, graphical user interfaces were brand new in 1988. The Apple Macintosh was only five years old. Windows was a joke back then. But Sun Microsystems was building Sparcstations that had credible X-Windows GUIs. So we went with Sun—and therefore with C and UNIX.</p>
<p class="noindent1">This was a startup. We worked 70 to 80 hours per week. We had the vision. We had the motivation. We had the will. We had the energy. We had the expertise. We had equity. We had dreams of being millionaires. We were full of shit.</p>
<p class="noindent1">The C code poured out of every orifice of our bodies. We slammed it here, and shoved it there. We constructed huge castles in the air. We had processes, and message queues, and grand, superlative architectures. We wrote a full seven-layer ISO communications stack from scratch—right down to the data link layer.</p>
<p class="noindent1">We wrote GUI code. GOOEY CODE! OMG! We wrote GOOOOOEY code.</p>
<p class="noindent1">I personally wrote a 3000-line C function named <code class="calibre11">gi()</code>; its name stood for Graphic Interpreter. It was a masterpiece of goo. It was not the only goo I wrote at Clear, but it was my most infamous.</p>
<p class="noindent1">Architecture? Are you joking? This was a startup. We didn’t have time for <em class="calibre9">architecture</em>. Just code, dammit! <em class="calibre9">Code for your very lives!</em></p>
<p class="noindent1">So we coded. And we coded. And we coded. But, after three years, what we failed to do was sell. Oh, we had an installation or two. But the market was not particularly interested in our grand vision, and our venture capital financiers were getting pretty fed up.</p>
<p class="noindent1">I hated my life at this point. I saw all my effort and dreams crashing down. I had conflicts at work, conflicts at home because of work, and conflicts with myself.</p>
<p class="noindent1">And then I got a phone call that changed everything.</p>
<h4 class="h2"><a class="calibre3" id="part0051_page_366"></a>T<small class="calibre13">HE</small> S<small class="calibre13">ETUP</small></h4>
<p class="noindent1">Two years before that phone call, two things of significance happened.</p>
<p class="noindent1">First, I managed to set up a <code class="calibre11">uucp</code> connection to a nearby company that had a <code class="calibre11">uucp</code> connection to another facility that was connected to the Internet. These connections were dial-up, of course. Our main Sparcstation (the one on my desk) used a 1200-bps modem to call up our <code class="calibre11">uucp</code> host twice per day. This gave us email and Netnews (an early social network where people discussed interesting issues).</p>
<p class="noindent1">Second, Sun released a C++ compiler. I had been interested in C++ and OO since 1983, but compilers were difficult to come by. So when the opportunity presented itself, I changed languages right away. I left the 3000-line C functions behind, and started to write C++ code at Clear. And I learned …</p>
<p class="noindent1">I read books. Of course, I read <em class="calibre9">The C++ Programming Language</em> and <em class="calibre9">The Annotated C++ Reference Manual</em> (<em class="calibre9">The ARM</em>) by Bjarne Stroustrup. I read Rebecca Wirfs-Brock’s lovely book on responsibility-driven design: <em class="calibre9">Designing Object Oriented Software</em>. I read <em class="calibre9">OOA</em> and <em class="calibre9">OOD</em> and <em class="calibre9">OOP</em> by Peter Coad. I read <em class="calibre9">Smalltalk-80</em> by Adele Goldberg. I read <em class="calibre9">Advanced C++ Programming Styles and Idioms</em> by James O. Coplien. But perhaps most significantly of all, I read <em class="calibre9">Object Oriented Design with Applications</em> by Grady Booch.</p>
<p class="noindent1">What a name! Grady Booch. How could anyone forget a name like that. What’s more, he was the <em class="calibre9">Chief Scientist</em> at a company called Rational! How I wanted to be a <em class="calibre9">Chief Scientist</em>! And so I read his book. And I learned, and I learned, and I learned …</p>
<p class="noindent1">As I learned, I also began debating on Netnews, the way people now debate on Facebook. My debates were about C++ and OO. For two years, I relieved the frustrations that were building at work by debating with hundreds of folks on Usenet about the best language features and the best principles of design. After a while, I even started making a certain amount of sense.</p>
<p class="noindent1"><a id="part0051_page_367"></a>It was in one of those debates that the foundations of the SOLID principles were laid.</p>
<p class="noindent1">And all that debating, and perhaps even some of the sense, got me noticed …</p>
<h4 class="h2">U<small class="calibre13">NCLE</small> B<small class="calibre13">OB</small></h4>
<p class="noindent1">One of the engineers at Clear was a young fellow by the name of Billy Vogel. Billy gave nicknames to everyone. He called me Uncle Bob. I suspect, despite my name being Bob, that he was making an offhand reference to J. R. “Bob” Dobbs (see <a href="https://en.wikipedia.org/wiki/File:Bobdobbs.png">https://en.wikipedia.org/wiki/File:Bobdobbs.png</a>).</p>
<p class="noindent1">At first I tolerated it. But as the months went by, his incessant chattering of “Uncle Bob, … Uncle Bob,” in the context of the pressures and disappointments of the startup, started to wear pretty thin.</p>
<p class="noindent1">And then, one day, the phone rang.</p>
<h4 class="h2">T<small class="calibre13">HE</small> P<small class="calibre13">HONE</small> C<small class="calibre13">ALL</small></h4>
<p class="noindent1">It was a recruiter. He had gotten my name as someone who knew C++ and object-oriented design. I’m not sure how, but I suspect it had something to do with my Netnews presence.</p>
<p class="noindent1">He said he had an opportunity in Silicon Valley, at a company named Rational. They were looking for help building a CASE<sup class="calibre10"><a id="part0051_appendixafn13"></a><a href="#part0051_appendixafn-13">13</a></sup> tool.</p>
<p class="noindent1">The blood drained from my face. I <em class="calibre9">knew</em> what this was. I don’t know how I knew, but I <em class="calibre9">knew</em>. This was <em class="calibre9">Grady Booch’s</em> company. I saw before me the opportunity to join forces with <em class="calibre9">Grady Booch</em>!</p>
<h3 class="h1"><a class="calibre3" id="part0051_page_368"></a>ROSE</h3>
<p class="noindent1">I joined Rational, as a contract programmer, in 1990. I was working on the ROSE product. This was a tool that allowed programmers to draw Booch diagrams—the diagrams that Grady had written about in <em class="calibre9">Object-Oriented Analysis and Design with Applications</em> (<a href="#part0051_chAfig9">Figure A.9</a> shows an example).</p>
<div class="fig-heading">
<div class="image1"><img alt="Image" class="calibre2" loading="lazy" src="../images/00136.jpeg"/></div>
<p class="fig-caption"><a id="part0051_chAfig9"></a><strong class="calibre8">Figure A.9</strong> A Booch diagram</p>
</div>
<p class="noindent1">The Booch notation was very powerful. It presaged notations like UML.</p>
<p class="noindent1">ROSE had an architecture—a <em class="calibre9">real</em> architecture. It was constructed in true layers, and the dependencies between layers were properly controlled. The architecture made it releasable, developable, and independently deployable.</p>
<p class="noindent1">Oh, it wasn’t perfect. There were a lot of things we still didn’t understand about architectural principles. We did not, for example, create a true plugin structure.</p>
<p class="noindent1">We also fell for one of the most unfortunate fads of the day—we used a so-called object-oriented database.</p>
<p class="noindent1"><a id="part0051_page_369"></a>But, overall, the experience was a great one. I spent a lovely year and a half working with the Rational team on ROSE. This was one of the most intellectually stimulating experiences of my professional life.</p>
<h4 class="h2">T<small class="calibre13">HE</small> D<small class="calibre13">EBATES</small> C<small class="calibre13">ONTINUED</small></h4>
<p class="noindent1">Of course, I did not stop debating on Netnews. In fact, I drastically increased my network presence. I started writing articles for <em class="calibre9">C++ Report</em>. And, with Grady’s help, I started working on my first book: <em class="calibre9">Designing Object-Oriented C++ Applications Using the Booch Method</em>.</p>
<p class="noindent1">One thing bothered me. It was perverse, but it was true. No one was calling me “Uncle Bob.” I found that I missed it. So I made the mistake of putting “Uncle Bob” in my email and Netnews signatures. And the name stuck. Eventually I realized that it was a pretty good brand.</p>
<h4 class="h2">... B<small class="calibre13">Y</small> A<small class="calibre13">NY</small> O<small class="calibre13">THER</small> N<small class="calibre13">AME</small></h4>
<p class="noindent1">ROSE was a gigantic C++ application. It was composed of layers, with a strictly enforced dependency rule. That rule is not the rule that I have described in this book. We did <em class="calibre9">not</em> point our dependencies toward high-level policies. Rather, we pointed our dependencies in the more traditional direction of flow control. The GUI pointed at the representation, which pointed at the manipulation rules, which pointed at the database. In the end, it was this failure to direct our dependencies toward policy that aided the eventual demise of the product.</p>
<p class="noindent1">The architecture of ROSE was similar to the architecture of a good compiler. The graphical notation was “parsed” into an internal representation; that representation was then manipulated by rules and stored in an object-oriented database.</p>
<p class="noindent1">Object-oriented databases were a relatively new idea, and the OO world was all abuzz with the implications. Every object-oriented programmer wanted to have an object-oriented database in his or her system. The idea was relatively simple, and deeply idealistic. The database stores objects, not tables. The <a id="part0051_page_370"></a>database was supposed to look like RAM. When you accessed an object, it simply appeared in memory. If that object pointed to another object, the other object would appear in memory as soon as you accessed it. It was like magic.</p>
<p class="noindent1">That database was probably our biggest practical mistake. We wanted the magic, but what we got was a big, slow, intrusive, expensive third-party framework that made our lives hell by impeding our progress on just about every level.</p>
<p class="noindent1">That database was not the only mistake we made. The biggest mistake, in fact, was over-architecture. There were many more layers than I have described here, and each had its own brand of communications overhead. This served to significantly reduce the productivity of the team.</p>
<p class="noindent1">Indeed, after many man-years of work, immense struggles, and two tepid releases, the whole tool was scrapped and replaced with a cute little application written by a small team in Wisconsin.</p>
<p class="noindent1">And so I learned that great architectures sometimes lead to great failures. Architecture must be flexible enough to adapt to the size of the problem. Architecting for the enterprise, when all you really need is a cute little desktop tool, is a recipe for failure.</p>
<h3 class="h1">A<small class="calibre13">RCHITECTS</small> R<small class="calibre13">EGISTRY</small> E<small class="calibre13">XAM</small></h3>
<p class="noindent1">In the early 1990s, I became a true consultant. I traveled the world teaching people what this new OO thing was. My consulting was focused strongly on the design and architecture of object-oriented systems.</p>
<p class="noindent1">One of my first consulting clients was Educational Testing Service (ETS). It was under contract with the National Council of Architects Registry Board (NCARB) to conduct the registration exams for new architect candidates.</p>
<p class="noindent1">Anyone desiring to be a registered architect (the kind who design buildings) in the United States or Canada must pass the registration exam. This exam <a id="part0051_page_371"></a>involved having the candidate solve a number of architectural problems involving building design. The candidate might be given a set of requirements for a public library, or a restaurant, or a church, and then asked to draw the appropriate architectural diagrams.</p>
<p class="noindent1">The results would be collected and saved until such time as a group of senior architects could be gathered together as jurors, to score the submissions. These gatherings were big, expensive events and were the source of much ambiguity and delay.</p>
<p class="noindent1">NCARB wanted to automate the process by having the candidates take the exams using a computer, and then have another computer do the evaluation and scoring. NCARB asked ETS to develop that software, and ETS hired me to gather a team of developers to produce the product.</p>
<p class="noindent1">ETS had broken the problem down into 18 individual test vignettes. Each would require a CAD-like GUI application that the candidate would use to express his or her solution. A separate scoring application would take in the solutions and produce scores.</p>
<p class="noindent1">My partner, Jim Newkirk, and I realized that these 36 applications had vast amounts of similarity. The 18 GUI apps all used similar gestures and mechanisms. The 18 scoring applications all used the same mathematical techniques. Given these shared elements, Jim and I were determined to develop a reusable framework for all 36 applications. Indeed, we sold this idea to ETS by saying that we’d spend a long time working on the first application, but then the rest would just pop out every few weeks.</p>
<p class="noindent1">At this point you should be face-palming or banging your head on this book. Those of you who are old enough may remember the “reuse” promise of OO. We were all convinced, back then, that if you just wrote good clean object-oriented C++ code, you would just naturally produce lots and lots of reusable code.</p>
<p class="noindent1">So we set about to write the first application—which was the most complicated of the batch. It was called Vignette Grande.</p>
<p class="noindent1"><a id="part0051_page_372"></a>The two of us worked full time on Vignette Grande with an eye toward creating a reusable framework. It took us a year. At the end of that year we had 45,000 lines of framework code and 6000 lines of application code. We delivered this product to ETS, and they contracted with us to write the other 17 applications post-haste.</p>
<p class="noindent1">So Jim and I recruited a team of three other developers and we began to work on the next few vignettes.</p>
<p class="noindent1">But something went wrong. We found that the reusable framework we had created was not particularly reusable. It did not fit well into the new applications being written. There were subtle frictions that just didn’t work.</p>
<p class="noindent1">This was deeply discouraging, but we believed we knew what to do about it. We went to ETS and told them that there would be a delay—that the 45,000-line framework needed to be rewritten, or at least readjusted. We told them that it would take a while longer to get that done.</p>
<p class="noindent1">I don’t need to tell you that ETS was not particularly happy with this news.</p>
<p class="noindent1">So we began again. We set the old framework aside and began writing four new vignettes simultaneously. We would borrow ideas and code from the old framework but rework them so that they fit into all four without modification. This effort took another year. It produced another 45,000-line framework, plus four vignettes that were on the order of 3000 to 6000 lines each.</p>
<p class="noindent1">Needless to say, the relationship between the GUI applications and the framework followed the Dependency Rule. The vignettes were plugins to the framework. All the high-level GUI policy was in the framework. The vignette code was just glue.</p>
<p class="noindent1">The relationship between the scoring applications and the framework was a bit more complex. The high-level scoring policy was in the vignette. The scoring framework plugged into the scoring vignette.</p>
<p class="noindent1"><a id="part0051_page_373"></a>Of course, both of these applications were statically linked C++ applications, so the notion of plugin was nowhere in our minds. And yet, the way the dependencies ran was consistent with the Dependency Rule.</p>
<p class="noindent1">Having delivered those four applications, we began on the next four. And this time they started popping out the back end every few weeks, just as we had predicted. The delay had cost us nearly a year on our schedule, so we hired another programmer to speed the process along.</p>
<p class="noindent1">We met our dates and our commitments. Our customer was happy. We were happy. Life was good.</p>
<p class="noindent1">But we learned a good lesson: You can’t make a reusable framework until you first make a usable framework. Reusable frameworks require that you build them in concert with <em class="calibre9">several</em> reusing applications.</p>
<h3 class="h1">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">As I said at the start, this appendix is somewhat autobiographical. I’ve hit the high points of the projects that I felt had an architectural impact. And, of course, I mentioned a few episodes that were not exactly relevant to the technical content of this book, but were significant nonetheless.</p>
<p class="noindent1">Of course, this was a partial history. There were many other projects that I worked on over the decades. I also purposely stopped this history in the early 1990s—because I have another book to write about the events of the late 1990s.</p>
<p class="noindent1">My hope is that you enjoyed this little trip down my memory lane; and that you were able to learn some things along the way.<a id="part0051_page_374"></a></p>
<p class="fn"><a id="part0051_appendixafn-1"></a><a href="#part0051_appendixafn1">1</a>. One of the stories we heard about the particular machine at ASC was that it was shipped in a large semi-trailer truck along with a household of furniture. On the way, the truck hit a bridge at high speed. The computer was fine, but it slid forward and crushed the furniture into splinters.</p>
<p class="fn"><a id="part0051_appendixafn-2"></a><a href="#part0051_appendixafn2">2</a>. Today we would say that it had a clock rate of 142 kHz.</p>
<p class="fn"><a id="part0051_appendixafn-3"></a><a href="#part0051_appendixafn3">3</a>. Imagine the mass of that disk. Imagine the kinetic energy! One day we came in and saw little metal shavings dropping out from the button of the cabinet. We called the maintenance man. He advised us to shut the unit down. When he came to repair it, he said that one of the bearings had worn out. Then he told us stories about how these disks, if not repaired, could tear loose from their moorings, plow through concrete block walls, and embed themselves into cars in the parking lot.</p>
<p class="fn"><a id="part0051_appendixafn-4"></a><a href="#part0051_appendixafn4">4</a>. Cathode ray tube: monochrome, green-screen, ASCII displays.</p>
<p class="fn"><a id="part0051_appendixafn-5"></a><a href="#part0051_appendixafn5">5</a>. The magic number 72 came from Hollerith punched cards, which held 80 characters each. The last 8 characters were “reserved” for sequence numbers in case you dropped the deck.</p>
<p class="fn"><a id="part0051_appendixafn-6"></a><a href="#part0051_appendixafn6">6</a>. Yes, I understand that’s an oxymoron.</p>
<p class="fn"><a id="part0051_appendixafn-7"></a><a href="#part0051_appendixafn7">7</a>. They had a little clear plastic window that allowed you to see the silicon chip inside, and allowed the UV to erase the data.</p>
<p class="fn"><a id="part0051_appendixafn-8"></a><a href="#part0051_appendixafn8">8</a>. Yes, I know that when software is burned into ROM, it’s called firmware—but even firmware is really still soft.</p>
<p class="fn"><a id="part0051_appendixafn-9"></a><a href="#part0051_appendixafn9">9</a>. RKO7.</p>
<p class="fn1"><a id="part0051_appendixafn-10"></a><a href="#part0051_appendixafn10">10</a>. This was later renamed as Bob’s Only Successful Software.</p>
<p class="fn1"><a id="part0051_appendixafn-11"></a><a href="#part0051_appendixafn11">11</a>. Our company held the patent. Our employment contract made it clear that anything we invented belonged to our company. My boss told me: “You sold it to us for one dollar, and we didn’t pay you that dollar.”</p>
<p class="fn1"><a id="part0051_appendixafn-12"></a><a href="#part0051_appendixafn12">12</a>. Three-Dimensional Black Board. If you were born in the 1950s, you likely get this reference: Drizzle, Drazzle, Druzzle, Drone.</p>
<p class="fn1"><a id="part0051_appendixafn-13"></a><a href="#part0051_appendixafn13">13</a>. Computer Aided Software Engineering</p>
</body><body class="calibre">
<h2 class="h2f" id="part0052_index"><a class="calibre3" id="part0052_page_375"></a>I<small class="calibre7">NDEX</small></h2>
<p class="noindent1"><strong class="calibre8">Numbers</strong></p>
<p class="indexmain" id="part0052_idx1">3DBB shared memory system, Craft Dispatch System archaeology project, <a href="#part0051_page_363">363</a></p>
<p class="indexmain" id="part0052_idx2">4-TEL, archaeology projects</p>
<p class="indexsub">BOSS, <a href="#part0051_page_351">351</a>–<a href="#part0051_page_352">352</a></p>
<p class="indexsub">C language, <a href="#part0051_page_349">349</a>–<a href="#part0051_page_351">351</a></p>
<p class="indexsub">DLU/DRU, <a href="#part0051_page_354">354</a>–<a href="#part0051_page_356">356</a></p>
<p class="indexsub">overview of, <a href="#part0051_page_339">339</a>–<a href="#part0051_page_344">344</a></p>
<p class="indexsub">pCCU, <a href="#part0051_page_352">352</a>–<a href="#part0051_page_354">354</a></p>
<p class="indexsub">SAC (service area computer), <a href="#part0051_page_344">344</a>–<a href="#part0051_page_349">349</a></p>
<p class="indexsub">VRS, <a href="#part0051_page_357">357</a>–<a href="#part0051_page_359">359</a></p>
<p class="indexmain" id="part0052_idx3">8085 computer, archaeological projects</p>
<p class="indexsub">4-TEL, <a href="#part0051_page_341">341</a></p>
<p class="indexsub">BOSS, <a href="#part0051_page_351">351</a></p>
<p class="indexsub">C language and, <a href="#part0051_page_349">349</a>–<a href="#part0051_page_351">351</a></p>
<p class="indexsub">DLU/DRU, <a href="#part0051_page_356">356</a></p>
<p class="indexmain" id="part0052_idx4">8086 Intel microcomputer, SAC archaeology project, <a href="#part0051_page_347">347</a>–<a href="#part0051_page_348">348</a></p>
<p class="indexmain1"><strong class="calibre8">A</strong></p>
<p class="indexmain" id="part0052_idx5">Abstract classes</p>
<p class="indexsub">conclusion, <a href="#part0027_page_132">132</a></p>
<p class="indexsub">Dependency Inversion Principle and, <a href="#part0023_page_87">87</a></p>
<p class="indexsub">leftover in Zone of Uselessness, <a href="#part0027_page_129">129</a>–<a href="#part0027_page_130">130</a></p>
<p class="indexsub">placing high-level policy, <a href="#part0027_page_126">126</a>–<a href="#part0027_page_128">128</a></p>
<p class="indexsub">services in Java as set of, <a href="#part0041_page_246">246</a></p>
<p class="indexmain" id="part0052_idx6">Abstract components, <a href="#part0027_page_125">125</a>–<a href="#part0027_page_126">126</a></p>
<p class="indexmain" id="part0052_idx7">Abstract Factories, <a href="#part0023_page_89">89</a>–<a href="#part0023_page_90">90</a></p>
<p class="indexmain" id="part0052_idx8">Abstractions</p>
<p class="indexsub">principle of stable. <em class="calibre9">See</em> <a href="#part0052_idx352">SAP (Stable Abstractions Principle)</a></p>
<p class="indexsub">source code dependencies and, <a href="#part0023_page_87">87</a></p>
<p class="indexsub">stable, <a href="#part0023_page_88">88</a>–<a href="#part0023_page_89">89</a></p>
<p class="indexmain" id="part0052_idx9">Access modifiers, architectural packages, <a href="#part0049_page_316">316</a>–<a href="#part0049_page_319">319</a></p>
<p class="indexmain" id="part0052_idx10">Accidental duplication, <a href="#part0030_page_154">154</a>–<a href="#part0030_page_155">155</a></p>
<p class="indexmain" id="part0052_idx11">Actors, <a href="#part0019_page_62">62</a>–<a href="#part0019_page_65">65</a></p>
<p class="indexmain" id="part0052_idx12">Address segments, relocatable binaries, <a href="#part0025_page_99">99</a>–<a href="#part0025_page_100">100</a></p>
<p class="indexmain" id="part0052_idx13"><a id="part0052_page_376"></a>ADP (Acyclic Dependencies Principle)</p>
<p class="indexsub">breaking cycle, <a href="#part0027_page_117">117</a>–<a href="#part0027_page_118">118</a></p>
<p class="indexsub">component dependency graph effected by, <a href="#part0027_page_118">118</a></p>
<p class="indexsub">effect of cycle in component dependency graph, <a href="#part0027_page_115">115</a>–<a href="#part0027_page_117">117</a></p>
<p class="indexsub">eliminating dependency cycles, <a href="#part0027_page_113">113</a>–<a href="#part0027_page_115">115</a></p>
<p class="indexsub">jitters, <a href="#part0027_page_118">118</a></p>
<p class="indexsub">overview of, <a href="#part0027_page_112">112</a></p>
<p class="indexsub">weekly build, <a href="#part0027_page_112">112</a>–<a href="#part0027_page_113">113</a></p>
<p class="indexmain" id="part0052_idx14">Aluminum die-cast monitoring, archaeology project, <a href="#part0051_page_338">338</a>–<a href="#part0051_page_339">339</a></p>
<p class="indexmain" id="part0052_idx15">APIs, testing, <a href="#part0042_page_252">252</a>–<a href="#part0042_page_253">253</a></p>
<p class="indexmain" id="part0052_idx16">App-titude test, <a href="#part0043_page_258">258</a>–<a href="#part0043_page_261">261</a></p>
<p class="indexmain" id="part0052_idx17">Application-specific business rules, use cases, <a href="#part0034_page_192">192</a>–<a href="#part0034_page_193">193</a>, <a href="#part0036_page_204">204</a></p>
<p class="indexmain" id="part0052_idx18">Architects</p>
<p class="indexsub">goal to minimize human resources, <a href="#part0031_page_160">160</a></p>
<p class="indexsub">registry exam archaeology project, <a href="#part0051_page_370">370</a>–<a href="#part0051_page_373">373</a></p>
<p class="indexsub">separate details from policy, <a href="#part0029_page_142">142</a></p>
<p class="indexmain" id="part0052_idx19">Architecture</p>
<p class="indexsub">clean. <em class="calibre9">See</em> <a href="#part0052_idx62">Clean architecture</a></p>
<p class="indexsub">clean embedded. <em class="calibre9">See</em> <a href="#part0052_idx63">Clean embedded architecture</a></p>
<p class="indexsub">design vs., <a href="#part0011_page_4">4</a></p>
<p class="indexsub">in DLU/DRU archaeology project, <a href="#part0051_page_356">356</a></p>
<p class="indexsub">Eisenhower’s matrix of importance vs. urgency, <a href="#part0012_page_16">16</a>–<a href="#part0012_page_17">17</a></p>
<p class="indexsub">getting software right, <a href="#part0010_page_2">2</a></p>
<p class="indexsub">immutability and, <a href="#part0017_page_52">52</a></p>
<p class="indexsub">independence. <em class="calibre9">See</em> <a href="#part0052_idx205">Independence</a></p>
<p class="indexsub">ISP and, <a href="#part0022_page_86">86</a></p>
<p class="indexsub">LSP and, <a href="#part0021_page_80">80</a></p>
<p class="indexsub">plugin, <a href="#part0031_page_170">170</a>–<a href="#part0031_page_171">171</a></p>
<p class="indexsub">in ROSE archaeology product, <a href="#part0051_page_368">368</a>–<a href="#part0051_page_370">370</a></p>
<p class="indexsub">in SAC archaeology project, <a href="#part0051_page_345">345</a>–<a href="#part0051_page_347">347</a></p>
<p class="indexsub">as senior to function, <a href="#part0012_page_18">18</a></p>
<p class="indexsub">as software value, <a href="#part0012_page_14">14</a>–<a href="#part0012_page_15">15</a></p>
<p class="indexsub">stability, <a href="#part0027_page_122">122</a>–<a href="#part0027_page_126">126</a></p>
<p class="indexsub">testing, <a href="#part0037_page_213">213</a></p>
<p class="indexsub">three big concerns in, <a href="#part0014_page_24">24</a></p>
<p class="indexsub">value of function vs., <a href="#part0012_page_15">15</a>–<a href="#part0012_page_16">16</a></p>
<p class="indexsub">in VRS archaeology project, <a href="#part0051_page_358">358</a>–<a href="#part0051_page_359">359</a></p>
<p class="indexmain" id="part0052_idx20">Architecture archaeology projects</p>
<p class="indexsub">4-TEL, <a href="#part0051_page_339">339</a>–<a href="#part0051_page_344">344</a></p>
<p class="indexsub">aluminum die-cast monitoring, <a href="#part0051_page_338">338</a>–<a href="#part0051_page_339">339</a></p>
<p class="indexsub">architects registry exam, <a href="#part0051_page_370">370</a>–<a href="#part0051_page_373">373</a></p>
<p class="indexsub">by author since 1970, <a href="#part0051_page_325">325</a>–<a href="#part0051_page_326">326</a></p>
<p class="indexsub">Basic Operating System and Scheduler, <a href="#part0051_page_351">351</a>–<a href="#part0051_page_352">352</a></p>
<p class="indexsub">C language, <a href="#part0051_page_349">349</a>–<a href="#part0051_page_351">351</a></p>
<p class="indexsub">conclusion, <a href="#part0051_page_373">373</a></p>
<p class="indexsub">Craft Dispatch System, <a href="#part0051_page_361">361</a>–<a href="#part0051_page_367">367</a></p>
<p class="indexsub">DLU/DRU, <a href="#part0051_page_354">354</a>–<a href="#part0051_page_356">356</a></p>
<p class="indexsub">Electronic Receptionist, <a href="#part0051_page_359">359</a>–<a href="#part0051_page_361">361</a></p>
<p class="indexsub">Laser Trim, <a href="#part0051_page_334">334</a>–<a href="#part0051_page_338">338</a></p>
<p class="indexsub">pCCU, <a href="#part0051_page_352">352</a>–<a href="#part0051_page_354">354</a></p>
<p class="indexsub">ROSE product, <a href="#part0051_page_368">368</a>–<a href="#part0051_page_370">370</a></p>
<p class="indexsub">service area computer, <a href="#part0051_page_344">344</a>–<a href="#part0051_page_349">349</a></p>
<p class="indexsub">Union Accounting system, <a href="#part0051_page_326">326</a>–<a href="#part0051_page_334">334</a></p>
<p class="indexsub">VRS, <a href="#part0051_page_357">357</a>–<a href="#part0051_page_359">359</a></p>
<p class="indexmain" id="part0052_idx21">Architecture, defining</p>
<p class="indexsub">conclusion, <a href="#part0029_page_146">146</a></p>
<p class="indexsub">deployment, <a href="#part0029_page_138">138</a></p>
<p class="indexsub">development, <a href="#part0029_page_137">137</a>–<a href="#part0029_page_138">138</a></p>
<p class="indexsub">device independence, <a href="#part0029_page_142">142</a>–<a href="#part0029_page_143">143</a></p>
<p class="indexsub">junk mail example, <a href="#part0029_page_144">144</a>–<a href="#part0029_page_145">145</a></p>
<p class="indexsub">keeping options open, <a href="#part0029_page_140">140</a>–<a href="#part0029_page_142">142</a></p>
<p class="indexsub"><a id="part0052_page_377"></a>maintenance, <a href="#part0029_page_139">139</a>–<a href="#part0029_page_140">140</a></p>
<p class="indexsub">operation, <a href="#part0029_page_138">138</a>–<a href="#part0029_page_139">139</a></p>
<p class="indexsub">physical addressing example, <a href="#part0029_page_145">145</a>–<a href="#part0029_page_146">146</a></p>
<p class="indexsub">understanding, <a href="#part0029_page_135">135</a>–<a href="#part0029_page_137">137</a></p>
<p class="indexmain" id="part0052_idx22">Architecture, screaming</p>
<p class="indexsub">about the web, <a href="#part0035_page_197">197</a>–<a href="#part0035_page_198">198</a></p>
<p class="indexsub">conclusion, <a href="#part0035_page_199">199</a></p>
<p class="indexsub">frameworks as tools, not ways of life, <a href="#part0035_page_198">198</a></p>
<p class="indexsub">overview of, <a href="#part0035_page_195">195</a>–<a href="#part0035_page_196">196</a></p>
<p class="indexsub">purpose of, <a href="#part0035_page_197">197</a></p>
<p class="indexsub">testable architectures, <a href="#part0035_page_198">198</a></p>
<p class="indexsub">theme, <a href="#part0035_page_196">196</a>–<a href="#part0035_page_197">197</a></p>
<p class="indexmain" id="part0052_idx23">Archives, as aggregation of components, <a href="#part0025_page_96">96</a></p>
<p class="indexmain" id="part0052_idx24">Artifacts, OCP, <a href="#part0020_page_70">70</a></p>
<p class="indexmain" id="part0052_idx25">ASC Tabulating, Union Accounting archaeology project, <a href="#part0051_page_326">326</a>–<a href="#part0051_page_334">334</a></p>
<p class="indexmain" id="part0052_idx26">Assignment, and functional programming, <a href="#part0014_page_23">23</a></p>
<p class="indexmain" id="part0052_idx27">Asymmetric marriage, to framework authors, <a href="#part0047_page_292">292</a>–<a href="#part0047_page_293">293</a></p>
<p class="indexmain" id="part0052_idx28">Authors, framework, <a href="#part0047_page_292">292</a>–<a href="#part0047_page_293">293</a></p>
<p class="indexmain" id="part0052_idx29">Automated systems, business rules, <a href="#part0034_page_191">191</a>–<a href="#part0034_page_192">192</a></p>
<p class="indexmain1"><strong class="calibre8">B</strong></p>
<p class="indexmain" id="part0052_idx30">Base classes, frameworks, <a href="#part0047_page_293">293</a></p>
<p class="indexmain" id="part0052_idx31">BCE system architecture, <a href="#part0036_page_202">202</a></p>
<p class="indexmain" id="part0052_idx32">Beck, Kent, <a href="#part0043_page_258">258</a>–<a href="#part0043_page_261">261</a></p>
<p class="indexmain" id="part0052_idx33">Behavior (function)</p>
<p class="indexsub">architecture supports system, <a href="#part0029_page_137">137</a>, <a href="#part0030_page_148">148</a></p>
<p class="indexsub">Eisenhower’s matrix of importance vs. urgency, <a href="#part0012_page_16">16</a>–<a href="#part0012_page_17">17</a></p>
<p class="indexsub">fighting for seniority of architecture over function, <a href="#part0012_page_18">18</a></p>
<p class="indexsub">keeping options open, <a href="#part0029_page_140">140</a>–<a href="#part0029_page_142">142</a></p>
<p class="indexsub">as software value, <a href="#part0012_page_14">14</a></p>
<p class="indexsub">value of function vs. architecture, <a href="#part0012_page_15">15</a>–<a href="#part0012_page_16">16</a></p>
<p class="indexmain" id="part0052_idx34">Binaries, relocatability, <a href="#part0025_page_99">99</a>–<a href="#part0025_page_100">100</a></p>
<p class="indexmain" id="part0052_idx35">Booch, Grady</p>
<p class="indexsub">introduction to, <a href="#part0051_page_366">366</a></p>
<p class="indexsub">working for, <a href="#part0051_page_367">367</a></p>
<p class="indexsub">working on ROSE product, <a href="#part0051_page_368">368</a>–<a href="#part0051_page_369">369</a></p>
<p class="indexmain" id="part0052_idx36">BOSS (Basic Operating System and Scheduler)</p>
<p class="indexsub">archaeology project, <a href="#part0051_page_351">351</a>–<a href="#part0051_page_352">352</a></p>
<p class="indexsub">in DLU/DRU archaeology project, <a href="#part0051_page_356">356</a></p>
<p class="indexmain" id="part0052_idx37">Boundaries</p>
<p class="indexsub">in <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_340">340</a>–<a href="#part0051_page_341">341</a></p>
<p class="indexsub">conclusion, <a href="#part0031_page_173">173</a></p>
<p class="indexsub">dividing services into components, <a href="#part0041_page_246">246</a></p>
<p class="indexsub">in Electronic Receptionist archaeology project, <a href="#part0051_page_361">361</a></p>
<p class="indexsub">FitNesse program, <a href="#part0031_page_163">163</a>–<a href="#part0031_page_165">165</a></p>
<p class="indexsub">input and output, <a href="#part0031_page_169">169</a>–<a href="#part0031_page_170">170</a></p>
<p class="indexsub">in Laser Trim archaeology project, <a href="#part0051_page_338">338</a></p>
<p class="indexsub">layers and. <em class="calibre9">See</em> <a href="#part0052_idx231">Layers and boundaries</a></p>
<p class="indexsub">overview of, <a href="#part0031_page_159">159</a>–<a href="#part0031_page_160">160</a></p>
<p class="indexsub">partial, <a href="#part0038_page_218">218</a>–<a href="#part0038_page_220">220</a></p>
<p class="indexsub">plugin architecture, <a href="#part0031_page_170">170</a>–<a href="#part0031_page_171">171</a></p>
<p class="indexsub">plugin argument, <a href="#part0031_page_172">172</a>–<a href="#part0031_page_173">173</a></p>
<p class="indexsub">sad stories of architectural failures, <a href="#part0031_page_160">160</a>–<a href="#part0031_page_163">163</a></p>
<p class="indexsub">services as function calls across, <a href="#part0041_page_240">240</a></p>
<p class="indexsub">test, <a href="#part0042_page_249">249</a>–<a href="#part0042_page_253">253</a></p>
<p class="indexsub">Union Accounting system archaeology project, <a href="#part0051_page_333">333</a>–<a href="#part0051_page_334">334</a></p>
<p class="indexsub">which lines to draw, and when, <a href="#part0031_page_165">165</a>–<a href="#part0031_page_169">169</a></p>
<p class="indexmain" id="part0052_idx38"><a id="part0052_page_378"></a>Boundary anatomy</p>
<p class="indexsub">boundary crossing, <a href="#part0032_page_176">176</a></p>
<p class="indexsub">conclusion, <a href="#part0032_page_181">181</a></p>
<p class="indexsub">deployment components, <a href="#part0032_page_178">178</a>–<a href="#part0032_page_179">179</a></p>
<p class="indexsub">dreaded monolith, <a href="#part0032_page_176">176</a>–<a href="#part0032_page_178">178</a></p>
<p class="indexsub">local processes, <a href="#part0032_page_179">179</a>–<a href="#part0032_page_180">180</a></p>
<p class="indexsub">services, <a href="#part0032_page_180">180</a>–<a href="#part0032_page_181">181</a></p>
<p class="indexsub">threads, <a href="#part0032_page_179">179</a></p>
<p class="indexmain" id="part0052_idx39">Boundary crossing</p>
<p class="indexsub">in clean architecture, <a href="#part0036_page_206">206</a></p>
<p class="indexsub">clean architecture scenario, <a href="#part0036_page_207">207</a>–<a href="#part0036_page_208">208</a></p>
<p class="indexsub">creating appropriate, <a href="#part0032_page_176">176</a></p>
<p class="indexsub">Dependency Rule for data in, <a href="#part0036_page_207">207</a></p>
<p class="indexmain" id="part0052_idx40">Breaking cycle, Acyclic Dependencies Principle, <a href="#part0027_page_117">117</a>–<a href="#part0027_page_118">118</a></p>
<p class="indexmain" id="part0052_idx41">Business managers</p>
<p class="indexsub">Eisenhower’s matrix of importance vs. urgency, <a href="#part0012_page_17">17</a></p>
<p class="indexsub">preference for function vs. architecture, <a href="#part0012_page_15">15</a>–<a href="#part0012_page_16">16</a></p>
<p class="indexmain" id="part0052_idx42">Business rules</p>
<p class="indexsub">boundaries between GUI and, <a href="#part0031_page_169">169</a>–<a href="#part0031_page_170">170</a></p>
<p class="indexsub">clean architecture for, <a href="#part0036_page_202">202</a>–<a href="#part0036_page_203">203</a></p>
<p class="indexsub">conclusion, <a href="#part0034_page_194">194</a></p>
<p class="indexsub">creating Entities, <a href="#part0034_page_190">190</a>–<a href="#part0034_page_191">191</a></p>
<p class="indexsub">decoupling from UI, <a href="#part0046_page_287">287</a>–<a href="#part0046_page_289">289</a></p>
<p class="indexsub">decoupling layers, <a href="#part0030_page_152">152</a>–<a href="#part0030_page_153">153</a></p>
<p class="indexsub">decoupling use cases, <a href="#part0030_page_153">153</a></p>
<p class="indexsub">designing for testability, <a href="#part0042_page_251">251</a></p>
<p class="indexsub">in Hunt the Wumpus adventure game, <a href="#part0039_page_222">222</a>–<a href="#part0039_page_223">223</a></p>
<p class="indexsub">independent developability, <a href="#part0016_page_47">47</a></p>
<p class="indexsub">keeping close to data, <a href="#part0019_page_67">67</a></p>
<p class="indexsub">plugging into, <a href="#part0031_page_170">170</a>–<a href="#part0031_page_173">173</a></p>
<p class="indexsub">policy statements calculating, <a href="#part0033_page_184">184</a></p>
<p class="indexsub">request/response models and, <a href="#part0034_page_193">193</a>–<a href="#part0034_page_194">194</a></p>
<p class="indexsub">in SAC archaeology project, <a href="#part0051_page_346">346</a>–<a href="#part0051_page_347">347</a></p>
<p class="indexsub">separating components with boundary lines, <a href="#part0031_page_165">165</a>–<a href="#part0031_page_169">169</a></p>
<p class="indexsub">understanding, <a href="#part0034_page_189">189</a>–<a href="#part0034_page_190">190</a></p>
<p class="indexsub">use cases for, <a href="#part0034_page_191">191</a>–<a href="#part0034_page_193">193</a>, <a href="#part0036_page_204">204</a></p>
<p class="indexmain1"><strong class="calibre8">C</strong></p>
<p class="indexmain" id="part0052_idx43">C++ language</p>
<p class="indexsub">inheritance in, <a href="#part0016_page_40">40</a></p>
<p class="indexsub">learning, <a href="#part0051_page_366">366</a></p>
<p class="indexsub">marrying STL framework in, <a href="#part0047_page_293">293</a></p>
<p class="indexsub">polymorphism in, <a href="#part0016_page_42">42</a></p>
<p class="indexsub">ROSE application, <a href="#part0051_page_369">369</a>–<a href="#part0051_page_370">370</a></p>
<p class="indexsub">weakening encapsulation, <a href="#part0016_page_36">36</a>–<a href="#part0016_page_37">37</a></p>
<p class="indexmain" id="part0052_idx44">C language</p>
<p class="indexsub">BOSS archaeology project using, <a href="#part0051_page_351">351</a>–<a href="#part0051_page_352">352</a></p>
<p class="indexsub">DLU/DRU archaeology project using, <a href="#part0051_page_356">356</a></p>
<p class="indexsub">encapsulation in, <a href="#part0016_page_34">34</a>–<a href="#part0016_page_36">36</a></p>
<p class="indexsub">inheritance in, <a href="#part0016_page_38">38</a>–<a href="#part0016_page_40">40</a></p>
<p class="indexsub">polymorphism in, <a href="#part0016_page_40">40</a>–<a href="#part0016_page_42">42</a></p>
<p class="indexsub">redesigning SAC in, <a href="#part0051_page_347">347</a>–<a href="#part0051_page_348">348</a></p>
<p class="indexmain" id="part0052_idx45">C language, archaeology project, <a href="#part0051_page_349">349</a>–<a href="#part0051_page_351">351</a></p>
<p class="indexmain" id="part0052_idx46">C# programming language</p>
<p class="indexsub">abstract components in, <a href="#part0027_page_125">125</a></p>
<p class="indexsub">dependency inversion, <a href="#part0016_page_45">45</a></p>
<p class="indexsub">using statements for dependencies, <a href="#part0033_page_184">184</a></p>
<p class="indexsub">weakening encapsulation, <a href="#part0016_page_36">36</a>–<a href="#part0016_page_37">37</a></p>
<p class="indexmain" id="part0052_idx47"><em class="calibre9">C Programming Language</em> (Kernighan &amp; Ritchie), <a href="#part0051_page_351">351</a></p>
<p class="indexmain" id="part0052_idx48">C4 software architecture model, <a href="#part0049_page_314">314</a>–<a href="#part0049_page_315">315</a></p>
<p class="indexmain" id="part0052_idx49">Carew, Mike, <a href="#part0051_page_356">356</a></p>
<p class="indexmain" id="part0052_idx50">CASE (Computer Aided Software Engineering) tool, <a href="#part0051_page_368">368</a></p>
<p class="indexmain" id="part0052_idx51"><a id="part0052_page_379"></a>Case study. <em class="calibre9">See</em> <a href="#part0052_idx434">Video sales case study</a></p>
<p class="indexmain" id="part0052_idx52">Cathode ray tube (CRT) terminals, Union Accounting archaeology project, <a href="#part0051_page_328">328</a>–<a href="#part0051_page_329">329</a></p>
<p class="indexmain" id="part0052_idx53">CCP (Common Closure Principle)</p>
<p class="indexsub">decoupling layers, <a href="#part0030_page_152">152</a></p>
<p class="indexsub">grouping policies into components, <a href="#part0033_page_186">186</a>–<a href="#part0033_page_187">187</a></p>
<p class="indexsub">keeping changes localized, <a href="#part0027_page_118">118</a></p>
<p class="indexsub">overview of, <a href="#part0026_page_105">105</a>–<a href="#part0026_page_107">107</a></p>
<p class="indexsub">Stable Dependencies Principle and, <a href="#part0027_page_120">120</a></p>
<p class="indexsub">tension diagram, <a href="#part0026_page_108">108</a>–<a href="#part0026_page_110">110</a></p>
<p class="indexmain" id="part0052_idx54">CCU/CMU (COLT control unit/COLT measurement unit), pCCU archaeology project, <a href="#part0051_page_353">353</a>–<a href="#part0051_page_354">354</a></p>
<p class="indexmain" id="part0052_idx55">CDS (Craft Dispatch System), archaeology project</p>
<p class="indexsub">overview of, <a href="#part0051_page_361">361</a>–<a href="#part0051_page_363">363</a></p>
<p class="indexmain" id="part0052_idx56">Central office line testers. <em class="calibre9">See</em> <a href="#part0052_idx71">COLTs (central office line testers)</a></p>
<p class="indexmain" id="part0052_idx57">Central offices (COs), <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_339">339</a>–<a href="#part0051_page_340">340</a></p>
<p class="indexmain" id="part0052_idx58">Change, ease of software, <a href="#part0012_page_14">14</a>–<a href="#part0012_page_15">15</a></p>
<p class="indexmain" id="part0052_idx59">Church, Alonzo, <a href="#part0014_page_22">22</a>–<a href="#part0014_page_23">23</a>, <a href="#part0017_page_50">50</a></p>
<p class="indexmain" id="part0052_idx60">CICS-COBOL program, aluminum die-cast archaeology project, <a href="#part0051_page_339">339</a></p>
<p class="indexmain" id="part0052_idx61">Classes</p>
<p class="indexsub">abstract. <em class="calibre9">See</em> <a href="#part0052_idx5">Abstract classes</a></p>
<p class="indexsub">Common Reuse Principle, <a href="#part0026_page_107">107</a>–<a href="#part0026_page_108">108</a></p>
<p class="indexsub">DIP and, <a href="#part0023_page_89">89</a></p>
<p class="indexsub">LSP use in guiding inheritance, <a href="#part0021_page_78">78</a></p>
<p class="indexsub">partitioning processes into, <a href="#part0020_page_71">71</a>–<a href="#part0020_page_72">72</a></p>
<p class="indexsub">Reuse/Release Equivalence Principle, <a href="#part0026_page_105">105</a></p>
<p class="indexsub">SRP examples, <a href="#part0019_page_67">67</a></p>
<p class="indexmain" id="part0052_idx62">Clean architecture</p>
<p class="indexsub">characteristics of, <a href="#part0036_page_201">201</a>–<a href="#part0036_page_203">203</a></p>
<p class="indexsub">conclusion, <a href="#part0036_page_209">209</a></p>
<p class="indexsub">Dependency Rule, <a href="#part0036_page_203">203</a>–<a href="#part0036_page_207">207</a></p>
<p class="indexsub">frameworks tend to violate, <a href="#part0047_page_293">293</a></p>
<p class="indexsub">typical scenario, <a href="#part0036_page_208">208</a></p>
<p class="indexsub">using layers and boundaries, <a href="#part0039_page_223">223</a>–<a href="#part0039_page_226">226</a></p>
<p class="indexmain" id="part0052_idx63">Clean embedded architecture</p>
<p class="indexsub">app-titude test, <a href="#part0043_page_258">258</a>–<a href="#part0043_page_261">261</a></p>
<p class="indexsub">conclusion, <a href="#part0043_page_273">273</a></p>
<p class="indexsub">don’t reveal hardware details to user of HAL, <a href="#part0043_page_265">265</a>–<a href="#part0043_page_269">269</a></p>
<p class="indexsub">DRY conditional compilation directives, <a href="#part0043_page_272">272</a></p>
<p class="indexsub">hardware is detail, <a href="#part0043_page_263">263</a>–<a href="#part0043_page_264">264</a></p>
<p class="indexsub">is testable embedded architecture, <a href="#part0043_page_262">262</a></p>
<p class="indexsub">layers, <a href="#part0043_page_262">262</a>–<a href="#part0043_page_263">263</a></p>
<p class="indexsub">operating system is detail, <a href="#part0043_page_269">269</a>–<a href="#part0043_page_271">271</a></p>
<p class="indexsub">overview of, <a href="#part0043_page_255">255</a>–<a href="#part0043_page_258">258</a></p>
<p class="indexsub">programming to interfaces and substitutability, <a href="#part0043_page_271">271</a>–<a href="#part0043_page_272">272</a></p>
<p class="indexsub">target-hardware bottleneck, <a href="#part0043_page_261">261</a></p>
<p class="indexmain" id="part0052_idx64"><a href="http://Cleancoders.com">Cleancoders.com</a>, <a href="#part0048_page_297">297</a></p>
<p class="indexmain" id="part0052_idx65">Clear Communications, <a href="#part0051_page_364">364</a>–<a href="#part0051_page_367">367</a></p>
<p class="indexsub">phone call, <a href="#part0051_page_367">367</a></p>
<p class="indexsub">setup, <a href="#part0051_page_366">366</a></p>
<p class="indexsub">Uncle Bob, <a href="#part0051_page_367">367</a></p>
<p class="indexmain" id="part0052_idx66">Clojure, <a href="#part0017_page_50">50</a>–<a href="#part0017_page_51">51</a>, <a href="#part0017_page_53">53</a>–<a href="#part0017_page_54">54</a></p>
<p class="indexmain" id="part0052_idx67">Codd, Edgar, <a href="#part0045_page_278">278</a></p>
<p class="indexmain" id="part0052_idx68">Code</p>
<p class="indexsub">in aluminum die-cast archaeology project, <a href="#part0051_page_338">338</a>–<a href="#part0051_page_339">339</a></p>
<p class="indexsub">decreasing productivity/increased cost of, <a href="#part0011_page_5">5</a>–<a href="#part0011_page_7">7</a></p>
<p class="indexsub">foolishness of overconfidence, <a href="#part0011_page_9">9</a>–<a href="#part0011_page_12">12</a></p>
<p class="indexsub">rising costs of development payroll, <a href="#part0011_page_8">8</a>–<a href="#part0011_page_9">9</a></p>
<p class="indexsub">in SAC archaeology project, <a href="#part0051_page_345">345</a></p>
<p class="indexsub"><a id="part0052_page_380"></a>signature of messy, <a href="#part0011_page_7">7</a>–<a href="#part0011_page_8">8</a></p>
<p class="indexsub">source code dependencies. <em class="calibre9">See</em> <a href="#part0052_idx379">Source code dependencies</a></p>
<p class="indexmain" id="part0052_idx69">Code organization</p>
<p class="indexsub">conclusion, <a href="#part0049_page_321">321</a></p>
<p class="indexsub">devil is in the details, <a href="#part0049_page_315">315</a>–<a href="#part0049_page_316">316</a></p>
<p class="indexsub">other decoupling modes, <a href="#part0049_page_319">319</a>–<a href="#part0049_page_320">320</a></p>
<p class="indexsub">overview of, <a href="#part0049_page_303">303</a>–<a href="#part0049_page_304">304</a></p>
<p class="indexsub">package by component, <a href="#part0049_page_310">310</a>–<a href="#part0049_page_315">315</a></p>
<p class="indexsub">package by feature, <a href="#part0049_page_306">306</a>–<a href="#part0049_page_307">307</a></p>
<p class="indexsub">package by layer, <a href="#part0049_page_304">304</a>–<a href="#part0049_page_306">306</a></p>
<p class="indexsub">ports and adapters, <a href="#part0049_page_308">308</a>–<a href="#part0049_page_310">310</a></p>
<p class="indexsub">vs. encapsulation, <a href="#part0049_page_316">316</a>–<a href="#part0049_page_319">319</a></p>
<p class="indexmain" id="part0052_idx70">Cohesion, Single Responsibility Principle, <a href="#part0019_page_63">63</a></p>
<p class="indexmain" id="part0052_idx71">COLTs (central office line testers)</p>
<p class="indexsub">in <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_340">340</a>–<a href="#part0051_page_344">344</a></p>
<p class="indexsub">pCCU archaeology project, <a href="#part0051_page_352">352</a>–<a href="#part0051_page_354">354</a></p>
<p class="indexsub">in service area computer archaeology project, <a href="#part0051_page_344">344</a>–<a href="#part0051_page_349">349</a></p>
<p class="indexmain" id="part0052_idx72">Common Closure Principle. <em class="calibre9">See</em> <a href="#part0052_idx53">CCP (Common Closure Principle)</a></p>
<p class="indexmain" id="part0052_idx73">Common Reuse Principle. <em class="calibre9">See</em> <a href="#part0052_idx104">CRP (Common Reuse Principle)</a></p>
<p class="indexmain" id="part0052_idx74">Communications</p>
<p class="indexsub">across deployment component boundaries, <a href="#part0032_page_179">179</a></p>
<p class="indexsub">across local process boundaries, <a href="#part0032_page_180">180</a></p>
<p class="indexsub">across service boundaries, <a href="#part0032_page_180">180</a>–<a href="#part0032_page_181">181</a></p>
<p class="indexsub">across source-level decoupled boundaries, <a href="#part0032_page_178">178</a></p>
<p class="indexsub">Conway’s law, <a href="#part0030_page_149">149</a></p>
<p class="indexsub">as function calls between components in monoliths, <a href="#part0032_page_178">178</a></p>
<p class="indexsub">in types of decoupling modes, <a href="#part0030_page_155">155</a>–<a href="#part0030_page_157">157</a></p>
<p class="indexmain" id="part0052_idx75">Compare and swap algorithm, <a href="#part0017_page_54">54</a></p>
<p class="indexmain" id="part0052_idx76">Compiled languages, <a href="#part0025_page_96">96</a></p>
<p class="indexmain" id="part0052_idx77">Compilers</p>
<p class="indexsub">enforce architectural principles with, <a href="#part0049_page_319">319</a></p>
<p class="indexsub">location of source code, <a href="#part0025_page_97">97</a>–<a href="#part0025_page_98">98</a></p>
<p class="indexsub">relocatable binaries, <a href="#part0025_page_99">99</a>–<a href="#part0025_page_100">100</a></p>
<p class="indexmain" id="part0052_idx78">Component architecture, video sales case study, <a href="#part0048_page_300">300</a>–<a href="#part0048_page_302">302</a></p>
<p class="indexmain" id="part0052_idx79">Component-based systems</p>
<p class="indexsub">building scalable, <a href="#part0041_page_241">241</a></p>
<p class="indexsub">designing services using SOLID, <a href="#part0041_page_245">245</a>–<a href="#part0041_page_246">246</a></p>
<p class="indexsub">function calls, <a href="#part0041_page_240">240</a></p>
<p class="indexsub">OO approach for cross-cutting concerns, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexmain" id="part0052_idx80">Component cohesion</p>
<p class="indexsub">Common Closure Principle, <a href="#part0026_page_105">105</a>–<a href="#part0026_page_107">107</a></p>
<p class="indexsub">Common Reuse Principle, <a href="#part0026_page_107">107</a>–<a href="#part0026_page_108">108</a></p>
<p class="indexsub">conclusion, <a href="#part0026_page_110">110</a></p>
<p class="indexsub">overview of, <a href="#part0026_page_104">104</a></p>
<p class="indexsub">Reuse/Release Equivalence Principle, <a href="#part0026_page_104">104</a>–<a href="#part0026_page_105">105</a></p>
<p class="indexsub">tension diagram, <a href="#part0026_page_108">108</a>–<a href="#part0026_page_110">110</a></p>
<p class="indexmain" id="part0052_idx81">Component coupling</p>
<p class="indexsub">ADP. <em class="calibre9">See</em> <a href="#part0052_idx13">ADP (Acyclic Dependencies Principle)</a></p>
<p class="indexsub">conclusion, <a href="#part0027_page_132">132</a></p>
<p class="indexsub">Fragile Tests Problem, <a href="#part0042_page_251">251</a></p>
<p class="indexsub">overview of, <a href="#part0027_page_111">111</a></p>
<p class="indexsub">Stable Abstractions Principle. <em class="calibre9">See</em> <a href="#part0052_idx352">SAP (Stable Abstractions Principle)</a></p>
<p class="indexsub">Stable Dependencies Principle, <a href="#part0027_page_120">120</a>–<a href="#part0027_page_126">126</a></p>
<p class="indexsub">top-down design, <a href="#part0027_page_118">118</a>–<a href="#part0027_page_119">119</a></p>
<p class="indexmain" id="part0052_idx82"><a id="part0052_page_381"></a>Component dependency graph</p>
<p class="indexsub">break cycle of components/reinstate as DAG, <a href="#part0027_page_117">117</a>–<a href="#part0027_page_118">118</a></p>
<p class="indexsub">effect of cycle in, <a href="#part0027_page_115">115</a>–<a href="#part0027_page_117">117</a></p>
<p class="indexmain" id="part0052_idx83">Component-per-team architecture, <a href="#part0029_page_137">137</a>–<a href="#part0029_page_138">138</a></p>
<p class="indexmain" id="part0052_idx84">Components</p>
<p class="indexsub">concrete, <a href="#part0023_page_91">91</a></p>
<p class="indexsub">deployment of, <a href="#part0032_page_178">178</a>–<a href="#part0032_page_179">179</a></p>
<p class="indexsub">history of, <a href="#part0025_page_96">96</a>–<a href="#part0025_page_99">99</a></p>
<p class="indexsub">linkers, <a href="#part0025_page_100">100</a>–<a href="#part0025_page_102">102</a></p>
<p class="indexsub">overview of, <a href="#part0025_page_96">96</a></p>
<p class="indexsub">package by, <a href="#part0049_page_313">313</a>–<a href="#part0049_page_315">315</a></p>
<p class="indexsub">partitioning processes into classes/separating classes into, <a href="#part0020_page_71">71</a>–<a href="#part0020_page_72">72</a></p>
<p class="indexsub">principles, <a href="#part0024_page_93">93</a></p>
<p class="indexsub">relocatability, <a href="#part0025_page_99">99</a>–<a href="#part0025_page_100">100</a></p>
<p class="indexsub">tests as system, <a href="#part0042_page_250">250</a></p>
<p class="indexmain" id="part0052_idx85">Computer Aided Software Engineering (CASE) tool, <a href="#part0051_page_368">368</a></p>
<p class="indexmain" id="part0052_idx86">Concrete components, Dependency Inversion Principle, <a href="#part0023_page_91">91</a></p>
<p class="indexmain" id="part0052_idx87">Concurrent tasks, BOSS archaeology project, <a href="#part0051_page_351">351</a>–<a href="#part0051_page_352">352</a></p>
<p class="indexmain" id="part0052_idx88">Concurrent updates, <a href="#part0017_page_52">52</a>–<a href="#part0017_page_53">53</a></p>
<p class="indexmain" id="part0052_idx89">Constantine, Larry, <a href="#part0015_page_29">29</a></p>
<p class="indexmain" id="part0052_idx90">Control, flow of. <em class="calibre9">See</em> <a href="#part0052_idx176">Flow of control</a></p>
<p class="indexmain" id="part0052_idx91">Control structures, program, <a href="#part0015_page_27">27</a>–<a href="#part0015_page_28">28</a></p>
<p class="indexmain" id="part0052_idx92">Control, transfer of, <a href="#part0014_page_22">22</a></p>
<p class="indexmain" id="part0052_idx93">Controllers</p>
<p class="indexsub">in clean architecture, <a href="#part0036_page_203">203</a>, <a href="#part0036_page_205">205</a></p>
<p class="indexsub">clean architecture scenario, <a href="#part0036_page_207">207</a>–<a href="#part0036_page_208">208</a></p>
<p class="indexsub">crossing circle boundaries, <a href="#part0036_page_206">206</a></p>
<p class="indexmain" id="part0052_idx94">Conway’s law, <a href="#part0030_page_149">149</a></p>
<p class="indexmain" id="part0052_idx95">Copper wires, pCCU archaeology project, <a href="#part0051_page_352">352</a>–<a href="#part0051_page_354">354</a></p>
<p class="indexmain" id="part0052_idx96">Core code, avoid frameworks in, <a href="#part0047_page_293">293</a></p>
<p class="indexmain" id="part0052_idx97">COs (central offices), <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_339">339</a>–<a href="#part0051_page_340">340</a></p>
<p class="indexmain" id="part0052_idx98">Coupling. <em class="calibre9">See also</em> <a href="#part0052_idx81">Component coupling</a></p>
<p class="indexsub">avoid allowing framework, <a href="#part0047_page_293">293</a></p>
<p class="indexsub">to premature decisions, <a href="#part0031_page_160">160</a></p>
<p class="indexmain" id="part0052_idx99">Craft Dispatch System. <em class="calibre9">See</em> <a href="#part0052_idx55">CDS (Craft Dispatch System), archaeology project</a></p>
<p class="indexmain" id="part0052_idx100">Critical Business Data, <a href="#part0034_page_190">190</a>–<a href="#part0034_page_191">191</a></p>
<p class="indexmain" id="part0052_idx101">Critical Business Rules, <a href="#part0034_page_190">190</a>–<a href="#part0034_page_193">193</a></p>
<p class="indexmain" id="part0052_idx102">Cross-cutting concerns</p>
<p class="indexsub">designing services to deal with, <a href="#part0041_page_247">247</a></p>
<p class="indexsub">object-oriented approach to, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexmain" id="part0052_idx103">Crossing data streams, <a href="#part0039_page_226">226</a></p>
<p class="indexmain" id="part0052_idx104">CRP (Common Reuse Principle)</p>
<p class="indexsub">influencing composition of components, <a href="#part0027_page_118">118</a></p>
<p class="indexsub">overview of, <a href="#part0026_page_107">107</a>–<a href="#part0026_page_108">108</a></p>
<p class="indexsub">tension diagram, <a href="#part0026_page_108">108</a>–<a href="#part0026_page_110">110</a></p>
<p class="indexmain" id="part0052_idx105">CRT (cathode ray tube) terminals, Union Accounting archaeology project, <a href="#part0051_page_328">328</a>–<a href="#part0051_page_329">329</a></p>
<p class="indexmain" id="part0052_idx106">Cycles</p>
<p class="indexsub">breaking, <a href="#part0027_page_117">117</a>–<a href="#part0027_page_118">118</a></p>
<p class="indexsub">effect of in dependency graph, <a href="#part0027_page_115">115</a>–<a href="#part0027_page_117">117</a></p>
<p class="indexsub">eliminating dependency, <a href="#part0027_page_113">113</a>–<a href="#part0027_page_115">115</a></p>
<p class="indexsub">weekly build issues, <a href="#part0027_page_112">112</a>–<a href="#part0027_page_113">113</a></p>
<p class="indexmain1"><strong class="calibre8">D</strong></p>
<p class="indexmain" id="part0052_idx107"><em class="calibre9">D</em> metric, distance from Main Sequence, <a href="#part0027_page_130">130</a>–<a href="#part0027_page_132">132</a></p>
<p class="indexmain" id="part0052_idx108">DAGs (directed acyclic graphs)</p>
<p class="indexsub">architectural framework for policy, <a href="#part0033_page_184">184</a></p>
<p class="indexsub">breaking cycle of components, <a href="#part0027_page_117">117</a>–<a href="#part0027_page_118">118</a></p>
<p class="indexsub">defined, <a href="#part0027_page_114">114</a></p>
<p class="indexmain" id="part0052_idx109">Dahl, Ole Johan, <a href="#part0014_page_22">22</a></p>
<p class="indexmain" id="part0052_idx110"><a id="part0052_page_382"></a>Data</p>
<p class="indexsub">clean architecture scenario, <a href="#part0036_page_207">207</a>–<a href="#part0036_page_208">208</a></p>
<p class="indexsub">Dependency Rule for crossing boundaries, <a href="#part0036_page_207">207</a></p>
<p class="indexsub">management concerns in architecture, <a href="#part0014_page_24">24</a></p>
<p class="indexsub">mappers, <a href="#part0037_page_214">214</a>–<a href="#part0037_page_215">215</a></p>
<p class="indexsub">separating from functions, <a href="#part0019_page_66">66</a></p>
<p class="indexmain" id="part0052_idx111">Data model, database vs., <a href="#part0045_page_278">278</a></p>
<p class="indexmain" id="part0052_idx112">Data storage</p>
<p class="indexsub">in Laser Trim archaeology project, <a href="#part0051_page_335">335</a></p>
<p class="indexsub">prevalence of database systems due to disks, <a href="#part0045_page_279">279</a>–<a href="#part0045_page_280">280</a></p>
<p class="indexsub">in Union Accounting archaeology project, <a href="#part0051_page_327">327</a>–<a href="#part0051_page_328">328</a></p>
<p class="indexmain" id="part0052_idx113">Database</p>
<p class="indexsub">clean architecture independent from, <a href="#part0036_page_202">202</a></p>
<p class="indexsub">clean architecture scenario, <a href="#part0036_page_207">207</a>–<a href="#part0036_page_208">208</a></p>
<p class="indexsub">creating testable architecture without, <a href="#part0035_page_198">198</a></p>
<p class="indexsub">decoupling layers, <a href="#part0030_page_153">153</a></p>
<p class="indexsub">decoupling use cases, <a href="#part0030_page_153">153</a></p>
<p class="indexsub">Dependency Rule, <a href="#part0036_page_205">205</a></p>
<p class="indexsub">drawing boundary line between business rules and, <a href="#part0031_page_165">165</a></p>
<p class="indexsub">gateways, <a href="#part0037_page_214">214</a></p>
<p class="indexsub">in Hunt the Wumpus adventure game, <a href="#part0039_page_222">222</a>–<a href="#part0039_page_223">223</a></p>
<p class="indexsub">independent developability, <a href="#part0016_page_47">47</a></p>
<p class="indexsub">leaving options open in development, <a href="#part0029_page_141">141</a>, <a href="#part0035_page_197">197</a></p>
<p class="indexsub">plugin architecture, <a href="#part0031_page_171">171</a></p>
<p class="indexsub">relational, <a href="#part0045_page_278">278</a></p>
<p class="indexsub">schema in Zone of Pain, <a href="#part0027_page_129">129</a></p>
<p class="indexsub">separating components with boundary lines, <a href="#part0031_page_165">165</a>–<a href="#part0031_page_169">169</a></p>
<p class="indexmain" id="part0052_idx114">Database is detail</p>
<p class="indexsub">anecdote, <a href="#part0045_page_281">281</a>–<a href="#part0045_page_283">283</a></p>
<p class="indexsub">conclusion, <a href="#part0045_page_283">283</a></p>
<p class="indexsub">details, <a href="#part0045_page_281">281</a></p>
<p class="indexsub">if there were no disks, <a href="#part0045_page_280">280</a>–<a href="#part0045_page_281">281</a></p>
<p class="indexsub">overview of, <a href="#part0045_page_277">277</a>–<a href="#part0045_page_278">278</a></p>
<p class="indexsub">performance, <a href="#part0045_page_281">281</a></p>
<p class="indexsub">relational databases, <a href="#part0045_page_278">278</a></p>
<p class="indexsub">why database systems are so prevalent, <a href="#part0045_page_279">279</a>–<a href="#part0045_page_280">280</a></p>
<p class="indexmain" id="part0052_idx115">DCI system architecture, <a href="#part0036_page_202">202</a></p>
<p class="indexmain" id="part0052_idx116">Deadlocks, from mutable variables, <a href="#part0017_page_52">52</a></p>
<p class="indexmain" id="part0052_idx117">Decoupling</p>
<p class="indexsub">as fallacy of services, <a href="#part0041_page_240">240</a>–<a href="#part0041_page_241">241</a></p>
<p class="indexsub">independent deployment, <a href="#part0030_page_154">154</a>, <a href="#part0041_page_241">241</a></p>
<p class="indexsub">independent development, <a href="#part0030_page_153">153</a>–<a href="#part0030_page_154">154</a>, <a href="#part0041_page_241">241</a></p>
<p class="indexsub">kitty problem example, <a href="#part0041_page_242">242</a>–<a href="#part0041_page_243">243</a></p>
<p class="indexsub">layers, <a href="#part0030_page_151">151</a>–<a href="#part0030_page_152">152</a></p>
<p class="indexsub">modes, <a href="#part0030_page_153">153</a>, <a href="#part0030_page_155">155</a>–<a href="#part0030_page_158">158</a></p>
<p class="indexsub">OO approach for cross-cutting concerns, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexsub">purpose of testing API, <a href="#part0042_page_252">252</a>–<a href="#part0042_page_253">253</a></p>
<p class="indexsub">source code dependencies, <a href="#part0049_page_319">319</a></p>
<p class="indexsub">use cases, <a href="#part0030_page_152">152</a></p>
<p class="indexmain" id="part0052_idx118">DeMarco, Tom, <a href="#part0015_page_29">29</a></p>
<p class="indexmain" id="part0052_idx119">Dependencies</p>
<p class="indexsub">ADP. <em class="calibre9">See</em> <a href="#part0052_idx13">ADP (Acyclic Dependencies Principle)</a></p>
<p class="indexsub">architectural framework for policy, <a href="#part0033_page_184">184</a></p>
<p class="indexsub">calculating stability metrics, <a href="#part0027_page_123">123</a></p>
<p class="indexsub">case study. <em class="calibre9">See</em> <a href="#part0052_idx434">Video sales case study</a></p>
<p class="indexsub">Common Reuse Principle and, <a href="#part0026_page_107">107</a>–<a href="#part0026_page_108">108</a></p>
<p class="indexsub">DIP. <em class="calibre9">See</em> <a href="#part0052_idx135">DIP (Dependency Inversion Principle)</a></p>
<p class="indexsub"><a id="part0052_page_383"></a>in Laser Trim archaeology project, <a href="#part0051_page_338">338</a></p>
<p class="indexsub">managing undesirable, <a href="#part0023_page_89">89</a>–<a href="#part0023_page_90">90</a></p>
<p class="indexsub">OCP example, <a href="#part0020_page_72">72</a></p>
<p class="indexsub">in package by layer, <a href="#part0049_page_304">304</a>–<a href="#part0049_page_306">306</a>, <a href="#part0049_page_310">310</a>–<a href="#part0049_page_311">311</a></p>
<p class="indexsub">software destroyed by unmanaged, <a href="#part0043_page_256">256</a></p>
<p class="indexsub">stable. <em class="calibre9">See</em> <a href="#part0052_idx359">SDP (Stable Dependencies Principle)</a></p>
<p class="indexsub">transitive, <a href="#part0020_page_75">75</a></p>
<p class="indexsub">understanding component, <a href="#part0027_page_121">121</a></p>
<p class="indexsub">in Union Accounting archaeology project, <a href="#part0051_page_333">333</a>–<a href="#part0051_page_334">334</a></p>
<p class="indexmain" id="part0052_idx120">Dependency graph, <a href="#part0027_page_115">115</a>–<a href="#part0027_page_118">118</a></p>
<p class="indexmain" id="part0052_idx121">Dependency Injection framework, Main component, <a href="#part0040_page_232">232</a></p>
<p class="indexmain" id="part0052_idx122">Dependency inversion, <a href="#part0016_page_44">44</a>–<a href="#part0016_page_47">47</a></p>
<p class="indexmain" id="part0052_idx123">Dependency management</p>
<p class="indexsub">metrics. <em class="calibre9">See</em> <a href="#part0052_idx13">ADP (Acyclic Dependencies Principle)</a></p>
<p class="indexsub">via full-fledged architectural boundaries, <a href="#part0038_page_218">218</a></p>
<p class="indexsub">via polymorphism in monolithic systems, <a href="#part0032_page_177">177</a></p>
<p class="indexsub">video sales case study, <a href="#part0048_page_302">302</a></p>
<p class="indexmain" id="part0052_idx124">Dependency Rule</p>
<p class="indexsub">clean architecture and, <a href="#part0036_page_203">203</a>–<a href="#part0036_page_206">206</a></p>
<p class="indexsub">clean architecture scenario, <a href="#part0036_page_207">207</a>–<a href="#part0036_page_208">208</a></p>
<p class="indexsub">crossing boundaries, <a href="#part0036_page_206">206</a></p>
<p class="indexsub">defined, <a href="#part0023_page_91">91</a></p>
<p class="indexsub">dependency management, <a href="#part0048_page_302">302</a></p>
<p class="indexsub">designing services to follow, <a href="#part0041_page_247">247</a></p>
<p class="indexsub">Entities, <a href="#part0036_page_204">204</a></p>
<p class="indexsub">frameworks and drivers, <a href="#part0036_page_205">205</a></p>
<p class="indexsub">frameworks tending to violate, <a href="#part0047_page_293">293</a></p>
<p class="indexsub">in Hunt the Wumpus adventure game, <a href="#part0039_page_223">223</a></p>
<p class="indexsub">interface adapters, <a href="#part0036_page_205">205</a></p>
<p class="indexsub">OO approach for cross-cutting concerns, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexsub">services may follow, <a href="#part0041_page_240">240</a></p>
<p class="indexsub">tests following, <a href="#part0042_page_250">250</a></p>
<p class="indexsub">use cases, <a href="#part0036_page_204">204</a></p>
<p class="indexsub">which data crosses boundaries, <a href="#part0036_page_207">207</a></p>
<p class="indexmain" id="part0052_idx125">Deployment</p>
<p class="indexsub">architecture determines ease of, <a href="#part0030_page_150">150</a></p>
<p class="indexsub">components, <a href="#part0032_page_178">178</a>–<a href="#part0032_page_180">180</a></p>
<p class="indexsub">components as units of, <a href="#part0025_page_96">96</a></p>
<p class="indexsub">impact of architecture on, <a href="#part0029_page_138">138</a></p>
<p class="indexsub">tests use independent, <a href="#part0042_page_250">250</a></p>
<p class="indexmain" id="part0052_idx126">Deployment-level decoupling mode, <a href="#part0030_page_156">156</a>–<a href="#part0030_page_157">157</a>, <a href="#part0032_page_178">178</a>–<a href="#part0032_page_179">179</a></p>
<p class="indexmain" id="part0052_idx127">Design</p>
<p class="indexsub">approaches to. <em class="calibre9">See</em> <a href="#part0052_idx69">Code organization</a></p>
<p class="indexsub">architecture vs., <a href="#part0011_page_4">4</a></p>
<p class="indexsub">decreasing productivity/increases cost of code, <a href="#part0011_page_5">5</a>–<a href="#part0011_page_7">7</a></p>
<p class="indexsub">getting it right, <a href="#part0010_page_2">2</a></p>
<p class="indexsub">goal of good, <a href="#part0011_page_4">4</a>–<a href="#part0011_page_5">5</a></p>
<p class="indexsub">reducing volatility of interfaces, <a href="#part0023_page_88">88</a></p>
<p class="indexsub">signature of a mess, <a href="#part0011_page_7">7</a>–<a href="#part0011_page_8">8</a></p>
<p class="indexsub">SOLID principles of, <a href="#part0018_page_57">57</a>–<a href="#part0018_page_59">59</a></p>
<p class="indexsub">for testability, <a href="#part0042_page_251">251</a></p>
<p class="indexmain" id="part0052_idx128"><em class="calibre9">Designing Object-Oriented C++ Applications Using the Booch Method</em>, <a href="#part0051_page_369">369</a></p>
<p class="indexmain" id="part0052_idx129">Detail</p>
<p class="indexsub">database is. <em class="calibre9">See</em> <a href="#part0052_idx114">Database is detail</a></p>
<p class="indexsub">don’t reveal hardware, to user of HAL, <a href="#part0043_page_265">265</a>–<a href="#part0043_page_269">269</a></p>
<p class="indexsub">framework is, <a href="#part0047_page_291">291</a>–<a href="#part0047_page_295">295</a></p>
<p class="indexsub">hardware is, <a href="#part0043_page_263">263</a>–<a href="#part0043_page_264">264</a></p>
<p class="indexsub"><a id="part0052_page_384"></a>separating from policy, <a href="#part0029_page_140">140</a>–<a href="#part0029_page_142">142</a></p>
<p class="indexsub">story of architectural success, <a href="#part0031_page_163">163</a>–<a href="#part0031_page_165">165</a></p>
<p class="indexsub">web is, <a href="#part0046_page_285">285</a>–<a href="#part0046_page_289">289</a></p>
<p class="indexmain" id="part0052_idx130">Developers</p>
<p class="indexsub">decreasing productivity/increasing cost of code, <a href="#part0011_page_5">5</a>–<a href="#part0011_page_7">7</a></p>
<p class="indexsub">Eisenhower’s matrix of importance vs. urgency, <a href="#part0012_page_17">17</a></p>
<p class="indexsub">foolishness of overconfidence, <a href="#part0011_page_9">9</a>–<a href="#part0011_page_12">12</a></p>
<p class="indexsub">preference for function vs. architecture, <a href="#part0012_page_15">15</a>–<a href="#part0012_page_16">16</a></p>
<p class="indexsub">scope vs. shape in determining cost of change, <a href="#part0012_page_15">15</a></p>
<p class="indexsub">signature of a mess, <a href="#part0011_page_8">8</a>–<a href="#part0011_page_9">9</a></p>
<p class="indexsub">as stakeholders, <a href="#part0012_page_18">18</a></p>
<p class="indexmain" id="part0052_idx131">Development</p>
<p class="indexsub">impact of architecture on, <a href="#part0029_page_137">137</a>–<a href="#part0029_page_138">138</a></p>
<p class="indexsub">independent. <em class="calibre9">See</em> <a href="#part0052_idx208">Independent developability</a></p>
<p class="indexsub">role of architecture in supporting, <a href="#part0030_page_149">149</a>–<a href="#part0030_page_150">150</a></p>
<p class="indexsub">role of test to support, <a href="#part0042_page_250">250</a></p>
<p class="indexmain" id="part0052_idx132">Device independence</p>
<p class="indexsub">defined, <a href="#part0029_page_142">142</a>–<a href="#part0029_page_143">143</a></p>
<p class="indexsub">IO device of UI as, <a href="#part0046_page_288">288</a>–<a href="#part0046_page_289">289</a></p>
<p class="indexsub">junk mail example, <a href="#part0029_page_144">144</a>–<a href="#part0029_page_145">145</a></p>
<p class="indexsub">physical addressing example, <a href="#part0029_page_145">145</a>–<a href="#part0029_page_146">146</a></p>
<p class="indexsub">in programming, <a href="#part0016_page_44">44</a></p>
<p class="indexmain" id="part0052_idx133">Digital revolution, and telephone companies, <a href="#part0051_page_352">352</a>–<a href="#part0051_page_354">354</a></p>
<p class="indexmain" id="part0052_idx134">Dijkstra, Edsger Wybe</p>
<p class="indexsub">applying discipline of proof to programming, <a href="#part0015_page_27">27</a></p>
<p class="indexsub">discovery of structured programming, <a href="#part0014_page_22">22</a></p>
<p class="indexsub">history of, <a href="#part0015_page_26">26</a></p>
<p class="indexsub">proclamation on goto statements, <a href="#part0015_page_28">28</a>–<a href="#part0015_page_29">29</a></p>
<p class="indexsub">on testing, <a href="#part0015_page_31">31</a></p>
<p class="indexmain" id="part0052_idx135">DIP (Dependency Inversion Principle)</p>
<p class="indexsub">breaking cycle of components, <a href="#part0027_page_117">117</a>–<a href="#part0027_page_118">118</a></p>
<p class="indexsub">conclusion, <a href="#part0023_page_91">91</a></p>
<p class="indexsub">concrete components, <a href="#part0023_page_91">91</a></p>
<p class="indexsub">crossing circle boundaries, <a href="#part0036_page_206">206</a></p>
<p class="indexsub">defined, <a href="#part0018_page_59">59</a></p>
<p class="indexsub">drawing boundary lines, <a href="#part0031_page_173">173</a></p>
<p class="indexsub">Entities without knowledge of use cases as, <a href="#part0034_page_193">193</a></p>
<p class="indexsub">factories, <a href="#part0023_page_89">89</a>–<a href="#part0023_page_90">90</a></p>
<p class="indexsub">in good software architecture, <a href="#part0020_page_71">71</a></p>
<p class="indexsub">not all components should be stable, <a href="#part0027_page_125">125</a></p>
<p class="indexsub">overview of, <a href="#part0023_page_87">87</a>–<a href="#part0023_page_88">88</a></p>
<p class="indexsub">stable abstractions, <a href="#part0023_page_88">88</a>–<a href="#part0023_page_89">89</a></p>
<p class="indexsub">Stable Abstractions Principle, <a href="#part0027_page_127">127</a></p>
<p class="indexmain" id="part0052_idx136">Directed acyclic graph. <em class="calibre9">See</em> <a href="#part0052_idx108">DAGs (directed acyclic graphs)</a></p>
<p class="indexmain" id="part0052_idx137">Directional control, Open-Closed Principle, <a href="#part0020_page_74">74</a></p>
<p class="indexmain" id="part0052_idx138">Disks</p>
<p class="indexsub">if there were no, <a href="#part0045_page_280">280</a>–<a href="#part0045_page_281">281</a></p>
<p class="indexsub">prevalence of database systems due to, <a href="#part0045_page_279">279</a>–<a href="#part0045_page_280">280</a></p>
<p class="indexsub">in Union Accounting archaeology project, <a href="#part0051_page_326">326</a>–<a href="#part0051_page_330">330</a></p>
<p class="indexmain" id="part0052_idx139">Dispatch code, service area computer project, <a href="#part0051_page_345">345</a></p>
<p class="indexmain" id="part0052_idx140">Display local unit/display remote unit (DLU/DRU) archaeology project, <a href="#part0051_page_354">354</a>–<a href="#part0051_page_356">356</a></p>
<p class="indexmain" id="part0052_idx141">DLU/DRU (display local unit/display remote unit), archaeology project, <a href="#part0051_page_354">354</a>–<a href="#part0051_page_356">356</a></p>
<p class="indexmain" id="part0052_idx142"><a id="part0052_page_385"></a>Do/while/until statements, <a href="#part0014_page_22">22</a>, <a href="#part0015_page_27">27</a></p>
<p class="indexmain" id="part0052_idx143">Don’t Repeat Yourself (DRY) principle, conditional compilation directives, <a href="#part0043_page_272">272</a></p>
<p class="indexmain" id="part0052_idx144">Drawing lines. <em class="calibre9">See</em> <a href="#part0052_idx37">Boundaries</a></p>
<p class="indexmain" id="part0052_idx145">Drivers, Dependency Rule, <a href="#part0036_page_205">205</a></p>
<p class="indexmain" id="part0052_idx146">DRY (Don’t Repeat Yourself) principle, conditional compilation directives, <a href="#part0043_page_272">272</a></p>
<p class="indexmain" id="part0052_idx147">DSL (domain-specific data-driven language), Laser Trim archaeology project, <a href="#part0051_page_337">337</a></p>
<p class="indexmain" id="part0052_idx148">Duplication</p>
<p class="indexsub">accidental, <a href="#part0019_page_63">63</a>–<a href="#part0019_page_65">65</a></p>
<p class="indexsub">true vs. accidental, <a href="#part0030_page_154">154</a>–<a href="#part0030_page_155">155</a></p>
<p class="indexmain" id="part0052_idx149">Dynamic polymorphism, <a href="#part0032_page_177">177</a>–<a href="#part0032_page_178">178</a>, <a href="#part0036_page_206">206</a></p>
<p class="indexmain" id="part0052_idx150">Dynamically linked libraries, as architectural boundaries, <a href="#part0032_page_178">178</a>–<a href="#part0032_page_179">179</a></p>
<p class="indexmain" id="part0052_idx151">Dynamically typed languages</p>
<p class="indexsub">DIP and, <a href="#part0023_page_88">88</a></p>
<p class="indexsub">ISP and, <a href="#part0022_page_85">85</a></p>
<p class="indexmain1"><strong class="calibre8">E</strong></p>
<p class="indexmain" id="part0052_idx152">Editing, Laser Trim archaeology project, <a href="#part0051_page_336">336</a></p>
<p class="indexmain" id="part0052_idx153">Educational Testing Service (ETS), <a href="#part0051_page_370">370</a>–<a href="#part0051_page_372">372</a></p>
<p class="indexmain" id="part0052_idx154">Eisenhower, matrix of importance vs. urgency, <a href="#part0012_page_16">16</a>–<a href="#part0012_page_17">17</a></p>
<p class="indexmain" id="part0052_idx155">Embedded architecture. <em class="calibre9">See</em> <a href="#part0052_idx63">Clean embedded architecture</a></p>
<p class="indexmain" id="part0052_idx156">Encapsulation</p>
<p class="indexsub">in defining OOP, <a href="#part0016_page_35">35</a>–<a href="#part0016_page_37">37</a></p>
<p class="indexsub">organization vs., <a href="#part0049_page_316">316</a>–<a href="#part0049_page_319">319</a></p>
<p class="indexsub">overuse of public and, <a href="#part0049_page_316">316</a></p>
<p class="indexmain" id="part0052_idx157">Entities</p>
<p class="indexsub">business rules and, <a href="#part0034_page_190">190</a>–<a href="#part0034_page_191">191</a></p>
<p class="indexsub">clean architecture scenario, <a href="#part0036_page_207">207</a>–<a href="#part0036_page_208">208</a></p>
<p class="indexsub">creating testable architecture, <a href="#part0035_page_198">198</a></p>
<p class="indexsub">Dependency Rule for, <a href="#part0036_page_204">204</a></p>
<p class="indexsub">risks of frameworks, <a href="#part0047_page_293">293</a></p>
<p class="indexsub">use cases vs., <a href="#part0034_page_191">191</a>–<a href="#part0034_page_193">193</a></p>
<p class="indexmain" id="part0052_idx158">Enumeration, Dijkstra’s proof for sequence/selection, <a href="#part0015_page_28">28</a></p>
<p class="indexmain" id="part0052_idx159">EPROM (Erasable Programmable Read-Only Memory) chips, <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_341">341</a>–<a href="#part0051_page_343">343</a></p>
<p class="indexmain" id="part0052_idx160">ER (Electronic Receptionist)</p>
<p class="indexsub">archaeology project, <a href="#part0051_page_359">359</a>–<a href="#part0051_page_361">361</a></p>
<p class="indexsub">Craft Dispatch System was, <a href="#part0051_page_362">362</a>–<a href="#part0051_page_364">364</a></p>
<p class="indexmain" id="part0052_idx161">ETS (Educational Testing Service), <a href="#part0051_page_370">370</a>–<a href="#part0051_page_372">372</a></p>
<p class="indexmain" id="part0052_idx162">Europe, redesigning SAC for US and, <a href="#part0051_page_347">347</a>–<a href="#part0051_page_348">348</a></p>
<p class="indexmain" id="part0052_idx163">Event sourcing, storing transactions, <a href="#part0017_page_54">54</a>–<a href="#part0017_page_55">55</a></p>
<p class="indexmain" id="part0052_idx164">Executables</p>
<p class="indexsub">deployment of monoliths, <a href="#part0032_page_176">176</a>–<a href="#part0032_page_178">178</a></p>
<p class="indexsub">linking components as, <a href="#part0025_page_96">96</a></p>
<p class="indexmain" id="part0052_idx165">External agency, clean architecture independence from, <a href="#part0036_page_202">202</a></p>
<p class="indexmain" id="part0052_idx166">External definition, compilers, <a href="#part0025_page_100">100</a></p>
<p class="indexmain" id="part0052_idx167">External reference, compilers, <a href="#part0025_page_100">100</a></p>
<p class="indexmain1"><strong class="calibre8">F</strong></p>
<p class="indexmain" id="part0052_idx168">Facade pattern, partial boundaries, <a href="#part0038_page_220">220</a></p>
<p class="indexmain" id="part0052_idx169">Fan-in/fan-out metrics, component stability, <a href="#part0027_page_122">122</a>–<a href="#part0027_page_123">123</a></p>
<p class="indexmain" id="part0052_idx170">Feathers, Michael, <a href="#part0018_page_58">58</a></p>
<p class="indexmain" id="part0052_idx171">File systems, mitigating time delay, <a href="#part0045_page_279">279</a>–<a href="#part0045_page_280">280</a></p>
<p class="indexmain" id="part0052_idx172">Firewalls, boundary crossings via, <a href="#part0032_page_176">176</a></p>
<p class="indexmain" id="part0052_idx173">Firmware</p>
<p class="indexsub">in <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_343">343</a>–<a href="#part0051_page_344">344</a></p>
<p class="indexsub">definitions of, <a href="#part0043_page_256">256</a>–<a href="#part0043_page_257">257</a></p>
<p class="indexsub"><a id="part0052_page_386"></a>eliminating target-hardware bottleneck, <a href="#part0043_page_262">262</a>–<a href="#part0043_page_263">263</a></p>
<p class="indexsub">fuzzy line between software and, <a href="#part0043_page_263">263</a>–<a href="#part0043_page_264">264</a></p>
<p class="indexsub">obsolete as hardware evolves, <a href="#part0043_page_256">256</a></p>
<p class="indexsub">stop writing so much, <a href="#part0043_page_257">257</a>–<a href="#part0043_page_258">258</a></p>
<p class="indexmain" id="part0052_idx174">FitNesse program</p>
<p class="indexsub">overview of, <a href="#part0031_page_163">163</a>–<a href="#part0031_page_165">165</a></p>
<p class="indexsub">partial boundary, <a href="#part0038_page_218">218</a>–<a href="#part0038_page_219">219</a></p>
<p class="indexmain" id="part0052_idx175">FLD (Field Labeled Data), Craft Dispatch System archaeology project, <a href="#part0051_page_363">363</a></p>
<p class="indexmain" id="part0052_idx176">Flow of control</p>
<p class="indexsub">crossing circle boundaries, <a href="#part0036_page_206">206</a></p>
<p class="indexsub">dependency management, case study, <a href="#part0048_page_302">302</a></p>
<p class="indexsub">dynamic polymorphism, <a href="#part0032_page_177">177</a>–<a href="#part0032_page_178">178</a></p>
<p class="indexsub">in Union Accounting archaeology project, <a href="#part0051_page_334">334</a></p>
<p class="indexmain" id="part0052_idx177">Fowler, Martin, <a href="#part0049_page_305">305</a>–<a href="#part0049_page_306">306</a></p>
<p class="indexmain" id="part0052_idx178">Fragile Tests Problem, <a href="#part0042_page_251">251</a></p>
<p class="indexmain" id="part0052_idx179">Frameworks</p>
<p class="indexsub">avoid basing architecture on, <a href="#part0035_page_197">197</a></p>
<p class="indexsub">clean architecture independent from, <a href="#part0036_page_202">202</a></p>
<p class="indexsub">creating testable architecture without, <a href="#part0035_page_198">198</a></p>
<p class="indexsub">Dependency Rule for, <a href="#part0036_page_205">205</a></p>
<p class="indexsub">as option to be left open, <a href="#part0035_page_197">197</a></p>
<p class="indexsub">as tools, not a way of life, <a href="#part0035_page_198">198</a></p>
<p class="indexmain" id="part0052_idx180">Frameworks are details</p>
<p class="indexsub">asymmetric marriage and, <a href="#part0047_page_292">292</a>–<a href="#part0047_page_293">293</a></p>
<p class="indexsub">conclusion, <a href="#part0047_page_295">295</a></p>
<p class="indexsub">framework authors, <a href="#part0047_page_292">292</a></p>
<p class="indexsub">frameworks you must simply marry, <a href="#part0047_page_295">295</a></p>
<p class="indexsub">popularity of, <a href="#part0047_page_292">292</a></p>
<p class="indexsub">risks, <a href="#part0047_page_293">293</a>–<a href="#part0047_page_294">294</a></p>
<p class="indexsub">solution, <a href="#part0047_page_294">294</a></p>
<p class="indexmain" id="part0052_idx181">Function calls, services as, <a href="#part0041_page_240">240</a></p>
<p class="indexmain" id="part0052_idx182">Functional decomposition</p>
<p class="indexsub">programming best practice, <a href="#part0015_page_32">32</a></p>
<p class="indexsub">in structured programming, <a href="#part0015_page_29">29</a></p>
<p class="indexmain" id="part0052_idx183">Functional pointers, OOP, <a href="#part0014_page_22">22</a>, <a href="#part0014_page_23">23</a></p>
<p class="indexmain" id="part0052_idx184">Functional programming</p>
<p class="indexsub">conclusion, <a href="#part0017_page_56">56</a></p>
<p class="indexsub">event sourcing, <a href="#part0017_page_54">54</a>–<a href="#part0017_page_55">55</a></p>
<p class="indexsub">history of, <a href="#part0014_page_22">22</a>–<a href="#part0014_page_23">23</a></p>
<p class="indexsub">immutability, <a href="#part0017_page_52">52</a></p>
<p class="indexsub">overview of, <a href="#part0017_page_50">50</a></p>
<p class="indexsub">segregation of mutability, <a href="#part0017_page_52">52</a>–<a href="#part0017_page_54">54</a></p>
<p class="indexsub">squares of integers example, <a href="#part0017_page_50">50</a>–<a href="#part0017_page_51">51</a></p>
<p class="indexmain" id="part0052_idx185">Functions</p>
<p class="indexsub">avoid overriding concrete, <a href="#part0023_page_89">89</a></p>
<p class="indexsub">breaking down into parts (functional decomposition), <a href="#part0015_page_29">29</a></p>
<p class="indexsub">one of three big concerns in architecture, <a href="#part0014_page_24">24</a></p>
<p class="indexsub">principle of doing one thing, <a href="#part0019_page_62">62</a></p>
<p class="indexsub">separating from data, <a href="#part0019_page_66">66</a></p>
<p class="indexsub">SRP examples, <a href="#part0019_page_67">67</a></p>
<p class="indexmain1"><strong class="calibre8">G</strong></p>
<p class="indexmain" id="part0052_idx186">Gateways, database, <a href="#part0037_page_214">214</a></p>
<p class="indexmain" id="part0052_idx187">GE Datanet <a href="#part0015_page_30">30</a> computer, Union Accounting archaeology project, <a href="#part0051_page_326">326</a>–<a href="#part0051_page_330">330</a></p>
<p class="indexmain" id="part0052_idx188">Goto statements</p>
<p class="indexsub">Dijkstra replaces with iteration control structures, <a href="#part0015_page_27">27</a></p>
<p class="indexsub">Dijkstra’s proclamation on harmfulness of, <a href="#part0015_page_28">28</a>–<a href="#part0015_page_29">29</a></p>
<p class="indexsub">history of structured programming, <a href="#part0014_page_22">22</a></p>
<p class="indexsub">removed in structured programming, <a href="#part0014_page_23">23</a></p>
<p class="indexmain" id="part0052_idx189"><em class="calibre9">Growing Object Oriented Software with Tests</em> (Freeman &amp; Pryce), <a href="#part0036_page_202">202</a></p>
<p class="indexmain" id="part0052_idx190"><a id="part0052_page_387"></a>GUI (graphical user interface). <em class="calibre9">See also</em> <a href="#part0052_idx418">UI (user interface)</a></p>
<p class="indexsub">decoupling business rules from, <a href="#part0046_page_287">287</a>–<a href="#part0046_page_289">289</a></p>
<p class="indexsub">designing for testability, <a href="#part0042_page_251">251</a></p>
<p class="indexsub">developing architects registry exam, <a href="#part0051_page_371">371</a>–<a href="#part0051_page_372">372</a></p>
<p class="indexsub">input/output and boundary lines, <a href="#part0031_page_169">169</a>–<a href="#part0031_page_170">170</a></p>
<p class="indexsub">plugin architecture, <a href="#part0031_page_170">170</a>–<a href="#part0031_page_171">171</a></p>
<p class="indexsub">plugin argument, <a href="#part0031_page_172">172</a>–<a href="#part0031_page_173">173</a></p>
<p class="indexsub">separating from business rules with boundaries, <a href="#part0031_page_165">165</a>–<a href="#part0031_page_169">169</a></p>
<p class="indexsub">unit testing, <a href="#part0037_page_212">212</a></p>
<p class="indexsub">web is, <a href="#part0046_page_288">288</a></p>
<p class="indexmain1"><strong class="calibre8">H</strong></p>
<p class="indexmain" id="part0052_idx191">HAL (hardware abstraction layer)</p>
<p class="indexsub">avoid revealing hardware details to user of, <a href="#part0043_page_265">265</a>–<a href="#part0043_page_269">269</a></p>
<p class="indexsub">as boundary line between software/firmware, <a href="#part0043_page_264">264</a></p>
<p class="indexsub">DRY conditional compilation directives, <a href="#part0043_page_272">272</a></p>
<p class="indexsub">operating system is detail and, <a href="#part0043_page_269">269</a>–<a href="#part0043_page_271">271</a></p>
<p class="indexmain" id="part0052_idx192">Hardware</p>
<p class="indexsub">eliminating target-hardware bottleneck with layers, <a href="#part0043_page_262">262</a>–<a href="#part0043_page_263">263</a></p>
<p class="indexsub">firmware becomes obsolete through evolution of, <a href="#part0043_page_256">256</a></p>
<p class="indexsub">in SAC archaeology project, <a href="#part0051_page_346">346</a>–<a href="#part0051_page_347">347</a></p>
<p class="indexmain" id="part0052_idx193">Header files, programming to interfaces with, <a href="#part0043_page_272">272</a></p>
<p class="indexmain" id="part0052_idx194">Hexagonal Architecture (Ports and Adapters), <a href="#part0036_page_202">202</a></p>
<p class="indexmain" id="part0052_idx195">High-level policy</p>
<p class="indexsub">decoupling from lower level input/output policies, <a href="#part0033_page_185">185</a>–<a href="#part0033_page_186">186</a></p>
<p class="indexsub">separating details from, <a href="#part0029_page_140">140</a>–<a href="#part0029_page_142">142</a></p>
<p class="indexsub">splitting data streams, <a href="#part0039_page_227">227</a>–<a href="#part0039_page_228">228</a></p>
<p class="indexsub">where to place, <a href="#part0027_page_126">126</a></p>
<p class="indexmain" id="part0052_idx196">Human resources, goal of architect to minimize, <a href="#part0031_page_160">160</a></p>
<p class="indexmain" id="part0052_idx197">Humble Object pattern</p>
<p class="indexsub">data mappers, <a href="#part0037_page_214">214</a>–<a href="#part0037_page_215">215</a></p>
<p class="indexsub">database getaways, <a href="#part0037_page_214">214</a></p>
<p class="indexsub">Presenters and Views, <a href="#part0037_page_212">212</a>–<a href="#part0037_page_213">213</a></p>
<p class="indexsub">Presenters as form of, <a href="#part0037_page_212">212</a></p>
<p class="indexsub">testing and architecture, <a href="#part0037_page_213">213</a></p>
<p class="indexsub">understanding, <a href="#part0037_page_212">212</a></p>
<p class="indexmain" id="part0052_idx198">Hunt the Wumpus game</p>
<p class="indexsub">layers and boundaries. <em class="calibre9">See</em> <a href="#part0052_idx231">Layers and boundaries</a></p>
<p class="indexsub">Main component from, <a href="#part0040_page_232">232</a>–<a href="#part0040_page_237">237</a></p>
<p class="indexmain1"><strong class="calibre8">I</strong></p>
<p class="indexmain" id="part0052_idx199">IBM System/7, aluminum die-cast archaeology project, <a href="#part0051_page_338">338</a>–<a href="#part0051_page_339">339</a></p>
<p class="indexmain" id="part0052_idx200">If/then/else statements, <a href="#part0014_page_22">22</a>, <a href="#part0015_page_27">27</a></p>
<p class="indexmain" id="part0052_idx201">Immutability, <a href="#part0017_page_52">52</a>–<a href="#part0017_page_54">54</a></p>
<p class="indexmain" id="part0052_idx202">Implementation strategy. <em class="calibre9">See</em> <a href="#part0052_idx69">Code organization</a></p>
<p class="indexmain" id="part0052_idx203">Importance, urgency vs. Eisenhower’s matrix of, <a href="#part0012_page_16">16</a>–<a href="#part0012_page_17">17</a></p>
<p class="indexmain" id="part0052_idx204">Incoming dependencies, stability metrics, <a href="#part0027_page_122">122</a>–<a href="#part0027_page_123">123</a></p>
<p class="indexmain" id="part0052_idx205">Independence</p>
<p class="indexsub">conclusion, <a href="#part0030_page_158">158</a></p>
<p class="indexsub">decoupling layers, <a href="#part0030_page_151">151</a>–<a href="#part0030_page_152">152</a></p>
<p class="indexsub">decoupling mode, <a href="#part0030_page_153">153</a></p>
<p class="indexsub">decoupling use cases, <a href="#part0030_page_152">152</a></p>
<p class="indexsub">deployment, <a href="#part0030_page_150">150</a></p>
<p class="indexsub">development, <a href="#part0030_page_149">149</a>–<a href="#part0030_page_150">150</a></p>
<p class="indexsub">duplication, <a href="#part0030_page_154">154</a>–<a href="#part0030_page_155">155</a></p>
<p class="indexsub">independent deployability, <a href="#part0030_page_154">154</a></p>
<p class="indexsub">independent developability, <a href="#part0030_page_153">153</a>–<a href="#part0030_page_154">154</a></p>
<p class="indexsub"><a id="part0052_page_388"></a>leaving options open, <a href="#part0030_page_150">150</a>–<a href="#part0030_page_151">151</a></p>
<p class="indexsub">operation, <a href="#part0030_page_149">149</a></p>
<p class="indexsub">overview of, <a href="#part0030_page_147">147</a>–<a href="#part0030_page_148">148</a></p>
<p class="indexsub">types of decoupling modes, <a href="#part0030_page_155">155</a>–<a href="#part0030_page_158">158</a></p>
<p class="indexsub">use cases, <a href="#part0030_page_148">148</a></p>
<p class="indexmain" id="part0052_idx206">Independent components</p>
<p class="indexsub">calculating stability metrics, <a href="#part0027_page_123">123</a></p>
<p class="indexsub">understanding, <a href="#part0027_page_121">121</a></p>
<p class="indexmain" id="part0052_idx207">Independent deployability</p>
<p class="indexsub">in <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_344">344</a></p>
<p class="indexsub">as fallacy of services, <a href="#part0041_page_241">241</a></p>
<p class="indexsub">kitty problem example, <a href="#part0041_page_242">242</a>–<a href="#part0041_page_243">243</a></p>
<p class="indexsub">in OO approach for cross-cutting concerns, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexsub">overview of, <a href="#part0030_page_154">154</a></p>
<p class="indexmain" id="part0052_idx208">Independent developability</p>
<p class="indexsub">as fallacy of services, <a href="#part0041_page_241">241</a></p>
<p class="indexsub">kitty problem example, <a href="#part0041_page_242">242</a>–<a href="#part0041_page_243">243</a></p>
<p class="indexsub">in OO approach for cross-cutting concerns, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexsub">overview of, <a href="#part0030_page_153">153</a>–<a href="#part0030_page_154">154</a></p>
<p class="indexsub">of UI and database, <a href="#part0016_page_47">47</a></p>
<p class="indexmain" id="part0052_idx209">Induction, Dijkstra’s proof related to iteration, <a href="#part0015_page_28">28</a></p>
<p class="indexmain" id="part0052_idx210">Information hiding, Open-Closed Principle, <a href="#part0020_page_74">74</a>–<a href="#part0020_page_75">75</a></p>
<p class="indexmain" id="part0052_idx211">Inheritance relationships</p>
<p class="indexsub">crossing circle boundaries, <a href="#part0036_page_206">206</a></p>
<p class="indexsub">defining OOP, <a href="#part0016_page_37">37</a>–<a href="#part0016_page_40">40</a></p>
<p class="indexsub">dependency inversion, <a href="#part0016_page_46">46</a></p>
<p class="indexsub">dependency management, <a href="#part0048_page_302">302</a></p>
<p class="indexsub">guiding use of, <a href="#part0021_page_78">78</a></p>
<p class="indexmain" id="part0052_idx212">Input/output</p>
<p class="indexsub">business rules for use cases, <a href="#part0034_page_193">193</a>–<a href="#part0034_page_194">194</a></p>
<p class="indexsub">decoupling higher-level policy from lower level, <a href="#part0033_page_185">185</a>–<a href="#part0033_page_187">187</a></p>
<p class="indexsub">policy level defined as distance from, <a href="#part0033_page_184">184</a></p>
<p class="indexsub">separating components with boundary lines, <a href="#part0031_page_169">169</a>–<a href="#part0031_page_170">170</a></p>
<p class="indexmain" id="part0052_idx213">Integers, functional programming example, <a href="#part0017_page_50">50</a>–<a href="#part0017_page_51">51</a></p>
<p class="indexmain" id="part0052_idx214">Integration, weekly build issues, <a href="#part0027_page_112">112</a>–<a href="#part0027_page_113">113</a></p>
<p class="indexmain" id="part0052_idx215">Interface adapters, Dependency Rule for, <a href="#part0036_page_205">205</a></p>
<p class="indexmain" id="part0052_idx216">Interface Segregation Principle. <em class="calibre9">See</em> <a href="#part0052_idx219">ISP (Interface Segregation Principle)</a></p>
<p class="indexmain" id="part0052_idx217">IO device</p>
<p class="indexsub">UNIX functions, <a href="#part0016_page_41">41</a>–<a href="#part0016_page_44">44</a></p>
<p class="indexsub">web is, <a href="#part0046_page_288">288</a>–<a href="#part0046_page_289">289</a></p>
<p class="indexmain" id="part0052_idx218">Isolation, test, <a href="#part0042_page_250">250</a>–<a href="#part0042_page_251">251</a></p>
<p class="indexmain" id="part0052_idx219">ISP (Interface Segregation Principle)</p>
<p class="indexsub">architecture and, <a href="#part0022_page_86">86</a></p>
<p class="indexsub">Common Reuse Principle compared with, <a href="#part0026_page_108">108</a></p>
<p class="indexsub">conclusion, <a href="#part0022_page_86">86</a></p>
<p class="indexsub">defined, <a href="#part0018_page_59">59</a></p>
<p class="indexsub">language type and, <a href="#part0022_page_85">85</a></p>
<p class="indexsub">overview of, <a href="#part0022_page_84">84</a>–<a href="#part0022_page_85">85</a></p>
<p class="indexmain" id="part0052_idx220">Iteration, <a href="#part0015_page_27">27</a>–<a href="#part0015_page_28">28</a></p>
<p class="indexmain1"><strong class="calibre8">J</strong></p>
<p class="indexmain" id="part0052_idx221">Jacobson, Ivar, <a href="#part0035_page_196">196</a>, <a href="#part0036_page_202">202</a></p>
<p class="indexmain" id="part0052_idx222">Jar files</p>
<p class="indexsub">component architecture, <a href="#part0048_page_301">301</a></p>
<p class="indexsub">components as, <a href="#part0025_page_96">96</a></p>
<p class="indexsub">creating partial boundary, <a href="#part0038_page_219">219</a></p>
<p class="indexsub">defining function of components, <a href="#part0049_page_313">313</a></p>
<p class="indexsub">designing component-based services, <a href="#part0041_page_245">245</a>–<a href="#part0041_page_246">246</a></p>
<p class="indexsub">Download and Go rule for, <a href="#part0031_page_163">163</a></p>
<p class="indexsub">in source-level decoupling mode, <a href="#part0032_page_176">176</a></p>
<p class="indexmain" id="part0052_idx223">Java</p>
<p class="indexsub">abstract components in, <a href="#part0027_page_125">125</a></p>
<p class="indexsub"><a id="part0052_page_389"></a>code organization approaches in. <em class="calibre9">See</em> <a href="#part0052_idx69">Code organization</a></p>
<p class="indexsub">components as jar files in, <a href="#part0025_page_96">96</a></p>
<p class="indexsub">DIP and, <a href="#part0023_page_87">87</a></p>
<p class="indexsub">import statements for dependencies, <a href="#part0033_page_184">184</a></p>
<p class="indexsub">ISP example, <a href="#part0022_page_84">84</a>–<a href="#part0022_page_85">85</a></p>
<p class="indexsub">marrying standard library framework in, <a href="#part0047_page_293">293</a></p>
<p class="indexsub">module frameworks in, <a href="#part0049_page_319">319</a></p>
<p class="indexsub">package by layer in, <a href="#part0049_page_304">304</a>–<a href="#part0049_page_306">306</a></p>
<p class="indexsub">squares of integers example in, <a href="#part0017_page_50">50</a>–<a href="#part0017_page_51">51</a></p>
<p class="indexsub">weakening encapsulation, <a href="#part0016_page_36">36</a>–<a href="#part0016_page_37">37</a></p>
<p class="indexmain" id="part0052_idx224">Jitters, breaking cycle of components, <a href="#part0027_page_118">118</a></p>
<p class="indexmain" id="part0052_idx225">Junk mail example, <a href="#part0029_page_144">144</a>–<a href="#part0029_page_145">145</a></p>
<p class="indexmain1"><strong class="calibre8">K</strong></p>
<p class="indexmain" id="part0052_idx226">Kitty problem example, <a href="#part0041_page_242">242</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexmain1"><strong class="calibre8">L</strong></p>
<p class="indexmain" id="part0052_idx227">Languages</p>
<p class="indexsub">clean architecture and, <a href="#part0039_page_223">223</a>–<a href="#part0039_page_226">226</a></p>
<p class="indexsub">Hunt the Wumpus adventure game, <a href="#part0039_page_222">222</a>–<a href="#part0039_page_223">223</a></p>
<p class="indexmain" id="part0052_idx228">Laser Trim, archaeology project</p>
<p class="indexsub">4-TEL project, <a href="#part0051_page_339">339</a></p>
<p class="indexsub">overview of, <a href="#part0051_page_334">334</a>–<a href="#part0051_page_338">338</a></p>
<p class="indexmain" id="part0052_idx229">Layered architecture</p>
<p class="indexsub">package by layer code organization, <a href="#part0049_page_304">304</a>–<a href="#part0049_page_306">306</a></p>
<p class="indexsub">relaxed, <a href="#part0049_page_311">311</a>–<a href="#part0049_page_312">312</a></p>
<p class="indexsub">why it is considered bad, <a href="#part0049_page_310">310</a>–<a href="#part0049_page_311">311</a></p>
<p class="indexmain" id="part0052_idx230">Layers</p>
<p class="indexsub">approach to code organization, <a href="#part0049_page_304">304</a>–<a href="#part0049_page_306">306</a></p>
<p class="indexsub">clean architecture using, <a href="#part0036_page_202">202</a>–<a href="#part0036_page_203">203</a></p>
<p class="indexsub">decoupling, <a href="#part0030_page_151">151</a>–<a href="#part0030_page_152">152</a></p>
<p class="indexsub">duplication of, <a href="#part0030_page_155">155</a></p>
<p class="indexsub">eliminating target-hardware bottleneck, <a href="#part0043_page_262">262</a>–<a href="#part0043_page_263">263</a></p>
<p class="indexsub">independent developability, <a href="#part0030_page_154">154</a></p>
<p class="indexmain" id="part0052_idx231">Layers and boundaries</p>
<p class="indexsub">clean architecture, <a href="#part0039_page_223">223</a>–<a href="#part0039_page_226">226</a></p>
<p class="indexsub">conclusion, <a href="#part0039_page_228">228</a></p>
<p class="indexsub">crossing streams, <a href="#part0039_page_226">226</a></p>
<p class="indexsub">Hunt the Wumpus adventure game, <a href="#part0039_page_222">222</a>–<a href="#part0039_page_223">223</a></p>
<p class="indexsub">overview of, <a href="#part0039_page_221">221</a>–<a href="#part0039_page_222">222</a></p>
<p class="indexsub">splitting streams, <a href="#part0039_page_227">227</a>–<a href="#part0039_page_228">228</a></p>
<p class="indexmain" id="part0052_idx232">Leiningen tool, module management, <a href="#part0026_page_104">104</a></p>
<p class="indexmain" id="part0052_idx233">Level</p>
<p class="indexsub">hierarchy of protection and, <a href="#part0020_page_74">74</a></p>
<p class="indexsub">policy and, <a href="#part0033_page_184">184</a>–<a href="#part0033_page_187">187</a></p>
<p class="indexmain" id="part0052_idx234">Libraries</p>
<p class="indexsub">location of source code, <a href="#part0025_page_97">97</a>–<a href="#part0025_page_98">98</a></p>
<p class="indexsub">relocatable binaries, <a href="#part0025_page_99">99</a>–<a href="#part0025_page_100">100</a></p>
<p class="indexmain" id="part0052_idx235">Life cycle, architecture supports system, <a href="#part0029_page_137">137</a></p>
<p class="indexmain" id="part0052_idx236">Linkers, separating from loaders, <a href="#part0025_page_100">100</a>–<a href="#part0025_page_102">102</a></p>
<p class="indexmain" id="part0052_idx237">Liskov, Barbara, <a href="#part0021_page_78">78</a></p>
<p class="indexmain" id="part0052_idx238">Liskov Substitution Principle (LSP). <em class="calibre9">See</em> <a href="#part0052_idx243">LSP (Liskov Substitution Principle)</a></p>
<p class="indexmain" id="part0052_idx239">LISP langauge, functional programming, <a href="#part0014_page_23">23</a></p>
<p class="indexmain" id="part0052_idx240">Lisp language, squares of integers example, <a href="#part0017_page_50">50</a>–<a href="#part0017_page_51">51</a></p>
<p class="indexmain" id="part0052_idx241">Loaders</p>
<p class="indexsub">linking, <a href="#part0025_page_100">100</a>–<a href="#part0025_page_102">102</a></p>
<p class="indexsub">relocatable binaries, <a href="#part0025_page_99">99</a>–<a href="#part0025_page_100">100</a></p>
<p class="indexmain" id="part0052_idx242">Local process boundaries, <a href="#part0032_page_179">179</a>–<a href="#part0032_page_180">180</a></p>
<p class="indexmain" id="part0052_idx243">LSP (Liskov Substitution Principle)</p>
<p class="indexsub">architecture and, <a href="#part0021_page_80">80</a></p>
<p class="indexsub">conclusion, <a href="#part0021_page_82">82</a></p>
<p class="indexsub">defined, <a href="#part0018_page_59">59</a></p>
<p class="indexsub">guiding use of inheritance, <a href="#part0021_page_78">78</a></p>
<p class="indexsub"><a id="part0052_page_390"></a>overview of, <a href="#part0021_page_78">78</a></p>
<p class="indexsub">square/rectangle example problem, <a href="#part0021_page_79">79</a></p>
<p class="indexsub">violation of, <a href="#part0021_page_80">80</a>–<a href="#part0021_page_82">82</a></p>
<p class="indexmain1"><strong class="calibre8">M</strong></p>
<p class="indexmain" id="part0052_idx244">M365 computer</p>
<p class="indexsub">4-TEL archaeology project, <a href="#part0051_page_340">340</a>–<a href="#part0051_page_341">341</a></p>
<p class="indexsub">Laser Trim archaeology project, <a href="#part0051_page_335">335</a>–<a href="#part0051_page_338">338</a></p>
<p class="indexsub">SAC archaeology project, <a href="#part0051_page_345">345</a>–<a href="#part0051_page_347">347</a></p>
<p class="indexmain" id="part0052_idx245">Mailboxes, local processes communicate via, <a href="#part0032_page_180">180</a></p>
<p class="indexmain" id="part0052_idx246">Main component</p>
<p class="indexsub">conclusion, <a href="#part0040_page_237">237</a></p>
<p class="indexsub">as concrete component, <a href="#part0023_page_91">91</a></p>
<p class="indexsub">defined, <a href="#part0040_page_232">232</a></p>
<p class="indexsub">object-oriented programming, <a href="#part0016_page_40">40</a></p>
<p class="indexsub">polymorphism, <a href="#part0016_page_45">45</a></p>
<p class="indexsub">small impact of releasing, <a href="#part0027_page_115">115</a></p>
<p class="indexsub">as ultimate detail, <a href="#part0040_page_232">232</a>–<a href="#part0040_page_237">237</a></p>
<p class="indexmain" id="part0052_idx247">Main Sequence</p>
<p class="indexsub">avoiding Zones of Exclusion via, <a href="#part0027_page_130">130</a></p>
<p class="indexsub">defining relationship between abstraction/stability, <a href="#part0027_page_127">127</a>–<a href="#part0027_page_128">128</a></p>
<p class="indexsub">measuring distance from, <a href="#part0027_page_130">130</a>–<a href="#part0027_page_132">132</a></p>
<p class="indexsub">Zone of Pain, <a href="#part0027_page_129">129</a></p>
<p class="indexsub">Zone of Uselessness, <a href="#part0027_page_129">129</a>–<a href="#part0027_page_130">130</a></p>
<p class="indexmain" id="part0052_idx248">Maintenance, impact of architecture on, <a href="#part0029_page_139">139</a>–<a href="#part0029_page_140">140</a></p>
<p class="indexmain" id="part0052_idx249">Marketing campaigns, database vendor, <a href="#part0045_page_283">283</a></p>
<p class="indexmain" id="part0052_idx250">Master Operating Program (MOP), Laser Trim archaeology project, <a href="#part0051_page_336">336</a></p>
<p class="indexmain" id="part0052_idx251">Mathematics</p>
<p class="indexsub">contrasting science with, <a href="#part0015_page_30">30</a></p>
<p class="indexsub">discipline of proof, <a href="#part0015_page_27">27</a>–<a href="#part0015_page_28">28</a></p>
<p class="indexmain" id="part0052_idx252">Maven tool, module management, <a href="#part0026_page_104">104</a></p>
<p class="indexmain" id="part0052_idx253">McCarthy, John, <a href="#part0014_page_23">23</a></p>
<p class="indexmain" id="part0052_idx254">Memory</p>
<p class="indexsub">early layout of, <a href="#part0025_page_98">98</a>–<a href="#part0025_page_99">99</a></p>
<p class="indexsub">local processes and, <a href="#part0032_page_179">179</a></p>
<p class="indexsub">RAM. <em class="calibre9">See</em> <a href="#part0052_idx329">RAM</a></p>
<p class="indexmain" id="part0052_idx255">Merges, SRP examples, <a href="#part0019_page_65">65</a></p>
<p class="indexmain" id="part0052_idx256">Message queues, local processes communicate via, <a href="#part0032_page_180">180</a></p>
<p class="indexmain" id="part0052_idx257">Metrics</p>
<p class="indexsub">abstraction, <a href="#part0027_page_127">127</a></p>
<p class="indexsub">distance from Main Sequence, <a href="#part0027_page_130">130</a>–<a href="#part0027_page_132">132</a></p>
<p class="indexmain" id="part0052_idx258">Meyer, Bertrand, <a href="#part0020_page_70">70</a></p>
<p class="indexmain" id="part0052_idx259">Micro-service architecture</p>
<p class="indexsub">in Craft Dispatch System archaeology project, <a href="#part0051_page_362">362</a>–<a href="#part0051_page_363">363</a></p>
<p class="indexsub">decoupling mode, <a href="#part0030_page_153">153</a></p>
<p class="indexsub">deployment strategy, <a href="#part0029_page_138">138</a></p>
<p class="indexsub">popularity of, <a href="#part0041_page_239">239</a></p>
<p class="indexmain" id="part0052_idx260">Modems, SAC archaeology project, <a href="#part0051_page_346">346</a>–<a href="#part0051_page_347">347</a></p>
<p class="indexmain" id="part0052_idx261">Modules</p>
<p class="indexsub">Common Reuse Principle, <a href="#part0026_page_107">107</a>–<a href="#part0026_page_108">108</a></p>
<p class="indexsub">defined, <a href="#part0019_page_62">62</a></p>
<p class="indexsub">management tools, <a href="#part0026_page_104">104</a></p>
<p class="indexsub">public types vs. published types, <a href="#part0049_page_319">319</a></p>
<p class="indexsub">Reuse/Release Equivalence Principle, <a href="#part0026_page_105">105</a></p>
<p class="indexmain" id="part0052_idx262">Monoliths</p>
<p class="indexsub">building scalable systems, <a href="#part0041_page_241">241</a></p>
<p class="indexsub">deployment-level components vs., <a href="#part0032_page_179">179</a></p>
<p class="indexsub">deployment of, <a href="#part0032_page_176">176</a>–<a href="#part0032_page_178">178</a></p>
<p class="indexsub">function calls, <a href="#part0041_page_240">240</a></p>
<p class="indexsub">local processes as statically linked, <a href="#part0032_page_180">180</a></p>
<p class="indexsub">threads, <a href="#part0032_page_179">179</a></p>
<p class="indexmain" id="part0052_idx263"><a id="part0052_page_391"></a>Moore’s Law, <a href="#part0025_page_101">101</a></p>
<p class="indexmain" id="part0052_idx264">MOP (Master Operating Program), Laser Trim archaeology project, <a href="#part0051_page_336">336</a></p>
<p class="indexmain" id="part0052_idx265">Morning after syndrome</p>
<p class="indexsub">eliminating dependency cycles to solve, <a href="#part0027_page_113">113</a>–<a href="#part0027_page_115">115</a></p>
<p class="indexsub">managing dependencies to prevent, <a href="#part0027_page_118">118</a></p>
<p class="indexsub">overview of, <a href="#part0027_page_112">112</a></p>
<p class="indexsub">weekly build issues, <a href="#part0027_page_112">112</a>–<a href="#part0027_page_113">113</a></p>
<p class="indexmain" id="part0052_idx266">MPS (multiprocessing system), SAC archaeology project, <a href="#part0051_page_345">345</a>–<a href="#part0051_page_346">346</a></p>
<p class="indexmain" id="part0052_idx267">Mutability, <a href="#part0017_page_52">52</a>–<a href="#part0017_page_54">54</a></p>
<p class="indexmain" id="part0052_idx268">Mutable variables, <a href="#part0017_page_51">51</a>, <a href="#part0017_page_54">54</a>–<a href="#part0017_page_55">55</a></p>
<p class="indexmain1"><strong class="calibre8">N</strong></p>
<p class="indexmain" id="part0052_idx269">National Council of Architects Registry Board (NCARB), <a href="#part0051_page_370">370</a>–<a href="#part0051_page_372">372</a></p>
<p class="indexmain" id="part0052_idx270">.NET, components as DLLs, <a href="#part0025_page_96">96</a></p>
<p class="indexmain" id="part0052_idx271">NetNews, presence of author on, <a href="#part0051_page_367">367</a>–<a href="#part0051_page_369">369</a></p>
<p class="indexmain" id="part0052_idx272">Newkirk, Jim, <a href="#part0051_page_371">371</a>–<a href="#part0051_page_372">372</a></p>
<p class="indexmain" id="part0052_idx273">Nygaard, Kristen, <a href="#part0014_page_22">22</a></p>
<p class="indexmain1"><strong class="calibre8">O</strong></p>
<p class="indexmain" id="part0052_idx274">Object-oriented databases, ROSE product, <a href="#part0051_page_368">368</a>–<a href="#part0051_page_370">370</a></p>
<p class="indexmain" id="part0052_idx275"><em class="calibre9">Object Oriented Design with Applications</em> (Booch), <a href="#part0051_page_366">366</a>, <a href="#part0051_page_368">368</a></p>
<p class="indexmain" id="part0052_idx276">Object-oriented programming</p>
<p class="indexsub">conclusion, <a href="#part0016_page_47">47</a></p>
<p class="indexsub">for cross-cutting concerns, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexsub">dependency inversion, <a href="#part0016_page_44">44</a>–<a href="#part0016_page_47">47</a></p>
<p class="indexsub">deployment of monoliths, <a href="#part0032_page_177">177</a></p>
<p class="indexsub">encapsulation, <a href="#part0016_page_35">35</a>–<a href="#part0016_page_37">37</a></p>
<p class="indexsub">history of, <a href="#part0014_page_22">22</a></p>
<p class="indexsub">inheritance, <a href="#part0016_page_37">37</a>–<a href="#part0016_page_40">40</a></p>
<p class="indexsub">overview of, <a href="#part0016_page_34">34</a>–<a href="#part0016_page_35">35</a></p>
<p class="indexsub">polymorphism, <a href="#part0016_page_40">40</a>–<a href="#part0016_page_43">43</a></p>
<p class="indexsub">power of polymorphism, <a href="#part0016_page_43">43</a>–<a href="#part0016_page_44">44</a></p>
<p class="indexmain" id="part0052_idx277"><em class="calibre9">Object Oriented Software Engineering</em> (Jacobson), <a href="#part0035_page_196">196</a>, <a href="#part0036_page_202">202</a></p>
<p class="indexmain" id="part0052_idx278">Object relational mappers (ORMs), <a href="#part0037_page_214">214</a>–<a href="#part0037_page_215">215</a></p>
<p class="indexmain" id="part0052_idx279">Objects, invented in <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_344">344</a></p>
<p class="indexmain" id="part0052_idx280">OCP (Open-Closed Principle)</p>
<p class="indexsub">birth of, <a href="#part0029_page_142">142</a></p>
<p class="indexsub">Common Closure Principle compared with, <a href="#part0026_page_106">106</a></p>
<p class="indexsub">conclusion, <a href="#part0020_page_75">75</a></p>
<p class="indexsub">in Craft Dispatch System archaeology project, <a href="#part0051_page_363">363</a></p>
<p class="indexsub">defined, <a href="#part0018_page_59">59</a></p>
<p class="indexsub">dependency management, <a href="#part0048_page_302">302</a></p>
<p class="indexsub">designing component-based services, <a href="#part0041_page_246">246</a></p>
<p class="indexsub">directional control, <a href="#part0020_page_74">74</a></p>
<p class="indexsub">information hiding, <a href="#part0020_page_74">74</a>–<a href="#part0020_page_75">75</a></p>
<p class="indexsub">overview of, <a href="#part0020_page_70">70</a></p>
<p class="indexsub">thought experiment, <a href="#part0020_page_71">71</a>–<a href="#part0020_page_74">74</a></p>
<p class="indexmain" id="part0052_idx281">OMC (Outboard Marine Corporation), aluminum die-cast archaeology project, <a href="#part0051_page_338">338</a>–<a href="#part0051_page_339">339</a></p>
<p class="indexmain" id="part0052_idx282">One-dimensional boundaries, <a href="#part0038_page_219">219</a></p>
<p class="indexmain" id="part0052_idx283">Open-Closed Principle. <em class="calibre9">See</em> <a href="#part0052_idx280">OCP (Open-Closed Principle)</a></p>
<p class="indexmain" id="part0052_idx284">Operating system abstraction layer (OSAL), clean embedded architecture, <a href="#part0043_page_270">270</a>–<a href="#part0043_page_271">271</a></p>
<p class="indexmain" id="part0052_idx285">Operating system (OS), is detail, <a href="#part0043_page_269">269</a>–<a href="#part0043_page_271">271</a></p>
<p class="indexmain" id="part0052_idx286">Operations</p>
<p class="indexsub">architecture supports system, <a href="#part0029_page_138">138</a>–<a href="#part0029_page_139">139</a>, <a href="#part0030_page_149">149</a></p>
<p class="indexsub">decoupling use cases for, <a href="#part0030_page_153">153</a></p>
<p class="indexsub"><a id="part0052_page_392"></a>use cases affected by changes in, <a href="#part0036_page_204">204</a></p>
<p class="indexmain" id="part0052_idx287">Options, keeping open</p>
<p class="indexsub">good architecture makes system easy to change, <a href="#part0030_page_150">150</a>–<a href="#part0030_page_151">151</a></p>
<p class="indexsub">operational architecture, <a href="#part0030_page_149">149</a></p>
<p class="indexsub">purpose of architecture, <a href="#part0029_page_140">140</a>–<a href="#part0029_page_142">142</a>, <a href="#part0035_page_197">197</a></p>
<p class="indexsub">via decoupling mode, <a href="#part0030_page_153">153</a></p>
<p class="indexmain" id="part0052_idx288">Organization vs. encapsulation, <a href="#part0049_page_316">316</a>–<a href="#part0049_page_319">319</a></p>
<p class="indexmain" id="part0052_idx289">ORMs (object relational mappers), <a href="#part0037_page_214">214</a>–<a href="#part0037_page_215">215</a></p>
<p class="indexmain" id="part0052_idx290">OS (operating system), is detail, <a href="#part0043_page_269">269</a>–<a href="#part0043_page_271">271</a></p>
<p class="indexmain" id="part0052_idx291">OSAL (operating system abstraction layer), clean embedded architecture, <a href="#part0043_page_270">270</a>–<a href="#part0043_page_271">271</a></p>
<p class="indexmain" id="part0052_idx292">Oscillations, web as one of many, <a href="#part0046_page_285">285</a>–<a href="#part0046_page_289">289</a></p>
<p class="indexmain" id="part0052_idx293">Outgoing dependencies, stability metrics, <a href="#part0027_page_122">122</a>–<a href="#part0027_page_123">123</a></p>
<p class="indexmain" id="part0052_idx294">Overconfidence, foolishness of, <a href="#part0011_page_9">9</a>–<a href="#part0011_page_12">12</a></p>
<p class="indexmain1"><strong class="calibre8">P</strong></p>
<p class="indexmain" id="part0052_idx295">Package by component, <a href="#part0049_page_310">310</a>–<a href="#part0049_page_315">315</a>, <a href="#part0049_page_318">318</a></p>
<p class="indexmain" id="part0052_idx296">Package by feature, <a href="#part0049_page_306">306</a>–<a href="#part0049_page_307">307</a>, <a href="#part0049_page_317">317</a></p>
<p class="indexmain" id="part0052_idx297">Package by layer</p>
<p class="indexsub">access modifiers, <a href="#part0049_page_317">317</a>–<a href="#part0049_page_318">318</a></p>
<p class="indexsub">horizontal layering of code, <a href="#part0049_page_304">304</a>–<a href="#part0049_page_306">306</a></p>
<p class="indexsub">why it is considered bad, <a href="#part0049_page_310">310</a>–<a href="#part0049_page_311">311</a></p>
<p class="indexmain" id="part0052_idx298">Packages, organization vs. encapsulation, <a href="#part0049_page_316">316</a>–<a href="#part0049_page_319">319</a></p>
<p class="indexmain" id="part0052_idx299">Page-Jones, Meilir, <a href="#part0015_page_29">29</a></p>
<p class="indexmain" id="part0052_idx300">Partial boundaries</p>
<p class="indexsub">conclusion, <a href="#part0038_page_220">220</a></p>
<p class="indexsub">facades, <a href="#part0038_page_220">220</a></p>
<p class="indexsub">one-dimensional boundaries, <a href="#part0038_page_219">219</a></p>
<p class="indexsub">reasons to implement, <a href="#part0038_page_217">217</a>–<a href="#part0038_page_218">218</a></p>
<p class="indexsub">skip last step, <a href="#part0038_page_218">218</a>–<a href="#part0038_page_219">219</a></p>
<p class="indexmain" id="part0052_idx301">Patches, in <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_344">344</a></p>
<p class="indexmain" id="part0052_idx302">PCCU, archaeology project, <a href="#part0051_page_352">352</a>–<a href="#part0051_page_354">354</a></p>
<p class="indexmain" id="part0052_idx303">PDP-11/60 computer, <a href="#part0051_page_349">349</a>–<a href="#part0051_page_351">351</a></p>
<p class="indexmain" id="part0052_idx304">Performance, as low-level concern, <a href="#part0045_page_281">281</a></p>
<p class="indexmain" id="part0052_idx305">Périphérique anti-pattern of ports and adapters, <a href="#part0049_page_320">320</a>–<a href="#part0049_page_321">321</a></p>
<p class="indexmain" id="part0052_idx306">Physical addressing example, <a href="#part0029_page_145">145</a>–<a href="#part0029_page_146">146</a></p>
<p class="indexmain" id="part0052_idx307">Plugin architecture</p>
<p class="indexsub">in <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_344">344</a></p>
<p class="indexsub">for device independence, <a href="#part0016_page_44">44</a></p>
<p class="indexsub">drawing boundaries for axis of change, <a href="#part0031_page_173">173</a></p>
<p class="indexsub">of lower-level components into higher-level components, <a href="#part0033_page_187">187</a></p>
<p class="indexsub">Main component as, <a href="#part0040_page_237">237</a></p>
<p class="indexsub">start with presumption of, <a href="#part0031_page_170">170</a>–<a href="#part0031_page_171">171</a></p>
<p class="indexmain" id="part0052_idx308">Pointers</p>
<p class="indexsub">in creating polymorphic behavior, <a href="#part0016_page_43">43</a></p>
<p class="indexsub">functional, <a href="#part0014_page_22">22</a>–<a href="#part0014_page_23">23</a></p>
<p class="indexmain" id="part0052_idx309">Policy</p>
<p class="indexsub">in clean architecture, <a href="#part0036_page_203">203</a></p>
<p class="indexsub">high-level. <em class="calibre9">See</em> <a href="#part0052_idx195">High-level policy</a></p>
<p class="indexsub">overview of, <a href="#part0033_page_183">183</a>–<a href="#part0033_page_184">184</a></p>
<p class="indexsub">software systems as statements of, <a href="#part0033_page_183">183</a></p>
<p class="indexsub">splitting data streams, <a href="#part0039_page_227">227</a>–<a href="#part0039_page_228">228</a></p>
<p class="indexmain" id="part0052_idx310">Polymorphic dispatch, <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_344">344</a></p>
<p class="indexmain" id="part0052_idx311">Polymorphism</p>
<p class="indexsub">crossing circle boundaries with dynamic, <a href="#part0036_page_206">206</a></p>
<p class="indexsub">dependency inversion, <a href="#part0016_page_44">44</a>–<a href="#part0016_page_47">47</a></p>
<p class="indexsub"><a id="part0052_page_393"></a>flow of control in dynamic, <a href="#part0032_page_177">177</a>–<a href="#part0032_page_178">178</a></p>
<p class="indexsub">in object-oriented programming, <a href="#part0014_page_22">22</a>, <a href="#part0016_page_40">40</a>–<a href="#part0016_page_43">43</a></p>
<p class="indexsub">power of, <a href="#part0016_page_43">43</a>–<a href="#part0016_page_44">44</a></p>
<p class="indexmain" id="part0052_idx312">Ports and adapters</p>
<p class="indexsub">access modifiers, <a href="#part0049_page_318">318</a></p>
<p class="indexsub">approach to code organization, <a href="#part0049_page_308">308</a>–<a href="#part0049_page_310">310</a></p>
<p class="indexsub">decouple dependencies with source code trees, <a href="#part0049_page_319">319</a>–<a href="#part0049_page_320">320</a></p>
<p class="indexsub">Périphérique anti-pattern of, <a href="#part0049_page_320">320</a>–<a href="#part0049_page_321">321</a></p>
<p class="indexmain" id="part0052_idx313">Positional stability, component, <a href="#part0027_page_122">122</a>–<a href="#part0027_page_123">123</a></p>
<p class="indexmain" id="part0052_idx314">Premature decisions, coupling to, <a href="#part0031_page_160">160</a>–<a href="#part0031_page_163">163</a></p>
<p class="indexmain" id="part0052_idx315">“Presentation Domain Data Layering” (Fowler), <a href="#part0049_page_305">305</a>–<a href="#part0049_page_306">306</a></p>
<p class="indexmain" id="part0052_idx316">Presenters</p>
<p class="indexsub">in clean architecture, <a href="#part0036_page_203">203</a>, <a href="#part0036_page_205">205</a></p>
<p class="indexsub">clean architecture scenario, <a href="#part0036_page_207">207</a>–<a href="#part0036_page_208">208</a></p>
<p class="indexsub">component architecture, <a href="#part0048_page_301">301</a></p>
<p class="indexsub">crossing circle boundaries, <a href="#part0036_page_206">206</a></p>
<p class="indexmain" id="part0052_idx317">Presenters and humble objects</p>
<p class="indexsub">conclusion, <a href="#part0037_page_215">215</a></p>
<p class="indexsub">data mappers, <a href="#part0037_page_214">214</a>–<a href="#part0037_page_215">215</a></p>
<p class="indexsub">database getaways, <a href="#part0037_page_214">214</a></p>
<p class="indexsub">Humble Object pattern, <a href="#part0037_page_212">212</a></p>
<p class="indexsub">overview of, <a href="#part0037_page_211">211</a>–<a href="#part0037_page_212">212</a></p>
<p class="indexsub">Presenters and Views, <a href="#part0037_page_212">212</a>–<a href="#part0037_page_213">213</a></p>
<p class="indexsub">service listeners, <a href="#part0037_page_215">215</a></p>
<p class="indexsub">testing and architecture, <a href="#part0037_page_213">213</a></p>
<p class="indexmain" id="part0052_idx318">Processes, partitioning into classes/separating classes, <a href="#part0020_page_71">71</a>–<a href="#part0020_page_72">72</a></p>
<p class="indexmain" id="part0052_idx319">Processor</p>
<p class="indexsub">is detail, <a href="#part0043_page_265">265</a>–<a href="#part0043_page_269">269</a></p>
<p class="indexsub">mutability and, <a href="#part0017_page_52">52</a></p>
<p class="indexmain" id="part0052_idx320">Product, video sales case study, <a href="#part0048_page_298">298</a></p>
<p class="indexmain" id="part0052_idx321">Productivity</p>
<p class="indexsub">decreasing, increasing cost of code, <a href="#part0011_page_5">5</a>–<a href="#part0011_page_7">7</a></p>
<p class="indexsub">signature of a mess, <a href="#part0011_page_8">8</a>–<a href="#part0011_page_9">9</a></p>
<p class="indexmain" id="part0052_idx322">Programming languages</p>
<p class="indexsub">abstract components in, <a href="#part0027_page_125">125</a>–<a href="#part0027_page_126">126</a></p>
<p class="indexsub">components, <a href="#part0025_page_96">96</a></p>
<p class="indexsub">dynamically typed, <a href="#part0023_page_88">88</a></p>
<p class="indexsub">ISP and, <a href="#part0022_page_85">85</a></p>
<p class="indexsub">statically typed, <a href="#part0023_page_87">87</a></p>
<p class="indexsub">variables in functional languages, <a href="#part0017_page_51">51</a></p>
<p class="indexmain" id="part0052_idx323">Programming paradigms</p>
<p class="indexsub">functional programming. <em class="calibre9">See</em> <a href="#part0052_idx184">Functional programming</a></p>
<p class="indexsub">history of, <a href="#part0013_page_19">19</a>–<a href="#part0013_page_20">20</a></p>
<p class="indexsub">object-oriented programming. <em class="calibre9">See</em> <a href="#part0052_idx276">Object-oriented programming</a></p>
<p class="indexsub">overview of, <a href="#part0014_page_21">21</a>–<a href="#part0014_page_24">24</a></p>
<p class="indexsub">structured programming. <em class="calibre9">See</em> <a href="#part0052_idx400">Structured programming</a></p>
<p class="indexmain" id="part0052_idx324">Proof</p>
<p class="indexsub">discipline of, <a href="#part0015_page_27">27</a>–<a href="#part0015_page_28">28</a></p>
<p class="indexsub">structured programming lacking, <a href="#part0015_page_30">30</a>–<a href="#part0015_page_31">31</a></p>
<p class="indexmain" id="part0052_idx325">Proxies, using with frameworks, <a href="#part0047_page_293">293</a></p>
<p class="indexmain" id="part0052_idx326">Public types</p>
<p class="indexsub">misuse of, <a href="#part0049_page_315">315</a>–<a href="#part0049_page_316">316</a></p>
<p class="indexsub">vs. types that are published in modules, <a href="#part0049_page_319">319</a></p>
<p class="indexmain" id="part0052_idx327">Python</p>
<p class="indexsub">DIP and, <a href="#part0023_page_88">88</a></p>
<p class="indexsub">ISP and, <a href="#part0022_page_85">85</a></p>
<p class="indexmain1"><strong class="calibre8">R</strong></p>
<p class="indexmain" id="part0052_idx328">Race conditions</p>
<p class="indexsub">due to mutable variables, <a href="#part0017_page_52">52</a></p>
<p class="indexsub">protecting against concurrent updates and, <a href="#part0017_page_53">53</a></p>
<p class="indexmain" id="part0052_idx329"><a id="part0052_page_394"></a>RAM</p>
<p class="indexsub">4-TEL archaeology project, <a href="#part0051_page_341">341</a>, <a href="#part0051_page_343">343</a>–<a href="#part0051_page_344">344</a></p>
<p class="indexsub">replacing disks, <a href="#part0045_page_280">280</a>–<a href="#part0045_page_281">281</a></p>
<p class="indexmain" id="part0052_idx330">Rational (company), <a href="#part0051_page_367">367</a>, <a href="#part0051_page_368">368</a></p>
<p class="indexmain" id="part0052_idx331">RDBMS (relational database management systems), <a href="#part0045_page_279">279</a>–<a href="#part0045_page_283">283</a></p>
<p class="indexmain" id="part0052_idx332">Real-time operating system (RTOS) is detail, <a href="#part0043_page_269">269</a>–<a href="#part0043_page_271">271</a></p>
<p class="indexmain" id="part0052_idx333">Relational database management systems (RDBMS), <a href="#part0045_page_279">279</a>–<a href="#part0045_page_283">283</a></p>
<p class="indexmain" id="part0052_idx334">Relational databases, <a href="#part0045_page_278">278</a>, <a href="#part0045_page_281">281</a>–<a href="#part0045_page_283">283</a></p>
<p class="indexmain" id="part0052_idx335">Relaxed layered architecture, <a href="#part0049_page_311">311</a>–<a href="#part0049_page_312">312</a></p>
<p class="indexmain" id="part0052_idx336">Releases</p>
<p class="indexsub">effect of cycle in component dependency graph, <a href="#part0027_page_115">115</a>–<a href="#part0027_page_117">117</a></p>
<p class="indexsub">eliminating dependency cycles, <a href="#part0027_page_113">113</a>–<a href="#part0027_page_115">115</a></p>
<p class="indexsub">numbering new component, <a href="#part0027_page_113">113</a></p>
<p class="indexsub">Reuse/Release Equivalence Principle for new, <a href="#part0026_page_104">104</a>–<a href="#part0026_page_105">105</a></p>
<p class="indexmain" id="part0052_idx337">Remote terminals, DLU/DRU archaeology project, <a href="#part0051_page_354">354</a>–<a href="#part0051_page_356">356</a></p>
<p class="indexmain" id="part0052_idx338">REP (Reuse/Release Equivalence Principle), <a href="#part0026_page_104">104</a>–<a href="#part0026_page_105">105</a>, <a href="#part0026_page_108">108</a>–<a href="#part0026_page_110">110</a></p>
<p class="indexmain" id="part0052_idx339">Request models, business rules, <a href="#part0034_page_193">193</a>–<a href="#part0034_page_194">194</a></p>
<p class="indexmain" id="part0052_idx340">ReSharper, plugin argument, <a href="#part0031_page_172">172</a>–<a href="#part0031_page_173">173</a></p>
<p class="indexmain" id="part0052_idx341">Response models, business rules, <a href="#part0034_page_193">193</a>–<a href="#part0034_page_194">194</a></p>
<p class="indexmain" id="part0052_idx342">REST, leave options open in development, <a href="#part0029_page_141">141</a></p>
<p class="indexmain" id="part0052_idx343">Reusability. <em class="calibre9">See</em> <a href="#part0052_idx104">CRP (Common Reuse Principle)</a></p>
<p class="indexmain" id="part0052_idx344">Reuse/Release Equivalence Principle (REP), <a href="#part0026_page_104">104</a>–<a href="#part0026_page_105">105</a>, <a href="#part0026_page_108">108</a>–<a href="#part0026_page_110">110</a></p>
<p class="indexmain" id="part0052_idx345">Risks</p>
<p class="indexsub">architecture should mitigate costs of, <a href="#part0029_page_139">139</a>–<a href="#part0029_page_140">140</a></p>
<p class="indexsub">of frameworks, <a href="#part0047_page_293">293</a>–<a href="#part0047_page_294">294</a></p>
<p class="indexmain" id="part0052_idx346">ROM boards, <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_341">341</a></p>
<p class="indexmain" id="part0052_idx347">ROSE product, archaeology project, <a href="#part0051_page_368">368</a>–<a href="#part0051_page_370">370</a></p>
<p class="indexmain" id="part0052_idx348">RTOS (real-time operating system) is detail, <a href="#part0043_page_269">269</a>–<a href="#part0043_page_271">271</a></p>
<p class="indexmain" id="part0052_idx349">Ruby</p>
<p class="indexsub">components as gem files, <a href="#part0025_page_96">96</a></p>
<p class="indexsub">DIP and, <a href="#part0023_page_88">88</a></p>
<p class="indexsub">ISP and, <a href="#part0022_page_85">85</a></p>
<p class="indexmain" id="part0052_idx350">RVM tool, module management, <a href="#part0026_page_104">104</a></p>
<p class="indexmain1"><strong class="calibre8">S</strong></p>
<p class="indexmain" id="part0052_idx351">SAC (service area computer), archaeology project</p>
<p class="indexsub">4-TEL using, <a href="#part0051_page_340">340</a>–<a href="#part0051_page_341">341</a></p>
<p class="indexsub">architecture, <a href="#part0051_page_345">345</a>–<a href="#part0051_page_347">347</a></p>
<p class="indexsub">conclusion, <a href="#part0051_page_349">349</a></p>
<p class="indexsub">dispatch determination, <a href="#part0051_page_345">345</a></p>
<p class="indexsub">DLU/DRU archaeology project, <a href="#part0051_page_354">354</a>–<a href="#part0051_page_356">356</a></p>
<p class="indexsub">Europe, <a href="#part0051_page_348">348</a>–<a href="#part0051_page_349">349</a></p>
<p class="indexsub">grand redesign, <a href="#part0051_page_347">347</a>–<a href="#part0051_page_348">348</a></p>
<p class="indexsub">overview of, <a href="#part0051_page_344">344</a></p>
<p class="indexmain" id="part0052_idx352">SAP (Stable Abstractions Principle)</p>
<p class="indexsub">avoiding zones of exclusion, <a href="#part0027_page_130">130</a></p>
<p class="indexsub">distance from main sequence, <a href="#part0027_page_130">130</a>–<a href="#part0027_page_132">132</a></p>
<p class="indexsub">drawing boundary lines, <a href="#part0031_page_173">173</a></p>
<p class="indexsub">introduction to, <a href="#part0027_page_126">126</a>–<a href="#part0027_page_127">127</a></p>
<p class="indexsub">main sequence, <a href="#part0027_page_127">127</a>–<a href="#part0027_page_130">130</a></p>
<p class="indexsub">measuring abstraction, <a href="#part0027_page_127">127</a></p>
<p class="indexsub">where to put high-level policy, <a href="#part0027_page_126">126</a></p>
<p class="indexmain" id="part0052_idx353">SC (service center), <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_339">339</a>–<a href="#part0051_page_340">340</a></p>
<p class="indexmain" id="part0052_idx354"><a id="part0052_page_395"></a>Scalability</p>
<p class="indexsub">kitty problem and services, <a href="#part0041_page_242">242</a>–<a href="#part0041_page_243">243</a></p>
<p class="indexsub">services not only option for building, <a href="#part0041_page_241">241</a></p>
<p class="indexmain" id="part0052_idx355">Schmidt, Doug, <a href="#part0043_page_256">256</a>–<a href="#part0043_page_258">258</a></p>
<p class="indexmain" id="part0052_idx356">Scientific methods, proving statements false, <a href="#part0015_page_30">30</a>–<a href="#part0015_page_31">31</a></p>
<p class="indexmain" id="part0052_idx357">Scope, of changing architecture, <a href="#part0012_page_15">15</a></p>
<p class="indexmain" id="part0052_idx358">Screaming architecture. <em class="calibre9">See</em> <a href="#part0052_idx22">Architecture, screaming</a></p>
<p class="indexmain" id="part0052_idx359">SDP (Stable Dependencies Principle)</p>
<p class="indexsub">abstract components, <a href="#part0027_page_125">125</a>–<a href="#part0027_page_126">126</a></p>
<p class="indexsub">not all components should be, <a href="#part0027_page_124">124</a>–<a href="#part0027_page_125">125</a></p>
<p class="indexsub">not all components should be stable, <a href="#part0027_page_123">123</a>–<a href="#part0027_page_125">125</a></p>
<p class="indexsub">overview of, <a href="#part0027_page_120">120</a></p>
<p class="indexsub">stability, <a href="#part0027_page_120">120</a>–<a href="#part0027_page_121">121</a></p>
<p class="indexsub">stability metrics, <a href="#part0027_page_122">122</a>–<a href="#part0027_page_123">123</a></p>
<p class="indexsub">Stable Abstractions Principle, <a href="#part0027_page_127">127</a></p>
<p class="indexmain" id="part0052_idx360">Security, testing API, <a href="#part0042_page_253">253</a></p>
<p class="indexmain" id="part0052_idx361">Selection, as program control structure, <a href="#part0015_page_27">27</a>–<a href="#part0015_page_28">28</a></p>
<p class="indexmain" id="part0052_idx362">Separation of components, as big concern in architecture, <a href="#part0014_page_24">24</a></p>
<p class="indexmain" id="part0052_idx363">Sequence, as program control structure, <a href="#part0015_page_27">27</a>–<a href="#part0015_page_28">28</a></p>
<p class="indexmain" id="part0052_idx364">Serial communication bus, SAC archaeology project, <a href="#part0051_page_347">347</a></p>
<p class="indexmain" id="part0052_idx365">Service area computer. <em class="calibre9">See</em> <a href="#part0052_idx351">SAC (service area computer), archaeology project</a></p>
<p class="indexmain" id="part0052_idx366">Service center (SC), <a href="#part0011_page_4">4</a>-TEL archaeology project, <a href="#part0051_page_339">339</a>–<a href="#part0051_page_340">340</a></p>
<p class="indexmain" id="part0052_idx367">Service-level decoupling mode, <a href="#part0030_page_153">153</a>, <a href="#part0030_page_156">156</a>–<a href="#part0030_page_157">157</a></p>
<p class="indexmain" id="part0052_idx368">Services</p>
<p class="indexsub">component-based, <a href="#part0041_page_245">245</a>–<a href="#part0041_page_246">246</a></p>
<p class="indexsub">conclusion, <a href="#part0041_page_247">247</a></p>
<p class="indexsub">cross-cutting concerns, <a href="#part0041_page_246">246</a>–<a href="#part0041_page_247">247</a></p>
<p class="indexsub">decoupling fallacy, <a href="#part0041_page_240">240</a>–<a href="#part0041_page_241">241</a></p>
<p class="indexsub">as function calls vs. architecture, <a href="#part0041_page_240">240</a></p>
<p class="indexsub">Humble Object boundaries for, <a href="#part0037_page_214">214</a>–<a href="#part0037_page_215">215</a></p>
<p class="indexsub">independent development/deployment fallacy, <a href="#part0041_page_241">241</a></p>
<p class="indexsub">kitty problem, <a href="#part0041_page_242">242</a>–<a href="#part0041_page_243">243</a></p>
<p class="indexsub">objects to the rescue, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexsub">overview of, <a href="#part0041_page_239">239</a></p>
<p class="indexsub">as strongest boundary, <a href="#part0032_page_180">180</a>–<a href="#part0032_page_181">181</a></p>
<p class="indexmain" id="part0052_idx369">Set program interrupt (SPI) instruction, aluminum die-cast archaeology project, <a href="#part0051_page_339">339</a></p>
<p class="indexmain" id="part0052_idx370">Shape, of change, <a href="#part0012_page_15">15</a></p>
<p class="indexmain" id="part0052_idx371">Single Responsibility Principle. <em class="calibre9">See</em> <a href="#part0052_idx387">SRP (Single Responsibility Principle)</a></p>
<p class="indexmain" id="part0052_idx372">SOA (service-oriented architecture)</p>
<p class="indexsub">decoupling mode, <a href="#part0030_page_153">153</a></p>
<p class="indexsub">in Electronic Receptionist archaeology project, <a href="#part0051_page_360">360</a>–<a href="#part0051_page_361">361</a></p>
<p class="indexsub">reasons for popularity of, <a href="#part0041_page_239">239</a></p>
<p class="indexmain" id="part0052_idx373">Sockets, local processes communicate via, <a href="#part0032_page_180">180</a></p>
<p class="indexmain" id="part0052_idx374">Software</p>
<p class="indexsub">clean embedded architecture isolates OS from, <a href="#part0043_page_270">270</a></p>
<p class="indexsub">components. <em class="calibre9">See</em> <a href="#part0052_idx84">Components</a></p>
<p class="indexsub">eliminating target-hardware bottleneck with layers, <a href="#part0043_page_262">262</a>–<a href="#part0043_page_263">263</a></p>
<p class="indexsub">fuzzy line between firmware and, <a href="#part0043_page_263">263</a>–<a href="#part0043_page_264">264</a></p>
<p class="indexsub">getting it right, <a href="#part0010_page_1">1</a>–<a href="#part0010_page_2">2</a></p>
<p class="indexsub"><a id="part0052_page_396"></a>SOLID principles, <a href="#part0018_page_58">58</a></p>
<p class="indexsub">value of architecture vs. behavior, <a href="#part0012_page_14">14</a>–<a href="#part0012_page_18">18</a></p>
<p class="indexmain" id="part0052_idx375">Software development</p>
<p class="indexsub">fighting for architecture over function, <a href="#part0012_page_18">18</a></p>
<p class="indexsub">like a science, <a href="#part0015_page_31">31</a></p>
<p class="indexmain" id="part0052_idx376">Software reuse</p>
<p class="indexsub">Common Reuse Principle, <a href="#part0026_page_107">107</a>–<a href="#part0026_page_108">108</a></p>
<p class="indexsub">reusable components and, <a href="#part0026_page_104">104</a></p>
<p class="indexsub">Reuse/Release Equivalence Principle, <a href="#part0026_page_104">104</a>–<a href="#part0026_page_105">105</a></p>
<p class="indexmain" id="part0052_idx377">SOLID principles</p>
<p class="indexsub">Dependency Inversion Principle. <em class="calibre9">See</em> <a href="#part0052_idx135">DIP (Dependency Inversion Principle)</a></p>
<p class="indexsub">designing component-based services using, <a href="#part0041_page_245">245</a>–<a href="#part0041_page_246">246</a></p>
<p class="indexsub">history of, <a href="#part0018_page_57">57</a>–<a href="#part0018_page_59">59</a></p>
<p class="indexsub">Interface Segregation Principle. <em class="calibre9">See</em> <a href="#part0052_idx219">ISP (Interface Segregation Principle)</a></p>
<p class="indexsub">Liskov Substitution Principle. <em class="calibre9">See</em> <a href="#part0052_idx243">LSP (Liskov Substitution Principle)</a></p>
<p class="indexsub">OO approach for cross-cutting concerns, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexsub">Open-Closed Principle. <em class="calibre9">See</em> <a href="#part0052_idx280">OCP (Open-Closed Principle)</a></p>
<p class="indexsub">Single Responsibility Principle. <em class="calibre9">See</em> <a href="#part0052_idx387">SRP (Single Responsibility Principle)</a></p>
<p class="indexmain" id="part0052_idx378">Source code, compiling, <a href="#part0025_page_97">97</a>–<a href="#part0025_page_98">98</a></p>
<p class="indexmain" id="part0052_idx379">Source code dependencies</p>
<p class="indexsub">creating boundary crossing via, <a href="#part0032_page_176">176</a></p>
<p class="indexsub">crossing circle boundaries, <a href="#part0036_page_206">206</a></p>
<p class="indexsub">decoupling, <a href="#part0033_page_184">184</a>–<a href="#part0033_page_185">185</a>, <a href="#part0049_page_319">319</a></p>
<p class="indexsub">dependency inversion, <a href="#part0016_page_44">44</a>–<a href="#part0016_page_47">47</a></p>
<p class="indexsub">local processes as, <a href="#part0032_page_180">180</a></p>
<p class="indexsub">OCP example, <a href="#part0020_page_72">72</a></p>
<p class="indexsub">referring only to abstractions, <a href="#part0023_page_87">87</a>–<a href="#part0023_page_88">88</a></p>
<p class="indexsub">UI components reuse game rules via, <a href="#part0039_page_222">222</a>–<a href="#part0039_page_223">223</a></p>
<p class="indexmain" id="part0052_idx380">Source code trees, decoupling dependencies, <a href="#part0049_page_319">319</a>–<a href="#part0049_page_321">321</a></p>
<p class="indexmain" id="part0052_idx381">Source-level decoupling mode, <a href="#part0030_page_155">155</a>–<a href="#part0030_page_157">157</a>, <a href="#part0032_page_176">176</a>–<a href="#part0032_page_178">178</a></p>
<p class="indexmain" id="part0052_idx382">Spelunking, architecture mitigates costs of, <a href="#part0029_page_139">139</a>–<a href="#part0029_page_140">140</a></p>
<p class="indexmain" id="part0052_idx383">SPI (set program interrupt) instruction, aluminum die-cast archaeology project, <a href="#part0051_page_339">339</a></p>
<p class="indexmain" id="part0052_idx384">Splitting data streams, <a href="#part0039_page_227">227</a>–<a href="#part0039_page_228">228</a></p>
<p class="indexmain" id="part0052_idx385">Square/rectangle problem, LSP, <a href="#part0021_page_79">79</a></p>
<p class="indexmain" id="part0052_idx386">Squares of integers, functional programming, <a href="#part0017_page_50">50</a>–<a href="#part0017_page_51">51</a></p>
<p class="indexmain" id="part0052_idx387">SRP (Single Responsibility Principle)</p>
<p class="indexsub">accidental duplication example, <a href="#part0019_page_63">63</a>–<a href="#part0019_page_65">65</a></p>
<p class="indexsub">Common Closure Principle vs., <a href="#part0026_page_106">106</a>–<a href="#part0026_page_107">107</a></p>
<p class="indexsub">conclusion, <a href="#part0019_page_66">66</a>–<a href="#part0019_page_67">67</a></p>
<p class="indexsub">decoupling layers, <a href="#part0030_page_152">152</a></p>
<p class="indexsub">defined, <a href="#part0018_page_59">59</a></p>
<p class="indexsub">dependency management, <a href="#part0048_page_302">302</a></p>
<p class="indexsub">in good software architecture, <a href="#part0020_page_71">71</a></p>
<p class="indexsub">grouping policies into components, <a href="#part0033_page_186">186</a>–<a href="#part0033_page_187">187</a></p>
<p class="indexsub">keeping changes localized, <a href="#part0027_page_118">118</a></p>
<p class="indexsub">merges, <a href="#part0019_page_65">65</a></p>
<p class="indexsub">overview of, <a href="#part0019_page_61">61</a>–<a href="#part0019_page_63">63</a></p>
<p class="indexsub">solutions, <a href="#part0019_page_66">66</a>–<a href="#part0019_page_67">67</a></p>
<p class="indexsub">use case analysis, <a href="#part0048_page_299">299</a></p>
<p class="indexsub"><a id="part0052_page_397"></a>where to draw boundaries, <a href="#part0031_page_172">172</a>–<a href="#part0031_page_173">173</a></p>
<p class="indexmain" id="part0052_idx388">Stability, component</p>
<p class="indexsub">measuring, <a href="#part0027_page_122">122</a>–<a href="#part0027_page_123">123</a></p>
<p class="indexsub">relationship between abstraction and, <a href="#part0027_page_127">127</a>–<a href="#part0027_page_130">130</a></p>
<p class="indexsub">SAP. <em class="calibre9">See</em> <a href="#part0052_idx352">SAP (Stable Abstractions Principle)</a></p>
<p class="indexsub">understanding, <a href="#part0027_page_120">120</a>–<a href="#part0027_page_121">121</a></p>
<p class="indexmain" id="part0052_idx389">Stable Abstractions Principle. <em class="calibre9">See</em> <a href="#part0052_idx352">SAP (Stable Abstractions Principle)</a></p>
<p class="indexmain" id="part0052_idx390">Stable components</p>
<p class="indexsub">abstract components as, <a href="#part0027_page_125">125</a>–<a href="#part0027_page_126">126</a></p>
<p class="indexsub">as harmless in Zone of Pain, <a href="#part0027_page_129">129</a></p>
<p class="indexsub">not all components should be, <a href="#part0027_page_123">123</a>–<a href="#part0027_page_125">125</a></p>
<p class="indexsub">placing high-level policies in, <a href="#part0027_page_126">126</a></p>
<p class="indexsub">Stable Abstractions Principle, <a href="#part0027_page_126">126</a>–<a href="#part0027_page_127">127</a></p>
<p class="indexmain" id="part0052_idx391">Stable Dependencies Principle. <em class="calibre9">See</em> <a href="#part0052_idx359">SDP (Stable Dependencies Principle)</a></p>
<p class="indexmain" id="part0052_idx392">Stakeholders</p>
<p class="indexsub">scope vs. shape for cost of change, <a href="#part0012_page_15">15</a></p>
<p class="indexsub">seniority of architecture over function, <a href="#part0012_page_18">18</a></p>
<p class="indexsub">values provided by software systems, <a href="#part0012_page_14">14</a></p>
<p class="indexmain" id="part0052_idx393">State</p>
<p class="indexsub">concurrency issues from mutation, <a href="#part0017_page_53">53</a></p>
<p class="indexsub">storing transactions but not, <a href="#part0017_page_54">54</a>–<a href="#part0017_page_55">55</a></p>
<p class="indexmain" id="part0052_idx394">Static analysis tools, architecture violations, <a href="#part0049_page_313">313</a></p>
<p class="indexmain" id="part0052_idx395">Static vs. dynamic polymorphism, <a href="#part0032_page_177">177</a></p>
<p class="indexmain" id="part0052_idx396">Strategy pattern</p>
<p class="indexsub">creating one-dimensional boundaries, <a href="#part0038_page_219">219</a></p>
<p class="indexsub">OO approach for cross-cutting concerns, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexmain" id="part0052_idx397">Streams, data</p>
<p class="indexsub">clean architecture and, <a href="#part0039_page_224">224</a>–<a href="#part0039_page_226">226</a></p>
<p class="indexsub">crossing, <a href="#part0039_page_226">226</a></p>
<p class="indexsub">splitting, <a href="#part0039_page_227">227</a>–<a href="#part0039_page_228">228</a></p>
<p class="indexmain" id="part0052_idx398">Structural coupling, testing API, <a href="#part0042_page_252">252</a></p>
<p class="indexmain" id="part0052_idx399">Structure. <em class="calibre9">See</em> <a href="#part0052_idx19">Architecture</a></p>
<p class="indexmain" id="part0052_idx400">Structured programming</p>
<p class="indexsub">Dijkstra’s proclamation on goto statements, <a href="#part0015_page_28">28</a>–<a href="#part0015_page_29">29</a></p>
<p class="indexsub">discipline of proof, <a href="#part0015_page_27">27</a>–<a href="#part0015_page_28">28</a></p>
<p class="indexsub">functional decomposition in, <a href="#part0015_page_29">29</a></p>
<p class="indexsub">history of, <a href="#part0014_page_22">22</a></p>
<p class="indexsub">lack of formal proofs, <a href="#part0015_page_30">30</a></p>
<p class="indexsub">overview of, <a href="#part0015_page_26">26</a></p>
<p class="indexsub">role of science in, <a href="#part0015_page_30">30</a>–<a href="#part0015_page_31">31</a></p>
<p class="indexsub">role of tests in, <a href="#part0015_page_31">31</a></p>
<p class="indexsub">value of, <a href="#part0015_page_31">31</a>–<a href="#part0015_page_32">32</a></p>
<p class="indexmain" id="part0052_idx401">Substitution</p>
<p class="indexsub">LSP. <em class="calibre9">See</em> <a href="#part0052_idx243">LSP (Liskov Substitution Principle)</a></p>
<p class="indexsub">programming to interfaces and, <a href="#part0043_page_271">271</a>–<a href="#part0043_page_272">272</a></p>
<p class="indexmain" id="part0052_idx402">Subtypes, defining, <a href="#part0021_page_78">78</a></p>
<p class="indexmain1"><strong class="calibre8">T</strong></p>
<p class="indexmain" id="part0052_idx403">Target-hardware bottleneck, <a href="#part0043_page_261">261</a>, <a href="#part0043_page_262">262</a>–<a href="#part0043_page_272">272</a></p>
<p class="indexmain" id="part0052_idx404">TAS (Teradyne Applied Systems), <a href="#part0051_page_334">334</a>–<a href="#part0051_page_338">338</a>, <a href="#part0051_page_339">339</a>–<a href="#part0051_page_344">344</a></p>
<p class="indexmain" id="part0052_idx405">Template Method pattern, OO approach for cross-cutting concerns, <a href="#part0041_page_244">244</a>–<a href="#part0041_page_245">245</a></p>
<p class="indexmain" id="part0052_idx406"><a id="part0052_page_398"></a>Test boundary</p>
<p class="indexsub">conclusion, <a href="#part0042_page_253">253</a></p>
<p class="indexsub">designing for testability, <a href="#part0042_page_251">251</a></p>
<p class="indexsub">Fragile Tests Problem, <a href="#part0042_page_251">251</a></p>
<p class="indexsub">overview of, <a href="#part0042_page_249">249</a>–<a href="#part0042_page_250">250</a></p>
<p class="indexsub">testing API, <a href="#part0042_page_252">252</a>–<a href="#part0042_page_253">253</a></p>
<p class="indexsub">tests as system components, <a href="#part0042_page_250">250</a></p>
<p class="indexmain" id="part0052_idx407">Testable architecture</p>
<p class="indexsub">clean architecture creating, <a href="#part0036_page_202">202</a></p>
<p class="indexsub">clean embedded architecture as, <a href="#part0043_page_262">262</a>–<a href="#part0043_page_272">272</a></p>
<p class="indexsub">overview of, <a href="#part0035_page_198">198</a></p>
<p class="indexmain" id="part0052_idx408">Testing</p>
<p class="indexsub">and architecture, <a href="#part0037_page_213">213</a></p>
<p class="indexsub">Presenters and Views, <a href="#part0037_page_212">212</a>–<a href="#part0037_page_213">213</a></p>
<p class="indexsub">in structured programming, <a href="#part0015_page_31">31</a></p>
<p class="indexsub">unit. <em class="calibre9">See</em> <a href="#part0052_idx423">Unit testing</a></p>
<p class="indexsub">via Humble Object pattern, <a href="#part0037_page_212">212</a></p>
<p class="indexmain" id="part0052_idx409">Threads</p>
<p class="indexsub">mutability and, <a href="#part0017_page_52">52</a></p>
<p class="indexsub">schedule/order of execution, <a href="#part0032_page_179">179</a></p>
<p class="indexmain" id="part0052_idx410">Three-tiered “architecture” (as topology), <a href="#part0031_page_161">161</a></p>
<p class="indexmain" id="part0052_idx411">Top-down design, component structure, <a href="#part0027_page_118">118</a>–<a href="#part0027_page_119">119</a></p>
<p class="indexmain" id="part0052_idx412">Transactional memory, <a href="#part0017_page_53">53</a></p>
<p class="indexmain" id="part0052_idx413">Transactions, storing, <a href="#part0017_page_54">54</a>–<a href="#part0017_page_55">55</a></p>
<p class="indexmain" id="part0052_idx414">Transitive dependencies, violating software principles, <a href="#part0020_page_75">75</a></p>
<p class="indexmain" id="part0052_idx415">Trouble tickets, CDS archaeology project, <a href="#part0051_page_362">362</a>–<a href="#part0051_page_364">364</a></p>
<p class="indexmain" id="part0052_idx416">True duplication, <a href="#part0030_page_154">154</a>–<a href="#part0030_page_155">155</a></p>
<p class="indexmain" id="part0052_idx417">Turning, Alan, <a href="#part0014_page_23">23</a></p>
<p class="indexmain1"><strong class="calibre8">U</strong></p>
<p class="indexmain" id="part0052_idx418">UI (user interface). <em class="calibre9">See also</em> <a href="#part0052_idx190">GUI (graphical user interface)</a></p>
<p class="indexsub">applying LSP to, <a href="#part0021_page_80">80</a></p>
<p class="indexsub">clean architecture independent from, <a href="#part0036_page_202">202</a></p>
<p class="indexsub">crossing circle boundaries, <a href="#part0036_page_206">206</a></p>
<p class="indexsub">decoupling business rules from, <a href="#part0046_page_287">287</a>–<a href="#part0046_page_289">289</a></p>
<p class="indexsub">decoupling layers, <a href="#part0030_page_152">152</a>–<a href="#part0030_page_153">153</a></p>
<p class="indexsub">decoupling use cases, <a href="#part0030_page_153">153</a></p>
<p class="indexsub">Hunt the Wumpus adventure game, <a href="#part0039_page_222">222</a>–<a href="#part0039_page_223">223</a></p>
<p class="indexsub">independent developability, <a href="#part0016_page_47">47</a>, <a href="#part0030_page_154">154</a></p>
<p class="indexsub">Interface Segregation Principle, <a href="#part0022_page_84">84</a></p>
<p class="indexsub">programming to, <a href="#part0043_page_271">271</a>–<a href="#part0043_page_272">272</a></p>
<p class="indexsub">reducing volatility of, <a href="#part0023_page_88">88</a></p>
<p class="indexsub">SAC archaeology project, <a href="#part0051_page_346">346</a></p>
<p class="indexmain" id="part0052_idx419">UML class diagram</p>
<p class="indexsub">package by layer, <a href="#part0049_page_304">304</a>–<a href="#part0049_page_305">305</a>, <a href="#part0049_page_310">310</a></p>
<p class="indexsub">ports and adapters, <a href="#part0049_page_308">308</a>–<a href="#part0049_page_310">310</a></p>
<p class="indexsub">relaxed layered architecture, <a href="#part0049_page_311">311</a>–<a href="#part0049_page_312">312</a></p>
<p class="indexmain" id="part0052_idx420">Uncle Bob, <a href="#part0051_page_367">367</a>, <a href="#part0051_page_369">369</a></p>
<p class="indexmain" id="part0052_idx421">UNIFY database system, VRS archaeology project, <a href="#part0051_page_358">358</a>–<a href="#part0051_page_359">359</a></p>
<p class="indexmain" id="part0052_idx422">Union Accounting system, archaeology project, <a href="#part0051_page_326">326</a>–<a href="#part0051_page_334">334</a></p>
<p class="indexmain" id="part0052_idx423">Unit testing</p>
<p class="indexsub">creating testable architecture, <a href="#part0035_page_198">198</a></p>
<p class="indexsub">effect of cycle in component dependency graph, <a href="#part0027_page_116">116</a>–<a href="#part0027_page_117">117</a></p>
<p class="indexsub">via Humble Object pattern, <a href="#part0037_page_212">212</a></p>
<p class="indexmain" id="part0052_idx424">UNIX, IO device driver functions, <a href="#part0016_page_41">41</a>–<a href="#part0016_page_44">44</a></p>
<p class="indexmain" id="part0052_idx425">Upgrades, risks of frameworks, <a href="#part0047_page_293">293</a></p>
<p class="indexmain" id="part0052_idx426">Urgency, Eisenhower’s matrix of importance vs., <a href="#part0012_page_16">16</a>–<a href="#part0012_page_17">17</a></p>
<p class="indexmain" id="part0052_idx427">Use cases</p>
<p class="indexsub">architecture must support, <a href="#part0030_page_148">148</a></p>
<p class="indexsub">business rules for, <a href="#part0034_page_191">191</a>–<a href="#part0034_page_194">194</a></p>
<p class="indexsub">clean architecture scenario, <a href="#part0036_page_207">207</a>–<a href="#part0036_page_208">208</a></p>
<p class="indexsub"><a id="part0052_page_399"></a>coupling to premature decisions with, <a href="#part0031_page_160">160</a></p>
<p class="indexsub">creating testable architecture, <a href="#part0035_page_198">198</a></p>
<p class="indexsub">crossing circle boundaries, <a href="#part0036_page_206">206</a></p>
<p class="indexsub">decoupling, <a href="#part0030_page_152">152</a></p>
<p class="indexsub">decoupling mode, <a href="#part0030_page_153">153</a></p>
<p class="indexsub">Dependency Rule for, <a href="#part0036_page_204">204</a></p>
<p class="indexsub">duplication of, <a href="#part0030_page_155">155</a></p>
<p class="indexsub">good architecture centered on, <a href="#part0035_page_196">196</a>, <a href="#part0035_page_197">197</a></p>
<p class="indexsub">independent developability and, <a href="#part0030_page_154">154</a></p>
<p class="indexsub">video sales case study, <a href="#part0048_page_298">298</a>–<a href="#part0048_page_300">300</a></p>
<p class="indexmain" id="part0052_idx428">User interface</p>
<p class="indexsub">GUI. <em class="calibre9">See</em> <a href="#part0052_idx190">GUI (graphical user interface)</a></p>
<p class="indexsub">UI. <em class="calibre9">See</em> <a href="#part0052_idx418">UI (user interface)</a></p>
<p class="indexmain" id="part0052_idx429">Utility library, Zone of Pain, <a href="#part0027_page_129">129</a></p>
<p class="indexmain" id="part0052_idx430">Uucp connection, <a href="#part0051_page_366">366</a></p>
<p class="indexmain1"><strong class="calibre8">V</strong></p>
<p class="indexmain" id="part0052_idx431">Values, software system</p>
<p class="indexsub">architecture (structure), <a href="#part0012_page_14">14</a>–<a href="#part0012_page_15">15</a></p>
<p class="indexsub">behavior, <a href="#part0012_page_14">14</a></p>
<p class="indexsub">Eisenhower’s matrix of importance vs. urgency, <a href="#part0012_page_16">16</a>–<a href="#part0012_page_17">17</a></p>
<p class="indexsub">fighting for seniority of architecture, <a href="#part0012_page_18">18</a></p>
<p class="indexsub">function vs. architecture, <a href="#part0012_page_15">15</a>–<a href="#part0012_page_16">16</a></p>
<p class="indexsub">overview of, <a href="#part0012_page_14">14</a></p>
<p class="indexmain" id="part0052_idx432">Variables, functional language, <a href="#part0017_page_51">51</a></p>
<p class="indexmain" id="part0052_idx433">Varian 620/f minicomputer, Union Accounting archaeology project, <a href="#part0051_page_331">331</a>–<a href="#part0051_page_334">334</a></p>
<p class="indexmain" id="part0052_idx434">Video sales case study</p>
<p class="indexsub">component architecture, <a href="#part0048_page_300">300</a>–<a href="#part0048_page_302">302</a></p>
<p class="indexsub">conclusion, <a href="#part0048_page_302">302</a></p>
<p class="indexsub">dependency management, <a href="#part0048_page_302">302</a></p>
<p class="indexsub">on process/decisions of good architect, <a href="#part0048_page_297">297</a>–<a href="#part0048_page_298">298</a></p>
<p class="indexsub">product, <a href="#part0048_page_298">298</a></p>
<p class="indexsub">use case analysis, <a href="#part0048_page_298">298</a>–<a href="#part0048_page_300">300</a></p>
<p class="indexmain" id="part0052_idx435">View Model, Presenters and Views, <a href="#part0037_page_213">213</a></p>
<p class="indexmain" id="part0052_idx436">Views</p>
<p class="indexsub">component architecture, <a href="#part0048_page_301">301</a></p>
<p class="indexsub">Presenters and, <a href="#part0037_page_212">212</a>–<a href="#part0037_page_213">213</a></p>
<p class="indexmain" id="part0052_idx437">Vignette Grande, architects registry exam, <a href="#part0051_page_371">371</a>–<a href="#part0051_page_372">372</a></p>
<p class="indexmain" id="part0052_idx438">Visual Studio, plugin argument, <a href="#part0031_page_172">172</a>–<a href="#part0031_page_173">173</a></p>
<p class="indexmain" id="part0052_idx439">Voice technologies, archaeology projects</p>
<p class="indexsub">Electronic Receptionist, <a href="#part0051_page_359">359</a>–<a href="#part0051_page_361">361</a></p>
<p class="indexsub">Voice Response System, <a href="#part0051_page_357">357</a>–<a href="#part0051_page_359">359</a></p>
<p class="indexmain" id="part0052_idx440">Volatile components</p>
<p class="indexsub">dependency graph and, <a href="#part0027_page_118">118</a></p>
<p class="indexsub">design for testability, <a href="#part0042_page_251">251</a></p>
<p class="indexsub">placing in volatile software, <a href="#part0027_page_126">126</a></p>
<p class="indexsub">as problematic in Zone of Pain, <a href="#part0027_page_129">129</a></p>
<p class="indexsub">Stable Dependencies Principle and, <a href="#part0027_page_120">120</a></p>
<p class="indexmain" id="part0052_idx441">Von Neumann, <a href="#part0016_page_34">34</a></p>
<p class="indexmain" id="part0052_idx442">VRS (Voice Response System), archaeology projects, <a href="#part0051_page_357">357</a>–<a href="#part0051_page_359">359</a>, <a href="#part0051_page_362">362</a>–<a href="#part0051_page_363">363</a></p>
<p class="indexmain1"><strong class="calibre8">W</strong></p>
<p class="indexmain" id="part0052_idx443">Web</p>
<p class="indexsub">as delivery system for your application, <a href="#part0035_page_197">197</a>–<a href="#part0035_page_198">198</a></p>
<p class="indexsub">Dependency Rule for, <a href="#part0036_page_205">205</a></p>
<p class="indexsub">is detail, <a href="#part0046_page_285">285</a>–<a href="#part0046_page_289">289</a></p>
<p class="indexmain" id="part0052_idx444">Web servers</p>
<p class="indexsub">creating testable architecture without, <a href="#part0035_page_198">198</a></p>
<p class="indexsub"><a id="part0052_page_400"></a>as option to be left open, <a href="#part0029_page_141">141</a>, <a href="#part0035_page_197">197</a></p>
<p class="indexsub">writing own, <a href="#part0031_page_163">163</a>–<a href="#part0031_page_165">165</a></p>
<p class="indexmain" id="part0052_idx445">Weekly build, <a href="#part0027_page_112">112</a>–<a href="#part0027_page_113">113</a></p>
<p class="indexmain" id="part0052_idx446">Wiki text, architectural success story, <a href="#part0031_page_164">164</a></p>
<p class="indexmain1"><strong class="calibre8">Y</strong></p>
<p class="indexmain" id="part0052_idx447">Yourdon, Ed, <a href="#part0015_page_29">29</a></p>
<p class="indexmain1"><strong class="calibre8">Z</strong></p>
<p class="indexmain" id="part0052_idx448">Zones of exclusion</p>
<p class="indexsub">avoiding, <a href="#part0027_page_130">130</a></p>
<p class="indexsub">relationship between abstraction/stability, <a href="#part0027_page_128">128</a></p>
<p class="indexsub">Zone of Pain, <a href="#part0027_page_129">129</a></p>
<p class="indexsub">Zone of Uselessness, <a href="#part0027_page_129">129</a>–<a href="#part0027_page_130">130</a><a id="part0052_page_401"></a><a id="part0052_page_402"></a><a id="part0052_page_403"></a><a id="part0052_page_404"></a><a id="part0052_page_405"></a><a id="part0052_page_406"></a></p>
</body><body class="calibre">
<p class="image"><img alt="images" class="calibre2" loading="lazy" src="../images/00137.jpeg"/></p>
</body><body class="calibre">
<h2 class="calibre1" id="part0054_split_000_ch5_images">Code Snippets</h2>
<div class="calibre21" id="part0054_split_000_calibre_pb_1"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_001_calibre_pb_2"><a href="#part0016_pch5ex01" id="part0054_split_001_pch5ex01a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00138.jpeg"/></a></div>
<div class="calibre21" id="part0054_split_001_calibre_pb_3"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_002_calibre_pb_4"><a href="#part0016_pch5ex02" id="part0054_split_002_pch5ex02a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00139.jpeg"/></a></div>
<div class="calibre21" id="part0054_split_002_calibre_pb_5"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_003_calibre_pb_6"><a href="#part0016_pch5ex03" id="part0054_split_003_pch5ex03a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00140.jpeg"/></a></div>
<div class="calibre21" id="part0054_split_003_calibre_pb_7"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_004_calibre_pb_8"><a href="#part0016_pch5ex04" id="part0054_split_004_pch5ex04a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00141.jpeg"/></a></div>
<div class="calibre21" id="part0054_split_004_calibre_pb_9"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_005_calibre_pb_10"><a href="#part0016_pch5ex05" id="part0054_split_005_pch5ex05a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00142.jpeg"/></a></div>
<div class="calibre21" id="part0054_split_005_calibre_pb_11"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_006_calibre_pb_12"><a href="#part0016_pch5ex06" id="part0054_split_006_pch5ex06a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00143.jpeg"/></a></div>
<div class="calibre21" id="part0054_split_006_calibre_pb_13"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_007_calibre_pb_14"><a href="#part0016_pch5ex07" id="part0054_split_007_pch5ex07a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00144.jpeg"/></a></div>
<div class="calibre21" id="part0054_split_007_calibre_pb_15"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_008_calibre_pb_16"><a href="#part0016_pch5ex08" id="part0054_split_008_pch5ex08a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00145.jpeg"/></a></div>
<div class="calibre21" id="part0054_split_008_calibre_pb_17"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_009_calibre_pb_18"><a href="#part0016_pch5ex09" id="part0054_split_009_pch5ex09a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00146.jpeg"/></a></div>
<div class="calibre21" id="part0054_split_009_calibre_pb_19"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_010_calibre_pb_20"><a href="#part0016_pch5ex010" id="part0054_split_010_pch5ex010a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00147.jpeg"/></a></div>
<div class="calibre21" id="part0054_split_010_calibre_pb_21"></div>
</body><body class="calibre">
<div class="image-p" id="part0054_split_011_calibre_pb_22"><a href="#part0016_pch5ex011" id="part0054_split_011_pch5ex011a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00148.jpeg"/></a></div>
</body><body class="calibre">
<h2 class="calibre1" id="part0055_split_000_ch6_images">Code Snippets</h2>
<div class="calibre21" id="part0055_split_000_calibre_pb_1"></div>
</body><body class="calibre">
<div class="image-p" id="part0055_split_001_calibre_pb_2"><a href="#part0017_pch6ex01" id="part0055_split_001_pch6ex01a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00149.jpeg"/></a></div>
<div class="calibre21" id="part0055_split_001_calibre_pb_3"></div>
</body><body class="calibre">
<div class="image-p" id="part0055_split_002_calibre_pb_4"><a href="#part0017_pch6ex02" id="part0055_split_002_pch6ex02a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00150.jpeg"/></a></div>
<div class="calibre21" id="part0055_split_002_calibre_pb_5"></div>
</body><body class="calibre">
<div class="image-p" id="part0055_split_003_calibre_pb_6"><a href="#part0017_pch6ex03" id="part0055_split_003_pch6ex03a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00151.jpeg"/></a></div>
<div class="calibre21" id="part0055_split_003_calibre_pb_7"></div>
</body><body class="calibre">
<div class="image-p" id="part0055_split_004_calibre_pb_8"><a href="#part0017_pch6ex04" id="part0055_split_004_pch6ex04a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00152.jpeg"/></a></div>
</body><body class="calibre">
<h2 class="calibre1" id="part0056_split_000_ch9_images">Code Snippets</h2>
<div class="calibre21" id="part0056_split_000_calibre_pb_1"></div>
</body><body class="calibre">
<div class="image-p" id="part0056_split_001_calibre_pb_2"><a href="#part0021_pch9ex01" id="part0056_split_001_pch9ex01a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00153.jpeg"/></a></div>
<div class="calibre21" id="part0056_split_001_calibre_pb_3"></div>
</body><body class="calibre">
<div class="image-p" id="part0056_split_002_calibre_pb_4"><a href="#part0021_pch9ex02" id="part0056_split_002_pch9ex02a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00154.jpeg"/></a></div>
<div class="calibre21" id="part0056_split_002_calibre_pb_5"></div>
</body><body class="calibre">
<div class="image-p" id="part0056_split_003_calibre_pb_6"><a href="#part0021_pch9ex03" id="part0056_split_003_pch9ex03a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00155.jpeg"/></a></div>
<div class="calibre21" id="part0056_split_003_calibre_pb_7"></div>
</body><body class="calibre">
<div class="image-p" id="part0056_split_004_calibre_pb_8"><a href="#part0021_pch9ex04" id="part0056_split_004_pch9ex04a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00156.jpeg"/></a></div>
<div class="calibre21" id="part0056_split_004_calibre_pb_9"></div>
</body><body class="calibre">
<div class="image-p" id="part0056_split_005_calibre_pb_10"><a href="#part0021_pch9ex05" id="part0056_split_005_pch9ex05a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00157.jpeg"/></a></div>
</body><body class="calibre">
<h2 class="calibre1" id="part0057_split_000_ch12_images">Code Snippets</h2>
<div class="calibre21" id="part0057_split_000_calibre_pb_1"></div>
</body><body class="calibre">
<div class="image-p" id="part0057_split_001_calibre_pb_2"><a href="#part0025_pch12ex01" id="part0057_split_001_pch12ex01a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00158.jpeg"/></a></div>
</body><body class="calibre">
<h2 class="calibre1" id="part0058_split_000_ch15_images">Code Snippets</h2>
<div class="calibre21" id="part0058_split_000_calibre_pb_1"></div>
</body><body class="calibre">
<div class="image-p" id="part0058_split_001_calibre_pb_2"><a href="#part0029_pch15ex01" id="part0058_split_001_pch15ex01a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00159.jpeg"/></a></div>
</body><body class="calibre">
<h2 class="calibre1" id="part0059_split_000_ch19_images">Code Snippets</h2>
<div class="calibre21" id="part0059_split_000_calibre_pb_1"></div>
</body><body class="calibre">
<div class="image-p" id="part0059_split_001_calibre_pb_2"><a href="#part0033_pch19ex01" id="part0059_split_001_pch19ex01a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00160.jpeg"/></a></div>
</body><body class="calibre">
<h2 class="calibre1" id="part0060_split_000_ch26_images">Code Snippets</h2>
<div class="calibre21" id="part0060_split_000_calibre_pb_1"></div>
</body><body class="calibre">
<div class="image-p" id="part0060_split_001_calibre_pb_2"><a href="#part0040_pch26ex01" id="part0060_split_001_pch26ex01a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00161.jpeg"/></a></div>
<div class="calibre21" id="part0060_split_001_calibre_pb_3"></div>
</body><body class="calibre">
<div class="image-p" id="part0060_split_002_calibre_pb_4"><a href="#part0040_pch26ex01"><img alt="Image" class="calibre22" loading="lazy" src="../images/00162.jpeg"/></a></div>
<div class="calibre21" id="part0060_split_002_calibre_pb_5"></div>
</body><body class="calibre">
<div class="image-p" id="part0060_split_003_calibre_pb_6"><a href="#part0040_pch26ex01"><img alt="Image" class="calibre22" loading="lazy" src="../images/00163.jpeg"/></a></div>
<div class="calibre21" id="part0060_split_003_calibre_pb_7"></div>
</body><body class="calibre">
<div class="image-p" id="part0060_split_004_calibre_pb_8"><a href="#part0040_pch26ex01"><img alt="Image" class="calibre22" loading="lazy" src="../images/00164.jpeg"/></a></div>
<div class="calibre21" id="part0060_split_004_calibre_pb_9"></div>
</body><body class="calibre">
<div class="image-p" id="part0060_split_005_calibre_pb_10"><a href="#part0040_pch26ex02" id="part0060_split_005_pch26ex02a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00165.jpeg"/></a></div>
<div class="calibre21" id="part0060_split_005_calibre_pb_11"></div>
</body><body class="calibre">
<div class="image-p" id="part0060_split_006_calibre_pb_12"><a href="#part0040_pch26ex02"><img alt="Image" class="calibre22" loading="lazy" src="../images/00166.jpeg"/></a></div>
<div class="calibre21" id="part0060_split_006_calibre_pb_13"></div>
</body><body class="calibre">
<div class="image-p" id="part0060_split_007_calibre_pb_14"><a href="#part0040_pch26ex03" id="part0060_split_007_pch26ex03a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00167.jpeg"/></a></div>
</body><body class="calibre">
<h2 class="calibre1" id="part0061_split_000_ch29_images">Code Snippets</h2>
<div class="calibre21" id="part0061_split_000_calibre_pb_1"></div>
</body><body class="calibre">
<div class="image-p" id="part0061_split_001_calibre_pb_2"><a href="#part0043_pch29ex01" id="part0061_split_001_pch29ex01a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00168.jpeg"/></a></div>
<div class="calibre21" id="part0061_split_001_calibre_pb_3"></div>
</body><body class="calibre">
<div class="image-p" id="part0061_split_002_calibre_pb_4"><a href="#part0043_pch29ex02" id="part0061_split_002_pch29ex02a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00169.jpeg"/></a></div>
<div class="calibre21" id="part0061_split_002_calibre_pb_5"></div>
</body><body class="calibre">
<div class="image-p" id="part0061_split_003_calibre_pb_6"><a href="#part0043_pch29ex03" id="part0061_split_003_pch29ex03a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00170.jpeg"/></a></div>
<div class="calibre21" id="part0061_split_003_calibre_pb_7"></div>
</body><body class="calibre">
<div class="image-p" id="part0061_split_004_calibre_pb_8"><a href="#part0043_pch29ex04" id="part0061_split_004_pch29ex04a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00171.jpeg"/></a></div>
<div class="calibre21" id="part0061_split_004_calibre_pb_9"></div>
</body><body class="calibre">
<div class="image-p" id="part0061_split_005_calibre_pb_10"><a href="#part0043_pch29ex05" id="part0061_split_005_pch29ex05a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00172.jpeg"/></a></div>
<div class="calibre21" id="part0061_split_005_calibre_pb_11"></div>
</body><body class="calibre">
<div class="image-p" id="part0061_split_006_calibre_pb_12"><a href="#part0043_pch29ex06" id="part0061_split_006_pch29ex06a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00173.jpeg"/></a></div>
<div class="calibre21" id="part0061_split_006_calibre_pb_13"></div>
</body><body class="calibre">
<div class="image-p" id="part0061_split_007_calibre_pb_14"><a href="#part0043_pch29ex07" id="part0061_split_007_pch29ex07a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00174.jpeg"/></a></div>
<div class="calibre21" id="part0061_split_007_calibre_pb_15"></div>
</body><body class="calibre">
<div class="image-p" id="part0061_split_008_calibre_pb_16"><a href="#part0043_pch29ex08" id="part0061_split_008_pch29ex08a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00175.jpeg"/></a></div>
<div class="calibre21" id="part0061_split_008_calibre_pb_17"></div>
</body><body class="calibre">
<div class="image-p" id="part0061_split_009_calibre_pb_18"><a href="#part0043_pch29ex09" id="part0061_split_009_pch29ex09a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00176.jpeg"/></a></div>
</body><body class="calibre">
<h2 class="calibre1" id="part0062_split_000_appa_images">Code Snippets</h2>
<div class="calibre21" id="part0062_split_000_calibre_pb_1"></div>
</body><body class="calibre">
<div class="image-p" id="part0062_split_001_calibre_pb_2"><a href="#part0051_pappaex01" id="part0062_split_001_pappaex01a"><img alt="Image" class="calibre22" loading="lazy" src="../images/00177.jpeg"/></a></div>
</body></body></html>