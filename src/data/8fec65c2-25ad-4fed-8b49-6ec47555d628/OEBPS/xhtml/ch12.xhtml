<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>Refactoring: Improving the Design of Existing Code</title>
<link rel="stylesheet" type="text/css" href="9780134757704.css"/>
</head>
<body>
<section epub:type="bodymatter">
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_349"/>Chapter 12<br/>Dealing with Inheritance</h2>
<p class="noindent">In this final chapter, I&#8217;ll turn to one of the best known features of object-oriented programming: inheritance. Like any powerful mechanism, it is both very useful and easy to misuse, and it&#8217;s often hard to see the misuse until it&#8217;s in the rear-view mirror.</p>
<p class="indent">Often, features need to move up or down the inheritance hierarchy. Several refactorings deal with that: <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em>, <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec2">Pull Up Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_353">353</a>)</span></em>, <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec3">Pull Up Constructor Body</a> (<a class="pd_maroon" href="ch12.xhtml#page_355">355</a>)</span></em>, <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec4">Push Down Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_359">359</a>)</span></em>, and <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec5">Push Down Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_361">361</a>)</span></em>. I can add and remove classes from the hierarchy with <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec8">Extract Superclass</a> (<a class="pd_maroon" href="ch12.xhtml#page_375">375</a>)</span></em>, <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec7">Remove Subclass</a> (<a class="pd_maroon" href="ch12.xhtml#page_369">369</a>)</span></em>, and <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec9">Collapse Hierarchy</a> (<a class="pd_maroon" href="ch12.xhtml#page_380">380</a>)</span></em>. I may want to add a subclass to replace a field that I&#8217;m using to trigger different behavior based on its value; I do this with <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec6">Replace Type Code with Subclasses</a> (<a class="pd_maroon" href="ch12.xhtml#page_362">362</a>)</span></em>.</p>
<p class="indent">Inheritance is a powerful tool, but sometimes it gets used in the wrong place&#8212;or the place it&#8217;s used in becomes wrong. In that case, I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec10">Replace Subclass with Delegate</a> (<a class="pd_maroon" href="ch12.xhtml#page_381">381</a>)</span></em> or <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec11">Replace Superclass with Delegate</a> (<a class="pd_maroon" href="ch12.xhtml#page_399">399</a>)</span></em> to turn inheritance into delegation.</p>
<h3 class="h3" id="ch12lev1sec1"><span epub:type="pagebreak" id="page_350"/>Pull Up Method</h3>
<p class="noindent">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec4">Push Down Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_359">359</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0350_01.jpg" aria-describedby="alt_p0350_01" alt="A figure illustrates how the refactoring technique is used to pull up a method."/>
<aside class="hidden" id="alt_p0350_01">
<p>The diagrammatic representation shows a method being pulled up into the superclass from its subclass. The actual code reads, class Employee {...} class Salesman extends Employee { get name() {...} } class Engineer extends Employee { get name() {...} } The code after refactoring reads, class Employee { get name() {...} } class Salesman extends Employee {...} class Engineer extends Employee {...}</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec1">Motivation</h4>
<p class="noindent">Eliminating duplicate code is important. Two duplicate methods may work fine as they are, but they are nothing but a breeding ground for bugs in the future. Whenever there is duplication, there is risk that an alteration to one copy will not be made to the other. Usually, it is difficult to find the duplicates.</p>
<p class="indent">The easiest case of using Pull Up Method is when the methods have the same body, implying there&#8217;s been a copy and paste. Of course it&#8217;s not always as obvious as that. I could just do the refactoring and see if the tests croak&#8212;but that puts a lot of reliance on my tests. I usually find it valuable to look for the differences&#8212;often, they show up behavior that I forgot to test for.</p>
<p class="indent"><span epub:type="pagebreak" id="page_351"/>Often, Pull Up Method comes after other steps. I see two methods in different classes that can be parameterized in such a way that they end up as essentially the same method. In that case, the smallest step is for me to apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec2">Parameterize Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_310">310</a>)</span></em> separately and then Pull Up Method.</p>
<p class="indent">The most awkward complication with Pull Up Method is if the body of the method refers to features that are on the subclass but not on the superclass. When that happens, I need to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec2">Pull Up Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_353">353</a>)</span></em> and Pull Up Method on those elements first.</p>
<p class="indent">If I have two methods with a similar overall flow, but differing in details, I&#8217;ll consider the Form Template Method <span class="pd_maroon">[<a href="biblo.xhtml#bib25">mf-ft</a>]</span>.</p>
<h4 class="h4" id="ch12lev2sec2">Mechanics</h4>
<ul class="square">
<li><p>Inspect methods to ensure they are identical.</p>
<div class="blockquote">
<p class="noindent">If they do the same thing, but are not identical, refactor them until they have identical bodies.</p>
</div></li>
<li><p>Check that all method calls and field references inside the method body refer to features that can be called from the superclass.</p></li>
<li><p>If the methods have different signatures, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to get them to the one you want to use on the superclass.</p></li>
<li><p>Create a new method in the superclass. Copy the body of one of the methods over to it.</p></li>
<li><p>Run static checks.</p></li>
<li><p>Delete one subclass method.</p></li>
<li><p>Test.</p></li>
<li><p>Keep deleting subclass methods until they are all gone.</p></li>
</ul>
<h4 class="h4" id="ch12lev2sec3">Example</h4>
<p class="noindent">I have two subclass methods that do the same thing.</p>
<p class="pro-title"><em>class Employee extends Party&#8230;</em></p>
<p class="codelink"><a id="p0351_01a" href="ch12_images.xhtml#p0351_01">Click here to view code image</a></p>
<pre class="pre">get annualCost() {
  return this.monthlyCost * 12;
}</pre>
<p class="pro-title"><em>class Department extends Party&#8230;</em></p>
<p class="codelink"><a id="p0351_02a" href="ch12_images.xhtml#p0351_02">Click here to view code image</a></p>
<pre class="pre">get totalAnnualCost() {
  return this.monthlyCost * 12;
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_352"/>I look at both classes and see that they refer to the <code>monthlyCost</code> property which isn&#8217;t defined on the superclass, but is present in both subclasses. Since I&#8217;m in a dynamic language, I&#8217;m OK; if I were in a static language, I&#8217;d need to define an abstract method on <code>Party</code>.</p>
<p class="indent">The methods have different names, so I <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to make them the same.</p>
<p class="indent"><em>class Department&#8230;</em></p>
<p class="codelink"><a id="p0352_01a" href="ch12_images.xhtml#p0352_01">Click here to view code image</a></p>
<pre class="pre">get <span class="pd_maroon1">annualCost</span>() {
  return this.monthlyCost * 12;
}</pre>
<p class="indent">I copy the method from one subclass and paste it into the superclass.</p>
<p class="pro-title"><em>class Party&#8230;</em></p>
<p class="codelink"><a id="p0352_02a" href="ch12_images.xhtml#p0352_02">Click here to view code image</a></p>
<pre class="pre">get annualCost() {
  return this.monthlyCost * 12;
}</pre>
<p class="indent">In a static language, I&#8217;d compile to ensure that all the references were OK. That won&#8217;t help me here, so I first remove <code>annualCost</code> from <code>Employee</code>, test, and then remove it from <code>Department</code>.</p>
<p class="indent">That completes the refactoring, but does leave a question. <code>annualCost</code> calls <code>monthlyCost</code>, but <code>monthlyCost</code> doesn&#8217;t appear in the <code>Party</code> class. It all works, because JavaScript is a dynamic language&#8212;but there is value in signaling that subclasses of <code>Party</code> should provide an implementation for <code>monthlyCost</code>, particularly if more subclasses get added later on. A good way to provide this signal is a trap method like this:</p>
<p class="pro-title"><em>class Party&#8230;</em></p>
<p class="codelink"><a id="p0352_03a" href="ch12_images.xhtml#p0352_03">Click here to view code image</a></p>
<pre class="pre">get monthlyCost() {
  throw new SubclassResponsibilityError();
}</pre>
<p class="indent">I call such an error a subclass responsibility error as that was the name used in Smalltalk.</p>
<h3 class="h3" id="ch12lev1sec2"><span epub:type="pagebreak" id="page_353"/>Pull Up Field</h3>
<p class="noindent">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec5">Push Down Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_361">361</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0353_01.jpg" aria-describedby="alt_p0353_01" alt="A figure illustrates how the refactoring technique is used to pull up a field."/>
<aside class="hidden" id="alt_p0353_01">
<p>The diagrammatic representation shows a field pulled up into the superclass from its subclass. The actual code reads, class Employee {...} // Java class Salesman extends Employee { private String name; } class Engineer extends Employee { private String name; } The code after refactoring reads, class Employee { protected String name; } class Salesman extends Employee {...} class Engineer extends Employee {...}</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec4">Motivation</h4>
<p class="noindent">If subclasses are developed independently, or combined through refactoring, I often find that they duplicate features. In particular, certain fields can be duplicates. Such fields sometimes have similar names&#8212;but not always. The only way I can tell what is going on is by looking at the fields and examining how they are used. If they are being used in a similar way, I can pull them up into the superclass.</p>
<p class="indent">By doing this, I reduce duplication in two ways. I remove the duplicate data declaration and I can then move behavior that uses the field from the subclasses to the superclass.</p>
<p class="indent"><span epub:type="pagebreak" id="page_354"/>Many dynamic languages do not define fields as part of their class definition&#8212;instead, fields appear when they are first assigned to. In this case, pulling up a field is essentially a consequence of <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec3">Pull Up Constructor Body</a> (<a class="pd_maroon" href="ch12.xhtml#page_355">355</a>)</span></em>.</p>
<h4 class="h4" id="ch12lev2sec5">Mechanics</h4>
<ul class="square">
<li><p>Inspect all users of the candidate field to ensure they are used in the same way.</p></li>
<li><p>If the fields have different names, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch09.xhtml#ch09lev1sec2">Rename Field</a> (<a class="pd_maroon" href="ch09.xhtml#page_244">244</a>)</span></em> to give them the same name.</p></li>
<li><p>Create a new field in the superclass.</p>
<div class="blockquote">
<p class="noindent">The new field will need to be accessible to subclasses (<code>protected</code> in common languages).</p>
</div></li>
<li><p>Delete the subclass fields.</p></li>
<li><p>Test.</p></li>
</ul>
<h3 class="h3" id="ch12lev1sec3"><span epub:type="pagebreak" id="page_355"/>Pull Up Constructor Body</h3>
<figure class="fig-group">
<img src="graphics/p0355_01.jpg" aria-describedby="alt_p0355_01" alt="A figure illustrates how the refactoring technique is used to pull up a constructor body."/>
<aside class="hidden" id="alt_p0355_01">
<p>The diagrammatic representation shows the constructors being pulled up into the superclass from its subclasses. The actual code reads, class Party {...} class Employee extends Party { constructor(name, id, monthlyCost) { super(); this._id = id; this._name = name; this._monthlyCost = monthlyCost; } } The code after refactoring reads, class Party { constructor(name){ this._name = name; } } class Employee extends Party { constructor(name, id, monthlyCost) { super(name); this._id = id; this._monthlyCost = monthlyCost; } }</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec6"><span epub:type="pagebreak" id="page_356"/>Motivation</h4>
<p class="noindent">Constructors are tricky things. They aren&#8217;t quite normal methods&#8212;so I&#8217;m more restricted in what I can do with them.</p>
<p class="indent">If I see subclass methods with common behavior, my first thought is to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> followed by <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em>, which will move it nicely into the superclass. Constructors tangle that&#8212;because they have special rules about what can be done in what order, so I need a slightly different approach.</p>
<p class="indent">If this refactoring starts getting messy, I reach for <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec8">Replace Constructor with Factory Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_334">334</a>)</span></em>.</p>
<h4 class="h4" id="ch12lev2sec7">Mechanics</h4>
<ul class="square">
<li><p>Define a superclass constructor, if one doesn&#8217;t already exist. Ensure it&#8217;s called by subclass constructors.</p></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec6">Slide Statements</a> (<a class="pd_maroon" href="ch08.xhtml#page_223">223</a>)</span></em> to move any common statements to just after the super call.</p></li>
<li><p>Remove the common code from each subclass and put it in the superclass. Add to the super call any constructor parameters referenced in the common code.</p></li>
<li><p>Test.</p></li>
<li><p>If there is any common code that cannot move to the start of the constructor, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> followed by <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em>.</p></li>
</ul>
<h4 class="h4" id="ch12lev2sec8">Example</h4>
<p class="noindent">I start with the following code:</p>
<p class="codelink"><a id="p0356_01a" href="ch12_images.xhtml#p0356_01">Click here to view code image</a></p>
<pre class="pre"><strong><span class="pd_green">class Party {}</span></strong>

<strong><span class="pd_green">class Employee extends Party {</span></strong>
  constructor(name, id, monthlyCost) {
    super();
    this._id = id;
    this._name = name;
    this._monthlyCost = monthlyCost;
  }
  // rest of class...

<span epub:type="pagebreak" id="page_357"/><strong><span class="pd_green">class Department extends Party {</span></strong>
  constructor(name, staff){
    super();
    this._name = name;
    this._staff = staff;
  }
  // rest of class...</pre>
<p class="indent">The common code here is the assignment of the name. I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec6">Slide Statements</a> (<a class="pd_maroon" href="ch08.xhtml#page_223">223</a>)</span></em> to move the assignment in <code>Employee</code> next to the call to <code>super()</code>:</p>
<p class="codelink"><a id="p0357_01a" href="ch12_images.xhtml#p0357_01">Click here to view code image</a></p>
<pre class="pre">class Employee extends Party {
  <span class="pd_maroon1">constructor(name, id, monthlyCost) {</span>
    super();
    <span class="pd_maroon1">this._name = name;</span>
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
  // rest of class...</pre>
<p class="indent">With that tested, I move the common code to the superclass. Since that code contains a reference to a constructor argument, I pass that in as a parameter.</p>
<p class="pro-title"><em>class Party&#8230;</em></p>
<pre class="pre">constructor(<span class="pd_maroon1">name</span>){
  <span class="pd_maroon1">this._name = name;</span>
}</pre>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0357_02a" href="ch12_images.xhtml#p0357_02">Click here to view code image</a></p>
<pre class="pre">constructor(name, id, monthlyCost) {
  super(<span class="pd_maroon1">name</span>);
  this._id = id;
  this._monthlyCost = monthlyCost;
}</pre>
<p class="pro-title"><em>class Department&#8230;</em></p>
<pre class="pre">constructor(name, staff){
  super(<span class="pd_maroon1">name</span>);
  this._staff = staff;
}</pre>
<p class="indent">Run the tests, and I&#8217;m done.</p>
<p class="indent">Most of the time, constructor behavior will work like this: Do the common elements first (with a <code>super</code> call), then do extra work that the subclass needs. Occasionally, however, there is some common behavior later.</p>
<p class="indent">Consider this example:</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_358"/><em>class Employee&#8230;</em></p>
<pre class="pre">constructor (name) {...}

get isPrivileged() {...}

assignCar() {...}</pre>
<p class="pro-title"><em>class Manager extends Employee&#8230;</em></p>
<p class="codelink"><a id="p0358_01a" href="ch12_images.xhtml#p0358_01">Click here to view code image</a></p>
<pre class="pre">constructor(name, grade) {
  super(name);
  this._grade = grade;
  if (this.isPrivileged) this.assignCar(); // every subclass does this
}

get isPrivileged() {
  return this._grade &gt; 4;
}</pre>
<p class="indent">The wrinkle here comes from the fact that the call to <code>isPrivileged</code> can&#8217;t be made until after the <code>grade</code> field is assigned, and that can only be done in the subclass.</p>
<p class="indent">In this case, I do <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the common code:</p>
<p class="pro-title"><em>class Manager&#8230;</em></p>
<p class="codelink"><a id="p0358_02a" href="ch12_images.xhtml#p0358_02">Click here to view code image</a></p>
<pre class="pre">constructor(name, grade) {
  super(name);
  this._grade = grade;
  this.<span class="pd_maroon1">finishConstruction</span>();
}

<span class="pd_maroon1">finishConstruction</span>() {
  if (this.isPrivileged) this.assignCar();
}</pre>
<p class="indent">Then, I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em> to move it to the superclass.</p>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0358_03a" href="ch12_images.xhtml#p0358_03">Click here to view code image</a></p>
<pre class="pre">finishConstruction() {
  if (this.isPrivileged) this.assignCar();
}</pre>
<h3 class="h3" id="ch12lev1sec4"><span epub:type="pagebreak" id="page_359"/>Push Down Method</h3>
<p class="noindent">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0359_01.jpg" aria-describedby="alt_p0359_01" alt="A figure illustrates how the refactoring technique is used to push down a method."/>
<aside class="hidden" id="alt_p0359_01">
<p>The diagrammatic representation shows a method from the superclass being pushed down to its subclass. The actual code reads, class Employee { get quota {...} } class Engineer extends Employee {...} class Salesman extends Employee {...} The code after refactoring reads, class Employee {...} class Engineer extends Employee {...} class Salesman extends Employee { get quota {...} }</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec9">Motivation</h4>
<p class="noindent">If a method is only relevant to one subclass (or a small proportion of subclasses), removing it from the superclass and putting it only on the subclass(es) makes that clearer. I can only do this refactoring if the caller knows it&#8217;s working with a particular subclass&#8212;otherwise, I should use <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec4">Replace Conditional with Polymorphism</a> (<a class="pd_maroon" href="ch10.xhtml#page_272">272</a>)</span></em> with some placebo behavior on the superclass.</p>
<h4 class="h4" id="ch12lev2sec10">Mechanics</h4>
<ul class="square">
<li><p>Copy the method into every subclass that needs it.</p></li>
<li><p>Remove the method from the superclass.</p></li>
<li><p><span epub:type="pagebreak" id="page_360"/>Test.</p></li>
<li><p>Remove the method from each superclass that doesn&#8217;t need it.</p></li>
<li><p>Test.</p></li>
</ul>
<h3 class="h3" id="ch12lev1sec5"><span epub:type="pagebreak" id="page_361"/>Push Down Field</h3>
<p class="noindent">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec2">Pull Up Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_353">353</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0361_01.jpg" aria-describedby="alt_p0361_01" alt="A figure illustrates how the refactoring technique is used to push down a field."/>
<aside class="hidden" id="alt_p0361_01">
<p>The diagrammatic representation shows a field from the superclass being pushed down to its subclass. The actual code reads, class Employee { // Java private String quota; } class Engineer extends Employee {...} class Salesman extends Employee {...} The code after refactoring reads, class Employee {...} class Engineer extends Employee {...} class Salesman extends Employee { protected String quota; }</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec11">Motivation</h4>
<p class="noindent">If a field is only used by one subclass (or a small proportion of subclasses), I move it to those subclasses.</p>
<h4 class="h4" id="ch12lev2sec12">Mechanics</h4>
<ul class="square">
<li><p>Declare field in all subclasses that need it.</p></li>
<li><p>Remove the field from the superclass.</p></li>
<li><p>Test.</p></li>
<li><p>Remove the field from all subclasses that don&#8217;t need it.</p></li>
<li><p>Test.</p></li>
</ul>
<h3 class="h3" id="ch12lev1sec6"><span epub:type="pagebreak" id="page_362"/>Replace Type Code with Subclasses</h3>
<p class="noindent">subsumes: <em>Replace Type Code with State/Strategy</em></p>
<p class="noindentz">subsumes: <em>Extract Subclass</em></p>
<p class="noindentz">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec7">Remove Subclass</a> (<a class="pd_maroon" href="ch12.xhtml#page_369">369</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0362_01.jpg" aria-describedby="alt_p0362_01" alt="A figure illustrates how the refactoring technique is used to replace type code with subclasses."/>
<aside class="hidden" id="alt_p0362_01">
<p>The diagrammatic representation shows the type code (enum, symbol, string, or number) created for its subclasses. The actual code reads, function createEmployee(name, type) { return new Employee(name, type); } The code after refactoring reads, function createEmployee(name, type) { switch (type) { case &#34;engineer&#34;: return new Engineer(name); case &#34;salesman&#34;: return new Salesman(name); case &#34;manager&#34;: return new Manager (name); }</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec13">Motivation</h4>
<p class="noindent">Software systems often need to represent different kinds of a similar thing. I may classify employees by their job type (engineer, manager, salesman), or orders by their priority (rush, regular). My first tool for handling this is some kind of type code field&#8212;depending on the language, that might be an enum, symbol, string, or number. Often, this type code will come from an external service that provides me with the data I&#8217;m working on.</p>
<p class="indent">Most of the time, such a type code is all I need. But there are a couple of situations where I could do with something more, and that something more are subclasses. There are two things that are particularly enticing about subclasses. First, they allow me to use polymorphism to handle conditional logic. I find this <span epub:type="pagebreak" id="page_363"/>most helpful when I have several functions that invoke different behavior depending on the value of the type code. With subclasses, I can apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec4">Replace Conditional with Polymorphism</a> (<a class="pd_maroon" href="ch10.xhtml#page_272">272</a>)</span></em> to these functions.</p>
<p class="indent">The second case is where I have fields or methods that are only valid for particular values of a type code, such as a sales quota that&#8217;s only applicable to the &#8220;salesman&#8221; type code. I can then create the subclass and apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec5">Push Down Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_361">361</a>)</span></em>. While I can include validation logic to ensure a field is only used when the type code has the correct value, using a subclass makes the relationship more explicit.</p>
<p class="indent">When using Replace Type Code with Subclasses, I need to consider whether to apply it directly to the class I&#8217;m looking at, or to the type code itself. Do I make engineer a subtype of employee, or should I give the employee an employee type property which can have subtypes for engineer and manager? Using direct subclassing is simpler, but I can&#8217;t use it for the job type if I need it for something else. I also can&#8217;t use direct subclasses if the type is mutable. If I need to move the subclasses to an employee type property, I can do that by using <em><span class="pd_maroon"><a class="pd_maroon" href="ch07.xhtml#ch07lev1sec3">Replace Primitive with Object</a> (<a class="pd_maroon" href="ch07.xhtml#page_174">174</a>)</span></em> on the type code to create an employee type class and then using Replace Type Code with Subclasses on that new class.</p>
<h4 class="h4" id="ch12lev2sec14">Mechanics</h4>
<ul class="square">
<li><p>Self-encapsulate the type code field.</p></li>
<li><p>Pick one type code value. Create a subclass for that type code. Override the type code getter to return the literal type code value.</p></li>
<li><p>Create selector logic to map from the type code parameter to the new subclass.</p>
<div class="blockquote">
<p class="noindent">With direct inheritance, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec8">Replace Constructor with Factory Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_334">334</a>)</span></em> and put the selector logic in the factory. With indirect inheritance, the selector logic may stay in the constructor.</p>
</div></li>
<li><p>Test.</p></li>
<li><p>Repeat creating the subclass and adding to the selector logic for each type code value. Test after each change.</p></li>
<li><p>Remove the type code field.</p></li>
<li><p>Test.</p></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec4">Push Down Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_359">359</a>)</span></em> and <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec4">Replace Conditional with Polymorphism</a> (<a class="pd_maroon" href="ch10.xhtml#page_272">272</a>)</span></em> on any methods that use the type code accessors. Once all are replaced, you can remove the type code accessors.</p></li>
</ul>
<h4 class="h4" id="ch12lev2sec15"><span epub:type="pagebreak" id="page_364"/>Example</h4>
<p class="noindent">I&#8217;ll start with this overused employee example:</p>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0364_01a" href="ch12_images.xhtml#p0364_01">Click here to view code image</a></p>
<pre class="pre">constructor(name, type){
  this.validateType(type);
  this._name = name;
  this._type = type;
}
validateType(arg) {
  if (!["engineer", "manager", "salesman"].includes(arg))
    throw new Error(`Employee cannot be of type ${arg}`);
}
toString() {return `${this._name} (${this._type})`;}</pre>
<p class="indent">My first step is to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec6">Encapsulate Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_132">132</a>)</span></em> to self-encapsulate the type code.</p>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0364_02a" href="ch12_images.xhtml#p0364_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get type() {return this._type;}</span>
toString() {return `${this._name} (${this.type})`;}</pre>
<div class="blockquote">
<p class="noindent"><span class="pd_brown"><em>Note that</em> <code>toString</code> <em>uses the new getter by removing the underscore.</em></span></p>
</div>
<p class="indent">I pick one type code, the engineer, to start with. I use direct inheritance, subclassing the employee class itself. The employee subclass is simple&#8212;just overriding the type code getter with the appropriate literal value.</p>
<p class="codelink"><a id="p0364_03a" href="ch12_images.xhtml#p0364_03">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">class Engineer extends Employee {</span>
  <span class="pd_maroon1">get type() {return "engineer";}</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">Although JavaScript constructors can return other objects, things will get messy if I try to put selector logic in there, since that logic gets intertwined with field initialization. So I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec8">Replace Constructor with Factory Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_334">334</a>)</span></em> to create a new space for it.</p>
<p class="codelink"><a id="p0364_04a" href="ch12_images.xhtml#p0364_04">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">function createEmployee(name, type) {</span>
  <span class="pd_maroon1">return new Employee(name, type);</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">To use the new subclass, I add selector logic into the factory.</p>
<p class="codelink"><a id="p0364_05a" href="ch12_images.xhtml#p0364_05">Click here to view code image</a></p>
<pre class="pre">function createEmployee(name, type) {
  <span class="pd_maroon1">switch (type) {</span>
    <span class="pd_maroon1">case "engineer": return new Engineer(name, type);</span>
  <span class="pd_maroon1">}</span>
  return new Employee(name, type);
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_365"/>I test to ensure that worked out correctly. But, because I&#8217;m paranoid, I then alter the return value of the engineer&#8217;s override and test again to ensure the test fails. That way I know the subclass is being used. I correct the return value and continue with the other cases. I can do them one at a time, testing after each change.</p>
<p class="codelink"><a id="p0365_01a" href="ch12_images.xhtml#p0365_01">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">class Salesman extends Employee {</span>
  <span class="pd_maroon1">get type() {return "salesman";}</span>
<span class="pd_maroon1">}</span>

<span class="pd_maroon1">class Manager extends Employee {</span>
  <span class="pd_maroon1">get type() {return "manager";}</span>
<span class="pd_maroon1">}</span>

function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
    <span class="pd_maroon1">case "salesman": return new Salesman(name, type);</span>
    <span class="pd_maroon1">case "manager":  return new Manager (name, type);</span>
  }
  return new Employee(name, type);
}</pre>
<p class="indent">Once I&#8217;m done with them all, I can remove the type code field and the superclass getting method (the ones in the subclasses remain).</p>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0365_02a" href="ch12_images.xhtml#p0365_02">Click here to view code image</a></p>
<pre class="pre">constructor(name, type){
  this.validateType(type);
  this._name = name;
  <span class="strike"><span class="pd_maroon1">this._type = type;</span></span>
}

<span class="strike"><span class="pd_maroon1">get type() {return this._type;}</span></span>
toString() {return `${this._name} (${this.type})`;}</pre>
<p class="indent">After testing to ensure all is still well, I can remove the validation logic, since the switch is effectively doing the same thing.</p>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0365_03a" href="ch12_images.xhtml#p0365_03">Click here to view code image</a></p>
<pre class="pre">constructor(name, type){
  <span class="strike"><span class="pd_maroon1">this.validateType(type);</span></span>
  this._name = name;
}

<span epub:type="pagebreak" id="page_366"/>function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
    case "salesman": return new Salesman(name, type);
    case "manager":  return new Manager (name, type);
    <span class="pd_maroon1">default: throw new Error(`Employee cannot be of type ${type}`);</span>
  }
  <span class="strike"><span class="pd_maroon1">return new Employee(name, type);</span></span>
}</pre>
<p class="indent">The type argument to the constructor is now useless, so it falls victim to <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em>.</p>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0366_01a" href="ch12_images.xhtml#p0366_01">Click here to view code image</a></p>
<pre class="pre">constructor(name<span class="strike"><span class="pd_maroon1">, type</span></span>){
  this._name = name;
}

function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name<span class="strike"><span class="pd_maroon1">, type</span></span>);
    case "salesman": return new Salesman(name<span class="strike"><span class="pd_maroon1">, type</span></span>);
    case "manager":  return new Manager (name<span class="strike"><span class="pd_maroon1">, type</span></span>);
    default: throw new Error(`Employee cannot be of type ${type}`);
  }
}</pre>
<p class="indent">I still have the type code accessors on the subclasses&#8212;<code>get type</code>. I&#8217;ll usually want to remove these too, but that may take a bit of time due to other methods that depend on them. I&#8217;ll use <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec4">Replace Conditional with Polymorphism</a> (<a class="pd_maroon" href="ch10.xhtml#page_272">272</a>)</span></em> and <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec4">Push Down Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_359">359</a>)</span></em> to deal with these. At some point, I&#8217;ll have no code that uses the <code>type</code> getters, so I will subject them to the tender mercies of <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec9">Remove Dead Code</a> (<a class="pd_maroon" href="ch08.xhtml#page_237">237</a>)</span></em>.</p>
<h4 class="h4" id="ch12lev2sec16">Example: Using Indirect Inheritance</h4>
<p class="noindent">Let&#8217;s go back to the starting case&#8212;but this time, I already have existing subclasses for part-time and full-time employees, so I can&#8217;t subclass from <code>Employee</code> for the type codes. Another reason to not use direct inheritance is keeping the ability to change the type of employee.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_367"/><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0367_01a" href="ch12_images.xhtml#p0367_01">Click here to view code image</a></p>
<pre class="pre">constructor(name, type){
  this.validateType(type);
  this._name = name;
  this._type = type;
}
validateType(arg) {
  if (!["engineer", "manager", "salesman"].includes(arg))
    throw new Error(`Employee cannot be of type ${arg}`);
}
get type()    {return this._type;}
set type(arg) {this._type = arg;}

get capitalizedType() {
  return this._type.charAt(0).toUpperCase() + this._type.substr(1).toLowerCase();
}
toString() {
  return `${this._name} (${this.capitalizedType})`;
}</pre>
<p class="indent">This time <code>toString</code> is a bit more complicated, to allow me to illustrate something shortly.</p>
<p class="indent">My first step is to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch07.xhtml#ch07lev1sec3">Replace Primitive with Object</a> (<a class="pd_maroon" href="ch07.xhtml#page_174">174</a>)</span></em> on the type code.</p>
<p class="codelink"><a id="p0367_02a" href="ch12_images.xhtml#p0367_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">class EmployeeType {</span>
  <span class="pd_maroon1">constructor(aString) {</span>
    <span class="pd_maroon1">this._value = aString;</span>
  <span class="pd_maroon1">}</span>
  <span class="pd_maroon1">toString() {return this._value;}</span>
<span class="pd_maroon1">}</span></pre>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0367_03a" href="ch12_images.xhtml#p0367_03">Click here to view code image</a></p>
<pre class="pre">constructor(name, type){
  this.validateType(type);
  this._name = name;
  this.type = type;
}
validateType(arg) {
  if (!["engineer", "manager", "salesman"].includes(arg))
    throw new Error(`Employee cannot be of type ${arg}`);
}
get <span class="pd_maroon1">typeString</span>()    {return this._type.toString();}
get type()    {return this._type;}
set type(arg) {this._type = new EmployeeType(arg);}

get capitalizedType() {
  return this.<span class="pd_maroon1">typeString</span>.charAt(0).toUpperCase()
    + this.<span class="pd_maroon1">typeString</span>.substr(1).toLowerCase();
}
<span epub:type="pagebreak" id="page_368"/>toString() {
  return `${this._name} (${this.capitalizedType})`;
}</pre>
<p class="indent">I then apply the usual mechanics of Replace Type Code with Subclasses to the employee type.</p>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0368_01a" href="ch12_images.xhtml#p0368_01">Click here to view code image</a></p>
<pre class="pre">set type(arg) {this._type = <span class="pd_maroon1">Employee.createEmployeeType</span>(arg);}

  <span class="pd_maroon1">static createEmployeeType(aString) {</span>
    <span class="pd_maroon1">switch(aString) {</span>
      <span class="pd_maroon1">case "engineer": return new Engineer();</span>
      <span class="pd_maroon1">case "manager": return new Manager ();</span>
      <span class="pd_maroon1">case "salesman": return new Salesman();</span>
      <span class="pd_maroon1">default: throw new Error(`Employee cannot be of type ${aString}`);</span>
    <span class="pd_maroon1">}</span>
  <span class="pd_maroon1">}</span>

<span class="pd_maroon1">class EmployeeType {</span>
<span class="pd_maroon1">}</span>
<span class="pd_maroon1">class Engineer extends EmployeeType {</span>
  <span class="pd_maroon1">toString() {return "engineer";}</span>
<span class="pd_maroon1">}</span>
<span class="pd_maroon1">class Manager extends EmployeeType {</span>
  <span class="pd_maroon1">toString() {return "manager";}</span>
<span class="pd_maroon1">}</span>
<span class="pd_maroon1">class Salesman extends EmployeeType {</span>
  <span class="pd_maroon1">toString() {return "salesman";}</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">If I were leaving it at that, I could remove the empty <code>EmployeeType</code>. But I prefer to leave it there as it makes explicit the relationship between the various subclasses. It&#8217;s also a handy spot for moving other behavior there, such as the capitalization logic I tossed into the example specifically to illustrate this point.</p>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0368_02a" href="ch12_images.xhtml#p0368_02">Click here to view code image</a></p>
<pre class="pre">toString() {
  return `${this._name} (${this.type.<span class="pd_maroon1">capitalizedName</span>})`;
}</pre>
<p class="pro-title"><em>class EmployeeType&#8230;</em></p>
<p class="codelink"><a id="p0368_03a" href="ch12_images.xhtml#p0368_03">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get capitalizedName() {</span>
  return this.<span class="pd_maroon1">toString</span>().charAt(0).toUpperCase()
    + this.<span class="pd_maroon1">toString</span>().substr(1).toLowerCase();
}</pre>
<div class="blockquote">
<p class="noindent">For those familiar with the first edition of the book, this example essentially supersedes the Replace Type Code with State/Strategy. I now think of that refactoring as Replace Type Code with Subclasses using indirect inheritance, so didn&#8217;t consider it worth its own entry in the catalog. (I never liked the name anyway.)</p>
</div>
<h3 class="h3" id="ch12lev1sec7"><span epub:type="pagebreak" id="page_369"/>Remove Subclass</h3>
<p class="noindent">formerly: <em>Replace Subclass with Fields</em></p>
<p class="noindentz">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec6">Replace Type Code with Subclasses</a> (<a class="pd_maroon" href="ch12.xhtml#page_362">362</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0369_01.jpg" aria-describedby="alt_p0369_01" alt="A figure illustrates how the refactoring technique is used to remove a subclass."/>
<aside class="hidden" id="alt_p0369_01">
<p>The diagrammatic representation shows a subclass being removed. The actual code reads, class Person { get genderCode() {return &#34;X&#34;;} } class Male extends Person { get genderCode() {return &#34;M&#34;;} } class Female extends Person { get genderCode() {return &#34;F&#34;;} } The code after refactoring reads, class Person { get genderCode() {return this._genderCode;} }</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec17">Motivation</h4>
<p class="noindent">Subclasses are useful. They support variations in data structure and polymorphic behavior. They are a good way to program by difference. But as a software system evolves, subclasses can lose their value as the variations they support are moved to other places or removed altogether. Sometimes, subclasses are added in anticipation of features that never end up being built, or end up being built in a way that doesn&#8217;t need the subclasses.</p>
<p class="indent">A subclass that does too little incurs a cost in understanding that is no longer worthwhile. When that time comes, it&#8217;s best to remove the subclass, replacing it with a field on its superclass.</p>
<h4 class="h4" id="ch12lev2sec18"><span epub:type="pagebreak" id="page_370"/>Mechanics</h4>
<ul class="square">
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec8">Replace Constructor with Factory Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_334">334</a>)</span></em> on the subclass constructor.</p>
<div class="blockquote">
<p class="noindent">If the clients of the constructors use a data field to decide which subclass to create, put that decision logic into a superclass factory method.</p>
</div></li>
<li><p>If any code tests against the subclass&#8217;s types, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the type test and <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em> to move it to the superclass. Test after each change.</p></li>
<li><p>Create a field to represent the subclass type.</p></li>
<li><p>Change the methods that refer to the subclass to use the new type field.</p></li>
<li><p>Delete the subclass.</p></li>
<li><p>Test.</p></li>
</ul>
<p class="indent">Often, this refactoring is used on a group of subclasses at once&#8212;in which case carry out the steps to encapsulate them (add factory function, move type tests) first, then individually fold them into the superclass.</p>
<h4 class="h4" id="ch12lev2sec19">Example</h4>
<p class="noindent">I&#8217;ll start with this stump of subclasses:</p>
<p class="pro-title"><em>class Person&#8230;</em></p>
<p class="codelink"><a id="p0370_01a" href="ch12_images.xhtml#p0370_01">Click here to view code image</a></p>
<pre class="pre">constructor(name) {
  this._name = name;
}
get name()    {return this._name;}
get genderCode() {return "X";}
// snip

class Male extends Person {
  get genderCode() {return "M";}
}

class Female extends Person {
  get genderCode() {return "F";}
}</pre>
<p class="indent">If that&#8217;s all that a subclass does, it&#8217;s not really worth having. But before I remove these subclasses, it&#8217;s usually worth checking to see if there&#8217;s any subclass-dependent behavior in the clients that should be moved in there. In this case, I don&#8217;t find anything worth keeping the subclasses for.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_371"/><em>client&#8230;</em></p>
<p class="codelink"><a id="p0371_01a" href="ch12_images.xhtml#p0371_01">Click here to view code image</a></p>
<pre class="pre">const numberOfMales = people.filter(p =&gt; p instanceof Male).length;</pre>
<p class="indent">Whenever I want to change how I represent something, I try to first encapsulate the current representation to minimize the impact on any client code. When it comes to creating subclasses, the way to encapsulate is to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec8">Replace Constructor with Factory Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_334">334</a>)</span></em>. In this case, there&#8217;s a couple of ways I could make the factory.</p>
<p class="indent">The most direct way is to create a factory method for each constructor.</p>
<p class="codelink"><a id="p0371_02a" href="ch12_images.xhtml#p0371_02">Click here to view code image</a></p>
<pre class="pre">function createPerson(name) {
  return new Person(name);
}
function createMale(name) {
  return new Male(name);
}
function createFemale(name) {
  return new Female(name);
}</pre>
<p class="indent">But although that&#8217;s the direct choice, objects like this are often loaded from a source that uses the gender codes directly.</p>
<p class="codelink"><a id="p0371_03a" href="ch12_images.xhtml#p0371_03">Click here to view code image</a></p>
<pre class="pre">function loadFromInput(data) {
  const result = [];
  data.forEach(aRecord =&gt; {
    let p;
    switch (aRecord.gender) {
      case 'M': p = new Male(aRecord.name); break;
      case 'F': p = new Female(aRecord.name); break;
      default: p = new Person(aRecord.name);
    }
    result.push(p);
  });
  return result;
}</pre>
<p class="indent">In that case, I find it better to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the selection logic for which class to create, and make that the factory function.</p>
<p class="codelink"><a id="p0371_04a" href="ch12_images.xhtml#p0371_04">Click here to view code image</a></p>
<pre class="pre">function <span class="pd_maroon1">createPerson</span>(aRecord) {
  let p;
  switch (aRecord.gender) {
    case 'M': p = new Male(aRecord.name); break;
    case 'F': p = new Female(aRecord.name); break;
    default: p = new Person(aRecord.name);
  }
  return p;
}

<span epub:type="pagebreak" id="page_372"/>function loadFromInput(data) {
  const result = [];
  data.forEach(aRecord =&gt; {
    result.push(<span class="pd_maroon1">createPerson</span>(aRecord));
  });
  return result;
}</pre>
<p class="indent">While I&#8217;m there, I&#8217;ll clean up those two functions. I&#8217;ll use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec4">Inline Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_123">123</a>)</span></em> on <code>createPerson</code>:</p>
<p class="codelink"><a id="p0372_01a" href="ch12_images.xhtml#p0372_01">Click here to view code image</a></p>
<pre class="pre">function createPerson(aRecord) {
  switch (aRecord.gender) {
    case 'M': <span class="pd_maroon1">return</span> new Male  (aRecord.name);
    case 'F': <span class="pd_maroon1">return</span> new Female(aRecord.name);
    default:  <span class="pd_maroon1">return</span> new Person(aRecord.name);
  }
}</pre>
<p class="noindent">and <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec8">Replace Loop with Pipeline</a> (<a class="pd_maroon" href="ch08.xhtml#page_231">231</a>)</span></em> on <code>loadFromInput</code>:</p>
<p class="codelink"><a id="p0372_02a" href="ch12_images.xhtml#p0372_02">Click here to view code image</a></p>
<pre class="pre">function loadFromInput(data) {
  return data.<span class="pd_maroon1">map(aRecord =&gt; createPerson(aRecord));</span>
}</pre>
<p class="indent">The factory encapsulates the creation of the subclasses, but there is also the use of <code>instanceof</code>&#8212;which never smells good. I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the type check.</p>
<p class="pro-title"><em>client&#8230;</em></p>
<p class="codelink"><a id="p0372_03a" href="ch12_images.xhtml#p0372_03">Click here to view code image</a></p>
<pre class="pre">const numberOfMales = people.filter(p =&gt; <span class="pd_maroon1">isMale</span>(p)).length;

function <span class="pd_maroon1">isMale</span>(aPerson) {return aPerson instanceof Male;}</pre>
<p class="indent">Then I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em> to move it into <code>Person</code>.</p>
<p class="pro-title"><em>class Person&#8230;</em></p>
<p class="codelink"><a id="p0372_04a" href="ch12_images.xhtml#p0372_04">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get isMale() {return this instanceof Male;}</span></pre>
<p class="pro-title"><em>client&#8230;</em></p>
<p class="codelink"><a id="p0372_05a" href="ch12_images.xhtml#p0372_05">Click here to view code image</a></p>
<pre class="pre">const numberOfMales = people.filter(p =&gt; <span class="pd_maroon1">p.isMale</span>).length;</pre>
<p class="indent">With that refactoring done, all knowledge of the subclasses is now safely encased within the superclass and the factory function. (Usually I&#8217;m wary of a superclass referring to a subclass, but this code isn&#8217;t going to last until my next cup of tea, so I&#8217;m not going worry about it.)</p>
<p class="indent">I now add a field to represent the difference between the subclasses; since I&#8217;m using a code loaded from elsewhere, I might as well just use that.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_373"/><em>class Person&#8230;</em></p>
<p class="codelink"><a id="p0373_01a" href="ch12_images.xhtml#p0373_01">Click here to view code image</a></p>
<pre class="pre">constructor(name, genderCode) {
  this._name = name;
  <span class="pd_maroon1">this._genderCode = genderCode || "X";</span>
}

get genderCode() {return <span class="pd_maroon1">this._genderCode</span>;}</pre>
<p class="indent">When initializing it, I set it to the default case. (As a side note, although most people can be classified as male or female, there are people who can&#8217;t. It&#8217;s a common modeling mistake to forget that.)</p>
<p class="indent">I then take the male case and fold its logic into the superclass. This involves modifying the factory to return a <code>Person</code> and modifying any <code>instanceof</code> tests to use the gender code field.</p>
<p class="codelink"><a id="p0373_02a" href="ch12_images.xhtml#p0373_02">Click here to view code image</a></p>
<pre class="pre">function createPerson(aRecord) {
  switch (aRecord.gender) {
    case 'M': return new <span class="pd_maroon1">Person(aRecord.name, "M")</span>;
    case 'F': return new Female(aRecord.name);
    default:  return new Person(aRecord.name);
  }
}</pre>
<p class="pro-title"><em>class Person&#8230;</em></p>
<p class="codelink"><a id="p0373_03a" href="ch12_images.xhtml#p0373_03">Click here to view code image</a></p>
<pre class="pre">get isMale() {return <span class="pd_maroon1">"M" === this._genderCode</span>;}</pre>
<p class="indent">I test, remove the male subclass, test again, and repeat for the female subclass.</p>
<p class="codelink"><a id="p0373_04a" href="ch12_images.xhtml#p0373_04">Click here to view code image</a></p>
<pre class="pre">function createPerson(aRecord) {
  switch (aRecord.gender) {
    case 'M': return new Person(aRecord.name, "M");
    case 'F': return new <span class="pd_maroon1">Person(aRecord.name, "F")</span>;
    default:  return new Person(aRecord.name);
  }
}</pre>
<p class="indent">I find the lack of symmetry with the gender code to be annoying. A future reader of the code will always wonder about this lack of symmetry. So I prefer to change the code to make it symmetrical&#8212;if I can do it without introducing any other complexity, which is the case here.</p>
<p class="codelink"><a id="p0373_05a" href="ch12_images.xhtml#p0373_05">Click here to view code image</a></p>
<pre class="pre">function createPerson(aRecord) {
  switch (aRecord.gender) {
    case 'M': return new Person(aRecord.name, "M");
    case 'F': return new Person(aRecord.name, "F");
    default:  return new Person(aRecord.name<span class="pd_maroon1">, "X"</span>);
  }
}</pre>
<p class="pro-title"><span epub:type="pagebreak" id="page_374"/><em>class Person&#8230;</em></p>
<p class="codelink"><a id="p0374_01a" href="ch12_images.xhtml#p0374_01">Click here to view code image</a></p>
<pre class="pre">constructor(name, genderCode) {
  this._name = name;
  this._genderCode = genderCode <span class="strike"><span class="pd_maroon1">|| "X"</span></span>;
}</pre>
<h3 class="h3" id="ch12lev1sec8"><span epub:type="pagebreak" id="page_375"/>Extract Superclass</h3>
<figure class="fig-group">
<img src="graphics/p0375_01.jpg" aria-describedby="alt_p0375_01" alt="A figure illustrates how the refactoring technique is used to extract a superclass."/>
<aside class="hidden" id="alt_p0375_01">
<p>The diagrammatic representation shows a superclass inheriting the common features of its subclasses. The actual code reads, class Department { get totalAnnualCost() {...} get name() {...} get headCount() {...} } class Employee { get annualCost() {...} get name() {...} get id() {...} } The code after refactoring reads, class Party { get name() {...} get annualCost() {...} } class Department extends Party { get annualCost() {...} get headCount() {...} } class Employee extends Party { get annualCost() {...} get id() {...} }</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec20"><span epub:type="pagebreak" id="page_376"/>Motivation</h4>
<p class="noindent">If I see two classes doing similar things, I can take advantage of the basic mechanism of inheritance to pull their similarities together into a superclass. I can use <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec2">Pull Up Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_353">353</a>)</span></em> to move common data into the superclass, and <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em> to move the common behavior.</p>
<p class="indent">Many writers on object orientation treat inheritance as something that should be carefully planned in advance, based on some kind of classification structure in the &#8220;real world.&#8221; Such classification structures can be a hint towards using inheritance&#8212;but just as often inheritance is something I realize during the evolution of a program, as I find common elements that I want to pull together.</p>
<p class="indent">An alternative to Extract Superclass is <em><span class="pd_maroon"><a class="pd_maroon" href="ch07.xhtml#ch07lev1sec5">Extract Class</a> (<a class="pd_maroon" href="ch07.xhtml#page_182">182</a>)</span></em>. Here you have, essentially, a choice between using inheritance or delegation as a way to unify duplicate behavior. Often Extract Superclass is the simpler approach, so I&#8217;ll do this first knowing I can use <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec11">Replace Superclass with Delegate</a> (<a class="pd_maroon" href="ch12.xhtml#page_399">399</a>)</span></em> should I need to later.</p>
<h4 class="h4" id="ch12lev2sec21">Mechanics</h4>
<ul class="square">
<li><p>Create an empty superclass. Make the original classes its subclasses.</p>
<div class="blockquote">
<p class="noindent">If needed, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> on the constructors.</p>
</div></li>
<li><p>Test.</p></li>
<li><p>One by one, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec3">Pull Up Constructor Body</a> (<a class="pd_maroon" href="ch12.xhtml#page_355">355</a>)</span></em>, <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em>, and <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec2">Pull Up Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_353">353</a>)</span></em> to move common elements to the superclass.</p></li>
<li><p>Examine remaining methods on the subclasses. See if there are common parts. If so, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> followed by <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em>.</p></li>
<li><p>Check clients of the original classes. Consider adjusting them to use the superclass interface.</p></li>
</ul>
<h4 class="h4" id="ch12lev2sec22">Example</h4>
<p class="noindent">I&#8217;m pondering these two classes, they share some common functionality&#8212;their name and the notions of annual and monthly costs:</p>
<p class="codelink"><a id="p0377_01a" href="ch12_images.xhtml#p0377_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_377"/><strong><span class="pd_green">class Employee {</span></strong>
  constructor(name, id, monthlyCost) {
    this._id = id;
    this._name = name;
    this._monthlyCost = monthlyCost;
  }
  get monthlyCost() {return this._monthlyCost;}
  get name() {return this._name;}
  get id() {return this._id;}

  get annualCost() {
    return this.monthlyCost * 12;
  }
}

<strong><span class="pd_green">class Department {</span></strong>
  constructor(name, staff){
    this._name = name;
    this._staff = staff;
  }
  get staff() {return this._staff.slice();}
  get name() {return this._name;}

  get totalMonthlyCost() {
    return this.staff
      .map(e =&gt; e.monthlyCost)
      .reduce((sum, cost) =&gt; sum + cost);
  }
  get headCount() {
    return this.staff.length;
  }
  get totalAnnualCost() {
    return this.totalMonthlyCost * 12;
  }
}</pre>
<p class="indent">I can make the common behavior more explicit by extracting a common superclass from them.</p>
<p class="indent">I begin by creating an empty superclass and letting them both extend from it.</p>
<p class="codelink"><a id="p0377_02a" href="ch12_images.xhtml#p0377_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">class Party {}</span>

class Employee <span class="pd_maroon1">extends Party</span> {
  constructor(name, id, monthlyCost) {
    <span class="pd_maroon1">super();</span>
    this._id = id;
    this._name = name;
    this._monthlyCost = monthlyCost;
  }
  // rest of class...

<span epub:type="pagebreak" id="page_378"/>class Department <span class="pd_maroon1">extends Party</span> {
  constructor(name, staff){
    <span class="pd_maroon1">super();</span>
    this._name = name;
    this._staff = staff;
  }
  // rest of class...</pre>
<p class="indent">When doing Extract Superclass, I like to start with the data, which in JavaScript involves manipulating the constructor. So I start with <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec2">Pull Up Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_353">353</a>)</span></em> to pull up the name.</p>
<p class="pro-title"><em>class Party&#8230;</em></p>
<pre class="pre">constructor(name){
  <span class="pd_maroon1">this._name = name;</span>
}</pre>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0378_01a" href="ch12_images.xhtml#p0378_01">Click here to view code image</a></p>
<pre class="pre">constructor(name, id, monthlyCost) {
  super(<span class="pd_maroon1">name</span>);
  this._id = id;
  this._monthlyCost = monthlyCost;
}</pre>
<p class="pro-title"><em>class Department&#8230;</em></p>
<pre class="pre">constructor(name, staff){
  super(<span class="pd_maroon1">name</span>);
  this._staff = staff;
}</pre>
<p class="indent">As I get data up to the superclass, I can also apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em> on associated methods. First, the name:</p>
<p class="pro-title"><em>class Party&#8230;</em></p>
<p class="codelink"><a id="p0378_02a" href="ch12_images.xhtml#p0378_02">Click here to view code image</a></p>
<pre class="pre">get name() {return this._name;}</pre>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0378_03a" href="ch12_images.xhtml#p0378_03">Click here to view code image</a></p>
<pre class="pre"><span class="strike"><span class="pd_maroon1">get name() {return this._name;}</span></span></pre>
<p class="pro-title"><em>class Department&#8230;</em></p>
<p class="codelink"><a id="p0378_04a" href="ch12_images.xhtml#p0378_04">Click here to view code image</a></p>
<pre class="pre"><span class="strike"><span class="pd_maroon1">get name() {return this._name;}</span></span></pre>
<p class="indent">I have two methods with similar bodies.</p>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0378_05a" href="ch12_images.xhtml#p0378_05">Click here to view code image</a></p>
<pre class="pre">get annualCost() {
  return this.monthlyCost * 12;
}</pre>
<p class="pro-title"><span epub:type="pagebreak" id="page_379"/><em>class Department&#8230;</em></p>
<p class="codelink"><a id="p0379_01a" href="ch12_images.xhtml#p0379_01">Click here to view code image</a></p>
<pre class="pre">get totalAnnualCost() {
  return this.totalMonthlyCost * 12;
}</pre>
<p class="indent">The methods they use, <code>monthlyCost</code> and <code>totalMonthlyCost</code>, have different names and different bodies&#8212;but do they represent the same intent? If so, I should use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to unify their names.</p>
<p class="pro-title"><em>class Department&#8230;</em></p>
<p class="codelink"><a id="p0379_02a" href="ch12_images.xhtml#p0379_02">Click here to view code image</a></p>
<pre class="pre">get totalAnnualCost() {
  return this.<span class="pd_maroon1">monthlyCost</span> * 12;
}

get <span class="pd_maroon1">monthlyCost</span>() { &#8230; }</pre>
<p class="indent">I then do a similar renaming to the annual costs:</p>
<p class="indent"><em>class Department&#8230;</em></p>
<p class="codelink"><a id="p0379_03a" href="ch12_images.xhtml#p0379_03">Click here to view code image</a></p>
<pre class="pre">get <span class="pd_maroon1">annualCost</span>() {
  return this.monthlyCost * 12;
}</pre>
<p class="indent">I can now apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em> to the annual cost methods.</p>
<p class="pro-title"><em>class Party&#8230;</em></p>
<p class="codelink"><a id="p0379_04a" href="ch12_images.xhtml#p0379_04">Click here to view code image</a></p>
<pre class="pre">get annualCost() {
  return this.monthlyCost * 12;
}</pre>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0379_05a" href="ch12_images.xhtml#p0379_05">Click here to view code image</a></p>
<pre class="pre"><span class="strike"><span class="pd_maroon1">get annualCost() {</span></span>
  <span class="strike"><span class="pd_maroon1">return this.monthlyCost * 12;</span></span>
<span class="strike"><span class="pd_maroon1">}</span></span></pre>
<p class="pro-title"><em>class Department&#8230;</em></p>
<p class="codelink"><a id="p0379_06a" href="ch12_images.xhtml#p0379_06">Click here to view code image</a></p>
<pre class="pre"><span class="strike"><span class="pd_maroon1">get annualCost() {</span></span>
  <span class="strike"><span class="pd_maroon1">return this.monthlyCost * 12;</span></span>
<span class="strike"><span class="pd_maroon1">}</span></span></pre>
<h3 class="h3" id="ch12lev1sec9"><span epub:type="pagebreak" id="page_380"/>Collapse Hierarchy</h3>
<figure class="fig-group">
<img src="graphics/p0380_01.jpg" aria-describedby="alt_p0380_01" alt="A figure illustrates how the refactoring technique is used in a collapse hierarchy."/>
<aside class="hidden" id="alt_p0380_01">
<p>In the diagrammatic representation, the subclass points toward the superclass, and the object in the subclass points to one of those in the superclass. The actual code reads, class Employee {...} class Salesman extends Employee {...} The code after refactoring reads, class Employee {...}</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec23">Motivation</h4>
<p class="noindent">When I&#8217;m refactoring a class hierarchy, I&#8217;m often pulling and pushing features around. As the hierarchy evolves, I sometimes find that a class and its parent are no longer different enough to be worth keeping separate. At this point, I&#8217;ll merge them together.</p>
<h4 class="h4" id="ch12lev2sec24">Mechanics</h4>
<ul class="square">
<li><p>Choose which one to remove.</p>
<div class="blockquote">
<p class="noindent">I choose based on which name makes most sense in the future. If neither name is best, I&#8217;ll pick one arbitrarily.</p>
</div></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec2">Pull Up Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_353">353</a>)</span></em>, <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec5">Push Down Field</a> (<a class="pd_maroon" href="ch12.xhtml#page_361">361</a>)</span></em>, <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec1">Pull Up Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_350">350</a>)</span></em>, and <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec4">Push Down Method</a> (<a class="pd_maroon" href="ch12.xhtml#page_359">359</a>)</span></em> to move all the elements into a single class.</p></li>
<li><p>Adjust any references to the victim to change them to the class that will stay.</p></li>
<li><p>Remove the empty class.</p></li>
<li><p>Test.</p></li>
</ul>
<h3 class="h3" id="ch12lev1sec10"><span epub:type="pagebreak" id="page_381"/>Replace Subclass with Delegate</h3>
<figure class="fig-group">
<img src="graphics/p0381_01.jpg" aria-describedby="alt_p0381_01" alt="A figure illustrates how the refactoring technique used to replace a subclass with a delegate."/>
<aside class="hidden" id="alt_p0381_01">
<p>The diagrammatic representation shows the replacement of a subclass with a delegate at the top, with the actual code below it reading, class Order { get daysToShip() { return this._warehouse.daysToShip; } } class PriorityOrder extends Order { get daysToShip() { return this._priorityPlan.daysToShip; } } The code after refactoring reads, class Order { get daysToShip() { return (this._priorityDelegate) ? this._priorityDelegate.daysToShip : this._warehouse.daysToShip; } } class PriorityOrderDelegate { get daysToShip() { return this._priorityPlan.daysToShip } }</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec25">Motivation</h4>
<p class="noindent">If I have some objects whose behavior varies from category to category, the natural mechanism to express this is inheritance. I put all the common data and behavior in the superclass, and let each subclass add and override features as <span epub:type="pagebreak" id="page_382"/>needed. Object-oriented languages make this simple to implement and thus a familiar mechanism.</p>
<p class="indent">But inheritance has its downsides. Most obviously, it&#8217;s a card that can only be played once. If I have more than one reason to vary something, I can only use inheritance for a single axis of variation. So, if I want to vary behavior of people by their age category and by their income level, I can either have subclasses for young and senior, or for well-off and poor&#8212;I can&#8217;t have both.</p>
<p class="indent">A further problem is that inheritance introduces a very close relationship between classes. Any change I want to make to the parent can easily break children, so I have to be careful and understand how children derive from the superclass. This problem is made worse when the logic of the two classes resides in different modules and is looked after by different teams.</p>
<p class="indent">Delegation handles both of these problems. I can delegate to many different classes for different reasons. Delegation is a regular relationship between objects&#8212;so I can have a clear interface to work with, which is much less coupling than subclassing. It&#8217;s therefore common to run into the problems with subclassing and apply Replace Subclass with Delegate.</p>
<p class="indent">There is a popular principle: &#8220;Favor object composition over class inheritance&#8221; (where composition is effectively the same as delegation). Many people take this to mean &#8220;inheritance considered harmful&#8221; and claim that we should never use inheritance. I use inheritance frequently, partly because I always know I can use Replace Subclass with Delegate should I need to change it later. Inheritance is a valuable mechanism that does the job most of the time without problems. So I reach for it first, and move onto delegation when it starts to rub badly. This usage is actually consistent with the principle&#8212;which comes from the Gang of Four book <span class="pd_maroon">[<a href="biblo.xhtml#bib11">gof</a>]</span> that explains how inheritance and composition work together. The principle was a reaction to the overuse of inheritance.</p>
<p class="indent">Those who are familiar with the Gang of Four book may find it helpful to think of this refactoring as replacing subclasses with the State or Strategy patterns. Both of these patterns are structurally the same, relying on the host delegating to a separate hierarchy. Not all cases of Replace Subclass with Delegate involve an inheritance hierarchy for the delegate (as the first example below illustrates), but setting up a hierarchy for states or strategies is often useful.</p>
<h4 class="h4" id="ch12lev2sec26">Mechanics</h4>
<ul class="square">
<li><p>If there are many callers for the constructors, apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec8">Replace Constructor with Factory Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_334">334</a>)</span></em>.</p></li>
<li><p>Create an empty class for the delegate. Its constructor should take any subclass-specific data as well as, usually, a back-reference to the superclass.</p></li>
<li><p>Add a field to the superclass to hold the delegate.</p></li>
<li><p><span epub:type="pagebreak" id="page_383"/>Modify the creation of the subclass so that it initializes the delegate field with an instance of the delegate.</p>
<div class="blockquote">
<p class="noindent">This can be done in the factory function, or in the constructor if the constructor can reliably tell whether to create the correct delegate.</p>
</div></li>
<li><p>Choose a subclass method to move to the delegate class.</p></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em> to move it to the delegate class. Don&#8217;t remove the source&#8217;s delegating code.</p>
<div class="blockquote">
<p class="noindent">If the method needs elements that should move to the delegate, move them. If it needs elements that should stay in the superclass, add a field to the delegate that refers to the superclass.</p>
</div></li>
<li><p>If the source method has callers outside the class, move the source&#8217;s delegating code from the subclass to the superclass, guarding it with a check for the presence of the delegate. If not, apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec9">Remove Dead Code</a> (<a class="pd_maroon" href="ch08.xhtml#page_237">237</a>)</span></em>.</p>
<div class="blockquote">
<p class="noindent">If there&#8217;s more than one subclass, and you start duplicating code within them, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec8">Extract Superclass</a> (<a class="pd_maroon" href="ch12.xhtml#page_375">375</a>)</span></em>. In this case, any delegating methods on the source super-class no longer need a guard if the default behavior is moved to the delegate superclass.</p>
</div></li>
<li><p>Test.</p></li>
<li><p>Repeat until all the methods of the subclass are moved.</p></li>
<li><p>Find all callers of the subclasses&#8217;s constructor and change them to use the superclass constructor.</p></li>
<li><p>Test.</p></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec9">Remove Dead Code</a> (<a class="pd_maroon" href="ch08.xhtml#page_237">237</a>)</span></em> on the subclass.</p></li>
</ul>
<h4 class="h4" id="ch12lev2sec27">Example</h4>
<p class="noindent">I have a class that makes a booking for a show.</p>
<p class="pro-title"><em>class Booking&#8230;</em></p>
<pre class="pre">constructor(show, date) {
  this._show = show;
  this._date = date;
}</pre>
<p class="indent">There is a subclass for premium booking that takes into account various extras that are available.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_384"/><em>class PremiumBooking extends Booking&#8230;</em></p>
<p class="codelink"><a id="p0384_01a" href="ch12_images.xhtml#p0384_01">Click here to view code image</a></p>
<pre class="pre">constructor(show, date, extras) {
  super(show, date);
  this._extras = extras;
}</pre>
<p class="indent">There are quite a few changes that the premium booking makes to what it inherits from the superclass. As is typical with this kind of programming-by-difference, in some cases the subclass overrides methods on the superclass, in others it adds new methods that are only relevant for the subclass. I won&#8217;t go into all of them, but I will pick out a few interesting cases.</p>
<p class="indent">First, there is a simple override. Regular bookings offer a talkback after the show, but only on nonpeak days.</p>
<p class="pro-title"><em>class Booking&#8230;</em></p>
<p class="codelink"><a id="p0384_02a" href="ch12_images.xhtml#p0384_02">Click here to view code image</a></p>
<pre class="pre">get hasTalkback() {
  return this._show.hasOwnProperty('talkback') &amp;&amp; !this.isPeakDay;
}</pre>
<p class="indent">Premium bookings override this to offer talkbacks on all days.</p>
<p class="pro-title"><em>class PremiumBooking&#8230;</em></p>
<p class="codelink"><a id="p0384_03a" href="ch12_images.xhtml#p0384_03">Click here to view code image</a></p>
<pre class="pre">get hasTalkback() {
  return this._show.hasOwnProperty('talkback');
}</pre>
<p class="indent">Determining the price is a similar override, with a twist that the premium method calls the superclass method.</p>
<p class="pro-title"><em>class Booking&#8230;</em></p>
<p class="codelink"><a id="p0384_04a" href="ch12_images.xhtml#p0384_04">Click here to view code image</a></p>
<pre class="pre">get basePrice() {
  let result = this._show.price;
  if (this.isPeakDay) result += Math.round(result * 0.15);
  return result;
}</pre>
<p class="pro-title"><em>class PremiumBooking&#8230;</em></p>
<p class="codelink"><a id="p0384_05a" href="ch12_images.xhtml#p0384_05">Click here to view code image</a></p>
<pre class="pre">get basePrice() {
  return Math.round(super.basePrice + this._extras.premiumFee);
}</pre>
<p class="indent">The last example is where the premium booking offers a behavior that isn&#8217;t present on the superclass.</p>
<p class="pro-title"><em>class PremiumBooking&#8230;</em></p>
<p class="codelink"><a id="p0384_06a" href="ch12_images.xhtml#p0384_06">Click here to view code image</a></p>
<pre class="pre">get hasDinner() {
  return this._extras.hasOwnProperty('dinner') &amp;&amp; !this.isPeakDay;
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_385"/>Inheritance works well for this example. I can understand the base class without having to understand the subclass. The subclass is defined just by saying how it differs from the base case&#8212;both reducing duplication and clearly communicating what are the differences it&#8217;s introducing.</p>
<p class="indent">Actually, it isn&#8217;t quite as perfect as the previous paragraph implies. There are things in the superclass structure that only make sense due to the subclass&#8212;such as methods that have been factored in such a way as to make it easier to override just the right kinds of behavior. So although most of the time I can modify the base class without having to understand subclasses, there are occasions where such mindful ignorance of the subclasses will lead me to breaking a subclass by modifying the superclass. However, if these occasions are not too common, the inheritance pays off&#8212;provided I have good tests to detect a subclass breakage.</p>
<p class="indent">So why would I want to change such a happy situation by using Replace Subclass with Delegate? Inheritance is a tool that can only be used once&#8212;so if I have another reason to use inheritance, and I think it will benefit me more than the premium booking subclass, I&#8217;ll need to handle premium bookings a different way. Also, I may need to change from the default booking to the premium booking dynamically&#8212;i.e., support a method like <code>aBooking.bePremium()</code>. In some cases, I can avoid this by creating a whole new object (a common example is where an HTTP request loads new data from the server). But sometimes, I need to modify a data structure and not rebuild it from scratch, and it is difficult to just replace a single booking that&#8217;s referred to from many different places. In such situations, it can be useful to allow a booking to switch from default to premium and back again.</p>
<p class="indent">When these needs crop up, I need to apply Replace Subclass with Delegate. I have clients call the constructors of the two classes to make the bookings:</p>
<p class="pro-title"><em>booking client</em></p>
<p class="codelink"><a id="p0385_01a" href="ch12_images.xhtml#p0385_01">Click here to view code image</a></p>
<pre class="pre">aBooking = new Booking(show,date);</pre>
<p class="pro-title"><em>premium client</em></p>
<p class="codelink"><a id="p0385_02a" href="ch12_images.xhtml#p0385_02">Click here to view code image</a></p>
<pre class="pre">aBooking = new PremiumBooking(show, date, extras);</pre>
<p class="indent">Removing subclasses will alter all of this, so I like to encapsulate the constructor calls with <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec8">Replace Constructor with Factory Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_334">334</a>)</span></em>.</p>
<p class="pro-title"><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0385_03a" href="ch12_images.xhtml#p0385_03">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">function createBooking(show, date) {</span>
  return new Booking(show, date);
}
<span class="pd_maroon1">function createPremiumBooking(show, date, extras) {</span>
  return new PremiumBooking (show, date, extras);
}</pre>
<p class="pro-title"><em>booking client</em></p>
<p class="codelink"><a id="p0385_04a" href="ch12_images.xhtml#p0385_04">Click here to view code image</a></p>
<pre class="pre">aBooking = <span class="pd_maroon1">createBooking</span>(show, date);</pre>
<p class="pro-title"><span epub:type="pagebreak" id="page_386"/><em>premium client</em></p>
<p class="codelink"><a id="p0386_01a" href="ch12_images.xhtml#p0386_01">Click here to view code image</a></p>
<pre class="pre">aBooking = <span class="pd_maroon1">createPremiumBooking</span>(show, date, extras);</pre>
<p class="indent">I now make the new delegate class. Its constructor parameters are those parameters that are only used in the subclass, together with a back-reference to the booking object. I&#8217;ll need this because several subclass methods require access to data stored in the superclass. Inheritance makes this easy to do, but with a delegate I need a back-reference.</p>
<p class="pro-title"><em>class PremiumBookingDelegate&#8230;</em></p>
<p class="codelink"><a id="p0386_02a" href="ch12_images.xhtml#p0386_02">Click here to view code image</a></p>
<pre class="pre">constructor(hostBooking, extras) {
  this._host = hostBooking;
  this._extras = extras;
}</pre>
<p class="indent">I now connect the new delegate to the booking object. I do this by modifying the factory function for premium bookings.</p>
<p class="pro-title"><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0386_03a" href="ch12_images.xhtml#p0386_03">Click here to view code image</a></p>
<pre class="pre">function createPremiumBooking(show, date, extras) {
  <span class="pd_maroon1">const result = new PremiumBooking (show, date, extras);</span>
  <span class="pd_maroon1">result</span>._bePremium(extras);
  return <span class="pd_maroon1">result</span>;
}</pre>
<p class="pro-title"><em>class Booking&#8230;</em></p>
<p class="codelink"><a id="p0386_04a" href="ch12_images.xhtml#p0386_04">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">_bePremium(extras) {</span>
  <span class="pd_maroon1">this._premiumDelegate = new PremiumBookingDelegate(this, extras);</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">I use a leading underscore on <code>_bePremium</code> to indicate that it shouldn&#8217;t be part of the public interface for <code>Booking</code>. Of course, if the point of doing this refactoring is to allow a booking to mutate to premium, it can be a public method.</p>
<div class="blockquote">
<p class="noindent">Alternatively, I can do all the connections in the constructor for <code>Booking</code>. In order to do that, I need some way to signal to the constructor that we have a premium booking. That could be an extra parameter, or just the use of <code>extras</code> if I can be sure that it is always present when used with a premium booking. Here, I prefer the explicitness of doing this through the factory function.</p>
</div>
<p class="indent">With the structures set up, it&#8217;s time to start moving the behavior. The first case I&#8217;ll consider is the simple override of <code>hasTalkback</code>. Here&#8217;s the existing code:</p>
<p class="pro-title"><em>class Booking&#8230;</em></p>
<p class="codelink"><a id="p0386_05a" href="ch12_images.xhtml#p0386_05">Click here to view code image</a></p>
<pre class="pre">get hasTalkback() {
  return this._show.hasOwnProperty('talkback') &amp;&amp; !this.isPeakDay;
}</pre>
<p class="pro-title"><span epub:type="pagebreak" id="page_387"/><em>class PremiumBooking&#8230;</em></p>
<p class="codelink"><a id="p0387_01a" href="ch12_images.xhtml#p0387_01">Click here to view code image</a></p>
<pre class="pre">get hasTalkback() {
  return this._show.hasOwnProperty('talkback');
}</pre>
<p class="indent">I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em> to move the subclass method to the delegate. To make it fit its home, I route any access to superclass data with a call to <code>_host</code>.</p>
<p class="pro-title"><em>class PremiumBookingDelegate&#8230;</em></p>
<p class="codelink"><a id="p0387_02a" href="ch12_images.xhtml#p0387_02">Click here to view code image</a></p>
<pre class="pre">get hasTalkback() {
  return this.<span class="pd_maroon1">_host</span>._show.hasOwnProperty('talkback');
}</pre>
<p class="pro-title"><em>class PremiumBooking&#8230;</em></p>
<p class="codelink"><a id="p0387_03a" href="ch12_images.xhtml#p0387_03">Click here to view code image</a></p>
<pre class="pre">get hasTalkback() {
  return <span class="pd_maroon1">this._premiumDelegate.hasTalkback;</span>
}</pre>
<p class="indent">I test to ensure everything is working, then delete the subclass method:</p>
<p class="pro-title"><em>class PremiumBooking&#8230;</em></p>
<p class="codelink"><a id="p0387_04a" href="ch12_images.xhtml#p0387_04">Click here to view code image</a></p>
<pre class="pre"><span class="strike"><span class="pd_maroon1">get hasTalkback() {</span></span>
  <span class="strike"><span class="pd_maroon1">return this._premiumDelegate.hasTalkback;</span></span>
<span class="strike"><span class="pd_maroon1">}</span></span></pre>
<p class="indent">I run the tests at this point, expecting some to fail.</p>
<p class="indent">Now I finish the move by adding dispatch logic to the superclass method to use the delegate if it is present.</p>
<p class="pro-title"><em>class Booking&#8230;</em></p>
<p class="codelink"><a id="p0387_05a" href="ch12_images.xhtml#p0387_05">Click here to view code image</a></p>
<pre class="pre">get hasTalkback() {
  return <span class="pd_maroon1">(this._premiumDelegate)</span>
    <span class="pd_maroon1">? this._premiumDelegate.hasTalkback</span>
    <span class="pd_maroon1">:</span> this._show.hasOwnProperty('talkback') &amp;&amp; !this.isPeakDay;
}</pre>
<p class="indent">The next case I&#8217;ll look at is the base price.</p>
<p class="pro-title"><em>class Booking&#8230;</em></p>
<p class="codelink"><a id="p0387_06a" href="ch12_images.xhtml#p0387_06">Click here to view code image</a></p>
<pre class="pre">get basePrice() {
  let result = this._show.price;
  if (this.isPeakDay) result += Math.round(result * 0.15);
  return result;
}</pre>
<p class="pro-title"><em>class PremiumBooking&#8230;</em></p>
<p class="codelink"><a id="p0387_07a" href="ch12_images.xhtml#p0387_07">Click here to view code image</a></p>
<pre class="pre">get basePrice() {
  return Math.round(<span class="pd_blue">super</span>.basePrice + this._extras.premiumFee);
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_388"/>This is almost the same, but there is a wrinkle in the form of the pesky call on <code>super</code> (which is pretty common in these kinds of subclass extension cases). When I move the subclass code to the delegate, I&#8217;ll need to call the parent case&#8212;but I can&#8217;t just call <code>this._host._basePrice</code> without getting into an endless recursion.</p>
<p class="indent">I have a couple of options here. One is to apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the base calculation to allow me to separate the dispatch logic from price calculation. (The rest of the move is as before.)</p>
<p class="pro-title"><em>class Booking&#8230;</em></p>
<p class="codelink"><a id="p0388_01a" href="ch12_images.xhtml#p0388_01">Click here to view code image</a></p>
<pre class="pre">get basePrice() {
  <span class="pd_maroon1">return (this._premiumDelegate)</span>
    <span class="pd_maroon1">? this._premiumDelegate.basePrice</span>
    <span class="pd_maroon1">: this._privateBasePrice;</span>
}

<span class="pd_maroon1">get _privateBasePrice() {</span>
  let result = this._show.price;
  if (this.isPeakDay) result += Math.round(result * 0.15);
  return result;
}</pre>
<p class="pro-title"><em>class PremiumBookingDelegate&#8230;</em></p>
<p class="codelink"><a id="p0388_02a" href="ch12_images.xhtml#p0388_02">Click here to view code image</a></p>
<pre class="pre">get basePrice() {
  return Math.round(this.<span class="pd_maroon1">_host._private</span>BasePrice + this._extras.premiumFee);
}</pre>
<p class="indent">Alternatively, I can recast the delegate&#8217;s method as an extension of the base method.</p>
<p class="pro-title"><em>class Booking&#8230;</em></p>
<p class="codelink"><a id="p0388_03a" href="ch12_images.xhtml#p0388_03">Click here to view code image</a></p>
<pre class="pre">get basePrice() {
  let result = this._show.price;
  if (this.isPeakDay) result += Math.round(result * 0.15);
  return <span class="pd_maroon1">(this._premiumDelegate)</span>
    <span class="pd_maroon1">? this._premiumDelegate.extendBasePrice(result)</span>
    : result;
}</pre>
<p class="pro-title"><em>class PremiumBookingDelegate&#8230;</em></p>
<p class="codelink"><a id="p0388_04a" href="ch12_images.xhtml#p0388_04">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">extendBasePrice</span>(base) {
  return Math.round(<span class="pd_maroon1">base</span> + this._extras.premiumFee);
}</pre>
<p class="indent">Both work reasonably here; I have a slight preference for the latter as it&#8217;s a bit smaller.</p>
<p class="indent">The last case is a method that only exists on the subclass.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_389"/><em>class PremiumBooking&#8230;</em></p>
<p class="codelink"><a id="p0389_01a" href="ch12_images.xhtml#p0389_01">Click here to view code image</a></p>
<pre class="pre">get hasDinner() {
  return this._extras.hasOwnProperty('dinner') &amp;&amp; !this.isPeakDay;
}</pre>
<p class="indent">I move it from the subclass to the delegate:</p>
<p class="pro-title"><em>class PremiumBookingDelegate&#8230;</em></p>
<p class="codelink"><a id="p0389_02a" href="ch12_images.xhtml#p0389_02">Click here to view code image</a></p>
<pre class="pre">get hasDinner() {
  return this._extras.hasOwnProperty('dinner') &amp;&amp; !this.<span class="pd_maroon1">_host</span>.isPeakDay;
}</pre>
<p class="indent">I then add dispatch logic to <code>Booking</code>:</p>
<p class="pro-title"><em>class Booking&#8230;</em></p>
<p class="codelink"><a id="p0389_03a" href="ch12_images.xhtml#p0389_03">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get hasDinner() {</span>
  <span class="pd_maroon1">return (this._premiumDelegate)</span>
    <span class="pd_maroon1">? this._premiumDelegate.hasDinner</span>
    <span class="pd_maroon1">: undefined;</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">In JavaScript, accessing a property on an object where it isn&#8217;t defined returns <code>undefined</code>, so I do that here. (Although my every instinct is to have it raise an error, which would be the case in other object-oriented dynamic languages I&#8217;m used to.)</p>
<p class="indent">Once I&#8217;ve moved all the behavior out of the subclass, I can change the factory method to return the superclass&#8212;and, once I&#8217;ve run tests to ensure all is well, delete the subclass.</p>
<p class="pro-title"><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0389_04a" href="ch12_images.xhtml#p0389_04">Click here to view code image</a></p>
<pre class="pre">function createPremiumBooking(show, date, extras) {
  const result = new <span class="strike"><span class="pd_maroon1">Premium</span></span>Booking (show, date, extras);
  result._bePremium(extras);
  return result;
}

<span class="strike"><span class="pd_maroon1">class PremiumBooking extends Booking ...</span></span></pre>
<p class="indent">This is one of those refactorings where I don&#8217;t feel that refactoring alone improves the code. Inheritance handles this situation very well, whereas using delegation involves adding dispatch logic, two-way references, and thus extra complexity. The refactoring may still be worthwhile, since the advantage of a mutable premium status, or a need to use inheritance for other purposes, may outweigh the disadvantage of losing inheritance.</p>
<h4 class="h4" id="ch12lev2sec28">Example: Replacing a Hierarchy</h4>
<p class="noindent">The previous example showed using Replace Subclass with Delegate on a single subclass, but I can do the same thing with an entire hierarchy.</p>
<p class="codelink"><a id="p0390_01a" href="ch12_images.xhtml#p0390_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_390"/><strong><span class="pd_green">function createBird</span></strong>(data) {
  switch (data.type) {
    case 'EuropeanSwallow':
      return new EuropeanSwallow(data);
    case 'AfricanSwallow':
      return new AfricanSwallow(data);
    case 'NorweigianBlueParrot':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}

<strong><span class="pd_green">class Bird</span></strong> {
  constructor(data) {
    this._name = data.name;
    this._plumage = data.plumage;
  }
  <strong><span class="pd_green">get name</span></strong>()    {return this._name;}

  <strong><span class="pd_green">get plumage</span></strong>() {
    return this._plumage || "average";
  }
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {return null;}
}

<strong><span class="pd_green">class EuropeanSwallow</span></strong> extends Bird {
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {return 35;}
}

<strong><span class="pd_green">class AfricanSwallow</span></strong> extends Bird {
  constructor(data) {
    super (data);
    this._numberOfCoconuts = data.numberOfCoconuts;
  }
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

<strong><span class="pd_green">class NorwegianBlueParrot</span></strong> extends Bird {
  constructor(data) {
    super (data);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }

  <strong><span class="pd_green">get plumage</span></strong>() {
    if (this._voltage &gt; 100) return "scorched";
    else return this._plumage || "beautiful";
  }
  <span epub:type="pagebreak" id="page_391"/><strong><span class="pd_green">get airSpeedVelocity</span></strong>() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
}</pre>
<p class="indent">The system will shortly be making a big difference between birds tagged in the wild and those tagged in captivity. That difference could be modeled as two subclasses for <code>Bird</code>: <code>WildBird</code> and <code>CaptiveBird</code>. However, I can only use inheritance once, so if I want to use subclasses for wild versus captive, I&#8217;ll have to remove them for the species.</p>
<p class="indent">When several subclasses are involved, I&#8217;ll tackle them one at a time, starting with a simple one&#8212;in this case, <code>EuropeanSwallow</code>. I create an empty delegate class for the delegate.</p>
<p class="codelink"><a id="p0391_01a" href="ch12_images.xhtml#p0391_01">Click here to view code image</a></p>
<pre class="pre">class EuropeanSwallowDelegate {
}</pre>
<p class="indent">I don&#8217;t put in any data or back-reference parameters yet. For this example, I&#8217;ll introduce them as I need them.</p>
<p class="indent">I need to decide where to handle the initialization of the delegate field. Here, since I have all the information in the single data argument to the constructor, I decide to do it in the constructor. Since there are several delegates I could add, I make a function to select the correct one based on the type code in the document.</p>
<p class="pro-title"><em>class Bird&#8230;</em></p>
<p class="codelink"><a id="p0391_02a" href="ch12_images.xhtml#p0391_02">Click here to view code image</a></p>
<pre class="pre">constructor(data) {
  this._name = data.name;
  this._plumage = data.plumage;
  <span class="pd_maroon1">this._speciesDelegate = this.selectSpeciesDelegate(data);</span>
}

  <span class="pd_maroon1">selectSpeciesDelegate(data) {</span>
    <span class="pd_maroon1">switch(data.type) {</span>
      <span class="pd_maroon1">case 'EuropeanSwallow':</span>
        <span class="pd_maroon1">return new EuropeanSwallowDelegate();</span>
      <span class="pd_maroon1">default: return null;</span>
    <span class="pd_maroon1">}</span>
  <span class="pd_maroon1">}</span></pre>
<p class="indent">Now I have the structure set up, I can apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em> to the European swallow&#8217;s air speed velocity.</p>
<p class="pro-title"><em>class EuropeanSwallowDelegate&#8230;</em></p>
<p class="codelink"><a id="p0391_03a" href="ch12_images.xhtml#p0391_03">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get airSpeedVelocity() {return 35;}</span></pre>
<p class="pro-title"><em>class EuropeanSwallow&#8230;</em></p>
<p class="codelink"><a id="p0391_04a" href="ch12_images.xhtml#p0391_04">Click here to view code image</a></p>
<pre class="pre">get airSpeedVelocity() {return <span class="pd_maroon1">this._speciesDelegate.airSpeedVelocity</span>;}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_392"/>I change <code>airSpeedVelocity</code> on the superclass to call a delegate, if present.</p>
<p class="pro-title"><em>class Bird&#8230;</em></p>
<p class="codelink"><a id="p0392_01a" href="ch12_images.xhtml#p0392_01">Click here to view code image</a></p>
<pre class="pre">get airSpeedVelocity() {
  return <span class="pd_maroon1">this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity :</span> null;
}</pre>
<p class="indent">I remove the subclass.</p>
<p class="codelink"><a id="p0392_02a" href="ch12_images.xhtml#p0392_02">Click here to view code image</a></p>
<pre class="pre"><span class="strike"><span class="pd_maroon1">class EuropeanSwallow extends Bird {</span></span>
  <span class="strike"><span class="pd_maroon1">get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}</span></span>
<span class="strike"><span class="pd_maroon1">}</span></span></pre>
<p class="pro-title"><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0392_03a" href="ch12_images.xhtml#p0392_03">Click here to view code image</a></p>
<pre class="pre">function createBird(data) {
  switch (data.type) {
    <span class="strike"><span class="pd_maroon1">case 'EuropeanSwallow':</span></span>
      <span class="strike"><span class="pd_maroon1">return new EuropeanSwallow(data);</span></span>
    case 'AfricanSwallow':
      return new AfricanSwallow(data);
    case 'NorweigianBlueParrot':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}</pre>
<p class="indent">Next I&#8217;ll tackle the African swallow. I create a class; this time, the constructor needs the data document.</p>
<p class="pro-title"><em>class AfricanSwallowDelegate&#8230;</em></p>
<p class="codelink"><a id="p0392_04a" href="ch12_images.xhtml#p0392_04">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">constructor(data) {</span>
  <span class="pd_maroon1">this._numberOfCoconuts = data.numberOfCoconuts;</span>
<span class="pd_maroon1">}</span></pre>
<p class="pro-title"><em>class Bird&#8230;</em></p>
<p class="codelink"><a id="p0392_05a" href="ch12_images.xhtml#p0392_05">Click here to view code image</a></p>
<pre class="pre">selectSpeciesDelegate(data) {
  switch(data.type) {
    case 'EuropeanSwallow':
      return new EuropeanSwallowDelegate();
    <span class="pd_maroon1">case 'AfricanSwallow':</span>
      <span class="pd_maroon1">return new AfricanSwallowDelegate(data);</span>
    default: return null;
  }
}</pre>
<p class="indent">I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em> on <code>airSpeedVelocity</code>.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_393"/><em>class AfricanSwallowDelegate&#8230;</em></p>
<p class="codelink"><a id="p0393_01a" href="ch12_images.xhtml#p0393_01">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get airSpeedVelocity() {</span>
  <span class="pd_maroon1">return 40 - 2 * this._numberOfCoconuts;</span>
<span class="pd_maroon1">}</span></pre>
<p class="pro-title"><em>class AfricanSwallow&#8230;</em></p>
<p class="codelink"><a id="p0393_02a" href="ch12_images.xhtml#p0393_02">Click here to view code image</a></p>
<pre class="pre">get airSpeedVelocity() {
  return this.<span class="pd_maroon1">_speciesDelegate.airSpeedVelocity</span>;
}</pre>
<p class="indent">I can now remove the African swallow subclass.</p>
<p class="codelink"><a id="p0393_03a" href="ch12_images.xhtml#p0393_03">Click here to view code image</a></p>
<pre class="pre"><span class="strike"><span class="pd_maroon1">class AfricanSwallow extends Bird {</span></span>
  <span class="strike"><span class="pd_maroon1">// all of the body ...</span></span>
  <span class="strike"><span class="pd_maroon1">}</span></span>

function createBird(data) {
  switch (data.type) {
    <span class="strike"><span class="pd_maroon1">case 'AfricanSwallow':</span></span>
      <span class="strike"><span class="pd_maroon1">return new AfricanSwallow(data);</span></span>
    case 'NorweigianBlueParrot':
      return new NorwegianBlueParrot(data);
    default:
      return new Bird(data);
  }
}</pre>
<p class="indent">Now for the Norwegian blue. Creating the class and moving the air speed velocity uses the same steps as before, so I&#8217;ll just show the result.</p>
<p class="pro-title"><em>class Bird&#8230;</em></p>
<p class="codelink"><a id="p0393_04a" href="ch12_images.xhtml#p0393_04">Click here to view code image</a></p>
<pre class="pre">selectSpeciesDelegate(data) {
  switch(data.type) {
    case 'EuropeanSwallow':
      return new EuropeanSwallowDelegate();
    case 'AfricanSwallow':
      return new AfricanSwallowDelegate(data);
    case 'NorweigianBlueParrot':
      return new NorwegianBlueParrotDelegate(data);
    default: return null;
  }
}</pre>
<p class="pro-title"><em>class NorwegianBlueParrotDelegate&#8230;</em></p>
<p class="codelink"><a id="p0393_05a" href="ch12_images.xhtml#p0393_05">Click here to view code image</a></p>
<pre class="pre">constructor(data) {
  this._voltage = data.voltage;
  this._isNailed = data.isNailed;
}
get airSpeedVelocity() {
  return (this._isNailed) ? 0 : 10 + this._voltage / 10;
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_394"/>All well and good, but the Norwegian blue overrides the <code>plumage</code> property, which I didn&#8217;t have to deal with for the other cases. The initial <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em> is simple enough, albeit with the need to modify the constructor to put in a back-reference to the bird.</p>
<p class="pro-title"><em>class NorwegianBlueParrot&#8230;</em></p>
<p class="codelink"><a id="p0394_01a" href="ch12_images.xhtml#p0394_01">Click here to view code image</a></p>
<pre class="pre">get plumage() {
  return <span class="pd_maroon1">this._speciesDelegate.plumage</span>;
}</pre>
<p class="pro-title"><em>class NorwegianBlueParrotDelegate&#8230;</em></p>
<p class="codelink"><a id="p0394_02a" href="ch12_images.xhtml#p0394_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get plumage() {</span>
  <span class="pd_maroon1">if (this._voltage &gt; 100) return "scorched";</span>
  <span class="pd_maroon1">else return this._bird._plumage || "beautiful";</span>
<span class="pd_maroon1">}</span>

<span class="pd_maroon1">constructor(data, bird) {</span>
  <span class="pd_maroon1">this._bird = bird;</span>
  this._voltage = data.voltage;
  this._isNailed = data.isNailed;
}</pre>
<p class="pro-title"><em>class Bird&#8230;</em></p>
<p class="codelink"><a id="p0394_03a" href="ch12_images.xhtml#p0394_03">Click here to view code image</a></p>
<pre class="pre">selectSpeciesDelegate(data) {
  switch(data.type) {
    case 'EuropeanSwallow':
      return new EuropeanSwallowDelegate();
    case 'AfricanSwallow':
      return new AfricanSwallowDelegate(data);
    case 'NorweigianBlueParrot':
      return new NorwegianBlueParrotDelegate(data, <span class="pd_maroon1">this</span>);
    default: return null;
  }
}</pre>
<p class="indent">The tricky step is how to remove the subclass method for <code>plumage</code>. If I do</p>
<p class="pro-title"><em>class Bird&#8230;</em></p>
<p class="codelink"><a id="p0394_04a" href="ch12_images.xhtml#p0394_04">Click here to view code image</a></p>
<pre class="pre">get plumage() {
  <span class="pd_maroon1">if (this._speciesDelegate)</span>
    <span class="pd_maroon1">return this._speciesDelegate.plumage;</span>
  <span class="pd_maroon1">else</span>
    return this._plumage || "average";
}</pre>
<p class="noindent">then I&#8217;ll get a bunch of errors because there is no plumage property on the other species&#8217; delegate classes.</p>
<p class="indent"><span epub:type="pagebreak" id="page_395"/>I could use a more precise conditional:</p>
<p class="pro-title"><em>class Bird&#8230;</em></p>
<p class="codelink"><a id="p0395_01a" href="ch12_images.xhtml#p0395_01">Click here to view code image</a></p>
<pre class="pre">get plumage() {
  if (this._speciesDelegate <span class="pd_maroon1">instanceof NorwegianBlueParrotDelegate</span>)
    return this._speciesDelegate.plumage;
  else
    return this._plumage || "average";
}</pre>
<p class="indent">But I hope that smells as much of decomposing parrot to you as it does to me. It&#8217;s almost never a good idea to use an explicit class check like this.</p>
<p class="indent">Another option is to implement the default case on the other delegates.</p>
<p class="pro-title"><em>class Bird&#8230;</em></p>
<p class="codelink"><a id="p0395_02a" href="ch12_images.xhtml#p0395_02">Click here to view code image</a></p>
<pre class="pre">get plumage() {
  if (this._speciesDelegate)
    return this._speciesDelegate.plumage;
  else
    return this._plumage || "average";
}</pre>
<p class="pro-title"><em>class EuropeanSwallowDelegate&#8230;</em></p>
<p class="codelink"><a id="p0395_03a" href="ch12_images.xhtml#p0395_03">Click here to view code image</a></p>
<pre class="pre">get plumage() {
  return this._bird._plumage || "average";
}</pre>
<p class="pro-title"><em>class AfricanSwallowDelegate&#8230;</em></p>
<p class="codelink"><a id="p0395_04a" href="ch12_images.xhtml#p0395_04">Click here to view code image</a></p>
<pre class="pre">get plumage() {
  return this._bird._plumage || "average";
}</pre>
<p class="indent">But this duplicates the default method for plumage. And if that&#8217;s not bad enough, I also get some bonus duplication in the constructors to assign the back-reference.</p>
<p class="indent">The solution to the duplication is, naturally, inheritance&#8212;I apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch12.xhtml#ch12lev1sec8">Extract Superclass</a> (<a class="pd_maroon" href="ch12.xhtml#page_375">375</a>)</span></em> to the species delegates:</p>
<p class="codelink"><a id="p0395_05a" href="ch12_images.xhtml#p0395_05">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">class SpeciesDelegate {</span>
  <span class="pd_maroon1">constructor(data, bird) {</span>
    <span class="pd_maroon1">this._bird = bird;</span>
  <span class="pd_maroon1">}</span>
  <span class="pd_maroon1">get plumage() {</span>
    <span class="pd_maroon1">return this._bird._plumage || "average";</span>
  <span class="pd_maroon1">}</span>

class EuropeanSwallowDelegate <span class="pd_maroon1">extends SpeciesDelegate</span> {

<span epub:type="pagebreak" id="page_396"/>class AfricanSwallowDelegate <span class="pd_maroon1">extends SpeciesDelegate</span> {
  constructor(data, bird) {
    <span class="pd_maroon1">super(data,bird);</span>
    this._numberOfCoconuts = data.numberOfCoconuts;
  }

class NorwegianBlueParrotDelegate <span class="pd_maroon1">extends SpeciesDelegate</span> {
  constructor(data, bird) {
    <span class="pd_maroon1">super(data, bird);</span>
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }</pre>
<p class="indent">Indeed, now I have a superclass, I can move any default behavior from <code>Bird</code> to <code>SpeciesDelegate</code> by ensuring there&#8217;s always something in the <code>speciesDelegate</code> field.</p>
<p class="pro-title"><em>class Bird&#8230;</em></p>
<p class="codelink"><a id="p0396_01a" href="ch12_images.xhtml#p0396_01">Click here to view code image</a></p>
<pre class="pre">selectSpeciesDelegate(data) {
  switch(data.type) {
    case 'EuropeanSwallow':
      return new EuropeanSwallowDelegate(data, this);
    case 'AfricanSwallow':
      return new AfricanSwallowDelegate(data, this);
    case 'NorweigianBlueParrot':
      return new NorwegianBlueParrotDelegate(data, this);
    <span class="pd_maroon1">default: return new SpeciesDelegate(data, this);</span>
  }
}
// rest of bird's code...

get plumage() {return <span class="pd_maroon1">this._speciesDelegate.plumage</span>;}

get airSpeedVelocity() {return <span class="pd_maroon1">this._speciesDelegate.airSpeedVelocity</span>;}</pre>
<p class="pro-title"><em>class SpeciesDelegate&#8230;</em></p>
<p class="codelink"><a id="p0396_02a" href="ch12_images.xhtml#p0396_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get airSpeedVelocity() {return null;}</span></pre>
<p class="indent">I like this, as it simplifies the delegating methods on <code>Bird</code>. I can easily see which behavior is delegated to the species delegate and which stays behind.</p>
<p class="indent">Here&#8217;s the final state of these classes:</p>
<p class="codelink"><a id="p0396_03a" href="ch12_images.xhtml#p0396_03">Click here to view code image</a></p>
<pre class="pre"><strong><span class="pd_green">function createBird</span></strong>(data) {
  return new Bird(data);
}

<span epub:type="pagebreak" id="page_397"/><strong><span class="pd_green">class Bird</span></strong> {
  <strong><span class="pd_green">constructor</span></strong>(data) {
    this._name = data.name;
    this._plumage = data.plumage;
    this._speciesDelegate = this.selectSpeciesDelegate(data);
  }
  <strong><span class="pd_green">get name</span></strong>()    {return this._name;}
  <strong><span class="pd_green">get plumage</span></strong>() {return this._speciesDelegate.plumage;}
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {return this._speciesDelegate.airSpeedVelocity;}

  <strong><span class="pd_green">selectSpeciesDelegate</span></strong>(data) {
    switch(data.type) {
      case 'EuropeanSwallow':
        return new EuropeanSwallowDelegate(data, this);
      case 'AfricanSwallow':
        return new AfricanSwallowDelegate(data, this);
      case 'NorweigianBlueParrot':
        return new NorwegianBlueParrotDelegate(data, this);
      default: return new SpeciesDelegate(data, this);
    }
  }
  // rest of bird's code...
}

<strong><span class="pd_green">class SpeciesDelegate</span></strong> {
  <strong><span class="pd_green">constructor</span></strong>(data, bird) {
    this._bird = bird;
  }
  <strong><span class="pd_green">get plumage</span></strong>() {
    return this._bird._plumage || "average";
  }
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {return null;}
}

<strong><span class="pd_green">class EuropeanSwallowDelegate</span></strong> extends SpeciesDelegate {
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {return 35;}
}

<strong><span class="pd_green">class AfricanSwallowDelegate</span></strong> extends SpeciesDelegate {
  <strong><span class="pd_green">constructor</span></strong>(data, bird) {
    super(data,bird);
    this._numberOfCoconuts = data.numberOfCoconuts;
  }
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {
    return 40 - 2 * this._numberOfCoconuts;
  }
}

<span epub:type="pagebreak" id="page_398"/><strong><span class="pd_green">class NorwegianBlueParrotDelegate</span></strong> extends SpeciesDelegate {
  <strong><span class="pd_green">constructor</span></strong>(data, bird) {
    super(data, bird);
    this._voltage = data.voltage;
    this._isNailed = data.isNailed;
  }
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {
    return (this._isNailed) ? 0 : 10 + this._voltage / 10;
  }
  <strong><span class="pd_green">get plumage</span></strong>() {
    if (this._voltage &gt; 100) return "scorched";
    else return this._bird._plumage || "beautiful";
  }
}</pre>
<p class="indent">This example replaces the original subclasses with a delegate, but there is still a very similar inheritance structure in <code>SpeciesDelegate</code>. Have I gained anything from this refactoring, other than freeing up inheritance on <code>Bird</code>? The species inheritance is now more tightly scoped, covering just the data and functions that vary due to the species. Any code that&#8217;s the same for all species remains on <code>Bird</code> and its future subclasses.</p>
<p class="indent">I could apply the same idea of creating a superclass delegate to the booking example earlier. This would allow me to replace those methods on <code>Booking</code> that have dispatch logic with simple calls to the delegate and letting its inheritance sort out the dispatch. However, it&#8217;s nearly dinner time, so I&#8217;ll leave that as an exercise for the reader.</p>
<p class="indent">These examples illustrate that the phrase &#8220;Favor object composition over class inheritance&#8221; might better be said as &#8220;Favor a judicious mixture of composition and inheritance over either alone&#8221;&#8212;but I fear that is not as catchy.</p>
<h3 class="h3" id="ch12lev1sec11"><span epub:type="pagebreak" id="page_399"/>Replace Superclass with Delegate</h3>
<p class="noindent">formerly: <em>Replace Inheritance with Delegation</em></p>
<figure class="fig-group">
<img src="graphics/p0399_01.jpg" aria-describedby="alt_p0399_01" alt="A representation for replacing the inheritance with a delegate using the refactoring technique."/>
<aside class="hidden" id="alt_p0399_01">
<p>The diagrammatic representation of a delegate replacing a superclass is shown at the top, with the actual code at the bottom reading, class List {. . .} class Stack extends List {. . .} The code after refactoring reads, class Stack { constructor () { this._storage = new List (); } } class List {. . .}</p>
</aside>
</figure>
<h4 class="h4" id="ch12lev2sec29">Motivation</h4>
<p class="noindent">In object-oriented programs, inheritance is a powerful and easily available way to reuse existing functionality. I inherit from some existing class, then override and add additional features. But subclassing can be done in a way that leads to confusion and complication.</p>
<p class="indent">One of the classic examples of mis-inheritance from the early days of objects was making a stack be a subclass of list. The idea that led to this was reusing of list&#8217;s data storage and operations to manipulate it. While it&#8217;s good to reuse, this inheritance had a problem: All the operations of the list were present on the interface of the stack, although most of them were not applicable to a stack. A better approach is to make the list into a field of the stack and delegate the necessary operations to it.</p>
<p class="indent">This is an example of one reason to use Replace Superclass with Delegate&#8212;if functions of the superclass don&#8217;t make sense on the subclass, that&#8217;s a sign that I shouldn&#8217;t be using inheritance to use the superclass&#8217;s functionality.</p>
<p class="indent"><span epub:type="pagebreak" id="page_400"/>As well as using all the functions of the superclass, it should also be true that every instance of the subclass is an instance of the superclass and a valid object in all cases where we&#8217;re using the superclass. If I have a car model class, with things like name and engine size, I might think I could reuse these features to represent a physical car, adding functions for VIN number and manufacturing date. This is a common, and often subtle, modeling mistake which I&#8217;ve called the type-instance homonym [<a href="biblo.xhtml#bib37">mf-tih</a>].</p>
<p class="indent">These are both examples of problems leading to confusion and errors&#8212;which can be easily avoided by replacing inheritance with delegation to a separate object. Using delegation makes it clear that it is a separate thing&#8212;one where only some of the functions carry over.</p>
<p class="indent">Even in cases where the subclass is reasonable modeling, I use Replace Super-class with Delegate because the relationship between a sub- and superclass is highly coupled, with the subclass easily broken by changes in the superclass. The downside is that I need to write a forwarding function for any function that is the same in the host and in the delegate&#8212;but, fortunately, even though such forwarding functions are boring to write, they are too simple to get wrong.</p>
<p class="indent">As a consequence of all this, some people advise avoiding inheritance entirely&#8212;but I don&#8217;t agree with that. Provided the appropriate semantic conditions apply (every method on the supertype applies to the subtype, every instance of the subtype is an instance of the supertype), inheritance is a simple and effective mechanism. I can easily apply Replace Superclass with Delegate should the situation change and inheritance is no longer the best option. So my advice is to (mostly) use inheritance first, and apply Replace Superclass with Delegate when (and if) it becomes a problem.</p>
<h4 class="h4" id="ch12lev2sec30">Mechanics</h4>
<ul class="square">
<li><p>Create a field in the subclass that refers to the superclass object. Initialize this delegate reference to a new instance.</p></li>
<li><p>For each element of the superclass, create a forwarding function in the subclass that forwards to the delegate reference. Test after forwarding each consistent group.</p>
<div class="blockquote">
<p class="noindent">Most of the time you can test after each function that&#8217;s forwarded, but, for example, get/set pairs can only be tested once both have been moved.</p>
</div></li>
<li><p>When all superclass elements have been overridden with forwarders, remove the inheritance link.</p></li>
</ul>
<h4 class="h4" id="ch12lev2sec31"><span epub:type="pagebreak" id="page_401"/>Example</h4>
<p class="noindent">I recently was consulting for an old town&#8217;s library of ancient scrolls. They keep details of their scrolls in a catalog. Each scroll has an ID number and records its title and list of tags.</p>
<p class="pro-title"><em>class CatalogItem&#8230;</em></p>
<p class="codelink"><a id="p0401_01a" href="ch12_images.xhtml#p0401_01">Click here to view code image</a></p>
<pre class="pre">constructor(id, title, tags) {
  this._id = id;
  this._title = title;
  this._tags = tags;
}

get id() {return this._id;}
get title() {return this._title;}
hasTag(arg) {return this._tags.includes(arg);}</pre>
<p class="indent">One of the things that scrolls need is regular cleaning. The code for that uses the catalog item and extends it with the data it needs for cleaning.</p>
<p class="pro-title"><em>class Scroll extends CatalogItem&#8230;</em></p>
<p class="codelink"><a id="p0401_02a" href="ch12_images.xhtml#p0401_02">Click here to view code image</a></p>
<pre class="pre">constructor(id, title, tags, dateLastCleaned) {
  super(id, title, tags);
  this._lastCleaned = dateLastCleaned;
}

needsCleaning(targetDate) {
  const threshold = this.hasTag("revered") ? 700 : 1500;
  return this.daysSinceLastCleaning(targetDate) &gt; threshold ;
}
daysSinceLastCleaning(targetDate) {
  return this._lastCleaned.until(targetDate, ChronoUnit.DAYS);
}</pre>
<p class="indent">This is an example of a common modeling error. There is a difference between the physical scroll and the catalog item. The scroll describing the treatment for the greyscale disease may have several copies, but be just one item in the catalog.</p>
<p class="indent">It many situations, I can get away with an error like this. I can think of the title and tags as copies of data in the catalog. Should this data never change, I can get away with this representation. But if I need to update either, I must be careful to ensure that all copies of the same catalog item are updated correctly.</p>
<p class="indent">Even without this issue, I&#8217;d still want to change the relationship. Using catalog item as a superclass to scroll is likely to confuse programmers in the future, and is thus a poor model to work with.</p>
<p class="indent"><span epub:type="pagebreak" id="page_402"/>I begin by creating a property in <code>Scroll</code> that refers to the catalog item, initializing it with a new instance.</p>
<p class="pro-title"><em>class Scroll extends CatalogItem&#8230;</em></p>
<p class="codelink"><a id="p0402_01a" href="ch12_images.xhtml#p0402_01">Click here to view code image</a></p>
<pre class="pre">constructor(id, title, tags, dateLastCleaned) {
  super(id, title, tags);
  <span class="pd_maroon1">this._catalogItem = new CatalogItem(id, title, tags);</span>
  this._lastCleaned = dateLastCleaned;
}</pre>
<p class="indent">I create forwarding methods for each element of the superclass that I use on the subclass.</p>
<p class="pro-title"><em>class Scroll&#8230;</em></p>
<p class="codelink"><a id="p0402_02a" href="ch12_images.xhtml#p0402_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get id() {return this._catalogItem.id;}</span>
<span class="pd_maroon1">get title() {return this._catalogItem.title;}</span>
<span class="pd_maroon1">hasTag(aString) {return this._catalogItem.hasTag(aString);}</span></pre>
<p class="indent">I remove the inheritance link to the catalog item.</p>
<p class="codelink"><a id="p0402_03a" href="ch12_images.xhtml#p0402_03">Click here to view code image</a></p>
<pre class="pre">class Scroll <span class="strike"><span class="pd_maroon1">extends CatalogItem</span></span>{
  constructor(id, title, tags, dateLastCleaned) {
    <span class="strike"><span class="pd_maroon1">super(id, title, tags);</span></span>
    this._catalogItem = new CatalogItem(id, title, tags);
    this._lastCleaned = dateLastCleaned;
  }</pre>
<p class="indent">Breaking the inheritance link finishes the basic Replace Superclass with Delegate refactoring, but there is something more I need to do in this case.</p>
<p class="indent">The refactoring shifts the role of the catalog item to that of a component of scroll; each scroll contains a unique instance of a catalog item. In many cases where I do this refactoring, this is enough. However, in this situation a better model is to link the greyscale catalog item to the six scrolls in the library that are copies of that writing. Doing this is, essentially, <em><span class="pd_maroon"><a class="pd_maroon" href="ch09.xhtml#ch09lev1sec5">Change Value to Reference</a> (<a class="pd_maroon" href="ch09.xhtml#page_256">256</a>)</span></em>.</p>
<p class="indent">There&#8217;s a problem that I have to fix, however, before I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch09.xhtml#ch09lev1sec5">Change Value to Reference</a> (<a class="pd_maroon" href="ch09.xhtml#page_256">256</a>)</span></em>. In the original inheritance structure, the scroll used the catalog item&#8217;s ID field to store its ID. But if I treat the catalog item as a reference, it needs to use that ID for the catalog item ID rather than the scroll ID. This means I need to create an ID field on scroll and use that instead of one in catalog item. It&#8217;s a sort-of move, sort-of split.</p>
<p class="pro-title"><em>class Scroll&#8230;</em></p>
<p class="codelink"><a id="p0402_04a" href="ch12_images.xhtml#p0402_04">Click here to view code image</a></p>
<pre class="pre">constructor(id, title, tags, dateLastCleaned) {
  <span class="pd_maroon1">this._id = id;</span>
  this._catalogItem = new CatalogItem(null, title, tags);
  this._lastCleaned = dateLastCleaned;
}

get id() {return <span class="pd_maroon1">this._id</span>;}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_403"/>Creating a catalog item with a null ID would usually raise red flags and cause alarms to sound. But that&#8217;s just temporary while I get things into shape. Once I&#8217;ve done that, the scrolls will refer to a shared catalog item with its proper ID.</p>
<p class="indent">Currently the scrolls are loaded as part of a load routine.</p>
<p class="pro-title"><em>load routine&#8230;</em></p>
<p class="codelink"><a id="p0403_01a" href="ch12_images.xhtml#p0403_01">Click here to view code image</a></p>
<pre class="pre">const scrolls = aDocument
      .map(record =&gt; new Scroll(record.id,
                                record.catalogData.title,
                                record.catalogData.tags,
                                LocalDate.parse(record.lastCleaned)));</pre>
<p class="indent">The first step in <em><span class="pd_maroon"><a class="pd_maroon" href="ch09.xhtml#ch09lev1sec5">Change Value to Reference</a> (<a class="pd_maroon" href="ch09.xhtml#page_256">256</a>)</span></em> is finding or creating a repository. I find there is a repository that I can easily import into the load routine. The repository supplies catalog items indexed by an ID. My next task is to see how to get that ID into the constructor of the scroll. Fortunately, it&#8217;s present in the input data and was being ignored as it wasn&#8217;t useful when using inheritance. With that sorted out, I can now use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to add both the catalog and the catalog item&#8217;s ID to the constructor parameters.</p>
<p class="pro-title"><em>load routine&#8230;</em></p>
<p class="codelink"><a id="p0403_02a" href="ch12_images.xhtml#p0403_02">Click here to view code image</a></p>
<pre class="pre">const scrolls = aDocument
      .map(record =&gt; new Scroll(record.id,
                                record.catalogData.title,
                                record.catalogData.tags,
                                LocalDate.parse(record.lastCleaned),
                                <span class="pd_maroon1">record.catalogData.id,</span>
                                <span class="pd_maroon1">catalog</span>));</pre>
<p class="pro-title"><em>class Scroll&#8230;</em></p>
<p class="codelink"><a id="p0403_03a" href="ch12_images.xhtml#p0403_03">Click here to view code image</a></p>
<pre class="pre">constructor(id, title, tags, dateLastCleaned, <span class="pd_maroon1">catalogID, catalog</span>) {
  this._id = id;
  this._catalogItem = new CatalogItem(null, title, tags);
  this._lastCleaned = dateLastCleaned;
}</pre>
<p class="indent">I now modify the constructor to use the catalog ID to look up the catalog item and use it instead of creating a new one.</p>
<p class="pro-title"><em>class Scroll&#8230;</em></p>
<p class="codelink"><a id="p0403_04a" href="ch12_images.xhtml#p0403_04">Click here to view code image</a></p>
<pre class="pre">constructor(id, title, tags, dateLastCleaned, catalogID, catalog) {
  this._id = id;
  this._catalogItem = <span class="pd_maroon1">catalog.get(catalogID);</span>
  this._lastCleaned = dateLastCleaned;
}</pre>
<p class="indent">I no longer need the title and tags passed into the constructor, so I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to remove them.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_404"/><em>load routine&#8230;</em></p>
<p class="codelink"><a id="p0404_01a" href="ch12_images.xhtml#p0404_01">Click here to view code image</a></p>
<pre class="pre">const scrolls = aDocument
      .map(record =&gt; new Scroll(record.id,
                                <span class="strike"><span class="pd_maroon1">record.catalogData.title,</span></span>
                                <span class="strike"><span class="pd_maroon1">record.catalogData.tags,</span></span>
                                LocalDate.parse(record.lastCleaned),
                                record.catalogData.id,
                                catalog));</pre>
<p class="pro-title"><em>class Scroll&#8230;</em></p>
<p class="codelink"><a id="p0404_02a" href="ch12_images.xhtml#p0404_02">Click here to view code image</a></p>
<pre class="pre">constructor(id, <span class="strike"><span class="pd_maroon1">title, tags,</span></span> dateLastCleaned, catalogID, catalog) {
  this._id = id;
  this._catalogItem = catalog.get(catalogID);
  this._lastCleaned = dateLastCleaned;
}</pre>
</section>
</body>
</html>