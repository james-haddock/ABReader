<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>Refactoring: Improving the Design of Existing Code</title>
<link rel="stylesheet" type="text/css" href="9780134757704.css"/>
</head>
<body>
<section epub:type="frontmatter">
<h2 class="h2a" id="foreword"><span epub:type="pagebreak" id="page_xi"/>Foreword to the First Edition</h2>
<p class="noindent">&#8220;Refactoring&#8221; was conceived in Smalltalk circles, but it wasn&#8217;t long before it found its way into other programming language camps. Because refactoring is integral to framework development, the term comes up quickly when &#8220;frameworkers&#8221; talk about their craft. It comes up when they refine their class hierarchies and when they rave about how many lines of code they were able to delete. Frameworkers know that a framework won&#8217;t be right the first time around&#8212;it must evolve as they gain experience. They also know that the code will be read and modified more frequently than it will be written. The key to keeping code readable and modifiable is refactoring&#8212;for frameworks, in particular, but also for software in general.</p>
<p class="indent">So, what&#8217;s the problem? Simply this: Refactoring is risky. It requires changes to working code that can introduce subtle bugs. Refactoring, if not done properly, can set you back days, even weeks. And refactoring becomes riskier when practiced informally or ad hoc. You start digging in the code. Soon you discover new opportunities for change, and you dig deeper. The more you dig, the more stuff you turn up. . .and the more changes you make. Eventually you dig yourself into a hole you can&#8217;t get out of. To avoid digging your own grave, refactoring must be done systematically. When my coauthors and I wrote <em>Design Patterns</em>, we mentioned that design patterns provide targets for refactorings. However, identifying the target is only one part of the problem; transforming your code so that you get there is another challenge.</p>
<p class="indent">Martin Fowler and the contributing authors make an invaluable contribution to object-oriented software development by shedding light on the refactoring process. This book explains the principles and best practices of refactoring, and points out when and where you should start digging in your code to improve it. At the book&#8217;s core is a comprehensive catalog of refactorings. Each refactoring describes the motivation and mechanics of a proven code transformation. Some of the refactorings, such as Extract Method or Move Field, may seem obvious.</p>
<p class="indent">But don&#8217;t be fooled. Understanding the mechanics of such refactorings is the key to refactoring in a disciplined way. The refactorings in this book will help you change your code one small step at a time, thus reducing the risks of evolving <span epub:type="pagebreak" id="page_xii"/>your design. You will quickly add these refactorings and their names to your development vocabulary.</p>
<p class="indent">My first experience with disciplined, &#8220;one step at a time&#8221; refactoring was when I was pair-programming at 30,000 feet with Kent Beck. He made sure that we applied refactorings from this book&#8217;s catalog one step at a time. I was amazed at how well this practice worked. Not only did my confidence in the resulting code increase, I also felt less stressed. I highly recommend you try these refactorings: You and your code will feel much better for it.</p>
<p class="right"><em>&#8212; Erich Gamma, Object Technology International, Inc.</em><br/><em>January 1999</em></p>
</section>
</body>
</html>