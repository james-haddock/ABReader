<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>Refactoring: Improving the Design of Existing Code</title>
<link rel="stylesheet" type="text/css" href="9780134757704.css"/>
</head>
<body>
<section epub:type="bodymatter">
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_259"/>Chapter 10<br/>Simplifying Conditional Logic</h2>
<p class="noindent">Much of the power of programs comes from their ability to implement conditional logic&#8212;but, sadly, much of the complexity of programs lies in these conditionals. I often use refactoring to make conditional sections easier to understand. I regularly apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec1">Decompose Conditional</a> (<a class="pd_maroon" href="ch10.xhtml#page_260">260</a>)</span></em> to complicated conditionals, and I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec2">Consolidate Conditional Expression</a> (<a class="pd_maroon" href="ch10.xhtml#page_263">263</a>)</span></em> to make logical combinations clearer. I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec3">Replace Nested Conditional with Guard Clauses</a> (<a class="pd_maroon" href="ch10.xhtml#page_266">266</a>)</span></em> to clarify cases where I want to run some pre-checks before my main processing. If I see several conditions using the same switching logic, it&#8217;s a good time to pull <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec4">Replace Conditional with Polymorphism</a> (<a class="pd_maroon" href="ch10.xhtml#page_272">272</a>)</span></em> out the box.</p>
<p class="indent">A lot of conditionals are used to handle special cases, such as nulls; if that logic is mostly the same, then <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec5">Introduce Special Case</a> (<a class="pd_maroon" href="ch10.xhtml#page_289">289</a>)</span></em> (often referred to as <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec5">Introduce Null Object</a> (<a class="pd_maroon" href="ch10.xhtml#page_289">289</a>)</span></em>) can remove a lot of duplicate code. And, although I like to remove conditions a lot, if I want to communicate (and check) a program&#8217;s state, I find <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec6">Introduce Assertion</a> (<a class="pd_maroon" href="ch10.xhtml#page_302">302</a>)</span></em> a worthwhile addition.</p>
<h3 class="h3" id="ch10lev1sec1"><span epub:type="pagebreak" id="page_260"/>Decompose Conditional</h3>
<figure class="fig-group">
<img src="graphics/p0260_01.jpg" aria-describedby="alt_p0260_01" alt="A figure illustrates how the refactoring technique is used to decompose the conditional expression."/>
<aside class="hidden" id="alt_p0260_01">
<p>The diagrammatic representation shows a complex conditional (if-else) statement decomposed to chunks of code, each with a function call. The actual code reads, if (!aDate.isBefore(plan.summerStart) &#38;&#38; !aDate.isAfter(plan.summerEnd)) charge = quantity * plan.summerRate; else charge = quantity * plam.regularRate + plan.regularServiceCharge; The code after refactoring reads, if (summer()) charge = summerCharge(); else charge = regularCharge();</p>
</aside>
</figure>
<h4 class="h4" id="ch10lev2sec1">Motivation</h4>
<p class="noindent">One of the most common sources of complexity in a program is complex conditional logic. As I write code to do various things depending on various conditions, I can quickly end up with a pretty long function. Length of a function is in itself a factor that makes it harder to read, but conditions increase the difficulty. The problem usually lies in the fact that the code, both in the condition checks and in the actions, tells me what happens but can easily obscure <em>why</em> it happens.</p>
<p class="indent">As with any large block of code, I can make my intention clearer by decomposing it and replacing each chunk of code with a function call named after the intention of that chunk. With conditions, I particularly like doing this for the conditional part and each of the alternatives. This way, I highlight the condition and make it clear what I&#8217;m branching on. I also highlight the reason for the branching.</p>
<p class="indent"><span epub:type="pagebreak" id="page_261"/>This is really just a particular case of applying <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> to my code, but I like to highlight this case as one where I&#8217;ve often found a remarkably good value for the exercise.</p>
<h4 class="h4" id="ch10lev2sec2">Mechanics</h4>
<ul class="square">
<li><p>Apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the condition and each leg of the conditional.</p></li>
</ul>
<h4 class="h4" id="ch10lev2sec3">Example</h4>
<p class="noindent">Suppose I&#8217;m calculating the charge for something that has separate rates for winter and summer:</p>
<p class="codelink"><a id="p0261_01a" href="ch10_images.xhtml#p0261_01">Click here to view code image</a></p>
<pre class="pre">if (!aDate.isBefore(plan.summerStart) &amp;&amp; !aDate.isAfter(plan.summerEnd))
  charge = quantity * plan.summerRate;
else
  charge = quantity * plan.regularRate + plan.regularServiceCharge;</pre>
<p class="indent">I extract the condition into its own function.</p>
<p class="codelink"><a id="p0261_02a" href="ch10_images.xhtml#p0261_02">Click here to view code image</a></p>
<pre class="pre">if (<span class="pd_maroon1">summer()</span>)
  charge = quantity * plan.summerRate;
else
  charge = quantity * plan.regularRate + plan.regularServiceCharge;

function <span class="pd_maroon1">summer()</span> {
  return !aDate.isBefore(plan.summerStart) &amp;&amp; !aDate.isAfter(plan.summerEnd);
}</pre>
<p class="indent">Then I do the <code>then</code> leg:</p>
<p class="codelink"><a id="p0261_03a" href="ch10_images.xhtml#p0261_03">Click here to view code image</a></p>
<pre class="pre">if (summer())
  charge = <span class="pd_maroon1">summerCharge</span>();
else
  charge = quantity * plan.regularRate + plan.regularServiceCharge;

function summer() {
  return !aDate.isBefore(plan.summerStart) &amp;&amp; !aDate.isAfter(plan.summerEnd);
}
function <span class="pd_maroon1">summerCharge</span>() {
  return quantity * plan.summerRate;
}</pre>
<p class="indent">Finally, the <code>else</code> leg:</p>
<p class="codelink"><a id="p0262_01a" href="ch10_images.xhtml#p0262_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_262"/>if (summer())
  charge = summerCharge();
else
  charge = <span class="pd_maroon1">regularCharge</span>();

function summer() {
  return !aDate.isBefore(plan.summerStart) &amp;&amp; !aDate.isAfter(plan.summerEnd);
}
function summerCharge() {
  return quantity * plan.summerRate;
}
function <span class="pd_maroon1">regularCharge</span>() {
  return quantity * plan.regularRate + plan.regularServiceCharge;
}</pre>
<p class="indent">With that done, I like to reformat the conditional using the ternary operator.</p>
<p class="codelink"><a id="p0262_02a" href="ch10_images.xhtml#p0262_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">charge = summer() ? summerCharge() : regularCharge();</span>

function summer() {
  return !aDate.isBefore(plan.summerStart) &amp;&amp; !aDate.isAfter(plan.summerEnd);
}
function summerCharge() {
  return quantity * plan.summerRate;
}
function regularCharge() {
  return quantity * plan.regularRate + plan.regularServiceCharge;
}</pre>
<h3 class="h3" id="ch10lev1sec2"><span epub:type="pagebreak" id="page_263"/>Consolidate Conditional Expression</h3>
<figure class="fig-group">
<img src="graphics/p0263_01.jpg" aria-describedby="alt_p0263_01" alt="A figure illustrated how the refactoring technique is used to consolidate the conditional expression."/>
<aside class="hidden" id="alt_p0263_01">
<p>The diagrammatic representation shows three if statements consolidated to one if statement. The actual code reads, if (anEmployee.seniority &#60; 2) return 0; if (anEmployee.monthsDisabled &#62; 12) return 0; if (anEmployee.isPartTime) return 0; The code after refactoring reads, if (isNotEligableForDisabilty()) return 0; function isNotEligableForDisability () { return ((anEmployee.seniority &#60; 2) || (anEmployee.monthDisabled &#62;12) || (anEmployee.isPartTime)); }</p>
</aside>
</figure>
<h4 class="h4" id="ch10lev2sec4">Motivation</h4>
<p class="noindent">Sometimes, I run into a series of conditional checks where each check is different yet the resulting action is the same. When I see this, I use <code>and</code> and <code>or</code> operators to consolidate them into a single conditional check with a single result.</p>
<p class="indent">Consolidating the conditional code is important for two reasons. First, it makes it clearer by showing that I&#8217;m really making a single check that combines other checks. The sequence has the same effect, but it looks like I&#8217;m carrying out a sequence of separate checks that just happen to be close together. The second reason I like to do this is that it often sets me up for <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em>. Extracting a condition is one of the most useful things I can do to clarify my code. It replaces a statement of what I&#8217;m doing with why I&#8217;m doing it.</p>
<p class="indent">The reasons in favor of consolidating conditionals also point to the reasons against doing it. If I consider it to be truly independent checks that shouldn&#8217;t be thought of as a single check, I don&#8217;t do the refactoring.</p>
<h4 class="h4" id="ch10lev2sec5"><span epub:type="pagebreak" id="page_264"/>Mechanics</h4>
<ul class="square">
<li><p>Ensure that none of the conditionals have any side effects.</p>
<div class="blockquote">
<p class="noindent">If any do, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec1">Separate Query from Modifier</a> (<a class="pd_maroon" href="ch11.xhtml#page_306">306</a>)</span></em> on them first.</p>
</div></li>
<li><p>Take two of the conditional statements and combine their conditions using a logical operator.</p>
<div class="blockquote">
<p class="noindent">Sequences combine with <code>or</code>, nested <code>if</code> statements combine with <code>and</code>.</p>
</div></li>
<li><p>Test.</p></li>
<li><p>Repeat combining conditionals until they are all in a single condition.</p></li>
<li><p>Consider using <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the resulting condition.</p></li>
</ul>
<h4 class="h4" id="ch10lev2sec6">Example</h4>
<p class="noindent">Perusing some code, I see the following:</p>
<p class="codelink"><a id="p0264_01a" href="ch10_images.xhtml#p0264_01">Click here to view code image</a></p>
<pre class="pre">function disabilityAmount(anEmployee) {
  if (anEmployee.seniority &lt; 2) return 0;
  if (anEmployee.monthsDisabled &gt; 12) return 0;
  if (anEmployee.isPartTime) return 0;
  // compute the disability amount</pre>
<p class="indent">It&#8217;s a sequence of conditional checks which all have the same result. Since the result is the same, I should combine these conditions into a single expression. For a sequence like this, I do it using an <code>or</code> operator.</p>
<p class="codelink"><a id="p0264_02a" href="ch10_images.xhtml#p0264_02">Click here to view code image</a></p>
<pre class="pre">function disabilityAmount(anEmployee) {
  if ((anEmployee.seniority &lt; 2)
      <span class="pd_maroon1">||</span> (anEmployee.monthsDisabled &gt; 12)) return 0;
  if (anEmployee.isPartTime) return 0;
  // compute the disability amount</pre>
<p class="indent">I test, then fold in the other condition:</p>
<p class="codelink"><a id="p0264_03a" href="ch10_images.xhtml#p0264_03">Click here to view code image</a></p>
<pre class="pre">function disabilityAmount(anEmployee) {
  if ((anEmployee.seniority &lt; 2)
      || (anEmployee.monthsDisabled &gt; 12)
      <span class="pd_maroon1">||</span> (anEmployee.isPartTime)) return 0;
  // compute the disability amount</pre>
<p class="indent">Once I have them all together, I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the condition.</p>
<p class="codelink"><a id="p0265_01a" href="ch10_images.xhtml#p0265_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_265"/>function disabilityAmount(anEmployee) {
  if (<span class="pd_maroon1">isNotEligableForDisability</span>()) return 0;
  // compute the disability amount

  function <span class="pd_maroon1">isNotEligableForDisability</span>() {
    return ((anEmployee.seniority &lt; 2)
            || (anEmployee.monthsDisabled &gt; 12)
            || (anEmployee.isPartTime));
  }</pre>
<h4 class="h4" id="ch10lev2sec7">Example: Using <code>and</code>s</h4>
<p class="noindent">The example above showed combining statements with an <code>or</code>, but I may run into cases that need <code>and</code>s as well. Such a case uses nested <code>if</code> statements:</p>
<p class="codelink"><a id="p0265_02a" href="ch10_images.xhtml#p0265_02">Click here to view code image</a></p>
<pre class="pre">if (anEmployee.onVacation)
  if (anEmployee.seniority &gt; 10)
    return 1;
return 0.5;</pre>
<p class="indent">I combine these using <code>and</code> operators.</p>
<p class="codelink"><a id="p0265_03a" href="ch10_images.xhtml#p0265_03">Click here to view code image</a></p>
<pre class="pre">if ((anEmployee.onVacation)
    <span class="pd_maroon1">&amp;&amp;</span> (anEmployee.seniority &gt; 10)) return 1;
return 0.5;</pre>
<p class="indent">If I have a mix of these, I can combine using <code>and</code> and <code>or</code> operators as needed. When this happens, things are likely to get messy, so I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> liberally to make it all understandable.</p>
<h3 class="h3" id="ch10lev1sec3"><span epub:type="pagebreak" id="page_266"/>Replace Nested Conditional with Guard Clauses</h3>
<figure class="fig-group">
<img src="graphics/p0266_01.jpg" aria-describedby="alt_p0266_01" alt="A figure illustrated how the refactoring technique is used to replace the nested conditional expressions with guard clauses."/>
<aside class="hidden" id="alt_p0266_01">
<p>The diagrammatic representation shows nested if-else statements, that are being replaced with guard clauses. The actual code reads, function getPayAmount() { let result; if (isDead) result = deadAmount(); else { if (isSeparated) result = separatedAmount(); else { if (isRetired) result = retiredAmount(); else result = normalPayAmount(); } } return result; } The code after refactoring reads, function getPayAmount() { if (isDead) return deadAmount(); if (isSeparated) return separatedAmount(); if (isRetired) return retiredAmount(); return normalPayAmount(); }</p>
</aside>
</figure>
<h4 class="h4" id="ch10lev2sec8"><span epub:type="pagebreak" id="page_267"/>Motivation</h4>
<p class="noindent">I often find that conditional expressions come in two styles. In the first style, both legs of the conditional are part of normal behavior, while in the second style, one leg is normal and the other indicates an unusual condition.</p>
<p class="indent">These kinds of conditionals have different intentions&#8212;and these intentions should come through in the code. If both are part of normal behavior, I use a condition with an <code>if</code> and an <code>else</code> leg. If the condition is an unusual condition, I check the condition and return if it&#8217;s true. This kind of check is often called a <strong>guard clause</strong>.</p>
<p class="indent">The key point of Replace Nested Conditional with Guard Clauses is emphasis. If I&#8217;m using an if-then-else construct, I&#8217;m giving equal weight to the <code>if</code> leg and the <code>else</code> leg. This communicates to the reader that the legs are equally likely and important. Instead, the guard clause says, &#8220;This isn&#8217;t the core to this function, and if it happens, do something and get out.&#8221;</p>
<p class="indent">I often find I use Replace Nested Conditional with Guard Clauses when I&#8217;m working with a programmer who has been taught to have only one entry point and one exit point from a method. One entry point is enforced by modern languages, but one exit point is really not a useful rule. Clarity is the key principle: If the method is clearer with one exit point, use one exit point; otherwise don&#8217;t.</p>
<h4 class="h4" id="ch10lev2sec9">Mechanics</h4>
<ul class="square">
<li><p>Select outermost condition that needs to be replaced, and change it into a guard clause.</p></li>
<li><p>Test.</p></li>
<li><p>Repeat as needed.</p></li>
<li><p>If all the guard clauses return the same result, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec2">Consolidate Conditional Expression</a> (<a class="pd_maroon" href="ch10.xhtml#page_263">263</a>)</span></em>.</p></li>
</ul>
<h4 class="h4" id="ch10lev2sec10">Example</h4>
<p class="noindent">Here&#8217;s some code to calculate a payment amount for an employee. It&#8217;s only relevant if the employee is still with the company, so it has to check for the two other cases.</p>
<p class="codelink"><a id="p0268_01a" href="ch10_images.xhtml#p0268_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_268"/>function payAmount(employee) {
  let result;
  if(employee.isSeparated) {
    result = {amount: 0, reasonCode: "SEP"};
  }
  else {
    if (employee.isRetired) {
      result = {amount: 0, reasonCode: "RET"};
    }
    else {
      // logic to compute amount
      lorem.ipsum(dolor.sitAmet);
      consectetur(adipiscing).elit();
      sed.do.eiusmod = tempor.incididunt.ut(labore) &amp;&amp; dolore(magna.aliqua);
      ut.enim.ad(minim.veniam);
      result = someFinalComputation();
    }
  }
  return result;
}</pre>
<p class="indent">Nesting the conditionals here masks the true meaning of what it going on. The primary purpose of this code only applies if these conditions aren&#8217;t the case. In this situation, the intention of the code reads more clearly with guard clauses.</p>
<p class="indent">As with any refactoring change, I like to take small steps, so I begin with the topmost condition.</p>
<p class="codelink"><a id="p0268_02a" href="ch10_images.xhtml#p0268_02">Click here to view code image</a></p>
<pre class="pre">function payAmount(employee) {
  let result;
  <span class="pd_maroon1">if (employee.isSeparated) return {amount: 0, reasonCode: "SEP"};</span>
  if (employee.isRetired) {
    result = {amount: 0, reasonCode: "RET"};
  }
  else {
    // logic to compute amount
    lorem.ipsum(dolor.sitAmet);
    consectetur(adipiscing).elit();
    sed.do.eiusmod = tempor.incididunt.ut(labore) &amp;&amp; dolore(magna.aliqua);
    ut.enim.ad(minim.veniam);
    result = someFinalComputation();
  }
  return result;
}</pre>
<p class="indent">I test that change and move on to the next one.</p>
<p class="codelink"><a id="p0269_01a" href="ch10_images.xhtml#p0269_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_269"/>function payAmount(employee) {
  let result;
  if (employee.isSeparated) return {amount: 0, reasonCode: "SEP"};
  <span class="pd_maroon1">if (employee.isRetired)   return {amount: 0, reasonCode: "RET"};</span>
  // logic to compute amount
  lorem.ipsum(dolor.sitAmet);
  consectetur(adipiscing).elit();
  sed.do.eiusmod = tempor.incididunt.ut(labore) &amp;&amp; dolore(magna.aliqua);
  ut.enim.ad(minim.veniam);
  result = someFinalComputation();
  return result;
}</pre>
<p class="indent">At which point the result variable isn&#8217;t really doing anything useful, so I remove it.</p>
<p class="codelink"><a id="p0269_02a" href="ch10_images.xhtml#p0269_02">Click here to view code image</a></p>
<pre class="pre">function payAmount(employee) {
  <span class="strike"><span class="pd_maroon1">let result;</span></span>
  if (employee.isSeparated) return {amount: 0, reasonCode: "SEP"};
  if (employee.isRetired)   return {amount: 0, reasonCode: "RET"};
  // logic to compute amount
  lorem.ipsum(dolor.sitAmet);
  consectetur(adipiscing).elit();
  sed.do.eiusmod = tempor.incididunt.ut(labore) &amp;&amp; dolore(magna.aliqua);
  ut.enim.ad(minim.veniam);
  <span class="pd_maroon1">return someFinalComputation();</span>
}</pre>
<p class="indent">The rule is that you always get an extra strawberry when you remove a mutable variable.</p>
<h4 class="h4" id="ch10lev2sec11">Example: Reversing the Conditions</h4>
<p class="noindent">When reviewing the manuscript of the first edition of this book, Joshua Kerievsky pointed out that we often do Replace Nested Conditional with Guard Clauses by reversing the conditional expressions. Even better, he gave me an example so I didn&#8217;t have to further tax my imagination.</p>
<p class="codelink"><a id="p0269_03a" href="ch10_images.xhtml#p0269_03">Click here to view code image</a></p>
<pre class="pre">function adjustedCapital(anInstrument) {
  let result = 0;
  if (anInstrument.capital &gt; 0) {
    if (anInstrument.interestRate &gt; 0 &amp;&amp; anInstrument.duration &gt; 0) {
      result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
    }
  }
  return result;
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_270"/>Again, I make the replacements one at a time, but this time I reverse the condition as I put in the guard clause.</p>
<p class="codelink"><a id="p0270_01a" href="ch10_images.xhtml#p0270_01">Click here to view code image</a></p>
<pre class="pre">function adjustedCapital(anInstrument) {
  let result = 0;
  <span class="pd_maroon1">if (anInstrument.capital &lt;= 0) return result;</span>
  if (anInstrument.interestRate &gt; 0 &amp;&amp; anInstrument.duration &gt; 0) {
    result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
  }
  return result;
}</pre>
<p class="indent">The next conditional is a bit more complicated, so I do it in two steps. First, I simply add a <code>not</code>.</p>
<p class="codelink"><a id="p0270_02a" href="ch10_images.xhtml#p0270_02">Click here to view code image</a></p>
<pre class="pre">function adjustedCapital(anInstrument) {
  let result = 0;
  if (anInstrument.capital &lt;= 0) return result;
  <span class="pd_maroon1">if (!(anInstrument.interestRate &gt; 0 &amp;&amp; anInstrument.duration &gt; 0)) return result;</span>
  result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
  return result;
}</pre>
<p class="indent">Leaving <code>not</code>s in a conditional like that twists my mind around at a painful angle, so I simplify it:</p>
<p class="codelink"><a id="p0270_03a" href="ch10_images.xhtml#p0270_03">Click here to view code image</a></p>
<pre class="pre">function adjustedCapital(anInstrument) {
  let result = 0;
  if (anInstrument.capital &lt;= 0) return result;
  <span class="pd_maroon1">if (anInstrument.interestRate &lt;= 0 || anInstrument.duration &lt;= 0) return result;</span>
  result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
  return result;
}</pre>
<p class="indent">Both of those lines have conditions with the same result, so I apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec2">Consolidate Conditional Expression</a> (<a class="pd_maroon" href="ch10.xhtml#page_263">263</a>)</span></em>.</p>
<p class="codelink"><a id="p0270_04a" href="ch10_images.xhtml#p0270_04">Click here to view code image</a></p>
<pre class="pre">function adjustedCapital(anInstrument) {
  let result = 0;
  if (   anInstrument.capital      &lt;= 0
      || anInstrument.interestRate &lt;= 0
      || anInstrument.duration     &lt;= 0) return result;
  result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
  return result;
}</pre>
<p class="indent">The <code>result</code> variable is doing two things here. Its first setting to zero indicates what to return when the guard clause triggers; its second value is the final computation. I can get rid of it, which both eliminates its double usage and gets me a strawberry.</p>
<p class="codelink"><a id="p0271_01a" href="ch10_images.xhtml#p0271_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_271"/>function adjustedCapital(anInstrument) {
  if (   anInstrument.capital      &lt;= 0
      || anInstrument.interestRate &lt;= 0
      || anInstrument.duration     &lt;= 0) <span class="pd_maroon1">return 0</span>;
  <span class="pd_maroon1">return</span> (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;
}</pre>
<h3 class="h3" id="ch10lev1sec4"><span epub:type="pagebreak" id="page_272"/>Replace Conditional with Polymorphism</h3>
<figure class="fig-group">
<img src="graphics/p0272_01.jpg" aria-describedby="alt_p0272_01" alt="A figure illustrates how the refactoring technique is used to replace the conditional expressions with polymorphism."/>
<aside class="hidden" id="alt_p0272_01">
<p>The diagrammatic representation shows the logic of a complex conditional statement replaced through polymorphism. The actual code reads, switch (bird.type) { case &#39;EuropeanSwallow&#39;: return &#34;average&#34;; case &#39;AfricanSwallow&#39;: return (bird.numberOfCoconuts &#62; 2) ? &#34;tired&#34; : &#34;average&#34;; case &#39;NorwegianBlueParrot&#39;: return (bird.voltage &#62; 100) ? &#34;scorched&#34; : &#34;beautiful&#34;; default: return &#34;unknown&#34;; The code after refactoring reads, class EuropeanSwallow { get plumage() { return &#34;average&#34;; } class AfricanSwallow { get plumage() { return (this.numberOfCoconuts &#62; 2) ? &#34;tired&#34; : &#34;average&#34;; } class NorwegianBlueParrot { get plumage() { return (this.voltage &#62; 100) ? &#34;scorched&#34; : &#34;beautiful&#34;; }</p>
</aside>
</figure>
<h4 class="h4" id="ch10lev2sec12">Motivation</h4>
<p class="noindent">Complex conditional logic is one of the hardest things to reason about in programming, so I always look for ways to add structure to conditional logic. Often, I find I can separate the logic into different circumstances&#8212;high-level cases&#8212;to <span epub:type="pagebreak" id="page_273"/>divide the conditions. Sometimes it&#8217;s enough to represent this division within the structure of a conditional itself, but using classes and polymorphism can make the separation more explicit.</p>
<p class="indent">A common case for this is where I can form a set of types, each handling the conditional logic differently. I might notice that books, music, and food vary in how they are handled because of their type. This is made most obvious when there are several functions that have a switch statement on a type code. In that case, I remove the duplication of the common switch logic by creating classes for each case and using polymorphism to bring out the type-specific behavior.</p>
<p class="indent">Another situation is where I can think of the logic as a base case with variants. The base case may be the most common or most straightforward. I can put this logic into a superclass which allows me to reason about it without having to worry about the variants. I then put each variant case into a subclass, which I express with code that emphasizes its difference from the base case.</p>
<p class="indent">Polymorphism is one of the key features of object-oriented programming&#8212;and, like any useful feature, it&#8217;s prone to overuse. I&#8217;ve come across people who argue that all examples of conditional logic should be replaced with polymorphism. I don&#8217;t agree with that view. Most of my conditional logic uses basic conditional statements&#8212;if/else and switch/case. But when I see complex conditional logic that can be improved as discussed above, I find polymorphism a powerful tool.</p>
<h4 class="h4" id="ch10lev2sec13">Mechanics</h4>
<ul class="square">
<li><p>If classes do not exist for polymorphic behavior, create them together with a factory function to return the correct instance.</p></li>
<li><p>Use the factory function in calling code.</p></li>
<li><p>Move the conditional function to the superclass.</p>
<div class="blockquote">
<p class="noindent">If the conditional logic is not a self-contained function, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> to make it so.</p>
</div></li>
<li><p>Pick one of the subclasses. Create a subclass method that overrides the conditional statement method. Copy the body of that leg of the conditional statement into the subclass method and adjust it to fit.</p></li>
<li><p>Repeat for each leg of the conditional.</p></li>
<li><p>Leave a default case for the superclass method. Or, if superclass should be abstract, declare that method as abstract or throw an error to show it should be the responsibility of a subclass.</p></li>
</ul>
<h4 class="h4" id="ch10lev2sec14"><span epub:type="pagebreak" id="page_274"/>Example</h4>
<p class="noindent">My friend has a collection of birds and wants to know how fast they can fly and what they have for plumage. So we have a couple of small programs to determine the information.</p>
<p class="codelink"><a id="p0274_01a" href="ch10_images.xhtml#p0274_01">Click here to view code image</a></p>
<pre class="pre"><strong><span class="pd_green">function plumages</span></strong>(birds) {
  return new Map(birds.map(b =&gt; [b.name, plumage(b)]));
}
<strong><span class="pd_green">function speeds</span></strong>(birds) {
  return new Map(birds.map(b =&gt; [b.name, airSpeedVelocity(b)]));
}

<strong><span class="pd_green">function plumage</span></strong>(bird) {
  switch (bird.type) {
  case 'EuropeanSwallow':
    return "average";
  case 'AfricanSwallow':
    return (bird.numberOfCoconuts &gt; 2) ? "tired" : "average";
  case 'NorwegianBlueParrot':
    return (bird.voltage &gt; 100) ? "scorched" : "beautiful";
  default:
    return "unknown";
  }
}

<strong><span class="pd_green">function airSpeedVelocity</span></strong>(bird) {
  switch (bird.type) {
  case 'EuropeanSwallow':
    return 35;
  case 'AfricanSwallow':
    return 40 - 2 * bird.numberOfCoconuts;
  case 'NorwegianBlueParrot':
    return (bird.isNailed) ? 0 : 10 + bird.voltage / 10;
  default:
    return null;
  }
}</pre>
<p class="indent">We have a couple of different operations that vary with the type of bird, so it makes sense to create classes and use polymorphism for any type-specific behavior.</p>
<p class="indent">I begin by using <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec9">Combine Functions into Class</a> (<a class="pd_maroon" href="ch06.xhtml#page_144">144</a>)</span></em> on <code>airSpeedVelocity</code> and <code>plumage</code>.</p>
<p class="codelink"><a id="p0274_02a" href="ch10_images.xhtml#p0274_02">Click here to view code image</a></p>
<pre class="pre">function plumage(bird) {
  return <span class="pd_maroon1">new Bird(bird).plumage;</span>
}

function airSpeedVelocity(bird) {
  return <span class="pd_maroon1">new Bird(bird).airSpeedVelocity;</span>
}

<span epub:type="pagebreak" id="page_275"/><span class="pd_maroon1">class Bird</span> {
  constructor(birdObject) {
    Object.assign(this, birdObject);
  }
  <span class="pd_maroon1">get plumage</span>() {
    switch (this.type) {
    case 'EuropeanSwallow':
      return "average";
    case 'AfricanSwallow':
      return (this.numberOfCoconuts &gt; 2) ? "tired" : "average";
    case 'NorwegianBlueParrot':
      return (this.voltage &gt; 100) ? "scorched" : "beautiful";
    default:
      return "unknown";
    }
  }
  <span class="pd_maroon1">get airSpeedVelocity</span>() {
    switch (this.type) {
    case 'EuropeanSwallow':
      return 35;
    case 'AfricanSwallow':
      return 40 - 2 * this.numberOfCoconuts;
    case 'NorwegianBlueParrot':
      return (this.isNailed) ? 0 : 10 + this.voltage / 10;
    default:
      return null;
    }
  }
}</pre>
<p class="indent">I now add subclasses for each kind of bird, together with a factory function to instantiate the appropriate subclass.</p>
<p class="codelink"><a id="p0275_01a" href="ch10_images.xhtml#p0275_01">Click here to view code image</a></p>
<pre class="pre">function plumage(bird) {
  return <span class="pd_maroon1">createBird</span>(bird).plumage;
}

function airSpeedVelocity(bird) {
  return <span class="pd_maroon1">createBird</span>(bird).airSpeedVelocity;
}

  <span class="pd_maroon1">function createBird(bird) {</span>
    <span class="pd_maroon1">switch (bird.type) {</span>
    <span class="pd_maroon1">case 'EuropeanSwallow':</span>
      <span class="pd_maroon1">return new EuropeanSwallow(bird);</span>
    <span class="pd_maroon1">case 'AfricanSwallow':</span>
      <span class="pd_maroon1">return new AfricanSwallow(bird);</span>
    <span class="pd_maroon1">case 'NorweigianBlueParrot':</span>
      <span class="pd_maroon1">return new NorwegianBlueParrot(bird);</span>
    <span class="pd_maroon1">default:</span>
      <span class="pd_maroon1">return new Bird(bird);</span>
    <span class="pd_maroon1">}</span>
  }

  <span epub:type="pagebreak" id="page_276"/><span class="pd_maroon1">class EuropeanSwallow extends Bird {</span>
  <span class="pd_maroon1">}</span>

  <span class="pd_maroon1">class AfricanSwallow extends Bird {</span>
  <span class="pd_maroon1">}</span>

  <span class="pd_maroon1">class NorwegianBlueParrot extends Bird {</span>
  <span class="pd_maroon1">}</span></pre>
<p class="indent">Now that I&#8217;ve created the class structure that I need, I can begin on the two conditional methods. I&#8217;ll begin with plumage. I take one leg of the switch statement and override it in the appropriate subclass.</p>
<p class="pro-title"><em>class EuropeanSwallow&#8230;</em></p>
<pre class="pre"><span class="pd_maroon1">get plumage() {</span>
  <span class="pd_maroon1">return "average";</span>
<span class="pd_maroon1">}</span></pre>
<p class="pro-title"><em>class Bird&#8230;</em></p>
<p class="codelink"><a id="p0276_01a" href="ch10_images.xhtml#p0276_01">Click here to view code image</a></p>
<pre class="pre">get plumage() {
  switch (this.type) {
  case 'EuropeanSwallow':
    <span class="pd_maroon1">throw "oops";</span>
  case 'AfricanSwallow':
    return (this.numberOfCoconuts &gt; 2) ? "tired" : "average";
  case 'NorwegianBlueParrot':
    return (this.voltage &gt; 100) ? "scorched" : "beautiful";
  default:
    return "unknown";
  }
}</pre>
<div class="blockquote">
<p class="noindent"><span class="pd_brown"><em>I put in the</em> <code>throw</code> <em>because I&#8217;m paranoid.</em></span></p>
</div>
<p class="indent">I can compile and test at this point. Then, if all is well, I do the next leg.</p>
<p class="pro-title"><em>class AfricanSwallow&#8230;</em></p>
<p class="codelink"><a id="p0276_02a" href="ch10_images.xhtml#p0276_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get plumage() {</span>
  <span class="pd_maroon1">return (this.numberOfCoconuts &gt; 2) ? "tired" : "average";</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">Then, the Norwegian Blue:</p>
<p class="pro-title"><em>class NorwegianBlueParrot&#8230;</em></p>
<p class="codelink"><a id="p0276_03a" href="ch10_images.xhtml#p0276_03">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get plumage() {</span>
  <span class="pd_maroon1">return (this.voltage &gt; 100) ? "scorched" : "beautiful";</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">I leave the superclass method for the default case.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_277"/><em>class Bird&#8230;</em></p>
<pre class="pre">get plumage() {
  <span class="pd_maroon1">return "unknown";</span>
}</pre>
<p class="indent">I repeat the same process for <code>airSpeedVelocity</code>. Once I&#8217;m done, I end up with the following code (I also inlined the top-level functions for <code>airSpeedVelocity</code> and <code>plumage</code>):</p>
<p class="codelink"><a id="p0277_01a" href="ch10_images.xhtml#p0277_01">Click here to view code image</a></p>
<pre class="pre"><strong><span class="pd_green">function plumages</span></strong>(birds) {
  return new Map(birds
                 .map(b =&gt; createBird(b))
                 .map(bird =&gt; [bird.name, bird.plumage]));
}
<strong><span class="pd_green">function speeds</span></strong>(birds) {
  return new Map(birds
                 .map(b =&gt; createBird(b))
                 .map(bird =&gt; [bird.name, bird.airSpeedVelocity]));
}

<strong><span class="pd_green">function createBird</span></strong>(bird) {
  switch (bird.type) {
  case 'EuropeanSwallow':
    return new EuropeanSwallow(bird);
  case 'AfricanSwallow':
    return new AfricanSwallow(bird);
  case 'NorwegianBlueParrot':
    return new NorwegianBlueParrot(bird);
  default:
    return new Bird(bird);
  }
}

<strong><span class="pd_green">class Bird</span></strong> {
  constructor(birdObject) {
    Object.assign(this, birdObject);
  }
  <strong><span class="pd_green">get plumage</span></strong>() {
    return "unknown";
  }
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {
    return null;
  }
}
<strong><span class="pd_green">class EuropeanSwallow</span></strong> extends Bird {
  <strong><span class="pd_green">get plumage</span></strong>() {
    return "average";
  }
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {
    return 35;
  }
}
<span epub:type="pagebreak" id="page_278"/><strong><span class="pd_green">class AfricanSwallow</span></strong> extends Bird {
  <strong><span class="pd_green">get plumage</span></strong>() {
    return (this.numberOfCoconuts &gt; 2) ? "tired" : "average";
  }
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {
    return 40 - 2 * this.numberOfCoconuts;
  }
}
<strong><span class="pd_green">class NorwegianBlueParrot</span></strong> extends Bird {
  <strong><span class="pd_green">get plumage</span></strong>() {
    return (this.voltage &gt; 100) ? "scorched" : "beautiful";
  }
  <strong><span class="pd_green">get airSpeedVelocity</span></strong>() {
    return (this.isNailed) ? 0 : 10 + this.voltage / 10;
  }
}</pre>
<p class="indent">Looking at this final code, I can see that the superclass <code>Bird</code> isn&#8217;t strictly needed. In JavaScript, I don&#8217;t need a type hierarchy for polymorphism; as long as my objects implement the appropriately named methods, everything works fine. In this situation, however, I like to keep the unnecessary superclass as it helps explain the way the classes are related in the domain.</p>
<h4 class="h4" id="ch10lev2sec15">Example: Using Polymorphism for Variation</h4>
<p class="noindent">With the birds example, I&#8217;m using a clear generalization hierarchy. That&#8217;s how subclassing and polymorphism is often discussed in textbooks (including mine)&#8212;but it&#8217;s not the only way inheritance is used in practice; indeed, it probably isn&#8217;t the most common or best way. Another case for inheritance is when I wish to indicate that one object is mostly similar to another, but with some variations.</p>
<p class="indent">As an example of this case, consider some code used by a rating agency to compute an investment rating for the voyages of sailing ships. The rating agency gives out either an &#8220;A&#8221; or &#8220;B&#8221; rating, depending of various factors due to risk and profit potential. The risk comes from assessing the nature of the voyage as well as the history of the captain&#8217;s prior voyages.</p>
<p class="codelink"><a id="p0278_01a" href="ch10_images.xhtml#p0278_01">Click here to view code image</a></p>
<pre class="pre"><strong><span class="pd_green">function rating</span></strong>(voyage, history) {
  const vpf = voyageProfitFactor(voyage, history);
  const vr = voyageRisk(voyage);
  const chr = captainHistoryRisk(voyage, history);
  if (vpf * 3 &gt; (vr + chr * 2)) return "A";
  else return "B";
}
<span epub:type="pagebreak" id="page_279"/><strong><span class="pd_green">function voyageRisk</span></strong>(voyage) {
  let result = 1;
  if (voyage.length &gt; 4) result += 2;
  if (voyage.length &gt; 8) result += voyage.length - 8;
  if (["china", "east-indies"].includes(voyage.zone)) result += 4;
  return Math.max(result, 0);
}
<strong><span class="pd_green">function captainHistoryRisk</span></strong>(voyage, history) {
  let result = 1;
  if (history.length &lt; 5) result += 4;
  result += history.filter(v =&gt; v.profit &lt; 0).length;
  if (voyage.zone === "china" &amp;&amp; hasChina(history)) result -= 2;
  return Math.max(result, 0);
}
<strong><span class="pd_green">function hasChina</span></strong>(history) {
  return history.some(v =&gt; "china" === v.zone);
}
<strong><span class="pd_green">function voyageProfitFactor</span></strong>(voyage, history) {
  let result = 2;
  if (voyage.zone === "china") result += 1;
  if (voyage.zone === "east-indies") result += 1;
  if (voyage.zone === "china" &amp;&amp; hasChina(history)) {
    result += 3;
    if (history.length &gt; 10) result += 1;
    if (voyage.length &gt; 12) result += 1;
    if (voyage.length &gt; 18) result -= 1;
  }
  else {
    if (history.length &gt; 8) result += 1;
    if (voyage.length &gt; 14) result -= 1;
  }
  return result;
}</pre>
<p class="indent">The functions <code>voyageRisk</code> and <code>captainHistoryRisk</code> score points for risk, <code>voyageProfitFactor</code> scores points for the potential profit, and <code>rating</code> combines these to give the overall rating for the voyage.</p>
<p class="indent">The calling code would look something like this:</p>
<p class="codelink"><a id="p0279_01a" href="ch10_images.xhtml#p0279_01">Click here to view code image</a></p>
<pre class="pre">const voyage = {zone: "west-indies", length: 10};
const history = [
  {zone: "east-indies", profit:  5},
  {zone: "west-indies", profit: 15},
  {zone: "china",       profit: -2},
  {zone: "west-africa", profit:  7},
];

const myRating = rating(voyage, history);</pre>
<p class="indent"><span epub:type="pagebreak" id="page_280"/>What I want to focus on here is how a couple of places use conditional logic to handle the case of a voyage to China where the captain has been to China before.</p>
<p class="codelink"><a id="p0280_01a" href="ch10_images.xhtml#p0280_01">Click here to view code image</a></p>
<pre class="pre">function rating(voyage, history) {
  const vpf = voyageProfitFactor(voyage, history);
  const vr = voyageRisk(voyage);
  const chr = captainHistoryRisk(voyage, history);
  if (vpf * 3 &gt; (vr + chr * 2)) return "A";
  else return "B";
}
  function voyageRisk(voyage) {
  let result = 1;
  if (voyage.length &gt; 4) result += 2;
  if (voyage.length &gt; 8) result += voyage.length - 8;
  if (["china", "east-indies"].includes(voyage.zone)) result += 4;
  return Math.max(result, 0);
}
function captainHistoryRisk(voyage, history) {
  let result = 1;
  if (history.length &lt; 5) result += 4;
  result += history.filter(v =&gt; v.profit &lt; 0).length;
  <span class="pd_maroon1">if (voyage.zone === "china" &amp;&amp; hasChina(history))</span> result -= 2;
  return Math.max(result, 0);
}
function hasChina(history) {
  return history.some(v =&gt; "china" === v.zone);
}
function voyageProfitFactor(voyage, history) {
  let result = 2;
  if (voyage.zone === "china") result += 1;
  if (voyage.zone === "east-indies") result += 1;
  <span class="pd_maroon1">if (voyage.zone === "china" &amp;&amp; hasChina(history))</span> {
    result += 3;
    if (history.length &gt; 10) result += 1;
    if (voyage.length &gt; 12) result += 1;
    if (voyage.length &gt; 18) result -= 1;
  }
  else {
    if (history.length &gt; 8) result += 1;
    if (voyage.length &gt; 14) result -= 1;
  }
  return result;
}</pre>
<p class="indent">I will use inheritance and polymorphism to separate out the logic for handling these cases from the base logic. This is a particularly useful refactoring if I&#8217;m about to introduce more special logic for this case&#8212;and the logic for these repeat China voyages can make it harder to understand the base case.</p>
<p class="indent"><span epub:type="pagebreak" id="page_281"/>I&#8217;m beginning with a set of functions. To introduce polymorphism, I need to create a class structure, so I begin by applying <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec9">Combine Functions into Class</a> (<a class="pd_maroon" href="ch06.xhtml#page_144">144</a>)</span></em>. This results in the following code:</p>
<p class="codelink"><a id="p0281_01a" href="ch10_images.xhtml#p0281_01">Click here to view code image</a></p>
<pre class="pre"><strong><span class="pd_green">function rating</span></strong>(voyage, history) {
  return new Rating(voyage, history).value;
}

<strong><span class="pd_green">class Rating</span></strong> {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }
  <strong><span class="pd_green">get value</span></strong>() {
    const vpf = this.voyageProfitFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 &gt; (vr + chr * 2)) return "A";
    else return "B";
  }
  <strong><span class="pd_green">get voyageRisk</span></strong>() {
    let result = 1;
    if (this.voyage.length &gt; 4) result += 2;
    if (this.voyage.length &gt; 8) result += this.voyage.length - 8;
    if (["china", "east-indies"].includes(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }
  <strong><span class="pd_green">get captainHistoryRisk</span></strong>() {
    let result = 1;
    if (this.history.length &lt; 5) result += 4;
    result += this.history.filter(v =&gt; v.profit &lt; 0).length;
    if (this.voyage.zone === "china" &amp;&amp; this.hasChinaHistory) result -= 2;
    return Math.max(result, 0);
  }
  <strong><span class="pd_green">get voyageProfitFactor</span></strong>() {
    let result = 2;

    if (this.voyage.zone === "china") result += 1;
    if (this.voyage.zone === "east-indies") result += 1;
    if (this.voyage.zone === "china" &amp;&amp; this.hasChinaHistory) {
      result += 3;
      if (this.history.length &gt; 10) result += 1;
      if (this.voyage.length &gt; 12) result += 1;
      if (this.voyage.length &gt; 18) result -= 1;
    }
    else {
      if (this.history.length &gt; 8) result += 1;
      if (this.voyage.length &gt; 14) result -= 1;
    }
    return result;
  }
  <span epub:type="pagebreak" id="page_282"/><strong><span class="pd_green">get hasChinaHistory</span></strong>() {
    return this.history.some(v =&gt; "china" === v.zone);
  }
}</pre>
<p class="indent">That&#8217;s given me the class for the base case. I now need to create an empty subclass to house the variant behavior.</p>
<p class="codelink"><a id="p0282_01a" href="ch10_images.xhtml#p0282_01">Click here to view code image</a></p>
<pre class="pre">class ExperiencedChinaRating extends Rating {
}</pre>
<p class="indent">I then create a factory function to return the variant class when needed.</p>
<p class="codelink"><a id="p0282_02a" href="ch10_images.xhtml#p0282_02">Click here to view code image</a></p>
<pre class="pre">function createRating(voyage, history) {
  if (voyage.zone === "china" &amp;&amp; history.some(v =&gt; "china" === v.zone))
    return new ExperiencedChinaRating(voyage, history);
  else return new Rating(voyage, history);
}</pre>
<p class="indent">I need to modify any callers to use the factory function instead of directly invoking the constructor, which in this case is just the rating function.</p>
<p class="codelink"><a id="p0282_03a" href="ch10_images.xhtml#p0282_03">Click here to view code image</a></p>
<pre class="pre">function rating(voyage, history) {
  return <span class="pd_maroon1">createRating</span>(voyage, history).value;
}</pre>
<p class="indent">There are two bits of behavior I need to move into a subclass. I begin with the logic in <code>captainHistoryRisk</code>:</p>
<p class="pro-title"><em>class Rating&#8230;</em></p>
<p class="codelink"><a id="p0282_04a" href="ch10_images.xhtml#p0282_04">Click here to view code image</a></p>
<pre class="pre">get captainHistoryRisk() {
  let result = 1;
  if (this.history.length &lt; 5) result += 4;
  result += this.history.filter(v =&gt; v.profit &lt; 0).length;
  <span class="pd_blue">if (this.voyage.zone === "china" &amp;&amp; this.hasChinaHistory) result -= 2;</span>
  return Math.max(result, 0);
}</pre>
<p class="indent">I write the overriding method in the subclass:</p>
<p class="pro-title"><em>class ExperiencedChinaRating</em></p>
<p class="codelink"><a id="p0282_05a" href="ch10_images.xhtml#p0282_05">Click here to view code image</a></p>
<pre class="pre">get captainHistoryRisk() {
  const result = super.captainHistoryRisk - 2;
  return Math.max(result, 0);
}</pre>
<p class="pro-title"><span epub:type="pagebreak" id="page_283"/><em>class Rating&#8230;</em></p>
<p class="codelink"><a id="p0283_01a" href="ch10_images.xhtml#p0283_01">Click here to view code image</a></p>
<pre class="pre">get captainHistoryRisk() {
  let result = 1;
  if (this.history.length &lt; 5) result += 4;
  result += this.history.filter(v =&gt; v.profit &lt; 0).length;
  <span class="strike"><span class="pd_maroon1">if (this.voyage.zone === "china" &amp;&amp; this.hasChinaHistory) result -= 2;</span></span>
  return Math.max(result, 0);
}</pre>
<p class="indent">Separating the variant behavior from <code>voyageProfitFactor</code> is a bit more messy. I can&#8217;t simply remove the variant behavior and call the superclass method since there is an alternative path here. I also don&#8217;t want to copy the whole superclass method down to the subclass.</p>
<p class="pro-title"><em>class Rating&#8230;</em></p>
<p class="codelink"><a id="p0283_02a" href="ch10_images.xhtml#p0283_02">Click here to view code image</a></p>
<pre class="pre">get voyageProfitFactor() {
  let result = 2;

  if (this.voyage.zone === "china") result += 1;
  if (this.voyage.zone === "east-indies") result += 1;
  <span class="pd_blue">if (this.voyage.zone === "china" &amp;&amp; this.hasChinaHistory) {</span>
    <span class="pd_blue">result += 3;</span>
    <span class="pd_blue">if (this.history.length &gt; 10) result += 1;</span>
    <span class="pd_blue">if (this.voyage.length &gt; 12) result += 1;</span>
    <span class="pd_blue">if (this.voyage.length &gt; 18) result -= 1;</span>
  <span class="pd_blue">}</span>
  else {
    if (this.history.length &gt; 8) result += 1;
    if (this.voyage.length &gt; 14) result -= 1;
  }
  return result;
}</pre>
<p class="indent">So my response is to first use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the entire conditional block.</p>
<p class="pro-title"><em>class Rating&#8230;</em></p>
<p class="codelink"><a id="p0283_03a" href="ch10_images.xhtml#p0283_03">Click here to view code image</a></p>
<pre class="pre">get voyageProfitFactor() {
  let result = 2;

  if (this.voyage.zone === "china") result += 1;
  if (this.voyage.zone === "east-indies") result += 1;
  result += <span class="pd_maroon1">this.voyageAndHistoryLengthFactor;</span>
  return result;
}

<span epub:type="pagebreak" id="page_284"/><span class="pd_maroon1">get voyageAndHistoryLengthFactor() {</span>
  <span class="pd_maroon1">let result = 0;</span>
  <span class="pd_maroon1">if (this.voyage.zone === "china" &amp;&amp; this.hasChinaHistory) {</span>
    <span class="pd_maroon1">result += 3;</span>
    <span class="pd_maroon1">if (this.history.length &gt; 10) result += 1;</span>
    <span class="pd_maroon1">if (this.voyage.length &gt; 12) result += 1;</span>
    <span class="pd_maroon1">if (this.voyage.length &gt; 18) result -= 1;</span>
  <span class="pd_maroon1">}</span>
  <span class="pd_maroon1">else {</span>
    <span class="pd_maroon1">if (this.history.length &gt; 8) result += 1;</span>
    <span class="pd_maroon1">if (this.voyage.length &gt; 14) result -= 1;</span>
  <span class="pd_maroon1">}</span>
  <span class="pd_maroon1">return result;</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">A function name with an &#8220;And&#8221; in it is a pretty bad smell, but I&#8217;ll let it sit and reek for a moment, while I apply the subclassing.</p>
<p class="pro-title"><em>class Rating&#8230;</em></p>
<p class="codelink"><a id="p0284_01a" href="ch10_images.xhtml#p0284_01">Click here to view code image</a></p>
<pre class="pre">get voyageAndHistoryLengthFactor() {
  let result = 0;
  if (this.history.length &gt; 8) result += 1;
  if (this.voyage.length &gt; 14) result -= 1;
  return result;
}</pre>
<p class="pro-title"><em>class ExperiencedChinaRating&#8230;</em></p>
<p class="codelink"><a id="p0284_02a" href="ch10_images.xhtml#p0284_02">Click here to view code image</a></p>
<pre class="pre">get voyageAndHistoryLengthFactor() {
  let result = 0;
  result += 3;
  if (this.history.length &gt; 10) result += 1;
  if (this.voyage.length &gt; 12) result += 1;
  if (this.voyage.length &gt; 18) result -= 1;
  return result;
}</pre>
<p class="indent">That&#8217;s, formally, the end of the refactoring&#8212;I&#8217;ve separated the variant behavior out into the subclass. The superclass&#8217;s logic is simpler to understand and work with, and I only need to deal with variant case when I&#8217;m working on the subclass code, which is expressed in terms of its difference with the superclass.</p>
<p class="indent">But I feel I should at least outline what I&#8217;d do with the awkward new method. Introducing a method purely for overriding by a subclass is a common thing to do when doing this kind of base-and-variation inheritance. But a crude method like this obscures what&#8217;s going on, instead of revealing.</p>
<p class="indent">The &#8220;And&#8221; gives away that there are really two separate modifications going on here&#8212;so I think it&#8217;s wise to separate them. I&#8217;ll do this by using <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> <span epub:type="pagebreak" id="page_285"/>on the history length modification, both in the superclass and subclass. I start with just the superclass:</p>
<p class="pro-title"><em>class Rating&#8230;</em></p>
<p class="codelink"><a id="p0285_01a" href="ch10_images.xhtml#p0285_01">Click here to view code image</a></p>
<pre class="pre">get voyageAndHistoryLengthFactor() {
  let result = 0;
  result += <span class="pd_maroon1">this.historyLengthFactor;</span>
  if (this.voyage.length &gt; 14) result -= 1;
  return result;
}
<span class="pd_maroon1">get historyLengthFactor() {</span>
  <span class="pd_maroon1">return (this.history.length &gt; 8) ? 1 : 0;</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">I do the same with the subclass:</p>
<p class="pro-title"><em>class ExperiencedChinaRating&#8230;</em></p>
<p class="codelink"><a id="p0285_02a" href="ch10_images.xhtml#p0285_02">Click here to view code image</a></p>
<pre class="pre">get voyageAndHistoryLengthFactor() {
  let result = 0;
  result += 3;
  result += <span class="pd_maroon1">this.historyLengthFactor;</span>
  if (this.voyage.length &gt; 12) result += 1;
  if (this.voyage.length &gt; 18) result -= 1;
  return result;
}
<span class="pd_maroon1">get historyLengthFactor() {</span>
  <span class="pd_maroon1">return (this.history.length &gt; 10) ? 1 : 0;</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">I can then use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec4">Move Statements to Callers</a> (<a class="pd_maroon" href="ch08.xhtml#page_217">217</a>)</span></em> on the superclass case.</p>
<p class="pro-title"><em>class Rating&#8230;</em></p>
<p class="codelink"><a id="p0285_03a" href="ch10_images.xhtml#p0285_03">Click here to view code image</a></p>
<pre class="pre">get voyageProfitFactor() {
  let result = 2;
  if (this.voyage.zone === "china") result += 1;
  if (this.voyage.zone === "east-indies") result += 1;
  result += this.historyLengthFactor;
  result += this.voyageAndHistoryLengthFactor;
  return result;
}
get voyageAndHistoryLengthFactor() {
  let result = 0;
  <span class="strike"><span class="pd_maroon1">result += this.historyLengthFactor;</span></span>
  if (this.voyage.length &gt; 14) result -= 1;
  return result;
}</pre>
<p class="pro-title"><span epub:type="pagebreak" id="page_286"/><em>class ExperiencedChinaRating&#8230;</em></p>
<p class="codelink"><a id="p0286_01a" href="ch10_images.xhtml#p0286_01">Click here to view code image</a></p>
<pre class="pre">get voyageAndHistoryLengthFactor() {
  let result = 0;
  result += 3;
  <span class="strike"><span class="pd_maroon1">result += this.historyLengthFactor;</span></span>
  if (this.voyage.length &gt; 12) result += 1;
  if (this.voyage.length &gt; 18) result -= 1;
  return result;
}</pre>
<p class="indent">I&#8217;d then use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Rename Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em>.</p>
<p class="pro-title"><em>class Rating&#8230;</em></p>
<p class="codelink"><a id="p0286_02a" href="ch10_images.xhtml#p0286_02">Click here to view code image</a></p>
<pre class="pre">get voyageProfitFactor() {
  let result = 2;
  if (this.voyage.zone === "china") result += 1;
  if (this.voyage.zone === "east-indies") result += 1;
  result += this.historyLengthFactor;
  result += this.<span class="pd_maroon1">voyageLengthFactor</span>;
  return result;
}

get <span class="pd_maroon1">voyageLengthFactor</span>() {
  return (this.voyage.length &gt; 14) ? - 1: 0;
}</pre>
<div class="blockquote">
<p class="noindent"><span class="pd_brown"><em>Changing to a ternary to simplify</em> <code>voyageLengthFactor</code>.</span></p>
</div>
<p class="pro-title"><em>class ExperiencedChinaRating&#8230;</em></p>
<p class="codelink"><a id="p0286_03a" href="ch10_images.xhtml#p0286_03">Click here to view code image</a></p>
<pre class="pre">get <span class="pd_maroon1">voyageLengthFactor</span>() {
  let result = 0;
  result += 3;
  if (this.voyage.length &gt; 12) result += 1;
  if (this.voyage.length &gt; 18) result -= 1;
  return result;
}</pre>
<p class="indent">One last thing. I don&#8217;t think adding 3 points makes sense as part of the voyage length factor&#8212;it&#8217;s better added to the overall result.</p>
<p class="pro-title"><em>class ExperiencedChinaRating&#8230;</em></p>
<p class="codelink"><a id="p0286_04a" href="ch10_images.xhtml#p0286_04">Click here to view code image</a></p>
<pre class="pre">  <span class="pd_maroon1">get voyageProfitFactor() {</span>
    <span class="pd_maroon1">return super.voyageProfitFactor + 3;</span>
  <span class="pd_maroon1">}</span>

get voyageLengthFactor() {
  let result = 0;
  <span class="strike"><span class="pd_maroon1">result += 3;</span></span>
  if (this.voyage.length &gt; 12) result += 1;
  if (this.voyage.length &gt; 18) result -= 1;
  return result;
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_287"/>At the end of the refactoring, I have the following code. First, there is the basic rating class which can ignore any complications of the experienced China case:</p>
<p class="codelink"><a id="p0287_01a" href="ch10_images.xhtml#p0287_01">Click here to view code image</a></p>
<pre class="pre"><strong><span class="pd_green">class Rating</span></strong> {
  constructor(voyage, history) {
    this.voyage = voyage;
    this.history = history;
  }
  <strong><span class="pd_green">get value</span></strong>() {
    const vpf = this.voyageProfitFactor;
    const vr = this.voyageRisk;
    const chr = this.captainHistoryRisk;
    if (vpf * 3 &gt; (vr + chr * 2)) return "A";
    else return "B";
  }
  <strong><span class="pd_green">get voyageRisk</span></strong>() {
    let result = 1;
    if (this.voyage.length &gt; 4) result += 2;
    if (this.voyage.length &gt; 8) result += this.voyage.length - 8;
    if (["china", "east-indies"].includes(this.voyage.zone)) result += 4;
    return Math.max(result, 0);
  }
  <strong><span class="pd_green">get captainHistoryRisk</span></strong>() {
    let result = 1;
    if (this.history.length &lt; 5) result += 4;
    result += this.history.filter(v =&gt; v.profit &lt; 0).length;
    return Math.max(result, 0);
  }
  <strong><span class="pd_green">get voyageProfitFactor</span></strong>() {
    let result = 2;
    if (this.voyage.zone === "china") result += 1;
    if (this.voyage.zone === "east-indies") result += 1;
    result += this.historyLengthFactor;
    result += this.voyageLengthFactor;
    return result;
  }
  <strong><span class="pd_green">get voyageLengthFactor</span></strong>() {
    return (this.voyage.length &gt; 14) ? - 1: 0;
  }
  <strong><span class="pd_green">get historyLengthFactor</span></strong>() {
    return (this.history.length &gt; 8) ? 1 : 0;
  }
}</pre>
<p class="indent">The code for the experienced China case reads as a set of variations on the base:</p>
<p class="codelink"><a id="p0288_01a" href="ch10_images.xhtml#p0288_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_288"/><strong><span class="pd_green">class ExperiencedChinaRating</span></strong> extends Rating {
  <strong><span class="pd_green">get captainHistoryRisk</span></strong>() {
    const result = super.captainHistoryRisk - 2;
    return Math.max(result, 0);
  }
  <strong><span class="pd_green">get voyageLengthFactor</span></strong>() {
    let result = 0;
    if (this.voyage.length &gt; 12) result += 1;
    if (this.voyage.length &gt; 18) result -= 1;
    return result;
  }
  <strong><span class="pd_green">get historyLengthFactor</span></strong>() {
    return (this.history.length &gt; 10) ? 1 : 0;
  }
  <strong><span class="pd_green">get voyageProfitFactor</span></strong>() {
    return super.voyageProfitFactor + 3;
  }
}</pre>
<h3 class="h3" id="ch10lev1sec5"><span epub:type="pagebreak" id="page_289"/>Introduce Special Case</h3>
<p class="noindent">formerly: <em>Introduce Null Object</em></p>
<figure class="fig-group">
<img src="graphics/p0289_01.jpg" aria-describedby="alt_p0289_01" alt="A figure illustrates how the refactoring technique is used in a special case."/>
<aside class="hidden" id="alt_p0289_01">
<p>The diagrammatic representation shows an object p, with a value that points to a method that includes a special object. The actual code reads, if (aCustomer === &#34;unknown&#34;) customerName = &#34;occupant&#34;; The code after refactoring reads, class UnknownCustomer { get name() {return &#34;occupant&#34;;}</p>
</aside>
</figure>
<h4 class="h4" id="ch10lev2sec16">Motivation</h4>
<p class="noindent">A common case of duplicated code is when many users of a data structure check a specific value, and then most of them do the same thing. If I find many parts of the code base having the same reaction to a particular value, I want to bring that reaction into a single place.</p>
<p class="indent">A good mechanism for this is the Special Case pattern where I create a special-case element that captures all the common behavior. This allows me to replace most of the special-case checks with simple calls.</p>
<p class="indent">A special case can manifest itself in several ways. If all I&#8217;m doing with the object is reading data, I can supply a literal object with all the values I need filled in. If I need more behavior than simple values, I can create a special object with methods for all the common behavior. The special-case object can be returned by an encapsulating class, or inserted into a data structure with a transform.</p>
<p class="indent">A common value that needs special-case processing is null, which is why this pattern is often called the Null Object pattern. But it&#8217;s the same approach for any special case&#8212;I like to say that Null Object is a special case of Special Case.</p>
<h4 class="h4" id="ch10lev2sec17">Mechanics</h4>
<p class="noindent">Begin with a container data structure (or class) that contains a property which is the subject of the refactoring. Clients of the container compare the <code>subject</code> <span epub:type="pagebreak" id="page_290"/>property of the container to a special-case value. We wish to replace the special-case value of the subject with a special case class or data structure.</p>
<ul class="square">
<li><p>Add a special-case check property to the subject, returning false.</p></li>
<li><p>Create a special-case object with only the special-case check property, returning true.</p></li>
<li><p>Apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> to the special-case comparison code. Ensure that all clients use the new function instead of directly comparing it.</p></li>
<li><p>Introduce the new special-case subject into the code, either by returning it from a function call or by applying a transform function.</p></li>
<li><p>Change the body of the special-case comparison function so that it uses the special-case check property.</p></li>
<li><p>Test.</p></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec9">Combine Functions into Class</a> (<a class="pd_maroon" href="ch06.xhtml#page_144">144</a>)</span></em> or <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec10">Combine Functions into Transform</a> (<a class="pd_maroon" href="ch06.xhtml#page_149">149</a>)</span></em> to move all of the common special-case behavior into the new element.</p>
<div class="blockquote">
<p class="noindent">Since the special-case class usually returns fixed values to simple requests, these may be handled by making the special case a literal record.</p>
</div></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> on the special-case comparison function for the places where it&#8217;s still needed.</p></li>
</ul>
<h4 class="h4" id="ch10lev2sec18">Example</h4>
<p class="noindent">A utility company installs its services in sites.</p>
<p class="pro-title"><em>class Site&#8230;</em></p>
<p class="codelink"><a id="p0290_01a" href="ch10_images.xhtml#p0290_01">Click here to view code image</a></p>
<pre class="pre">get customer() {return this._customer;}</pre>
<p class="indent">There are various properties of the customer class; I&#8217;ll consider three of them.</p>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<pre class="pre">get name()           {...}
get billingPlan()    {...}
set billingPlan(arg) {...}
get paymentHistory() {...}</pre>
<p class="indent">Most of the time, a site has a customer, but sometimes there isn&#8217;t one. Someone may have moved out and I don&#8217;t yet know who, if anyone, has moved in. When this happens, the data record fills the customer field with the string &#8220;unknown&#8221;. Because this can happen, clients of the site need to be able to handle an unknown customer. Here are some example fragments:</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_291"/><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0291_01a" href="ch10_images.xhtml#p0291_01">Click here to view code image</a></p>
<pre class="pre">const aCustomer = site.customer;
// ... lots of intervening code ...
let customerName;
if (aCustomer === "unknown") customerName = "occupant";
else customerName = aCustomer.name;</pre>
<p class="pro-title"><em>client 2&#8230;</em></p>
<p class="codelink"><a id="p0291_02a" href="ch10_images.xhtml#p0291_02">Click here to view code image</a></p>
<pre class="pre">const plan = (aCustomer === "unknown") ?
      registry.billingPlans.basic
      : aCustomer.billingPlan;</pre>
<p class="pro-title"><em>client 3&#8230;</em></p>
<p class="codelink"><a id="p0291_03a" href="ch10_images.xhtml#p0291_03">Click here to view code image</a></p>
<pre class="pre">if (aCustomer !== "unknown") aCustomer.billingPlan = newPlan;</pre>
<p class="pro-title"><em>client 4&#8230;</em></p>
<p class="codelink"><a id="p0291_04a" href="ch10_images.xhtml#p0291_04">Click here to view code image</a></p>
<pre class="pre">const weeksDelinquent = (aCustomer === "unknown") ?
      0
      : aCustomer.paymentHistory.weeksDelinquentInLastYear;</pre>
<p class="indent">Looking through the code base, I see many clients of the site object that have to deal with an unknown customer. Most of them do the same thing when they get one: They use &#8220;occupant&#8221; as the name, give them a basic billing plan, and class them as zero-weeks delinquent. This widespread testing for a special case, plus a common response, is what tells me it&#8217;s time for a Special Case Object.</p>
<p class="indent">I begin by adding a method to the customer to indicate it is unknown.</p>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<pre class="pre">get isUnknown() {return false;}</pre>
<p class="indent">I then add an Unknown Customer class.</p>
<p class="codelink"><a id="p0291_05a" href="ch10_images.xhtml#p0291_05">Click here to view code image</a></p>
<pre class="pre">class UnknownCustomer {
  get isUnknown() {return true;}
}</pre>
<div class="blockquote">
<p class="noindent">Note that I don&#8217;t make <code>UnknownCustomer</code> a subclass of <code>Customer</code>. In other languages, particularly those statically typed, I would, but JavaScript&#8217;s rules for subclassing, as well as its dynamic typing, make it better to not do that here.</p>
</div>
<p class="indent">Now comes the tricky bit. I have to return this new special-case object whenever I expect <code>"unknown"</code> and change each test for an unknown value to use the new <code>isUnknown</code> method. In general, I always want to arrange things so I can make one small change at a time, then test. But if I change the customer class to return an unknown customer instead of &#8220;unknown&#8221;, I have to make every client testing for &#8220;unknown&#8221; to call <code>isUnknown</code>&#8212;and I have to do it all at once. I find that as appealing as eating liver (i.e., not at all).</p>
<p class="indent"><span epub:type="pagebreak" id="page_292"/>There is a common technique to use whenever I find myself in this bind. I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the code that I&#8217;d have to change in lots of places&#8212;in this case, the special-case comparison code.</p>
<p class="codelink"><a id="p0292_01a" href="ch10_images.xhtml#p0292_01">Click here to view code image</a></p>
<pre class="pre">function isUnknown(arg) {
  if (!((arg instanceof Customer) || (arg === "unknown")))
    throw new Error(`investigate bad value: &lt;${arg}&gt;`);
  return (arg === "unknown");
}</pre>
<div class="blockquote">
<p class="noindent">I&#8217;ve put a trap in here for an unexpected value. This can help me to spot any mistakes or odd behavior as I&#8217;m doing this refactoring.</p>
</div>
<p class="indent">I can now use this function whenever I&#8217;m testing for an unknown customer. I can change these calls one at a time, testing after each change.</p>
<p class="pro-title"><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0292_02a" href="ch10_images.xhtml#p0292_02">Click here to view code image</a></p>
<pre class="pre">let customerName;
if (<span class="pd_maroon1">isUnknown</span>(aCustomer)) customerName = "occupant";
else customerName = aCustomer.name;</pre>
<p class="indent">After a while, I have done them all.</p>
<p class="pro-title"><em>client 2&#8230;</em></p>
<p class="codelink"><a id="p0292_03a" href="ch10_images.xhtml#p0292_03">Click here to view code image</a></p>
<pre class="pre">const plan = (<span class="pd_maroon1">isUnknown</span>(aCustomer)) ?
      registry.billingPlans.basic
      : aCustomer.billingPlan;</pre>
<p class="pro-title"><em>client 3&#8230;</em></p>
<p class="codelink"><a id="p0292_04a" href="ch10_images.xhtml#p0292_04">Click here to view code image</a></p>
<pre class="pre">if (!<span class="pd_maroon1">isUnknown</span>(aCustomer)) aCustomer.billingPlan = newPlan;</pre>
<p class="pro-title"><em>client 4&#8230;</em></p>
<p class="codelink"><a id="p0292_05a" href="ch10_images.xhtml#p0292_05">Click here to view code image</a></p>
<pre class="pre">const weeksDelinquent = <span class="pd_maroon1">isUnknown</span>(aCustomer) ?
      0
      : aCustomer.paymentHistory.weeksDelinquentInLastYear;</pre>
<p class="indent">Once I&#8217;ve changed all the callers to use <code>isUnknown</code>, I can change the site class to return an unknown customer.</p>
<p class="pro-title"><em>class Site&#8230;</em></p>
<p class="codelink"><a id="p0292_06a" href="ch10_images.xhtml#p0292_06">Click here to view code image</a></p>
<pre class="pre">get customer() {
  <span class="pd_maroon1">return (this._customer === "unknown") ? new UnknownCustomer() : this._customer;</span>
}</pre>
<p class="indent">I can check that I&#8217;m no longer using the &#8220;unknown&#8221; string by changing <code>isUnknown</code> to use the unknown value.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_293"/><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0293_01a" href="ch10_images.xhtml#p0293_01">Click here to view code image</a></p>
<pre class="pre">function isUnknown(arg) {
  if (!(arg instanceof Customer || arg instanceof UnknownCustomer))
    throw new Error(`investigate bad value: &lt;${arg}&gt;`);
  return arg.isUnknown;
}</pre>
<p class="indent">I test to ensure that&#8217;s all working.</p>
<p class="indent">Now the fun begins. I can use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec9">Combine Functions into Class</a> (<a class="pd_maroon" href="ch06.xhtml#page_144">144</a>)</span></em> to take each client&#8217;s special-case check and see if I can replace it with a commonly expected value. At the moment, I have various clients using &#8220;occupant&#8221; for the name of an unknown customer, like this:</p>
<p class="pro-title"><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0293_02a" href="ch10_images.xhtml#p0293_02">Click here to view code image</a></p>
<pre class="pre">let customerName;
if (isUnknown(aCustomer)) customerName = "occupant";
else customerName = aCustomer.name;</pre>
<p class="indent">I add a suitable method to the unknown customer:</p>
<p class="pro-title"><em>class UnknownCustomer&#8230;</em></p>
<p class="codelink"><a id="p0293_03a" href="ch10_images.xhtml#p0293_03">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get name() {return "occupant";}</span></pre>
<p class="indent">Now I can make all that conditional code go away.</p>
<p class="pro-title"><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0293_04a" href="ch10_images.xhtml#p0293_04">Click here to view code image</a></p>
<pre class="pre">const customerName = <span class="pd_maroon1">aCustomer.name;</span></pre>
<p class="indent">Once I&#8217;ve tested that this works, I&#8217;ll probably be able to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec4">Inline Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_123">123</a>)</span></em> on that variable too.</p>
<p class="indent">Next is the billing plan property.</p>
<p class="pro-title"><em>client 2&#8230;</em></p>
<p class="codelink"><a id="p0293_05a" href="ch10_images.xhtml#p0293_05">Click here to view code image</a></p>
<pre class="pre">const plan = (isUnknown(aCustomer)) ?
      registry.billingPlans.basic
      : aCustomer.billingPlan;</pre>
<p class="pro-title"><em>client 3&#8230;</em></p>
<p class="codelink"><a id="p0293_06a" href="ch10_images.xhtml#p0293_06">Click here to view code image</a></p>
<pre class="pre">if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;</pre>
<p class="indent">For read behavior, I do the same thing I did with the name&#8212;take the common response and reply with it. With the write behavior, the current code doesn&#8217;t call the setter for an unknown customer&#8212;so for the special case, I let the setter be called, but it does nothing.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_294"/><em>class UnknownCustomer&#8230;</em></p>
<p class="codelink"><a id="p0294_01a" href="ch10_images.xhtml#p0294_01">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get billingPlan()    {return registry.billingPlans.basic;}</span>
<span class="pd_maroon1">set billingPlan(arg) { /* ignore */ }</span></pre>
<p class="pro-title"><em>client reader&#8230;</em></p>
<p class="codelink"><a id="p0294_02a" href="ch10_images.xhtml#p0294_02">Click here to view code image</a></p>
<pre class="pre">const plan = <span class="pd_maroon1">aCustomer.billingPlan;</span></pre>
<p class="pro-title"><em>client writer&#8230;</em></p>
<p class="codelink"><a id="p0294_03a" href="ch10_images.xhtml#p0294_03">Click here to view code image</a></p>
<pre class="pre">aCustomer.billingPlan = <span class="pd_maroon1">newPlan;</span></pre>
<p class="indent">Special-case objects are value objects, and thus should always be immutable, even if the objects they are substituting for are not.</p>
<p class="indent">The last case is a bit more involved because the special case needs to return another object that has its own properties.</p>
<p class="pro-title"><em>client&#8230;</em></p>
<p class="codelink"><a id="p0294_04a" href="ch10_images.xhtml#p0294_04">Click here to view code image</a></p>
<pre class="pre">const weeksDelinquent = isUnknown(aCustomer) ?
      0
      : aCustomer.paymentHistory.weeksDelinquentInLastYear;</pre>
<p class="indent">The general rule with a special-case object is that if it needs to return related objects, they are usually special cases themselves. So here I need to create a null payment history.</p>
<p class="pro-title"><em>class UnknownCustomer&#8230;</em></p>
<p class="codelink"><a id="p0294_05a" href="ch10_images.xhtml#p0294_05">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get paymentHistory() {return new NullPaymentHistory();}</span></pre>
<p class="pro-title"><em>class NullPaymentHistory&#8230;</em></p>
<p class="codelink"><a id="p0294_06a" href="ch10_images.xhtml#p0294_06">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">get weeksDelinquentInLastYear() {return 0;}</span></pre>
<p class="pro-title"><em>client&#8230;</em></p>
<p class="codelink"><a id="p0294_07a" href="ch10_images.xhtml#p0294_07">Click here to view code image</a></p>
<pre class="pre">const weeksDelinquent = <span class="pd_maroon1">aCustomer.paymentHistory.weeksDelinquentInLastYear;</span></pre>
<p class="indent">I carry on, looking at all the clients to see if I can replace them with the polymorphic behavior. But there will be exceptions&#8212;clients that want to do something different with the special case. I may have 23 clients that use &#8220;occupant&#8221; for the name of an unknown customer, but there&#8217;s always one that needs something different.</p>
<p class="pro-title"><em>client&#8230;</em></p>
<p class="codelink"><a id="p0294_08a" href="ch10_images.xhtml#p0294_08">Click here to view code image</a></p>
<pre class="pre">const name = ! isUnknown(aCustomer) ? aCustomer.name : "unknown occupant";</pre>
<p class="indent">In that case, I need to retain a special-case check. I will change it to use the method on customer, essentially using <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> on <code>isUnknown</code>.</p>
<p class="pro-title"><em>client&#8230;</em></p>
<p class="codelink"><a id="p0294_09a" href="ch10_images.xhtml#p0294_09">Click here to view code image</a></p>
<pre class="pre">const name = <span class="pd_maroon1">aCustomer.isUnknown ? "unknown occupant" : aCustomer.name;</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_295"/>When I&#8217;m done with all the clients, I should be able to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec9">Remove Dead Code</a> (<a class="pd_maroon" href="ch08.xhtml#page_237">237</a>)</span></em> on the global <code>isPresent</code> function, as nobody should be calling it any more.</p>
<h4 class="h4" id="ch10lev2sec19">Example: Using an Object Literal</h4>
<p class="noindent">Creating a class like this is a fair bit of work for what is really a simple value. But for the example I gave, I had to make the class since the customer could be updated. If, however, I only read the data structure, I can use a literal object instead.</p>
<p class="indent">Here is the opening case again&#8212;just the same, except this time there is no client that updates the customer:</p>
<p class="pro-title"><em>class Site&#8230;</em></p>
<p class="codelink"><a id="p0295_01a" href="ch10_images.xhtml#p0295_01">Click here to view code image</a></p>
<pre class="pre">get customer() {return this._customer;}</pre>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<pre class="pre">get name()           {...}
get billingPlan()    {...}
set billingPlan(arg) {...}
get paymentHistory() {...}</pre>
<p class="pro-title"><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0295_02a" href="ch10_images.xhtml#p0295_02">Click here to view code image</a></p>
<pre class="pre">const aCustomer = site.customer;
// ... lots of intervening code ...
let customerName;
if (aCustomer === "unknown") customerName = "occupant";
else customerName = aCustomer.name;</pre>
<p class="pro-title"><em>client 2&#8230;</em></p>
<p class="codelink"><a id="p0295_03a" href="ch10_images.xhtml#p0295_03">Click here to view code image</a></p>
<pre class="pre">const plan = (aCustomer === "unknown") ?
      registry.billingPlans.basic
      : aCustomer.billingPlan;</pre>
<p class="pro-title"><em>client 3&#8230;</em></p>
<p class="codelink"><a id="p0295_04a" href="ch10_images.xhtml#p0295_04">Click here to view code image</a></p>
<pre class="pre">const weeksDelinquent = (aCustomer === "unknown") ?
      0
      : aCustomer.paymentHistory.weeksDelinquentInLastYear;</pre>
<p class="indent">As with the previous case, I start by adding an <code>isUnknown</code> property to the customer and creating a special-case object with that field. The difference is that this time, the special case is a literal.</p>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<pre class="pre">get isUnknown() {return false;}</pre>
<p class="pro-title"><span epub:type="pagebreak" id="page_296"/><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0296_01a" href="ch10_images.xhtml#p0296_01">Click here to view code image</a></p>
<pre class="pre">function createUnknownCustomer() {
  return {
    isUnknown: true,
  };
}</pre>
<p class="indent">I apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> to the special case condition test.</p>
<p class="codelink"><a id="p0296_02a" href="ch10_images.xhtml#p0296_02">Click here to view code image</a></p>
<pre class="pre">function isUnknown(arg) {
  return (arg === "unknown");
}</pre>
<p class="pro-title"><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0296_03a" href="ch10_images.xhtml#p0296_03">Click here to view code image</a></p>
<pre class="pre">let customerName;
if (<span class="pd_maroon1">isUnknown</span>(aCustomer)) customerName = "occupant";
else customerName = aCustomer.name;</pre>
<p class="pro-title"><em>client 2&#8230;</em></p>
<p class="codelink"><a id="p0296_04a" href="ch10_images.xhtml#p0296_04">Click here to view code image</a></p>
<pre class="pre">const plan = <span class="pd_maroon1">isUnknown</span>(aCustomer) ?
      registry.billingPlans.basic
      : aCustomer.billingPlan;</pre>
<p class="pro-title"><em>client 3&#8230;</em></p>
<p class="codelink"><a id="p0296_05a" href="ch10_images.xhtml#p0296_05">Click here to view code image</a></p>
<pre class="pre">const weeksDelinquent = <span class="pd_maroon1">isUnknown</span>(aCustomer) ?
      0
      : aCustomer.paymentHistory.weeksDelinquentInLastYear;</pre>
<p class="indent">I change the site class and the condition test to work with the special case.</p>
<p class="pro-title"><em>class Site&#8230;</em></p>
<p class="codelink"><a id="p0296_06a" href="ch10_images.xhtml#p0296_06">Click here to view code image</a></p>
<pre class="pre">get customer() {
  <span class="pd_maroon1">return (this._customer === "unknown") ? createUnknownCustomer() : this._customer;</span>
}</pre>
<p class="pro-title"><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0296_07a" href="ch10_images.xhtml#p0296_07">Click here to view code image</a></p>
<pre class="pre">function isUnknown(arg) {
  return <span class="pd_maroon1">arg.isUnknown;</span>
}</pre>
<p class="indent">Then I replace each standard response with the appropriate literal value. I start with the name:</p>
<p class="codelink"><a id="p0296_08a" href="ch10_images.xhtml#p0296_08">Click here to view code image</a></p>
<pre class="pre">function createUnknownCustomer() {
  return {
    isUnknown: true,
    <span class="pd_maroon1">name: "occupant",</span>
  };
}</pre>
<p class="pro-title"><span epub:type="pagebreak" id="page_297"/><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0297_01a" href="ch10_images.xhtml#p0297_01">Click here to view code image</a></p>
<pre class="pre">const customerName = <span class="pd_maroon1">aCustomer.name;</span></pre>
<p class="indent">Then, the billing plan:</p>
<p class="codelink"><a id="p0297_02a" href="ch10_images.xhtml#p0297_02">Click here to view code image</a></p>
<pre class="pre">function createUnknownCustomer() {
  return {
    isUnknown: true,
    name: "occupant",
    <span class="pd_maroon1">billingPlan: registry.billingPlans.basic,</span>
  };
}</pre>
<p class="pro-title"><em>client 2&#8230;</em></p>
<p class="codelink"><a id="p0297_03a" href="ch10_images.xhtml#p0297_03">Click here to view code image</a></p>
<pre class="pre">const plan = <span class="pd_maroon1">aCustomer.billingPlan;</span></pre>
<p class="indent">Similarly, I can create a nested null payment history with the literal:</p>
<p class="codelink"><a id="p0297_04a" href="ch10_images.xhtml#p0297_04">Click here to view code image</a></p>
<pre class="pre">function createUnknownCustomer() {
  return {
    isUnknown: true,
    name: "occupant",
    billingPlan: registry.billingPlans.basic,
    <span class="pd_maroon1">paymentHistory: {</span>
      <span class="pd_maroon1">weeksDelinquentInLastYear: 0,</span>
    <span class="pd_maroon1">},</span>
  };
}</pre>
<p class="pro-title"><em>client 3&#8230;</em></p>
<p class="codelink"><a id="p0297_05a" href="ch10_images.xhtml#p0297_05">Click here to view code image</a></p>
<pre class="pre">const weeksDelinquent = <span class="pd_maroon1">aCustomer.paymentHistory.weeksDelinquentInLastYear;</span></pre>
<p class="indent">If I use a literal like this, I should make it immutable, which I might do with <code>freeze</code>. Usually, I&#8217;d rather use a class.</p>
<h4 class="h4" id="ch10lev2sec20">Example: Using a Transform</h4>
<p class="noindent">Both previous cases involve a class, but the same idea can be applied to a record by using a transform step.</p>
<p class="indent">Let&#8217;s assume our input is a simple record structure that looks something like this:</p>
<p class="codelink"><a id="p0298_01a" href="ch10_images.xhtml#p0298_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_298"/>{
  name: "Acme Boston",
  location: "Malden MA",
  // more site details
  customer: {
    name: "Acme Industries",
    billingPlan: "plan-451",
    paymentHistory: {
      weeksDelinquentInLastYear: 7
      //more
    },
    // more
  }
}</pre>
<p class="indent">In some cases, the customer isn&#8217;t known, and such cases are marked in the same way:</p>
<p class="codelink"><a id="p0298_02a" href="ch10_images.xhtml#p0298_02">Click here to view code image</a></p>
<pre class="pre">{
  name: "Warehouse Unit 15",
  location: "Malden MA",
  // more site details
  customer: "unknown",
}</pre>
<p class="indent">I have similar client code that checks for the unknown customer:</p>
<p class="pro-title"><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0298_03a" href="ch10_images.xhtml#p0298_03">Click here to view code image</a></p>
<pre class="pre">const site = acquireSiteData();
const aCustomer = site.customer;
// ... lots of intervening code ...
let customerName;
if (aCustomer === "unknown") customerName = "occupant";
else customerName = aCustomer.name;</pre>
<p class="pro-title"><em>client 2&#8230;</em></p>
<p class="codelink"><a id="p0298_04a" href="ch10_images.xhtml#p0298_04">Click here to view code image</a></p>
<pre class="pre">const plan = (aCustomer === "unknown") ?
      registry.billingPlans.basic
      : aCustomer.billingPlan;</pre>
<p class="pro-title"><em>client 3&#8230;</em></p>
<p class="codelink"><a id="p0298_05a" href="ch10_images.xhtml#p0298_05">Click here to view code image</a></p>
<pre class="pre">const weeksDelinquent = (aCustomer === "unknown") ?
      0
      : aCustomer.paymentHistory.weeksDelinquentInLastYear;</pre>
<p class="indent">My first step is to run the site data structure through a transform that, currently, does nothing but a deep copy.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_299"/><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0299_01a" href="ch10_images.xhtml#p0299_01">Click here to view code image</a></p>
<pre class="pre">  <span class="pd_maroon1">const rawSite = acquireSiteData();</span>
  <span class="pd_maroon1">const site = enrichSite(rawSite);</span>
  const aCustomer = site.customer;
  // ... lots of intervening code ...
  let customerName;
  if (aCustomer === "unknown") customerName = "occupant";
  else customerName = aCustomer.name;

<span class="pd_maroon1">function enrichSite(inputSite) {</span>
  <span class="pd_maroon1">return _.cloneDeep(inputSite);</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">I apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> to the test for an unknown customer.</p>
<p class="codelink"><a id="p0299_02a" href="ch10_images.xhtml#p0299_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">function isUnknown(aCustomer) {</span>
  <span class="pd_maroon1">return aCustomer === "unknown";</span>
<span class="pd_maroon1">}</span></pre>
<p class="pro-title"><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0299_03a" href="ch10_images.xhtml#p0299_03">Click here to view code image</a></p>
<pre class="pre">const rawSite = acquireSiteData();
const site = enrichSite(rawSite);
const aCustomer = site.customer;
// ... lots of intervening code ...
let customerName;
if (<span class="pd_maroon1">isUnknown</span>(aCustomer)) customerName = "occupant";
else customerName = aCustomer.name;</pre>
<p class="pro-title"><em>client 2&#8230;</em></p>
<p class="codelink"><a id="p0299_04a" href="ch10_images.xhtml#p0299_04">Click here to view code image</a></p>
<pre class="pre">const plan = (<span class="pd_maroon1">isUnknown</span>(aCustomer)) ?
      registry.billingPlans.basic
      : aCustomer.billingPlan;</pre>
<p class="pro-title"><em>client 3&#8230;</em></p>
<p class="codelink"><a id="p0299_05a" href="ch10_images.xhtml#p0299_05">Click here to view code image</a></p>
<pre class="pre">const weeksDelinquent = (<span class="pd_maroon1">isUnknown</span>(aCustomer)) ?
      0
      : aCustomer.paymentHistory.weeksDelinquentInLastYear;</pre>
<p class="indent">I begin the enrichment by adding an <code>isUnknown</code> property to the customer.</p>
<p class="codelink"><a id="p0299_06a" href="ch10_images.xhtml#p0299_06">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">function enrichSite(aSite) {</span>
  <span class="pd_maroon1">const result = _.cloneDeep(aSite);</span>
  <span class="pd_maroon1">const unknownCustomer = {</span>
    <span class="pd_maroon1">isUnknown: true,</span>
  <span class="pd_maroon1">};</span>

  <span class="pd_maroon1">if (isUnknown(result.customer)) result.customer = unknownCustomer;</span>
  <span class="pd_maroon1">else result.customer.isUnknown = false;</span>
  <span class="pd_maroon1">return result;</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_300"/>I can then modify the special-case condition test to include probing for this new property. I keep the original test as well, so that the test will work on both raw and enriched sites.</p>
<p class="codelink"><a id="p0300_01a" href="ch10_images.xhtml#p0300_01">Click here to view code image</a></p>
<pre class="pre">function isUnknown(aCustomer) {
  <span class="pd_maroon1">if (aCustomer === "unknown") return true;</span>
  <span class="pd_maroon1">else return aCustomer.isUnknown;</span>
}</pre>
<p class="indent">I test to ensure that&#8217;s all OK, then start applying <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec10">Combine Functions into Transform</a> (<a class="pd_maroon" href="ch06.xhtml#page_149">149</a>)</span></em> on the special case. First, I move the choice of name into the enrichment function.</p>
<p class="codelink"><a id="p0300_02a" href="ch10_images.xhtml#p0300_02">Click here to view code image</a></p>
<pre class="pre">function enrichSite(aSite) {
  const result = _.cloneDeep(aSite);
  const unknownCustomer = {
    isUnknown: true,
    <span class="pd_maroon1">name: "occupant",</span>
  };

  if (isUnknown(result.customer)) result.customer = unknownCustomer;
  else result.customer.isUnknown = false;
  return result;
}</pre>
<p class="pro-title"><em>client 1&#8230;</em></p>
<p class="codelink"><a id="p0300_03a" href="ch10_images.xhtml#p0300_03">Click here to view code image</a></p>
<pre class="pre">const rawSite = acquireSiteData();
const site = enrichSite(rawSite);
const aCustomer = site.customer;
// ... lots of intervening code ...
<span class="pd_maroon1">const customerName = aCustomer.name;</span></pre>
<p class="indent">I test, then do the billing plan.</p>
<p class="codelink"><a id="p0300_04a" href="ch10_images.xhtml#p0300_04">Click here to view code image</a></p>
<pre class="pre">function enrichSite(aSite) {
  const result = _.cloneDeep(aSite);
  const unknownCustomer = {
    isUnknown: true,
    name: "occupant",
    <span class="pd_maroon1">billingPlan: registry.billingPlans.basic,</span>
  };

  if (isUnknown(result.customer)) result.customer = unknownCustomer;
  else result.customer.isUnknown = false;
  return result;
}</pre>
<p class="pro-title"><em>client 2&#8230;</em></p>
<p class="codelink"><a id="p0300_05a" href="ch10_images.xhtml#p0300_05">Click here to view code image</a></p>
<pre class="pre">const plan = <span class="pd_maroon1">aCustomer.billingPlan;</span></pre>
<p class="indent">I test again, then do the last client.</p>
<p class="codelink"><a id="p0301_01a" href="ch10_images.xhtml#p0301_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_301"/>function enrichSite(aSite) {
  const result = _.cloneDeep(aSite);
  const unknownCustomer = {
    isUnknown: true,
    name: "occupant",
    billingPlan: registry.billingPlans.basic,
    <span class="pd_maroon1">paymentHistory: {</span>
      <span class="pd_maroon1">weeksDelinquentInLastYear: 0,</span>
    <span class="pd_maroon1">}</span>
  };

  if (isUnknown(result.customer)) result.customer = unknownCustomer;
  else result.customer.isUnknown = false;
  return result;
}</pre>
<p class="pro-title"><em>client 3&#8230;</em></p>
<p class="codelink"><a id="p0301_02a" href="ch10_images.xhtml#p0301_02">Click here to view code image</a></p>
<pre class="pre">const weeksDelinquent = <span class="pd_maroon1">aCustomer.paymentHistory.weeksDelinquentInLastYear;</span></pre>
<h3 class="h3" id="ch10lev1sec6"><span epub:type="pagebreak" id="page_302"/>Introduce Assertion</h3>
<figure class="fig-group">
<img src="graphics/p0302_01.jpg" aria-describedby="alt_p0302_01" alt="A figure illustrates how the refactoring technique is used in assertion."/>
<aside class="hidden" id="alt_p0302_01">
<p>The diagrammatic representation shows the code that indicates assertion (assumption). The actual code reads, if (this.discountRate) base = base - (this.discountRate * base); The code after refactoring reads, assert(this.discountRate &#62;= 0); if (this.discountRate) base = base - (this.discountRate * base);</p>
</aside>
</figure>
<h4 class="h4" id="ch10lev2sec21">Motivation</h4>
<p class="noindent">Often, sections of code work only if certain conditions are true. This may be as simple as a square root calculation only working on a positive input value. With an object, it may require that at least one of a group of fields has a value in it.</p>
<p class="indent">Such assumptions are often not stated but can only be deduced by looking through an algorithm. Sometimes, the assumptions are stated with a comment. A better technique is to make the assumption explicit by writing an assertion.</p>
<p class="indent">An assertion is a conditional statement that is assumed to be always true. Failure of an assertion indicates a programmer error. Assertion failures should never be checked by other parts of the system. Assertions should be written so that the program functions equally correctly if they are all removed; indeed, some languages provide assertions that can be disabled by a compile-time switch.</p>
<p class="indent">I often see people encourage using assertions in order to find errors. While this is certainly a Good Thing, it&#8217;s not the only reason to use them. I find assertions to be a valuable form of communication&#8212;they tell the reader something about the assumed state of the program at this point of execution. I also find them handy for debugging, and their communication value means I&#8217;m inclined to leave them in once I&#8217;ve fixed the error I&#8217;m chasing. Self-testing code reduces their value for debugging, as steadily narrowing unit tests often do the job better, but I still like assertions for communication.</p>
<h4 class="h4" id="ch10lev2sec22"><span epub:type="pagebreak" id="page_303"/>Mechanics</h4>
<ul class="square">
<li><p>When you see that a condition is assumed to be true, add an assertion to state it.</p></li>
</ul>
<p class="indent">Since assertions should not affect the running of a system, adding one is always behavior-preserving.</p>
<h4 class="h4" id="ch10lev2sec23">Example</h4>
<p class="noindent">Here&#8217;s a simple tale of discounts. A customer can be given a discount rate to apply to all their purchases:</p>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<p class="codelink"><a id="p0303_01a" href="ch10_images.xhtml#p0303_01">Click here to view code image</a></p>
<pre class="pre">applyDiscount(aNumber) {
  return (this.discountRate)
    ? aNumber - (this.discountRate * aNumber)
    : aNumber;
}</pre>
<p class="indent">There&#8217;s an assumption here that the discount rate is a positive number. I can make that assumption explicit by using an assertion. But I can&#8217;t easily place an assertion into a ternary expression, so first I&#8217;ll reformulate it as an if-then statement.</p>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<p class="codelink"><a id="p0303_02a" href="ch10_images.xhtml#p0303_02">Click here to view code image</a></p>
<pre class="pre">applyDiscount(aNumber) {
  if (!this.discountRate) return aNumber;
  else return aNumber - (this.discountRate * aNumber);
}</pre>
<p class="indent">Now I can easily add the assertion.</p>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<p class="codelink"><a id="p0303_03a" href="ch10_images.xhtml#p0303_03">Click here to view code image</a></p>
<pre class="pre">applyDiscount(aNumber) {
  if (!this.discountRate) return aNumber;
  else {
    <span class="pd_maroon1">assert(this.discountRate &gt;= 0);</span>
    return aNumber - (this.discountRate * aNumber);
  }
}</pre>
<p class="indent">In this case, I&#8217;d rather put this assertion into the setting method. If the assertion fails in <code>applyDiscount</code>, my first puzzle is how it got into the field in the first place.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_304"/><em>class Customer&#8230;</em></p>
<p class="codelink"><a id="p0304_01a" href="ch10_images.xhtml#p0304_01">Click here to view code image</a></p>
<pre class="pre">set discountRate(aNumber) {
  <span class="pd_maroon1">assert(null === aNumber || aNumber &gt;= 0);</span>
  this._discountRate = aNumber;
}</pre>
<p class="indent">An assertion like this can be particularly valuable if it&#8217;s hard to spot the error source&#8212;which may be an errant minus sign in some input data or some inversion elsewhere in the code.</p>
<p class="indent">There is a real danger of overusing assertions. I don&#8217;t use assertions to check everything that I think is true, but only to check things that <em>need</em> to be true. Duplication is a particular problem, as it&#8217;s common to tweak these kinds of conditions. So I find it&#8217;s essential to remove any duplication in these conditions, usually by a liberal use of <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em>.</p>
<p class="indent">I only use assertions for things that are programmer errors. If I&#8217;m reading data from an external source, any value checking should be a first-class part of the program, not an assertion&#8212;unless I&#8217;m really confident in the external source. Assertions are a last resort to help track bugs&#8212;though, ironically, I only use them when I think they should never fail.</p>
</section>
</body>
</html>