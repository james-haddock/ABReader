<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>Refactoring: Improving the Design of Existing Code</title>
<link rel="stylesheet" type="text/css" href="9780134757704.css"/>
</head>
<body>
<section epub:type="bodymatter">
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_197"/>Chapter 8<br/>Moving Features</h2>
<p class="noindent">So far, the refactorings have been about creating, removing, and renaming program elements. Another important part of refactoring is moving elements between contexts. I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em> to move functions between classes and other modules. Fields can move too, with <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec2">Move Field</a> (<a class="pd_maroon" href="ch08.xhtml#page_207">207</a>)</span></em>.</p>
<p class="indent">I also move individual statements around. I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec3">Move Statements into Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_213">213</a>)</span></em> and <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec4">Move Statements to Callers</a> (<a class="pd_maroon" href="ch08.xhtml#page_217">217</a>)</span></em> to move them in or out of functions, as well as <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec6">Slide Statements</a> (<a class="pd_maroon" href="ch08.xhtml#page_223">223</a>)</span></em> to move them within a function. Sometimes, I can take some statements that match an existing function and use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec5">Replace Inline Code with Function Call</a> (<a class="pd_maroon" href="ch08.xhtml#page_222">222</a>)</span></em> to remove the duplication.</p>
<p class="indent">Two refactorings I often do with loops are <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec7">Split Loop</a> (<a class="pd_maroon" href="ch08.xhtml#page_227">227</a>)</span></em>, to ensure a loop does only one thing, and <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec8">Replace Loop with Pipeline</a> (<a class="pd_maroon" href="ch08.xhtml#page_231">231</a>)</span></em> to get rid of a loop entirely.</p>
<p class="indent">And then there&#8217;s the favorite refactoring of many a fine programmer: <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec9">Remove Dead Code</a> (<a class="pd_maroon" href="ch08.xhtml#page_237">237</a>)</span></em>. Nothing is as satisfying as applying the digital flamethrower to superfluous statements.</p>
<h3 class="h3" id="ch08lev1sec1"><span epub:type="pagebreak" id="page_198"/>Move Function</h3>
<p class="noindent">formerly: <em>Move Method</em></p>
<figure class="fig-group">
<img src="graphics/p0198_01.jpg" aria-describedby="alt_p0198_01" alt="A figure shows a simple representation and a code for the &#145;move function&#146; operation"/>
<aside class="hidden" id="alt_p0198_01">
<p>A diagrammatic representation of the &#145;move function&#146; operation shows a function being moved at the top, and the actual code reads, class Account { get overdraftCharge() {...} The refactored code reads, class AccountType { get overdraftCharge() {...}</p>
</aside>
</figure>
<h4 class="h4" id="ch08lev2sec1">Motivation</h4>
<p class="noindent">The heart of a good software design is its modularity&#8212;which is my ability to make most modifications to a program while only having to understand a small part of it. To get this modularity, I need to ensure that related software elements are grouped together and the links between them are easy to find and understand. But my understanding of how to do this isn&#8217;t static&#8212;as I better understand what I&#8217;m doing, I learn how to best group together software elements. To reflect that growing understanding, I need to move elements around.</p>
<p class="indent">All functions live in some context; it may be global, but usually it&#8217;s some form of a module. In an object-oriented program, the core modular context is a class. Nesting a function within another creates another common context. Different languages provide varied forms of modularity, each creating a context for a function to live in.</p>
<p class="indent">One of the most straightforward reasons to move a function is when it references elements in other contexts more than the one it currently resides in. Moving it together with those elements often improves encapsulation, allowing other parts of the software to be less dependent on the details of this module.</p>
<p class="indent">Similarly, I may move a function because of where its callers live, or where I need to call it from in my next enhancement. A function defined as a helper inside another function may have value on its own, so it&#8217;s worth moving it to somewhere more accessible. A method on a class may be easier for me to use if shifted to another.</p>
<p class="indent"><span epub:type="pagebreak" id="page_199"/>Deciding to move a function is rarely an easy decision. To help me decide, I examine the current and candidate contexts for that function. I need to look at what functions call this one, what functions are called by the moving function, and what data that function uses. Often, I see that I need a new context for a group of functions and create one with <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec9">Combine Functions into Class</a> (<a class="pd_maroon" href="ch06.xhtml#page_144">144</a>)</span></em> or <em><span class="pd_maroon"><a class="pd_maroon" href="ch07.xhtml#ch07lev1sec5">Extract Class</a> (<a class="pd_maroon" href="ch07.xhtml#page_182">182</a>)</span></em>. Although it can be difficult to decide where the best place for a function is, the more difficult this choice, often the less it matters. I find it valuable to try working with functions in one context, knowing I&#8217;ll learn how well they fit, and if they don&#8217;t fit I can always move them later.</p>
<h4 class="h4" id="ch08lev2sec2">Mechanics</h4>
<ul class="square">
<li><p>Examine all the program elements used by the chosen function in its current context. Consider whether they should move too.</p>
<div class="blockquote">
<p class="noindent">If I find a called function that should also move, I usually move it first. That way, moving a clusters of functions begins with the one that has the least dependency on the others in the group.</p>
<p class="noindent">If a high-level function is the only caller of subfunctions, then you can inline those functions into the high-level method, move, and reextract at the destination.</p>
</div></li>
<li><p>Check if the chosen function is a polymorphic method.</p>
<div class="blockquote">
<p class="noindent">If I&#8217;m in an object-oriented language, I have to take account of super- and subclass declarations.</p>
</div></li>
<li><p>Copy the function to the target context. Adjust it to fit in its new home.</p>
<div class="blockquote">
<p class="noindent">If the body uses elements in the source context, I need to either pass those elements as parameters or pass a reference to that source context.</p>
<p class="noindent">Moving a function often means I need to come up with a different name that works better in the new context.</p>
</div></li>
<li><p>Perform static analysis.</p></li>
<li><p>Figure out how to reference the target function from the source context.</p></li>
<li><p>Turn the source function into a delegating function.</p></li>
<li><p>Test.</p></li>
<li><p>Consider <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> on the source function.</p>
<div class="blockquote">
<p class="noindent">The source function can stay indefinitely as a delegating function. But if its callers can just as easily reach the target directly, then it&#8217;s better to remove the middle man.</p>
</div></li>
</ul>
<h4 class="h4" id="ch08lev2sec3"><span epub:type="pagebreak" id="page_200"/>Example: Moving a Nested Function to Top Level</h4>
<p class="noindent">I&#8217;ll begin with a function that calculates the total distance for a GPS track record.</p>
<p class="codelink"><a id="p0200_01a" href="ch08_images.xhtml#p0200_01">Click here to view code image</a></p>
<pre class="pre">function trackSummary(points) {
  const totalTime = calculateTime();
  const totalDistance = calculateDistance();
  const pace = totalTime / 60 /  totalDistance ;
  return {
    time: totalTime,
    distance: totalDistance,
    pace: pace
  };

  function calculateDistance() {
    let result = 0;
    for (let i = 1; i &lt; points.length; i++) {
      result += distance(points[i-1], points[i]);
    }
    return result;
  }

 function distance(p1,p2) { ... }
 function radians(degrees) { ... }
 function calculateTime() { ... }

}</pre>
<p class="indent">I&#8217;d like to move <code>calculateDistance</code> to the top level so I can calculate distances for tracks without all the other parts of the summary.</p>
<p class="indent">I begin by copying the function to the top level.</p>
<p class="codelink"><a id="p0200_02a" href="ch08_images.xhtml#p0200_02">Click here to view code image</a></p>
<pre class="pre">function trackSummary(points) {
  const totalTime = calculateTime();
  const totalDistance = calculateDistance();
  const pace = totalTime / 60 /  totalDistance ;
  return {
    time: totalTime,
    distance: totalDistance,
    pace: pace
  };

  function calculateDistance() {
    let result = 0;
    for (let i = 1; i &lt; points.length; i++) {
      result += distance(points[i-1], points[i]);
    }
    return result;
  }
  ...

 <span epub:type="pagebreak" id="page_201"/>function distance(p1,p2) { ... }
 function radians(degrees) { ... }
 function calculateTime() { ... }

}

  <span class="pd_maroon1">function top_calculateDistance() {</span>
    <span class="pd_maroon1">let result = 0;</span>
    <span class="pd_maroon1">for (let i = 1; i &lt; points.length; i++) {</span>
      <span class="pd_maroon1">result += distance(points[i-1], points[i]);</span>
    <span class="pd_maroon1">}</span>
    <span class="pd_maroon1">return result;</span>
  <span class="pd_maroon1">}</span></pre>
<p class="indent">When I copy a function like this, I like to change the name so I can distinguish them both in the code and in my head. I don&#8217;t want to think about what the right name should be right now, so I create a temporary name.</p>
<p class="indent">The program still works, but my static analysis is rightly rather upset. The new function has two undefined symbols: <code>distance</code> and <code>points</code>. The natural way to deal with <code>points</code> is to pass it in as a parameter.</p>
<p class="codelink"><a id="p0201_01a" href="ch08_images.xhtml#p0201_01">Click here to view code image</a></p>
<pre class="pre">function top_calculateDistance(<span class="pd_maroon1">points</span>) {
  let result = 0;
  for (let i = 1; i &lt; points.length; i++) {
    result += distance(points[i-1], points[i]);
  }
  return result;
}</pre>
<p class="indent">I could do the same with <code>distance</code>, but perhaps it makes sense to move it together with <code>calculateDistance</code>. Here&#8217;s the relevant code:</p>
<p class="pro-title"><em>function trackSummary&#8230;</em></p>
<p class="codelink"><a id="p0201_02a" href="ch08_images.xhtml#p0201_02">Click here to view code image</a></p>
<pre class="pre">function distance(p1,p2) {
  // haversine formula see http://www.movable-type.co.uk/scripts/latlong.html
  const EARTH_RADIUS = 3959; // in miles
  const dLat = radians(p2.lat) - radians(p1.lat);
  const dLon = radians(p2.lon) - radians(p1.lon);
  const a = Math.pow(Math.sin(dLat / 2),2)
          + Math.cos(radians(p2.lat))
          * Math.cos(radians(p1.lat))
          * Math.pow(Math.sin(dLon / 2), 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return EARTH_RADIUS * c;
}
function radians(degrees) {
  return degrees * Math.PI / 180;
}</pre>
<p class="indent">I can see that <code>distance</code> only uses <code>radians</code> and <code>radians</code> doesn&#8217;t use anything inside its current context. So rather than pass the functions, I might as well move them <span epub:type="pagebreak" id="page_202"/>too. I can make a small step in this direction by moving them from their current context to nest them inside the nested <code>calculateDistance</code>.</p>
<p class="codelink"><a id="p0202_01a" href="ch08_images.xhtml#p0202_01">Click here to view code image</a></p>
<pre class="pre">function trackSummary(points) {
  const totalTime = calculateTime();
  const totalDistance = calculateDistance();
  const pace = totalTime / 60 /  totalDistance ;
  return {
    time: totalTime,
    distance: totalDistance,
    pace: pace
  };

  function calculateDistance() {
    let result = 0;
    for (let i = 1; i &lt; points.length; i++) {
      result += distance(points[i-1], points[i]);
    }
    return result;

    function distance(p1,p2) { ... }
    function radians(degrees) { ... }
  }</pre>
<p class="indent">By doing this, I can use both static analysis and testing to tell me if there are any complications. In this case all is well, so I can copy them over to <code>top_calculateDistance</code>.</p>
<p class="codelink"><a id="p0202_02a" href="ch08_images.xhtml#p0202_02">Click here to view code image</a></p>
<pre class="pre">function top_calculateDistance(points) {
  let result = 0;
  for (let i = 1; i &lt; points.length; i++) {
    result += distance(points[i-1], points[i]);
  }
  return result;

 function distance(p1,p2) { ... }
 function radians(degrees) { ... }

}</pre>
<p class="indent">Again, the copy doesn&#8217;t change how the program runs, but does give me an opportunity for more static analysis. Had I not spotted that <code>distance</code> calls <code>radians</code>, the linter would have caught it at this step.</p>
<p class="indent">Now that I have prepared the table, it&#8217;s time for the major change&#8212;the body of the original <code>calculateDistance</code> will now call <code>top_calculateDistance</code>:</p>
<p class="codelink"><a id="p0203_01a" href="ch08_images.xhtml#p0203_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_203"/>function trackSummary(points) {
  const totalTime = calculateTime();
  const totalDistance = calculateDistance();
  const pace = totalTime / 60 /  totalDistance ;
  return {
    time: totalTime,
    distance: totalDistance,
    pace: pace
  };

  function calculateDistance() {
    <span class="pd_maroon1">return top_calculateDistance(points);</span>
  }</pre>
<p class="indent">This is the crucial time to run tests to fully test that the moved function has bedded down in its new home.</p>
<p class="indent">With that done, it&#8217;s like unpacking the boxes after moving house. The first thing is to decide whether to keep the original function that&#8217;s just delegating or not. In this case, there are few callers and, as usual with nested functions, they are highly localized. So I&#8217;m happy to get rid of it.</p>
<p class="codelink"><a id="p0203_02a" href="ch08_images.xhtml#p0203_02">Click here to view code image</a></p>
<pre class="pre">function trackSummary(points) {
  const totalTime = calculateTime();
  const totalDistance = <span class="pd_maroon1">top_calculateDistance(points);</span>
  const pace = totalTime / 60 /  totalDistance ;
  return {
    time: totalTime,
    distance: totalDistance,
    pace: pace
  };</pre>
<p class="indent">Now is also a good time to think about what I want the name to be. Since the top-level function has the highest visibility, I&#8217;d like it to have the best name. <code>totalDistance</code> seems like a good choice. I can&#8217;t use that immediately since it will be shadowed by the variable inside <code>trackSummary</code>&#8212;but I don&#8217;t see any reason to keep that anyway, so I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec4">Inline Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_123">123</a>)</span></em> on it.</p>
<p class="codelink"><a id="p0203_03a" href="ch08_images.xhtml#p0203_03">Click here to view code image</a></p>
<pre class="pre">function trackSummary(points) {
  const totalTime = calculateTime();
  const pace = totalTime / 60 /  <span class="pd_maroon1">totalDistance(points)</span> ;
  return {
    time: totalTime,
    distance: <span class="pd_maroon1">totalDistance(points)</span>,
    pace: pace
  };
<span epub:type="pagebreak" id="page_204"/>function <span class="pd_maroon1">totalDistance</span>(points) {
  let result = 0;
  for (let i = 1; i &lt; points.length; i++) {
    result += distance(points[i-1], points[i]);
  }
  return result;</pre>
<p class="indent">If I&#8217;d had the need to keep the variable, I&#8217;d have renamed it to something like <code>totalDistanceCache</code> or <code>distance</code>.</p>
<p class="indent">Since the functions for <code>distance</code> and <code>radians</code> don&#8217;t depend on anything inside <code>totalDistance</code>, I prefer to move them to top level too, putting all four functions at the top level.</p>
<p class="codelink"><a id="p0204_01a" href="ch08_images.xhtml#p0204_01">Click here to view code image</a></p>
<pre class="pre">function trackSummary(points) { ... }
function totalDistance(points) { ... }
function distance(p1,p2) { ... }
function radians(degrees) { ... }</pre>
<p class="indent">Some people would prefer to keep <code>distance</code> and <code>radians</code> inside <code>totalDistance</code> in order to restrict their visibility. In some languages that may be a consideration, but with ES 2015, JavaScript has an excellent module mechanism that&#8217;s the best tool for controlling function visibility. In general, I&#8217;m wary of nested functions&#8212;they too easily set up hidden data interrelationships that can get hard to follow.</p>
<h4 class="h4" id="ch08lev2sec4">Example: Moving between Classes</h4>
<p class="noindent">To illustrate this variety of Move Function, I&#8217;ll start here:</p>
<p class="pro-title"><em>class Account&#8230;</em></p>
<p class="codelink"><a id="p0204_02a" href="ch08_images.xhtml#p0204_02">Click here to view code image</a></p>
<pre class="pre">get bankCharge() {
  let result = 4.5;
  if (this._daysOverdrawn &gt; 0) result += this.overdraftCharge;
  return result;
}

get overdraftCharge() {
  if (this.type.isPremium) {
    const baseCharge = 10;
    if (this.daysOverdrawn &lt;= 7)
      return baseCharge;
    else
      return baseCharge + (this.daysOverdrawn - 7) * 0.85;
  }
  else
    return this.daysOverdrawn * 1.75;
}</pre>
<p class="indent">Coming up are changes that lead to different types of account having different algorithms for determining the charge. Thus it seems natural to move <code>overdraftCharge</code> to the account type class.</p>
<p class="indent"><span epub:type="pagebreak" id="page_205"/>The first step is to look at the features that the <code>overdraftCharge</code> method uses and consider whether it is worth moving a batch of methods together. In this case I need the <code>daysOverdrawn</code> method to remain on the account class, because that will vary with individual accounts.</p>
<p class="indent">Next, I copy the method body over to the account type and get it to fit.</p>
<p class="pro-title"><em>class AccountType&#8230;</em></p>
<p class="codelink"><a id="p0205_01a" href="ch08_images.xhtml#p0205_01">Click here to view code image</a></p>
<pre class="pre">overdraftCharge(<span class="pd_maroon1">daysOverdrawn</span>) {
  if (<span class="pd_maroon1">this.isPremium</span>) {
    const baseCharge = 10;
    if (<span class="pd_maroon1">daysOverdrawn</span> &lt;= 7)
      return baseCharge;
    else
      return baseCharge + (daysOv<span class="pd_maroon1">erdrawn</span> - 7) * 0.85;
  }
  else
    return <span class="pd_maroon1">daysOverdrawn</span> * 1.75;
}</pre>
<p class="indent">In order to get the method to fit in its new location, I need to deal with two call targets that change their scope. <code>isPremium</code> is now a simple call on <code>this</code>. With <code>daysOverdrawn</code> I have to decide&#8212;do I pass the value or do I pass the account? For the moment, I just pass the simple value but I may well change this in the future if I require more than just the days overdrawn from the account&#8212;especially if what I want from the account varies with the account type.</p>
<p class="indent">Next, I replace the original method body with a delegating call.</p>
<p class="pro-title"><em>class Account&#8230;</em></p>
<p class="codelink"><a id="p0205_02a" href="ch08_images.xhtml#p0205_02">Click here to view code image</a></p>
<pre class="pre">get bankCharge() {
  let result = 4.5;
  if (this._daysOverdrawn &gt; 0) result += this.overdraftCharge;
  return result;
}

get overdraftCharge() {
  <span class="pd_maroon1">return this.type.overdraftCharge(this.daysOverdrawn);</span>
}</pre>
<p class="indent">Then comes the decision of whether to leave the delegation in place or to inline <code>overdraftCharge</code>. Inlining results in:</p>
<p class="pro-title"><em>class Account&#8230;</em></p>
<p class="codelink"><a id="p0205_03a" href="ch08_images.xhtml#p0205_03">Click here to view code image</a></p>
<pre class="pre">get bankCharge() {
  let result = 4.5;
  if (this._daysOverdrawn &gt; 0)
    result += <span class="pd_maroon1">this.type.overdraftCharge(this.daysOverdrawn);</span>
  return result;
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_206"/>In the earlier steps, I passed <code>daysOverdrawn</code> as a parameter&#8212;but if there&#8217;s a lot of data from the account to pass, I might prefer to pass the account itself.</p>
<p class="pro-title"><em>class Account&#8230;</em></p>
<p class="codelink"><a id="p0206_01a" href="ch08_images.xhtml#p0206_01">Click here to view code image</a></p>
<pre class="pre">get bankCharge() {
  let result = 4.5;
  if (this._daysOverdrawn &gt; 0) result += this.overdraftCharge;
  return result;
}

get overdraftCharge() {
  return this.type.overdraftCharge<span class="pd_maroon1">(this)</span>;
}</pre>
<p class="pro-title"><em>class AccountType&#8230;</em></p>
<p class="codelink"><a id="p0206_02a" href="ch08_images.xhtml#p0206_02">Click here to view code image</a></p>
<pre class="pre">overdraftCharge(<span class="pd_maroon1">account</span>) {
  if (this.isPremium) {
    const baseCharge = 10;
    if (<span class="pd_maroon1">account</span>.day>sOverdrawn &lt;= 7)
      return baseCharge;
    else
      return baseCharge + (<span class="pd_maroon1">account</span>.daysOverdrawn - 7) * 0.85;
  }
  else
    return <span class="pd_maroon1">account</span>.daysOverdrawn * 1.75;
}</pre>
<h3 class="h3" id="ch08lev1sec2"><span epub:type="pagebreak" id="page_207"/>Move Field</h3>
<figure class="fig-group">
<img src="graphics/p0207_01.jpg" aria-describedby="alt_p0207_01" alt="A figure shows a simple representation and a code for the &#145;move field&#146; operation."/>
<aside class="hidden" id="alt_p0207_01">
<p>A diagrammatic representation of the &#145;move field&#146; operation shows that the user is changed to a new field created in the target class. The actual code reads, class Customer { get plan() {return this._plan;} get discountRate() {return this._discountRate;} The refactored code reads, class Customer { get plan() {return this._plan;} get discountRate() {return this.plan.discountRate;}</p>
</aside>
</figure>
<h4 class="h4" id="ch08lev2sec5">Motivation</h4>
<p class="noindent">Programming involves writing a lot of code that implements behavior&#8212;but the strength of a program is really founded on its data structures. If I have a good set of data structures that match the problem, then my behavior code is simple and straightforward. But poor data structures lead to lots of code whose job is merely dealing with the poor data. And it&#8217;s not just messier code that&#8217;s harder to understand; it also means the data structures obscure what the program is doing.</p>
<p class="indent">So, data structures are important&#8212;but like most aspects of programming they are hard to get right. I do make an initial analysis to figure out the best data structures, and I&#8217;ve found that experience and techniques like domain-driven design have improved my ability to do that. But despite all my skill and experience, I still find that I frequently make mistakes in that initial design. In the process of programming, I learn more about the problem domain and my data structures. A design decision that is reasonable and correct one week can become wrong in another.</p>
<p class="indent">As soon as I realize that a data structure isn&#8217;t right, it&#8217;s vital to change it. If I leave my data structures with their blemishes, those blemishes will confuse my thinking and complicate my code far into the future.</p>
<p class="indent">I may seek to move data because I find I always need to pass a field from one record whenever I pass another record to a function. Pieces of data that are always passed to functions together are usually best put in a single record in order to <span epub:type="pagebreak" id="page_208"/>clarify their relationship. Change is also a factor; if a change in one record causes a field in another record to change too, that&#8217;s a sign of a field in the wrong place. If I have to update the same field in multiple structures, that&#8217;s a sign that it should move to another place where it only needs to be updated once.</p>
<p class="indent">I usually do Move Field in the context of a broader set of changes. Once I&#8217;ve moved a field, I find that many of the users of the field are better off accessing that data through the target object rather than the original source. I then change these with later refactorings. Similarly, I may find that I can&#8217;t do Move Field at the moment due to the way the data is used. I need to refactor some usage patterns first, then do the move.</p>
<p class="indent">In my description so far, I&#8217;m saying &#8220;record,&#8221; but all this is true of classes and objects too. A class is a record type with attached functions&#8212;and these need to be kept healthy just as much as any other data. The attached functions do make it easier to move data around, since the data is encapsulated behind accessor methods. I can move the data, change the accessors, and clients of the accessors will still work. So, this is a refactoring that&#8217;s easier to do if you have classes, and my description below makes that assumption. If I&#8217;m using bare records that don&#8217;t support encapsulation, I can still make a change like this, but it is more tricky.</p>
<h4 class="h4" id="ch08lev2sec6">Mechanics</h4>
<ul class="square">
<li><p>Ensure the source field is encapsulated.</p></li>
<li><p>Test.</p></li>
<li><p>Create a field (and accessors) in the target.</p></li>
<li><p>Run static checks.</p></li>
<li><p>Ensure there is a reference from the source object to the target object.</p>
<div class="blockquote">
<p class="noindent">An existing field or method may give you the target. If not, see if you can easily create a method that will do so. Failing that, you may need to create a new field in the source object that can store the target. This may be a permanent change, but you can also do it temporarily until you have done enough refactoring in the broader context.</p>
</div></li>
<li><p>Adjust accessors to use the target field.</p>
<div class="blockquote">
<p class="noindent">If the target is shared between source objects, consider first updating the setter to modify both target and source fields, followed by <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec6">Introduce Assertion</a> (<a class="pd_maroon" href="ch10.xhtml#page_302">302</a>)</span></em> to detect inconsistent updates. Once you determine all is well, finish changing the accessors to use the target field.</p>
</div></li>
<li><p>Test.</p></li>
<li><p><span epub:type="pagebreak" id="page_209"/>Remove the source field.</p></li>
<li><p>Test.</p></li>
</ul>
<h4 class="h4" id="ch08lev2sec7">Example</h4>
<p class="noindent">I&#8217;m starting here with this customer and contract:</p>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<p class="codelink"><a id="p0209_01a" href="ch08_images.xhtml#p0209_01">Click here to view code image</a></p>
<pre class="pre">constructor(name, discountRate) {
  this._name = name;
  this._discountRate = discountRate;
  this._contract = new CustomerContract(dateToday());
}
get discountRate() {return this._discountRate;}
becomePreferred() {
  this._discountRate += 0.03;
  // other nice things
}
applyDiscount(amount) {
  return amount.subtract(amount.multiply(this._discountRate));
}</pre>
<p class="pro-title"><em>class CustomerContract&#8230;</em></p>
<p class="codelink"><a id="p0209_02a" href="ch08_images.xhtml#p0209_02">Click here to view code image</a></p>
<pre class="pre">constructor(startDate) {
  this._startDate = startDate;
}</pre>
<p class="indent">I want to move the discount rate field from the customer to the customer contract.</p>
<p class="indent">The first thing I need to use is <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec6">Encapsulate Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_132">132</a>)</span></em> to encapsulate access to the discount rate field.</p>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<p class="codelink"><a id="p0209_03a" href="ch08_images.xhtml#p0209_03">Click here to view code image</a></p>
<pre class="pre">constructor(name, discountRate) {
  this._name = name;
  this.<span class="pd_maroon1">_setDiscountRate</span>(discountRate);
  this._contract = new CustomerContract(dateToday());
}
get discountRate() {return this._discountRate;}
<span class="pd_maroon1">_setDiscountRate(aNumber) {this._discountRate = aNumber;}</span>
becomePreferred() {
  this.<span class="pd_maroon1">_setDiscountRate</span>(<span class="pd_maroon1">this.discountRate</span> + 0.03);
  // other nice things
}
applyDiscount(amount) {
  return amount.subtract(amount.multiply(<span class="pd_maroon1">this.discountRate</span>));
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_210"/>I use a method to update the discount rate, rather than a property setter, as I don&#8217;t want to make a public setter for the discount rate.</p>
<p class="indent">I add a field and accessors to the customer contract.</p>
<p class="pro-title"><em>class CustomerContract&#8230;</em></p>
<p class="codelink"><a id="p0210_01a" href="ch08_images.xhtml#p0210_01">Click here to view code image</a></p>
<pre class="pre">constructor(startDate, <span class="pd_maroon1">discountRate</span>) {
  this._startDate = startDate;
  <span class="pd_maroon1">this._discountRate = discountRate;</span>
}
<span class="pd_maroon1">get discountRate()    {return this._discountRate;}</span>
<span class="pd_maroon1">set discountRate(arg) {this._discountRate = arg;}</span></pre>
<p class="indent">I now modify the accessors on customer to use the new field. When I did that, I got an error: &#8220;Cannot set property &#8217;discountRate&#8217; of undefined&#8221;. This was because <code>_setDiscountRate</code> was called before I created the contract object in the constructor. To fix that, I first reverted to the previous state, then used <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec6">Slide Statements</a> (<a class="pd_maroon" href="ch08.xhtml#page_223">223</a>)</span></em> to move the <code>_setDiscountRate</code> after creating the contract.</p>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<p class="codelink"><a id="p0210_02a" href="ch08_images.xhtml#p0210_02">Click here to view code image</a></p>
<pre class="pre">constructor(name, discountRate) {
  this._name = name;
  this._setDiscountRate(discountRate);
  this._contract = new CustomerContract(dateToday());
}</pre>
<p class="indent">I tested that, then changed the accessors again to use the contract.</p>
<p class="pro-title"><em>class Customer&#8230;</em></p>
<p class="codelink"><a id="p0210_03a" href="ch08_images.xhtml#p0210_03">Click here to view code image</a></p>
<pre class="pre">get discountRate() {return this.<span class="pd_maroon1">_contract</span>.discountRate;}
_setDiscountRate(aNumber) {this.<span class="pd_maroon1">_contract</span>.discountRate = aNumber;}</pre>
<p class="indent">Since I&#8217;m using JavaScript, there is no declared source field, so I don&#8217;t need to remove anything further.</p>
<h5 class="h5" id="ch08lev3sec1"><em>Changing a Bare Record</em></h5>
<p class="noindent">This refactoring is generally easier with objects, since encapsulation provides a natural way to wrap data access in methods. If I have many functions accessing a bare record, then, while it&#8217;s still a valuable refactoring, it is decidedly more tricky.</p>
<p class="indent">I can create accessor functions and modify all the reads and writes to use them. If the field that&#8217;s being moved is immutable, I can update both the source and the target fields when I set its value and gradually migrate reads. Still, if possible, my first move would be to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch07.xhtml#ch07lev1sec1">Encapsulate Record</a> (<a class="pd_maroon" href="ch07.xhtml#page_162">162</a>)</span></em> to turn the record into a class so I can make the change more easily.</p>
<h4 class="h4" id="ch08lev2sec8"><span epub:type="pagebreak" id="page_211"/>Example: Moving to a Shared Object</h4>
<p class="noindent">Now, let&#8217;s consider a different case. Here&#8217;s an account with an interest rate:</p>
<p class="pro-title"><em>class Account&#8230;</em></p>
<p class="codelink"><a id="p0211_01a" href="ch08_images.xhtml#p0211_01">Click here to view code image</a></p>
<pre class="pre">constructor(number, type, interestRate) {
  this._number = number;
  this._type = type;
  this._interestRate = interestRate;
}
get interestRate() {return this._interestRate;}</pre>
<p class="pro-title"><em>class AccountType&#8230;</em></p>
<pre class="pre">constructor(nameString) {
  this._name = nameString;
}</pre>
<p class="indent">I want to change things so that an account&#8217;s interest rate is determined from its account type.</p>
<p class="indent">The access to the interest rate is already nicely encapsulated, so I&#8217;ll just create the field and an appropriate accessor on the account type.</p>
<p class="pro-title"><em>class AccountType&#8230;</em></p>
<p class="codelink"><a id="p0211_02a" href="ch08_images.xhtml#p0211_02">Click here to view code image</a></p>
<pre class="pre">constructor(nameString, <span class="pd_maroon1">interestRate</span>) {
  this._name = nameString;
  <span class="pd_maroon1">this._interestRate = interestRate;</span>
}
<span class="pd_maroon1">get interestRate() {return this._interestRate;}</span></pre>
<p class="indent">But there is a potential problem when I update the accesses from account. Before this refactoring, each account had its own interest rate. Now, I want all accounts to share the interest rates of their account type. If all the accounts of the same type already have the same interest rate, then there&#8217;s no change in observable behavior, so I&#8217;m fine with the refactoring. But if there&#8217;s an account with a different interest rate, it&#8217;s no longer a refactoring. If my account data is held in a database, I should check the database to ensure that all my accounts have the rate matching their type. I can also <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec6">Introduce Assertion</a> (<a class="pd_maroon" href="ch10.xhtml#page_302">302</a>)</span></em> in the account class.</p>
<p class="pro-title"><em>class Account&#8230;</em></p>
<p class="codelink"><a id="p0211_03a" href="ch08_images.xhtml#p0211_03">Click here to view code image</a></p>
<pre class="pre">constructor(number, type, interestRate) {
  this._number = number;
  this._type = type;
  <span class="pd_maroon1">assert(interestRate === this._type.interestRate);</span>
  this._interestRate = interestRate;
}
get interestRate() {return this._interestRate;}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_212"/>I might run the system for a while with this assertion in place to see if I get an error. Or, instead of adding an assertion, I might log the problem. Once I&#8217;m confident that I&#8217;m not introducing an observable change, I can change the access, removing the update from the account completely.</p>
<p class="pro-title"><em>class Account&#8230;</em></p>
<p class="codelink"><a id="p0212_01a" href="ch08_images.xhtml#p0212_01">Click here to view code image</a></p>
<pre class="pre">constructor(number, type) {
  this._number = number;
  this._type = type;
}
get interestRate() {return this.<span class="pd_maroon1">_type</span>.interestRate;}</pre>
<h3 class="h3" id="ch08lev1sec3"><span epub:type="pagebreak" id="page_213"/>Move Statements into Function</h3>
<p class="noindent">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec4">Move Statements to Callers</a> (<a class="pd_maroon" href="ch08.xhtml#page_217">217</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0213_01.jpg" aria-describedby="alt_p0213_01" alt="A figure shows a simple representation and a code to move statements into a function."/>
<aside class="hidden" id="alt_p0213_01">
<p>A diagrammatic representation of moving statements into the function is shown at the top and the actual code reads, result.push(`&#60;p&#62;title: ${person.photo.title}&#60;/p&#62;`); result.concat(photoData(person.photo)); function photoData(aPhoto) { return [ `&#60;p&#62;location: ${aPhoto.location}&#60;/p&#62;`, `&#60;p&#62;date: ${aPhoto.date.toDateString()}&#60;/p&#62;`, ]; } The refactored code reads, result.concat(photoData(person.photo)); function photoData(aPhoto) { return [ `&#60;p&#62;title: ${aPhoto.title}&#60;/p&#62;`, `&#60;p&#62;location: ${aPhoto.location}&#60;/p&#62;`, `&#60;p&#62;date: ${aPhoto.date.toDateString()}&#60;/p&#62;`, ]; }</p>
</aside>
</figure>
<h4 class="h4" id="ch08lev2sec9">Motivation</h4>
<p class="noindent">Removing duplication is one of the best rules of thumb of healthy code. If I see the same code executed every time I call a particular function, I look to combine that repeating code into the function itself. That way, any future modifications to the repeating code can be done in one place and used by all the callers. Should the code vary in the future, I can easily move it (or some of it) out again with <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec4">Move Statements to Callers</a> (<a class="pd_maroon" href="ch08.xhtml#page_217">217</a>)</span></em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_214"/>I move statements into a function when I can best understand these statements as part of the called function. If they don&#8217;t make sense as part of the called function, but still should be called with it, I&#8217;ll simply use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the statements and the called function. That&#8217;s essentially the same process as I describe below, but without the inline and rename steps. It&#8217;s not unusual to do that and then, after later reflection, carry out those final steps.</p>
<h4 class="h4" id="ch08lev2sec10">Mechanics</h4>
<ul class="square">
<li><p>If the repetitive code isn&#8217;t adjacent to the call of the target function, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec6">Slide Statements</a> (<a class="pd_maroon" href="ch08.xhtml#page_223">223</a>)</span></em> to get it adjacent.</p></li>
<li><p>If the target function is only called by the source function, just cut the code from the source, paste it into the target, test, and ignore the rest of these mechanics.</p></li>
<li><p>If you have more callers, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on one of the call sites to extract both the call to the target function and the statements you wish to move into it. Give it a name that&#8217;s transient, but easy to grep.</p></li>
<li><p>Convert every other call to use the new function. Test after each conversion.</p></li>
<li><p>When all the original calls use the new function, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> to inline the original function completely into the new function, removing the original function.</p></li>
<li><p><em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Rename Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to change the name of the new function to the same name as the original function.</p>
<div class="blockquote">
<p class="noindent">Or to a better name, if there is one.</p>
</div></li>
</ul>
<h4 class="h4" id="ch08lev2sec11">Example</h4>
<p class="noindent">I&#8217;ll start with this code to emit HTML for data about a photo:</p>
<p class="codelink"><a id="p0214_01a" href="ch08_images.xhtml#p0214_01">Click here to view code image</a></p>
<pre class="pre">function renderPerson(outStream, person) {
  const result = [];
  result.push(`&lt;p&gt;${person.name}&lt;/p&gt;`);
  result.push(renderPhoto(person.photo));
  <span class="pd_maroon1">result.push(`&lt;p&gt;title: ${person.photo.title}&lt;/p&gt;`);</span>
  <span class="pd_maroon1">result.push(emitPhotoData(person.photo));</span>
  return result.join("\n");
}

<span epub:type="pagebreak" id="page_215"/>function photoDiv(p) {
  return [
    "&lt;div&gt;",
    <span class="pd_maroon1">`&lt;p&gt;title: ${p.title}&lt;/p&gt;`,</span>
    <span class="pd_maroon1">emitPhotoData(p),</span>
    "&lt;/div&gt;",
  ].join("\n");
}

function emitPhotoData(aPhoto) {
  const result = [];
  result.push(`&lt;p&gt;location: ${aPhoto.location}&lt;/p&gt;`);
  result.push(`&lt;p&gt;date: ${aPhoto.date.toDateString()}&lt;/p&gt;`);
  return result.join("\n");
}</pre>
<p class="indent">This code shows two calls to <code>emitPhotoData</code>, each preceded by a line of code that is semantically equivalent. I&#8217;d like to remove this duplication by moving the title printing into <code>emitPhotoData</code>. If I had just the one caller, I would just cut and paste the code, but the more callers I have, the more I&#8217;m inclined to use a safer procedure.</p>
<p class="indent">I begin by using <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on one of the callers. I&#8217;m extracting the statements I want to move into <code>emitPhotoData</code>, together with the call to <code>emitPhotoData</code> itself.</p>
<p class="codelink"><a id="p0215_01a" href="ch08_images.xhtml#p0215_01">Click here to view code image</a></p>
<pre class="pre">function photoDiv(p) {
  return [
    "&lt;div&gt;",
    <span class="pd_maroon1">zznew(p),</span>
    "&lt;/div&gt;",
  ].join("\n");
}

function <span class="pd_maroon1">zznew</span>(p) {
  return [
    `&lt;p&gt;title: ${p.title}&lt;/p&gt;`,
    emitPhotoData(p),
  ].join("\n");
}</pre>
<p class="indent">I can now look at the other callers of <code>emitPhotoData</code> and, one by one, replace the calls and the preceding statements with calls to the new function.</p>
<p class="codelink"><a id="p0215_02a" href="ch08_images.xhtml#p0215_02">Click here to view code image</a></p>
<pre class="pre">function renderPerson(outStream, person) {
  const result = [];
  result.push(`&lt;p&gt;${person.name}&lt;/p&gt;`);
  result.push(renderPhoto(person.photo));
  <span class="pd_maroon1">result.push(zznew(person.photo));</span>
  return result.join("\n");
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_216"/>Now that I&#8217;ve done all the callers, I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> on <code>emitPhotoData</code>:</p>
<p class="codelink"><a id="p0216_01a" href="ch08_images.xhtml#p0216_01">Click here to view code image</a></p>
<pre class="pre">function zznew(p) {
  return [
    `&lt;p&gt;title: ${p.title}&lt;/p&gt;`,
    <span class="pd_maroon1">`&lt;p&gt;location: ${p.location}&lt;/p&gt;`,</span>
    <span class="pd_maroon1">`&lt;p&gt;date: ${p.date.toDateString()}&lt;/p&gt;`,</span>
  ].join("\n");
}</pre>
<p class="noindent">and finish with <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Rename Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em>:</p>
<p class="codelink"><a id="p0216_02a" href="ch08_images.xhtml#p0216_02">Click here to view code image</a></p>
<pre class="pre">function renderPerson(outStream, person) {
  const result = [];
  result.push(`&lt;p&gt;${person.name}&lt;/p&gt;`);
  result.push(renderPhoto(person.photo));
  result.push(<span class="pd_maroon1">emitPhotoData</span>(person.photo));
  return result.join("\n");
}

function photoDiv(aPhoto) {
  return [
    "&lt;div&gt;",
    <span class="pd_maroon1">emitPhotoData</span>(aPhoto),
    "&lt;/div&gt;",
  ].join("\n");
}

function <span class="pd_maroon1">emitPhotoData</span>(aPhoto) {
  return [
    `&lt;p&gt;title: ${aPhoto.title}&lt;/p&gt;`,
    `&lt;p&gt;location: ${aPhoto.location}&lt;/p&gt;`,
    `&lt;p&gt;date: ${aPhoto.date.toDateString()}&lt;/p&gt;`,
  ].join("\n");
}</pre>
<div class="blockquote">
<p class="noindent">I also make the parameter names fit my convention while I&#8217;m at it.</p>
</div>
<h3 class="h3" id="ch08lev1sec4"><span epub:type="pagebreak" id="page_217"/>Move Statements to Callers</h3>
<p class="noindent">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec3">Move Statements into Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_213">213</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0217_01.jpg" aria-describedby="alt_p0217_01" alt="A figure shows a simple representation and a code to move statements to the callers."/>
<aside class="hidden" id="alt_p0217_01">
<p>A diagrammatic representation for moving statements to the callers is shown at the top, and the actual code reads, emitPhotoData(outStream, person.photo); function emitPhotoData(outStream, photo) { outStream.write(`&#60;p&#62;title: ${photo.title}&#60;/p&#62;\n`); outStream.write(`&#60;p&#62;location: ${photo.location}&#60;/p&#62;\n`); } The refactored code reads, emitPhotoData(outStream, person.photo); outStream.write(`&#60;p&#62;location: ${person.photo.location}&#60;/p&#62;\n`); function emitPhotoData(outStream, photo) { outStream.write(`&#60;p&#62;title: ${photo.title}&#60;/p&#62;\n`); }</p>
</aside>
</figure>
<h4 class="h4" id="ch08lev2sec12">Motivation</h4>
<p class="noindent">Functions are the basic building block of the abstractions we build as programmers. And, as with any abstraction, we don&#8217;t always get the boundaries right. As a code base changes its capabilities&#8212;as most useful software does&#8212;we often find our abstraction boundaries shift. For functions, that means that what might once have been a cohesive, atomic unit of behavior becomes a mix of two or more different things.</p>
<p class="indent">One trigger for this is when common behavior used in several places needs to vary in some of its calls. Now, we need to move the varying behavior out of the function to its callers. In this case, I&#8217;ll use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec6">Slide Statements</a> (<a class="pd_maroon" href="ch08.xhtml#page_223">223</a>)</span></em> to get the varying behavior to the beginning or end of the function and then Move Statements to Callers. Once the varying code is in the caller, I can change it when necessary.</p>
<p class="indent"><span epub:type="pagebreak" id="page_218"/>Move Statements to Callers works well for small changes, but sometimes the boundaries between caller and callee need complete reworking. In that case, my best move is to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> and then slide and extract new functions to form better boundaries.</p>
<h4 class="h4" id="ch08lev2sec13">Mechanics</h4>
<ul class="square">
<li><p>In simple circumstances, where you have only one or two callers and a simple function to call from, just cut the first line from the called function and paste (and perhaps fit) it into the callers. Test and you&#8217;re done.</p></li>
<li><p>Otherwise, apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> to all the statements that you <em>don&#8217;t</em> wish to move; give it a temporary but easily searchable name.</p>
<div class="blockquote">
<p class="noindent">If the function is a method that is overridden by subclasses, do the extraction on all of them so that the remaining method is identical in all classes. Then remove the subclass methods.</p>
</div></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> on the original function.</p></li>
<li><p>Apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> on the extracted function to rename it to the original name.</p>
<div class="blockquote">
<p class="noindent">Or to a better name, if you can think of one.</p>
</div></li>
</ul>
<h4 class="h4" id="ch08lev2sec14">Example</h4>
<p class="noindent">Here&#8217;s a simple case: a function with two callers.</p>
<p class="codelink"><a id="p0218_01a" href="ch08_images.xhtml#p0218_01">Click here to view code image</a></p>
<pre class="pre">function renderPerson(outStream, person) {
  outStream.write(`&lt;p&gt;${person.name}&lt;/p&gt;\n`);
  renderPhoto(outStream, person.photo);
  <span class="pd_maroon1">emitPhotoData</span>(outStream, person.photo);
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p =&gt; p.date &gt; recentDateCutoff())
    .forEach(p =&gt; {
      outStream.write("&lt;div&gt;\n");
      <span class="pd_maroon1">emitPhotoData</span>(outStream, p);
      outStream.write("&lt;/div&gt;\n");
    });
}

function <span class="pd_maroon1">emitPhotoData</span>(outStream, photo) {
  outStream.write(`&lt;p&gt;title: ${photo.title}&lt;/p&gt;\n`);
  outStream.write(`&lt;p&gt;date: ${photo.date.toDateString()}&lt;/p&gt;\n`);
  outStream.write(`&lt;p&gt;location: ${photo.location}&lt;/p&gt;\n`);
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_219"/>I need to modify the software so that <code>listRecentPhotos</code> renders the location information differently while <code>renderPerson</code> stays the same. To make this change easier, I&#8217;ll use Move Statements to Callers on the final line.</p>
<p class="indent">Usually, when faced with something this simple, I&#8217;ll just cut the last line from <code>renderPerson</code> and paste it below the two calls. But since I&#8217;m explaining what to do in more tricky cases, I&#8217;ll go through the more elaborate but safer procedure.</p>
<p class="indent">My first step is to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the code that will remain in <code>emitPhotoData</code>.</p>
<p class="codelink"><a id="p0219_01a" href="ch08_images.xhtml#p0219_01">Click here to view code image</a></p>
<pre class="pre">function renderPerson(outStream, person) {
  outStream.write(`&lt;p&gt;${person.name}&lt;/p&gt;\n`);
  renderPhoto(outStream, person.photo);
  emitPhotoData(outStream, person.photo);
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p =&gt; p.date &gt; recentDateCutoff())
    .forEach(p =&gt; {
      outStream.write("&lt;div&gt;\n");
      emitPhotoData(outStream, p);
      outStream.write("&lt;/div&gt;\n");
    });
}

function emitPhotoData(outStream, photo) {
  <span class="pd_maroon1">zztmp(outStream, photo);</span>
  outStream.write(`&lt;p&gt;location: ${photo.location}&lt;/p&gt;\n`);
}

function <span class="pd_maroon1">zztmp</span>(outStream, photo) {
  outStream.write(`&lt;p&gt;title: ${photo.title}&lt;/p&gt;\n`);
  outStream.write(`&lt;p&gt;date: ${photo.date.toDateString()}&lt;/p&gt;\n`);
}</pre>
<p class="indent">Usually, the name of the extracted function is only temporary, so I don&#8217;t worry about coming up with anything meaningful. However, it is helpful to use something that&#8217;s easy to grep. I can test at this point to ensure the code works over the function call boundary.</p>
<p class="indent">Now I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em>, one call at a time. I start with <code>renderPerson</code>.</p>
<p class="codelink"><a id="p0219_02a" href="ch08_images.xhtml#p0219_02">Click here to view code image</a></p>
<pre class="pre">function renderPerson(outStream, person) {
  outStream.write(`&lt;p&gt;${person.name}&lt;/p&gt;\n`);
  renderPhoto(outStream, person.photo);
  <span class="pd_maroon1">zztmp(outStream, person.photo);</span>
  <span class="pd_maroon1">outStream.write(`&lt;p&gt;location: ${person.photo.location}&lt;/p&gt;\n`);</span>
}

<span epub:type="pagebreak" id="page_220"/>function listRecentPhotos(outStream, photos) {
  photos
    .filter(p =&gt; p.date &gt; recentDateCutoff())
    .forEach(p =&gt; {
      outStream.write("&lt;div&gt;\n");
      emitPhotoData(outStream, p);
      outStream.write("&lt;/div&gt;\n");
    });
}

function emitPhotoData(outStream, photo) {
  zztmp(outStream, photo);
  outStream.write(`&lt;p&gt;location: ${photo.location}&lt;/p&gt;\n`);
}

function zztmp(outStream, photo) {
  outStream.write(`&lt;p&gt;title: ${photo.title}&lt;/p&gt;\n`);
  outStream.write(`&lt;p&gt;date: ${photo.date.toDateString()}&lt;/p&gt;\n`);
}</pre>
<p class="indent">I test again to ensure this call is working properly, then move onto the next.</p>
<p class="codelink"><a id="p0220_01a" href="ch08_images.xhtml#p0220_01">Click here to view code image</a></p>
<pre class="pre">function renderPerson(outStream, person) {
  outStream.write(`&lt;p&gt;${person.name}&lt;/p&gt;\n`);
  renderPhoto(outStream, person.photo);
  zztmp(outStream, person.photo);
  outStream.write(`&lt;p&gt;location: ${person.photo.location}&lt;/p&gt;\n`);
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p =&gt; p.date &gt; recentDateCutoff())
    .forEach(p =&gt; {
      outStream.write("&lt;div&gt;\n");
      <span class="pd_maroon1">zztmp(outStream, p);</span>
      <span class="pd_maroon1">outStream.write(`&lt;p&gt;location: ${p.location}&lt;/p&gt;\n`);</span>
      outStream.write("&lt;/div&gt;\n");
    });
}

function emitPhotoData(outStream, photo) {
  zztmp(outStream, photo);
  outStream.write(`&lt;p&gt;location: ${photo.location}&lt;/p&gt;\n`);
}

function zztmp(outStream, photo) {
  outStream.write(`&lt;p&gt;title: ${photo.title}&lt;/p&gt;\n`);
  outStream.write(`&lt;p&gt;date: ${photo.date.toDateString()}&lt;/p&gt;\n`);
}</pre>
<p class="indent">Then I can delete the outer function, completing <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em>.</p>
<p class="codelink"><a id="p0221_01a" href="ch08_images.xhtml#p0221_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_221"/>function renderPerson(outStream, person) {
  outStream.write(`&lt;p&gt;${person.name}&lt;/p&gt;\n`);
  renderPhoto(outStream, person.photo);
  zztmp(outStream, person.photo);
  outStream.write(`&lt;p&gt;location: ${person.photo.location}&lt;/p&gt;\n`);
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p =&gt; p.date &gt; recentDateCutoff())
    .forEach(p =&gt; {
      outStream.write("&lt;div&gt;\n");
      zztmp(outStream, p);
      outStream.write(`&lt;p&gt;location: ${p.location}&lt;/p&gt;\n`);
      outStream.write("&lt;/div&gt;\n");
    });
}

<span class="strike"><span class="pd_maroon1">function emitPhotoData(outStream, photo) {</span></span>
  <span class="strike"><span class="pd_maroon1">zztmp(outStream, photo);</span></span>
  <span class="strike"><span class="pd_maroon1">outStream.write(`&lt;p&gt;location: ${photo.location}&lt;/p&gt;\n`);</span></span>
<span class="strike"><span class="pd_maroon1">}</span></span>

function zztmp(outStream, photo) {
  outStream.write(`&lt;p&gt;title: ${photo.title}&lt;/p&gt;\n`);
  outStream.write(`&lt;p&gt;date: ${photo.date.toDateString()}&lt;/p&gt;\n`);
}</pre>
<p class="indent">I then rename <code>zztmp</code> back to the original name.</p>
<p class="codelink"><a id="p0221_02a" href="ch08_images.xhtml#p0221_02">Click here to view code image</a></p>
<pre class="pre">function renderPerson(outStream, person) {
  outStream.write(`&lt;p&gt;${person.name}&lt;/p&gt;\n`);
  renderPhoto(outStream, person.photo);
  <span class="pd_maroon1">emitPhotoData</span>(outStream, person.photo);
  outStream.write(`&lt;p&gt;location: ${person.photo.location}&lt;/p&gt;\n`);
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p =&gt; p.date &gt; recentDateCutoff())
    .forEach(p =&gt; {
      outStream.write("&lt;div&gt;\n");
      <span class="pd_maroon1">emitPhotoData</span>(outStream, p);
      outStream.write(`&lt;p&gt;location: ${p.location}&lt;/p&gt;\n`);
      outStream.write("&lt;/div&gt;\n");
    });
}

function <span class="pd_maroon1">emitPhotoData</span>(outStream, photo) {
  outStream.write(`&lt;p&gt;title: ${photo.title}&lt;/p&gt;\n`);
  outStream.write(`&lt;p&gt;date: ${photo.date.toDateString()}&lt;/p&gt;\n`);
}</pre>
<h3 class="h3" id="ch08lev1sec5"><span epub:type="pagebreak" id="page_222"/>Replace Inline Code with Function Call</h3>
<figure class="fig-group">
<img src="graphics/p0222_01.jpg" aria-describedby="alt_p0222_01" alt="A figure shows a simple representation and a code to replace the inline code with a function call."/>
<aside class="hidden" id="alt_p0222_01">
<p>A diagrammatic representation for replacing the inline code with a function call is shown at the top, and the actual code reads, let appliesToMass = false; for(const s of states) { if (s === &#34;MA&#34;) appliesToMass = true; } The refactored code reads, appliesToMass = states.includes(&#34;MA&#34;);</p>
</aside>
</figure>
<h4 class="h4" id="ch08lev2sec15">Motivation</h4>
<p class="noindent">Functions allow me to package up bits of behavior. This is useful for understanding&#8212;a named function can explain the purpose of the code rather than its mechanics. It&#8217;s also valuable to remove duplication: Instead of writing the same code twice, I just call the function. Then, should I need to change the function&#8217;s implementation, I don&#8217;t have to track down similar-looking code to update all the changes. (I may have to look at the callers, to see if they should all use the new code, but that&#8217;s both less common and much easier.)</p>
<p class="indent">If I see inline code that&#8217;s doing the same thing that I have in an existing function, I&#8217;ll usually want to replace that inline code with a function call. The exception is if I consider the similarity to be coincidental&#8212;so that, if I change the function body, I don&#8217;t expect the behavior in this inline code to change. A guide to this is the name of the function. A good name should make sense in place of inline code I have. If the name doesn&#8217;t make sense, that may be because it&#8217;s a poor name (in which case I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Rename Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to fix it) or because the function&#8217;s purpose is different to what I want in this case&#8212;so I shouldn&#8217;t call it.</p>
<p class="indent">I find it particularly satisfying to do this with calls to library functions&#8212;that way, I don&#8217;t even have to write the function body.</p>
<h4 class="h4" id="ch08lev2sec16">Mechanics</h4>
<ul class="square">
<li><p>Replace the inline code with a call to the existing function.</p></li>
<li><p>Test.</p></li>
</ul>
<h3 class="h3" id="ch08lev1sec6"><span epub:type="pagebreak" id="page_223"/>Slide Statements</h3>
<p class="noindent">formerly: <em>Consolidate Duplicate Conditional Fragments</em></p>
<figure class="fig-group">
<img src="graphics/p0223_01.jpg" aria-describedby="alt_p0223_01" alt="A figure shows a simple representation and a code for slide statements."/>
<aside class="hidden" id="alt_p0223_01">
<p>A diagrammatic representation of slide statements is shown at the top, and the actual code reads, const pricingPlan = retrievePricingPlan(); const order = retreiveOrder(); let charge; const chargePerUnit = pricingPlan.unit; The refactored code reads, const pricingPlan = retrievePricingPlan(); const chargePerUnit = pricingPlan.unit; const order = retreiveOrder(); let charge;</p>
</aside>
</figure>
<h4 class="h4" id="ch08lev2sec17">Motivation</h4>
<p class="noindent">Code is easier to understand when things that are related to each other appear together. If several lines of code access the same data structure, it&#8217;s best for them to be together rather than intermingled with code accessing other data structures. At its simplest, I use Slide Statements to keep such code together. A very common case of this is declaring and using variables. Some people like to declare all their variables at the top of a function. I prefer to declare the variable just before I first use it.</p>
<p class="indent">Usually, I move related code together as a preparatory step for another refactoring, often an <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em>. Putting related code into a clearly separated function is a better separation than just moving a set of lines together, but I can&#8217;t do the <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> unless the code is together in the first place.</p>
<h4 class="h4" id="ch08lev2sec18">Mechanics</h4>
<ul class="square">
<li><p>Identify the target position to move the fragment to. Examine statements between source and target to see if there is interference for the candidate fragment. Abandon action if there is any interference.</p>
<div class="blockquote">
<p class="noindent">A fragment cannot slide backwards earlier than any element it references is declared.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_224"/>A fragment cannot slide forwards beyond any element that references it.</p>
<p class="noindent">A fragment cannot slide over any statement that modifies an element it references.</p>
<p class="noindent">A fragment that modifies an element cannot slide over any other element that references the modified element.</p>
</div></li>
<li><p>Cut the fragment from the source and paste into the target position.</p></li>
<li><p>Test.</p></li>
</ul>
<p class="indent">If the test fails, try breaking down the slide into smaller steps. Either slide over less code or reduce the amount of code in the fragment you&#8217;re moving.</p>
<h4 class="h4" id="ch08lev2sec19">Example</h4>
<p class="noindent">When sliding code fragments, there are two decisions involved: what slide I&#8217;d like to do and whether I can do it. The first decision is very context-specific. On the simplest level, I like to declare elements close to where I use them, so I&#8217;ll often slide a declaration down to its usage. But almost always I slide some code because I want to do another refactoring&#8212;perhaps to get a clump of code together to <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em>.</p>
<p class="indent">Once I have a sense of where I&#8217;d like to move some code, the next part is deciding if I can do it. This involves looking at the code I&#8217;m sliding and the code I&#8217;m sliding over: Do they interfere with each other in a way that would change the observable behavior of the program?</p>
<p class="indent">Consider the following fragment of code:</p>
<p class="codelink"><a id="p0224_01a" href="ch08_images.xhtml#p0224_01">Click here to view code image</a></p>
<pre class="pre"> 1 const pricingPlan = retrievePricingPlan();
 2 const order = retreiveOrder();
 3 const baseCharge = pricingPlan.base;
 4 let charge;
 5 const chargePerUnit = pricingPlan.unit;
 6 const units = order.units;
 7 let discount;
 8 charge = baseCharge + units * chargePerUnit;
 9 let discountableUnits = Math.max(units - pricingPlan.discountThreshold, 0);
10 discount = discountableUnits * pricingPlan.discountFactor;
11 if (order.isRepeat) discount += 20;
12 charge = charge - discount;
13 chargeOrder(charge);</pre>
<p class="indent">The first seven lines are declarations, and it&#8217;s relatively easy to move these. For example, I may want to move all the code dealing with discounts together, which would involve moving line 7 (<code>`let discount`</code>) to above line 10 (<code>`discount = ...`</code>). Since a declaration has no side effects and refers to no other variable, I can safely move this forwards as far as the first line that references <code>discount</code> itself. This is also a common move&#8212;if I want to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the discount logic, I&#8217;ll need to move the declaration down first.</p>
<p class="indent"><span epub:type="pagebreak" id="page_225"/>I do similar analysis with any code that doesn&#8217;t have side effects. So I can take line 2 (<code>`const order = ...`</code>) and move it down to above line 6 (<code>`const units = ...`</code>) without trouble.</p>
<p class="indent">In this case, I&#8217;m also helped by the fact that the code I&#8217;m moving over doesn&#8217;t have side effects either. Indeed, I can freely rearrange code that lacks side effects to my heart&#8217;s content, which is one of the reasons why wise programmers prefer to use side-effect-free code as much as possible.</p>
<p class="indent">There is a wrinkle here, however. How do I know that line 2 is side-effect-free? To be sure, I&#8217;d need to look inside <code>retrieveOrder()</code> to ensure there are no side effects there (and inside any functions it calls, and inside any functions its functions call, and so on). In practice, when working on my own code, I know that I generally follow the Command-Query Separation [<a href="biblo.xhtml#bib20">mf-cqs</a>] principle, so any function that returns a value is free of side effects. But I can only be confident of that because I know the code base; if I were working in an unknown code base, I&#8217;d have to be more cautious. But I do try to follow the Command-Query Separation in my own code because it&#8217;s so valuable to know that code is free of side effects.</p>
<p class="indent">When sliding code that has a side effect, or sliding over code with side effects, I have to be much more careful. What I&#8217;m looking for is interference between the two code fragments. So, let&#8217;s say I want to slide line 11 (<code>`if (order.isRepeat) ...`</code>) down to the end. I&#8217;m prevented from doing that by line 12 because it references the variable whose state I&#8217;m changing in line 11. Similarly, I can&#8217;t take line 13 (<code>`chargeOrder(charge)`</code>) and move it up because line 12 modifies some state that line 13 references. However, I can slide line 8 (<code>`charge = baseCharge + ...`</code>) over lines 9&#8211;11 because there they don&#8217;t modify any common state.</p>
<p class="indent">The most straightforward rule to follow is that I can&#8217;t slide one fragment of code over another if any data that both fragments refer to is modified by either one. But that&#8217;s not a comprehensive rule; I can happily slide either of the following two lines over the other:</p>
<pre class="pre">a = a + 10;
a = a + 5;</pre>
<p class="indent">But judging whether a slide is safe means I have to really understand the operations involved and how they compose.</p>
<p class="indent">Since I need to worry so much about updating state, I look to remove as much of it as I can. So with this code, I&#8217;d be looking to apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch09.xhtml#ch09lev1sec1">Split Variable</a> (<a class="pd_maroon" href="ch09.xhtml#page_240">240</a>)</span></em> on <code>charge</code> before I indulge in any sliding around of that code.</p>
<p class="indent">Here, the analysis is relatively simple because I&#8217;m mostly just modifying local variables. With more complex data structures, it&#8217;s much harder to be sure when I get interference. So tests play an important role: Slide the fragment, run tests, see if things break. If my test coverage is good, I can feel happy with the refactoring. But if tests aren&#8217;t reliable, I need to be more wary&#8212;or, more likely, to improve the tests for the code I&#8217;m working on.</p>
<p class="indent"><span epub:type="pagebreak" id="page_226"/>The most important consequence of a test failure after a slide is to use smaller slides: Instead of sliding over ten lines, I&#8217;ll just pick five, or slide up to what I reckon is a dangerous line. It may also mean that the slide isn&#8217;t worth it, and I need to work on something else first.</p>
<h4 class="h4" id="ch08lev2sec20">Example: Sliding with Conditionals</h4>
<p class="noindent">I can also do slides with conditionals. This will either involve removing duplicate logic when I slide out of a conditional, or adding duplicate logic when I slide in.</p>
<p class="indent">Here&#8217;s a case where I have the same statements in both legs of a conditional:</p>
<p class="codelink"><a id="p0226_01a" href="ch08_images.xhtml#p0226_01">Click here to view code image</a></p>
<pre class="pre">let result;
if (availableResources.length === 0) {
  result = createResource();
  <span class="pd_maroon1">allocatedResources.push(result);</span>
} else {
  result = availableResources.pop();
  <span class="pd_maroon1">allocatedResources.push(result);</span>
}
return result;</pre>
<p class="indent">I can slide these out of the conditional, in which case they turn into a single statement outside of the conditional block.</p>
<p class="codelink"><a id="p0226_02a" href="ch08_images.xhtml#p0226_02">Click here to view code image</a></p>
<pre class="pre">let result;
if (availableResources.length === 0) {
  result = createResource();
} else {
  result = availableResources.pop();
}
<span class="pd_maroon1">allocatedResources.push(result);</span>
return result;</pre>
<p class="indent">In the reverse case, sliding a fragment into a conditional means repeating it in every leg of the conditional.</p>
<h4 class="h4" id="ch08lev2sec21">Further Reading</h4>
<p class="noindent">I&#8217;ve seen an almost identical refactoring under the name of Swap Statement <span class="pd_maroon">[<a href="biblo.xhtml#bib48">wake-swap</a>]</span>. Swap Statement moves adjacent fragments, but it only works with single-statement fragments. You can think of it as Slide Statements where both the sliding fragment and the slid-over fragment are single statements. This refactoring appeals to me; after all, I&#8217;m always going on about taking small steps&#8212;steps that may seem ridiculously small to those new to refactoring.</p>
<p class="indent">But I ended up writing this refactoring with larger fragments because that is what I do. I only move one statement at a time if I&#8217;m having difficulty with a larger slide, and I rarely run into problems with larger slides. With more messy code, however, smaller slides end up being easier.</p>
<h3 class="h3" id="ch08lev1sec7"><span epub:type="pagebreak" id="page_227"/>Split Loop</h3>
<figure class="fig-group">
<img src="graphics/p0227_01.jpg" aria-describedby="alt_p0227_01" alt="A figure shows a simple representation and a code for splitting a loop."/>
<aside class="hidden" id="alt_p0227_01">
<p>A diagrammatic representation of splitting a loop is shown at the top and the actual code reads, let averageAge = 0; let totalSalary = 0; for (const p of people) { averageAge += p.age; totalSalary += p.salary; } averageAge = averageAge / people.length; The refactored code reads, let totalSalary = 0; for (const p of people) { totalSalary += p.salary; } let averageAge = 0; for (const p of people) { averageAge += p.age; } averageAge = averageAge / people.length;</p>
</aside>
</figure>
<h4 class="h4" id="ch08lev2sec22">Motivation</h4>
<p class="noindent">You often see loops that are doing two different things at once just because they can do that with one pass through a loop. But if you&#8217;re doing two different things in the same loop, then whenever you need to modify the loop you have <span epub:type="pagebreak" id="page_228"/>to understand both things. By splitting the loop, you ensure you only need to understand the behavior you need to modify.</p>
<p class="indent">Splitting a loop can also make it easier to use. A loop that calculates a single value can just return that value. Loops that do many things need to return structures or populate local variables. I frequently follow a sequence of Split Loop followed by <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em>.</p>
<p class="indent">Many programmers are uncomfortable with this refactoring, as it forces you to execute the loop twice. My reminder, as usual, is to separate refactoring from optimization (<em><span class="pd_maroon"><a class="pd_maroon" href="ch02.xhtml#ch02lev1sec8">Refactoring and Performance</a> (<a class="pd_maroon" href="ch02.xhtml#page_64">64</a>)</span></em>). Once I have my code clear, I&#8217;ll optimize it, and if the loop traversal is a bottleneck, it&#8217;s easy to slam the loops back together. But the actual iteration through even a large list is rarely a bottleneck, and splitting the loops often enables other, more powerful, optimizations.</p>
<h4 class="h4" id="ch08lev2sec23">Mechanics</h4>
<ul class="square">
<li><p>Copy the loop.</p></li>
<li><p>Identify and eliminate duplicate side effects.</p></li>
<li><p>Test.</p></li>
</ul>
<p class="indent">When done, consider <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on each loop.</p>
<h4 class="h4" id="ch08lev2sec24">Example</h4>
<p class="noindent">I&#8217;ll start with a little bit of code that calculates the total salary and youngest age.</p>
<p class="codelink"><a id="p0228_01a" href="ch08_images.xhtml#p0228_01">Click here to view code image</a></p>
<pre class="pre">let youngest = people[0] ? people[0].age : Infinity;
let totalSalary = 0;
for (const p of people) {
  if (p.age &lt; youngest) youngest = p.age;
  totalSalary += p.salary;
}

return `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;</pre>
<p class="indent">It&#8217;s a very simple loop, but it&#8217;s doing two different calculations. To split them, I begin with just copying the loop.</p>
<p class="codelink"><a id="p0228_02a" href="ch08_images.xhtml#p0228_02">Click here to view code image</a></p>
<pre class="pre">let youngest = people[0] ? people[0].age : Infinity;
let totalSalary = 0;
for (const p of people) {
  if (p.age &lt; youngest) youngest = p.age;
  totalSalary += p.salary;
}

<span epub:type="pagebreak" id="page_229"/><span class="pd_maroon1">for (const p of people) {</span>
  <span class="pd_maroon1">if (p.age &lt; youngest) youngest = p.age;</span>
  <span class="pd_maroon1">totalSalary += p.salary;</span>
<span class="pd_maroon1">}</span>

return `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;</pre>
<p class="indent">With the loop copied, I need to remove the duplication that would otherwise produce wrong results. If something in the loop has no side effects, I can leave it there for now, but it&#8217;s not the case with this example.</p>
<p class="codelink"><a id="p0229_01a" href="ch08_images.xhtml#p0229_01">Click here to view code image</a></p>
<pre class="pre">let youngest = people[0] ? people[0].age : Infinity;
let totalSalary = 0;
for (const p of people) {
  <span class="strike"><span class="pd_maroon1">if (p.age &lt; youngest) youngest = p.age;</span></span>
  totalSalary += p.salary;
}

for (const p of people) {
  if (p.age &lt; youngest) youngest = p.age;
  <span class="strike"><span class="pd_maroon1">totalSalary += p.salary;</span></span>
}

return `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;</pre>
<p class="indent">Officially, that&#8217;s the end of the Split Loop refactoring. But the point of Split Loop isn&#8217;t what it does on its own but what it sets up for the next move&#8212;and I&#8217;m usually looking to extract the loops into their own functions. I&#8217;ll use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec6">Slide Statements</a> (<a class="pd_maroon" href="ch08.xhtml#page_223">223</a>)</span></em> to reorganize the code a bit first.</p>
<p class="codelink"><a id="p0229_02a" href="ch08_images.xhtml#p0229_02">Click here to view code image</a></p>
<pre class="pre">let totalSalary = 0;
for (const p of people) {
  totalSalary += p.salary;
}

<span class="pd_maroon1">let youngest = people[0] ? people[0].age : Infinity;</span>
for (const p of people) {
  if (p.age &lt; youngest) youngest = p.age;
}

return `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;</pre>
<p class="indent">Then I do a couple of <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em>.</p>
<p class="codelink"><a id="p0230_01a" href="ch08_images.xhtml#p0230_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_230"/>return `youngestAge: ${<span class="pd_maroon1">youngestAge()</span>}, totalSalary: ${<span class="pd_maroon1">totalSalary()</span>}`;

<span class="pd_maroon1">function totalSalary() {</span>
  let totalSalary = 0;
  for (const p of people) {
    totalSalary += p.salary;
  }
  <span class="pd_maroon1">return totalSalary;</span>
}

<span class="pd_maroon1">function youngestAge() {</span>
  let youngest = people[0] ? people[0].age : Infinity;
  for (const p of people) {
    if (p.age &lt; youngest) youngest = p.age;
  }
  <span class="pd_maroon1">return youngest;</span>
}</pre>
<p class="indent">I can rarely resist <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec8">Replace Loop with Pipeline</a> (<a class="pd_maroon" href="ch08.xhtml#page_231">231</a>)</span></em> for the total salary, and there&#8217;s an obvious <em><span class="pd_maroon"><a class="pd_maroon" href="ch07.xhtml#ch07lev1sec9">Substitute Algorithm</a> (<a class="pd_maroon" href="ch07.xhtml#page_195">195</a>)</span></em> for the youngest age.</p>
<p class="codelink"><a id="p0230_02a" href="ch08_images.xhtml#p0230_02">Click here to view code image</a></p>
<pre class="pre">return `youngestAge: ${youngestAge()}, totalSalary: ${totalSalary()}`;

function totalSalary() {
  <span class="pd_maroon1">return people.reduce((total,p) =&gt; total + p.salary, 0);</span>
}
function youngestAge() {
  <span class="pd_maroon1">return Math.min(...people.map(p =&gt; p.age));</span>
}</pre>
<h3 class="h3" id="ch08lev1sec8"><span epub:type="pagebreak" id="page_231"/>Replace Loop with Pipeline</h3>
<figure class="fig-group">
<img src="graphics/p0231_01.jpg" aria-describedby="alt_p0231_01" alt="A figure shows a simple representation and a code to replace a loop with a pipeline."/>
<aside class="hidden" id="alt_p0231_01">
<p>A diagrammatic representation for replacing a loop with a pipeline is shown at the top, and the actual code reads, const names = []; for (const i of input) { if (i.job === &#34;programmer&#34;) names.push(i.name); } The refactored code reads, const names = input .filter(i =&#62; i.job === &#34;programmer&#34;) .map(i =&#62; i.name) ;</p>
</aside>
</figure>
<h4 class="h4" id="ch08lev2sec25">Motivation</h4>
<p class="noindent">Like most programmers, I was taught to use loops to iterate over a collection of objects. Increasingly, however, language environments provide a better construct: the collection pipeline. Collection Pipelines <span class="pd_maroon">[<a href="biblo.xhtml#bib19">mf-cp</a>]</span> allow me to describe my processing as a series of operations, each consuming and emitting a collection. The most common of these operations are <em>map</em>, which uses a function to transform each element of the input collection, and <em>filter</em> which uses a function to select a subset of the input collection for later steps in the pipeline. I find logic much easier to follow if it is expressed as a pipeline&#8212;I can then read from top to bottom to see how objects flow through the pipeline.</p>
<h4 class="h4" id="ch08lev2sec26">Mechanics</h4>
<ul class="square">
<li><p>Create a new variable for the loop&#8217;s collection.</p>
<div class="blockquote">
<p class="noindent">This may be a simple copy of an existing variable.</p>
</div></li>
<li><p><span epub:type="pagebreak" id="page_232"/>Starting at the top, take each bit of behavior in the loop and replace it with a collection pipeline operation in the derivation of the loop collection variable. Test after each change.</p></li>
<li><p>Once all behavior is removed from the loop, remove it.</p>
<div class="blockquote">
<p class="noindent">If it assigns to an accumulator, assign the pipeline result to the accumulator.</p>
</div></li>
</ul>
<h4 class="h4" id="ch08lev2sec27">Example</h4>
<p class="noindent">I&#8217;ll begin with some data: a CSV file of data about our offices.</p>
<p class="codelink"><a id="p0232_01a" href="ch08_images.xhtml#p0232_01">Click here to view code image</a></p>
<pre class="pre">office, country, telephone
Chicago, USA, +1 312 373 1000
Beijing, China, +86 4008 900 505
Bangalore, India, +91 80 4064 9570
Porto Alegre, Brazil, +55 51 3079 3550
Chennai, India, +91 44 660 44766

... (more data follows)</pre>
<p class="indent">The following function picks out the offices in India and returns their cities and telephone numbers:</p>
<p class="codelink"><a id="p0232_02a" href="ch08_images.xhtml#p0232_02">Click here to view code image</a></p>
<pre class="pre">function acquireData(input) {
  const lines = input.split("\n");
  let firstLine = true;
  const result = [];
  for (const line of lines) {
    if (firstLine) {
      firstLine = false;
      continue;
    }
    if (line.trim() === "") continue;
    const record = line.split(",");
    if (record[1].trim() === "India") {
      result.push({city: record[0].trim(), phone: record[2].trim()});
    }
  }
  return result;
}</pre>
<p class="indent">I want to replace that loop with a collection pipeline.</p>
<p class="indent">My first step is to create a separate variable for the loop to work over.</p>
<p class="codelink"><a id="p0233_01a" href="ch08_images.xhtml#p0233_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_233"/>function acquireData(input) {
  const lines = input.split("\n");
  let firstLine = true;
  const result = [];
  <span class="pd_maroon1">const loopItems = lines</span>
  for (const line of <span class="pd_maroon1">loopItems</span>) {
    if (firstLine) {
      firstLine = false;
      continue;
    }
    if (line.trim() === "") continue;
    const record = line.split(",");
    if (record[1].trim() === "India") {
      result.push({city: record[0].trim(), phone: record[2].trim()});
    }
  }
  return result;
}</pre>
<p class="indent">The first part of the loop is all about skipping the first line of the CSV file. This calls for a slice, so I remove that first section of the loop and add a slice operation to the formation of the loop variable.</p>
<p class="codelink"><a id="p0233_02a" href="ch08_images.xhtml#p0233_02">Click here to view code image</a></p>
<pre class="pre">function acquireData(input) {
  const lines = input.split("\n");
  <span class="strike"><span class="pd_maroon1">let firstLine = true;</span></span>
  const result = [];
  const loopItems = lines
        .<span class="pd_maroon1">slice(1)</span>;
  for (const line of loopItems) {
    <span class="strike"><span class="pd_maroon1">if (firstLine) {</span></span>
      <span class="strike"><span class="pd_maroon1">firstLine = false;</span></span>
      <span class="strike"><span class="pd_maroon1">continue;</span></span>
    <span class="strike"><span class="pd_maroon1">}</span></span>
    if (line.trim() === "") continue;
    const record = line.split(",");
    if (record[1].trim() === "India") {
      result.push({city: record[0].trim(), phone: record[2].trim()});
    }
  }
  return result;
}</pre>
<p class="indent">As a bonus, this lets me delete <code>firstLine</code>&#8212;and I particularly enjoy deleting control variables.</p>
<p class="indent"><span epub:type="pagebreak" id="page_234"/>The next bit of behavior removes any blank lines. I can replace this with a filter operation.</p>
<p class="codelink"><a id="p0234_01a" href="ch08_images.xhtml#p0234_01">Click here to view code image</a></p>
<pre class="pre">function acquireData(input) {
  const lines = input.split("\n");
  const result = [];
  const loopItems = lines
        .slice(1)
        <span class="pd_maroon1">.filter(line =&gt; line.trim() !== "")</span>
        ;
  for (const line of loopItems) {
    <span class="strike"><span class="pd_maroon1">if (line.trim() === "") continue;</span></span>
    const record = line.split(",");
    if (record[1].trim() === "India") {
      result.push({city: record[0].trim(), phone: record[2].trim()});
    }
  }
  return result;
}</pre>
<div class="blockquote">
<p class="noindent">When writing a pipeline, I find it best to put the terminal semicolon on its own line.</p>
</div>
<p class="indent">I use the map operation to turn lines into an array of strings&#8212;misleadingly called record in the original function, but it&#8217;s safer to keep the name for now and rename later.</p>
<p class="codelink"><a id="p0234_02a" href="ch08_images.xhtml#p0234_02">Click here to view code image</a></p>
<pre class="pre">function acquireData(input) {
  const lines = input.split("\n");
  const result = [];
  const loopItems = lines
        .slice(1)
        .filter(line =&gt; line.trim() !== "")
        <span class="pd_maroon1">.map(line =&gt; line.split(","))</span>
        ;
  for (const line of loopItems) {
    const record = line;<span class="strike"><span class="pd_maroon1">.split(",");</span></span>
    if (record[1].trim() === "India") {
      result.push({city: record[0].trim(), phone: record[2].trim()});
    }
  }
  return result;
}</pre>
<p class="indent">Filter again to just get the India records:</p>
<p class="codelink"><a id="p0235_01a" href="ch08_images.xhtml#p0235_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_235"/>function acquireData(input) {
  const lines = input.split("\n");
  const result = [];
  const loopItems = lines
        .slice(1)
        .filter(line =&gt; line.trim() !== "")
        .map(line =&gt; line.split(","))
        .filter(record =&gt; record[1].trim() === "India")
        ;
  for (const line of loopItems) {
    const record = line;
    <span class="strike"><span class="pd_maroon1">if (record[1].trim() === "India") {</span></span>
      result.push({city: record[0].trim(), phone: record[2].trim()});
    <span class="strike"><span class="pd_maroon1">}</span></span>
  }
  return result;
}</pre>
<p class="indent">Map to the output record form:</p>
<p class="codelink"><a id="p0235_02a" href="ch08_images.xhtml#p0235_02">Click here to view code image</a></p>
<pre class="pre">function acquireData(input) {
  const lines = input.split("\n");
  const result = [];
  const loopItems = lines
        .slice(1)
        .filter(line =&gt; line.trim() !== "")
        .map(line =&gt; line.split(","))
        .filter(record =&gt; record[1].trim() === "India")
        <span class="pd_maroon1">.map(record =&gt; ({city: record[0].trim(), phone: record[2].trim()}))</span>
        ;
  for (const line of loopItems) {
    const record = line;
    result.push(<span class="pd_maroon1">line</span>);
  }
  return result;
}</pre>
<p class="indent">Now, all the loop does is assign values to the accumulator. So I can remove it and assign the result of the pipeline to the accumulator:</p>
<p class="codelink"><a id="p0236_01a" href="ch08_images.xhtml#p0236_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_236"/>function acquireData(input) {
  const lines = input.split("\n");
  const <span class="pd_maroon1">result =</span> lines
        .slice(1)
        .filter(line =&gt; line.trim() !== "")
        .map(line =&gt; line.split(","))
        .filter(record =&gt; record[1].trim() === "India")
        .map(record =&gt; ({city: record[0].trim(), phone: record[2].trim()}))
        ;
  <span class="strike"><span class="pd_maroon1">for (const line of loopItems) {</span></span>
    <span class="strike"><span class="pd_maroon1">const record = line;</span></span>
    <span class="strike"><span class="pd_maroon1">result.push(line);</span></span>
  <span class="strike"><span class="pd_maroon1">}</span></span>
  return result;
}</pre>
<p class="indent">That&#8217;s the core of the refactoring. But I do have some cleanup I&#8217;d like to do. I inlined <code>result</code>, renamed some lambda variables, and made the layout read more like a table.</p>
<p class="codelink"><a id="p0236_02a" href="ch08_images.xhtml#p0236_02">Click here to view code image</a></p>
<pre class="pre">function acquireData(input) {
  const lines = input.split("\n");
  return lines
        .slice  (1)
        .filter (line   =&gt; line.trim() !== "")
        .map    (line   =&gt; line.split(","))
        .filter (fields =&gt; fields[1].trim() === "India")
        .map    (fields =&gt; ({city: fields[0].trim(), phone: fields[2].trim()}))
        ;
}</pre>
<p class="indent">I thought about inlining <code>lines</code> too, but felt that its presence explains what&#8217;s happening.</p>
<h4 class="h4" id="ch08lev2sec28">Further Reading</h4>
<p class="noindent">For more examples on turning loops into pipelines, see my essay &#8220;Refactoring with Loops and Collection Pipelines&#8221; <span class="pd_maroon">[<a href="biblo.xhtml#bib32">mf-ref-pipe</a>]</span>.</p>
<h3 class="h3" id="ch08lev1sec9"><span epub:type="pagebreak" id="page_237"/>Remove Dead Code</h3>
<figure class="fig-group">
<img src="graphics/p0237_01.jpg" aria-describedby="alt_p0237_01" alt="A figure illustrates how the refactoring technique is used to remove the dead code."/>
<aside class="hidden" id="alt_p0237_01">
<p>The diagrammatic representation shows the set of codes getting removed. The actual code that is removed is: if(false) { doSomethingThatUsedToMatter(); }</p>
</aside>
</figure>
<h4 class="h4" id="ch08lev2sec29">Motivation</h4>
<p class="noindent">When we put code into production, even on people&#8217;s devices, we aren&#8217;t charged by weight. A few unused lines of code don&#8217;t slow down our systems nor take up significant memory; indeed, decent compilers will instinctively remove them. But unused code is still a significant burden when trying to understand how the software works. It doesn&#8217;t carry any warning signs telling programmers that they can ignore this function as it&#8217;s never called any more, so they still have to spend time understanding what it&#8217;s doing and why changing it doesn&#8217;t seem to alter the output as they expected.</p>
<p class="indent">Once code isn&#8217;t used any more, we should delete it. I don&#8217;t worry that I may need it sometime in the future; should that happen, I have my version control system so I can always dig it out again. If it&#8217;s something I really think I may need one day, I might put a comment into the code that mentions the lost code and which revision it was removed in&#8212;but, honestly, I can&#8217;t remember the last time I did that, or regretted that I hadn&#8217;t done it.</p>
<p class="indent">Commenting out dead code was once a common habit. This was useful in the days before version control systems were widely used, or when they were inconvenient. Now, when I can put even the smallest code base under version control, that&#8217;s no longer needed.</p>
<h4 class="h4" id="ch08lev2sec30">Mechanics</h4>
<ul class="square">
<li><p>If the dead code can be referenced from outside, e.g., when it&#8217;s a full function, do a search to check for callers.</p></li>
<li><p>Remove the dead code.</p></li>
<li><p>Test.</p></li>
</ul>
</section>
</body>
</html>