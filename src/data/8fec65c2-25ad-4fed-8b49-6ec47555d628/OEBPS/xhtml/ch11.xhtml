<?xml version="1.0" encoding="UTF-8"?>
<html xml:lang="en-us" lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>Refactoring: Improving the Design of Existing Code</title>
<link rel="stylesheet" type="text/css" href="9780134757704.css"/>
</head>
<body>
<section epub:type="bodymatter">
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_305"/>Chapter 11<br/>Refactoring APIs</h2>
<p class="noindent">Modules and their functions are the building blocks of our software. APIs are the joints that we use to plug them together. Making these APIs easy to understand and use is important but also difficult: I need to refactor them as I learn how to improve them.</p>
<p class="indent">A good API clearly separates any functions that update data from those that only read data. If I see them combined, I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec1">Separate Query from Modifier</a> (<a class="pd_maroon" href="ch11.xhtml#page_306">306</a>)</span></em> to tease them apart. I can unify functions that only vary due to a value with <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec2">Parameterize Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_310">310</a>)</span></em>. Some parameters, however, are really just a signal of an entirely different behavior and are best excised with <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec3">Remove Flag Argument</a> (<a class="pd_maroon" href="ch11.xhtml#page_314">314</a>)</span></em>.</p>
<p class="indent">Data structures are often unpacked unnecessarily when passed between functions; I prefer to keep them together with <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec4">Preserve Whole Object</a> (<a class="pd_maroon" href="ch11.xhtml#page_319">319</a>)</span></em>. Decisions on what should be passed as a parameter, and what can be resolved by the called function, are ones I often need to revisit with <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec5">Replace Parameter with Query</a> (<a class="pd_maroon" href="ch11.xhtml#page_324">324</a>)</span></em> and <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec6">Replace Query with Parameter</a> (<a class="pd_maroon" href="ch11.xhtml#page_327">327</a>)</span></em>.</p>
<p class="indent">A class is a common form of module. I prefer my objects to be as immutable as possible, so I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec7">Remove Setting Method</a> (<a class="pd_maroon" href="ch11.xhtml#page_331">331</a>)</span></em> whenever I can. Often, when a caller asks for a new object, I need more flexibility than a simple constructor gives, which I can get by using <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec8">Replace Constructor with Factory Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_334">334</a>)</span></em>.</p>
<p class="indent">The last two refactorings address the difficulty of breaking down a particularly complex function that passes a lot of data around. I can turn that function into an object with <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec9">Replace Function with Command</a> (<a class="pd_maroon" href="ch11.xhtml#page_337">337</a>)</span></em>, which makes it easier to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the function&#8217;s body. If I later simplify the function and no longer need it as a command object, I turn it back into a function with <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec10">Replace Command with Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_344">344</a>)</span></em>.</p>
<h3 class="h3" id="ch11lev1sec1"><span epub:type="pagebreak" id="page_306"/>Separate Query from Modifier</h3>
<figure class="fig-group">
<img src="graphics/p0306_01.jpg" aria-describedby="alt_p0306_01" alt="A figure illustrates how the refactoring technique is used to separate the query from a modifier."/>
<aside class="hidden" id="alt_p0306_01">
<p>The diagrammatic representation shows the logic to separate functions, with and without side effects. The actual code reads, function getTotalOutstandingAndSendBill() { const result = customer.invoices.reduce((total, each) =&#62; each.amount + total, 0); sendBill(); return result; } The code after refactoring reads, function totalOutstanding() { return customer.invoices.reduce((total, each) =&#62; each.amount + total, 0); } function sendBill() { emailGateway.send(formatBill(customer)); }</p>
</aside>
</figure>
<h4 class="h4" id="ch11lev2sec1">Motivation</h4>
<p class="noindent">When I have a function that gives me a value and has no observable side effects, I have a very valuable thing. I can call this function as often as I like. I can move the call to other places in a calling function. It&#8217;s easier to test. In short, I have a lot less to worry about.</p>
<p class="indent">It is a good idea to clearly signal the difference between functions with side effects and those without. A good rule to follow is that any function that returns a value should not have observable side effects&#8212;the command-query separation <span class="pd_maroon">[<a href="biblo.xhtml#bib20">mf-cqs</a>]</span>. Some programmers treat this as an absolute rule. I&#8217;m not 100 percent pure on this (as on anything), but I try to follow it most of the time, and it has served me well.</p>
<p class="indent">If I come across a method that returns a value but also has side effects, I always try to separate the query from the modifier.</p>
<p class="indent"><span epub:type="pagebreak" id="page_307"/>Note that I use the phrase <em>observable</em> side effects. A common optimization is to cache the value of a query in a field so that repeated calls go quicker. Although this changes the state of the object with the cache, the change is not observable. Any sequence of queries will always return the same results for each query.</p>
<h4 class="h4" id="ch11lev2sec2">Mechanics</h4>
<ul class="square">
<li><p>Copy the function, name it as a query.</p>
<div class="blockquote">
<p class="noindent">Look into the function to see what is returned. If the query is used to populate a variable, the variable&#8217;s name should provide a good clue.</p>
</div></li>
<li><p>Remove any side effects from the new query function.</p></li>
<li><p>Run static checks.</p></li>
<li><p>Find each call of the original method. If that call uses the return value, replace the original call with a call to the query and insert a call to the original method below it. Test after each change.</p></li>
<li><p>Remove return values from original.</p></li>
<li><p>Test.</p></li>
</ul>
<p class="indent">Often after doing this there will be duplication between the query and the original method that can be tidied up.</p>
<h4 class="h4" id="ch11lev2sec3">Example</h4>
<p class="noindent">Here is a function that scans a list of names for a miscreant. If it finds one, it returns the name of the bad guy and sets off the alarms. It only does this for the first miscreant it finds (I guess one is enough).</p>
<p class="codelink"><a id="p0307_01a" href="ch11_images.xhtml#p0307_01">Click here to view code image</a></p>
<pre class="pre">function alertForMiscreant (people) {
  for (const p of people) {
    if (p === "Don") {
      setOffAlarms();
      return "Don";
    }
    if (p === "John") {
      setOffAlarms();
      return "John";
    }
  }
  return "";
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_308"/>I begin by copying the function, naming it after the query aspect of the function.</p>
<p class="codelink"><a id="p0308_01a" href="ch11_images.xhtml#p0308_01">Click here to view code image</a></p>
<pre class="pre">function <span class="pd_maroon1">findMiscreant</span> (people) {
  for (const p of people) {
    if (p === "Don") {
      setOffAlarms();
      return "Don";
    }
    if (p === "John") {
      setOffAlarms();
      return "John";
    }
  }
  return "";
}</pre>
<p class="indent">I remove the side effects from this new query.</p>
<p class="codelink"><a id="p0308_02a" href="ch11_images.xhtml#p0308_02">Click here to view code image</a></p>
<pre class="pre">function findMiscreant (people) {
  for (const p of people) {
    if (p === "Don") {
      <span class="strike"><span class="pd_maroon1">setOffAlarms();</span></span>
      return "Don";
    }
    if (p === "John") {
      <span class="strike"><span class="pd_maroon1">setOffAlarms();</span></span>
      return "John";
    }
  }
  return "";
}</pre>
<p class="indent">I now go to each caller and replace it with a call to the query, followed by a call to the modifier. So</p>
<p class="codelink"><a id="p0308_03a" href="ch11_images.xhtml#p0308_03">Click here to view code image</a></p>
<pre class="pre">const found = alertForMiscreant(people);</pre>
<p class="noindent">changes to</p>
<p class="codelink"><a id="p0308_04a" href="ch11_images.xhtml#p0308_04">Click here to view code image</a></p>
<pre class="pre">const found = <span class="pd_maroon1">findMiscreant(people)</span>;
alertForMiscreant(people);</pre>
<p class="indent">I now remove the return values from the modifier.</p>
<p class="codelink"><a id="p0309_01a" href="ch11_images.xhtml#p0309_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_309"/>function alertForMiscreant (people) {
  for (const p of people) {
    if (p === "Don") {
      setOffAlarms();
      <span class="pd_maroon1">return</span>;
    }
    if (p === "John") {
      setOffAlarms();
      <span class="pd_maroon1">return</span>;
    }
  }
  <span class="pd_maroon1">return</span>;
}</pre>
<p class="indent">Now I have a lot of duplication between the original modifier and the new query, so I can use <em><span class="pd_maroon"><a class="pd_maroon" href="ch07.xhtml#ch07lev1sec9">Substitute Algorithm</a> (<a class="pd_maroon" href="ch07.xhtml#page_195">195</a>)</span></em> so that the modifier uses the query.</p>
<p class="codelink"><a id="p0309_02a" href="ch11_images.xhtml#p0309_02">Click here to view code image</a></p>
<pre class="pre">function alertForMiscreant (people) {
  if (findMiscreant(people) !== "") setOffAlarms();
}</pre>
<h3 class="h3" id="ch11lev1sec2"><span epub:type="pagebreak" id="page_310"/>Parameterize Function</h3>
<p class="noindent">formerly: <em>Parameterize Method</em></p>
<figure class="fig-group">
<img src="graphics/p0310_01.jpg" aria-describedby="alt_p0310_01" alt="A figure illustrates how the refactoring technique is used to parameterize a function."/>
<aside class="hidden" id="alt_p0310_01">
<p>The diagrammatic representation shows a function with its parameter. The actual code reads, function tenPercentRaise(aPerson) { aPerson.salary = aPerson.salary.multiply(1.1); } function fivePercentRaise(aPerson) { aPerson.salary = aPerson.salary.multiply(1.05); } The code after refactoring reads, function raise(aPerson, factor) { aPerson.salary = aPerson.salary.multiply(1 + factor); }</p>
</aside>
</figure>
<h4 class="h4" id="ch11lev2sec4">Motivation</h4>
<p class="noindent">If I see two functions that carry out very similar logic with different literal values, I can remove the duplication by using a single function with parameters for the different values. This increases the usefulness of the function, since I can apply it elsewhere with different values.</p>
<h4 class="h4" id="ch11lev2sec5">Mechanics</h4>
<ul class="square">
<li><p>Select one of the similar methods.</p></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to add any literals that need to turn into parameters.</p></li>
<li><p>For each caller of the function, add the literal value.</p></li>
<li><p>Test.</p></li>
<li><p>Change the body of the function to use the new parameters. Test after each change.</p></li>
<li><p>For each similar function, replace the call with a call to the parameterized function. Test after each one.</p>
<div class="blockquote">
<p class="noindent"><span epub:type="pagebreak" id="page_311"/>If the original parameterized function doesn&#8217;t work for a similar function, adjust it for the new function before moving on to the next.</p>
</div></li>
</ul>
<h4 class="h4" id="ch11lev2sec6">Example</h4>
<p class="noindent">An obvious example is something like this:</p>
<p class="codelink"><a id="p0311_01a" href="ch11_images.xhtml#p0311_01">Click here to view code image</a></p>
<pre class="pre">function tenPercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.1);
}
function fivePercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.05);
}</pre>
<p class="indent">Hopefully it&#8217;s obvious that I can replace these with</p>
<p class="codelink"><a id="p0311_02a" href="ch11_images.xhtml#p0311_02">Click here to view code image</a></p>
<pre class="pre">function raise(aPerson, factor) {
  aPerson.salary = aPerson.salary.multiply(1 + factor);
}</pre>
<p class="indent">But it can be a bit more involved than that. Consider this code:</p>
<p class="codelink"><a id="p0311_03a" href="ch11_images.xhtml#p0311_03">Click here to view code image</a></p>
<pre class="pre">function baseCharge(usage) {
  if (usage &lt; 0) return usd(0);
  const amount =
        bottomBand(usage) * 0.03
        + middleBand(usage) * 0.05
        + topBand(usage) * 0.07;
  return usd(amount);
}

function bottomBand(usage) {
  return Math.min(usage, 100);
}

function middleBand(usage) {
  return usage &gt; 100 ? Math.min(usage, 200) - 100 : 0;
}

function topBand(usage) {
  return usage &gt; 200 ? usage - 200 : 0;
}</pre>
<p class="indent">Here the logic is clearly pretty similar&#8212;but is it similar enough to support creating a parameterized method for the bands? It is, but may be a touch less obvious than the trivial case above.</p>
<p class="indent">When looking to parameterize some related functions, my approach is to take one of the functions and add parameters to it, with an eye to the other cases. With range-oriented things like this, usually the place to start is with the middle range. So I&#8217;ll work on <code>middleBand</code> to change it to use parameters, and then adjust other callers to fit.</p>
<p class="indent"><span epub:type="pagebreak" id="page_312"/><code>middleBand</code> uses two literal values: <code>100</code> and <code>200</code>. These represent the bottom and top of this middle band. I begin by using <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to add them to the call. While I&#8217;m at it, I&#8217;ll also change the name of the function to something that makes sense with the parameterization.</p>
<p class="codelink"><a id="p0312_01a" href="ch11_images.xhtml#p0312_01">Click here to view code image</a></p>
<pre class="pre">function <span class="pd_maroon1">withinBand(usage, bottom, top)</span> {
  return usage &gt; 100 ? Math.min(usage, 200) - 100 : 0;
}

function baseCharge(usage) {
  if (usage &lt; 0) return usd(0);
  const amount =
        bottomBand(usage) * 0.03
        + <span class="pd_maroon1">withinBand</span>(usage, <span class="pd_maroon1">100, 200</span>) * 0.05
        + topBand(usage) * 0.07;
  return usd(amount);
}</pre>
<p class="indent">I replace each literal with a reference to the parameter:</p>
<p class="codelink"><a id="p0312_02a" href="ch11_images.xhtml#p0312_02">Click here to view code image</a></p>
<pre class="pre">function withinBand(usage, bottom, top) {
  return usage &gt; <span class="pd_maroon1">bottom</span> ? Math.min(usage, 200) <span class="pd_maroon1">- bottom</span> : 0;
}</pre>
<p class="noindent">then:</p>
<p class="codelink"><a id="p0312_03a" href="ch11_images.xhtml#p0312_03">Click here to view code image</a></p>
<pre class="pre">function withinBand(usage, bottom, top) {
  return usage &gt; bottom ? Math.min(usage, <span class="pd_maroon1">top</span>) - bottom : 0;
}</pre>
<p class="indent">I replace the call to the bottom band with a call to the newly parameterized function.</p>
<p class="codelink"><a id="p0312_04a" href="ch11_images.xhtml#p0312_04">Click here to view code image</a></p>
<pre class="pre">function baseCharge(usage) {
  if (usage &lt; 0) return usd(0);
  const amount =
        <span class="pd_maroon1">withinBand</span>(usage, <span class="pd_maroon1">0, 100</span>) * 0.03
        + withinBand(usage, 100, 200) * 0.05
        + topBand(usage) * 0.07;
  return usd(amount);
}

<span class="strike"><span class="pd_maroon1">function bottomBand(usage) {</span></span>
  <span class="strike"><span class="pd_maroon1">return Math.min(usage, 100);</span></span>
<span class="strike"><span class="pd_maroon1">}</span></span></pre>
<p class="indent">To replace the call to the top band, I need to make use of infinity.</p>
<p class="codelink"><a id="p0313_01a" href="ch11_images.xhtml#p0313_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_313"/>function baseCharge(usage) {
  if (usage &lt; 0) return usd(0);
  const amount =
        withinBand(usage, 0, 100) * 0.03
        + withinBand(usage, 100, 200) * 0.05
        + <span class="pd_maroon1">withinBand</span>(usage, <span class="pd_maroon1">200, Infinity</span>) * 0.07;
  return usd(amount);
}

<span class="strike"><span class="pd_maroon1">function topBand(usage) {</span></span>
  <span class="strike"><span class="pd_maroon1">return usage &gt; 200 ? usage - 200 : 0;</span></span>
<span class="strike"><span class="pd_maroon1">}</span></span></pre>
<p class="indent">With the logic working the way it does now, I could remove the initial guard clause. But although it&#8217;s logically unnecessary now, I like to keep it as it documents how to handle that case.</p>
<h3 class="h3" id="ch11lev1sec3"><span epub:type="pagebreak" id="page_314"/>Remove Flag Argument</h3>
<p class="noindent">formerly: <em>Replace Parameter with Explicit Methods</em></p>
<figure class="fig-group">
<img src="graphics/p0314_01.jpg" aria-describedby="alt_p0314_01" alt="A figure illustrates how the refactoring technique is used to remove a flag argument."/>
<aside class="hidden" id="alt_p0314_01">
<p>The diagrammatic representation shows the logic behind the flag arguments getting removed. The actual code reads, function setDimension(name, value) { if (name === &#34;height&#34;) { this._height = value; return; } if (name === &#34;width&#34;) { this._width = value; return; } } The code after refactoring reads, function setHeight(value) {this._height = value;} function setWidth (value) {this._width = value;}</p>
</aside>
</figure>
<h4 class="h4" id="ch11lev2sec7">Motivation</h4>
<p class="noindent">A flag argument is a function argument that the caller uses to indicate which logic the called function should execute. I may call a function that looks like this:</p>
<p class="codelink"><a id="p0314_02a" href="ch11_images.xhtml#p0314_02">Click here to view code image</a></p>
<pre class="pre">function bookConcert(aCustomer, isPremium) {
  if (isPremium) {
    // logic for premium booking
  } else {
    // logic for regular booking
  }
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_315"/>To book a premium concert, I issue the call like so:</p>
<pre class="pre">bookConcert(aCustomer, true);</pre>
<p class="indent">Flag arguments can also come as enums:</p>
<p class="codelink"><a id="p0315_01a" href="ch11_images.xhtml#p0315_01">Click here to view code image</a></p>
<pre class="pre">bookConcert(aCustomer, CustomerType.PREMIUM);</pre>
<p class="noindent">or strings (or symbols in languages that use them):</p>
<p class="codelink"><a id="p0315_02a" href="ch11_images.xhtml#p0315_02">Click here to view code image</a></p>
<pre class="pre">bookConcert(aCustomer, "premium");</pre>
<p class="indent">I dislike flag arguments because they complicate the process of understanding what function calls are available and how to call them. My first route into an API is usually the list of available functions, and flag arguments hide the differences in the function calls that are available. Once I select a function, I have to figure out what values are available for the flag arguments. Boolean flags are even worse since they don&#8217;t convey their meaning to the reader&#8212;in a function call, I can&#8217;t figure out what <code>true</code> means. It&#8217;s clearer to provide an explicit function for the task I want to do.</p>
<pre class="pre">premiumBookConcert(aCustomer);</pre>
<p class="indent">Not all arguments like this are flag arguments. To be a flag argument, the callers must be setting the boolean value to a literal value, not data that&#8217;s flowing through the program. Also, the implementation function must be using the argument to influence its control flow, not as data that it passes to further functions.</p>
<p class="indent">Removing flag arguments doesn&#8217;t just make the code clearer&#8212;it also helps my tooling. Code analysis tools can now more easily see the difference between calling the premium logic and calling regular logic.</p>
<p class="indent">Flag arguments can have a place if there&#8217;s more than one of them in the function, since otherwise I would need explicit functions for every combination of their values. But that&#8217;s also a signal of a function doing too much, and I should look for a way to create simpler functions that I can compose for this logic.</p>
<h4 class="h4" id="ch11lev2sec8">Mechanics</h4>
<ul class="square">
<li><p>Create an explicit function for each value of the parameter.</p>
<div class="blockquote">
<p class="noindent">If the main function has a clear dispatch conditional, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec1">Decompose Conditional</a> (<a class="pd_maroon" href="ch10.xhtml#page_260">260</a>)</span></em> to create the explicit functions. Otherwise, create wrapping functions.</p>
</div></li>
<li><p>For each caller that uses a literal value for the parameter, replace it with a call to the explicit function.</p></li>
</ul>
<h4 class="h4" id="ch11lev2sec9"><span epub:type="pagebreak" id="page_316"/>Example</h4>
<p class="noindent">Looking through some code, I see calls to calculate a delivery date for a shipment. Some of the calls look like</p>
<p class="codelink"><a id="p0316_01a" href="ch11_images.xhtml#p0316_01">Click here to view code image</a></p>
<pre class="pre">aShipment.deliveryDate = deliveryDate(anOrder, true);</pre>
<p class="noindent">and some look like</p>
<p class="codelink"><a id="p0316_02a" href="ch11_images.xhtml#p0316_02">Click here to view code image</a></p>
<pre class="pre">aShipment.deliveryDate = deliveryDate(anOrder, false);</pre>
<p class="indent">Faced with code like this, I immediately begin to wonder about the meaning of the boolean value. What is it doing?</p>
<p class="indent">The body of <code>deliveryDate</code> looks like this:</p>
<p class="codelink"><a id="p0316_03a" href="ch11_images.xhtml#p0316_03">Click here to view code image</a></p>
<pre class="pre">function deliveryDate(anOrder, isRush) {
  if (isRush) {
    let deliveryTime;
    if (["MA", "CT"]     .includes(anOrder.deliveryState)) deliveryTime = 1;
    else if (["NY", "NH"].includes(anOrder.deliveryState)) deliveryTime = 2;
    else deliveryTime = 3;
    return anOrder.placedOn.plusDays(1 + deliveryTime);
  }
  else {
    let deliveryTime;
    if (["MA", "CT", "NY"].includes(anOrder.deliveryState)) deliveryTime = 2;
    else if (["ME", "NH"] .includes(anOrder.deliveryState)) deliveryTime = 3;
    else deliveryTime = 4;
    return anOrder.placedOn.plusDays(2 + deliveryTime);
  }
}</pre>
<p class="indent">Here, the caller is using a literal boolean value to determine which code should run&#8212;a classic flag argument. But the whole point of using a function is to follow the caller&#8217;s instructions, so it is better to clarify the caller&#8217;s intent with explicit functions.</p>
<p class="indent">In this case, I can do this by using <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec1">Decompose Conditional</a> (<a class="pd_maroon" href="ch10.xhtml#page_260">260</a>)</span></em>, which gives me this:</p>
<p class="codelink"><a id="p0316_04a" href="ch11_images.xhtml#p0316_04">Click here to view code image</a></p>
<pre class="pre">function deliveryDate(anOrder, isRush) {
  if (isRush) return rushDeliveryDate(anOrder);
  else        return regularDeliveryDate(anOrder);
}
<span epub:type="pagebreak" id="page_317"/>function rushDeliveryDate(anOrder) {
    let deliveryTime;
    if (["MA", "CT"]     .includes(anOrder.deliveryState)) deliveryTime = 1;
    else if (["NY", "NH"].includes(anOrder.deliveryState)) deliveryTime = 2;
    else deliveryTime = 3;
    return anOrder.placedOn.plusDays(1 + deliveryTime);
}
function regularDeliveryDate(anOrder) {
    let deliveryTime;
    if (["MA", "CT", "NY"].includes(anOrder.deliveryState)) deliveryTime = 2;
    else if (["ME", "NH"] .includes(anOrder.deliveryState)) deliveryTime = 3;
    else deliveryTime = 4;
    return anOrder.placedOn.plusDays(2 + deliveryTime);
}</pre>
<p class="indent">The two new functions capture the intent of the call better, so I can replace each call of</p>
<p class="codelink"><a id="p0317_01a" href="ch11_images.xhtml#p0317_01">Click here to view code image</a></p>
<pre class="pre">aShipment.deliveryDate = deliveryDate(anOrder, true);</pre>
<p class="noindent">with</p>
<p class="codelink"><a id="p0317_02a" href="ch11_images.xhtml#p0317_02">Click here to view code image</a></p>
<pre class="pre">aShipment.deliveryDate = <span class="pd_maroon1">rush</span>DeliveryDate(anOrder);</pre>
<p class="noindent">and similarly with the other case.</p>
<p class="indent">When I&#8217;ve replaced all the callers, I remove <code>deliveryDate</code>.</p>
<p class="indent">A flag argument isn&#8217;t just the presence of a boolean value; it&#8217;s that the boolean is set with a literal rather than data. If all the callers of <code>deliveryDate</code> were like this:</p>
<p class="codelink"><a id="p0317_03a" href="ch11_images.xhtml#p0317_03">Click here to view code image</a></p>
<pre class="pre">const isRush = determineIfRush(anOrder);
aShipment.deliveryDate = deliveryDate(anOrder, isRush);</pre>
<p class="noindent">then I&#8217;d have no problem with <code>deliveryDate</code>&#8217;s signature (although I&#8217;d still want to apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch10.xhtml#ch10lev1sec1">Decompose Conditional</a> (<a class="pd_maroon" href="ch10.xhtml#page_260">260</a>)</span></em>).</p>
<p class="indent">It may be that some callers use the argument as a flag argument by setting it with a literal, while others set the argument with data. In this case, I&#8217;d still use Remove Flag Argument, but not change the data callers and not remove <code>deliveryDate</code> at the end. That way I support both interfaces for the different uses.</p>
<p class="indent">Decomposing the conditional like this is a good way to carry out this refactoring, but it only works if the dispatch on the parameter is the outer part of the function (or I can easily refactor it to make it so). It&#8217;s also possible that the parameter is used in a much more tangled way, such as this alternative version of <code>deliveryDate</code>:</p>
<p class="codelink"><a id="p0318_01a" href="ch11_images.xhtml#p0318_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_318"/>function deliveryDate(anOrder, isRush) {
  let result;
  let deliveryTime;
  if (anOrder.deliveryState === "MA" || anOrder.deliveryState === "CT")
    deliveryTime = isRush? 1 : 2;
  else if (anOrder.deliveryState === "NY" || anOrder.deliveryState === "NH") {
    deliveryTime = 2;
    if (anOrder.deliveryState === "NH" &amp;&amp; !isRush)
      deliveryTime = 3;
  }
  else if (isRush)
    deliveryTime = 3;
  else if (anOrder.deliveryState === "ME")
    deliveryTime = 3;
  else
    deliveryTime = 4;
  result = anOrder.placedOn.plusDays(2 + deliveryTime);
  if (isRush) result = result.minusDays(1);
  return result;
}</pre>
<p class="indent">In this case, teasing out <code>isRush</code> into a top-level dispatch conditional is likely more work than I fancy. So instead, I can layer functions over the <code>deliveryDate</code>:</p>
<p class="codelink"><a id="p0318_02a" href="ch11_images.xhtml#p0318_02">Click here to view code image</a></p>
<pre class="pre">function rushDeliveryDate   (anOrder) {return deliveryDate(anOrder, true);}
function regularDeliveryDate(anOrder) {return deliveryDate(anOrder, false);}</pre>
<div class="blockquote">
<p class="noindent">These wrapping functions are essentially partial applications of <code>deliveryDate</code>, although they are defined in program text rather than by composition of functions.</p>
</div>
<p class="indent">I can then do the same replacement of callers that I did with the decomposed conditional earlier on. If there aren&#8217;t any callers using the parameter as data, I like to restrict its visibility or rename it to a name that conveys that it shouldn&#8217;t be used directly (e.g., <code>deliveryDateHelperOnly</code>).</p>
<h3 class="h3" id="ch11lev1sec4"><span epub:type="pagebreak" id="page_319"/>Preserve Whole Object</h3>
<figure class="fig-group">
<img src="graphics/p0319_01.jpg" aria-describedby="alt_p0319_01" alt="A figure illustrates how the refactoring technique is used to preserve the whole object."/>
<aside class="hidden" id="alt_p0319_01">
<p>The diagrammatic representation shows the values derived from the objects that are getting passed to the function as arguments. The actual code reads, const low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; if (aPlan.withinRange(low, high)) The code after refactoring reads, if (aPlan.withinRange(aRoom.daysTempRange))</p>
</aside>
</figure>
<h4 class="h4" id="ch11lev2sec10">Motivation</h4>
<p class="noindent">If I see code that derives a couple of values from a record and then passes these values into a function, I like to replace those values with the whole record itself, letting the function body derive the values it needs.</p>
<p class="indent">Passing the whole record handles change better should the called function need more data from the whole in the future&#8212;that change would not require me to alter the parameter list. It also reduces the size of the parameter list, which usually makes the function call easier to understand. If many functions are called with the parts, they often duplicate the logic that manipulates these parts&#8212;logic that can often be moved to the whole.</p>
<p class="indent">The main reason I wouldn&#8217;t do this is if I don&#8217;t want the called function to have a dependency on the whole&#8212;which typically occurs when they are in different modules.</p>
<p class="indent">Pulling several values from an object to do some logic on them alone is a smell (<em><span class="pd_maroon"><a class="pd_maroon" href="ch03.xhtml#ch03lev1sec9">Feature Envy</a> (<a class="pd_maroon" href="ch03.xhtml#page_77">77</a>)</span></em>), and usually a signal that this logic should be moved into the whole itself. Preserve Whole Object is particularly common after I&#8217;ve done <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec8">Introduce Parameter Object</a> (<a class="pd_maroon" href="ch06.xhtml#page_140">140</a>)</span></em>, as I hunt down any occurrences of the original data clump to replace them with the new object.</p>
<p class="indent">If several bits of code only use the same subset of an object&#8217;s features, then that may indicate a good opportunity for <em><span class="pd_maroon"><a class="pd_maroon" href="ch07.xhtml#ch07lev1sec5">Extract Class</a> (<a class="pd_maroon" href="ch07.xhtml#page_182">182</a>)</span></em>.</p>
<p class="indent">One case that many people miss is when an object calls another object with several of its own data values. If I see this, I can replace those values with a self-reference (<code>this</code> in JavaScript).</p>
<h4 class="h4" id="ch11lev2sec11"><span epub:type="pagebreak" id="page_320"/>Mechanics</h4>
<ul class="square">
<li><p>Create an empty function with the desired parameters.</p>
<div class="blockquote">
<p class="noindent">Give the function an easily searchable name so it can be replaced at the end.</p>
</div></li>
<li><p>Fill the body of the new function with a call to the old function, mapping from the new parameters to the old ones.</p></li>
<li><p>Run static checks.</p></li>
<li><p>Adjust each caller to use the new function, testing after each change.</p>
<div class="blockquote">
<p class="noindent">This may mean that some code that derives the parameter isn&#8217;t needed, so can fall to <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec9">Remove Dead Code</a> (<a class="pd_maroon" href="ch08.xhtml#page_237">237</a>)</span></em>.</p>
</div></li>
<li><p>Once all original callers have been changed, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> on the original function.</p></li>
<li><p>Change the name of the new function and all its callers.</p></li>
</ul>
<h4 class="h4" id="ch11lev2sec12">Example</h4>
<p class="noindent">Consider a room monitoring system. It compares its daily temperature range with a range in a predefined heating plan.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0320_01a" href="ch11_images.xhtml#p0320_01">Click here to view code image</a></p>
<pre class="pre">const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (!aPlan.withinRange(low, high))
  alerts.push("room temperature went outside range");</pre>
<p class="pro-title"><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0320_02a" href="ch11_images.xhtml#p0320_02">Click here to view code image</a></p>
<pre class="pre">withinRange(bottom, top) {
  return (bottom &gt;= this._temperatureRange.low) &amp;&amp; (top &lt;= this._temperatureRange.high);
}</pre>
<p class="indent">Instead of unpacking the range information when I pass it in, I can pass in the whole range object.</p>
<p class="indent">I begin by stating the interface I want as an empty function.</p>
<p class="pro-title"><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0320_03a" href="ch11_images.xhtml#p0320_03">Click here to view code image</a></p>
<pre class="pre">xxNEWwithinRange(aNumberRange) {
}</pre>
<p class="indent">Since I intend it to replace the existing <code>withinRange</code>, I name it the same but with an easily replaceable prefix.</p>
<p class="indent">I then add the body of the function, which relies on calling the existing <code>withinRange</code>. The body thus consists of a mapping from the new parameter to the existing ones.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_321"/><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0321_01a" href="ch11_images.xhtml#p0321_01">Click here to view code image</a></p>
<pre class="pre">xxNEWwithinRange(aNumberRange) {
  return this.withinRange(aNumberRange.low, aNumberRange.high);
}</pre>
<p class="indent">Now I can begin the serious work, taking the existing function calls and having them call the new function.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0321_02a" href="ch11_images.xhtml#p0321_02">Click here to view code image</a></p>
<pre class="pre">const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (!aPlan.<span class="pd_maroon1">xxNEWwithinRange(aRoom.daysTempRange))</span>
  alerts.push("room temperature went outside range");</pre>
<p class="indent">When I&#8217;ve changed the calls, I may see that some of the earlier code isn&#8217;t needed anymore, so I wield <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec9">Remove Dead Code</a> (<a class="pd_maroon" href="ch08.xhtml#page_237">237</a>)</span></em>.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0321_03a" href="ch11_images.xhtml#p0321_03">Click here to view code image</a></p>
<pre class="pre"><span class="strike"><span class="pd_maroon1">const low = aRoom.daysTempRange.low;</span></span>
<span class="strike"><span class="pd_maroon1">const high = aRoom.daysTempRange.high;</span></span>
if (!aPlan.xxNEWwithinRange(aRoom.daysTempRange))
  alerts.push("room temperature went outside range");</pre>
<p class="indent">I replace these one at a time, testing after each change.</p>
<p class="indent">Once I&#8217;ve replaced them all, I can use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> on the original function.</p>
<p class="pro-title"><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0321_04a" href="ch11_images.xhtml#p0321_04">Click here to view code image</a></p>
<pre class="pre">xxNEWwithinRange(aNumberRange) {
  return <span class="pd_maroon1">(aNumberRange.low &gt;= this._temperatureRange.low) &amp;&amp;</span>
    <span class="pd_maroon1">(aNumberRange.high &lt;= this._temperatureRange.high);</span>
}</pre>
<p class="indent">And I finally remove that ugly prefix from the new function and all its callers. The prefix makes it a simple global replace, even if I don&#8217;t have a robust rename support in my editor.</p>
<p class="pro-title"><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0321_05a" href="ch11_images.xhtml#p0321_05">Click here to view code image</a></p>
<pre class="pre">withinRange(aNumberRange) {
  return (aNumberRange.low &gt;= this._temperatureRange.low) &amp;&amp;
    (aNumberRange.high &lt;= this._temperatureRange.high);
}</pre>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0321_06a" href="ch11_images.xhtml#p0321_06">Click here to view code image</a></p>
<pre class="pre">if (!aPlan.withinRange(aRoom.daysTempRange))
  alerts.push("room temperature went outside range");</pre>
<h4 class="h4" id="ch11lev2sec13"><span epub:type="pagebreak" id="page_322"/>Example: A Variation to Create the New Function</h4>
<p class="noindent">In the above example, I wrote the code for the new function directly. Most of the time, that&#8217;s pretty simple and the easiest way to go. But there is a variation on this that&#8217;s occasionally useful&#8212;which can allow me to compose the new function entirely from refactorings.</p>
<p class="indent">I start with a caller of the existing function.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0322_01a" href="ch11_images.xhtml#p0322_01">Click here to view code image</a></p>
<pre class="pre">const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (!aPlan.withinRange(low, high))
  alerts.push("room temperature went outside range");</pre>
<p class="indent">I want to rearrange the code so I can create the new function by using <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on some existing code. The caller code isn&#8217;t quite there yet, but I can get there by using <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec3">Extract Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_119">119</a>)</span></em> a few times. First, I disentangle the call to the old function from the conditional.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0322_02a" href="ch11_images.xhtml#p0322_02">Click here to view code image</a></p>
<pre class="pre">const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
const <span class="pd_maroon1">isWithinRange</span> = aPlan.withinRange(low, high);
if (!<span class="pd_maroon1">isWithinRange</span>)
  alerts.push("room temperature went outside range");</pre>
<p class="indent">I then extract the input parameter.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0322_03a" href="ch11_images.xhtml#p0322_03">Click here to view code image</a></p>
<pre class="pre">const <span class="pd_maroon1">tempRange</span> = aRoom.daysTempRange;
const low = <span class="pd_maroon1">tempRange</span>.low;
const high = <span class="pd_maroon1">tempRange</span>.high;
const isWithinRange = aPlan.withinRange(low, high);
if (!isWithinRange)
  alerts.push("room temperature went outside range");</pre>
<p class="indent">With that done, I can now use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> to create the new function.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0322_04a" href="ch11_images.xhtml#p0322_04">Click here to view code image</a></p>
<pre class="pre">const tempRange = aRoom.daysTempRange;
const isWithinRange = <span class="pd_maroon1">xxNEWwithinRange</span>(aPlan, tempRange);
if (!isWithinRange)
  alerts.push("room temperature went outside range");</pre>
<p class="pro-title"><span epub:type="pagebreak" id="page_323"/><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0323_01a" href="ch11_images.xhtml#p0323_01">Click here to view code image</a></p>
<pre class="pre">function <span class="pd_maroon1">xxNEWwithinRange</span>(aPlan, tempRange) {
  const low = tempRange.low;
  const high = tempRange.high;
  const isWithinRange = aPlan.withinRange(low, high);
  return isWithinRange;
}</pre>
<p class="indent">Since the original function is in a different context (the <code>HeatingPlan</code> class), I need to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em>.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0323_02a" href="ch11_images.xhtml#p0323_02">Click here to view code image</a></p>
<pre class="pre">const tempRange = aRoom.daysTempRange;
const isWithinRange = <span class="pd_maroon1">aPlan</span>.xxNEWwithinRange(tempRange);
if (!isWithinRange)
  alerts.push("room temperature went outside range");</pre>
<p class="pro-title"><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0323_03a" href="ch11_images.xhtml#p0323_03">Click here to view code image</a></p>
<pre class="pre">xxNEWwithinRange(tempRange) {
  const low = tempRange.low;
  const high = tempRange.high;
  const isWithinRange = this.withinRange(low, high);
  return isWithinRange;
}</pre>
<p class="indent">I then continue as before, replacing other callers and inlining the old function into the new one. I would also inline the variables I extracted to provide the clean separation for extracting the new function.</p>
<p class="indent">Because this variation is entirely composed of refactorings, it&#8217;s particularly handy when I have a refactoring tool with robust extract and inline operations.</p>
<h3 class="h3" id="ch11lev1sec5"><span epub:type="pagebreak" id="page_324"/>Replace Parameter with Query</h3>
<p class="noindent">formerly: <em>Replace Parameter with Method</em></p>
<p class="noindentz">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec6">Replace Query with Parameter</a> (<a class="pd_maroon" href="ch11.xhtml#page_327">327</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0324_01.jpg" aria-describedby="alt_p0324_01" alt="A figure illustrates how the refactoring technique is used to replace a parameter with a query."/>
<aside class="hidden" id="alt_p0324_01">
<p>The diagrammatic representation shows the function with a parameter getting replaced to the query of another method. The actual code reads, availableVacation(anEmployee, anEmployee.grade); function availableVacation(anEmployee, grade) { // calculate vacation... The code after refactoring reads, availableVacation(anEmployee) function availableVacation(anEmployee) { const grade = anEmployee.grade; // calculate vacation...</p>
</aside>
</figure>
<h4 class="h4" id="ch11lev2sec14">Motivation</h4>
<p class="noindent">The parameter list to a function should summarize the points of variability of that function, indicating the primary ways in which that function may behave differently. As with any statement in code, it&#8217;s good to avoid any duplication, and it&#8217;s easier to understand if the parameter list is short.</p>
<p class="indent">If a call passes in a value that the function can just as easily determine for itself, that&#8217;s a form of duplication&#8212;one that unnecessarily complicates the caller which has to determine the value of a parameter when it could be freed from that work.</p>
<p class="indent">The limit on this is suggested by the phrase &#8220;just as easily.&#8221; By removing the parameter, I&#8217;m shifting the responsibility for determining the parameter value. When the parameter is present, determining its value is the caller&#8217;s responsibility; otherwise, that responsibility shifts to the function body. My usual habit is to simplify life for callers, which implies moving responsibility to the function body&#8212;but only if that responsibility is appropriate there.</p>
<p class="indent">The most common reason to avoid Replace Parameter with Query is if removing the parameter adds an unwanted dependency to the function body&#8212;forcing it to access a program element that I&#8217;d rather it remained ignorant of. This may be a <span epub:type="pagebreak" id="page_325"/>new dependency, or an existing one that I&#8217;d like to remove. Usually this comes up where I&#8217;d need to add a problematic function call to the function body, or access something within a receiver object that I&#8217;d prefer to move out later.</p>
<p class="indent">The safest case for Replace Parameter with Query is when the value of the parameter I want to remove is determined merely by querying another parameter in the list. There&#8217;s rarely any point in passing two parameters if one can be determined from the other.</p>
<p class="indent">One thing to watch out for is if the function I&#8217;m looking at has referential transparency&#8212;that is, if I can be sure that it will behave the same way whenever it&#8217;s called with the same parameter values. Such functions are much easier to reason about and test, and I don&#8217;t want to alter them to lose that property. So I wouldn&#8217;t replace a parameter with an access to a mutable global variable.</p>
<h4 class="h4" id="ch11lev2sec15">Mechanics</h4>
<ul class="square">
<li><p>If necessary, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the calculation of the parameter.</p></li>
<li><p>Replace references to the parameter in the function body with references to the expression that yields the parameter. Test after each change.</p></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to remove the parameter.</p></li>
</ul>
<h4 class="h4" id="ch11lev2sec16">Example</h4>
<p class="noindent">I most often use Replace Parameter with Query when I&#8217;ve done some other refactorings that make a parameter no longer needed. Consider this code.</p>
<p class="pro-title"><em>class Order&#8230;</em></p>
<p class="codelink"><a id="p0325_01a" href="ch11_images.xhtml#p0325_01">Click here to view code image</a></p>
<pre class="pre">get finalPrice() {
  const basePrice = this.quantity * this.itemPrice;
  let discountLevel;
  if (this.quantity &gt; 100) discountLevel = 2;
  else discountLevel = 1;
  return this.discountedPrice(basePrice, discountLevel);
}

discountedPrice(basePrice, discountLevel) {
  switch (discountLevel) {
    case 1: return basePrice * 0.95;
    case 2: return basePrice * 0.9;
  }
}</pre>
<p class="indent">When I&#8217;m simplifying a function, I&#8217;m keen to apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch07.xhtml#ch07lev1sec4">Replace Temp with Query</a> (<a class="pd_maroon" href="ch07.xhtml#page_178">178</a>)</span></em>, which would lead me to</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_326"/><em>class Order&#8230;</em></p>
<p class="codelink"><a id="p0326_01a" href="ch11_images.xhtml#p0326_01">Click here to view code image</a></p>
<pre class="pre">get finalPrice() {
  const basePrice = this.quantity * this.itemPrice;
  return this.discountedPrice(basePrice, this.<span class="pd_maroon1">discountLevel</span>);
}

get <span class="pd_maroon1">discountLevel</span>() {
  return (this.quantity &gt; 100) ? 2 : 1;
}</pre>
<p class="indent">Once I&#8217;ve done this, there&#8217;s no need to pass the result of <code>discountLevel</code> to <code>discountedPrice</code>&#8212;it can just as easily make the call itself.</p>
<p class="indent">I replace any reference to the parameter with a call to the method instead.</p>
<p class="pro-title"><em>class Order&#8230;</em></p>
<p class="codelink"><a id="p0326_02a" href="ch11_images.xhtml#p0326_02">Click here to view code image</a></p>
<pre class="pre">discountedPrice(basePrice, discountLevel) {
  switch (<span class="pd_maroon1">this.</span>discountLevel) {
    case 1: return basePrice * 0.95;
    case 2: return basePrice * 0.9;
  }
}</pre>
<p class="indent">I can then use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to remove the parameter.</p>
<p class="pro-title"><em>class Order&#8230;</em></p>
<p class="codelink"><a id="p0326_03a" href="ch11_images.xhtml#p0326_03">Click here to view code image</a></p>
<pre class="pre">get finalPrice() {
  const basePrice = this.quantity * this.itemPrice;
  return this.discountedPrice(basePrice<span class="strike"><span class="pd_maroon1">, this.discountLevel</span></span>);
}

discountedPrice(basePrice<span class="strike"><span class="pd_maroon1">, discountLevel</span></span>) {
  switch (this.discountLevel) {
    case 1: return basePrice * 0.95;
    case 2: return basePrice * 0.9;
  }
}</pre>
<h3 class="h3" id="ch11lev1sec6"><span epub:type="pagebreak" id="page_327"/>Replace Query with Parameter</h3>
<p class="noindent">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec5">Replace Parameter with Query</a> (<a class="pd_maroon" href="ch11.xhtml#page_324">324</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0327_01.jpg" aria-describedby="alt_p0327_01" alt="A figure illustrates how the refactoring technique is used to replace a query with a parameter."/>
<aside class="hidden" id="alt_p0327_01">
<p>The diagrammatic representation shows the replacement of internal reference of the method with a parameter. The actual code reads, targetTemperature(aPlan) function targetTemperature(aPlan) { currentTemperature = thermostat.currentTemperature; // rest of function... The code after refactoring reads, targetTemperature(aPlan, thermostat.currentTemperature) function targetTemperature(aPlan, currentTemperature) { // rest of function...</p>
</aside>
</figure>
<h4 class="h4" id="ch11lev2sec17">Motivation</h4>
<p class="noindent">When looking through a function&#8217;s body, I sometimes see references to something in the function&#8217;s scope that I&#8217;m not happy with. This might be a reference to a global variable, or to an element in the same module that I intend to move away. To resolve this, I need to replace the internal reference with a parameter, shifting the responsibility of resolving the reference to the caller of the function.</p>
<p class="indent">Most of these cases are due to my wish to alter the dependency relationships in the code&#8212;to make the target function no longer dependent on the element I want to parameterize. There&#8217;s a tension here between converting everything to parameters, which results in long repetitive parameter lists, and sharing a lot of scope which can lead to a lot of coupling between functions. Like most tricky decisions, it&#8217;s not something I can reliably get right, so it&#8217;s important that I can reliably change things so the program can take advantage of my increasing understanding.</p>
<p class="indent">It&#8217;s easier to reason about a function that will always give the same result when called with same parameter values&#8212;this is called referential transparency. If a function accesses some element in its scope that isn&#8217;t referentially transparent, then the containing function also lacks referential transparency. I can fix that by <span epub:type="pagebreak" id="page_328"/>moving that element to a parameter. Although such a move will shift responsibility to the caller, there is often a lot to be gained by creating clear modules with referential transparency. A common pattern is to have modules consisting of pure functions which are wrapped by logic that handles the I/O and other variable elements of a program. I can use Replace Query with Parameter to purify parts of a program, making those parts easier to test and reason about.</p>
<p class="indent">But Replace Query with Parameter isn&#8217;t just a bag of benefits. By moving a query to a parameter, I force my caller to figure out how to provide this value. This complicates life for callers of the functions, and my usual bias is to design interfaces that make life easier for their consumers. In the end, it boils down to allocation of responsibility around the program, and that&#8217;s a decision that&#8217;s neither easy nor immutable&#8212;which is why this refactoring (and its inverse) is one that I need to be very familiar with.</p>
<h4 class="h4" id="ch11lev2sec18">Mechanics</h4>
<ul class="square">
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec3">Extract Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_119">119</a>)</span></em> on the query code to separate it from the rest of the function body.</p></li>
<li><p>Apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> to the body code that isn&#8217;t the call to the query.</p>
<div class="blockquote">
<p class="noindent">Give the new function an easily searchable name, for later renaming.</p>
</div></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec4">Inline Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_123">123</a>)</span></em> to get rid of the variable you just created.</p></li>
<li><p>Apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> to the original function.</p></li>
<li><p>Rename the new function to that of the original.</p></li>
</ul>
<h4 class="h4" id="ch11lev2sec19">Example</h4>
<p class="noindent">Consider a simple, yet annoying, control system for temperature. It allows the user to select a temperature on a thermostat&#8212;but only sets the target temperature within a range determined by a heating plan.</p>
<p class="pro-title"><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0328_01a" href="ch11_images.xhtml#p0328_01">Click here to view code image</a></p>
<pre class="pre">get targetTemperature() {
  if      (thermostat.selectedTemperature &gt;  this._max) return this._max;
  else if (thermostat.selectedTemperature &lt;  this._min) return this._min;
  else return thermostat.selectedTemperature;
}</pre>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0328_02a" href="ch11_images.xhtml#p0328_02">Click here to view code image</a></p>
<pre class="pre">if      (thePlan.targetTemperature &gt; thermostat.currentTemperature) setToHeat();
else if (thePlan.targetTemperature &lt; thermostat.currentTemperature) setToCool();
else setOff();</pre>
<p class="indent"><span epub:type="pagebreak" id="page_329"/>As a user of such a system, I might be annoyed to have my desires overridden by the heating plan rules, but as a programmer I might be more concerned about how the <code>targetTemperature</code> function has a dependency on a global thermostat object. I can break this dependency by moving it to a parameter.</p>
<p class="indent">My first step is to use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec3">Extract Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_119">119</a>)</span></em> on the parameter that I want to have in my function.</p>
<p class="pro-title"><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0329_01a" href="ch11_images.xhtml#p0329_01">Click here to view code image</a></p>
<pre class="pre">get targetTemperature() {
  <span class="pd_maroon1">const selectedTemperature =</span> thermostat.selectedTemperature;
  if      <span class="pd_maroon1">(selectedTemperature</span> &gt;  this._max) return this._max;
  else if <span class="pd_maroon1">(selectedTemperature</span> &lt;  this._min) return this._min;
  else return <span class="pd_maroon1">selectedTemperature</span>;
}</pre>
<p class="indent">That makes it easy to apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> on the entire body of the function except for the bit that figures out the parameter.</p>
<p class="pro-title"><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0329_02a" href="ch11_images.xhtml#p0329_02">Click here to view code image</a></p>
<pre class="pre">get targetTemperature() {
  const selectedTemperature = thermostat.selectedTemperature;
  return <span class="pd_maroon1">this.xxNEWtargetTemperature(selectedTemperature);</span>
}

<span class="pd_maroon1">xxNEWtargetTemperature(selectedTemperature)</span> {
  if      (selectedTemperature &gt;  this._max) return this._max;
  else if (selectedTemperature &lt;  this._min) return this._min;
  else return selectedTemperature;
}</pre>
<p class="indent">I then inline the variable I just extracted, which leaves the function as a simple call.</p>
<p class="pro-title"><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0329_03a" href="ch11_images.xhtml#p0329_03">Click here to view code image</a></p>
<pre class="pre">get targetTemperature() {
  return this.xxNEWtargetTemperature(<span class="pd_maroon1">thermostat.selectedTemperature</span>);
}</pre>
<p class="indent">I can now use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> on this method.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0329_04a" href="ch11_images.xhtml#p0329_04">Click here to view code image</a></p>
<pre class="pre">if      (thePlan.<span class="pd_maroon1">xxNEWtargetTemperature(thermostat.selectedTemperature)</span> &gt;
         thermostat.currentTemperature)
  setToHeat();
else if (thePlan.<span class="pd_maroon1">xxNEWtargetTemperature(thermostat.selectedTemperature)</span> &lt;
         thermostat.currentTemperature)
  setToCool();
else
  setOff();</pre>
<p class="indent"><span epub:type="pagebreak" id="page_330"/>I take advantage of the easily searchable name of the new function to rename it by removing the prefix.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0330_01a" href="ch11_images.xhtml#p0330_01">Click here to view code image</a></p>
<pre class="pre">if      (thePlan.<span class="pd_maroon1">targetTemperature</span>(thermostat.selectedTemperature) &gt;
         thermostat.currentTemperature)
  setToHeat();
else if (thePlan.<span class="pd_maroon1">targetTemperature</span>(thermostat.selectedTemperature) &lt;
         thermostat.currentTemperature)
  setToCool();
else
  setOff();</pre>
<p class="pro-title"><em>class HeatingPlan&#8230;</em></p>
<p class="codelink"><a id="p0330_02a" href="ch11_images.xhtml#p0330_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">targetTemperature</span>(selectedTemperature) {
  if      (selectedTemperature &gt;  this._max) return this._max;
  else if (selectedTemperature &lt;  this._min) return this._min;
  else return selectedTemperature;
}</pre>
<p class="indent">As is often the case with this refactoring, the calling code looks more unwieldy than before. Moving a dependency out of a module pushes the responsibility of dealing with that dependency back to the caller. That&#8217;s the trade-off for the reduced coupling.</p>
<p class="indent">But removing the coupling to the thermostat object isn&#8217;t the only gain I&#8217;ve made with this refactoring. The <code>HeatingPlan</code> class is immutable&#8212;its fields are set in the constructor with no methods to alter them. (I&#8217;ll save you the effort of looking at the whole class; just trust me on this.) Given an immutable heating plan, by moving the thermostat reference out of the function body I&#8217;ve also made <code>targetTemperature</code> referentially transparent. Every time I call <code>targetTemperature</code> on the same object, with the same argument, I will get the same result. If all the methods of the heating plan have referential transparency, that makes this class much easier to test and reason about.</p>
<p class="indent">A problem with JavaScript&#8217;s class model is that it&#8217;s impossible to enforce an immutable class&#8212;there&#8217;s always a way to get at an object&#8217;s data. But writing a class to signal and encourage immutability is often good enough. Creating classes that have this characteristic is often a sound strategy and Replace Query with Parameter is a handy tool for doing this.</p>
<h3 class="h3" id="ch11lev1sec7"><span epub:type="pagebreak" id="page_331"/>Remove Setting Method</h3>
<figure class="fig-group">
<img src="graphics/p0331_01.jpg" aria-describedby="alt_p0331_01" alt="A figure illustrates how the refactoring technique is used to remove the setting method."/>
<aside class="hidden" id="alt_p0331_01">
<p>The diagrammatic representation shows the field set as setting method getting removed. The actual code reads, class Person { get name() {...} set name(aString) {...} The code after refactoring reads, class Person { get name() {...}</p>
</aside>
</figure>
<h4 class="h4" id="ch11lev2sec20">Motivation</h4>
<p class="noindent">Providing a setting method indicates that a field may be changed. If I don&#8217;t want that field to change once the object is created, I don&#8217;t provide a setting method (and make the field immutable). That way, the field is set only in the constructor, my intention to have it not change is clear, and I usually remove the very possibility that the field will change.</p>
<p class="indent">There&#8217;s a couple of common cases where this comes up. One is where people always use accessor methods to manipulate a field, even within constructors. This leads to the only call to a setting method being from the constructor. I prefer to remove the setting method to make it clear that updates make no sense after construction.</p>
<p class="indent">Another case is where the object is created by clients using creation script rather than by a simple constructor call. Such a creation script starts with the constructor call followed by a sequence of setter method calls to create the new object. Once the script is finished, we don&#8217;t expect the new object to change some (or even all) of its fields. The setters are only expected to be called during this initial creation. In this case, I&#8217;d get rid of them to make my intentions clearer.</p>
<h4 class="h4" id="ch11lev2sec21"><span epub:type="pagebreak" id="page_332"/>Mechanics</h4>
<ul class="square">
<li><p>If the value that&#8217;s being set isn&#8217;t provided to the constructor, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to add it. Add a call to the setting method within the constructor.</p>
<div class="blockquote">
<p class="noindent">If you wish to remove several setting methods, add all their values to the constructor at once. This simplifies the later steps.</p>
</div></li>
<li><p>Remove each call of a setting method outside of the constructor, using the new constructor value instead. Test after each one.</p>
<div class="blockquote">
<p class="noindent">If you can&#8217;t replace the call to the setter by creating a new object (because you are updating a shared reference object), abandon the refactoring.</p>
</div></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> on the setting method. Make the field immutable if possible.</p></li>
<li><p>Test.</p></li>
</ul>
<h4 class="h4" id="ch11lev2sec22">Example</h4>
<p class="noindent">I have a simple person class.</p>
<p class="pro-title"><em>class Person&#8230;</em></p>
<p class="codelink"><a id="p0332_01a" href="ch11_images.xhtml#p0332_01">Click here to view code image</a></p>
<pre class="pre">get name()    {return this._name;}
set name(arg) {this._name = arg;}
get id()    {return this._id;}
set id(arg) {this._id = arg;}</pre>
<p class="indent">At the moment, I create a new object with code like this:</p>
<pre class="pre">const martin = new Person();
martin.name = "martin";
martin.id = "1234";</pre>
<p class="indent">The name of a person may change after it&#8217;s created, but the ID does not. To make this clear, I want to remove the setting method for ID.</p>
<p class="indent">I still need to set the ID initially, so I&#8217;ll use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to add it to the constructor.</p>
<p class="pro-title"><em>class Person&#8230;</em></p>
<pre class="pre">constructor(<span class="pd_maroon1">id</span>) {
  this.<span class="pd_maroon1">id = id</span>;
}</pre>
<p class="indent">I then adjust the creation script to set the ID via the constructor.</p>
<p class="codelink"><a id="p0333_01a" href="ch11_images.xhtml#p0333_01">Click here to view code image</a></p>
<pre class="pre"><span epub:type="pagebreak" id="page_333"/>const martin = new Person(<span class="pd_maroon1">"1234"</span>);
martin.name = "martin";
<span class="strike"><span class="pd_maroon1">martin.id = "1234";</span></span></pre>
<p class="indent">I do this in each place I create a person, testing after each change.</p>
<p class="indent">When they are all done, I can apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> to the setting method.</p>
<p class="pro-title"><em>class Person&#8230;</em></p>
<p class="codelink"><a id="p0333_02a" href="ch11_images.xhtml#p0333_02">Click here to view code image</a></p>
<pre class="pre">constructor(id) {
  <span class="pd_maroon1">this._id</span> = id;
}
get name()    {return this._name;}
set name(arg) {this._name = arg;}
get id()    {return this._id;}
<span class="strike"><span class="pd_maroon1">set id(arg) {this._id = arg;}</span></span></pre>
<h3 class="h3" id="ch11lev1sec8"><span epub:type="pagebreak" id="page_334"/>Replace Constructor with Factory Function</h3>
<p class="noindent">formerly: <em>Replace Constructor with Factory Method</em></p>
<figure class="fig-group">
<img src="graphics/p0334_01.jpg" aria-describedby="alt_p0334_01" alt="A figure illustrates how the refactoring technique is used to replace the constructor with the factory function."/>
<aside class="hidden" id="alt_p0334_01">
<p>The diagrammatic representation shows the logic that the constructor is replaced by a factory function named new thing() {}. The actual code reads, leadEngineer = new Employee(document.leadEngineer, &#39;E&#39;); The code after refactoring reads, leadEngineer = createEngineer(document.leadEngineer);</p>
</aside>
</figure>
<h4 class="h4" id="ch11lev2sec23">Motivation</h4>
<p class="noindent">Many object-oriented languages have a special constructor function that&#8217;s called to initialize an object. Clients typically call this constructor when they want to create a new object. But these constructors often come with awkward limitations that aren&#8217;t there for more general functions. A Java constructor must return an instance of the class it was called with, which means I can&#8217;t replace it with a subclass or proxy depending on the environment or parameters. Constructor naming is fixed, which makes it impossible for me to use a name that is clearer than the default. Constructors often require a special operator to invoke (&#8220;new&#8221; in many languages) which makes them difficult to use in contexts that expect normal functions.</p>
<p class="indent">A factory function suffers from no such limitations. It will likely call the constructor as part of its implementation, but I can freely substitute something else.</p>
<h4 class="h4" id="ch11lev2sec24">Mechanics</h4>
<ul class="square">
<li><p>Create a factory function, its body being a call to the constructor.</p></li>
<li><p>Replace each call to the constructor with a call to the factory function.</p></li>
<li><p>Test after each change.</p></li>
<li><p>Limit the constructor&#8217;s visibility as much as possible.</p></li>
</ul>
<h4 class="h4" id="ch11lev2sec25"><span epub:type="pagebreak" id="page_335"/>Example</h4>
<p class="noindent">A quick but wearisome example uses kinds of employees. Consider an employee class:</p>
<p class="pro-title"><em>class Employee&#8230;</em></p>
<p class="codelink"><a id="p0335_01a" href="ch11_images.xhtml#p0335_01">Click here to view code image</a></p>
<pre class="pre">constructor (name, typeCode) {
  this._name = name;
  this._typeCode = typeCode;
}
get name() {return this._name;}
get type() {
  return Employee.legalTypeCodes[this._typeCode];
}
static get legalTypeCodes() {
  return {"E": "Engineer", "M": "Manager", "S": "Salesman"};
}</pre>
<p class="indent">This is used from</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0335_02a" href="ch11_images.xhtml#p0335_02">Click here to view code image</a></p>
<pre class="pre">candidate = new Employee(document.name, document.empType);</pre>
<p class="noindent">and</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0335_03a" href="ch11_images.xhtml#p0335_03">Click here to view code image</a></p>
<pre class="pre">const leadEngineer = new Employee(document.leadEngineer, 'E');</pre>
<p class="indent">My first step is to create the factory function. Its body is a simple delegation to the constructor.</p>
<p class="pro-title"><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0335_04a" href="ch11_images.xhtml#p0335_04">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">function createEmployee(name, typeCode) {</span>
  <span class="pd_maroon1">return new Employee(name, typeCode);</span>
<span class="pd_maroon1">}</span></pre>
<p class="indent">I then find the callers of the constructor and change them, one at a time, to use the factory function instead.</p>
<p class="indent">The first one is obvious:</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0335_05a" href="ch11_images.xhtml#p0335_05">Click here to view code image</a></p>
<pre class="pre">candidate = <span class="pd_maroon1">createEmployee</span>(document.name, document.empType);</pre>
<p class="indent">With the second case, I could use the new factory function like this:</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0335_06a" href="ch11_images.xhtml#p0335_06">Click here to view code image</a></p>
<pre class="pre">const leadEngineer = <span class="pd_maroon1">createEmployee</span>(document.leadEngineer, 'E');</pre>
<p class="indent"><span epub:type="pagebreak" id="page_336"/>But I don&#8217;t like using the type code here&#8212;it&#8217;s generally a bad smell to pass a code as a literal string. So I prefer to create a new factory function that embeds the kind of employee I want into its name.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0336_01a" href="ch11_images.xhtml#p0336_01">Click here to view code image</a></p>
<pre class="pre">const leadEngineer = <span class="pd_maroon1">createEngineer</span>(document.leadEngineer);</pre>
<p class="pro-title"><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0336_02a" href="ch11_images.xhtml#p0336_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">function createEngineer(name) {</span>
  <span class="pd_maroon1">return new Employee(name, 'E');</span>
<span class="pd_maroon1">}</span></pre>
<h3 class="h3" id="ch11lev1sec9"><span epub:type="pagebreak" id="page_337"/>Replace Function with Command</h3>
<p class="noindent">formerly: <em>Replace Method with Method Object</em></p>
<p class="noindentz">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec10">Replace Command with Function</a> (<a class="pd_maroon" href="ch11.xhtml#page_344">344</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0337_01.jpg" aria-describedby="alt_p0337_01" alt="A figure illustrates how the refactoring technique is used to replace a function with command."/>
<aside class="hidden" id="alt_p0337_01">
<p>The diagrammatic representation shows a method with its object replaced with a command. The actual code reads, function score(candidate, medicalExam, scoringGuide) { let result = 0; let healthLevel = 0; // long body code } The code after refactoring reads, class Scorer { constructor(candidate, medicalExam, scoringGuide) { this._candidate = candidate; this._medicalExam = medicalExam; this._scoringGuide = scoringGuide; } execute() { this._result = 0; this._healthLevel = 0; // long body code } }</p>
</aside>
</figure>
<h4 class="h4" id="ch11lev2sec26">Motivation</h4>
<p class="noindent">Functions&#8212;either freestanding or attached to objects as methods&#8212;are one of the fundamental building blocks of programming. But there are times when it&#8217;s useful to encapsulate a function into its own object, which I refer to as a &#8220;command object&#8221; or simply a <strong>command</strong>. Such an object is mostly built around a single method, whose request and execution is the purpose of the object.</p>
<p class="indent">A command offers a greater flexibility for the control and expression of a function than the plain function mechanism. Commands can have complimentary operations, such as undo. I can provide methods to build up their parameters to <span epub:type="pagebreak" id="page_338"/>support a richer lifecycle. I can build in customizations using inheritance and hooks. If I&#8217;m working in a language with objects but without first-class functions, I can provide much of that capability by using commands instead. Similarly, I can use methods and fields to help break down a complex function, even in a language that lacks nested functions, and I can call those methods directly while testing and debugging.</p>
<p class="indent">All these are good reasons to use commands, and I need to be ready to refactor functions into commands when I need to. But we must not forget that this flexibility, as ever, comes at a price paid in complexity. So, given the choice between a first-class function and a command, I&#8217;ll pick the function 95% of the time. I only use a command when I specifically need a facility that simpler approaches can&#8217;t provide.</p>
<div class="blockquote">
<p class="noindent">Like many words in software development, &#8220;command&#8221; is rather overloaded. In the context I&#8217;m using it here, it is an object that encapsulates a request, following the command pattern in Design Patterns <span class="pd_maroon">[<a href="biblo.xhtml#bib11">gof</a>]</span>. When I use &#8220;command&#8221; in this sense, I use &#8220;command object&#8221; to set the context, and &#8220;command&#8221; afterwards. The word &#8220;command&#8221; is also used in the command-query separation principle <span class="pd_maroon">[<a href="biblo.xhtml#bib20">mf-cqs</a>]</span>, where a command is an object method that changes observable state. I&#8217;ve always tried to avoid using command in that sense, preferring &#8220;modifier&#8221; or &#8220;mutator.&#8221;</p>
</div>
<h4 class="h4" id="ch11lev2sec27">Mechanics</h4>
<ul class="square">
<li><p>Create an empty class for the function. Name it based on the function.</p></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em> to move the function to the empty class.</p>
<div class="blockquote">
<p class="noindent">Keep the original function as a forwarding function until at least the end of the refactoring.</p>
<p class="noindent">Follow any convention the language has for naming commands. If there is no convention, choose a generic name for the command&#8217;s execute function, such as &#8220;execute&#8221; or &#8220;call&#8221;.</p>
</div></li>
<li><p>Consider making a field for each argument, and move these arguments to the constructor.</p></li>
</ul>
<h4 class="h4" id="ch11lev2sec28">Example</h4>
<p class="noindent">The JavaScript language has many faults, but one of its great decisions was to make functions first-class entities. I thus don&#8217;t have to go through all the hoops of creating commands for common tasks that I need to do in languages without this facility. But there are still times when a command is the right tool for the job.</p>
<p class="indent">One of these cases is breaking up a complex function so I can better understand and modify it. To really show the value of this refactoring, I need a long and <span epub:type="pagebreak" id="page_339"/>complicated function&#8212;but that would take too long to write, let alone for you to read. Instead, I&#8217;ll go with a function that&#8217;s short enough not to need it. This one scores points for an insurance application:</p>
<p class="codelink"><a id="p0339_01a" href="ch11_images.xhtml#p0339_01">Click here to view code image</a></p>
<pre class="pre">function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
  let highMedicalRiskFlag = false;

  if (medicalExam.isSmoker) {
    healthLevel += 10;
    highMedicalRiskFlag = true;
  }
  let certificationGrade = "regular";
  if (scoringGuide.stateWithLowCertification(candidate.originState)) {
    certificationGrade = "low";
    result -= 5;
  }
  // lots more code like this
  result -= Math.max(healthLevel - 5, 0);
  return result;
}</pre>
<p class="indent">I begin by creating an empty class and then <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec1">Move Function</a> (<a class="pd_maroon" href="ch08.xhtml#page_198">198</a>)</span></em> to move the function into it.</p>
<p class="codelink"><a id="p0339_02a" href="ch11_images.xhtml#p0339_02">Click here to view code image</a></p>
<pre class="pre">function score(candidate, medicalExam, scoringGuide) {
  return <span class="pd_maroon1">new Scorer().execute(candidate, medicalExam, scoringGuide);</span>
}
  <span class="pd_maroon1">class Scorer {</span>
    <span class="pd_maroon1">execute</span> (candidate, medicalExam, scoringGuide) {
      let result = 0;
      let healthLevel = 0;
      let highMedicalRiskFlag = false;

      if (medicalExam.isSmoker) {
        healthLevel += 10;
        highMedicalRiskFlag = true;
      }
      let certificationGrade = "regular";
      if (scoringGuide.stateWithLowCertification(candidate.originState)) {
        certificationGrade = "low";
        result -= 5;
      }
      // lots more code like this
      result -= Math.max(healthLevel - 5, 0);
      return result;
    }
  }</pre>
<p class="indent"><span epub:type="pagebreak" id="page_340"/>Most of the time, I prefer to pass arguments to a command on the constructor and have the <code>execute</code> method take no parameters. While this matters less for a simple decomposition scenario like this, it&#8217;s very handy when I want to manipulate the command with a more complicated parameter setting lifecycle or customizations. Different command classes can have different parameters but be mixed together when queued for execution.</p>
<p class="indent">I can do these parameters one at a time.</p>
<p class="codelink"><a id="p0340_01a" href="ch11_images.xhtml#p0340_01">Click here to view code image</a></p>
<pre class="pre">function score(candidate, medicalExam, scoringGuide) {
  return new Scorer(<span class="pd_maroon1">candidate</span>).execute(<span class="strike"><span class="pd_maroon1">candidate,</span></span> medicalExam, scoringGuide);
}</pre>
<p class="pro-title"><em>class Scorer&#8230;</em></p>
<p class="codelink"><a id="p0340_02a" href="ch11_images.xhtml#p0340_02">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">constructor(candidate){</span>
  <span class="pd_maroon1">this._candidate = candidate;</span>
<span class="pd_maroon1">}</span>

execute (<span class="strike"><span class="pd_maroon1">candidate,</span></span> medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
  let highMedicalRiskFlag = false;

  if (medicalExam.isSmoker) {
    healthLevel += 10;
    highMedicalRiskFlag = true;
  }
  let certificationGrade = "regular";
  if (scoringGuide.stateWithLowCertification(<span class="pd_maroon1">this._candidate</span>.originState)) {
    certificationGrade = "low";
    result -= 5;
  }
  // lots more code like this
  result -= Math.max(healthLevel - 5, 0);
  return result;
}</pre>
<p class="indent">I continue with the other parameters</p>
<p class="codelink"><a id="p0340_03a" href="ch11_images.xhtml#p0340_03">Click here to view code image</a></p>
<pre class="pre">function score(candidate, medicalExam, scoringGuide) {
  return new Scorer(candidate, <span class="pd_maroon1">medicalExam, scoringGuide</span>).execute();
}</pre>
<p class="pro-title"><em>class Scorer&#8230;</em></p>
<p class="codelink"><a id="p0340_04a" href="ch11_images.xhtml#p0340_04">Click here to view code image</a></p>
<pre class="pre">constructor(candidate, <span class="pd_maroon1">medicalExam, scoringGuide</span>){
  this._candidate = candidate;
  <span class="pd_maroon1">this._medicalExam</span> = medicalExam;
  <span class="pd_maroon1">this._scoringGuide</span> = scoringGuide;
}

<span epub:type="pagebreak" id="page_341"/>execute () {
  let result = 0;
  let healthLevel = 0;
  let highMedicalRiskFlag = false;

  if (<span class="pd_maroon1">this._medicalExam</span>.isSmoker) {
    healthLevel += 10;
    highMedicalRiskFlag = true;
  }
  let certificationGrade = "regular";
  if (<span class="pd_maroon1">this._scoringGuide</span>.stateWithLowCertification(this._candidate.originState)) {
    certificationGrade = "low";
    result -= 5;
  }
  // lots more code like this
  result -= Math.max(healthLevel - 5, 0);
  return result;
}</pre>
<p class="indent">That completes Replace Function with Command, but the whole point of doing this refactoring is to allow me to break down the complicated functions&#8212;so let me outline some steps to achieve that. My next move here is to change all the local variables into fields. Again, I do these one at a time.</p>
<p class="pro-title"><em>class Scorer&#8230;</em></p>
<p class="codelink"><a id="p0341_01a" href="ch11_images.xhtml#p0341_01">Click here to view code image</a></p>
<pre class="pre">constructor(candidate, medicalExam, scoringGuide){
  this._candidate = candidate;
  this._medicalExam = medicalExam;
  this._scoringGuide = scoringGuide;
}

execute () {
  <span class="pd_maroon1">this._result</span> = 0;
  let healthLevel = 0;
  let highMedicalRiskFlag = false;

  if (this._medicalExam.isSmoker) {
    healthLevel += 10;
    highMedicalRiskFlag = true;
  }
  let certificationGrade = "regular";
  if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
    certificationGrade = "low";
    <span class="pd_maroon1">this._result</span> -= 5;
  }
  // lots more code like this
  <span class="pd_maroon1">this._result</span> -= Math.max(healthLevel - 5, 0);
  return <span class="pd_maroon1">this._result</span>;
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_342"/>I repeat this for all the local variables. (This is one of those refactorings that I felt was sufficiently simple that I haven&#8217;t given it an entry in the catalog. I feel slightly guilty about this.)</p>
<p class="pro-title"><em>class Scorer&#8230;</em></p>
<p class="codelink"><a id="p0342_01a" href="ch11_images.xhtml#p0342_01">Click here to view code image</a></p>
<pre class="pre">constructor(candidate, medicalExam, scoringGuide){
  this._candidate = candidate;
  this._medicalExam = medicalExam;
  this._scoringGuide = scoringGuide;
}

execute () {
  this._result = 0;
  <span class="pd_maroon1">this._healthLevel</span> = 0;
  <span class="pd_maroon1">this._highMedicalRiskFlag</span> = false;

  if (this._medicalExam.isSmoker) {
    <span class="pd_maroon1">this._healthLevel</span> += 10;
    <span class="pd_maroon1">this._highMedicalRiskFlag</span> = true;
  }
  <span class="pd_maroon1">this._certificationGrade</span> = "regular";
  if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
    <span class="pd_maroon1">this._certificationGrade</span> = "low";
    this._result -= 5;
  }
  // lots more code like this
  this._result -= Math.max(<span class="pd_maroon1">this._healthLevel</span> - 5, 0);
  return this._result;
}</pre>
<p class="indent">Now I&#8217;ve moved all the function&#8217;s state to the command object, I can use refactorings like <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> without getting tangled up in all the variables and their scopes.</p>
<p class="pro-title"><em>class Scorer&#8230;</em></p>
<p class="codelink"><a id="p0342_02a" href="ch11_images.xhtml#p0342_02">Click here to view code image</a></p>
<pre class="pre">execute () {
  this._result = 0;
  this._healthLevel = 0;
  this._highMedicalRiskFlag = false;

  this.<span class="pd_maroon1">scoreSmoking()</span>;
  this._certificationGrade = "regular";
  if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
    this._certificationGrade = "low";
    this._result -= 5;
  }
  // lots more code like this
  this._result -= Math.max(this._healthLevel - 5, 0);
  return this._result;
  }

<span epub:type="pagebreak" id="page_343"/><span class="pd_maroon1">scoreSmoking</span>() {
  if (this._medicalExam.isSmoker) {
    this._healthLevel += 10;
    this._highMedicalRiskFlag = true;
  }
}</pre>
<p class="indent">This allows me to treat the command similarly to how I&#8217;d deal with a nested function. Indeed, when doing this refactoring in JavaScript, using nested functions would be a reasonable alternative to using a command. I&#8217;d still use a command for this, partly because I&#8217;m more familiar with commands and partly because with a command I can write tests and debugging calls against the subfunctions.</p>
<h3 class="h3" id="ch11lev1sec10"><span epub:type="pagebreak" id="page_344"/>Replace Command with Function</h3>
<p class="noindent">inverse of: <em><span class="pd_maroon"><a class="pd_maroon" href="ch11.xhtml#ch11lev1sec9">Replace Function with Command</a> (<a class="pd_maroon" href="ch11.xhtml#page_337">337</a>)</span></em></p>
<figure class="fig-group">
<img src="graphics/p0344_01.jpg" aria-describedby="alt_p0344_01" alt="A figure illustrates how the refactoring technique is used to replace a command with a function."/>
<aside class="hidden" id="alt_p0344_01">
<p>The diagrammatic representation shows a command F, that is replaced by a method with an object. The actual code reads, class ChargeCalculator { constructor (customer, usage){ this._customer = customer; this._usage = usage; } execute() { return this._customer.rate * this._usage; } } The code after refactoring reads, function charge(customer, usage) { return customer.rate * usage; }</p>
</aside>
</figure>
<h4 class="h4" id="ch11lev2sec29">Motivation</h4>
<p class="noindent">Command objects provide a powerful mechanism for handling complex computations. They can easily be broken down into separate methods sharing common state through the fields; they can be invoked via different methods for different effects; they can have their data built up in stages. But that power comes at a cost. Most of the time, I just want to invoke a function and have it do its thing. If that&#8217;s the case, and the function isn&#8217;t too complex, then a command object is more trouble than its worth and should be turned into a regular function.</p>
<h4 class="h4" id="ch11lev2sec30">Mechanics</h4>
<ul class="square">
<li><p>Apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> to the creation of the command and the call to the command&#8217;s execution method.</p>
<div class="blockquote">
<p class="noindent">This creates the new function that will replace the command in due course.</p>
</div></li>
<li><p><span epub:type="pagebreak" id="page_345"/>For each method called by the command&#8217;s execution method, apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em>.</p>
<div class="blockquote">
<p class="noindent">If the supporting function returns a value, use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec3">Extract Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_119">119</a>)</span></em> on the call first and then <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em>.</p>
</div></li>
<li><p>Use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to put all the parameters of the constructor into the command&#8217;s execution method instead.</p></li>
<li><p>For each field, alter the references in the command&#8217;s execution method to use the parameter instead. Test after each change.</p></li>
<li><p>Inline the constructor call and command&#8217;s execution method call into the caller (which is the replacement function).</p></li>
<li><p>Test.</p></li>
<li><p>Apply <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec9">Remove Dead Code</a> (<a class="pd_maroon" href="ch08.xhtml#page_237">237</a>)</span></em> to the command class.</p></li>
</ul>
<h4 class="h4" id="ch11lev2sec31">Example</h4>
<p class="noindent">I&#8217;ll begin with this small command object:</p>
<p class="codelink"><a id="p0345_01a" href="ch11_images.xhtml#p0345_01">Click here to view code image</a></p>
<pre class="pre">class ChargeCalculator {
  constructor (customer, usage, provider){
    this._customer = customer;
    this._usage = usage;
    this._provider = provider;
  }
  get baseCharge() {
    return this._customer.baseRate * this._usage;
  }
  get charge() {
    return this.baseCharge + this._provider.connectionCharge;
  }
}</pre>
<p class="indent">It is used by code like this:</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0345_02a" href="ch11_images.xhtml#p0345_02">Click here to view code image</a></p>
<pre class="pre">monthCharge = new ChargeCalculator(customer, usage, provider).charge;</pre>
<p class="indent">The command class is small and simple enough to be better off as a function.</p>
<p class="indent">I begin by using <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec1">Extract Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_106">106</a>)</span></em> to wrap the class creation and invocation.</p>
<p class="pro-title"><em>caller&#8230;</em></p>
<p class="codelink"><a id="p0345_03a" href="ch11_images.xhtml#p0345_03">Click here to view code image</a></p>
<pre class="pre">monthCharge = charge(customer, usage, provider);</pre>
<p class="pro-title"><span epub:type="pagebreak" id="page_346"/><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0346_01a" href="ch11_images.xhtml#p0346_01">Click here to view code image</a></p>
<pre class="pre"><span class="pd_maroon1">function charge(customer, usage, provider) {</span>
  return new ChargeCalculator(customer, usage, provider).charge;
}</pre>
<p class="indent">I have to decide how to deal with any supporting functions, in this case <code>baseCharge</code>. My usual approach for a function that returns a value is to first <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec3">Extract Variable</a> (<a class="pd_maroon" href="ch06.xhtml#page_119">119</a>)</span></em> on that value.</p>
<p class="pro-title"><em>class ChargeCalculator&#8230;</em></p>
<p class="codelink"><a id="p0346_02a" href="ch11_images.xhtml#p0346_02">Click here to view code image</a></p>
<pre class="pre">get baseCharge() {
  return this._customer.baseRate * this._usage;
}
get charge() {
  <span class="pd_maroon1">const baseCharge = this.baseCharge;</span>
  return <span class="pd_maroon1">baseCharge</span> + this._provider.connectionCharge;
}</pre>
<p class="indent">Then, I use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em> on the supporting function.</p>
<p class="pro-title"><em>class ChargeCalculator&#8230;</em></p>
<p class="codelink"><a id="p0346_03a" href="ch11_images.xhtml#p0346_03">Click here to view code image</a></p>
<pre class="pre">get charge() {
  const baseCharge = <span class="pd_maroon1">this._customer.baseRate * this._usage;</span>
  return baseCharge + this._provider.connectionCharge;
}</pre>
<p class="indent">I now have all the processing in a single function, so my next step is to move the data passed to the constructor to the main method. I first use <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec5">Change Function Declaration</a> (<a class="pd_maroon" href="ch06.xhtml#page_124">124</a>)</span></em> to add all the constructor parameters to the <code>charge</code> method.</p>
<p class="pro-title"><em>class ChargeCalculator&#8230;</em></p>
<p class="codelink"><a id="p0346_04a" href="ch11_images.xhtml#p0346_04">Click here to view code image</a></p>
<pre class="pre">constructor (customer, usage, provider){
  this._customer = customer;
  this._usage = usage;
  this._provider = provider;
}

charge<span class="pd_maroon1">(customer, usage, provider)</span> {
  const baseCharge = this._customer.baseRate * this._usage;
  return baseCharge + this._provider.connectionCharge;
}</pre>
<p class="pro-title"><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0346_05a" href="ch11_images.xhtml#p0346_05">Click here to view code image</a></p>
<pre class="pre">function charge(customer, usage, provider) {
  return new ChargeCalculator(customer, usage, provider)
                      .charge<span class="pd_maroon1">(customer, usage, provider)</span>;
}</pre>
<p class="indent">Now I can alter the body of <code>charge</code> to use the passed parameters instead. I can do this one at a time.</p>
<p class="pro-title"><span epub:type="pagebreak" id="page_347"/><em>class ChargeCalculator&#8230;</em></p>
<p class="codelink"><a id="p0347_01a" href="ch11_images.xhtml#p0347_01">Click here to view code image</a></p>
<pre class="pre">constructor (customer, usage, provider){
  <span class="strike"><span class="pd_maroon1">this._customer = customer;</span></span>
  this._usage = usage;
  this._provider = provider;
}

charge(customer, usage, provider) {
  const baseCharge = <span class="pd_maroon1">customer</span>.baseRate * this._usage;
  return baseCharge + this._provider.connectionCharge;
}</pre>
<p class="indent">I don&#8217;t have to remove the assignment to <code>this._customer</code> in the constructor, as it will just be ignored. But I prefer to do it since that will make a test fail if I miss changing a use of field to the parameter. (And if a test doesn&#8217;t fail, I should consider adding a new test.)</p>
<p class="indent">I repeat this for the other parameters, ending up with</p>
<p class="pro-title"><em>class ChargeCalculator&#8230;</em></p>
<p class="codelink"><a id="p0347_02a" href="ch11_images.xhtml#p0347_02">Click here to view code image</a></p>
<pre class="pre">charge(customer, usage, provider) {
  const baseCharge = customer.baseRate * <span class="pd_maroon1">usage</span>;
  return baseCharge + <span class="pd_maroon1">provider</span>.connectionCharge;
}</pre>
<p class="indent">Once I&#8217;ve done all of these, I can inline into the top-level <code>charge</code> function. This is a special kind of <em><span class="pd_maroon"><a class="pd_maroon" href="ch06.xhtml#ch06lev1sec2">Inline Function</a> (<a class="pd_maroon" href="ch06.xhtml#page_115">115</a>)</span></em>, as it&#8217;s inlining both the constructor and method call together.</p>
<p class="pro-title"><em>top level&#8230;</em></p>
<p class="codelink"><a id="p0347_03a" href="ch11_images.xhtml#p0347_03">Click here to view code image</a></p>
<pre class="pre">function charge(customer, usage, provider) {
  <span class="pd_maroon1">const baseCharge = customer.baseRate * usage;</span>
  return <span class="pd_maroon1">baseCharge + provider.connectionCharge;</span>
}</pre>
<p class="indent">The command class is now dead code, so I&#8217;ll use <em><span class="pd_maroon"><a class="pd_maroon" href="ch08.xhtml#ch08lev1sec9">Remove Dead Code</a> (<a class="pd_maroon" href="ch08.xhtml#page_237">237</a>)</span></em> to give it an honorable burial.</p>
</section>
</body>
</html>