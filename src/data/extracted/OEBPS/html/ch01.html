<?xml version="1.0" encoding="UTF-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>One. Fundamentals</title>
<link href="9780132762564.css" rel="stylesheet" type="text/css"/>
<link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml"/>
<meta name="Adept.resource" value="urn:uuid:7baf5dbb-ffe1-4201-87bd-b993ed04f947"/>
</head>
<body>
<p><a id="ch01"/></p>
<h2><a id="page_2"/>One. Fundamentals</h2>
<div class="sidebar">
<hr/>
<p><a id="ch01sb01"/></p>
<p class="indenthangingN"><strong><a href="#ch01sec1lev3">1.1</a></strong> <a href="#ch01sec1lev3">Basic Programming Model</a> <a href="#ch01sec1lev3">8</a></p>
<p class="indenthangingN"><strong><a href="#ch01sec1lev4">1.2</a></strong> <a href="#ch01sec1lev4">Data Abstraction</a> <a href="#ch01sec1lev4">64</a></p>
<p class="indenthangingN"><strong><a href="ch01a.html#ch01sec1lev5">1.3</a></strong> <a href="ch01a.html#ch01sec1lev5">Bags, Queues, and Stacks</a> <a href="ch01a.html#ch01sec1lev5">120</a></p>
<p class="indenthangingN"><strong><a href="ch01a.html#ch01sec1lev6">1.4</a></strong> <a href="ch01a.html#ch01sec1lev6">Analysis of Algorithms</a> <a href="ch01a.html#ch01sec1lev6">172</a></p>
<p class="indenthangingN"><strong><a href="ch01a.html#ch01sec1lev7">1.5</a></strong> <a href="ch01a.html#ch01sec1lev7">Case Study: Union-Find</a> <a href="ch01a.html#ch01sec1lev7">216</a></p>
<hr/>
</div>
<p><a id="page_3"/>The objective of this book is to study a broad variety of important and useful <em>algorithms</em>—methods for solving problems that are suited for computer implementation. Algorithms go hand in hand with <em>data structures</em>—schemes for organizing data that leave them amenable to efficient processing by an algorithm. This chapter introduces the basic tools that we need to study algorithms and data structures.</p>
<p>First, we introduce our <em>basic programming model</em>. All of our programs are implemented using a small subset of the Java programming language plus a few of our own libraries for input/output and for statistical calculations. <a href="#ch01sec1lev3"><small>SECTION 1.1</small></a> is a summary of language constructs, features, and libraries that we use in this book.</p>
<p>Next, we emphasize <em>data abstraction</em>, where we define <em>abstract data types</em> (ADTs) in the service of modular programming. In <a href="#ch01sec1lev4"><small>SECTION 1.2</small></a> we introduce the process of implementing an ADT in Java, by specifying an <em>applications programming interface</em> (API) and then using the Java class mechanism to develop an implementation for use in client code.</p>
<p>As important and useful examples, we next consider three fundamental ADTs: the <em>bag</em>, the <em>queue</em>, and the <em>stack</em>. <a href="ch01a.html#ch01sec1lev5"><small>SECTION 1.3</small></a> describes APIs and implementations of bags, queues, and stacks using arrays, resizing arrays, and linked lists that serve as models and starting points for algorithm implementations throughout the book.</p>
<p>Performance is a central consideration in the study of algorithms. <a href="ch01a.html#ch01sec1lev6"><small>SECTION 1.4</small></a> describes our approach to analyzing algorithm performance. The basis of our approach is the <em>scientific method</em>: we develop hypotheses about performance, create mathematical models, and run experiments to test them, repeating the process as necessary.</p>
<p>We conclude with a case study where we consider solutions to a <em>connectivity</em> problem that uses algorithms and data structures that implement the classic <em>union-find</em> ADT.</p>
<p><a id="ch01sec1lev1"/></p>
<h3><a id="page_4"/>Algorithms</h3>
<p>When we write a computer program, we are generally implementing a <em>method</em> that has been devised previously to solve some problem. This method is often independent of the particular programming language being used—it is likely to be equally appropriate for many computers and many programming languages. It is the method, rather than the computer program itself, that specifies the steps that we can take to solve the problem. The term <em>algorithm</em> is used in computer science to describe a finite, deterministic, and effective problem-solving method suitable for implementation as a computer program. Algorithms are the stuff of computer science: they are central objects of study in the field.</p>
<p>We can define an algorithm by describing a procedure for solving a problem in a natural language, or by writing a computer program that implements the procedure, as shown at right for <em>Euclid’s algorithm</em> for finding the greatest common divisor of two numbers, a variant of which was devised over 2,300 years ago. If you are not familiar with Euclid’s algorithm, you are encouraged to work <a href="#ch01qa1q24"><small>EXERCISE 1.1.24</small></a> and <a href="#ch01qa1q25"><small>EXERCISE 1.1.25</small></a>, perhaps after reading <a href="#ch01sec1lev3"><small>SECTION 1.1</small></a>. In this book, we use computer programs to describe algorithms. One important reason for doing so is that it makes easier the task of checking whether they are finite, deterministic, and effective, as required. But it is also important to recognize that a program in a particular language is just one way to express an algorithm. The fact that many of the algorithms in this book have been expressed in multiple programming languages over the past several decades reinforces the idea that each algorithm is a method suitable for implementation on any computer in any programming language.</p>
<p class="image"><img alt="image" src="graphics/p0004-01.jpg"/></p>
<p>Most algorithms of interest involve organizing the data involved in the computation. Such organization leads to <em>data structures</em>, which also are central objects of study in computer science. Algorithms and data structures go hand in hand. In this book we take the view that data structures exist as the byproducts or end products of algorithms and that we must therefore study them in order to understand the algorithms. Simple algorithms can give rise to complicated data structures and, conversely, complicated algorithms can use simple data structures. We shall study the properties of many data structures in this book; indeed, we might well have titled the book <em>Algorithms and Data Structures</em>.</p>
<p><a id="page_5"/>When we use a computer to help us solve a problem, we typically are faced with a number of possible approaches. For small problems, it hardly matters which approach we use, as long as we have one that correctly solves the problem. For huge problems (or applications where we need to solve huge numbers of small problems), however, we quickly become motivated to devise methods that use time and space efficiently.</p>
<p>The primary reason to learn about algorithms is that this discipline gives us the potential to reap huge savings, even to the point of enabling us to do tasks that would otherwise be impossible. In an application where we are processing millions of objects, it is not unusual to be able to make a program millions of times faster by using a well-designed algorithm. We shall see such examples on numerous occasions throughout the book. By contrast, investing additional money or time to buy and install a new computer holds the potential for speeding up a program by perhaps a factor of only 10 or 100. Careful algorithm design is an extremely effective part of the process of solving a huge problem, whatever the applications area.</p>
<p>When developing a huge or complex computer program, a great deal of effort must go into understanding and defining the problem to be solved, managing its complexity, and decomposing it into smaller subtasks that can be implemented easily. Often, many of the algorithms required after the decomposition are trivial to implement. In most cases, however, there are a few algorithms whose choice is critical because most of the system resources will be spent running those algorithms. These are the types of algorithms on which we concentrate in this book. We study fundamental algorithms that are useful for solving challenging problems in a broad variety of applications areas.</p>
<p>The sharing of programs in computer systems is becoming more widespread, so although we might expect to be <em>using</em> a large fraction of the algorithms in this book, we also might expect to have to <em>implement</em> only a small fraction of them. For example, the Java libraries contain implementations of a host of fundamental algorithms. However, implementing simple versions of basic algorithms helps us to understand them better and thus to more effectively use and tune advanced versions from a library. More important, the opportunity to reimplement basic algorithms arises frequently. The primary reason to do so is that we are faced, all too often, with completely new computing environments (hardware and software) with new features that old implementations may not use to best advantage. In this book, we concentrate on the simplest reasonable implementations of the best algorithms. We do pay careful attention to coding the critical parts of the algorithms, and take pains to note where low-level optimization effort could be most beneficial.</p>
<p>The choice of the best algorithm for a particular task can be a complicated process, perhaps involving sophisticated mathematical analysis. The branch of computer science that comprises the study of such questions is called <em>analysis of algorithms</em>. Many <a id="page_6"/>of the algorithms that we study have been shown through analysis to have excellent theoretical performance; others are simply known to work well through experience. Our primary goal is to learn reasonable algorithms for important tasks, yet we shall also pay careful attention to comparative performance of the methods. We should not use an algorithm without having an idea of what resources it might consume, so we strive to be aware of how our algorithms might be expected to perform.</p>
<p><a id="ch01sec1lev2"/></p>
<h3>Summary of topics</h3>
<p>As an overview, we describe the major parts of the book, giving specific topics covered and an indication of our general orientation toward the material. This set of topics is intended to touch on as many fundamental algorithms as possible. Some of the areas covered are core computer-science areas that we study in depth to learn basic algorithms of wide applicability. Other algorithms that we discuss are from advanced fields of study within computer science and related fields. The algorithms that we consider are the products of decades of research and development and continue to play an essential role in the ever-expanding applications of computation.</p>
<p><strong><em><span class="pd_red">Fundamentals</span></em></strong> (<a href="#ch01"><small>CHAPTER 1</small></a>) in the context of this book are the basic principles and methodology that we use to implement, analyze, and compare algorithms. We consider our Java programming model, data abstraction, basic data structures, abstract data types for collections, methods of analyzing algorithm performance, and a case study.</p>
<p><strong><em><span class="pd_red">Sorting</span></em></strong> algorithms (<a href="ch02.html#ch02"><small>CHAPTER 2</small></a>) for rearranging arrays in order are of fundamental importance. We consider a variety of algorithms in considerable depth, including insertion sort, selection sort, shellsort, quicksort, mergesort, and heapsort. We also encounter algorithms for several related problems, including priority queues, selection, and merging. Many of these algorithms will find application as the basis for other algorithms later in the book.</p>
<p><strong><em><span class="pd_red">Searching</span></em></strong> algorithms (<a href="ch03.html#ch03"><small>CHAPTER 3</small></a>) for finding specific items among large collections of items are also of fundamental importance. We discuss basic and advanced methods for searching, including binary search trees, balanced search trees, and hashing. We note relationships among these methods and compare performance.</p>
<p><strong><em><span class="pd_red">Graphs</span></em></strong> (<a href="ch04.html#ch04"><small>CHAPTER 4</small></a>) are sets of objects and connections, possibly with weights and orientation. Graphs are useful models for a vast number of difficult and important problems, and the design of algorithms for processing graphs is a major field of study. We consider depth-first search, breadth-first search, connectivity problems, and several algorithms and applications, including Kruskal’s and Prim’s algorithms for finding minimum spanning tree and Dijkstra’s and the Bellman-Ford algorithms for solving shortest-paths problems.</p>
<p><a id="page_7"/><strong><em><span class="pd_red">Strings</span></em></strong> (<a href="ch05.html#ch05"><small>CHAPTER 5</small></a>) are an essential data type in modern computing applications. We consider a range of methods for processing sequences of characters. We begin with faster algorithms for sorting and searching when keys are strings. Then we consider substring search, regular expression pattern matching, and data-compression algorithms. Again, an introduction to advanced topics is given through treatment of some elementary problems that are important in their own right.</p>
<p><strong><em><span class="pd_red">Context</span></em></strong> (<a href="ch06.html#ch06"><small>CHAPTER 6</small></a>) helps us relate the material in the book to several other advanced fields of study, including scientific computing, operations research, and the theory of computing. We survey event-driven simulation, B-trees, suffix arrays, maximum flow, and other advanced topics from an introductory viewpoint to develop appreciation for the interesting advanced fields of study where algorithms play a critical role. Finally, we describe search problems, reduction, and NP-completeness to introduce the theoretical underpinnings of the study of algorithms and relationships to material in this book.</p>
<p><small>THE STUDY OF ALGORITHMS IS INTERESTING AND EXCITING</small> because it is a new field (almost all the algorithms that we study are less than 50 years old, and some were just recently discovered) with a rich tradition (a few algorithms have been known for hundreds of years). New discoveries are constantly being made, but few algorithms are completely understood. In this book we shall consider intricate, complicated, and difficult algorithms as well as elegant, simple, and easy ones. Our challenge is to understand the former and to appreciate the latter in the context of scientific and commercial applications. In doing so, we shall explore a variety of useful tools and develop a style of <em>algorithmic thinking</em> that will serve us well in computational challenges to come.</p>
<p><a id="ch01sec1lev3"/></p>
<h3><a id="page_8"/>1.1 Basic Programming Model</h3>
<p><small>OUR STUDY OF ALGORITHMS</small> is based upon implementing them as <em>programs</em> written in the Java programming language. We do so for several reasons:</p>
<p class="indenthangingB">• Our programs are concise, elegant, and complete descriptions of algorithms.</p>
<p class="indenthangingB">• You can run the programs to study properties of the algorithms.</p>
<p class="indenthangingB">• You can put the algorithms immediately to good use in applications.</p>
<p>These are important and significant advantages over the alternatives of working with English-language descriptions of algorithms.</p>
<p>A potential downside to this approach is that we have to work with a specific programming language, possibly making it difficult to separate the idea of the algorithm from the details of its implementation. Our implementations are designed to mitigate this difficulty, by using programming constructs that are both found in many modern languages and needed to adequately describe the algorithms.</p>
<p>We use only a small subset of Java. While we stop short of formally defining the subset that we use, you will see that we make use of relatively few Java constructs, and that we emphasize those that are found in many modern programming languages. The code that we present is complete, and our expectation is that you will download it and execute it, on our test data or test data of your own choosing.</p>
<p>We refer to the programming constructs, software libraries, and operating system features that we use to implement and describe algorithms as our <em>programming model</em>. In this section and <a href="#ch01sec1lev4"><small>SECTION 1.2</small></a>, we fully describe this programming model. The treatment is self-contained and primarily intended for documentation and for your reference in understanding any code in the book. The model we describe is the same model introduced in our book <em>An Introduction to Programming in Java: An Interdisciplinary Approach</em>, which provides a slower-paced introduction to the material.</p>
<p>For reference, the figure on the facing page depicts a complete Java program that illustrates many of the basic features of our programming model. We use this code for examples when discussing language features, but defer considering it in detail to page <a href="#ch01sec2lev10">46</a> (it implements a classic algorithm known as <em>binary search</em> and tests it for an application known as <em>whitelist filtering</em>). We assume that you have experience programming in some modern language, so that you are likely to recognize many of these features in this code. Page references are included in the annotations to help you find answers to any questions that you might have. Since our code is somewhat stylized and we strive to make consistent use of various Java idioms and constructs, it is worthwhile even for experienced Java programmers to read the information in this section.</p>
<p class="image"><a id="page_9"/><img alt="image" src="graphics/01_01-anatomyprogram.jpg"/></p>
<p><a id="ch01sec2lev1"/></p>
<h4><a id="page_10"/>Basic structure of a Java program</h4>
<p>A Java program (<em>class</em>) is either a <em>library of static methods</em> (functions) or a <em>data type definition</em>. To create libraries of static methods and data-type definitions, we use the following seven components, the basis of programming in Java and many other modern languages:</p>
<p class="indenthangingB">• <em>Primitive data types</em> precisely define the meaning of terms like <em>integer</em>, <em>real number</em>, and <em>boolean value</em> within a computer program. Their definition includes the set of possible values and <em>operations</em> on those values, which can be combined into <em>expressions</em> like mathematical expressions that define values.</p>
<p class="indenthangingB">• <em>Statements</em> allow us to define a computation by creating and assigning values to <em>variables</em>, controlling execution flow, or causing side effects. We use six types of statements: <em>declarations</em>, <em>assignments</em>, <em>conditionals</em>, <em>loops</em>, <em>calls</em>, and <em>returns</em>.</p>
<p class="indenthangingB">• <em>Arrays</em> allow us to work with multiple values of the same type.</p>
<p class="indenthangingB">• <em>Static methods</em> allow us to encapsulate and reuse code and to develop programs as a set of independent modules.</p>
<p class="indenthangingB">• <em>Strings</em> are sequences of characters. Some operations on them are built in to Java.</p>
<p class="indenthangingB">• <em>Input/output</em> sets up communication between programs and the outside world.</p>
<p class="indenthangingB">• <em>Data abstraction</em> extends encapsulation and reuse to allow us to define non-primitive data types, thus supporting object-oriented programming.</p>
<p>In this section, we will consider the first five of these in turn. Data abstraction is the topic of the next section.</p>
<p>Running a Java program involves interacting with an operating system or a program development environment. For clarity and economy, we describe such actions in terms of a <em>virtual terminal</em>, where we interact with programs by typing commands to the system. See the booksite for details on using a virtual terminal on your system, or for information on using one of the many more advanced program development environments that are available on modern systems.</p>
<p>For example, <code>BinarySearch</code> is two static methods, <code>rank()</code> and <code>main()</code>. The first static method, <code>rank()</code>, is four statements: two declarations, a loop (which is itself an assignment and two conditionals), and a return. The second, <code>main()</code>, is three statements: a declaration, a call, and a loop (which is itself an assignment and a conditional).</p>
<p>To invoke a Java program, we first <em>compile</em> it using the <code>javac</code> command, then <em>run</em> it using the <code>java</code> command. For example, to run <code>BinarySearch</code>, we first type the command <code>javac BinarySearch.java</code> (which creates a file <code>BinarySearch.class</code> that contains a lower-level version of the program in Java <em>bytecode</em> in the file <code>BinarySearch.class</code>). Then we type <code>java BinarySearch</code> (followed by a whitelist file name) to transfer control to the bytecode version of the program. To develop a basis for understanding the effect of these actions, we next consider in detail primitive data types and expressions, the various kinds of Java statements, arrays, static methods, strings, and input/output.</p>
<p><a id="ch01sec2lev2"/></p>
<h4><a id="page_11"/>Primitive data types and expressions</h4>
<p>A <em>data type</em> is a set of values and a set of operations on those values. We begin by considering the following four <em>primitive</em> data types that are the basis of the Java language:</p>
<p class="indenthangingB">• <em>Integers</em>, with arithmetic operations (<code>int</code>)</p>
<p class="indenthangingB">• <em>Real numbers</em>, again with arithmetic operations (<code>double</code>)</p>
<p class="indenthangingB">• <em>Booleans</em>, the set of values { <em>true</em>, <em>false</em> } with logical operations (<code>boolean</code>)</p>
<p class="indenthangingB">• <em>Characters</em>, the alphanumeric characters and symbols that you type (<code>char</code>)</p>
<p>Next we consider mechanisms for specifying values and operations for these types.</p>
<p>A Java program manipulates <em>variables</em> that are named with <em>identifiers</em>. Each variable is associated with a data type and stores one of the permissible data-type values. In Java code, we use <em>expressions</em> like familiar mathematical expressions to apply the operations associated with each type. For primitive types, we use identifiers to refer to variables, <em>operator</em> symbols such as <code>+ - * /</code> to specify operations, <em>literals</em> such as <code>1</code> or <code>3.14</code> to specify values, and expressions such as <code>(x + 2.236)/2</code> to specify operations on values. The purpose of an expression is to define one of the data-type values.</p>
<p class="image"><img alt="image" src="graphics/t0011-01.jpg"/></p>
<p><a id="page_12"/>To define a data type, we need only specify the values and the set of operations on those values. This information is summarized in the table below for Java’s <code>int</code>, <code>double</code>, <code>boolean</code>, and <code>char</code> data types. These data types are similar to the basic data types found in many programming languages. For <code>int</code> and <code>double</code>, the operations are familiar arithmetic operations; for <code>boolean</code>, they are familiar logical operations. It is important to note that <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> are <em>overloaded</em>—the same symbol specifies operations in multiple different types, depending on context. The key property of these primitive operations is that <em>an operation involving values of a given type has a value of that type</em>. This rule highlights the idea that we are often working with approximate values, since it is often the case that the exact value that would seem to be defined by the expression is not a value of the type. For example, <code>5/3</code> has the value <code>1</code> and <code>5.0/3.0</code> has a value very close to <code>1.66666666666667</code> but neither of these is exactly equal to 5/3. This table is far from complete; we discuss some additional operators and various exceptional situations that we occasionally need to consider in the Q&amp;A at the end of this section.</p>
<p class="image"><img alt="image" src="graphics/t0012-01.jpg"/></p>
<p><a id="ch01sec3lev1"/></p>
<h5><a id="page_13"/><em>Expressions</em></h5>
<p>As illustrated in the table at the bottom of the previous page, typical expressions are <em>infix</em>: a literal (or an expression), followed by an operator, followed by another literal (or another expression). When an expression contains more than one operator, the order in which they are applied is often significant, so the following <em>precedence</em> conventions are part of the Java language specification: The operators <code>*</code> and <code>/</code> (and <code>%</code>) have higher precedence than (are applied before) the <code>+</code> and <code>-</code> operators; among logical operators, <code>!</code> is the highest precedence, followed by <code>&amp;&amp;</code> and then <code>||</code>. Generally, operators of the same precedence are applied left to right. As in standard arithmetic expressions, you can use parentheses to override these rules. Since precedence rules vary slightly from language to language, we use parentheses and otherwise strive to avoid dependence on precedence rules in our code.</p>
<p><a id="ch01sec3lev2"/></p>
<h5><em>Type conversion</em></h5>
<p>Numbers are automatically promoted to a more inclusive type if no information is lost. For example, in the expression <code>1 + 2.5</code>, the <code>1</code> is promoted to the double value <code>1.0</code> and the expression evaluates to the <code>double</code> value <code>3.5</code>. A <em>cast</em> is a type name in parentheses within an expression, a directive to convert the following value into a value of that type. For example <code>(int) 3.7</code> is <code>3</code> and <code>(double) 3</code> is <code>3.0</code>. Note that casting to an <code>int</code> is truncation instead of rounding—rules for casting within complicated expressions can be intricate, and casts should be used sparingly and with care. A best practice is to use expressions that involve literals or variables of a single type.</p>
<p><a id="ch01sec3lev3"/></p>
<h5><em>Comparisons</em></h5>
<p>The following operators compare two values of the same type and produce a <code>boolean</code> value: <em>equal</em> (<code>==</code>), <em>not equal</em> (<code>!=</code>), <em>less than</em> (<code>&lt;</code>), <em>less than or equal</em> (<code>&lt;=</code>), <em>greater than</em> (<code>&gt;</code>), and g<em>reater than or equal</em> (<code>&gt;=</code>). These operators are known as <em>mixed-type</em> operators because their value is <code>boolean</code>, not the type of the values being compared. An expression with a boolean value is known as a <em>boolean expression</em>. Such expressions are essential components in conditional and loop statements, as we will see.</p>
<p><a id="ch01sec3lev4"/></p>
<h5><em>Other primitive types</em></h5>
<p>Java’s <code>int</code> has 2<sup>32</sup> different values by design, so it can be represented in a 32-bit machine word (many machines have 64-bit words nowadays, but the 32-bit <code>int</code> persists). Similarly, the <code>double</code> standard specifies a 64-bit representation. These data-type sizes are adequate for typical applications that use integers and real numbers. To provide flexibility, Java has five additional primitive data types:</p>
<p class="indenthangingB">• 64-bit integers, with arithmetic operations (<code>long</code>)</p>
<p class="indenthangingB">• 16-bit integers, with arithmetic operations (<code>short</code>)</p>
<p class="indenthangingB">• 16-bit characters, with arithmetic operations (<code>char</code>)</p>
<p class="indenthangingB">• 8-bit integers, with arithmetic operations (<code>byte</code>)</p>
<p class="indenthangingB">• 32-bit single-precision real numbers, again with arithmetic operations (<code>float</code>)</p>
<p>We most often use <code>int</code> and <code>double</code> arithmetic operations in this book, so we do not consider the others (which are very similar) in further detail here.</p>
<p><a id="ch01sec2lev3"/></p>
<h4><a id="page_14"/>Statements</h4>
<p>A Java program is composed of <em>statements</em>, which define the computation by creating and manipulating variables, assigning data-type values to them, and controlling the flow of execution of such operations. Statements are often organized in blocks, sequences of statements within curly braces.</p>
<p class="indenthangingB">• <em>Declarations</em> create variables of a specified type and name them with identifiers.</p>
<p class="indenthangingB">• <em>Assignments</em> associate a data-type value (defined by an expression) with a variable. Java also has several <em>implicit assignment</em> idioms for changing the value of a data-type value relative to its current value, such as incrementing the value of an integer variable.</p>
<p class="indenthangingB">• <em>Conditionals</em> provide for a simple change in the flow of execution—execute the statements in one of two blocks, depending on a specified condition.</p>
<p class="indenthangingB">• <em>Loops</em> provide for a more profound change in the flow of execution—execute the statements in a block as long as a given condition is true.</p>
<p class="indenthangingB">• <em>Calls</em> and <em>returns</em> relate to static methods (see page <a href="#ch01sec2lev6">22</a>), which provide another way to change the flow of execution and to organize code.</p>
<p>A program is a sequence of statements, with declarations, assignments, conditionals, loops, calls, and returns. Programs typically have a <em>nested</em> structure: a statement among the statements in a block within a conditional or a loop may itself be a conditional or a loop. For example, the <code>while</code> loop in <code>rank()</code> contains an <code>if</code> statement. Next, we consider each of these types of statements in turn.</p>
<p><a id="ch01sec3lev5"/></p>
<h5><em>Declarations</em></h5>
<p>A <em>declaration</em> statement associates a variable name with a type at compile time. Java requires us to use declarations to specify the names and types of variables. By doing so, we are being explicit about any computation that we are specifying. Java is said to be a <em>strongly typed</em> language, because the Java compiler checks for consistency (for example, it does not permit us to multiply a <code>boolean</code> and a <code>double</code>). Declarations can appear anywhere before a variable is first used—most often, we put them <em>at</em> the point of first use. The <em>scope</em> of a variable is the part of the program where it is defined. Generally the scope of a variable is composed of the statements that follow the declaration in the same block as the declaration.</p>
<p><a id="ch01sec3lev6"/></p>
<h5><em>Assignments</em></h5>
<p>An <em>assignment</em> statement associates a data-type value (defined by an expression) with a variable. When we write <code>c = a + b</code> in Java, we are not expressing mathematical equality, but are instead expressing an action: set the value of the variable <code>c</code> to be the value of <code>a</code> plus the value of <code>b</code>. It is true that <code>c</code> is mathematically equal to <code>a + b</code> immediately after the assignment statement has been executed, but the point of the statement is to change the value of <code>c</code> (if necessary). The left-hand side of an assignment statement must be a single variable; the right-hand side can be an arbitrary expression that produces a value of the type.</p>
<p><a id="ch01sec3lev7"/></p>
<h5><a id="page_15"/><em>Conditionals</em></h5>
<p>Most computations require different actions for different inputs. One way to express these differences in Java is the <code>if</code> statement:</p>
<p class="programlisting">if (&lt;boolean expression&gt;) { &lt;block statements&gt; }</p>
<p>This description introduces a formal notation known as a <em>template</em> that we use occasionally to specify the format of Java constructs. We put within angle brackets (<code>&lt; &gt;</code>) a construct that we have already defined, to indicate that we can use any instance of that construct where specified. In this case, <code>&lt;boolean expression&gt;</code> represents an expression that has a boolean value, such as one involving a comparison operation, and <code>&lt;block statements&gt;</code> represents a sequence of Java statements. It is possible to make formal definitions of <code>&lt;boolean expression&gt;</code> and <code>&lt;block statements&gt;</code>, but we refrain from going into that level of detail. The meaning of an <code>if</code> statement is self-explanatory: the statement(s) in the block are to be executed if and only if the boolean expression is <code>true</code>. The <code>if-else</code> statement:</p>
<p class="programlisting"><img alt="image" src="graphics/p0015-02.jpg"/></p>
<p>allows for choosing between two alternative blocks of statements.</p>
<p><a id="ch01sec3lev8"/></p>
<h5><em>Loops</em></h5>
<p>Many computations are inherently repetitive. The basic Java construct for handling such computations has the following format:</p>
<p class="programlisting">while (&lt;boolean expression&gt;) { &lt;block statements&gt; }</p>
<p>The <code>while</code> statement has the same form as the <code>if</code> statement (the only difference being the use of the keyword <code>while</code> instead of <code>if</code>), but the meaning is quite different. It is an instruction to the computer to behave as follows: if the boolean expression is <code>false</code>, do nothing; if the boolean expression is <code>true</code>, execute the sequence of statements in the block (just as with <code>if</code>) but then check the boolean expression again, execute the sequence of statements in the block again if the boolean expression is <code>true</code>, and continue as long as the boolean expression is <code>true</code>. We refer to the statements in the block in a loop as the <em>body</em> of the loop.</p>
<p><a id="ch01sec3lev9"/></p>
<h5><em>Break and continue</em></h5>
<p>Some situations call for slightly more complicated control flow than provided by the basic <code>if</code> and <code>while</code> statements. Accordingly, Java supports two additional statements for use within <code>while</code> loops:</p>
<p class="indenthangingB">• The <code>break</code> statement, which immediately exits the loop</p>
<p class="indenthangingB">• The <code>continue</code> statement, which immediately begins the next iteration of the loop</p>
<p>We rarely use these statements in the code in this book (and many programmers never use them), but they do considerably simplify code in certain instances.</p>
<p><a id="ch01sec2lev4"/></p>
<h4><a id="page_16"/>Shortcut notations</h4>
<p>There are several ways to express a given computation; we seek clear, elegant, and efficient code. Such code often takes advantage of the following widely used shortcuts (that are found in many languages, not just Java).</p>
<p><a id="ch01sec3lev10"/></p>
<h5><em>Initializing declarations</em></h5>
<p>We can combine a declaration with an assignment to initialize a variable at the same time that it is declared (created). For example, the code <code>int i = 1;</code> creates an <code>int</code> variable named <code>i</code> <em>and</em> assigns it the initial value <code>1</code>. A best practice is to use this mechanism close to first use of the variable (to limit scope).</p>
<p><a id="ch01sec3lev11"/></p>
<h5><em>Implicit assignments</em></h5>
<p>The following shortcuts are available when our purpose is to modify a variable’s value relative to its current value:</p>
<p class="indenthangingB">• Increment/decrement operators: <code>++i</code> is the same as <code>i = i + 1</code>; both have the value <code>i</code> in an expression. Similarly, <code>--i</code> is the same as <code>i = i - 1</code>. The code <code>i++</code> and <code>i--</code> are the same except that the expression value is the value <em>before</em> the increment/decrement, not after.</p>
<p class="indenthangingB">• Other compound operators: Prepending a binary operator to the <code>=</code> in an assignment is equivalent to using the variable on the left as the first operand. For example, the code <code>i/=2;</code> is equivalent to the code <code>i = i/2;</code> Note that <code>i += 1;</code> has the same effect as <code>i = i+1;</code> (and <code>i++</code>).</p>
<p><a id="ch01sec3lev12"/></p>
<h5><em>Single-statement blocks</em></h5>
<p>If a block of statements in a conditional or a loop has only a single statement, the curly braces may be omitted.</p>
<p><a id="ch01sec3lev13"/></p>
<h5><em>For notation</em></h5>
<p>Many loops follow this scheme: initialize an index variable to some value and then use a <code>while</code> loop to test a loop continuation condition involving the index variable, where the last statement in the <code>while</code> loop increments the index variable. You can express such loops compactly with Java’s <code>for</code> notation:</p>
<p class="programlisting"><img alt="image" src="graphics/p0016-01.jpg"/></p>
<p>This code is, with only a few exceptions, equivalent to</p>
<p class="programlisting"><img alt="image" src="graphics/p0016-02.jpg"/></p>
<p>We use <code>for</code> loops to support this initialize-and-increment programming idiom.</p>
<p class="image"><a id="page_17"/><img alt="image" src="graphics/t0017-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0017-02.jpg"/></p>
<p><a id="ch01sec2lev5"/></p>
<h4><a id="page_18"/>Arrays</h4>
<p>An <em>array</em> stores a sequence of values that are all of the same type. We want not only to store values but also to access each individual value. The method that we use to refer to individual values in an array is numbering and then <em>indexing</em> them. If we have <em>N</em> values, we think of them as being numbered from 0 to <em>N</em>−1. Then, we can unambiguously specify one of them in Java code by using the notation <code>a[i]</code> to refer to the <code>i</code>th value for any value of <code>i</code> from <code>0</code> to <code>N-1</code>. This Java construct is known as a <em>one-dimensional array</em>.</p>
<p><a id="ch01sec3lev14"/></p>
<h5><em>Creating and initializing an array</em></h5>
<p>Making an array in a Java program involves three distinct steps:</p>
<p class="indenthangingB">• Declare the array name and type.</p>
<p class="indenthangingB">• Create the array.</p>
<p class="indenthangingB">• Initialize the array values.</p>
<p>To declare the array, you need to specify a name and the type of data it will contain. To create it, you need to specify its length (the number of values). For example, the “long form” code shown at right makes an array of <code>N</code> numbers of type <code>double</code>, all initialized to <code>0.0</code>. The first statement is the array declaration. It is just like a declaration of a variable of the corresponding primitive type except for the square brackets following the type name, which specify that we are declaring an array. The keyword <em>new</em> in the second statement is a Java directive to create the array. The reason that we need to explicitly create arrays at run time is that the Java compiler cannot know how much space to reserve for the array at compile time (as it can for primitive-type values). The <code>for</code> statement initializes the <code>N</code> array values. This code sets all of the array entries to the value <code>0.0</code>. When you begin to write code that uses an array, you must be sure that your code declares, creates, and initializes it. Omitting one of these steps is a common programming mistake.</p>
<p class="image"><img alt="image" src="graphics/01_02-anatomyarray.jpg"/></p>
<p><a id="ch01sec3lev15"/></p>
<h5><em>Default array initialization</em></h5>
<p>For economy in code, we often take advantage of Java’s default array initialization convention and combine all three steps into a single statement, as in the “short form” code in our example. The code to the left of the equal sign constitutes the declaration; the code to the right constitutes the creation. The <code>for</code> loop is unnecessary in this case because the default initial value of variables of type <code>double</code> in a Java array is <a id="page_19"/><code>0.0</code>, but it would be required if a nonzero value were desired. The default initial value is zero for numeric types and <code>false</code> for type <code>boolean</code>.</p>
<h5><em>Initializing declaration</em></h5>
<p>The third option shown for our example is to specify the initialization values at compile time, by listing literal values between curly braces, separated by commas.</p>
<p><a id="ch01sec3lev16"/></p>
<h5><em>Using an array</em></h5>
<p>Typical array-processing code is shown on page <a href="#page_21">21</a>. After declaring and creating an array, you can refer to any individual value anywhere you would use a variable name in a program by enclosing an integer index in square brackets after the array name. Once we create an array, its size is fixed. A program can refer to the length of an array <code>a[]</code> with the code <code>a.length</code>. The last element of an array <code>a[]</code> is always <code>a[a.length-1]</code>. Java does <em>automatic bounds checking</em>—if you have created an array of size <code>N</code> and use an index whose value is less than <code>0</code> or greater than <code>N-1</code>, your program will terminate with an <code>ArrayOutOfBoundsException</code> runtime exception.</p>
<p><a id="ch01sec3lev17"/></p>
<h5><em>Aliasing</em></h5>
<p>Note carefully that <em>an array name refers to the whole array</em>—if we assign one array name to another, then both refer to the same array, as illustrated in the following code fragment.</p>
<p class="programlisting"><img alt="image" src="graphics/p0019-01.jpg"/></p>
<p>This situation is known as <em>aliasing</em> and can lead to subtle bugs. If your intent is to make a copy of an array, then you need to declare, create, and initialize a new array and then copy all of the entries in the original array to the new array, as in the third example on page <a href="#page_21">21</a>.</p>
<p><a id="ch01sec3lev18"/></p>
<h5><em>Two-dimensional arrays</em></h5>
<p>A <em>two-dimensional array</em> in Java is an array of one-dimensional arrays. A two-dimensional array may be <em>ragged</em> (its arrays may all be of differing lengths), but we most often work with (for appropriate parameters <em>M</em> and <em>N</em>) <em>M</em>-by-<em>N</em> two-dimensional arrays that are arrays of <em>M rows</em>, each an array of length <em>N</em> (so it also makes sense to refer to the array as having <em>N columns</em>). Extending Java array constructs to handle two-dimensional arrays is straightforward. To refer to the entry in row <code>i</code> and column <code>j</code> of a two-dimensional array <code>a[][]</code>, we use the notation <code>a[i][j]</code>; to declare a two-dimensional array, we add another pair of square brackets; and to create the array, we specify the number of rows followed by the number of columns after the type name (both within square brackets), as follows:</p>
<p class="programlisting"><a id="page_20"/>double[][] a = new double[M][N];</p>
<p>We refer to such an array as an <em>M</em>-by-<em>N</em> array. By convention, the first dimension is the number of rows and the second is the number of columns. As with one-dimensional arrays, Java initializes all entries in arrays of numeric types to zero and in arrays of <code>boolean</code> values to <code>false</code>. Default initialization of two-dimensional arrays is useful because it masks more code than for one-dimensional arrays. The following code is equivalent to the single-line create-and-initialize idiom that we just considered:</p>
<p class="programlisting"><img alt="image" src="graphics/p0020-02.jpg"/></p>
<p>This code is superfluous when initializing to zero, but the nested <code>for</code> loops are needed to initialize to other value(s).</p>
<p class="image"><a id="page_21"/><img alt="image" src="graphics/t0021-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0021-02.jpg"/></p>
<p><a id="ch01sec2lev6"/></p>
<h4><a id="page_22"/>Static methods</h4>
<p>Every Java program in this book is either a <em>data-type definition</em> (which we describe in detail in <a href="#ch01sec1lev4"><small>SECTION 1.2</small></a>) or a <em>library of static methods</em> (which we describe here). Static methods are called <em>functions</em> in many programming languages, since they can behave like mathematical functions, as described next. Each static method is a sequence of statements that are executed, one after the other, when the static method is <em>called</em>, in the manner described below. The modifier <em>static</em> distinguishes these methods from <em>instance methods</em>, which we discuss in <a href="#ch01sec1lev4"><small>SECTION 1.2</small></a>. We use the word <em>method</em> without a modifier when describing characteristics shared by both kinds of methods.</p>
<p><a id="ch01sec3lev19"/></p>
<h5><em>Defining a static method</em></h5>
<p>A <em>method</em> encapsulates a computation that is defined as a sequence of statements. A method takes <em>arguments</em> (values of given data types) and computes a <em>return value</em> of some data type that depends upon the arguments (such as a value defined by a mathematical function) or causes a <em>side effect</em> that depends on the arguments (such as printing a value). The static method <code>rank()</code> in <code>BinarySearch</code> is an example of the first; <code>main()</code> is an example of the second. Each static method is composed of a <em>signature</em> (the keywords <code>public static</code> followed by a return type, the method name, and a sequence of arguments, each with a declared type) and a <em>body</em> (a statement block: a sequence of statements, enclosed in curly braces). Examples of static methods are shown in the table on the facing page.</p>
<p class="image"><img alt="image" src="graphics/01_03-anatomystaticmethod.jpg"/></p>
<p><a id="ch01sec3lev20"/></p>
<h5><em>Invoking a static method</em></h5>
<p>A <em>call</em> on a static method is its name followed by expressions that specify argument values in parentheses, separated by commas. When the method call is part of an expression, the method computes a value and that value is used in place of the call in the expression. For example the call on <code>rank()</code> in <code>BinarySearch()</code> returns an <code>int</code> value. A method call followed by a semicolon is a <em>statement</em> that generally causes side effects. For example, the call <code>Arrays.sort()</code> in <code>main()</code> in <code>BinarySearch</code> is a call on the system method <code>Arrays.sort()</code> that has the side effect of putting the entries in the array in sorted order. When a method is called, its argument variables are initialized with the values of the corresponding expressions in the call. A <code>return</code> statement terminates a static method, returning control to the caller. If the static method is to compute a value, that value must be specified in a <code>return</code> statement (if such a static method can reach the end of its sequence of statements without a <code>return</code>, the compiler will report the error).</p>
<p class="image"><a id="page_23"/><img alt="image" src="graphics/t0023-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0023-02.jpg"/></p>
<p><a id="ch01sec3lev21"/></p>
<h5><a id="page_24"/><em>Properties of methods</em></h5>
<p>A complete detailed description of the properties of methods is beyond our scope, but the following points are worth noting:</p>
<p class="indenthangingB">• <em>Arguments are passed by value.</em> You can use argument variables anywhere in the code in the body of the method in the same way you use local variables. The only difference between an argument variable and a local variable is that the argument variable is initialized with the argument value provided by the calling code. The method works with the value of its arguments, not the arguments themselves. One consequence of this approach is that changing the value of an argument variable within a static method has no effect on the calling code. Generally, we do not change argument variables in the code in this book. The pass-by-value convention implies that array arguments are aliased (see page <a href="#ch01sec3lev16">19</a>)—the method uses the argument variable to refer to the caller’s array and can change the contents of the array (though it cannot change the array itself). For example, <code>Arrays.sort()</code> certainly changes the contents of the array passed as argument: it puts the entries in order.</p>
<p class="indenthangingB">• <em>Method names can be overloaded.</em> For example, the Java <code>Math</code> library uses this approach to provide implementations of <code>Math.abs()</code>, <code>Math.min()</code>, and <code>Math.max()</code> for all primitive numeric types. Another common use of overloading is to define two different versions of a function, one that takes an argument and another that uses a default value of that argument.</p>
<p class="indenthangingB">• <em>A method has a single return value but may have multiple return statements.</em> A Java method can provide only one return value, of the type declared in the method signature. Control goes back to the calling program as soon as the first <code>return</code> statement in a static method is reached. You can put <code>return</code> statements wherever you need them. Even though there may be multiple <code>return</code> statements, any static method returns a single value each time it is invoked: the value following the first <code>return</code> statement encountered.</p>
<p class="indenthangingB">• <em>A method can have side effects.</em> A method may use the keyword <code>void</code> as its return type, to indicate that it has no return value. An explicit return is not necessary in a <code>void</code> static method: control returns to the caller after the last statement. A <code>void</code> static method is said to produce side effects (consume input, produce output, change entries in an array, or otherwise change the state of the system). For example, the <code>main()</code> static method in our programs has a <code>void</code> return type because its purpose is to produce output. Technically, <code>void</code> methods do not implement mathematical functions (and neither does <code>Math.random()</code>, which takes no arguments but does produce a return value).</p>
<p>The instance methods that are the subject of <a href="ch02.html#ch02sec1lev1"><small>SECTION 2.1</small></a> share these properties, though profound differences surround the issue of side effects.</p>
<p><a id="ch01sec3lev22"/></p>
<h5><a id="page_25"/><em>Recursion</em></h5>
<p>A method can call itself (if you are not comfortable with this idea, known as <em>recursion</em>, you are encouraged to work <a href="#ch01qa1q16"><small>EXERCISES 1.1.16</small></a> through <a href="#ch01qa1q22">1.1.22</a>). For example, the code at the bottom of this page gives an alternate implementation of the <code>rank()</code> method in <code>BinarySearch</code>. We often use recursive implementations of methods because they can lead to compact, elegant code that is easier to understand than a corresponding implementation that does not use recursion. For example, the comment in the implementation below provides a succinct description of what the code is supposed to do. We can use this comment to convince ourselves that it operates correctly, by mathematical induction. We will expand on this topic and provide such a proof for binary search in <a href="ch03.html#ch03sec1lev1"><small>SECTION 3.1</small></a>. There are three important rules of thumb in developing recursive programs:</p>
<p class="indenthangingB">• The recursion has a <em>base case</em>—we always include a conditional statement as the first statement in the program that has a <code>return</code>.</p>
<p class="indenthangingB">• Recursive calls must address subproblems that are <em>smaller</em> in some sense, so that recursive calls converge to the base case. In the code below, the difference between the values of the fourth and the third arguments always decreases.</p>
<p class="indenthangingB">• Recursive calls should not address subproblems that <em>overlap</em>. In the code below, the portions of the array referenced by the two subproblems are disjoint.</p>
<p>Violating any of these guidelines is likely to lead to incorrect results or a spectacularly inefficient program (see <a href="#ch01qa1q19"><small>EXERCISES 1.1.19</small></a> and <a href="#ch01qa1q27">1.1.27</a>). Adhering to them is likely to lead to a clear and correct program whose performance is easy to understand. Another reason to use recursive methods is that they lead to mathematical models that we can use to understand performance. We address this issue for binary search in <a href="ch03.html#ch03sec1lev2"><small>SECTION 3.2</small></a> and in several other instances throughout the book.</p>
<p class="image"><img alt="image" src="graphics/p0025-01.jpg"/></p>
<p><a id="ch01sec3lev23"/></p>
<h5><a id="page_26"/><em>Basic programming model</em></h5>
<p>A <em>library of static methods</em> is a set of static methods that are defined in a Java class, by creating a file with the keywords <code>public class</code> followed by the class name, followed by the static methods, enclosed in braces, kept in a file with the same name as the class and a <code>.java</code> extension. A basic model for Java programming is to develop a program that addresses a specific computational task by creating a library of static methods, one of which is named <code>main()</code>. Typing <code>java</code> followed by a class name followed by a sequence of strings leads to a call on <code>main()</code> in that class, with an array containing those strings as argument. After the last statement in <code>main()</code> executes, the program terminates. In this book, when we talk of a <em>Java program</em> for accomplishing a task, we are talking about code developed along these lines (possibly also including a data-type definition, as described in <a href="#ch01sec1lev4"><small>SECTION 1.2</small></a>). For example, <code>BinarySearch</code> is a Java program composed of two static methods, <code>rank()</code> and <code>main()</code>, that accomplishes the task of printing numbers from an input stream that are not found in a whitelist file given as command-line argument.</p>
<p><a id="ch01sec3lev24"/></p>
<h5><em>Modular programming</em></h5>
<p>Of critical importance in this model is that libraries of static methods enable <em>modular programming</em> where we build libraries of static methods (<em>modules</em>) and a static method in one library can call static methods defined in other libraries. This approach has many important advantages. It allows us to</p>
<p class="indenthangingB">• Work with modules of reasonable size, even in program involving a large amount of code</p>
<p class="indenthangingB">• Share and reuse code without having to reimplement it</p>
<p class="indenthangingB">• Easily substitute improved implementations</p>
<p class="indenthangingB">• Develop appropriate abstract models for addressing programming problems</p>
<p class="indenthangingB">• Localize debugging (see the paragraph below on unit testing)</p>
<p>For example, <code>BinarySearch</code> makes use of three other independently developed libraries, our <code>StdIn</code> and <code>In</code> library and Java’s <code>Arrays</code> library. Each of these libraries, in turn, makes use of several other libraries.</p>
<p><a id="ch01sec3lev25"/></p>
<h5><em>Unit testing</em></h5>
<p>A best practice in Java programming is to include a <code>main()</code> in every library of static methods that tests the methods in the library (some other programming languages disallow multiple <code>main()</code> methods and thus do not support this approach). Proper unit testing can be a significant programming challenge in itself. At a minimum, every module should contain a <code>main()</code> method that exercises the code in the module and provides some assurance that it works. As a module matures, we often refine the <code>main()</code> method to be a <em>development client</em> that helps us do more detailed tests as we develop the code, or a <em>test client</em> that tests all the code extensively. As a client becomes more complicated, we might put it in an independent module. In this book, we use <code>main()</code> to help illustrate the purpose of each module and leave test clients for exercises.</p>
<p><a id="ch01sec3lev26"/></p>
<h5><a id="page_27"/><em>External libraries</em></h5>
<p>We use static methods from four different kinds of libraries, each requiring (slightly) differing procedures for code reuse. Most of these are libraries of static methods, but a few are data-type definitions that also include some static methods.</p>
<p class="indenthangingB">• The standard system libraries <code>java.lang.*</code>. These include <code>Math</code>, which contains methods for commonly used mathematical functions; <code>Integer</code> and <code>Double</code>, which we use for converting between strings of characters and <code>int</code> and <code>double</code> values; <code>String</code> and <code>StringBuilder</code>, which we discuss in detail later in this section and in <a href="ch05.html#ch05"><small>CHAPTER 5</small></a>; and dozens of other libraries that we do not use.</p>
<p class="image"><img alt="image" src="graphics/p0027-01.jpg"/></p>
<p class="indenthangingB">• Imported system libraries such as <code>java.util.Arrays</code>. There are thousands of such libraries in a standard Java release, but we make scant use of them in this book. An <code>import</code> statement at the beginning of the program is needed to use such libraries (and signal that we are doing so).</p>
<p class="indenthangingB">• Other libraries in this book. For example, another program can use <code>rank()</code> in <code>BinarySearch</code>. To use such a program, download the source from the booksite into your working directory.</p>
<p class="indenthangingB">• The standard libraries <code>Std*</code> that we have developed for use in this book (and our introductory book <em>An Introduction to Programming in Java: An Interdisciplinary Approach</em>). These libraries are summarized in the following several pages. Source code and instructions for downloading them are available on the booksite.</p>
<p>To invoke a method from another library (one in the same directory or a specified directory, a standard system library, or a system library that is named in an <code>import</code> statement before the class definition), we prepend the library name to the method name for each call. For example, the <code>main()</code> method in <code>BinarySearch</code> calls the <code>sort()</code> method in the system library <code>java.util.Arrays</code>, the <code>readInts()</code> method in our library <code>In</code>, and the <code>println()</code> method in our library <code>StdOut</code>.</p>
<p><small>LIBRARIES OF METHODS IMPLEMENTED BY OURSELVES AND BY OTHERS</small> in a modular programming environment can vastly expand the scope of our programming model. Beyond all of the libraries available in a standard Java release, thousands more are available on the web for applications of all sorts. To limit the scope of our programming model to a manageable size so that we can concentrate on algorithms, we use just the libraries listed in the table at right on this page, with a subset of their methods listed in <em>APIs</em>, as described next.</p>
<p><a id="ch01sec2lev7"/></p>
<h4><a id="page_28"/>APIs</h4>
<p>A critical component of modular programming is <em>documentation</em> that explains the operation of library methods that are intended for use by others. We will consistently describe the library methods that we use in this book in <em>application programming interfaces (APIs)</em> that list the library name and the signatures and short descriptions of each of the methods that we use. We use the term <em>client</em> to refer to a program that calls a method in another library and the term <em>implementation</em> to describe the Java code that implements the methods in an API.</p>
<p><a id="ch01sec3lev27"/></p>
<h5><em>Example</em></h5>
<p>The following example, the API for commonly used static methods from the standard <code>Math</code> library in <code>java.lang</code>, illustrates our conventions for APIs:</p>
<p class="image"><img alt="image" src="graphics/p0028-01.jpg"/></p>
<p><a id="page_29"/>These methods implement mathematical functions—they use their arguments to compute a value of a specified type (except <code>random()</code>, which does not implement a mathematical function because it does not take an argument). Since they all operate on <code>double</code> values and compute a <code>double</code> result, you can consider them as extending the <code>double</code> data type—extensibility of this nature is one of the characteristic features of modern programming languages. Each method is described by a line in the API that specifies the information you need to know in order to use the method. The <code>Math</code> library also defines the precise constant values <code>PI</code> (for π) and <code>E</code> (for <em>e</em>), so that you can use those names to refer to those constants in your programs. For example, the value of <code>Math.sin(Math.PI/2)</code> is <code>1.0</code> and the value of <code>Math.log(Math.E)</code> is <code>1.0</code> (because <code>Math.sin()</code> takes its argument in radians and <code>Math.log()</code> implements the natural logarithm function).</p>
<p><a id="ch01sec3lev28"/></p>
<h5><em>Java libraries</em></h5>
<p>Extensive online descriptions of thousands of libraries are part of every Java release, but we excerpt just a few methods that we use in the book, in order to clearly delineate our programming model. For example, <code>BinarySearch</code> uses the <code>sort()</code> method from Java’s <code>Arrays</code> library, which we document as follows:</p>
<p class="image"><img alt="image" src="graphics/t0029-01.jpg"/></p>
<p>The <code>Arrays</code> library is not in <code>java.lang</code>, so an <code>import</code> statement is needed to use it, as in <code>BinarySearch</code>. Actually, <a href="ch02.html#ch02"><small>CHAPTER 2</small></a> of this book is devoted to implementations of <code>sort()</code> for arrays, including the mergesort and quicksort algorithms that are implemented in <code>Arrays.sort()</code>. Many of the fundamental algorithms that we consider in this book are implemented in Java and in many other programming environments. For example, <code>Arrays</code> also includes an implementation of binary search. To avoid confusion, we generally use our own implementations, although there is nothing wrong with using a finely tuned library implementation of an algorithm that you understand.</p>
<p><a id="ch01sec3lev29"/></p>
<h5><a id="page_30"/><em>Our standard libraries</em></h5>
<p>We have developed a number of libraries that provide useful functionality for introductory Java programming, for scientific applications, and for the development, study, and application of algorithms. Most of these libraries are for input and output; we also make use of the following two libraries to test and analyze our implementations. The first extends <code>Math.random()</code> to allow us to draw random values from various distributions; the second supports statistical calculations:</p>
<p class="image"><img alt="image" src="graphics/t0030-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0030-02.jpg"/></p>
<p><a id="page_31"/>The <code>initialize()</code> method in <code>StdRandom</code> allows us to <em>seed</em> the random number generator so that we can reproduce experiments involving random numbers. For reference, implementations of many of these methods are given on page <a href="#ch01sec2lev8">32</a>. Some of these methods are extremely easy to implement; why do we bother including them in a library? Answers to this question are standard for well-designed libraries:</p>
<p class="indenthangingB">• They implement a level of abstraction that allow us to focus on implementing and testing the algorithms in the book, not generating random objects or calculating statistics. Client code that uses such methods is clearer and easier to understand than homegrown code that does the same calculation.</p>
<p class="indenthangingB">• Library implementations test for exceptional conditions, cover rarely encountered situations, and submit to extensive testing, so that we can count on them to operate as expected. Such implementations might involve a significant amount of code. For example, we often want implementations for various types of data. For example, Java’s <code>Arrays</code> library includes multiple overloaded implementations of <code>sort()</code>, one for each type of data that you might need to sort.</p>
<p>These are bedrock considerations for modular programming in Java, but perhaps a bit overstated in this case. While the methods in both of these libraries are essentially self-documenting and many of them are not difficult to implement, some of them represent interesting algorithmic exercises. Accordingly, you are well-advised to <em>both</em> study the code in <code>StdRandom.java</code> and <code>StdStats.java</code> on the booksite <em>and</em> to take advantage of these tried-and-true implementations. The easiest way to use these libraries (and to examine the code) is to download the source code from the booksite and put them in your working directory; various system-dependent mechanisms for using them without making multiple copies are also described on the booksite.</p>
<p><a id="ch01sec3lev30"/></p>
<h5><em>Your own libraries</em></h5>
<p>It is worthwhile to consider <em>every program that you write</em> as a library implementation, for possible reuse in the future.</p>
<p class="indenthangingB">• Write code for the client, a top-level implementation that breaks the computation up into manageable parts.</p>
<p class="indenthangingB">• Articulate an API for a library (or multiple APIs for multiple libraries) of static methods that can address each part.</p>
<p class="indenthangingB">• Develop an implementation of the API, with a <code>main()</code> that tests the methods independent of the client.</p>
<p>Not only does this approach provide you with valuable software that you can later reuse, but also taking advantage of modular programming in this way is a key to successfully addressing a complex programming task.</p>
<p class="image"><a id="page_32"/><img alt="image" src="graphics/t0032-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0032-02.jpg"/></p>
<p><a id="page_33"/><small>THE PURPOSE OF AN API</small> is to <em>separate</em> the client from the implementation: the client should know nothing about the implementation other than information given in the API, and the implementation should not take properties of any particular client into account. APIs enable us to separately develop code for various purposes, then reuse it widely. No Java library can contain all the methods that we might need for a given computation, so this ability is a crucial step in addressing complex programming applications. Accordingly, programmers normally think of the API as a <em>contract</em> between the client and the implementation that is a clear specification of what each method is to do. Our goal when developing an implementation is to honor the terms of the contract. Often, there are many ways to do so, and separating client code from implementation code gives us the freedom to substitute new and improved implementations. In the study of algorithms, this ability is an important ingredient in our ability to understand the impact of algorithmic improvements that we develop.</p>
<p><a id="ch01sec2lev8"/></p>
<h4><a id="page_34"/>Strings</h4>
<p>A <code>String</code> is a sequence of characters (<code>char</code> values). A literal <code>String</code> is a sequence of characters within double quotes, such as <code>"Hello, World"</code>. The data type <code>String</code> is a Java data type but it is <em>not</em> a primitive type. We consider <code>String</code> now because it is a fundamental data type that almost every Java program uses.</p>
<p><a id="ch01sec3lev31"/></p>
<h5><em>Concatenation</em></h5>
<p>Java has a built-in <em>concatenation</em> operator (+) for <code>String</code> like the built-in operators that it has for primitive types, justifying the addition of the row in the table below to the primitive-type table on page <a href="#page_12">12</a>. The result of concatenating two <code>String</code> values is a single <code>String</code> value, the first string followed by the second.</p>
<p class="image"><img alt="image" src="graphics/t0034-01.jpg"/></p>
<p><a id="ch01sec3lev32"/></p>
<h5><em>Conversion</em></h5>
<p>Two primary uses of strings are to convert values that we can enter on a keyboard into data-type values and to convert data-type values to values that we can read on a display. Java has built-in operations for <code>String</code> to facilitate these operations. In particular, the language includes libraries <code>Integer</code> and <code>Double</code> that contain static methods to convert between <code>String</code> values and <code>int</code> values and between <code>String</code> values and <code>double</code> values, respectively.</p>
<p class="image"><img alt="image" src="graphics/t0034-02.jpg"/></p>
<p><a id="ch01sec3lev33"/></p>
<h5><a id="page_35"/><em>Automatic conversion</em></h5>
<p>We rarely explicitly use the static <code>toString()</code> methods just described because Java has a built-in mechanism that allows us to convert from any data type value to a <code>String</code> value by using concatenation: if <em>one</em> of the arguments of <code>+</code> is a <code>String</code>, Java <em>automatically</em> converts the other argument to a <code>String</code> (if it is not already a <code>String</code>). Beyond usage like <code>"The square root of 2.0 is " + Math.sqrt(2.0)</code> this mechanism enables conversion of any data-type value to a <code>String</code>, by concatenating it with the empty string <code>""</code>.</p>
<p><a id="ch01sec3lev34"/></p>
<h5><em>Command-line arguments</em></h5>
<p>One important use of strings in Java programming is to enable a mechanism for passing information from the command line to the program. The mechanism is simple. When you type the <code>java</code> command followed by a library name followed by a sequence of strings, the Java system invokes the <code>main()</code> method in that library with an <em>array of strings</em> as argument: the strings typed after the library name. For example, the <code>main()</code> method in <code>BinarySearch</code> takes one command-line argument, so the system creates an array of size one. The program uses that value, <code>args[0]</code>, to name the file containing the whitelist, for use as the argument to <code>In.readInts()</code>. Another typical paradigm that we often use in our code is when a command-line argument is intended to represent a number, so we use <code>parseInt()</code> to convert to an <code>int</code> value or <code>parseDouble()</code> to convert to a <code>double</code> value.</p>
<p><small>COMPUTING WITH STRINGS</small> is an essential component of modern computing. For the moment, we make use of <code>String</code> just to convert between external representation of numbers as sequences of characters and internal representation of numeric data-type values. In <a href="#ch01sec1lev4"><small>SECTION 1.2</small></a>, we will see that Java supports many, many more operations on <code>String</code> values that we use throughout the book; in <a href="ch01a.html#ch01sec1lev6"><small>SECTION 1.4</small></a>, we will examine the internal representation of <code>String</code> values; and in <a href="ch05.html#ch05"><small>CHAPTER 5</small></a>, we consider in depth algorithms that process <code>String</code> data. These algorithms are among the most interesting, intricate, and impactful methods that we consider in this book.</p>
<p><a id="ch01sec2lev9"/></p>
<h4><a id="page_36"/>Input and output</h4>
<p>The primary purpose of our standard libraries for input, output, and drawing is to support a simple model for Java programs to interact with the outside world. These libraries are built upon extensive capabilities that are available in Java libraries, but are generally much more complicated and much more difficult to learn and use. We begin by briefly reviewing the model.</p>
<p>In our model, a Java program takes input values from <em>command-line arguments</em> or from an abstract stream of characters known as the <em>standard input stream</em> and writes to another abstract stream of characters known as the <em>standard output stream</em>.</p>
<p class="image"><img alt="image" src="graphics/01_04-birdseyeio.jpg"/></p>
<p>Necessarily, we need to consider the interface between Java and the operating system, so we need to briefly discuss basic mechanisms that are provided by most modern operating systems and program-development environments. You can find more details about your particular system on the booksite. By default, command-line arguments, standard input, and standard output are associated with an application supported by either the operating system or the program development environment that takes commands. We use the generic term <em>terminal window</em> to refer to the window maintained by this application, where we type and read text. Since early Unix systems in the 1970s this model has proven to be a convenient and direct way for us to interact with our programs and data. We add to the classical model a <em>standard drawing</em> that allows us to create visual representations for data analysis.</p>
<p><a id="ch01sec3lev35"/></p>
<h5><em>Commands and arguments</em></h5>
<p>In the terminal window, we see a prompt, where we type <em>commands</em> to the operating system that may take <em>arguments</em>. We use only a few commands in this book, shown in the table below. Most often, we use the <code>.java</code> command, to run our programs. As mentioned on page <a href="#ch01sec3lev33">35</a>, Java classes have a <code>main()</code> static method that takes a <code>String</code> array <code>args[]</code> as its argument. That array is the sequence of command-line arguments that we type, provided to Java by the operating system. By convention, both Java and the operating system process the arguments as strings. If we intend for an argument to be a number, we use a method such as <code>Integer.parseInt()</code> to convert it from <code>String</code> to the appropriate type.</p>
<p class="image"><img alt="image" src="graphics/t0036-01.jpg"/></p>
<p><a id="ch01sec3lev36"/></p>
<h5><a id="page_37"/><em>Standard output</em></h5>
<p>Our <code>StdOut</code> library provides support for standard output. By default, the system connects standard output to the terminal window. The <code>print()</code> method puts its argument on standard output; the <code>println()</code> method adds a newline; and the <code>printf()</code> method supports formatted output, as described next. Java provides a similar method in its <code>System.out</code> library; we use <code>StdOut</code> to treat standard input and standard output in a uniform manner (and to provide a few technical improvements).</p>
<p class="image"><img alt="image" src="graphics/01_05-anatomycommand.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0037-01.jpg"/></p>
<p>To use these methods, download into your working directory <code>StdOut.java</code> from the booksite and use code such as S<code>tdOut.println("Hello, World");</code> to call them. A sample client is shown at right.</p>
<p class="image"><img alt="image" src="graphics/p0037-01.jpg"/></p>
<p><a id="ch01sec3lev37"/></p>
<h5><em>Formatted output</em></h5>
<p>In its simplest form, <code>printf()</code> takes two arguments. The first argument is a <em>format string</em> that describes how the second argument is to be converted to a string for output. The simplest type of format string begins with <code>%</code> and ends with a one-letter <em>conversion code</em>. The conversion codes that we use most frequently are <code>d</code> (for decimal values from Java’s integer types), <code>f</code> (for floating-point values), and <code>s</code> (for <code>String</code> values). Between the <code>%</code> and the conversion code is an integer value that specifies the <em>field width</em> of the <a id="page_38"/>converted value (the number of characters in the converted output string). By default, blank spaces are added on the left to make the length of the converted output equal to the field width; if we want the spaces on the right, we can insert a minus sign before the field width. (If the converted output string is bigger than the field width, the field width is ignored.) Following the width, we have the option of including a period followed by the number of digits to put after the decimal point (the precision) for a <code>double</code> value or the number of characters to take from the beginning of the string for a <code>String</code> value. The most important thing to remember about using <code>printf()</code> is that <em>the conversion code in the format and the type of the corresponding argument must match</em>. That is, Java must be able to convert from the type of the argument to the type required by the conversion code. The first argument of <code>printf()</code> is a <code>String</code> that may contain characters other than a format string. Any part of the argument that is not part of a format string passes through to the output, with the format string replaced by the argument value (converted to a <code>String</code> as specified). For example, the statement</p>
<p class="programlisting">StdOut.printf("PI is approximately %.2f\n", Math.PI);</p>
<p class="image"><img alt="image" src="graphics/p0037-02.jpg"/></p>
<p>prints the line</p>
<p class="programlisting">PI is approximately 3.14</p>
<p>Note that we need to explicitly include the newline character <code>\n</code> in the argument in order to print a new line with <code>printf()</code>. The <code>printf()</code> function can take more than two arguments. In this case, the format string will have a format specifier for each additional argument, perhaps separated by other characters to pass through to the output. You can also use the static method <code>String.format()</code> with arguments exactly as just described for <code>printf()</code> to get a formatted string without printing it. Formatted printing is a convenient mechanism that allows us to develop compact code that can produce tabulated experimental data (our primary use in this book).</p>
<p class="image"><img alt="image" src="graphics/t0038-01.jpg"/></p>
<p><a id="ch01sec3lev38"/></p>
<h5><a id="page_39"/><em>Standard input</em></h5>
<p>Our <code>StdIn</code> library takes data from the standard input stream that may be empty or may contain a sequence of values separated by whitespace (spaces, tabs, newline characters, and the like). By default, the system connects standard output to the terminal window—what you type is the input stream (terminated by <code>&lt;ctrl-d&gt;</code> or <code>&lt;ctrl-z&gt;</code>, depending on your terminal window application). Each value is a <code>String</code> or a value from one of Java’s primitive types. One of the key features of the standard input stream is that your program consumes values when it reads them. Once your program has read a value, it cannot back up and read it again. This assumption is restrictive, but it reflects physical characteristics of some input devices and simplifies implementing the abstraction. Within the input stream model, the static methods in this library are largely self-documenting (described by their signatures).</p>
<p class="image"><img alt="image" src="graphics/p0039-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/p0039-02.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0039-01.jpg"/></p>
<p><a id="ch01sec3lev39"/></p>
<h5><a id="page_40"/><em>Redirection and piping</em></h5>
<p>Standard input and output enable us to take advantage of command-line extensions supported by many operating-systems. By adding a simple directive to the command that invokes a program, we can <em>redirect</em> its standard output to a file, either for permanent storage or for input to another program at a later time:</p>
<p class="programlisting">% java RandomSeq 1000 100.0 200.0 &gt; data.txt</p>
<p>This command specifies that the standard output stream is not to be printed in the terminal window, but instead is to be written to a text file named <code>data.txt</code>. Each call to <code>StdOut.print()</code> or <code>StdOut.println()</code> appends text at the end of that file. In this example, the end result is a file that contains 1,000 random values. No output appears in the terminal window: it goes directly into the file named after the <code>&gt;</code> symbol. Thus, we can save away information for later retrieval. Note that we do not have to change <code>RandomSeq</code> in any way—it is using the standard output abstraction and is unaffected by our use of a different implementation of that abstraction. Similarly, we can redirect standard input so that <code>StdIn</code> reads data from a file instead of the terminal application:</p>
<p class="programlisting"><img alt="image" src="graphics/p0040-02.jpg"/></p>
<p class="image"><img alt="image" src="graphics/01_06_redirect-pipe.jpg"/></p>
<p>This command reads a sequence of numbers from the file <code>data.txt</code> and computes their average value. Specifically, the <code>&lt;</code> symbol is a directive that tells the operating system to implement the standard input stream by reading from the text file <code>data.txt</code> instead of waiting for the user to type something into the terminal window. When the program calls <code>StdIn.readDouble()</code>, the operating system reads the value from the file. Combining these to redirect the output of one program to the input of another is known as <em>piping</em>:</p>
<p class="programlisting"><img alt="image" src="graphics/p0040-03.jpg"/></p>
<p><a id="page_41"/>This command specifies that standard output for <code>RandomSeq</code> and standard input for <code>Average</code> are the same stream. The effect is as if <code>RandomSeq</code> were typing the numbers it generates into the terminal window while <code>Average</code> is running. This difference is profound, because it removes the limitation on the size of the input and output streams that we can process. For example, we could replace <code>1000</code> in our example with <code>1000000000</code>, even though we might not have the space to save a billion numbers on our computer (we do need the time to process them). When <code>RandomSeq</code> calls <code>StdOut.println()</code>, a string is added to the end of the stream; when <code>Average</code> calls <code>StdIn</code>.<code>readInt()</code>, a string is removed from the beginning of the stream. The timing of precisely what happens is up to the operating system: it might run <code>RandomSeq</code> until it produces some numbers, and then run <code>Average</code> to consume those numbers, or it might run <code>Average</code> until it needs to consume a number, and then run <code>RandomSeq</code> until it produces the needed output. The end result is the same, but our programs are freed from worrying about such details because they work solely with the standard input and standard output abstractions.</p>
<p><a id="ch01sec3lev40"/></p>
<h5><em>Input and output from a file</em></h5>
<p>Our <code>In</code> and <code>Out</code> libraries provide static methods that implement the abstraction of reading from and writing to a file the contents of an array of values of a primitive type (or <code>String</code>). We use <code>readInts()</code>, <code>readDoubles()</code>, and <code>readStrings()</code> in the <code>In</code> library and <code>writeInts()</code>, <code>writeDoubles()</code>, and <code>writeStrings()</code> in the <code>Out</code> library. The named argument can be a file or a web page. For example, this ability allows us to use a file and standard input for two different purposes in the same program, as in <code>BinarySearch</code>. The <code>In</code> and <code>Out</code> libraries also implement data types with instance methods that allow us the more general ability to treat multiple files as input and output streams, and web pages as input streams, so we will revisit them in <a href="#ch01sec1lev4"><small>SECTION 1.2</small></a>.</p>
<p class="image"><img alt="image" src="graphics/t0041-01.jpg"/></p>
<p><a id="ch01sec3lev41"/></p>
<h5><a id="page_42"/><em>Standard drawing (basic methods)</em></h5>
<p>Up to this point, our input/output abstractions have focused exclusively on text strings. Now we introduce an abstraction for producing drawings as output. This library is easy to use and allows us to take advantage of a visual medium to cope with far more information than is possible with just text. As with standard input/output, our standard drawing abstraction is implemented in a library <code>StdDraw</code> that you can access by downloading the file <code>StdDraw.java</code> from the booksite into your working directory. Standard draw is very simple: we imagine an abstract drawing device capable of drawing lines and points on a two-dimensional canvas. The device is capable of responding to the commands to draw basic geometric shapes that our programs issue in the form of calls to static methods in <code>StdDraw</code>, including methods for drawing lines, points, text strings, circles, rectangles, and polygons. Like the methods for standard input and standard output, these methods are nearly self-documenting: <code>StdDraw.line()</code> draws a straight line segment connecting the point (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>) with the point (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>) whose coordinates are given as arguments. <code>StdDraw.point()</code> draws a spot centered on the point (<em>x</em>, <em>y</em>) whose coordinates are given as arguments, and so forth, as illustrated in the diagrams at right. Geometric shapes can be filled (in black, by default). The default scale is the unit square (all coordinates are between 0 and 1). The standard implementation displays the canvas in a window on your computer’s screen, with black lines and points on a white background.</p>
<p class="image"><img alt="image" src="graphics/01_07-stddrawshapes.jpg"/></p>
<p class="image"><a id="page_43"/><img alt="image" src="graphics/t0043-01.jpg"/></p>
<p><a id="ch01sec3lev42"/></p>
<h5><em>Standard drawing (control methods)</em></h5>
<p>The library also includes methods to change the scale and size of the canvas, the color and width of the lines, the text font, and the timing of drawing (for use in animation). As arguments for <code>setPenColor()</code> you can use one of the predefined colors <code>BLACK</code>, <code>BLUE</code>, <code>CYAN</code>, <code>DARK_GRAY</code>, <code>GRAY</code>, <code>GREEN</code>, <code>LIGHT_GRAY</code>, <code>MAGENTA</code>, <code>ORANGE</code>, <code>PINK</code>, <code>RED</code>, <code>BOOK_RED</code>, <code>WHITE</code>, and <code>YELLOW</code> that are defined as constants in <code>StdDraw</code> (so we refer to one of them with code like <code>StdDraw.RED</code>). The window also includes a menu option to save your drawing to a file, in a format suitable for publishing on the web.</p>
<p class="image"><img alt="image" src="graphics/t0043-02.jpg"/></p>
<p><a id="page_44"/><small>IN THIS BOOK</small>, we use <code>StdDraw</code> for data analysis and for creating visual representations of algorithms in operation. The table at on the opposite page indicates some possiblities; we will consider many more examples in the text and the exercises throughout the book. The library also supports <em>animation</em>—of course, this topic is treated primarily on the booksite.</p>
<p class="image"><a id="page_45"/><img alt="image" src="graphics/t0045-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0045-02.jpg"/></p>
<p><a id="ch01sec2lev10"/></p>
<h4><a id="page_46"/>Binary search</h4>
<p>The sample Java program that we started with, shown on the facing page, is based on the famous, effective, and widely used <em>binary search</em> algorithm. This example is a prototype of the way in which we will examine new algorithms throughout the book. As with all of the programs we consider, it is both a precise definition of the method and a complete Java implementation that you can download from the booksite.</p>
<p><a id="ch01sec3lev43"/></p>
<h5><em>Binary search</em></h5>
<p>We will study the binary search algorithm in detail in <a href="ch03.html#ch03sec1lev2"><small>SECTION 3.2</small></a>, but a brief description is appropriate here. The algorithm is implemented in the static method <code>rank()</code>, which takes an integer key and a <em>sorted</em> array of <code>int</code> values as arguments and returns the index of the key if it is present in the array, <code>-1</code> otherwise. It accomplishes this task by maintaining variables <code>lo</code> and <code>hi</code> such that the key is in <code>a[lo..hi]</code> if it is in the array, then entering into a loop that tests the middle entry in the interval (at index <code>mid</code>). If the key is equal to <code>a[mid]</code>, the return value is <code>mid</code>; otherwise the method cuts the interval size about in half, looking at the left half if the key is less than <code>a[mid]</code> and at the right half if the key is greater than <code>a[mid]</code>. The process terminates when the key is found or the interval is empty. Binary search is effective because it needs to examine just a few array entries (relative to the size of the array) to find the key (or determine that it is not there).</p>
<p class="image"><img alt="image" src="graphics/01_11-bs.jpg"/></p>
<p><a id="ch01sec3lev44"/></p>
<h5><em>Development client</em></h5>
<p>For every algorithm implementation, we include a development client <code>main()</code> that you can use with sample input files provided in the book and on the booksite to learn about the algorithm and to test its performance. In this example, the client reads integers from the file named on the command line, then prints any integers on standard input that do not appear in the file. We use small test files such as those shown at right to demonstrate this behavior, and as the basis for traces and examples such as those at left above. We use large test files to model real-world applications and to test performance (see page <a href="#ch01sec3lev45">48</a>).</p>
<p class="image"><img alt="image" src="graphics/01_12-testbs.jpg"/></p>
<div class="sidebar">
<hr/>
<p><a id="ch01sb02"/></p>
<h3><a id="page_47"/>Binary Search</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0047-01.jpg"/></p>
<p>This program takes the name of a whitelist file (a sequence of integers) as argument and filters any entry that is on the whitelist from standard input, leaving only integers that are not on the whitelist on standard output. It uses the binary search algorithm, implemented in the static method <code>rank()</code>, to accomplish the task efficiently. See <a href="ch03.html#ch03sec1lev1"><small>SECTION 3.1</small></a> for a full discussion of the binary search algorithm, its correctness, its performance analysis, and its applications.</p>
<p class="image"><img alt="image" src="graphics/p0047-02.jpg"/></p>
<hr/>
</div>
<p><a id="ch01sec3lev45"/></p>
<h5><a id="page_48"/><em>Whitelisting</em></h5>
<p>When possible, our development clients are intended to mirror practical situations and demonstrate the need for the algorithm at hand. In this case, the process is known as <em>whitelisting</em>. Specifically, imagine a credit card company that needs to check whether customer transactions are for a valid account. To do so, it can</p>
<p class="indenthangingB">• Keep customers account numbers in a file, which we refer to as a <em>whitelist</em>.</p>
<p class="indenthangingB">• Produce the account number associated with each transaction in the standard input stream.</p>
<p class="indenthangingB">• Use the test client to put onto standard output the numbers that are <em>not</em> associated with any customer. Presumably the company would refuse such transactions.</p>
<p>It would not be unusual for a big company with millions of customers to have to process millions of transactions or more. To model this situation, we provide on the booksite the files <code>largeW.txt</code> (1 million integers) and <code>largeT.txt</code> (10 million integers).</p>
<p><a id="ch01sec3lev46"/></p>
<h5><em>Performance</em></h5>
<p>A working program is often not sufficient. For example, a much simpler implementation of <code>rank()</code>, which does not even require the array to be sorted, is to check every entry, as follows:</p>
<p class="programlisting"><img alt="image" src="graphics/p0048-01.jpg"/></p>
<p>Given this simple and easy-to-understand solution, why do we use mergesort and binary search? If you work <a href="#ch01qa1q38"><small>EXERCISE 1.1.38</small></a>, you will see that your computer is too slow to run this brute-force implementation of <code>rank()</code> for large numbers of inputs (say, 1 million whitelist entries and 10 million transactions). <em>Solving the whitelist problem for a large number of inputs is not feasible without efficient algorithms such as binary search and mergesort.</em> Good performance is often of critical importance, so we lay the groundwork for studying performance in <a href="ch01a.html#ch01sec1lev6"><small>SECTION 1.4</small></a> and analyze the performance characteristics of all of our algorithms (including binary search, in <a href="ch03.html#ch03sec1lev1"><small>SECTION 3.1</small></a> and mergesort, in <a href="ch02.html#ch02sec1lev2"><small>SECTION 2.2</small></a>).</p>
<p><small>IN THE PRESENT CONTEXT</small>, our goal in thoroughly outlining our programming model is to ensure that you can run code like <code>BinarySearch</code> on your computer, use it on test data like ours, and modify it to adapt to various situations (such as those described in the exercises at the end of this section), in order to best understand its applicability. The programming model that we have sketched is designed to facilitate such activities, which are crucial to our approach to studying algorithms.</p>
<p class="image"><a id="page_49"/><img alt="image" src="graphics/01_13-testbslarge.jpg"/></p>
<p><a id="ch01sec2lev11"/></p>
<h4><a id="page_50"/>Perspective</h4>
<p>In this section, we have described a fine and complete programming model that served (and still serves) many programmers for many decades. Modern programming, however, goes one step further. This next level is called <em>data abstraction</em>, sometimes known as <em>object-oriented programming</em>, and is the subject of the next section. Simply put, the idea behind data abstraction is to allow a program to define <em>data types</em> (sets of values and sets of operations on those values), not just static methods that operate on predefined data types.</p>
<p>Object-oriented programming has come into widespread use in recent decades, and data abstraction is central to modern program development. We embrace data abstraction in this book for three primary reasons:</p>
<p class="indenthangingB">• It enables us to expand our ability to reuse code through modular programming. For example, our sorts in <a href="ch02.html#ch02"><small>CHAPTER 2</small></a> and binary search and other algorithms in <a href="ch03.html#ch03"><small>CHAPTER 3</small></a> allow clients to make use of the same code for any type of data (not just integers), including one defined by the client.</p>
<p class="indenthangingB">• It provides a convenient mechanism for building so-called <em>linked</em> data structures that provide more flexibility than arrays and are the basis of efficient algorithms in many settings.</p>
<p class="indenthangingB">• It enables us to precisely define the algorithmic challenges that we face. For example, our union-find algorithms in <a href="ch01a.html#ch01sec1lev7"><small>SECTION 1.5</small></a>, our priority-queue algorithms in <a href="ch02.html#ch02sec1lev4"><small>SECTION 2.4</small></a>, and our symbol-table algorithms in <a href="ch03.html#ch03"><small>CHAPTER 3</small></a> are all oriented toward defining data structures that enable efficient implementations of a <em>set</em> of operations. This challenge aligns perfectly with data abstraction.</p>
<p>Despite all of these considerations, our focus remains on the study of algorithms. In this context, we proceed to consider next the essential features of object-oriented programming that are relevant to our mission.</p>
<p><a id="ch01sec2lev12"/></p>
<h4><a id="page_51"/>Q&amp;A</h4>
<p><strong>Q.</strong> What is Java bytecode?</p>
<p><strong>A.</strong> A low-level version of your program that runs on the Java <em>virtual machine</em>. This level of abstraction makes it easier for the developers of Java to ensure that our programs run on a broad variety of devices.</p>
<p><strong>Q.</strong> It seems wrong that Java should just let <code>int</code>s overflow and give bad values. Shouldn’t Java automatically check for overflow?</p>
<p><strong>A.</strong> This issue is a contentious one among programmers. The short answer is that the lack of such checking is one reason such types are called <em>primitive</em> data types. A little knowledge can go a long way in avoiding such problems. We use the <code>int</code> type for small numbers (less than ten decimal digits), and the <code>long</code> type when values run into the billions or more.</p>
<p><strong>Q.</strong> What is the value of <code>Math.abs(-2147483648)</code>?</p>
<p><strong>A.</strong> <code>-2147483648</code>. This strange (but true) result is a typical example of the effects of integer overflow.</p>
<p><strong>Q.</strong> How can I initialize a <code>double</code> variable to infinity?</p>
<p><strong>A.</strong> Java has built-in constants available for this purpose: <code>Double.POSITIVE_INFINITY</code> and <code>Double.NEGATIVE_INFINITY</code>.</p>
<p><strong>Q.</strong> Can you compare a <code>double</code> to an <code>int</code>?</p>
<p><strong>A.</strong> Not without doing a type conversion, but remember that Java usually does the requisite type conversion automatically. For example, if <code>x</code> is an <code>int</code> with the value <code>3</code>, then the expression <code>(x &lt; 3.1)</code> is <code>true</code>—Java converts <code>x</code> to <code>double</code> (because <code>3.1</code> is a <code>double</code> literal) before performing the comparison.</p>
<p><strong>Q.</strong> What happens if I use a variable before initializing it to a value?</p>
<p><strong>A.</strong> Java will report a compile-time error if there is any path through your code that would lead to use of an uninitialized variable.</p>
<p><strong>Q.</strong> What are the values of <code>1/0</code> and <code>1.0/0.0</code> as Java expressions?</p>
<p><strong>A.</strong> The first generates a runtime <em>exception</em> for division by zero (which stops your program because the value is undefined); the second has the value <code>Infinity</code>.</p>
<p><a id="page_52"/><strong>Q.</strong> Can you use <code>&lt;</code> and <code>&gt;</code> to compare <code>String</code> variables?</p>
<p><strong>A.</strong> No. Those operators are defined only for primitive types. See page <a href="#ch01sec3lev61">80</a>.</p>
<p><strong>Q.</strong> What is the result of division and remainder for negative integers?</p>
<p><strong>A.</strong> The quotient <code>a/b</code> rounds toward <code>0</code>; the remainder <code>a % b</code> is defined such that <code>(a / b) * b + a % b</code> is always equal to <code>a</code>. For example, <code>-14/3</code> and <code>14/-3</code> are both <code>-4</code>, but <code>-14 % 3</code> is <code>-2</code> and <code>14 % -3</code> is <code>2</code>.</p>
<p><strong>Q.</strong> Why do we say <code>(a &amp;&amp; b)</code> and not <code>(a &amp; b)</code>?</p>
<p><strong>A.</strong> The operators <code>&amp;</code>, <code>|</code>, and <code>^</code> are <em>bitwise</em> logical operations for integer types that do <em>and</em>, <em>or</em>, and <em>exclusive or</em> (respectively) on each bit position. Thus the value of <code>10&amp;6</code> is <code>2</code>, the value of <code>10|6</code> is <code>14</code> and the value of <code>10^6</code> is <code>12</code>. We use these operators rarely (but occasionally) in this book. The operators <code>&amp;&amp;</code> and <code>||</code> are valid only in boolean expressions are included separately because of <em>short-circuiting</em>: an expression is evaluated left-to-right and the evaluation stops when the value is known.</p>
<p><strong>Q.</strong> Is ambiguity in nested <code>if</code> statements a problem?</p>
<p><strong>A.</strong> Yes. In Java, when you write</p>
<p class="programlisting">if &lt;<span class="em">expr1</span>&gt; if &lt;<span class="em">expr2</span>&gt; &lt;<span class="em">stmntA</span>&gt; else &lt;<span class="em">stmntB</span>&gt;</p>
<p>it is equivalent to</p>
<p class="programlisting">if <span class="em">&lt;expr1&gt;</span> { if &lt;<span class="em">expr2</span>&gt; &lt;<span class="em">stmntA</span>&gt; else &lt;<span class="em">stmntB</span>&gt; }</p>
<p>even if you might have been thinking</p>
<p class="programlisting">if <span class="em">&lt;expr1&gt;</span> { if &lt;<span class="em">expr2</span>&gt; &lt;<span class="em">stmntA</span>&gt; } else &lt;<span class="em">stmntB</span>&gt;</p>
<p>Using explicit braces is a good way to avoid this <em>dangling else</em> pitfall.</p>
<p><strong>Q.</strong> What is the difference between a <code>for</code> loop and its <code>while</code> formulation?</p>
<p><strong>A.</strong> The code in the <code>for</code> loop header is considered to be in the same block as the <code>for</code> loop body. In a typical <code>for</code> loop, the incrementing variable is not available for use in later statements; in the corresponding <code>while</code> loop, it is. This distinction is often a reason to use a <code>while</code> instead of a <code>for</code> loop.</p>
<p><strong>Q.</strong> Some Java programmers use <code>int a[]</code> instead of <code>int[] a</code> to declare arrays. What’s the difference?</p>
<p><a id="page_53"/><strong>A.</strong> In Java, both are legal and equivalent. The former is how arrays are declared in C. The latter is the preferred style in Java since the type of the variable <code>int[]</code> more clearly indicates that it is an <em>array</em> of integers.</p>
<p><strong>Q.</strong> Why do array indices start at <code>0</code> instead of <code>1</code>?</p>
<p><strong>A.</strong> This convention originated with machine-language programming, where the address of an array element would be computed by adding the index to the address of the beginning of an array. Starting indices at <code>1</code> would entail either a waste of space at the beginning of the array or a waste of time to subtract the <code>1</code>.</p>
<p><strong>Q.</strong> If <code>a[]</code> is an array, why does <code>StdOut.println(a)</code> print out a hexadecimal integer, such as <code>@f62373</code>, instead of the elements of the array?</p>
<p><strong>A.</strong> Good question. It is printing out the memory address of the array, which, unfortunately, is rarely what you want.</p>
<p><strong>Q.</strong> Why are we not using the standard Java libraries for input and graphics?</p>
<p><strong>A.</strong> We <em>are</em> using them, but we prefer to work with simpler abstract models. The Java libraries behind <code>StdIn</code> and <code>StdDraw</code> are built for production programming, and the libraries and their APIs are a bit unwieldy. To get an idea of what they are like, look at the code in <code>StdIn.java</code> and <code>StdDraw.java</code>.</p>
<p><strong>Q.</strong> Can my program reread data from standard input?</p>
<p><strong>A.</strong> No. You only get one shot at it, in the same way that you cannot undo <code>println()</code>.</p>
<p><strong>Q.</strong> What happens if my program attempts to read after standard input is exhausted?</p>
<p><strong>A.</strong> You will get an error. <code>StdIn.isEmpty()</code> allows you to avoid such an error by checking whether there is more input available.</p>
<p><strong>Q.</strong> What does this error message mean?</p>
<p class="programlisting1">Exception in thread "main" java.lang.NoClassDefFoundError: StdIn</p>
<p><strong>A.</strong> You probably forgot to put <code>StdIn.java</code> in your working directory.</p>
<p><strong>Q.</strong> Can a static method take another static method as an argument in Java?</p>
<p><strong>A.</strong> No. Good question, since many other languages do support this capability.</p>
<p><a id="ch01sec2lev13"/></p>
<h4><a id="page_54"/>Exercises</h4>
<p><a id="ch01qa1q1"/><strong>1.1.1</strong> Give the value of each of the following expressions:</p>
<p class="indenthangingN"><em>a.</em> <code>( 0 + 15 ) / 2</code></p>
<p class="indenthangingN"><em>b.</em> <code>2.0e-6 * 100000000.1</code></p>
<p class="indenthangingN"><em>c.</em> <code>true &amp;&amp; false || true &amp;&amp; true</code></p>
<p><a id="ch01qa1q2"/><strong>1.1.2</strong> Give the type and value of each of the following expressions:</p>
<p class="indenthangingN"><em>a.</em> <code>(1 + 2.236)/2</code></p>
<p class="indenthangingN"><em>b.</em> <code>1 + 2 + 3 + 4.0</code></p>
<p class="indenthangingN"><em>c.</em> <code>4.1 &gt;= 4</code></p>
<p class="indenthangingN"><em>d.</em> <code>1 + 2 + "3"</code></p>
<p><a id="ch01qa1q3"/><strong>1.1.3</strong> Write a program that takes three integer command-line arguments and prints <code>equal</code> if all three are equal, and <code>not equal</code> otherwise.</p>
<p><a id="ch01qa1q4"/><strong>1.1.4</strong> What (if anything) is wrong with each of the following statements?</p>
<p class="indenthangingN"><em>a.</em> <code>if (a &gt; b) then c = 0;</code></p>
<p class="indenthangingN"><em>b.</em> <code>if a &gt; b { c = 0; }</code></p>
<p class="indenthangingN"><em>c.</em> <code>if (a &gt; b) c = 0;</code></p>
<p class="indenthangingN"><em>d.</em> <code>if (a &gt; b) c = 0 else b = 0;</code></p>
<p><a id="ch01qa1q5"/><strong>1.1.5</strong> Write a code fragment that prints <code>true</code> if the <code>double</code> variables <code>x</code> and <code>y</code> are both strictly between <code>0</code> and <code>1</code> and <code>false</code> otherwise.</p>
<p><a id="ch01qa1q6"/><strong>1.1.6</strong> What does the following program print?</p>
<p class="programlisting"><img alt="image" src="graphics/p0054-01.jpg"/></p>
<p><a id="page_55"/><a id="ch01qa1q7"/><strong>1.1.7</strong> Give the value printed by each of the following code fragments:</p>
<p class="indenthangingN"><img alt="image" src="graphics/p0055-01.jpg"/></p>
<p><a id="ch01qa1q8"/><strong>1.1.8</strong> What do each of the following print?</p>
<p class="indenthangingN"><em>a.</em> <code>System.out.println('b');</code></p>
<p class="indenthangingN"><em>b.</em> <code>System.out.println('b' + 'c');</code></p>
<p class="indenthangingN"><em>c.</em> <code>System.out.println((char) ('a' + 4));</code></p>
<p>Explain each outcome.</p>
<p><a id="ch01qa1q9"/><strong>1.1.9</strong> Write a code fragment that puts the binary representation of a positive integer <code>N</code> into a <code>String s</code>.</p>
<p><em>Solution</em>: Java has a built-in method <code>Integer.toBinaryString(N)</code> for this job, but the point of the exercise is to see how such a method might be implemented. Here is a particularly concise solution:</p>
<p class="programlisting"><img alt="image" src="graphics/p0055-04.jpg"/></p>
<p><a id="page_56"/><a id="ch01qa1q10"/><strong>1.1.10</strong> What is wrong with the following code fragment?</p>
<p class="programlisting"><img alt="image" src="graphics/p0056-01.jpg"/></p>
<p><em>Solution</em>: It does not allocate memory for <code>a[]</code> with <code>new</code>. This code results in a <code>variable a might not have been initialized</code> compile-time error.</p>
<p><a id="ch01qa1q11"/><strong>1.1.11</strong> Write a code fragment that prints the contents of a two-dimensional boolean array, using <code>*</code> to represent <code>true</code> and a space to represent <code>false</code>. Include row and column numbers.</p>
<p><a id="ch01qa1q12"/><strong>1.1.12</strong> What does the following code fragment print?</p>
<p class="programlisting"><img alt="image" src="graphics/p0056-02.jpg"/></p>
<p><a id="ch01qa1q13"/><strong>1.1.13</strong> Write a code fragment to print the <em>transposition</em> (rows and columns changed) of a two-dimensional array with <em>M</em> rows and <em>N</em> columns.</p>
<p><a id="ch01qa1q14"/><strong>1.1.14</strong> Write a static method <code>lg()</code> that takes an <code>int</code> value <code>N</code> as argument and returns the largest <code>int</code> not larger than the base-2 logarithm of <code>N</code>. Do <em>not</em> use <code>Math</code>.</p>
<p><a id="ch01qa1q15"/><strong>1.1.15</strong> Write a static method <code>histogram()</code> that takes an array <code>a[]</code> of <code>int</code> values and an integer <code>M</code> as arguments and returns an array of length <code>M</code> whose <code>i</code>th entry is the number of times the integer <code>i</code> appeared in the argument array. If the values in <code>a[]</code> are all between <code>0</code> and <code>M−1</code>, the sum of the values in the returned array should be equal to <code>a.length</code>.</p>
<p><a id="ch01qa1q16"/><strong>1.1.16</strong> Give the value of <code>exR1(6)</code>:</p>
<p class="programlisting"><img alt="image" src="graphics/p0056-03.jpg"/></p>
<p><a id="page_57"/><a id="ch01qa1q17"/><strong>1.1.17</strong> Criticize the following recursive function:</p>
<p class="programlisting"><img alt="image" src="graphics/p0057-01.jpg"/></p>
<p><em>Answer</em>: The base case will never be reached. A call to <code>exR2(3)</code> will result in calls to <code>exR2(0)</code>, <code>exR2(-3)</code>, <code>exR3(-6)</code>, and so forth until a <code>StackOverflowError</code> occurs.</p>
<p><a id="ch01qa1q18"/><strong>1.1.18</strong> Consider the following recursive function:</p>
<p class="programlisting"><img alt="image" src="graphics/p0057-02.jpg"/></p>
<p>What are the values of <code>mystery(2, 25)</code> and <code>mystery(3, 11)</code>? Given positive integers <code>a</code> and <code>b</code>, describe what value <code>mystery(a, b)</code> computes. Answer the same question, but replace <code>+</code> with <code>*</code> and replace <code>return 0</code> with <code>return 1</code>.</p>
<p><a id="ch01qa1q19"/><strong>1.1.19</strong> Run the following program on your computer:</p>
<p class="programlisting"><img alt="image" src="graphics/p0057-03.jpg"/></p>
<p><a id="page_58"/>What is the largest value of <code>N</code> for which this program takes less 1 hour to compute the value of <code>F(N)</code>? Develop a better implementation of <code>F(N)</code> that saves computed values in an array.</p>
<p><a id="ch01qa1q20"/><strong>1.1.20</strong> Write a recursive static method that computes the value of ln (<em>N</em>!)</p>
<p><a id="ch01qa1q21"/><strong>1.1.21</strong> Write a program that reads in lines from standard input with each line containing a name and two integers and then uses <code>printf()</code> to print a table with a column of the names, the integers, and the result of dividing the first by the second, accurate to three decimal places. You could use a program like this to tabulate batting averages for baseball players or grades for students.</p>
<p><a id="ch01qa1q22"/><strong>1.1.22</strong> Write a version of <code>BinarySearch</code> that uses the recursive <code>rank()</code> given on page <a href="#ch01sec3lev22">25</a> and <em>traces</em> the method calls. Each time the recursive method is called, print the argument values <code>lo</code> and <code>hi</code>, indented by the depth of the recursion. <em>Hint</em>: Add an argument to the recursive method that keeps track of the depth.</p>
<p><a id="ch01qa1q23"/><strong>1.1.23</strong> Add to the <code>BinarySearch</code> test client the ability to respond to a second argument: <code>+</code> to print numbers from standard input that <em>are not</em> in the whitelist, <code>-</code> to print numbers that <em>are</em> in the whitelist.</p>
<p><a id="ch01qa1q24"/><strong>1.1.24</strong> Give the sequence of values of <em>p</em> and <em>q</em> that are computed when Euclid’s algorithm is used to compute the greatest common divisor of 105 and 24. Extend the code given on page <a href="#ch01sec1lev1">4</a> to develop a program <code>Euclid</code> that takes two integers from the command line and computes their greatest common divisor, printing out the two arguments for each call on the recursive method. Use your program to compute the greatest common divisor of 1111111 and 1234567.</p>
<p><a id="ch01qa1q25"/><strong>1.1.25</strong> Use mathematical induction to prove that Euclid’s algorithm computes the greatest common divisor of any pair of nonnegative integers <em>p</em> and <em>q</em>.</p>
<p><a id="ch01sec2lev14"/></p>
<h4><a id="page_59"/>Creative Problems</h4>
<p><a id="ch01qa1q26"/><strong>1.1.26</strong> <em>Sorting three numbers.</em> Suppose that the variables <code>a</code>, <code>b</code>, <code>c</code>, and <code>t</code> are all of the same numeric primitive type. Show that the following code puts <code>a</code>, <code>b</code>, and <code>c</code> in ascending order:</p>
<p class="programlisting"><img alt="image" src="graphics/p0059-01.jpg"/></p>
<p><a id="ch01qa1q27"/><strong>1.1.27</strong> <em>Binomial distribution.</em> Estimate the number of recursive calls that would be used by the code</p>
<p class="programlisting"><img alt="image" src="graphics/p0059-02.jpg"/></p>
<p>to compute <code>binomial(100, 50, 0.25)</code>. Develop a better implementation that is based on saving computed values in an array.</p>
<p><a id="ch01qa1q28"/><strong>1.1.28</strong> <em>Remove duplicates.</em> Modify the test client in <code>BinarySearch</code> to remove any duplicate keys in the whitelist after the sort.</p>
<p><a id="ch01qa1q29"/><strong>1.1.29</strong> <em>Equal keys.</em> Add to <code>BinarySearch</code> a static method <code>rank()</code> that takes a key and a sorted array of <code>int</code> values (some of which may be equal) as arguments and returns the number of elements that are smaller than the key and a similar method <code>count()</code> that returns the number of elements equal to the key. <em>Note</em>: If <code>i</code> and <code>j</code> are the values returned by <code>rank(key, a)</code> and <code>count(key, a)</code> respectively, then <code>a[i..i+j-1</code>] are the values in the array that are equal to <code>key</code>.</p>
<p><a id="ch01qa1q30"/><strong>1.1.30</strong> <em>Array exercise.</em> Write a code fragment that creates an <em>N</em>-by-<em>N</em> boolean array <code>a[][]</code> such that <code>a[i][j]</code> is <code>true</code> if <code>i</code> and <code>j</code> are relatively prime (have no common factors), and <code>false</code> otherwise.</p>
<p><a id="ch01qa1q31"/><strong>1.1.31</strong> <em>Random connections.</em> Write a program that takes as command-line arguments an integer <code>N</code> and a <code>double</code> value <code>p</code> (between 0 and 1), plots <code>N</code> equally spaced dots of size .05 on the circumference of a circle, and then, with probability <code>p</code> for each pair of points, draws a gray line connecting them.</p>
<p><a id="page_60"/><a id="ch01qa1q32"/><strong>1.1.32</strong> <em>Histogram.</em> Suppose that the standard input stream is a sequence of <code>double</code> values. Write a program that takes an integer <em>N</em> and two <code>double</code> values <em>l</em> and <em>r</em> from the command line and uses <code>StdDraw</code> to plot a histogram of the count of the numbers in the standard input stream that fall in each of the <em>N</em> intervals defined by dividing (<em>l</em>, <em>r</em>) into <em>N</em> equal-sized intervals.</p>
<p><a id="ch01qa1q33"/><strong>1.1.33</strong> <em>Matrix library.</em> Write a library <code>Matrix</code> that implements the following API:</p>
<p class="image"><img alt="image" src="graphics/t0060-01.jpg"/></p>
<p>Develop a test client that reads values from standard input and tests all the methods.</p>
<p><a id="ch01qa1q34"/><strong>1.1.34</strong> <em>Filtering.</em> Which of the following <em>require</em> saving all the values from standard input (in an array, say), and which could be implemented as a filter using only a fixed number of variables and arrays of fixed size (not dependent on <em>N</em>)? For each, the input comes from standard input and consists of <em>N</em> real numbers between 0 and 1.</p>
<p class="indenthangingB">• Print the maximum and minimum numbers.</p>
<p class="indenthangingB">• Print the median of the numbers.</p>
<p class="indenthangingB">• Print the <em>k</em>th smallest value, for <em>k</em> less than 100.</p>
<p class="indenthangingB">• Print the sum of the squares of the numbers.</p>
<p class="indenthangingB">• Print the average of the <em>N</em> numbers.</p>
<p class="indenthangingB">• Print the percentage of numbers greater than the average.</p>
<p class="indenthangingB">• Print the <em>N</em> numbers in increasing order.</p>
<p class="indenthangingB">• Print the <em>N</em> numbers in random order.</p>
<p><a id="ch01sec2lev15"/></p>
<h4><a id="page_61"/>Experiments</h4>
<p><a id="ch01qa1q35"/><strong>1.1.35</strong> <em>Dice simulation.</em> The following code computes the exact probability distribution for the sum of two dice:</p>
<p class="programlisting"><img alt="image" src="graphics/p0061-01.jpg"/></p>
<p>The value <code>dist[i]</code> is the probability that the dice sum to <code>k</code>. Run experiments to validate this calculation simulating <em>N</em> dice throws, keeping track of the frequencies of occurrence of each value when you compute the sum of two random integers between 1 and 6. How large does <em>N</em> have to be before your empirical results match the exact results to three decimal places?</p>
<p><a id="ch01qa1q36"/><strong>1.1.36</strong> <em>Empirical shuffle check.</em> Run computational experiments to check that our shuffling code on page <a href="#ch01sec2lev8">32</a> works as advertised. Write a program <code>ShuffleTest</code> that takes command-line arguments <em>M</em> and <em>N</em>, does <em>N</em> shuffles of an array of size <em>M</em> that is initialized with <code>a[i] = i</code> before each shuffle, and prints an <em>M</em>-by-<em>M</em> table such that row <code>i</code> gives the number of times <code>i</code> wound up in position <code>j</code> for all <code>j</code>. All entries in the array should be close to <em>N/M</em>.</p>
<p><a id="ch01qa1q37"/><strong>1.1.37</strong> <em>Bad shuffling.</em> Suppose that you choose a random integer between <code>0</code> and <code>N-1</code> in our shuffling code instead of one between <code>i</code> and <code>N-1</code>. Show that the resulting order is <em>not</em> equally likely to be one of the <em>N!</em> possibilities. Run the test of the previous exercise for this version.</p>
<p><a id="ch01qa1q38"/><strong>1.1.38</strong> <em>Binary search versus brute-force search.</em> Write a program <code>BruteForceSearch</code> that uses the brute-force search method given on page <a href="#ch01sec3lev45">48</a> and compare its running time on your computer with that of <code>BinarySearch</code> for <code>largeW.txt</code> and <code>largeT.txt</code>.</p>
<p><a id="page_62"/><a id="ch01qa1q39"/><strong>1.1.39</strong> <em>Random matches.</em> Write a <code>BinarySearch</code> client that takes an <code>int</code> value <code>T</code> as command-line argument and runs <em>T</em> trials of the following experiment for <em>N</em> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>: generate two arrays of <em>N</em> randomly generated positive six-digit <code>int</code> values, and find the number of values that appear in both arrays. Print a table giving the average value of this quantity over the <em>T</em> trials for each value of <em>N</em>.</p>
<p><a id="ch01sec1lev4"/></p>
<h3><a id="page_64"/>1.2 Data Abstraction</h3>
<p><small>A DATA TYPE</small> is a set of values and a set of operations on those values. So far, we have discussed in detail Java’s <em>primitive</em> data types: for example, the <em>values</em> of the primitive data type <code>int</code> are integers between −2<sup>31</sup> and 2<sup>31</sup> − 1; the <em>operations</em> of <code>int</code> include <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>, <code>%</code>, <code>&lt;</code>, and <code>&gt;</code>. In principle, we could write all of our programs using only the built-in primitive types, but it is much more convenient to write programs at a higher level of abstraction. In this section, we focus on the process of defining and using data types, which is known as <em>data abstraction</em> (and supplements the <em>function abstraction</em> style that is the basis of <a href="#ch01sec1lev3"><small>SECTION 1.1</small></a>).</p>
<p>Programming in Java is largely based on building data types known as <em>reference types</em> with the familiar Java <code>class</code>. This style of programming is known as <em>object-oriented programming</em>, as it revolves around the concept of an <em>object</em>, an entity that holds a data type value. With Java’s primitive types we are largely confined to programs that operate on numbers, but with reference types we can write programs that operate on strings, pictures, sounds, any of hundreds of other abstractions that are available in Java’s standard libraries or on our booksite. Even more significant than libraries of predefined data types is that the range of data types available in Java programming is open-ended, because <em>you can define your own data types</em> to implement any abstraction whatsoever.</p>
<p>An <em>abstract data type</em> (ADT) is a data type whose representation is hidden from the client. Implementing an ADT as a Java class is not very different from implementing a function library as a set of static methods. The primary difference is that we associate <em>data</em> with the function implementations and we hide the representation of the data from the client. When <em>using</em> an ADT, we focus on the <em>operations</em> specified in the API and pay no attention to the data representation; when <em>implementing</em> an ADT, we focus on the <em>data</em>, then implement operations on that data.</p>
<p>Abstract data types are important because they support encapsulation in program design. In this book, we use them as a means to</p>
<p class="indenthangingB">• Precisely specify problems in the form of APIs for use by diverse clients</p>
<p class="indenthangingB">• Describe algorithms and data structures as API implementations</p>
<p>Our primary reason for studying different algorithms for the same task is that performance characteristics differ. Abstract data types are an appropriate framework for the study of algorithms because they allow us to put knowledge of algorithm performance to immediate use: we can substitute one algorithm for another to improve performance for all clients without changing any client code.</p>
<p><a id="ch01sec2lev16"/></p>
<h4><a id="page_65"/>Using abstract data types</h4>
<p><em>You do not need to know how a data type is implemented in order to be able to use it</em>, so we begin by describing how to write programs that use a simple data type named <code>Counter</code> whose values are a name and a nonnegative integer and whose operations are <em>create and initialize to zero</em>, <em>increment by one</em>, and <em>examine the current value.</em> This abstraction is useful in many contexts. For example, it would be reasonable to use such a data type in electronic voting software, to ensure that the only thing that a voter can do is increment a chosen candidate’s tally by one. Or, we might use a <code>Counter</code> to keep track of fundamental operations when analyzing the performance of algorithms. To use a <code>Counter</code>, you need to learn our mechanism for specifying the operations defined in the data type and the Java language mechanisms for creating and manipulating data-type values. Such mechanisms are critically important in modern programming, and we use them throughout this book, so this first example is worthy of careful attention.</p>
<p><a id="ch01sec3lev47"/></p>
<h5><em>API for an abstract data type</em></h5>
<p>To specify the behavior of an abstract data type, we use an <em>application programming interface</em> (API), which is a list of <em>constructors</em> and <em>instance methods</em> (operations), with an informal description of the effect of each, as in this API for <code>Counter</code>:</p>
<p class="image"><img alt="image" src="graphics/t0065-01.jpg"/></p>
<p>Even though the basis of a data-type definition is a set of values, the role of the values is not visible from the API, only the operations on those values. Accordingly, an ADT definition has many similarities with a library of static methods (see page <a href="#ch01sec3lev21">24</a>):</p>
<p class="indenthangingB">• Both are implemented as a Java <code>class</code>.</p>
<p class="indenthangingB">• Instance methods may take zero or more arguments of a specified type, separated by commas and enclosed in parentheses.</p>
<p class="indenthangingB">• They may provide a return value of a specified type or no return value (signified by <code>void</code>).</p>
<p>And there are three significant differences:</p>
<p class="indenthangingB">• Some entries in the API have the same name as the class and lack a return type. Such entries are known as <em>constructors</em> and play a special role. In this case, <code>Counter</code> has a constructor that takes a <code>String</code> argument.</p>
<p class="indenthangingB"><a id="page_66"/>• Instance methods lack the <code>static</code> modifier. They are <em>not</em> static methods—their purpose is to operate on data type values.</p>
<p class="indenthangingB">• Some instance methods are present so as to adhere to Java conventions—we refer to such methods as <em>inherited methods</em> and shade them gray in the API.</p>
<p>As with APIs for libraries of static methods, an API for an abstract data type is a contract with all clients and, therefore, the starting point both for developing any client code and for developing any data-type implementation. In this case, the API tells us that to use <code>Counter</code>, we have available the <code>Counter()</code> constructor, the <code>increment()</code> and <code>tally()</code> instance methods, and the inherited <code>toString()</code> method.</p>
<p><a id="ch01sec3lev48"/></p>
<h5><em>Inherited methods</em></h5>
<p>Various Java conventions enable a data type to take advantage of built-in language mechanisms by including specific methods in the API. For example, all Java data types <em>inherit</em> a <code>toString()</code> method that returns a <code>String</code> representation of the data-type values. Java calls this method when any data-type value is to be concatenated with a <code>String</code> value with the <code>+</code> operator. The default implementation is not particularly useful (it gives a string representation of the memory address of the data-type value), so we often provide an implementation that overrides the default, and include <code>toString()</code> in the API whenever we do so. Other examples of such methods include <code>equals()</code>, <code>compareTo()</code>, and <code>hashCode()</code> (see page <a href="#ch01sec3lev76">101</a>).</p>
<p><a id="ch01sec3lev49"/></p>
<h5><em>Client code</em></h5>
<p>As with modular programming based on static methods, the API allows us to write client code without knowing details of the implementation (and to write implementation code without knowing details of any particular client). The mechanisms introduced on page <a href="#ch01sec2lev7">28</a> for organizing programs as independent modules are useful for all Java classes, and thus are effective for modular programming with ADTs as well as for libraries of static methods. Accordingly, we can use an ADT in any program provided that the source code is in a <code>.java</code> file in the same directory, or in the standard Java library, or accessible through an <code>import</code> statement, or through one of the classpath mechanisms described on the booksite. All of the benefits of modular programming follow. By encapsulating all the code that implements a data type within a single Java class, we enable the development of client code at a higher level of abstraction. To develop client code, you need to be able to <em>declare variables</em>, <em>create objects</em> to hold data-type values, and <em>provide access</em> to the values for instance methods to operate on them. These processes are different from the corresponding processes for primitive types, though you will notice many similarities.</p>
<p><a id="ch01sec3lev50"/></p>
<h5><a id="page_67"/><em>Objects</em></h5>
<p>Naturally, you can declare that a variable <code>heads</code> is to be associated with data of type <code>Counter</code> with the code</p>
<p class="programlisting">Counter heads;</p>
<p>but how can you assign values or specify operations? The answer to this question involves a fundamental concept in data abstraction: an <em>object</em> is an entity that can take on a data-type value. Objects are characterized by three essential properties: <em>state, identity,</em> and <em>behavior</em>. The <em>state</em> of an object is a value from its data type. The <em>identity</em> of an object distinguishes one object from another. It is useful to think of an object’s identity as the place where its value is stored in memory. The <em>behavior</em> of an object is the effect of data-type operations. The implementation has the sole responsibility for maintaining an object’s identity, so that client code can use a data type without regard to the representation of its state by conforming to an API that describes an object’s behavior. An object’s state might be used to provide information to a client or cause a side effect or be changed by one of its data type’s operations, but the details of the representation of the data-type value are not relevant to client code. A <em>reference</em> is a mechanism for accessing an object. Java nomenclature makes clear the distinction from primitive types (where variables are associated with values) by using the term <em>reference types</em> for nonprimitive types. The details of implementing references vary in Java implementations, but it is useful to think of a reference as a memory address, as shown at right (for brevity, we use three-digit memory addresses in the diagram).</p>
<p class="image"><img alt="image" src="graphics/01_14-objectrep.jpg"/></p>
<p><a id="ch01sec3lev51"/></p>
<h5><em>Creating objects</em></h5>
<p>Each data-type value is stored in an object. To create (or <em>instantiate</em>) an individual object, we invoke a constructor by using the keyword <code>new</code>, followed by the class name, followed by <code>()</code> (or a list of argument values enclosed in parentheses, if the constructor takes arguments). A constructor has no return type because it always returns a reference to an object of its data type. Each time that a client uses <code>new()</code>, the system</p>
<p class="indenthangingB">• Allocates memory space for the object</p>
<p class="indenthangingB">• Invokes the constructor to initialize its value</p>
<p class="indenthangingB">• Returns a reference to the object</p>
<p>In client code we typically create objects in an initializing declaration that associates a variable with the object, as we often do with variables of primitive types. Unlike primitive types, variables are associated with references to objects, not the data-type values <a id="page_68"/>themselves. We can create any number of objects from the same class—each object has its own identity and may or may not store the same value as another object of the same type. For example, the code</p>
<p class="programlisting">Counter heads = new Counter("heads");<br/>
Counter tails = new Counter("tails");</p>
<p class="image"><img alt="image" src="graphics/01_15_anatomycreateobject.jpg"/></p>
<p>creates two different <code>Counter</code> objects. In an abstract data type, details of the representation of the value are hidden from client code. You might assume that the value associated with each <code>Counter</code> object is a <code>String</code> name and an <code>int</code> tally, but <em>you cannot write code that depends on any specific representation</em> (or even know whether that assumption is true—perhaps the tally is a <code>long</code> value).</p>
<p><a id="ch01sec3lev52"/></p>
<h5><em>Invoking instance methods</em></h5>
<p>The purpose of an instance method is to operate on data-type values, so the Java language includes a special mechanism to invoke instance methods that emphasizes a connection to an object. Specifically, we invoke an instance method by writing a variable name that refers to an object, followed by a period, followed by an instance method name, followed by 0 or more arguments, enclosed in parentheses and separated by commas. An instance method might <em>change</em> the data-type value or just <em>examine</em> the data-type value. Instance methods have all of the properties of static methods that we considered on page <a href="#ch01sec3lev21">24</a>—arguments are passed by value, method names can be overloaded, they may have a return value, and they may cause side effects—but they have an additional property that characterizes them: <em>each invocation is associated with an object</em>. For example, the code</p>
<p class="programlisting">heads.increment();</p>
<p class="image"><img alt="image" src="graphics/01_16-anatomyinstancemethod.jpg"/></p>
<p>invokes the instance method <code>increment()</code> to operate on the <code>Counter</code> object <code>heads</code> (in this case the operation involves incrementing the tally), and the code</p>
<p class="programlisting">heads.tally() - tails.tally();</p>
<p>invokes the instance method <code>tally()</code> twice, first to operate on the <code>Counter</code> object <code>heads</code> and then to operate on the <code>Counter</code> object <code>tails</code> (in this case the <a id="page_69"/>operation involves returning the tally as an <code>int</code> value). As these examples illustrate, you can use calls on instance methods in client code in the same way as you use calls on static methods—as statements (<code>void</code> methods) or values in expressions (methods that return a value). The primary purpose of static methods is to implement functions; the primary purpose of non-static (instance) methods is to implement data-type operations. Either type of method may appear in client code, but you can easily distinguish between them, because a static method call starts with a <em>class</em> name (uppercase, by convention) and a non-static method call always starts with an <em>object</em> name (lowercase, by convention). These differences are summarized in the table at right.</p>
<p class="image"><img alt="image" src="graphics/t0069-01.jpg"/></p>
<p><a id="ch01sec3lev53"/></p>
<h5><em>Using objects</em></h5>
<p>Declarations give us variable names for objects that we can use in code not just to create objects and invoke instance methods, but also in the same way as we use variable names for integers, floating-point numbers, and other primitive types. To develop client code for a given data type, we:</p>
<p class="indenthangingB">• Declare variables of the type, for use in referring to objects</p>
<p class="indenthangingB">• Use the keyword <code>new</code> to invoke a constructor that creates objects of the type</p>
<p class="indenthangingB">• Use the object name to invoke instance methods, either as statements or within expressions</p>
<p>For example, the class <code>Flips</code> shown at the top of the next page is a <code>Counter</code> client that takes a command-line argument <code>T</code> and simulates <code>T</code> coin flips (it is also a <code>StdRandom</code> client). Beyond these direct uses, we can use variables associated with objects in the same way as we use variables associated with primitive-type values:</p>
<p class="indenthangingB">• In assignment statements</p>
<p class="indenthangingB">• To pass or return objects from methods</p>
<p class="indenthangingB">• To create and use arrays of object.</p>
<p>Understanding the behavior of each of these types of uses requires thinking in terms of <em>references</em>, not values, as you will see when we consider them, in turn.</p>
<p><a id="ch01sec3lev54"/></p>
<h5><em>Assignment statements</em></h5>
<p>An assignment statement with a reference type creates a copy of the reference. The assignment statement does not create a new object, just another reference to an existing object. This situation is known as <em>aliasing</em>: both variables refer to the same object. The effect of aliasing is a bit unexpected, because it is different for variables holding values of a primitive type. Be sure that you understand the difference. <a id="page_70"/>If <code>x</code> and <code>y</code> are variables of a primitive type, then the assignment <code>x = y</code> copies the value of <code>y</code> to <code>x</code>. For reference types, the <em>reference</em> is copied (not the value). Aliasing is a common source of bugs in Java programs, as illustrated by the following example:</p>
<p class="programlisting"><img alt="image" src="graphics/p0070-02.jpg"/></p>
<p class="image"><img alt="image" src="graphics/p0070-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/01_17-objectrepalias.jpg"/></p>
<p>With a typical <code>toString()</code> implementation this code would print the string <code>"2 ones"</code> which may or may not be what was intended and is counterintuitive at first. Such bugs are common in programs written by people without much experience in using objects (that may be you, so pay attention here!). Changing the state of an object impacts all code involving aliased variables referencing that object. We are used to thinking of two different variables of primitive types as being independent, but that intuition does not carry over to variables of reference types.</p>
<p><a id="ch01sec3lev55"/></p>
<h5><a id="page_71"/><em>Objects as arguments</em></h5>
<p>You can pass objects as <em>arguments</em> to methods. This ability typically simplifies client code. For example, when we use a <code>Counter</code> as an argument, we are essentially passing both a name and a tally, but need only specify one variable. When we call a method with arguments, the effect in Java is as if each argument value were to appear on the right-hand side of an assignment statement with the corresponding argument name on the left. That is, Java passes a <em>copy</em> of the argument value from the calling program to the method. This arrangement is known as <em>pass by value</em> (see page <a href="#ch01sec3lev21">24</a>). One important consequence is that the method cannot change the value of a caller’s variable. For primitive types, this policy is what we expect (the two variables are independent), but each time that we use a reference type as a method argument we create an alias, so we must be cautious. In other words, the convention is to pass the <em>reference</em> by value (make a copy of it) but to pass the <em>object</em> by reference. For example, if we pass a reference to an object of type <code>Counter</code>, the method cannot change the original reference (make it point to a different <code>Counter</code>), but it <em>can</em> change the value of the object, for example by using the reference to call <code>increment()</code>.</p>
<p><a id="ch01sec3lev56"/></p>
<h5><em>Objects as return values</em></h5>
<p>Naturally, you can also use an object as a <em>return value</em> from a method. The method might return an object passed to it as an argument, as in the example below, or it might create an object and return a reference to it. This capability is important because Java methods allow only one return value—using objects enables us to write code that, in effect, returns multiple values.</p>
<p class="image"><img alt="image" src="graphics/p0071-01.jpg"/></p>
<p><a id="ch01sec3lev57"/></p>
<h5><a id="page_72"/><em>Arrays are objects</em></h5>
<p>In Java, every value of any nonprimitive type is an object. In particular, arrays are objects. As with strings, there is special language support for certain operations on arrays: declarations, initialization, and indexing. As with any other object, when we pass an array to a method or use an array variable on the right hand side of an assignment statement, we are making a copy of the array reference, not a copy of the array. This convention is appropriate for the typical case where we expect the method to be able to modify the array, by rearranging its entries, as, for example, in <code>java.util.Arrays.sort()</code> or the <code>shuffle()</code> method that we considered on page <a href="#page_32">32</a>.</p>
<p><a id="ch01sec3lev58"/></p>
<h5><em>Arrays of objects</em></h5>
<p>Array entries can be of any type, as we have already seen: <code>args[]</code> in our <code>main()</code> implementations is an array of <code>String</code> objects. When we create an array of objects, we do so in two steps:</p>
<p class="indenthangingB">• Create the array, using the bracket syntax for array constructors.</p>
<p class="indenthangingB">• Create each object in the array, using a standard constructor for each.</p>
<p>For example, the code below simulates rolling a die, using an array of <code>Counter</code> objects to keep track of the number of occurrences of each possible value. An array of objects in Java is an array of references to objects, not the objects themselves. If the objects are large, then we may gain efficiency by not having to move them around, just their references. If they are small, we may lose efficiency by having to follow a reference each time we need to get to some information.</p>
<p class="image"><img alt="image" src="graphics/p0072-01.jpg"/></p>
<p><a id="page_73"/><small>WITH THIS FOCUS ON OBJECTS</small>, writing code that embraces data abstraction (defining and using data types, with data-type values held in objects) is widely referred to as <em>object-oriented programming</em>. The basic concepts that we have just covered are the starting point for object-oriented programming, so it is worthwhile to briefly summarize them. A <em>data type</em> is a set of values and a set of operations defined on those values. We implement data types in independent Java <code>class</code> modules and write client programs that use them. An <em>object</em> is an entity that can take on a data-type value or an <em>instance</em> of a data type. Objects are characterized by three essential properties: <em>state, identity,</em> and <em>behavior</em>. A data-type implementation supports clients of the data type as follows:</p>
<p class="indenthangingB">• Client code can <em>create objects</em> (establish identity) by using the <code>new</code> construct to invoke a constructor that creates an object, initializes its instance variables, and returns a reference to that object.</p>
<p class="indenthangingB">• Client code can <em>manipulate data-type values</em> (control an object’s behavior, possibly changing its state) by using a variable associated with an object to invoke an instance method that operates on that object’s instance variables.</p>
<p class="indenthangingB">• Client code can <em>manipulate objects</em> by creating arrays of objects and passing them and returning them to methods, in the same way as for primitive-type values, except that variables refer to references to values, not the values themselves.</p>
<p>These capabilities are the foundation of a flexible, modern, and widely useful programming style that we will use as the basis for studying algorithms in this book.</p>
<p><a id="ch01sec2lev17"/></p>
<h4><a id="page_74"/>Examples of abstract data types</h4>
<p>The Java language has thousands of built-in ADTs, and we have defined many other ADTs to facilitate the study of algorithms. Indeed, every Java program that we write is a data-type implementation (or a library of static methods). To control complexity, we will specifically cite APIs for any ADT that we use in this book (not many, actually).</p>
<p>In this section, we introduce as examples several data types, with some examples of client code. In some cases, we present excerpts of APIs that may contain dozens of instance methods or more. We articulate these APIs to present real-world examples, to specify the instance methods that we will use in the book, and to emphasize that you do not need to know the details of an ADT implementation in order to be able to use it.</p>
<p>For reference, the data types that we use and develop in this book are shown on the facing page. These fall into several different categories:</p>
<p class="indenthangingB">• Standard system ADTs in <code>java.lang.*</code>, which can be used in any Java program.</p>
<p class="indenthangingB">• Java ADTs in libraries such as <code>java.awt</code>, <code>java.net</code>, and <code>java.io</code>, which can also be used in any Java program, but need an <code>import</code> statement.</p>
<p class="indenthangingB">• Our I/O ADTs that allow us to work with multiple input/output streams similar to <code>StdIn</code> and <code>StdOut</code>.</p>
<p class="indenthangingB">• Data-oriented ADTs whose primary purpose is to facilitate organizing and processing data by encapsulating the representation. We describe several examples for applications in computational geometry and information processing later in this section and use them as examples in client code later on.</p>
<p class="indenthangingB">• Collection ADTs whose primary purpose is to facilitate manipulating collections of data of the same type. We describe the basic <code>Bag</code>, <code>Stack</code>, and <code>Queue</code> types in <a href="ch01a.html#ch01sec1lev5"><small>SECTION 1.3</small></a>, <code>PQ</code> types in <a href="ch02.html#ch02"><small>CHAPTER 2</small></a>, and the <code>ST</code> and <code>SET</code> types in <a href="ch03.html#ch03"><small>CHAPTERS 3</small></a> and <em><a href="ch05.html#ch05">5</a></em>.</p>
<p class="indenthangingB">• Operations-oriented ADTs that we use to analyze algorithms, as described in <a href="ch01a.html#ch01sec1lev6"><small>SECTION 1.4</small></a> and <a href="ch01a.html#ch01sec1lev7"><small>SECTION 1.5</small></a>.</p>
<p class="indenthangingB">• ADTs for graph algorithms, including both data-oriented ADTs that focus on encapsulating representations of various kinds of graphs and operations-oriented ADTs that focus on providing specifications for graph-processing algorithms.</p>
<p>This list does not include the dozens of types that we consider in exercises, which may be found in the index. Also, as described on page <a href="#ch01sec2lev19">90</a>, we often distinguish multiple implementations of various ADTs with a descriptive prefix. As a group, the ADTs that we use demonstrate that organizing and understanding the data types that you use is an important factor in modern programming.</p>
<p>A typical application might use only five to ten of these ADTs. A prime goal in the development and organization of the ADTs in this book is to enable programmers to easily take advantage of a relatively small set of them in developing client code.</p>
<p class="image"><a id="page_75"/><img alt="image" src="graphics/t0075-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0075-02.jpg"/></p>
<p><a id="ch01sec3lev59"/></p>
<h5><a id="page_76"/><em>Geometric objects</em></h5>
<p>A natural example of object-oriented programming is designing data types for geometric objects. For example, the APIs on the facing page define abstract data types for three familiar geometric objects: <code>Point2D</code> (points in the plane), <code>Interval1D</code> (intervals on the line), and <code>Interval2D</code> (two-dimensional intervals in the plane, or axis-aligned rectangles). As usual, the APIs are essentially self-documenting and lead immediately to easily understood client code such as the example at left, which reads the boundaries of an <code>Interval2D</code> and an integer <em>T</em> from the command line, generates <em>T</em> random points in the unit square, and counts the number of points that fall in the interval (an estimate of the area of the rectangle). For dramatic effect, the client also draws the interval and the points that fall outside the interval. This computation is a model for a method that reduces the problem of computing the area and volume of geometric shapes to the problem of determining whether a point falls within the shape or not (a less difficult but not trivial problem). Of course, we can define APIs for other geometric objects such as line segments, triangles, polygons, circles, and so forth, though implementing operations on them can be challenging. Several examples are addressed in the exercises at the end of this section.</p>
<p class="image"><img alt="image" src="graphics/p0076-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/01_18-box10000.jpg"/></p>
<p><small>PROGRAMS THAT PROCESS GEOMETRIC OBJECTS</small> have wide application in computing with models of the natural world, in scientific computing, video games, movies, and many other applications. The development and study of such programs and applications has blossomed into a far-reaching field of study known as <em>computational geometry</em>, which is a <a id="page_77"/>fertile area of examples for the application of the algorithms that we address in this book, as you will see in examples throughout the book. In the present context, our interest is to suggest that abstract data types that directly represent geometric abstractions are not difficult to define and can lead to simple and clear client code. This idea is reinforced in several exercises at the end of this section and on the booksite.</p>
<p class="image"><img alt="image" src="graphics/t0077-01.jpg"/></p>
<p><a id="ch01sec3lev60"/></p>
<h5><a id="page_78"/><em>Information processing</em></h5>
<p>Whether it be a bank processing millions of credit card transactions or a web analytics company processing billions of touchpad taps or a scientific research group processing millions of experimental observations, a great many applications are centered around processing and organizing information. Abstract data types provide a natural mechanism for organizing the information. Without getting into details, the two APIs on the facing page suggest a typical approach for a commercial application. The idea is to define data types that allow us to keep information in objects that correspond to things in the real world. A date is a day, a month, and a year and a transaction is a customer, a date, and an amount. These two are just examples: we might also define data types that can hold detailed information for customers, times, locations, goods and services, or whatever. Each data type consists of constructors that create objects containing the data and methods for use by client code to access it. To simplify client code, we provide two constructors for each type, one that presents the data in its appropriate type and another that parses a string to get the data (see <a href="#ch01qa2q19"><small>EXERCISE 1.2.19</small></a> for details). As usual, there is no reason for client code to know the representation of the data. Most often, the reason to organize the data in this way is to treat the data associated with an object as a single entity: we can maintain arrays of <code>Transaction</code> values, use <code>Date</code> values as a argument or a return value for a method, and so forth. The focus of such data types is on encapsulating the data, while at the same time enabling the development of client code that does not depend on the representation of the data. We do not dwell on organizing information in this way, except to take note that doing so and including the inherited methods <code>toString()</code>, <code>compareTo()</code>, <code>equals()</code>, and <code>hashCode()</code> allows us to take advantage of algorithm implementations that can process <em>any type of data</em>. We will discuss inherited methods in more detail on page <a href="#ch01sec3lev75">100</a>. For example, we have already noted Java’s convention that enables clients to print a string representation of every value if we include <code>toString()</code> implementation in a data type. We consider conventions corresponding to the other inherited methods in <a href="ch01a.html#ch01sec1lev5"><small>SECTION 1.3</small></a>, <a href="ch02.html#ch02sec1lev5"><small>SECTION 2.5</small></a>, <a href="ch03.html#ch03sec1lev4"><small>SECTION 3.4</small></a>, and <a href="ch03a.html#ch03sec1lev5"><small>SECTION 3.5</small></a>, using <code>Date</code> and <code>Transaction</code> as examples. <a href="ch01a.html#ch01sec1lev5"><small>SECTION 1.3</small></a> gives classic examples of data types and a Java language mechanism known as <em>parameterized types,</em> or <em>generics</em>, that takes advantage of these conventions, and <a href="ch02.html#ch02"><small>CHAPTER 2</small></a> and <a href="ch03.html#ch03"><small>CHAPTER 3</small></a> are also devoted to taking advantage of generic types and inherited methods to develop implementations of sorting and searching algorithms that are effective for any type of data.</p>
<p><small>WHENEVER YOU HAVE DATA OF DIFFERENT TYPES</small> that logically belong together, it is worthwhile to contemplate defining an ADT as in these examples. The ability to do so helps to organize the data, can greatly simplify client code in typical applications, and is an important step on the road to data abstraction.</p>
<p class="image"><a id="page_79"/><img alt="image" src="graphics/t0079-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0079-02.jpg"/></p>
<p><a id="ch01sec3lev61"/></p>
<h5><a id="page_80"/><em>Strings</em></h5>
<p>Java’s <code>String</code> is an important and useful ADT. A <code>String</code> is an indexed sequence of <code>char</code> values. <code>String</code> has dozens of instance methods, including the following:</p>
<p class="image"><img alt="image" src="graphics/t0080-01.jpg"/></p>
<p><code>String</code> values are similar to arrays of characters, but the two are not the same. Arrays have built-in Java language syntax for accessing a character; <code>String</code> has instance methods for indexed access, length, and many other operations. On the other hand, <code>String</code> has special language support for initialization and concatenation: instead of creating and initializing a string with a constructor, we can use a string literal; instead of invoking the method <code>concat()</code> we can use the <code>+</code> operator. We do not need to consider the details of the implementation, though understanding performance characteristics of some of the methods is important when developing string-processing algorithms, as you will see in <a href="ch05.html#ch05"><small>CHAPTER 5</small></a>. Why not just use arrays of characters instead of <code>String</code> values? The answer to this question is the same as for any ADT: <em>to simplify and clarify client code</em>. With <code>String</code>, we can write clear and simple client code that uses numerous convenient instance methods without regard to the way in which strings are represented (see facing page). Even this short list contains powerful operations that require advanced algorithms such <a id="page_82"/>as those considered in <a href="ch05.html#ch05"><small>CHAPTER 5</small></a>. For example, the argument of <code>split()</code> can be a <em>regular expression</em> (see <a href="ch05.html#ch05sec1lev10"><small>SECTION 5.4</small></a>)—the <code>split()</code> example on page <a href="#page_81">81</a> uses the argument “<code>\\s+</code>”, which means “one or more tabs, spaces, newlines, or returns.”</p>
<p class="image"><img alt="image" src="graphics/01_19-stringops.jpg"/></p>
<p class="image"><a id="page_81"/><img alt="image" src="graphics/p0081-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/p0081-02.jpg"/></p>
<p><a id="ch01sec3lev62"/></p>
<h5><em>Input and output revisited</em></h5>
<p>A disadvantage of the <code>StdIn</code>, <code>StdOut</code>, and <code>StdDraw</code> standard libraries of <a href="#ch01sec1lev3"><small>SECTION 1.1</small></a> is that they restrict us to working with just one input file, one output file, and one drawing for any given program. With object-oriented programming, we can define similar mechanisms that allow us to work with <em>multiple</em> input streams, output streams, and drawings within one program. Specifically, our standard libary includes the data types <code>In</code>, <code>Out</code>, and <code>Draw</code> with the APIs shown on the facing page, When invoked with a constructor having a <code>String</code> argument, <code>In</code> and <code>Out</code> will first try to find a file in the current directory of your computer that has that name. If it cannot do so, it will assume the argument to be a website name and will try to connect to that website (if no such website exists, it will issue a runtime exception). In either case, the specified file or website becomes the source/target of the input/output for the stream object thus created, and the <code>read*()</code> and <code>print*()</code> methods will refer to that file or website. (If you use the no-argument constructor, then you obtain the standard streams.) This arrangement makes it possible for a single program to process multiple files and drawings. You also can assign such objects to variables, pass them as arguments or return values from methods, create arrays of them, and manipulate them just as you manipulate objects of any type. The program <code>Cat</code> shown at left is a sample client of <code>In</code> and <code>Out</code> that uses multiple input streams to concatenate several input files into a single output file. The <code>In</code> and <code>Out</code> classes also contain static methods for reading files containing values that are all <code>int</code>, <code>double</code>, or <code>String</code> types into an array (see page <a href="ch01a.html#ch01sec3lev90">126</a> and <a href="#ch01qa2q15"><small>EXERCISE 1.2.15</small></a>).</p>
<p class="image"><img alt="image" src="graphics/p0082-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/p0082-02.jpg"/></p>
<p class="image"><a id="page_83"/><img alt="image" src="graphics/t0083-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0083-02.jpg"/></p>
<p><a id="ch01sec2lev18"/></p>
<h4><a id="page_84"/>Implementing abstract data types</h4>
<p>As with libraries of static methods, we implement ADTs with a Java <code>class</code>, putting the code in a file with the same name as the class, followed by the <code>.java</code> extension. The first statements in the file declare <em>instance variables</em> that define the data-type values. Following the instance variables are the <em>constructor</em> and the <em>instance methods</em> that implement operations on data-type values. Instance methods may be <em>public</em> (specified in the API) or <em>private</em> (used to organize the computation and not available to clients). A data-type definition may have multiple constructors and may also include definitions of static methods. In particular, a unit-test client <code>main()</code> is normally useful for testing and debugging. As a first example, we consider an implementation of the <code>Counter</code> ADT that we defined on page <a href="#ch01sec2lev16">65</a>. A full annotated implementation is shown on the facing page, for reference as we discuss its constituent parts. Every ADT implementation that you will develop has the same basic ingredients as this simple example.</p>
<p><a id="ch01sec3lev63"/></p>
<h5><em>Instance variables</em></h5>
<p>To define data-type values (the <em>state</em> of each object), we declare <em>instance variables</em> in much the same way as we declare local variables. There is a critical distinction between instance variables and the local variables within a static method or a block that you are accustomed to: there is just <em>one</em> value corresponding to each local variable at a given time, but there are <em>numerous</em> values corresponding to each instance variable (one for each object that is an instance of the data type). There is no ambiguity with this arrangement, because each time that we access an instance variable, we do so with an object name—that object is the one whose value we are accessing. Also, each declaration is qualified by a <em>visibility modifier</em>. In ADT implementations, we use <code>private</code>, using a Java language mechansim to enforce the idea that the representation of an ADT is to be hidden from the client, and also <code>final</code>, if the value is not to be changed once it is initialized. <code>Counter</code> has two instance variables: a <code>String</code> value <code>name</code> and an <code>int</code> value <code>count</code>. If we were to use <code>public</code> instance variables (allowed in Java) the data type would, by definition, not be abstract, so we do not do so.</p>
<p class="image"><img alt="image" src="graphics/01_20-anatomyvariable.jpg"/></p>
<p><a id="ch01sec3lev64"/></p>
<h5><em>Constructors</em></h5>
<p>Every Java class has at least one <em>constructor</em> that establishes an object’s <em>identity</em>. A constructor is like a static method, but it can refer directly to instance variables and has no return value. Generally, the purpose of a constructor is to initialize the instance variables. Every constructor creates an object and provides to the client a reference to that object. Constructors always share the same name as the class. We can overload the name and have multiple constructors with different signatures, just as with methods. If no other constructor is defined, a default no-argument constructor is <a id="page_86"/>implicit, has no arguments, and initializes instance values to default values. The default values of instance variables are <code>0</code> for primitive numeric types, <code>false</code> for <code>boolean</code>, and <code>null</code> for reference types. These defaults may be changed by using initializing declarations for instance variables. Java automatically invokes a constructor when a client program uses the keyword <code>new</code>. Overloaded constructors are typically used to initialize instance variables to client-supplied values other than the defaults. For example, <code>Counter</code> has a one-argument constructor that initializes the <code>name</code> instance variable to the value given as argument (leaving the <code>count</code> instance variable to be initialized to the default value <code>0</code>).</p>
<p class="image"><a id="page_85"/><img alt="image" src="graphics/01_21-anatomyclass.jpg"/></p>
<p class="image"><img alt="image" src="graphics/01_22-anatomyconstructor.jpg"/></p>
<p><a id="ch01sec3lev65"/></p>
<h5><em>Instance methods</em></h5>
<p>To implement data-type instance operations (the <em>behavior</em> of each object), we implement <em>instance methods</em> with code that is precisely like the code that you learned in <a href="#ch01sec1lev3"><small>SECTION 1.1</small></a> to implement static methods (functions). Each instance method has a return type, a <em>signature</em> (which specifies its name and the types and names of its parameter variables), and a <em>body</em> (which consists of a sequence of statements, including a <em>return</em> statement that provides a value of the return type back to the client). When a client invokes a method, the parameter values (if any) are initialized with client values, the statements are executed until a return value is computed, and the value is returned to the client, with the same effect as if the method invocation in the client were replaced with that value. All of this action is the same as for static methods, but there is one critical distinction for instance methods: <em>they can access and perform operations on instance variables</em>. How do we specify which object’s instance variables we want to use? If you think about this question for a moment, you will see the logical answer: a reference to a variable in an instance method refers to the value <em>for the object that was used to invoke the method</em>. When we say <code>heads.increment()</code> the code in <code>increment()</code> is referring to the instance variables for <code>heads</code>. In other words, <a id="page_87"/>object-oriented programming adds one critically important additional way to use variables in a Java program:</p>
<p class="indenthangingB">• to invoke an instance method that operates on the object’s values.</p>
<p class="image"><img alt="image" src="graphics/01_23-anatomyinstancemethod.jpg"/></p>
<p>The difference from working solely with static methods is semantic (see the Q&amp;A), but has reoriented the way that modern programmers think about developing code in many situations. As you will see, it also dovetails well with the study of algorithms and data structures.</p>
<p><a id="ch01sec3lev66"/></p>
<h5><em>Scope</em></h5>
<p>In summary, the Java code that we write to implement instance methods uses <em>three</em> kinds of variables:</p>
<p class="indenthangingB">• Parameter variables</p>
<p class="indenthangingB">• Local variables</p>
<p class="indenthangingB">• <em>Instance variables</em></p>
<p>The first two of these are the same as for static methods: parameter variables are specified in the method signature and initialized with client values when the method is called, and local variables are declared and initialized within the method body. The scope of parameter variables is the entire method; the scope of local variables is the following statements in the block where they are defined. Instance variables are completely different: they hold data-type values for objects in a class, and their scope is the entire class (whenever there is an ambiguity, you can use the <code>this</code> prefix to identify instance variables). Understanding the distinctions among these three kinds of variables in instance methods is a key to success in object-oriented programming.</p>
<p class="image"><img alt="image" src="graphics/01_24-scopebug.jpg"/></p>
<p><a id="ch01sec3lev67"/></p>
<h5><a id="page_88"/><em>API, clients, and implementations</em></h5>
<p>These are the basic components that you need to understand to be able to build and use abstract data types in Java. Every ADT implementation that we will consider will be a Java class with private instance variables, constructors, instance methods, and a client. To fully understand a data type, we need the API, typical client code, and an implementation, summarized for <code>Counter</code> on the facing page. To emphasize the separation of client and implementation, we normally present each client as a separate class containing a static method <code>main()</code> and reserve test client’s <code>main()</code> in the data-type definition for minimal unit testing and development (calling each instance method at least once). In each data type that we develop, we go through the same steps. Rather than thinking about what action we need to take next to accomplish a computational goal (as we did when first learning to program), we think about the needs of a client, then accommodate them in an ADT, following these three steps:</p>
<p class="indenthangingB">• Specify an API. The purpose of the API is to <em>separate clients from implementations</em>, to enable modular programming. We have two goals when specifying an API. First, we want to enable clear and correct client code. Indeed, it is a good idea to write some client code before finalizing the API to gain confidence that the specified data-type operations are the ones that clients need. Second, we want to be able to implement the operations. There is no point specifying operations that we have no idea how to implement.</p>
<p class="indenthangingB">• Implement a Java class that meets the API specifications. First we choose the instance variables, then we write constructors and the instance methods.</p>
<p class="indenthangingB">• Develop multiple test clients, to validate the design decisions made in the first two steps.</p>
<p>What operations do clients need to perform, and what data-type values can best support those operations? These basic decisions are at the heart of every implementation that we develop.</p>
<p class="image"><a id="page_89"/><img alt="image" src="graphics/t0089-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0089-02.jpg"/></p>
<p><a id="ch01sec2lev19"/></p>
<h4><a id="page_90"/>More implementations of abstract data types</h4>
<p>As with any programming concept, the best way to understand the power and utility of ADTs is to consider carefully more examples and more implementations. There will be ample opportunity for you to do so, as much of this book is devoted to ADT implementations, but a few more simple examples will help us lay the groundwork for addressing them.</p>
<p><a id="ch01sec3lev68"/></p>
<h5><em>Date</em></h5>
<p>Shown on the facing page are two implementations of the <code>Date</code> ADT that we considered on page <a href="#page_79">79</a>. To reduce clutter, we omit the parsing constructor (which is described in <a href="#ch01qa2q19"><small>EXERCISE 1.2.19</small></a>) and the inherited methods <code>equals()</code> (see page <a href="#page_103">103</a>), <code>compareTo()</code> (see page <a href="ch02.html#page_247">247</a>), and <code>hashCode()</code> (see <a href="ch03.html#ch03qa4q22"><small>EXERCISE 3.4.22</small></a>). The straightforward implementation on the left maintains the day, month, and year as instance variables, so that the instance methods can just return the appropriate value; the more space-efficient implementation on the right uses only a single <code>int</code> value to represent a date, using a mixed-radix number that represents the date with day <em>d</em>, month <em>m</em>, and year <em>y</em> as 512<em>y</em> + 32<em>m</em> + <em>d.</em> One way that a client might notice the difference between these implementations is by violating implicit assumptions: the second implementation depends for its correctness on the day being between 0 and 31, the month being between 0 and 15, and the year being positive (in practice, both implementations should check that months are between 1 and 12, days are between 1 and 31, and that dates such as June 31 and February 29, 2009, are illegal, though that requires a bit more work). This example highlights the idea that we rarely <em>fully</em> specify implementation requirements in an API (we normally do the best we can, and could do better here). Another way that a client might notice the difference between the two implementations is <em>performance:</em> the implementation on the right uses less space to hold data-type values at the cost of more time to provide them to the client in the agreed form (one or two arithmetic operations are needed). Such tradeoffs are common: one client may prefer one of the implementations and another client might prefer the other, so we need to accommodate both. Indeed, one of the recurring themes of this book is that we need to understand the space and time requirements of various implementations and their suitability for use by various clients. One of the key advantages of using data abstraction in our implementations is that we can normally change from one implementation to another <em>without changing any client code</em>.</p>
<p><a id="ch01sec3lev69"/></p>
<h5><em>Maintaining multiple implementations</em></h5>
<p>Multiple implementations of the same API can present maintainence and nomenclature issues. In some cases, we simply want to replace an old implementation with an improved one. In others, we may need to maintain two implementations, one suitable for some clients, the other suitable for others. Indeed, a prime goal of this book is to consider in depth several implementations of each of a number of fundamental ADTs, generally with different performance characteristics. In this book, we often compare the performance of a single client using two <a id="page_92"/>different implementations of the same API. For this reason, we generally adopt an informal naming convention where we:</p>
<p class="indenthangingB">• Identify different implementations of the same API by prepending a descriptive modifier. For example, we might name our <code>Date</code> implementations on the previous page <code>BasicDate</code> and <code>SmallDate</code>, and we might wish to develop a <code>SmartDate</code> implementation that can validate that dates are legal.</p>
<p class="indenthangingB">• Maintain a reference implementation with no prefix that makes a choice that should be suitable for most clients. That is, most clients should just use <code>Date</code>.</p>
<p class="image"><a id="page_91"/><img alt="image" src="graphics/t0091-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0091-02.jpg"/></p>
<p>In a large system, this solution is not ideal, as it might involve changing client code. For example, if we were to develop a new implementation <code>ExtraSmallDate</code>, then our only options are to change client code or to make it the reference implementation for use by all clients. Java has various advanced language mechanisms for maintaining multiple implementations without needing to change client code, but we use them sparingly because their use is challenging (and even controversial) even for experts, especially in conjuction with other advanced language features that we do value (generics and iterators). These issues are important (for example, ignoring them led to the celebrated <em>Y2K problem</em> at the turn of the millennium, because many programs used their own implementations of the date abstraction that did not take into account the first two digits of the year), but detailed consideration of these issues would take us rather far afield from the study of algorithms.</p>
<p><a id="ch01sec3lev70"/></p>
<h5><em>Accumulator</em></h5>
<p>The <em>accumulator</em> API shown on the facing page defines an abstract data type that provides to clients the ability to maintain a running average of data values. For example, we use this data type frequently in this book to process experimental results (see <a href="ch01a.html#ch01sec1lev6"><small>SECTION 1.4</small></a>). The implementation is straightforward: it maintains a <code>int</code> instance variable counts the number of data values seen so far and a <code>double</code> instance variable that keeps track of the sum of the values seen so far; to compute the average it divides the sum by the count. Note that the implementation does not save the data values—it could be used for a huge number of them (even on a device that is not capable of holding that many), or a huge number of accumulators could be used on a big system. This performance characteristic is subtle and might be specified in the API, because an implementation that does save the values might cause an application to run out of memory.</p>
<p class="image"><a id="page_93"/><img alt="image" src="graphics/t0093-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0093-02.jpg"/></p>
<p><a id="ch01sec3lev71"/></p>
<h5><a id="page_94"/><em>Visual accumulator</em></h5>
<p>The <em>visual accumulator</em> implementation shown on the facing page extends <code>Accumulator</code> to present a useful side effect: it draws on <code>StdDraw</code> all the data (in gray) and the running average (in red). The easiest way to do so is to add a constructor that provides the number of points to be plotted and the maximum value, for rescaling the plot. <code>VisualAccumulator</code> is not technically an implementation of the <code>Accumulator</code> API (its constructor has a different signature and it causes a different prescribed side effect). Generally, we are careful to fully specify APIs and are loath to make <em>any</em> changes in an API once articulated, as it might involve changing an unknown amount of client (and implementation) code, but adding a constructor to gain functionality can sometimes be defended because it involves changing the same line in client code that we change when changing a class name. In this example, if we have developed a client that uses an <code>Accumulator</code> and perhaps has many calls to <code>addDataValue()</code> and <code>mean()</code>, we can enjoy the benefits of <code>VisualAccumulator</code> by just changing one line of client code.</p>
<p class="image"><img alt="image" src="graphics/01_25-visacc20.jpg"/></p>
<p class="image"><img alt="image" src="graphics/01_26-visacc2000.jpg"/></p>
<p class="image"><a id="page_95"/><img alt="image" src="graphics/t0095-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0095-02.jpg"/></p>
<p><a id="ch01sec2lev20"/></p>
<h4><a id="page_96"/>Designing abstract data types</h4>
<p><em>An abstract data type is a data type whose representation is hidden from the client.</em> This idea has had a powerful effect on modern programming. The various examples that we have considered give us the vocabulary to address advanced characteristics of ADTs and their implementation as Java classes. Many of these topics are, on the surface, tangential to the study of algorithms, so it is safe for you to skim this section and refer to it later in the context of specific implementation problems. Our goal is to put important information related to designing data types in one place for reference and to set the stage for implementations throughout this book.</p>
<p><a id="ch01sec3lev72"/></p>
<h5><em>Encapsulation</em></h5>
<p>A hallmark of object-oriented programming is that it enables us to <em>encapsulate</em> data types within their implementations, to facilitate separate development of clients and data type implementations. Encapsulation enables modular programming, allowing us to</p>
<p class="indenthangingB">• Independently develop of client and implementation code</p>
<p class="indenthangingB">• Substitute improved implementations without affecting clients</p>
<p class="indenthangingB">• Support programs not yet written (the API is a guide for any future client)</p>
<p>Encapsulation also isolates data-type operations, which leads to the possibility of</p>
<p class="indenthangingB">• Limiting the potential for error</p>
<p class="indenthangingB">• Adding consistency checks and other debugging tools in implementations</p>
<p class="indenthangingB">• Clarifying client code</p>
<p>An encapsulated data type can be used by any client, so it extends the Java language. The programming style that we are advocating is predicated on the idea of breaking large programs into small modules that can be developed and debugged independently. This approach improves the resiliency of our software by limiting and localizing the effects of making changes, and it promotes code reuse by making it possible to substitute new implementations of a data type to improve performance, accuracy, or memory footprint. The same idea works in many settings. We often reap the benefits of encapsulation when we use system libraries. New versions of the Java system often include new implementations of various data types or static method libraries, but <em>the APIs do not change</em>. In the context of the study of algorithms and data structures, there is strong and constant motivation to develop better algorithms because we can improve performance for <em>all</em> clients by substituting an improved ADT implementation without changing the code of <em>any</em> client. The key to success in modular programming is to maintain <em>independence</em> among modules. We do so by insisting on the API being the <em>only</em> point of dependence between client and implementation. <em>You do not need to know how a data type is implemented in order to use it</em> and <em>you can assume that a client knows nothing but the API</em> when implementing a data type. Encapsulation is the key to attaining both of these advantages.</p>
<p><a id="ch01sec3lev73"/></p>
<h5><a id="page_97"/><em>Designing APIs</em></h5>
<p>One of the most important and most challenging steps in building modern software is designing APIs. This task takes practice, careful deliberation, and many iterations, but any time spent designing a good API is certain to be repaid in time saved debugging or code reuse. Articulating an API might seem to be overkill when writing a small program, but you should consider writing <em>every</em> program as though you will need to reuse the code someday. Ideally, an API would clearly articulate behavior for all possible inputs, including side effects, and then we would have software to check that implementations meet the specification. Unfortunately, a fundamental result from theoretical computer science known as the <em>specification problem</em> implies that this goal is actually <em>impossible</em> to achieve. Briefly, such a specification would have to be written in a formal language like a programming language, and the problem of determining whether two programs perform the same computation is known, mathematically, to be <em>undecidable</em>. Therefore, our APIs are brief English-language descriptions of the set of values in the associated abstract data type along with a list of constructors and instance methods, again with brief English-language descriptions of their purpose, including side effects. To validate the design, we always include examples of client code in the text surrounding our APIs. Within this broad outline, there are numerous pitfalls that every API design is susceptible to:</p>
<p class="indenthangingB">• An API may be <em>too hard to implement</em>, implying implementations that are difficult or impossible to develop.</p>
<p class="indenthangingB">• An API may be <em>too hard to use</em>, leading to client code that is more complicated than it would be without the API.</p>
<p class="indenthangingB">• An API may be <em>too narrow</em>, omitting methods that clients need.</p>
<p class="indenthangingB">• An API may be <em>too wide</em>, including a large number of methods not needed by any client. This pitfall is perhaps the most common, and one of the most difficult to avoid. The size of an API tends to grow over time because it is not difficult to add methods to an existing API, but it <em>is</em> difficult to remove methods without breaking existing clients.</p>
<p class="indenthangingB">• An API may be <em>too general</em>, providing no useful abstractions.</p>
<p class="indenthangingB">• An API may be <em>too specific</em>, providing abstractions so detailed or so diffuse as to be useless.</p>
<p class="indenthangingB">• An API may be <em>too dependent on a particular representation</em>, therefore not serving the purpose of freeing client code from the details of using that representation. This pitfall is also difficult to avoid, because the representation is certainly central to the development of the implementation.</p>
<p>These considerations are sometimes summarized in yet another motto: <em>provide to clients the methods they need and no others.</em></p>
<p><a id="ch01sec3lev74"/></p>
<h5><a id="page_98"/><em>Algorithms and abstract data types</em></h5>
<p>Data abstraction is naturally suited to the study of algorithms, because it helps us provide a framework within which we can precisely specify both what an algorithm needs to accomplish and how a client can make use of an algorithm. Typically, in this book, an algorithm is an implementation of an instance method in an abstract data type. For example, our whitelisting example at the beginning of the chapter is naturally cast as an ADT client, based on the following operations:</p>
<p class="indenthangingB">• Construct a <code>SET</code> from an array of given values.</p>
<p class="indenthangingB">• Determine whether a given value is in the set.</p>
<p>These operations are encapsulated in the <code>StaticSETofInts</code> ADT, shown on the facing page along with <code>Whitelist</code>, a typical client. <code>StaticSETofInts</code> is a special case of the more general and more useful <em>symbol table</em> ADT that is the focus of <a href="ch03.html#ch03"><small>CHAPTER 3</small></a>. Binary search is one of several algorithms that we study that is suitable for implementing these ADTs. By comparison with the <code>BinarySearch</code> implementation on page <a href="#ch01sb02">47</a>, this implementation leads to clearer and more useful client code. For example, <code>StaticSETofInts</code> enforces the idea that the array must be sorted before <code>rank()</code> is called. With the abstract data type, we separate the client from the implementation making it easier for <em>any</em> client to benefit from the ingenuity of the binary search algorithm, just by following the API (clients of <code>rank()</code> in <code>BinarySearch</code> have to know to sort the array first). Whitelisting is one of many clients that can take advantage of binary search.</p>
<p><small>EVERY JAVA PROGRAM</small> is a set of static methods and/or a data type implementation. In this book, we focus primarily on <em>abstract</em> data type implementations such as <code>StaticSETofInts</code>, where the focus is on operations and the representation of the data is hidden from the client. As this example illustrates, data abstraction enables us to</p>
<p class="indenthangingB">• Precisely specify what algorithms can provide for clients</p>
<p class="indenthangingB">• Separate algorithm implementations from the client code</p>
<p class="indenthangingB">• Develop layers of abstraction, where we make use of well-understood algorithms to develop other algorithms</p>
<p class="image"><img alt="image" src="graphics/t0098-01.jpg"/></p>
<p>These are desirable properties of <em>any</em> approach to describing algorithms, whether it be an English-language description or pseudo-code. By embracing the Java <code>class</code> mechanism in support of data abstraction, we have little to lose and much to gain: working code that we can test and use to compare performance for diverse clients.</p>
<p class="image"><a id="page_99"/><img alt="image" src="graphics/t0099-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0099-02.jpg"/></p>
<p><a id="ch01sec3lev75"/></p>
<h5><a id="page_100"/><em>Interface inheritance</em></h5>
<p>Java provides language support for defining relationships among objects, known as <em>inheritance</em>. These mechanisms are widely used by software developers, so you will study them in detail if you take a course in software engineering. The first inheritance mechanism that we consider is known as <em>subtyping</em>, which allows us to specify a relationship between otherwise unrelated classes by specifying in an <em>interface</em> a set of common methods that each implementing class must contain. An interface is nothing more than a list of instance methods. For example, instead of using our informal API, we might have articulated an interface for <code>Date</code>:</p>
<p class="programlisting"><img alt="image" src="graphics/p0100-01.jpg"/></p>
<p>and then referred to the interface in our implementation code</p>
<p class="programlisting"><img alt="image" src="graphics/p0100-02.jpg"/></p>
<p>so that the Java compiler will check that it matches the interface. Adding the code <code>implements Datable</code> to any class that implements <code>month()</code>, <code>day()</code>, and <code>year()</code> provides a guarantee to any client that an object of that class can invoke those methods. This arrangement is known as <em>interface inheritance</em>—an implementing class <em>inherits</em> the interface. Interface inheritance allows us to write client programs that can manipulate objects of <em>any</em> type that implements the interface (even a type to be created in the future), by invoking methods in the interface. We might have used interface inheritance in place of our more informal APIs, but chose not to do so to avoid dependence on specific high-level language mechanisms that are not critical to the understanding of algorithms and to avoid the extra baggage of interface files. But there are a few situations where Java conventions make <a id="page_101"/>it worthwhile for us to take advantage of interfaces: we use them for <em>comparison</em> and for <em>iteration</em>, as detailed in the table at the bottom of the previous page, and will consider them in more detail when we cover those concepts.</p>
<p class="image"><img alt="image" src="graphics/t0100-01.jpg"/></p>
<p><a id="ch01sec3lev76"/></p>
<h5><em>Implementation inheritance</em></h5>
<p>Java also supports another inheritence mechanism known as <em>subclassing,</em> which is a powerful technique that enables a programmer to change behavior and add functionality without rewriting an entire class from scratch. The idea is to define a new class (<em>subclass</em>, or <em>derived class</em>) that inherits instance methods <em>and</em> instance variables from another class (<em>superclass</em>, or <em>base class</em>). The subclass contains more methods than the superclass. Moreover, the subclass can redefine or <em>override</em> methods in the superclass. Subclassing is widely used by systems programmers to build so-called <em>extensible</em> libraries—one programmer (even you) can add methods to a library built by another programmer (or, perhaps, a team of systems programmers), effectively reusing the code in a potentially huge library. For example, this approach is widely used in the development of graphical user interfaces, so that the large amount of code required to provide all the facilities that users expect (drop-down menus, cut-and-paste, access to files, and so forth) can be reused. The use of subclassing is controversial among systems and applications programmers (its advantages over interface inheritance are debatable), and we avoid it in this book because it generally works against encapsulation. Certain vestiges of the approach are built in to Java and therefore unavoidable: specifically, every class is a subtype of Java’s <code>Object</code> class. This structure enables the “convention” that every class includes an implementation of <code>getClass()</code>, <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>, and several other methods that we do not use in this book. Actually, every class <em>inherits</em> these methods from <code>Object</code> through subclassing, so any client can use them for any object. We usually override <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code> in new classes because the default <code>Object</code> implementation generally does not lead to the desired behavior. We now will consider <code>toString()</code> and <code>equals()</code>; we discuss <code>hashCode()</code> in <a href="ch03.html#ch03sec1lev4"><small>SECTION 3.4</small></a>.</p>
<p class="image"><img alt="image" src="graphics/t0101-01.jpg"/></p>
<p><a id="ch01sec3lev77"/></p>
<h5><a id="page_102"/><em>String conversion</em></h5>
<p>By convention, every Java type inherits <code>toString()</code> from <code>Object</code>, so any client can invoke <code>toString()</code> for any object. This convention is the basis for Java’s automatic conversion of one operand of the concatenation operator <code>+</code> to a <code>String</code> whenever the other operand is a <code>String</code>. If an object’s data type does not include an implementation of <code>toString()</code>, then the default implementation in <code>Object</code> is invoked, which is normally not helpful, since it typically returns a string representation of the memory address of the object. Accordingly, we generally include implementations of <code>toString()</code> that override the default in every class that we develop, as highlighted for <code>Date</code> on the facing page. As illustrated in this code, <code>toString()</code> implementations are often quite simple, implicitly (through <code>+</code>) using <code>toString()</code> for each instance variable.</p>
<p><a id="ch01sec3lev78"/></p>
<h5><em>Wrapper types</em></h5>
<p>Java supplies built-in reference types known as <em>wrapper types</em>, one for each of the primitive types: <code>Boolean</code>, <code>Byte</code>, <code>Character</code>, <code>Double</code>, <code>Float</code>, <code>Integer</code>, <code>Long</code>, and <code>Short</code> correspond to <code>boolean</code>, <code>byte</code>, <code>char</code>, <code>double</code>, <code>float</code>, <code>int</code>, <code>long</code>, and <code>short</code>, respectively. These classes consist primarily of static methods such as <code>parseInt()</code> but they also include the inherited instance methods <code>toString()</code>, <code>compareTo()</code>, <code>equals()</code>, and <code>hashCode()</code>. Java automatically converts from primitive types to wrapper types when warranted, as described on page <a href="ch01a.html#ch01sec3lev86">122</a>. For example, when an <code>int</code> value is concatenated with a <code>String</code>, it is converted to an <code>Integer</code> that can invoke <code>toString()</code>.</p>
<p><a id="ch01sec3lev79"/></p>
<h5><em>Equality</em></h5>
<p>What does it mean for two objects to be equal? If we test equality with <code>(a == b)</code> where <code>a</code> and <code>b</code> are reference variables of the same type, we are testing whether they have the same identity: whether the <em>references</em> are equal. Typical clients would rather be able to test whether the <em>data-type values</em> (object state) are the same, or to implement some type-specific rule. Java gives us a head start by providing implementations both for standard types such as <code>Integer</code>, <code>Double</code>, and <code>String</code> and for more complicated types such as <code>File</code> and <code>URL</code>. When using these types of data, you can just use the built-in implementation. For example, if <code>x</code> and <code>y</code> are <code>String</code> values, then <code>x.equals(y)</code> is <code>true</code> if and only if <code>x</code> and <code>y</code> have the same length and are identical in each character position. When we define our own data types, such as <code>Date</code> or <code>Transaction</code>, we need to override <code>equals()</code>. Java’s convention is that <code>equals()</code> must be an <em>equivalence relation</em>. It must be</p>
<p class="indenthangingB">• <em>Reflexive</em>: <code>x.equals(x)</code> is <code>true.</code></p>
<p class="indenthangingB">• <em>Symmetric</em>: <code>x.equals(y)</code> is <code>true</code> if and only if <code>y.equals(x) is true.</code></p>
<p class="indenthangingB">• <em>Transitive</em>: if <code>x.equals(y)</code> and <code>y.equals(z)</code> are <code>true</code>, then so is <code>x.equals(z).</code></p>
<p>In addition, it must take an <code>Object</code> as argument and satisfy the following properties.</p>
<p class="indenthangingB">• <em>Consistent</em>: multiple invocations of <code>x.equals(y)</code> consistently return the same value, provided neither object is modified.</p>
<p class="indenthangingB">• <em>Not null</em>: <code>x.equals(null)</code> returns <code>false.</code></p>
<p><a id="page_103"/>These are natural definitions, but ensuring that these properties hold, adhering to Java conventions, and avoiding unnecessary work in an implementation can be tricky, as illustrated for <code>Date</code> below. It takes the following step-by-step approach:</p>
<p class="indenthangingB">• If the reference to this object is the same as the reference to the argument object, return <code>true</code>. This test saves the work of doing all the other checks in this case.</p>
<p class="indenthangingB">• If the argument is null, return <code>false</code>, to adhere to the convention (and to avoid following a null reference in code to follow).</p>
<p class="indenthangingB">• If the objects are not from the same class, return <code>false</code>. To determine an object’s class, we use <code>getClass()</code>. Note that we can use <code>==</code> to tell us whether two objects of type <code>Class</code> are equal because <code>getClass()</code> is guaranteed to return the same reference for all objects in any given class.</p>
<p class="indenthangingB">• Cast the argument from <code>Object</code> to <code>Date</code> (this cast must succeed because of the previous test).</p>
<p class="indenthangingB">• Return <code>false</code> if any instance variables do not match. For other classes, some other definition of equality might be appropriate. For example, we might regard two <code>Counter</code> objects as equal if their <code>count</code> instance variables are equal.</p>
<p class="image"><img alt="image" src="graphics/p0103-01.jpg"/></p>
<p>This implementation is a model that you can use to implement <code>equals()</code> for any type that you implement. Once you have implemented one <code>equals()</code>, you will not find it difficult to implement another.</p>
<p><a id="ch01sec3lev80"/></p>
<h5><a id="page_104"/><em>Memory management</em></h5>
<p>The ability to assign a new value to a reference variable creates the possibility that a program may have created an object that can no longer be referenced. For example, consider the three assignment statements in the figure at left. After the third assignment statement, not only do <code>a</code> and <code>b</code> refer to the same <code>Date</code> object (12/31/1999), but also there is no longer a reference to the <code>Date</code> object that was created and used to initialize <code>b</code>. The only reference to that object was in the variable <code>b</code>, and this reference was overwritten by the assignment, so there is no way to refer to the object again. Such an object is said to be <em>orphaned</em>. Objects are also orphaned when they go out of scope. Java programs tend to create huge numbers of objects (and variables that hold primitive data-type values), but only have a need for a small number of them at any given point in time. Accordingly, programming languages and systems need mechanisms to <em>allocate</em> memory for data-type values during the time they are needed and to <em>free</em> the memory when they are no longer needed (for an object, sometime after it is orphaned). Memory management turns out to be easier for primitive types because all of the information needed for memory allocation is known at compile time. Java (and most other systems) takes care of reserving space for variables when they are declared and freeing that space when they go out of scope. Memory management for objects is more complicated: the system can allocate memory for an object when it is created, but cannot know precisely when to free the memory associated with each object because the dynamics of a program in execution determines when objects are orphaned. In many languages (such as C and C++) the programmer is responsible for both allocating and freeing memory. Doing so is tedious and notoriously error-prone. One of Java’s most significant features is its ability to <em>automatically</em> manage memory. The idea is to free the programmers from the responsibility of managing memory by keeping track of orphaned objects and returning the memory they use to a pool of free memory. Reclaiming memory in this way is known as <em>garbage collection</em>. One of Java’s characteristic features is its policy that references cannot be modified. This policy enables Java to do efficient automatic garbage collection. Programmers still debate whether the overhead of automatic garbage collection justifies the convenience of not having to worry about memory management.</p>
<p class="image"><img alt="image" src="graphics/01_27-objectreporphan.jpg"/></p>
<p><a id="ch01sec3lev81"/></p>
<h5><a id="page_105"/><em>Immutability</em></h5>
<p>An <em>immutable</em> data type, such as <code>Date</code>, has the property that the value of an object never changes once constructed. By contrast, a <em>mutable</em> data type, such as <code>Counter</code> or <code>Accumulator</code>, manipulates object values that are intended to change. Java’s language support for helping to enforce immutability is the <code>final</code> modifier. When you declare a variable to be <code>final</code>, you are promising to assign it a value only once, either in an initializer or in the constructor. Code that could modify the value of a <code>final</code> variable leads to a compile-time error. In our code, we use the modifier <code>final</code> with instance variables whose values never change. This policy serves as documentation that the value does not change, prevents accidental changes, and makes programs easier to debug. For example, you do not have to include a <code>final</code> value in a trace, since you know that its value never changes. A data type such as <code>Date</code> whose instance variables are all primitive and <code>final</code> is immutable (in code that does not use implementation inheritence, our convention). Whether to make a data type immutable is an important design decision and depends on the application at hand. For data types such as <code>Date</code>, the purpose of the abstraction is to encapsulate values that do not change so that we can use them in assignment statements and as arguments and return values from functions in the same way as we use primitive types (without having to worry about their values changing). A programmer implementing a <code>Date</code> client might reasonably expect to write the code <code>d = d0</code> for two <code>Date</code> variables, in the same way as for <code>double</code> or <code>int</code> values. But if <code>Date</code> were mutable and the value of <code>d</code> were to change <em>after</em> the assignment <code>d = d0</code>, then the value of <code>d0</code> would <em>also</em> change (they are both references to the same object)! On the other hand, for data types such as <code>Counter</code> and <code>Accumulator</code>, the very purpose of the abstraction is to encapsulate values as they change. You have already encountered this distinction as a client programmer, when using Java arrays (mutable) and Java’s <code>String</code> data type (immutable). When you pass a <code>String</code> to a method, you do not worry about that method changing the sequence of characters in the <code>String</code>, but when you pass an array to a method, the method is free to change the contents of the array. <code>String</code> objects are immutable because we generally do <em>not</em> want <code>String</code> values to change, and Java arrays are mutable because we generally <em>do</em> want array values to change. There are also situations where we want to have mutable strings (that is the purpose of Java’s <code>StringBuilder</code> class) and where we want to have immutable arrays (that is the purpose of the <code>Vector</code> class that we consider later in this section). Generally, immutable types are easier to use and harder to misuse than mutable types because the scope of code that can change their values is far smaller. It is easier to debug code that uses immutable types because it is easier to guarantee that variables in client code that uses them remain in a consistent state. When using mutable types, <a id="page_106"/>you must always be concerned about where and when their values change. The downside of immutability is that <em>a new object must be created for every value</em>. This expense is normally manageable because Java garbage collectors are typically optimized for such situations. Another downside of immutability stems from the fact that, unfortunately, <code>final</code> guarantees immutability only when instance variables are primitive types, not reference types. If an instance variable of a reference type has the <code>final</code> modifier, the value of that instance variable (the reference to an object) will never change—it will always refer to the same object—but the value of the object itself <em>can</em> change. For example, this code does <em>not</em> implement an immutable type:</p>
<p class="programlisting"><img alt="image" src="graphics/p0106-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0105-01.jpg"/></p>
<p>A client program could create a <code>Vector</code> by specifying the entries in an array, and then (bypassing the API) change the elements of the <code>Vector</code> after construction:</p>
<p class="programlisting"><img alt="image" src="graphics/p0106-02.jpg"/></p>
<p>The instance variable <code>coords[]</code> is <code>private</code> and <code>final</code>, but <code>Vector</code> is mutable because the client holds a reference to the data. Immutability needs to be taken into account in any data-type design, and whether a data type is immutable should be specified in the API, so that clients know that object values will not change. In this book, our primary interest in immutability is for use in certifying the correctness of our algorithms. For example, if the type of data used for a binary search algorithm were mutable, then clients could invalidate our assumption that the array is sorted for binary search.</p>
<p><a id="ch01sec3lev82"/></p>
<h5><a id="page_107"/><em>Design by contract</em></h5>
<p>To conclude, we briefly discuss Java language mechanisms that enables you to verify assumptions about your program <em>as it is running</em>. We use two Java language mechanisms for this purpose:</p>
<p class="indenthangingB">• Exceptions and errors, which generally handle unforeseen errors <em>outside</em> our control</p>
<p class="indenthangingB">• Assertions, which verify assumptions that we make <em>within</em> code we develop</p>
<p>Liberal use of both exceptions and assertions is good programming practice. We use them sparingly in the book for economy, but you will find them throughout the code on the booksite. This code aligns with a substantial amount of the surrounding commentary about each algorithm in the text that has to do with exceptional conditions and with asserted invariants.</p>
<p><a id="ch01sec3lev83"/></p>
<h5><em>Exceptions and errors</em></h5>
<p><em>Exceptions</em> and <em>errors</em> are disruptive events that occur while a program is running, often to signal an error. The action taken is known as <em>throwing an exception or throwing an error</em>. We have already encountered exceptions thrown by Java system methods in the course of learning basic features of Java: <code>StackOverflowError</code>, <code>ArithmeticException</code>, <code>ArrayIndexOutOfBoundsException</code>, <code>OutOfMemoryError</code>, and <code>NullPointerException</code> are typical examples. You can also create your own exceptions. The simplest kind is a <code>RuntimeException</code> that terminates execution of the program and prints an error message</p>
<p class="programlisting">throw new RuntimeException("Error message here.");</p>
<p>A general practice known as <em>fail fast</em> programming suggests that an error is more easily pinpointed if an exception is thrown as soon as an error is discovered (as opposed to ignoring the error and deferring the exception to sometime in the future).</p>
<p><a id="ch01sec3lev84"/></p>
<h5><em>Assertions</em></h5>
<p>An <em>assertion</em> is a boolean expression that you are affirming is <code>true</code> at that point in the program. If the expression is <code>false</code>, the program will terminate and report an error message. We use assertions both to gain confidence in the correctness of programs and to document intent. For example, suppose that you have a computed value that you might use to index into an array. If this value were negative, it would cause an <code>ArrayIndexOutOfBoundsException</code> sometime later. But if you write the code <code>assert index &gt;= 0;</code> you can pinpoint the place where the error occurred. You can also add an optional detail message such as</p>
<p class="programlisting">assert index &gt;= 0 : "Negative index in method X";</p>
<p>to help you locate the bug. By default, assertions are disabled. You can enable them from the command line by using the <code>-enableassertions</code> flag (<code>-ea</code> for short). Assertions are for debugging: your program should not rely on assertions for normal operation since they may be disabled. When you take a course in systems programming, you will learn <a id="page_108"/>to use assertions to ensure that your code <em>never</em> terminates in a system error or goes into an infinite loop. One model, known as the <em>design-by-contract</em> model of programming expresses the idea. The designer of a data type expresses a <em>precondition</em> (the condition that the client promises to satisfy when calling a method), a <em>postcondition</em> (the condition that the implementation promises to achieve when returning from a method), and <em>side effects</em> (any other change in state that the method could cause). During development, these conditions can be tested with assertions.</p>
<p><a id="ch01sec3lev85"/></p>
<h5><em>Summary</em></h5>
<p>The language mechanisms discussed throughout this section illustrate that effective data-type design leads to nontrivial issues that are not easy to resolve. Experts are still debating the best ways to support some of the design ideas that we are discussing. Why does Java not allow functions as arguments? Why does Matlab copy arrays passed as arguments to functions? As mentioned early in <a href="#ch01"><small>CHAPTER 1</small></a>, it is a slippery slope from complaining about features in a programming language to becoming a programming-language designer. If you do not plan to do so, your best strategy is to use widely available languages. Most systems have extensive libraries that you certainly should use when appropriate, but you often can simplify your client code and protect yourself by building abstractions that can easily transport to other languages. Your main goal is to develop data types so that most of your work is done at a level of abstraction that is appropriate to the problem at hand.</p>
<p>The table on the facing page summarizes the various kinds of Java classes that we have considered.</p>
<p class="image"><a id="page_109"/><img alt="image" src="graphics/t0109-01.jpg"/></p>
<p><a id="ch01sec2lev21"/></p>
<h4><a id="page_110"/>Q &amp; A</h4>
<p><strong>Q.</strong> Why bother with data abstraction?</p>
<p><strong>A.</strong> It helps us produce reliable and correct code. For example, in the 2000 presidential election, Al Gore received –16,022 votes on an electronic voting machine in Volusia County, Florida—the tally was clearly not properly encapsulated in the voting machine software!</p>
<p><strong>Q.</strong> Why the distinction between primitive and reference types? Why not just have reference types?</p>
<p><strong>A.</strong> Performance. Java provides the reference types <code>Integer</code>, <code>Double</code>, and so forth that correspond to primitive types that can be used by programmers who prefer to ignore the distinction. Primitive types are closer to the types of data that are supported by computer hardware, so programs that use them usually run faster than programs that use corresponding reference types.</p>
<p><strong>Q.</strong> Do data types <em>have</em> to be abstract?</p>
<p><strong>A.</strong> No. Java also allows <code>public</code> and <code>protected</code> to allow some clients to refer directly to instance variables. As described in the text, the advantages of allowing client code to directly refer to data are greatly outweighed by the disadvantages of dependence on a particular representation, so all instance variables are <code>private</code> in our code. We also occasionally use <code>private</code> instance methods to share code among public methods.</p>
<p><strong>Q.</strong> What happens if I forget to use <code>new</code> when creating an object?</p>
<p><strong>A.</strong> To Java, it looks as though you want to call a static method with a return value of the object type. Since you have not defined such a method, the error message is the same as anytime you refer to an undefined symbol. If you compile the code</p>
<p class="programlisting">Counter c = Counter("test");</p>
<p>you get this error message:</p>
<p class="programlisting">cannot find symbol<br/>
symbol  : method Counter(String)</p>
<p>You get the same kind of error message if you provide the wrong number of arguments to a constructor.</p>
<p><a id="page_111"/><strong>Q.</strong> What happens if I forget to use <code>new</code> when creating an array of objects?</p>
<p><strong>A.</strong> You need to use <code>new</code> for each object that you create, so when you create an array of <em>N</em> objects, you need to use <code>new</code> <em>N</em>+1 times: once for the array and once for each of the objects. If you forget to create the array:</p>
<p class="programlisting">Counter[] a;<br/>
a[0] = new Counter("test");</p>
<p>you get the same error message that you would get when trying to assign a value to any uninitialized variable:</p>
<p class="programlisting"><img alt="image" src="graphics/p0111-02.jpg"/></p>
<p>but if you forget to use <code>new</code> when creating an object within the array and then try to use it to invoke a method:</p>
<p class="programlisting">Counter[] a = new Counter[2];<br/>
a[0].increment();</p>
<p>you get a <code>NullPointerException</code>.</p>
<p><strong>Q.</strong> Why not write <code>StdOut.println(x.toString())</code> to print objects?</p>
<p><strong>A.</strong> That code works fine, but Java saves us the trouble of writing it by automatically invoking the <code>toString()</code> method for any object, since <code>println()</code> has a method that takes an <code>Object</code> as argument.</p>
<p><strong>Q.</strong> What is a <em>pointer</em>?</p>
<p><strong>A.</strong> Good question. Perhaps that should be <code>NullReferenceException</code>. Like a Java reference, you can think of a <em>pointer</em> as a machine address. In many programming languages, the pointer is a primitive data type that programmers can manipulate in many ways. But programming with pointers is notoriously error-prone, so operations provided for pointers need to be carefully designed to help programmers avoid errors. Java takes this point of view to an extreme (that is favored by many modern programming-language designers). In Java, there is only <em>one</em> way to create a reference (<code>new</code>) and only <em>one</em> way to change a reference (with an assignment statement). That is, the only things that a programmer can do with references are to create them and copy them. In <a id="page_112"/>programming-language jargon, Java references are known as <em>safe pointers</em>, because Java can guarantee that each reference points to an object of the specified type (and it can determine which objects are not in use, for garbage collection). Programmers used to writing code that directly manipulates pointers think of Java as having no pointers at all, but people still debate whether it is really desirable to have unsafe pointers.</p>
<p><strong>Q.</strong> Where can I find more details on how Java implements references and does garbage collection?</p>
<p><strong>A.</strong> One Java system might differ completely from another. For example, one natural scheme is to use a pointer (machine address); another is to use a <em>handle</em> (a pointer to a pointer). The former gives faster access to data; the latter provides for better garbage collection.</p>
<p><strong>Q.</strong> What exactly does it mean to <code>import</code> a name?</p>
<p><strong>A.</strong> Not much: it just saves some typing. You could type <code>java.util.Arrays</code> instead of <code>Arrays</code> everywhere in your code instead of using the <code>import</code> statement.</p>
<p><strong>Q.</strong> What is the problem with implementation inheritance?</p>
<p><strong>A.</strong> Subtyping makes modular programming more difficult for two reasons. First, any change in the superclass affects all subclasses. The subclass cannot be developed <em>independently</em> of the superclass; indeed, it is <em>completely dependent</em> on the superclass. This problem is known as the <em>fragile base class</em> problem. Second, the subclass code, having access to instance variables, can subvert the intention of the superclass code. For example, the designer of a class like <code>Counter</code> for a voting system may take great care to make it so that <code>Counter</code> can only increment the tally by one (remember Al Gore’s problem). But a subclass, with full access to the instance variable, can change it to any value whatever.</p>
<p><strong>Q.</strong> How do I make a class immutable?</p>
<p><strong>A.</strong> To ensure immutability of a data type that includes an instance variable of a mutable type, we need to make a local copy, known as a <em>defensive copy</em>. And that may not be enough. Making the copy is one challenge; ensuring that none of the instance methods change values is another.</p>
<p><strong>Q.</strong> What is <code>null</code>?</p>
<p><a id="page_113"/><strong>A.</strong> It is a literal value that refers to no object. Invoking a method using the <code>null</code> reference is meaningless and results in a <code>NullPointerException</code>. If you get this error message, check to make sure that your constructor properly initializes all of its instance variables.</p>
<p><strong>Q.</strong> Can I have a static method in a class that implements a data type?</p>
<p><strong>A.</strong> Of course. For example, all of our classes have <code>main().</code> Also, it is natural to consider adding static methods for operations that involve multiple objects where none of them naturally suggests itself as the one that should invoke the method. For example, we might define a static method like the following within <code>Point</code>:</p>
<p class="programlisting"><img alt="image" src="graphics/p0113-01.jpg"/></p>
<p>Often, including such methods can serve to clarify client code.</p>
<p><strong>Q.</strong> Are there other kinds of variables besides parameter, local, and instance variables?</p>
<p><strong>A.</strong> If you include the keyword <code>static</code> in a class declaration (outside of any type) it creates a completely different type of variable, known as a <em>static variable</em>. Like instance variables, static variables are accessible to every method in the class; however, they are not associated with any object. In older programming languages, such variables are known as <em>global variables</em>, because of their global scope. In modern programming, we focus on limiting scope and therefore rarely use such variables. When we do, we will call attention to them.</p>
<p><strong>Q.</strong> What is a <em>deprecated</em> method?</p>
<p><strong>A.</strong> A method that is no longer fully supported, but kept in an API to maintain compatibility. For example, Java once included a method <code>Character.isSpace()</code>, and programmers wrote programs that relied on using that method’s behavior. When the designers of Java later wanted to support additional Unicode whitespace characters, they could not change the behavior of <code>isSpace()</code> without breaking client programs, so, instead, they added a new method, <code>Character.isWhiteSpace()</code>, and deprecated the old method. As time wears on, this practice certainly complicates APIs. Sometimes, entire classes are deprecated. For example, Java deprecated its <code>java.util.Date</code> in order to better support internationalization.</p>
<p><a id="ch01sec2lev22"/></p>
<h4><a id="page_114"/>Exercises</h4>
<p><a id="ch01qa2q1"/><strong>1.2.1</strong> Write a <code>Point2D</code> client that takes an integer value <em>N</em> from the command line, generates <em>N</em> random points in the unit square, and computes the distance separating the <em>closest pair</em> of points.</p>
<p><a id="ch01qa2q2"/><strong>1.2.2</strong> Write an <code>Interval1D</code> client that takes an <code>int</code> value <em>N</em> as command-line argument, reads <em>N</em> intervals (each defined by a pair of <code>double</code> values) from standard input, and prints all pairs that intersect.</p>
<p><a id="ch01qa2q3"/><strong>1.2.3</strong> Write an <code>Interval2D</code> client that takes command-line arguments <code>N</code>, <code>min</code>, and <code>max</code> and generates <code>N</code> random 2D intervals whose width and height are uniformly distributed between <code>min</code> and <code>max</code> in the unit square. Draw them on <code>StdDraw</code> and print the number of pairs of intervals that intersect and the number of intervals that are contained in one another.</p>
<p><a id="ch01qa2q4"/><strong>1.2.4</strong> What does the following code fragment print?</p>
<p class="programlisting"><img alt="image" src="graphics/p0114-01.jpg"/></p>
<p><a id="ch01qa2q5"/><strong>1.2.5</strong> What does the following code fragment print?</p>
<p class="programlisting"><img alt="image" src="graphics/p0114-02.jpg"/></p>
<p><em>Answer</em>: <code>"Hello World"</code>. <code>String</code> objects are immutable—string methods return a new <code>String</code> object with the appropriate value (but they do not change the value of the object that was used to invoke them). This code ignores the objects returned and just prints the original string. To print <code>"WORLD"</code>, use <code>s = s.toUpperCase()</code> and <code>s = s.substring(6, 11)</code>.</p>
<p><a id="ch01qa2q6"/><strong>1.2.6</strong> A string <code>s</code> is a <em>circular rotation</em> of a string <code>t</code> if it matches when the characters are circularly shifted by any number of positions; e.g., <code>ACTGACG</code> is a circular shift of <code>TGACGAC</code>, and vice versa. Detecting this condition is important in the study of genomic sequences. Write a program that checks whether two given strings <code>s</code> and <code>t</code> are circular <a id="page_115"/>shifts of one another. <em>Hint</em>: The solution is a one-liner with <code>indexOf()</code>, <code>length()</code>, and string concatenation.</p>
<p><a id="ch01qa2q7"/><strong>1.2.7</strong> What does the following recursive function return?</p>
<p class="programlisting"><img alt="image" src="graphics/p0115-01.jpg"/></p>
<p><a id="ch01qa2q8"/><strong>1.2.8</strong> Suppose that <code>a[]</code> and <code>b[]</code> are each integer arrays consisting of millions of integers. What does the follow code do? Is it reasonably efficient?</p>
<p class="programlisting">int[] t = a; a = b; b = t;</p>
<p><em>Answer</em>. It swaps them. It could hardly be more efficient because it does so by copying references, so that it is not necessary to copy millions of elements.</p>
<p><a id="ch01qa2q9"/><strong>1.2.9</strong> Instrument <code>BinarySearch</code> (page <a href="#ch01sb02">47</a>) to use a <code>Counter</code> to count the total number of keys examined during all searches and then print the total after all searches are complete. <em>Hint</em>: Create a <code>Counter</code> in <code>main()</code> and pass it as an argument to <code>rank()</code>.</p>
<p><a id="ch01qa2q10"/><strong>1.2.10</strong> Develop a class <code>VisualCounter</code> that allows both increment and decrement operations. Take two arguments <code>N</code> and <code>max</code> in the constructor, where <code>N</code> specifies the maximum number of operations and <code>max</code> specifies the maximum absolute value for the counter. As a side effect, create a plot showing the value of the counter each time its tally changes.</p>
<p><a id="ch01qa2q11"/><strong>1.2.11</strong> Develop an implementation <code>SmartDate</code> of our <code>Date</code> API that raises an exception if the date is not legal.</p>
<p><a id="ch01qa2q12"/><strong>1.2.12</strong> Add a method <code>dayOfTheWeek()</code> to <code>SmartDate</code> that returns a <code>String</code> value <code>Monday</code>, <code>Tuesday</code>, <code>Wednesday</code>, <code>Thursday</code>, <code>Friday</code>, <code>Saturday</code>, or <code>Sunday</code>, giving the appropriate day of the week for the date. You may assume that the date is in the 21st century.</p>
<p><a id="page_116"/><a id="ch01qa2q13"/><strong>1.2.13</strong> Using our implementation of <code>Date</code> as a model (page <a href="#page_91">91</a>), develop an implementation of <code>Transaction</code>.</p>
<p><a id="ch01qa2q14"/><strong>1.2.14</strong> Using our implementation of <code>equals()</code> in <code>Date</code> as a model (page <a href="#page_103">103</a>), developan implementation of <code>equals()</code> for <code>Transaction</code>.</p>
<p><a id="ch01sec2lev23"/></p>
<h4><a id="page_117"/>Creative Problems</h4>
<p><a id="ch01qa2q15"/><strong>1.2.15</strong> <em>File input.</em> Develop a possible implementation of the static <code>readInts()</code> method from <code>In</code> (which we use for various test clients, such as binary search on page <a href="#ch01sb02">47</a>) that is based on the <code>split()</code> method in <code>String</code>.</p>
<p><em>Solution</em>:</p>
<p class="programlisting"><img alt="image" src="graphics/p0117-01.jpg"/></p>
<p>We will consider a different implementation in <a href="ch01a.html#ch01sec1lev5"><small>SECTION 1.3</small></a> (see page <a href="ch01a.html#page_126">126</a>).</p>
<p><a id="ch01qa2q16"/><strong>1.2.16</strong> <em>Rational numbers.</em> Implement an immutable data type <code>Rational</code> for rational numbers that supports addition, subtraction, multiplication, and division.</p>
<p class="image"><img alt="image" src="graphics/t0117-01.jpg"/></p>
<p>You do not have to worry about testing for overflow (see <a href="#ch01qa2q17"><small>EXERCISE 1.2.17</small></a>), but use as instance variables two <code>long</code> values that represent the numerator and denominator to limit the possibility of overflow. Use Euclid’s algorithm (see page <a href="#ch01sec1lev1">4</a>) to ensure that the numerator and denominator never have any common factors. Include a test client that exercises all of your methods.</p>
<p><a id="page_118"/><a id="ch01qa2q17"/><strong>1.2.17</strong> <em>Robust implementation of rational numbers.</em> Use assertions to develop an implementation of <code>Rational</code> (see <a href="#ch01qa2q16"><small>EXERCISE 1.2.16</small></a>) that is immune to overflow.</p>
<p><a id="ch01qa2q18"/><strong>1.2.18</strong> <em>Variance for accumulator.</em> Validate that the following code, which adds the methods <code>var()</code> and <code>stddev()</code> to <code>Accumulator</code>, computes both the mean and variance of the numbers presented as arguments to <code>addDataValue()</code>:</p>
<p class="programlisting"><img alt="image" src="graphics/p0118-01.jpg"/></p>
<p>This implementation is less susceptible to roundoff error than the straightforward implementation based on saving the sum of the squares of the numbers.</p>
<p><a id="page_119"/><a id="ch01qa2q19"/><strong>1.2.19</strong> <em>Parsing.</em> Develop the parse constructors for your <code>Date</code> and <code>Transaction</code> implementations of <a href="#ch01qa2q13"><small>EXERCISE 1.2.13</small></a> that take a single <code>String</code> argument to specify the initialization values, using the formats given in the table below.</p>
<p><em>Partial solution</em>:</p>
<p class="programlisting"><img alt="image" src="graphics/p0119-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0119-01.jpg"/></p>
</body>
</html>