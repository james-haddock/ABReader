<?xml version="1.0" encoding="UTF-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Three. Searching</title>
<link href="9780132762564.css" rel="stylesheet" type="text/css"/>
<link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml"/>
<meta name="Adept.resource" value="urn:uuid:7baf5dbb-ffe1-4201-87bd-b993ed04f947"/>
</head>
<body>
<p><a id="ch03a"/></p>
<p><a id="ch03sec1lev5"/></p>
<h3><a id="page_486"/>3.5 Applications</h3>
<p><small>FROM THE EARLY DAYS OF COMPUTING</small>, when symbol tables allowed programmers to progress from using numeric addresses in machine language to using symbolic names in assembly language, to modern applications of the new millennium, when symbolic names have meaning across worldwide computer networks, fast search algorithms have played and continue to play an essential role in computation. Modern applications for symbol tables include organization of scientific data, from searching for markers or patterns in genomic data to mapping the universe; organization of knowledge on the web, from searching in online commerce to putting libraries online; and implementing the internet infrastructure, from routing packets among machines on the web to shared file systems and video streaming. Efficient search algorithms have enabled these and countless other important applications. We will consider several representative examples in this section:</p>
<p class="indenthangingB">• A dictionary client and an indexing client that enable fast and flexible access to information in comma-separated-value files (and similar formats), which are widely used to store data on the web</p>
<p class="indenthangingB">• An indexing client for building an inverted index of a set of files</p>
<p class="indenthangingB">• A sparse-matrix data type that uses a symbol table to address problem sizes far beyond what is possible with the standard implementation</p>
<p>In <a href="ch06.html#ch06"><small>CHAPTER 6</small></a>, we consider a symbol table that is appropriate for tables such as databases and file systems that contain a vast number of keys, as large as can be reasonably contemplated.</p>
<p>Symbol tables also play a critical role in algorithms that we consider throughout the rest of the book. For example, we use symbol tables to represent graphs (<a href="ch04.html#ch04"><small>CHAPTER 4</small></a>) and to process strings (<a href="ch05.html#ch05"><small>CHAPTER 5</small></a>).</p>
<p>As we have seen throughout this chapter, developing symbol-table implementations that can guarantee fast performance for all operations is certainly a challenging task. On the other hand, the implementations that we have considered are well-studied, widely used, and available in many software environments (including Java libraries). From this point forward, you certainly should consider the symbol-table abstraction to be a key component in your programmer’s toolbox.</p>
<p><a id="ch03sec2lev37"/></p>
<h4><a id="page_487"/>Which symbol-table implementation should I use?</h4>
<p>The table at the bottom of this page summarizes the performance characteristics of the algorithms that we have considered in propositions and properties in this chapter (with the exception of the worst-case results for hashing, which are from the research literature and unlikely to be experienced in practice). It is clear from the table that, for typical applications, your decision comes down to a choice between hash tables and binary search trees.</p>
<p>The advantages of hashing over BST implementations are that the code is simpler and search times are optimal (constant), if the keys are of a standard type or are sufficiently simple that we can be confident of developing an efficient hash function for them that (approximately) satisfies the uniform hashing assumption. The advantages of BSTs over hashing are that they are based on a simpler abstract interface (no hash function need be designed); red-black BSTs can provide guaranteed worst-case performance; and they support a wider range of operations (such as rank, select, sort, and range search). As a rule of thumb, most programmers will use hashing except when one or more of these factors is important, when red-black BSTs are called for. In <a href="ch05.html#ch05"><small>CHAPTER 5</small></a>, we will study one exception to this rule of thumb: when keys are long strings, we can build data structures that are even more flexible than red-black BSTs and even faster than hashing.</p>
<p class="image"><img alt="image" src="graphics/t0487-01.jpg"/></p>
<p><a id="page_488"/>Our symbol-table implementations are useful for a wide range of applications, but our algorithms are easily adapted to support several other options that are widely used and worth considering.</p>
<p><a id="ch03sec3lev77"/></p>
<h5><em>Primitive types</em></h5>
<p>Suppose that we have a symbol table with integer keys and associated floating-point numbers. When we use our standard setup, the keys and values are stored as <code>Integer</code> and <code>Double</code> wrapper-type values, so we need two extra memory references to access each key-value pair. These references may be no problem in an application that involves thousands of searches on thousands of keys but may represent excessive cost in an application that involves billions of searches on millions of keys. Using a primitive type instead of <code>Key</code> would save one reference per key-value pair. When the associated value is also primitive, we can eliminate another reference. The situation is diagrammed at right for separate chaining; the same tradeoffs hold for other implementations. For performance-critical applications, it is worthwhile and not difficult to develop versions of our implementations along these lines (see <a href="#ch03qa5q4"><small>EXERCISE 3.5.4</small></a>).</p>
<p class="image"><img alt="image" src="graphics/03_74-hashprimitive.jpg"/></p>
<p><a id="ch03sec3lev78"/></p>
<h5><em>Duplicate keys</em></h5>
<p>The possibility of duplicate keys sometimes needs special consideration in symbol-table implementations. In many applications, it is desirable to associate multiple values with the same key. For example, in a transaction-processing system, numerous transactions may have the same customer key value. Our convention to disallow duplicate keys amounts to leaving duplicate-key management to the client. We will consider an example of such a client later in this section. In many of our implementations, we could consider the alternative of leaving key-value pairs with duplicate keys in the primary search data structure and to return <em>any</em> value with the given key for a search. We might also add methods to return <em>all</em> values with the given key. Our BST and hashing implementations are not difficult to adapt to keep duplicate keys within the data structure; doing so for red-black BSTs is just slightly more challenging (see <a href="#ch03qa5q9"><small>EXERCISE 3.5.9</small></a> and <a href="#ch03qa5q10"><small>EXERCISE 3.5.10</small></a>). Such implementations are common in the literature (including earlier editions of this book).</p>
<p><a id="ch03sec3lev79"/></p>
<h5><a id="page_489"/><em>Java libraries</em></h5>
<p>Java’s <code>java.util.TreeMap</code> and <code>java.util.HashMap</code> libraries are symbol-table implementations based on red-black BSTs and hashing with separate chaining respectively. <code>TreeMap</code> does not directly support <code>rank()</code>, <code>select()</code>, and other operations in our ordered symbol-table API, but it does support operations that enable efficient implementation of these. <code>HashMap</code> is roughly equivalent to our <code>LinearProbingST</code> implementation—it uses array resizing to enforce a load factor of about 75 percent.</p>
<p><small>TO BE CONSISTENT AND SPECIFIC</small>, we use in this book the symbol-table implementation based on red-black BSTs from <a href="ch03.html#ch03sec1lev3"><small>SECTION 3.3</small></a> or the one based on linear-probing hashing from <a href="ch03.html#ch03sec1lev4"><small>SECTION 3.4</small></a>. For economy and to emphasize client independence from specific implementations, we use the name <code>ST</code> as shorthand for <code>RedBlackBST</code> for ordered symbol tables in client code and the name <code>HashST</code> as shorthand for <code>LinearProbingHashST</code> when order is not important and hash functions are available. We adopt these conventions with full knowledge that specific applications might have demands that could call for some variation or extension of one of these algorithms and data structures. Which symbol table should you use? Whatever you decide, test your choice to be sure that it is delivering the performance that you expect.</p>
<p><a id="ch03sec2lev38"/></p>
<h4>Set APIs</h4>
<p>Some symbol-table clients do not need the values, just the ability to insert keys into a table and to test whether a key is in the table. Because we disallow duplicate keys, these operations correspond to the following API where we are just interested in the <em>set</em> of keys in the table, not any associated values:</p>
<p class="image"><img alt="image" src="graphics/t0489-01.jpg"/></p>
<p>You can turn any symbol-table implementation into a <code>SET</code> implementation by ignoring values or by using a simple wrapper class (see <a href="#ch03qa5q1"><small>EXERCISES 3.5.1</small></a> through <a href="#ch03qa5q3">3.5.3</a>).</p>
<p><a id="page_490"/>Extending <code>SET</code> to include <em>union</em>, <em>intersection</em>, <em>complement</em>, and other common mathematical set operations requires a more sophisticated API (for example, the <em>complement</em> operation requires some mechanism for specifying a <em>universe</em> of all possible keys) and provides a number of interesting algorithmic challenges, as discussed in <a href="#ch03qa5q17"><small>EXERCISE 3.5.17</small></a>.</p>
<p>As with <code>ST</code>, we have unordered and ordered versions of <code>SET</code>. If keys are <code>Comparable</code>, we can include <code>min()</code>, <code>max()</code>, <code>floor()</code>, <code>ceiling()</code>, <code>deleteMin()</code>, <code>deleteMax()</code>, <code>rank()</code>, <code>select()</code>, and the two-argument versions of <code>size()</code> and <code>get()</code> to define a full API for ordered keys. To match our <code>ST</code> conventions, we use the name <code>SET</code> in client code for ordered sets and the name <code>HashSET</code> when order is not important.</p>
<p>To illustrate uses of <code>SET</code>, we consider <em>filter</em> clients that read a sequence of strings from standard input and write some of them to standard output. Such clients have their origin in early systems where main memory was far too small to hold all the data, and they are still relevant today, when we write programs that take their input from the web. As example input, we use <code>tinyTale.txt</code> (see page <a href="ch03.html#page_371">371</a>). For readability, we preserve newlines from the input to the output in examples, even though the code does not do so.</p>
<p><a id="ch03sec3lev80"/></p>
<h5><em>Dedup</em></h5>
<p>The prototypical filter example is a <code>SET</code> or <code>HashSET</code> client that removes duplicates in the input stream. It is customary to refer to this operation as <em>dedup</em>. We maintain a set of the string keys seen so far. If the next key is <em>in</em> the set, ignore it; if it is <em>not in</em> the set, add it to the set and print it. The keys appear on standard output in the order they appear on standard input, with duplicates removed. This process takes space proportional to the number of distinct keys in the input stream (which is typically far smaller than the total number of keys).</p>
<p class="image"><img alt="image" src="graphics/p0490-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/p0490-02.jpg"/></p>
<p><a id="ch03sec3lev81"/></p>
<h5><a id="page_491"/><em>Whitelist and blacklist</em></h5>
<p>Another classic filter uses keys in a separate file to decide which keys from the input stream are passed to the output stream. This general process has many natural applications. The simplest example is a <em>whitelist</em>, where any key that is in the file is identified as “good.” The client might choose to pass through to standard output any key that is <em>not in</em> the whitelist and to ignore any key that is <em>in</em> the whitelist (as in the example considered in our first program in <a href="ch01.html#ch01"><small>CHAPTER 1</small></a>); another client might choose to pass through to standard output any key that is <em>in</em> the whitelist and to ignore any key that is <em>not in</em> the whitelist (as shown in the <code>HashSET</code> client <code>WhiteFilter</code> at right). For example, your email application might use such a filter to allow you to specify the addresses of your friends and to direct it to consider emails from anyone else as spam. We build a <code>HashSET</code> of the keys in the specified list, then read the keys from standard input. If the next key is <em>in</em> the set, print it; if it is <em>not in</em> the set, ignore it. A <em>blacklist</em> is the opposite, where any key that is in the file is identified as “bad.” Again, there are two natural filters for clients using a blacklist. In our email example, you might specify the addresses of known spammers and direct the email application to let through all mail not from one of those addresses. We can implement a <code>HashSET</code> client <code>BlackFilter</code> that implements this filter by negating the filter test in <code>WhiteFilter</code>. Typical practical situations such as a credit card company using a blacklist to filter out stolen card numbers or an internet router using a whitelist to implement a firewall are likely to involve huge lists, unbounded input streams, and strict response requirements. The sorts of symbol-table implementations that we have considered enable such challenges to easily be met.</p>
<p class="image"><img alt="image" src="graphics/p0491-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/p0491-02.jpg"/></p>
<p><a id="ch03sec2lev39"/></p>
<h4><a id="page_492"/>Dictionary clients</h4>
<p>The most basic kind of symbol-table client builds a symbol table with successive <em>put</em> operations in order to support <em>get</em> requests. Many applications also take advantage of the idea that a symbol table is a <em>dynamic</em> dictionary, where it is easy to look up information <em>and</em> to update the information in the table. The following list of familiar examples illustrates the utility of this approach:</p>
<p class="indenthangingB">• <em>Phone book</em>. When keys are people’s names and values are their phone numbers, a symbol table models a phone book. A very significant difference from a printed phone book is that we can add new names or change existing phone numbers. We could also use the phone number as the key and the name as the value—if you have never done so, try typing your phone number (with area code) into the search field in your browser.</p>
<p class="indenthangingB">• <em>Dictionary</em>. Associating a word with its definition is a familiar concept that gives us the name “dictionary.” For centuries people kept printed dictionaries in their homes and offices in order to check the definitions and spellings (values) of words (keys). Now, because of good symbol-table implementations, people expect built-in spell checkers and immediate access to word definitions on their computers.</p>
<p class="indenthangingB">• <em>Account information</em>. People who own stock now regularly check the current price on the web. Several services on the web associate a ticker symbol (key) with the current price (value), usually along with a great deal of other information. Commercial applications of this sort abound, including financial institutions associating account information with a name or account number or educational institutions associating grades with a student name or identification number.</p>
<p class="indenthangingB">• <em>Genomics</em>. Symbols play a central role in modern genomics. The simplest example is the use of the letters <code>A</code>, <code>C</code>, <code>T</code>, and <code>G</code> to represent the nucleotides found in the DNA of living organisms. The next simplest is the correspondence between codons (nucleotide triplets) and amino acids (<code>TTA</code> corresponds to leucine, <code>TCT</code> to serine, and so forth), then the correspondence between sequences of amino acids and proteins, and so forth. Researchers in genomics routinely use various types of symbol tables to organize this knowledge.</p>
<p class="indenthangingB">• <em>Experimental data</em>. From astrophysics to zoology, modern scientists are awash in experimental data, and organizing and efficiently accessing this data are vital to understanding what it means. Symbol tables are a critical starting point, and advanced data structures and algorithms that are based on symbol tables are now an important part of scientific research.</p>
<p class="indenthangingB">• <em>Compilers.</em> One of the earliest uses of symbol tables was to organize information for programming. At first, programs were simply sequences of numbers, but programmers very quickly found that using symbolic names for operations and <a id="page_493"/>memory locations (variable names) was far more convenient. Associating the names with the numbers requires a symbol table. As the size of programs grew, the cost of the symbol-table operations became a bottleneck in program development time, which led to the development of data structures and algorithms like the ones we consider in this chapter.</p>
<p class="indenthangingB">• <em>File systems.</em> We use symbol tables regularly to organize data on computer systems. Perhaps the most prominent example is the <em>file system</em>, where we associate a file name (key) with the location of its contents (value). Your music player uses the same system to associate song titles (keys) with the location of the music itself (value).</p>
<p class="image"><img alt="image" src="graphics/t0493-01.jpg"/></p>
<p class="indenthangingB">• <em>Internet DNS.</em> The domain name system (DNS) that is the basis for organizing information on the internet associates URLs (keys) that humans understand (such as <a href="http://www.princeton.edu">www.princeton.edu</a> or <a href="http://www.wikipedia.org">www.wikipedia.org</a>) with IP addresses (values) that computer network routers understand (such as <code>208.216.181.15</code> or <code>207.142.131.206</code>). This system is the next-generation “phone book.” Thus, humans can use names that are easy to remember and machines can efficiently process the numbers. The number of symbol-table lookups done each second for this purpose on internet routers around the world is huge, so performance is of obvious importance. Millions of new computers and other devices are put onto the internet each year, so these symbol tables on internet routers need to be dynamic.</p>
<p>Despite its scope, this list is still just a representative sample, intended to give you a flavor of the scope of applicability of the symbol-table abstraction. Whenever you specify something by name, there is a symbol table at work. Your computer’s file system or the web might do the work for you, but there is still a symbol table there somewhere.</p>
<p>As a specific example, we consider a symbol-table client that you can use to look up information that is kept in a table on a file or a web page using the <em>comma-separated-value</em> (<code>.csv</code>) file format. This simple format achieves the (admittedly modest) goal of keeping tabular data in a form that anyone can read (and is likely to be able to read in the future) without needing to use a particular application: the data is in text form, one row per line, with entries separated by commas. You can find on the booksite <a id="page_494"/>numerous <code>.csv</code> files that are related to various applications that we have described, including <code>amino.csv</code> (codon-to-amino-acid encodings), <code>DJIA.csv</code> (opening price, volume, and closing price of the Dow Jones Industrial Average, for every day in its history), <code>ip.csv</code> (a selection of entries from the DNS database), and <code>upc.csv</code> (the Uniform Product Code bar codes that are widely used to identify consumer products). Spreadsheet and other data-processing applications programs can read and write <code>.csv</code> files, and our example illustrates that you can also write a Java program to process the data any way that you would like.</p>
<p class="image1"><img alt="image" src="graphics/p0494-01.jpg"/></p>
<p class="image2"><img alt="image" src="graphics/p0494-02.jpg"/></p>
<p><code>LookupCSV</code> (on the facing page) builds a set of key-value pairs from a file of comma-separated values as specified on the command line and then prints out values corresponding to keys read from standard input. The command-line arguments are the file name and two integers, one specifying the field to serve as the key and the other specifying the field to serve as the value.</p>
<p>The purpose of this example is to illustrate the utility and flexibility of the symbol-table abstraction. What website has IP address <code>128.112.136.35</code>? (<a href="http://www.cs.princeton.edu">www.cs.princeton.edu</a>) What amino acid corresponds to the codon <code>TCA</code>? (<code>Serine</code>) What was the DJIA on October 29, 1929? (<code>252.38</code>) What product has UPC <code>0002100001086</code>? (<code>Kraft Parmesan</code>) You can easily look up the answers to questions like these with <code>LookupCSV</code> and the appropriate <code>.csv</code> files.</p>
<p>Performance is not much of an issue when handling interactive queries (since your computer can look through millions <a id="page_496"/>of things in the time it takes to type a query), so fast implementations of <code>ST</code> are not noticeable when you use <code>LookupCSV</code>. However, when a <em>program</em> is doing the lookups (and a huge number of them), performance matters. For example, an internet router might need to look up millions of IP addresses per second. In this book, we have already seen the need for good performance with <code>FrequencyCounter</code>, and we will see several other examples in this section.</p>
<div class="sidebar">
<hr/>
<p><a id="ch03sb36"/></p>
<h3><a id="page_495"/>Dictionary lookup</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0495-01.jpg"/></p>
<p>This data-driven symbol-table client reads key-value pairs from a file, then prints the values corresponding to the keys found on standard input. Both keys and values are strings. The separating delimiter is taken as a command-line argument.</p>
<p class="image"><img alt="image" src="graphics/p0495-02.jpg"/></p>
<hr/>
</div>
<p>Examples of similar but more sophisticated test clients for <code>.csv</code> files are described in the exercises. For instance, we could make the dictionary dynamic by also allowing standard-input commands to change the value associated with a key, or we could allow range searching, or we could build multiple dictionaries for the same file.</p>
<p><a id="ch03sec2lev40"/></p>
<h4>Indexing clients</h4>
<p>Dictionaries are characterized by the idea that there is one value associated with each key, so the direct use of our <code>ST</code> data type, which is based on the associative-array abstraction that assigns one value to each key, is appropriate. Each account number uniquely identifies a customer, each UPC uniquely identifies a product, and so forth. In general, of course, there may be multiple values associated with a given key. For example, in our <code>amino.csv</code> example, each codon identifies one amino acid, but each amino acid is associated with a list of codons, as in the example <code>aminoI.csv</code> at right, where each line contains an amino acid and the list of codons associated with it. We use the term <em>index</em> to describe symbol tables that associate multiple values with each key. Here are some more examples:</p>
<p class="indenthangingB">• <em>Commercial transactions</em>. One way for a company that maintains customer accounts to keep track of a day’s transactions is to keep an index of the day’s transactions. The key is the account number; the value is the list of occurrences of that account number in the transaction list.</p>
<p class="indenthangingB">• <em>Web search.</em> When you type a keyword and get a list of websites containing that keyword, you are using an index created by your web search engine. There is one value (the set of pages) associated with each key (the query), although the reality is a bit more complicated because we often specify multiple keys.</p>
<p class="indenthangingB"><a id="page_497"/>• <em>Movies and performers</em>. The file <code>movies.txt</code> on the booksite (excerpted below) is taken from the <em>Internet Movie Database</em> (IMDB). Each line has a movie name (the key), followed by a list of performers in that movie (the value), separated by slashes.</p>
<p class="image"><img alt="image" src="graphics/03_75-aminos.jpg"/></p>
<p>We can easily build an index by putting the values to be associated with each key into a single data structure (a <code>Queue</code>, say) and then associating that key with that data structure as value. Extending <code>LookupCSV</code> along these lines is straightforward, but we leave that as an exercise (see <a href="#ch03qa5q12"><small>EXERCISE 3.5.12</small></a>) and consider instead <code>LookupIndex</code> on page <a href="#page_499">499</a>, which uses a symbol table to build an index from files like <code>aminoI.txt</code> and <code>movies.txt</code> (where the separator character need not be a comma, as in a .csv file, but can be specified on the command line). After building the index, <code>LookupIndex</code> then takes key queries and prints the values associated with each key. More interesting, <code>LookupIndex</code> also builds an <em>inverted inde</em>x associated with each file, where values and keys switch roles. In the amino acid example, this gives the same functionality as <code>Lookup</code> (find the amino acid associated with a given codon); in the movie-performer example it adds the ability to find the movies associated with any given performer, which is implicit in the data but would be difficult to produce without a symbol table. <em>Study this example carefully</em>, as it provides good insight into the essential nature of symbol tables.</p>
<p class="image"><img alt="image" src="graphics/t0497-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/03_76-movies.jpg"/></p>
<p><a id="ch03sec3lev82"/></p>
<h5><a id="page_498"/><em>Inverted index</em></h5>
<p>The term <em>inverted index</em> is normally applied to a situation where values are used to <em>locate</em> keys. We have a large amount of data and want to know where certain keys of interest occur. This application is another prototypical example of a symbol-table client that uses an intermixed sequence of calls to <code>get()</code> and <code>put()</code>. Again, we associate each key with a <code>SET</code> of locations, where the occurrences of the key can be found. The nature and use of the location depend on the application: in a book, a location might be a page number; in a program, a location might be a line number; in genomics, a location might be a position in a genetic sequence; and so forth:</p>
<p class="indenthangingB">• <em>Internet Movie DataBase (IMDB)</em>. In the example just considered, the input is an index that associates each movie with a list of performers. The inverted index associates each performer with a list of movies.</p>
<p class="indenthangingB">• <em>Book index</em>. Every textbook has an index where you look up a term and get the page numbers containing that term. While creating a good index generally involves work by the book author to eliminate common and irrelevant words, a document preparation system will certainly use a symbol table to help automate the process. An interesting special case is known as a <em>concordance</em>, which associates each word in a text with the set of positions in the text where that word occurs (see <a href="#ch03qa5q20"><small>EXERCISE 3.5.20</small></a>).</p>
<p class="image"><img alt="image" src="graphics/t0498-01.jpg"/></p>
<p class="indenthangingB">• <em>Compiler</em>. In a large program that uses a large number of symbols, it is useful to know where each name is used. Historically, an explicit printed symbol table was one of the most important tools used by programmers to keep track of where symbols are used in their programs. In modern systems, symbol tables are the basis of software tools that programmers use to manage names.</p>
<p class="indenthangingB">• <em>File search</em>. Modern operating systems provide you with the ability to type a term and to learn the names of files containing that term. The key is the term; the value is the set of files containing that term.</p>
<p class="indenthangingB">• <em>Genomics</em>. In a typical (if oversimplified) scenario in genomics research, a scientist wants to know the positions of a given genetic sequence in an existing genome or set of genomes. Existence or proximity of certain sequences may be of scientific significance. The starting point for such research is an index like a concordance, but modified to take into account the fact that genomes are not separated into words (see <a href="#ch03qa5q15"><small>EXERCISE 3.5.15</small></a>).</p>
<div class="sidebar">
<hr/>
<p><a id="ch03sb37"/></p>
<h3><a id="page_499"/>Index (and inverted index) lookup</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0499-01.jpg"/></p>
<p>This data-driven symbol-table client reads key-value pairs from a file, then prints the values corresponding to the keys found on standard input. Keys are strings; values are lists of strings. The separating delimiter is taken as a command-line argument.</p>
<p class="image"><img alt="image" src="graphics/p0499-02.jpg"/></p>
<hr/>
</div>
<p><a id="page_500"/><code>FileIndex</code> (on the facing page) takes file names from the command line and uses a symbol table to build an inverted index associating every word in any of the files with a <code>SET</code> of file names where the word can be found, then takes keyword queries from standard input, and produces its associated list of files. This process is similar to that used by familiar software tools for searching the web or for searching for information on your computer; you type a keyword to get a list of places where that keyword occurs. Developers of such tools typically embellish the process by paying careful attention to</p>
<p class="indenthangingB">• The form of the query</p>
<p class="indenthangingB">• The set of files/pages that are indexed</p>
<p class="indenthangingB">• The order in which files are listed in the response</p>
<p>For example, you are certainly used to typing queries that contain multiple keywords to a web search engine (which is based on indexing a large fraction of the pages on the web) that provides answers in order of relevance or importance (to you or to an advertiser). The exercises at the end of this section address some of these embellishments. We will consider various algorithmic issues related to web search later, but the symbol table is certainly at the heart of the process.</p>
<p>As with <code>LookupIndex</code>, you are certainly encouraged to download <code>FileIndex</code> from the booksite and use it to index some text files on your computer or some websites of interest, to gain further appreciation for the utility of symbol tables. If you do so, you will find that it can build large indices for huge files with little delay, because each <em>put</em> operation and <em>get</em> request is taken care of immediately. Providing this immediate response for huge dynamic tables is one of the classic triumphs of algorithmic technology.</p>
<div class="sidebar">
<hr/>
<p><a id="ch03sb38"/></p>
<h3><a id="page_501"/>File indexing</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0501-01.jpg"/></p>
<p>This symbol-table client indexes a set of files. We search for each word in each file in a symbol table, maintaining a <code>SET</code> of file names that contain the word. Names for <code>In</code> can also refer to web pages, so this code can also be used to build an inverted index of web pages.</p>
<p class="image"><img alt="image" src="graphics/p0501-02.jpg"/></p>
<p class="image"><img alt="image" src="graphics/p0501-03.jpg"/></p>
<hr/>
</div>
<p><a id="ch03sec2lev41"/></p>
<h4><a id="page_502"/>Sparse vectors</h4>
<p>Our next example illustrates the importance of symbol tables in scientific and mathematical calculations. We describe a fundamental and familiar calculation that becomes a bottleneck in typical practical applications, then show how using a symbol table can remove the bottleneck and enable solution of vastly larger problems. Indeed, this particular calculation was at the core of the PageRank algorithm that was developed by S. Brin and L. Page and led to the emergence of Google in the early 2000s (and is a well-known mathematical abstraction that is useful in many other contexts).</p>
<p class="image"><img alt="image" src="graphics/03_77-matrixvector.jpg"/></p>
<p>The basic calculation that we consider is <em>matrix-vector multiplication</em>: given a matrix and a vector, compute a result vector whose <em>i</em>th entry is the <em>dot product</em> of the given vector and the <em>i</em>th row of the matrix. For simplicity, we consider the case when the matrix is square with <em>N</em> rows and <em>N</em> columns and the vectors are of size <em>N</em>. This operation is elementary to code in Java, requiring time proportional to <em>N</em><sup>2</sup>, for the <em>N</em> multiplications to compute each of the <em>N</em> entries in the result vector, which also matches the space proportional to <em>N</em><sup>2</sup> that is required to store the matrix.</p>
<p>In practice, it is very often the case that <em>N</em> is huge. For example, in the Google application cited above, <em>N</em> is the number of pages on the web. At the time PageRank was developed, that was in the tens or hundreds of billions and it has skyrocketed since, so the value of <em>N</em><sup>2</sup> would be far more than 10<sup>20</sup>. No one can afford that much time or space, so a better algorithm is needed.</p>
<p>Fortunately, it is also often the case that the matrix is <em>sparse</em>: a huge number of its entries are 0. Indeed, for the Google application, the average number of nonzero entries per row is a small constant: virtually all web pages have links to only a few others (not all the pages on the web). Accordingly, we can represent the matrix as an array of sparse vectors, using a <code>SparseVector</code> implementation like the <code>HashST</code> client on the facing page. Instead of using the <a id="page_504"/>code <code>a[i][j]</code> to refer to the element in row <code>i</code> and column <code>j</code>, we use <code>a[i].put(j, val)</code> to set a value in the matrix and <code>a[i].get(j)</code> to retrieve a value. As you can see from the code below, matrix-vector multiplication using this class is even simpler than with the array representation (and it more clearly describes the computation). More important, it only requires time proportional to <em>N</em> plus the number of nonzero elements in the matrix.</p>
<p class="image"><img alt="image" src="graphics/p0502-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/03_78-sparsematrix.jpg"/></p>
<div class="sidebar">
<hr/>
<p><a id="ch03sb39"/></p>
<h3><a id="page_503"/>Sparse vector with dot product</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0503-01.jpg"/></p>
<p>This symbol-table client is a bare-bones sparse vector implementation that illustrates an efficient dot product for sparse vectors. We multiply each entry by its counterpart in the other operand and add the result to a running sum. The number of multiplications required is equal to the number of nonzero entries in the sparse vector.</p>
<hr/>
</div>
<p>For small matrices or matrices that are not sparse, the overhead for maintaining symbol tables can be substantial, but it is worth your while to be sure to understand the ramifications of using symbol tables for huge sparse matrices. To fix ideas, consider a huge application (like the one faced by Brin and Page) where <em>N</em> is 10 billion or 100 billion, but the average number of nonzero elements per row is less than 10. For such an application, <em>using symbol tables speeds up matrix-vector multiplication by a factor of a billion or more</em>. The elementary nature of this application should not detract from its importance: programmers who do not take advantage of the potential to save time and space in this way severely limit their potential to solve practical problems, while programmers who do take factor-of-a-billion <a id="page_505"/>speedups when they are available are likely to be able to address problems that could not otherwise be contemplated.</p>
<p class="image"><img alt="image" src="graphics/p0504-01.jpg"/></p>
<p>Building the matrix for the Google application is a graph-processing application (and a symbol-table client!), albeit for a huge sparse matrix. Given the matrix, the Page-Rank calculation is nothing more than doing a matrix-vector multiplication, replacing the source vector with the result vector, and iterating the process until it converges (as guaranteed by fundamental theorems in probability theory). Thus, the use of a class like <code>SparseVector</code> can improve the time and space usage for this application by a factor of 10 billion or 100 billion or more.</p>
<p>Similar savings are possible in many scientific calculations, so sparse vectors and matrices are widely used and typically incorporated into specialized systems for scientific computing. When working with huge vectors and matrices, it is wise to run simple performance tests to be sure that the kinds of performance gains that we have illustrated here are not being missed. On the other hand, array processing for primitive types of data is built in to most programming languages, so using arrays for vectors that are not sparse, as we did in this example, may offer further speedups. Developing a good understanding of the underlying costs and making the appropriate implementation decisions is certainly worthwhile for such applications.</p>
<p><small>SYMBOL TABLES ARE A PRIMARY CONTRIBUTION OF ALGORITHMIC TECHNOLOGY</small> to the development of our modern computational infrastructure because of their ability to deliver savings on a huge scale in a vast array of practical applications, making the difference between providing solutions to a wide range of problems and not being able to address them at all. Few fields of science or engineering involve studying the effects of an invention that improves costs by factors of 100 billion—symbol-table applications put us in just that position, as we have just seen in several examples, and these improvements have had profound effects. The data structures and algorithms that we have considered are certainly not the final word: they were all developed in just a few decades, and their properties are not fully understood. Because of their importance, symbol-table implementations continue to be studied intensely by researchers around the world, and we can look forward to new developments on many fronts as the scale and scope of the applications they address continue to expand.</p>
<p><a id="ch03sec2lev42"/></p>
<h4><a id="page_506"/>Q&amp;A</h4>
<p><strong>Q.</strong> Can a <code>SET</code> contain <code>null</code>?</p>
<p><strong>A.</strong> No. As with symbol tables, keys are non-null objects.</p>
<p><strong>Q.</strong> Can a <code>SET</code> be <code>null</code>?</p>
<p><strong>A.</strong> No. A <code>SET</code> can be empty (contain no objects), but not <code>null</code>. As with any Java data type, a variable of type <code>SET</code> can have the value <code>null</code>, but that just indicates that it does not reference any <code>SET</code>. The result of using <code>new</code> to create a <code>SET</code> is always an object that is not <code>null</code>.</p>
<p><strong>Q.</strong> If all my data is in memory, there is no real reason to use a filter, right?</p>
<p><strong>A.</strong> Right. Filtering really shines in the case when you have no idea how much data to expect. Otherwise, it may be a useful way of thinking, but not a cure-all.</p>
<p><strong>Q.</strong> I have data in a spreadsheet. Can I develop something like <code>LookupCSV</code> to search through it?</p>
<p><strong>A.</strong> Your spreadsheet application probably has an option to export to a <code>.csv</code> file, so you can use <code>LookupCSV</code> directly.</p>
<p><strong>Q.</strong> Why would I need <code>FileIndex</code>? Doesn’t my operating system solve this problem?</p>
<p><strong>A.</strong> If you are using an OS that meets your needs, continue to do so, by all means. As with many of our programs, <code>FileIndex</code> is intended to show you the basic underlying mechanisms of such applications and to suggest possibilities to you.</p>
<p><strong>Q.</strong> Why not have the <code>dot()</code> method in <code>SparseVector</code> take a <code>SparseVector</code> object as argument and return a <code>SparseVector</code> object?</p>
<p><strong>A.</strong> That is a fine alternate design and a nice programming exercise that requires code that is a bit more intricate than for our design (see <a href="#ch03qa5q16"><small>EXERCISE 3.5.16</small></a>). For general matrix processing, it might be worthwhile to also add a <code>SparseMatrix</code> type.</p>
<p><a id="ch03sec2lev43"/></p>
<h4><a id="page_507"/>Exercises</h4>
<p><a id="ch03qa5q1"/><strong>3.5.1</strong> Implement <code>SET</code> and <code>HashSET</code> as “wrapper class” clients of <code>ST</code> and <code>HashST</code>, respectively (provide dummy values and ignore them).</p>
<p><a id="ch03qa5q2"/><strong>3.5.2</strong> Develop a <code>SET</code> implementation <code>SequentialSearchSET</code> by starting with the code for <code>SequentialSearchST</code> and eliminating all of the code involving values.</p>
<p><a id="ch03qa5q3"/><strong>3.5.3</strong> Develop a <code>SET</code> implementation <code>BinarySearchSET</code> by starting with the code for <code>BinarySearchST</code> and eliminating all of the code involving values.</p>
<p><a id="ch03qa5q4"/><strong>3.5.4</strong> Develop classes <code>HashSTint</code> and <code>HashSTdouble</code> for maintaining sets of keys of primitive <code>int</code> and <code>double</code> types, respectively. (Convert generics to primitive types in the code of <code>LinearProbingHashST</code>.)</p>
<p><a id="ch03qa5q5"/><strong>3.5.5</strong> Develop classes <code>STint</code> and <code>STdouble</code> for maintaining ordered symbol tables where keys are primitive <code>int</code> and <code>double</code> types, respectively. (Convert generics to primitive types in the code of <code>RedBlackBST</code>.) Test your solution with a version of <code>SparseVector</code> as a client.</p>
<p><a id="ch03qa5q6"/><strong>3.5.6</strong> Develop classes <code>HashSETint</code> and <code>HashSETdouble</code> for maintaining sets of keys of primitive <code>int</code> and <code>double</code> types, respectively. (Eliminate code involving values in your solution to <a href="#ch03qa5q4"><small>EXERCISE 3.5.4</small></a>.)</p>
<p><a id="ch03qa5q7"/><strong>3.5.7</strong> Develop classes <code>SETint</code> and <code>SETdouble</code> for maintaining ordered sets of keys of primitive <code>int</code> and <code>double</code> types, respectively. (Eliminate code involving values in your solution to <a href="#ch03qa5q5"><small>EXERCISE 3.5.5</small></a>.)</p>
<p><a id="ch03qa5q8"/><strong>3.5.8</strong> Modify <code>LinearProbingHashST</code> to keep duplicate keys in the table. Return <em>any</em> value associated with the given key for <code>get()</code>, and remove <em>all</em> items in the table that have keys equal to the given key for <code>delete()</code>.</p>
<p><a id="ch03qa5q9"/><strong>3.5.9</strong> Modify <code>BST</code> to keep duplicate keys in the tree. Return <em>any</em> value associated with the given key for <code>get()</code>, and remove <em>all</em> nodes in the tree that have keys equal to the given key for <code>delete()</code>.</p>
<p><a id="ch03qa5q10"/><strong>3.5.10</strong> Modify <code>RedBlackBST</code> to keep duplicate keys in the tree. Return <em>any</em> value associated with the given key for <code>get()</code>, and remove <em>all</em> nodes in the tree that have keys equal to the given key for <code>delete()</code>.</p>
<p><a id="page_508"/><a id="ch03qa5q11"/><strong>3.5.11</strong> Develop a <code>MultiSET</code> class that is like <code>SET</code>, but allows equal keys and thus implements a mathematical <em>multiset</em>.</p>
<p><a id="ch03qa5q12"/><strong>3.5.12</strong> Modify <code>LookupCSV</code> to associate with each key all values that appear in a key-value pair with that key in the input (not just the most recent, as in the associative-array abstraction).</p>
<p><a id="ch03qa5q13"/><strong>3.5.13</strong> Modify <code>LookupCSV</code> to make a program <code>RangeLookupCSV</code> that takes two key values from the standard input and prints all key-value pairs in the <code>.csv</code> file such that the key falls within the range specified.</p>
<p><a id="ch03qa5q14"/><strong>3.5.14</strong> Develop and test a static method <code>invert()</code> that takes as argument an <code>ST&lt;String, Bag&lt;String&gt;&gt;</code> and produces as return value the inverse of the given symbol table (a symbol table of the same type).</p>
<p><a id="ch03qa5q15"/><strong>3.5.15</strong> Write a program that takes a string on standard input and an integer <em>k</em> as command-line argument and puts on standard output a sorted list of the <em>k</em>-grams found in the string, each followed by its index in the string.</p>
<p><a id="ch03qa5q16"/><strong>3.5.16</strong> Add a method <code>sum()</code> to <code>SparseVector</code> that takes a <code>SparseVector</code> as argument and returns a <code>SparseVector</code> that is the term-by-term sum of this vector and the argument vector. <em>Note</em>: You need <code>delete()</code> (and special attention to precision) to handle the case where an entry becomes 0.</p>
<p><a id="ch03sec2lev44"/></p>
<h4><a id="page_509"/>Creative Problems</h4>
<p><a id="ch03qa5q17"/><strong>3.5.17</strong> <em>Mathematical sets.</em> Your goal is to develop an implementation of the following API <code>MathSET</code> for processing (mutable) mathematical sets:</p>
<p class="image"><img alt="image" src="graphics/t0509-01.jpg"/></p>
<p>Use a symbol table. <em>Extra credit</em>: Represent sets with arrays of <code>boolean</code> values.</p>
<p><a id="ch03qa5q18"/><strong>3.5.18</strong> <em>Multisets.</em> After referring to <a href="#ch03qa5q2"><small>EXERCISES 3.5.2</small></a> and <a href="#ch03qa5q3">3.5.3</a> and the previous exercise, develop APIs <code>MultiHashSET</code> and <code>MultiSET</code> for multisets (sets that can have equal keys) and implementations <code>SeparateChainingMultiSET</code> and <code>BinarySearchMultiSET</code> for multisets and ordered multisets, respectively.</p>
<p><a id="ch03qa5q19"/><strong>3.5.19</strong> <em>Equal keys in symbol tables.</em> Consider the API <code>MultiST</code> (unordered or ordered) to be the same as our symbol-table APIs defined on page <a href="ch03.html#page_363">363</a> and page <a href="ch03.html#page_366">366</a>, but with equal keys allowed, so that the semantics of <code>get()</code> is to return <em>any</em> value associated with the given key, and we add a new method</p>
<p class="programlisting">Iterable&lt;Value&gt; getAll(Key key)</p>
<p><a id="page_510"/>that returns <em>all</em> values associated with the given key. Using our code for <code>SeparateChainingST</code> and <code>BinarySearchST</code> as a starting point, develop implementations <code>SeparateChainingMultiST</code> and <code>BinarySearchMultiST</code> for these APIs.</p>
<p><a id="ch03qa5q20"/><strong>3.5.20</strong> <em>Concordance.</em> Write an <code>ST</code> client <code>Concordance</code> that puts on standard output a concordance of the strings in the standard input stream (see page <a href="#page_498">498</a>).</p>
<p><a id="ch03qa5q21"/><strong>3.5.21</strong> <em>Inverted concordance.</em> Write a program <code>InvertedConcordance</code> that takes a concordance on standard input and puts the original string on standard output stream. <em>Note</em>: This computation is associated with a famous story having to do with the Dead Sea Scrolls. The team that discovered the original tablets enforced a secrecy rule that essentially resulted in their making public only a concordance. After a while, other researchers figured out how to invert the concordance, and the full text was eventually made public.</p>
<p><a id="ch03qa5q22"/><strong>3.5.22</strong> <em>Fully indexed CSV.</em> Implement an <code>ST</code> client <code>FullLookupCSV</code> that builds an array of <code>ST</code> objects (one for each field), with a test client that allows the user to specify the key and value fields in each query.</p>
<p><a id="ch03qa5q23"/><strong>3.5.23</strong> <em>Sparse matrices.</em> Develop an API and an implementation for sparse 2D matrices. Support matrix addition and matrix multiplication. Include constructors for row and column vectors.</p>
<p><a id="ch03qa5q24"/><strong>3.5.24</strong> <em>Non-overlapping interval search.</em> Given a list of non-overlapping intervals of items, write a function that takes an item as argument and determines in which, if any, interval that item lies. For example, if the items are integers and the intervals are <code>1643-2033</code>, <code>5532-7643</code>, <code>8999-10332</code>, <code>5666653-5669321</code>, then the query point <code>9122</code> lies in the third interval and <code>8122</code> lies in no interval.</p>
<p><a id="ch03qa5q25"/><strong>3.5.25</strong> <em>Registrar scheduling.</em> The registrar at a prominent northeastern University recently scheduled an instructor to teach two different classes at the same exact time. Help the registrar prevent future mistakes by describing a method to check for such conflicts. For simplicity, assume all classes run for 50 minutes starting at 9:00, 10:00, 11:00, 1:00, 2:00, or 3:00.</p>
<p><a id="ch03qa5q26"/><strong>3.5.26</strong> <em>LRU cache.</em> Create a data structure that supports the following operations: access and remove. The access operation inserts the item onto the data structure if it’s not already present. The remove operation deletes and returns the item that was least <a id="page_511"/>recently accessed. <em>Hint</em>: Maintain the items in order of access in a doubly linked list, along with pointers to the first and last nodes. Use a symbol table with keys = items, values = location in linked list. When you access an element, delete it from the linked list and reinsert it at the beginning. When you remove an element, delete it from the end and remove it from the symbol table.</p>
<p><a id="ch03qa5q27"/><strong>3.5.27</strong> <em>List.</em> Develop an implementation of the following API:</p>
<p class="image"><img alt="image" src="graphics/t0511-01.jpg"/></p>
<p><em>Hint</em>: Use two symbol tables, one to find the <code>i</code>th item in the list efficiently, and the other to efficiently search by item. (Java’s <code>java.util.List</code> interface contains methods like these but does not supply any implementation that efficiently supports all operations.)</p>
<p><a id="ch03qa5q28"/><strong>3.5.28</strong> <em>UniQueue.</em> Create a data type that is a queue, except that an element may only be inserted the queue once. Use an existence symbol table to keep track of all elements that have ever been inserted and ignore requests to re-insert such items.</p>
<p><a id="page_512"/><a id="ch03qa5q29"/><strong>3.5.29</strong> <em>Symbol table with random access.</em> Create a data type that supports inserting a key-value pair, searching for a key and returning the associated value, and deleting and returning a random key. <em>Hint</em>: Combine a symbol table and a randomized queue.</p>
<p><a id="ch03sec2lev45"/></p>
<h4><a id="page_513"/>Experiments</h4>
<p><a id="ch03qa5q30"/><strong>3.5.30</strong> <em>Duplicates (revisited).</em> Redo <a href="ch02.html#ch02qa5q31"><small>EXERCISE 2.5.31</small></a> using the <code>Dedup</code> filter given on page <a href="#page_490">490</a>. Compare the running times of the two approaches. Then use <code>Dedup</code> to run the experiments for <em>N</em> = 10<sup>7</sup>, 10<sup>8</sup>, and 10<sup>9</sup>, repeat the experiments for random <code>long</code> values and discuss the results.</p>
<p><a id="ch03qa5q31"/><strong>3.5.31</strong> <em>Spell checker.</em> With the file <code>dictionary.txt</code> from the booksite as command-line argument, the <code>BlackFilter</code> client described on page <a href="#page_491">491</a> prints all misspelled words in a text file taken from standard input. Compare the performance of <code>RedBlackBST</code>, <code>SeparateChainingHashST</code>, and <code>LinearProbingHashST</code> for the file <code>WarAndPeace.txt</code> (available on the booksite) with this client and discuss the results.</p>
<p><a id="ch03qa5q32"/><strong>3.5.32</strong> <em>Dictionary.</em> Study the performance of a client like <code>LookupCSV</code> in a scenario where performance matters. Specifically, design a query-generation scenario instead of taking commands from standard input, and run performance tests for large inputs and large numbers of queries.</p>
<p><a id="ch03qa5q33"/><strong>3.5.33</strong> <em>Indexing.</em> Study a client like <code>LookupIndex</code> in a scenario where performance matters. Specifically, design a query-generation scenario instead of taking commands from standard input, and run performance tests for large inputs and large numbers of queries.</p>
<p><a id="ch03qa5q34"/><strong>3.5.34</strong> <em>Sparse vector.</em> Run experiments to compare the performance of matrix-vector multiplication using <code>SparseVector</code> to the standard implementation using arrays.</p>
<p><a id="ch03qa5q35"/><strong>3.5.35</strong> <em>Primitive types.</em> Evaluate the utility of using primitive types for <code>Integer</code> and <code>Double</code> values, for <code>LinearProbingHashST</code> and <code>RedBlackBST</code>. How much space and time are saved, for large numbers of searches in large tables?</p>
</body>
</html>