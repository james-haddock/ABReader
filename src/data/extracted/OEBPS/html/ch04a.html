<?xml version="1.0" encoding="UTF-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Four. Graphs</title>
<link href="9780132762564.css" rel="stylesheet" type="text/css"/>
<link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml"/>
<meta name="Adept.resource" value="urn:uuid:7baf5dbb-ffe1-4201-87bd-b993ed04f947"/>
</head>
<body>
<p><a id="ch04a"/></p>
<p><a id="ch04sec1lev13"/></p>
<h3><a id="page_638"/>4.4 Shortest Paths</h3>
<p><small>PERHAPS THE MOST INTUITIVE</small> graph-processing problem is one that you encounter regularly, when using a map application or a navigation system to get directions from one place to another. A graph model is immediate: vertices correspond to intersections and edges correspond to roads, with weights on the edges that model the cost, perhaps distance or travel time. The possibility of one-way roads means that we will need to consider edge-weighted <em>digraphs</em>. In this model, the problem is easy to formulate:</p>
<p class="center"><em>Find the lowest-cost way to get from one vertex to another.</em></p>
<p>Beyond direct applications of this sort, the shortest-paths model is appropriate for a range of other problems, some of which do not seem to be at all related to graph processing. As one example, we shall consider the <em>arbitrage</em> problem from computational finance at the end of this section.</p>
<p>We adopt a general model where we work with <em>edge-weighted digraphs</em> (combining the models of <a href="ch04.html#ch04sec1lev11"><small>SECTION 4.2</small></a> and <a href="ch04.html#ch04sec1lev12"><small>SECTION 4.3</small></a>). In <a href="ch04.html#ch04sec1lev11"><small>SECTION 4.2</small></a> we wished to know whether it is <em>possible</em> to get from one vertex to another; in this section, we take weights into consideration, as we did for undirected edge-weighted graphs in <a href="ch04.html#ch04sec1lev12"><small>SECTION 4.3</small></a>. Every directed path in an edge-weighted digraph has an associated <em>path weight</em>, the value of which is the sum of the weights of that path’s edges. This essential measure allows us to formulate such problems as “find the lowest-weight directed path from one vertex to another,” the topic of this section. The figure at left shows an example.</p>
<p class="image"><img alt="image" src="graphics/t0638-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/04_67-tinynetwork.jpg"/></p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb48"/></p>
<p><strong>Definition.</strong> A <em>shortest path</em> from vertex <code>s</code> to vertex <code>t</code> in an edge-weighted digraph is a directed path from <code>s</code> to <code>t</code> with the property that no other such path has a lower weight.</p>
<hr/>
</div>
<p><a id="page_639"/>Thus, in this section, we consider classic algorithms for the following problem:</p>
<p class="indenthanging"><strong><em>Single-source shortest paths.</em></strong> Given an edge-weighted digraph and a source vertex <code>s</code>, support queries of the form <em>Is there a directed path from</em> <code>s</code> <em>to a given target vertex</em> <code>t</code>? If so, find a <em>shortest</em> such path (one whose total weight is minimal).</p>
<p>The plan of the section is to cover the following list of topics:</p>
<p class="indenthangingB">• Our APIs and implementations for edge-weighted digraphs, and a single-source shortest-paths API</p>
<p class="indenthangingB">• The classic Dijkstra’s algorithm for the problem when weights are nonnegative</p>
<p class="indenthangingB">• A faster algorithm for acyclic edge-weighted digraphs (edge-weighted DAGs) that works even when edge weights can be negative</p>
<p class="indenthangingB">• The classic Bellman-Ford algorithm for use in the general case, when cycles may be present, edge weights may be negative, and we need algorithms for finding negative-weight cycles and shortest paths in edge-weighted digraphs with no such cycles</p>
<p>In the context of the algorithms, we also consider applications.</p>
<p><a id="ch04sec2lev36"/></p>
<h4>Properties of shortest paths</h4>
<p>The basic definition of the shortest-paths problem is succinct, but its brevity masks several points worth examining before we begin to formulate algorithms and data structures for solving it:</p>
<p class="indenthangingB">• <em>Paths are directed</em>. A shortest path must respect the direction of its edges.</p>
<p class="indenthangingB">• <em>The weights are not necessarily distances.</em> Geometric intuition can be helpful in understanding algorithms, so we use examples where vertices are points in the plane and weights are Euclidean distances, such as the digraph on the facing page. But the weights might represent time or cost or an entirely different variable and do not need to be proportional to a distance at all. We are emphasizing this point by using mixed-metaphor terminology where we refer to a <em>shortest</em> path of minimal <em>weight</em> or <em>cost</em>.</p>
<p class="indenthangingB">• <em>Not all vertices need be reachable</em>. If <code>t</code> is not reachable from <code>s</code>, there is no path at all, and therefore there is no shortest path from <code>s</code> to <code>t</code>. For simplicity, our small running example is strongly connected (every vertex is reachable from every other vertex).</p>
<p class="indenthangingB">• <em>Negative weights introduce complications</em>. For the moment, we assume that edge weights are positive (or zero). The surprising impact of negative weights is a major focus of the last part of this section.</p>
<p class="indenthangingB">• <em>Shortest paths are normally simple</em>. Our algorithms ignore zero-weight edges that form cycles, so that the shortest paths they find have no cycles.</p>
<p class="indenthangingB">• <em>Shortest paths are not necessarily unique</em>. There may be multiple paths of the lowest <a id="page_640"/>weight from one vertex to another; we are content to find any one of them.</p>
<p class="indenthangingB">• <em>Parallel edges and self-loops may be present</em>. Only the lowest-weight among a set of parallel edges will play a role, and no shortest path contains a self-loop (except possibly one of zero weight, which we ignore). In the text, we implicitly assume that parallel edges are not present for convenience in using the notation <code>v-&gt;w</code> to refer unambiguously to the edge from <code>v</code> to <code>w</code>, but our code handles them without difficulty.</p>
<p class="image"><img alt="image" src="graphics/04_68-sptstiny.jpg"/></p>
<p><a id="ch04sec3lev44"/></p>
<h5><em>Shortest-paths tree</em></h5>
<p>We focus on the <em>single-source shortest-paths problem</em>, where we are given a source vertex <code>s</code>. The result of the computation is a tree known as the <em>shortest-paths tree</em> (SPT), which gives a shortest path from <code>s</code> to every vertex reachable from <code>s</code>.</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb49"/></p>
<p><strong>Definition.</strong> Given an edge-weighted digraph and a designated vertex <code>s</code>, a <em>shortest-paths tree</em> for a source <code>s</code> is a subgraph containing <code>s</code> and all the vertices reachable from <code>s</code> that forms a directed tree rooted at <code>s</code> such that every tree path is a shortest path in the digraph.</p>
<hr/>
</div>
<p>Such a tree always exists: in general there may be two paths of the same length connecting <code>s</code> to a vertex; if that is the case, we can delete the final edge on one of them, continuing until we have only one path connecting the source to each vertex (a rooted tree). By building a shortest-paths tree, we can provide clients with the shortest path from <code>s</code> to any vertex in the graph, using a parent-link representation, in precisely the same manner as for paths in graphs in <a href="ch04.html#ch04sec1lev10"><small>SECTION 4.1</small></a>.</p>
<p class="image"><img alt="image" src="graphics/04_69-mediumspt.jpg"/></p>
<p><a id="ch04sec2lev37"/></p>
<h4><a id="page_641"/>Edge-weighted digraph data types</h4>
<p>Our data type for directed edges is simpler than for undirected edges because we follow directed edges in just one direction. Instead of the <code>either()</code> and <code>other()</code> methods in <code>Edge</code>, we have <code>from()</code> and <code>to()</code> methods:</p>
<p class="image"><img alt="image" src="graphics/t0641-01.jpg"/></p>
<p>As with our transition from <code>Graph</code> to <code>EdgeWeightedGraph</code> from <a href="ch04.html#ch04sec1lev10"><small>SECTION 4.1</small></a> to <a href="ch04.html#ch04sec1lev12"><small>SECTION 4.3</small></a>, we include an <code>edges()</code> method and use <code>DirectedEdge</code> instead of integers:</p>
<p class="image"><img alt="image" src="graphics/t0641-02.jpg"/></p>
<p>You can find implementations of these two APIs on the following two pages. These are natural extensions of the implementations of <a href="ch04.html#ch04sec1lev11"><small>SECTION 4.2</small></a> and <a href="ch04.html#ch04sec1lev12"><small>SECTION 4.3</small></a>. Instead of the adjacency lists of integers used in <code>Digraph</code>, we have adjacency lists of <code>DirectedEdge</code> objects in <code>EdgeWeightedDigraph</code>. As with the transition from <code>Graph</code> to <code>Digraph</code> from <a href="ch04.html#ch04sec1lev10"><small>SECTION 4.1</small></a> to <a href="ch04.html#ch04sec1lev11"><small>SECTION 4.2</small></a>, the transition from <code>EdgeWeightedGraph</code> in <a href="ch04.html#ch04sec1lev12"><small>SECTION 4.3</small></a> to <code>EdgeWeightedDigraph</code> in this section simplifies the code, since each edge appears only once in the data structure.</p>
<div class="sidebar">
<hr/>
<p><a id="ch04sb50"/></p>
<h3><a id="page_642"/>Directed weighted edge data type</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0642-01.jpg"/></p>
<p>This <code>DirectedEdge</code> implementation is simpler than the undirected weighted <code>Edge</code> implementation of <a href="ch04.html#ch04sec1lev12"><small>SECTION 4.3</small></a> (see page <a href="ch04.html#ch04sb38">610</a>) because the two vertices are distinguished. Our clients use the idiomatic code <code>int v = e.to(), w = e.from();</code> to access a <code>DirectedEdge e</code>’s two vertices.</p>
<hr/>
</div>
<div class="sidebar">
<hr/>
<p><a id="ch04sb51"/></p>
<h3><a id="page_643"/>Edge-weighted digraph data type</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0643-01.jpg"/></p>
<p>This <code>EdgeWeightedDigraph</code> implementation is an amalgam of <code>EdgeWeightedGraph</code> and <code>Digraph</code> that maintains a vertex-indexed array of bags of <code>DirectedEdge</code> objects. As with <code>Digraph</code>, every edge appears just once: if an edge connects <code>v</code> to <code>w</code>, it appears in <code>v</code>’s adjacency list. Self-loops and parallel edges are allowed. The <code>toString()</code> implementation is left as <a href="#ch04qa4q2"><small>EXERCISE 4.4.2</small></a>.</p>
<hr/>
</div>
<p class="image"><img alt="image" src="graphics/04_70-weighteddigraph.jpg"/></p>
<p><a id="page_644"/>The figure above shows the data structure that <code>EdgeWeightedDigraph</code> builds to represent the digraph defined by the edges at left when they are added in the order they appear. As usual, we use <code>Bag</code> to represent adjacency lists and depict them as linked lists, the standard representation. As with the unweighted digraphs of <a href="ch04.html#ch04sec1lev11"><small>SECTION 4.2</small></a>, only one representation of each edge appears in the data structure.</p>
<p><a id="ch04sec3lev45"/></p>
<h5><em>Shortest-paths API</em></h5>
<p>For shortest paths, we use the same design paradigm as for the <code>DepthFirstPaths</code> and <code>BreadthFirstPaths</code> APIs in <a href="ch04.html#ch04sec1lev10"><small>SECTION 4.1</small></a>. Our algorithms implement the following API to provide clients with shortest paths and their lengths:</p>
<p class="image"><img alt="image" src="graphics/t0644-01.jpg"/></p>
<p>The constructor builds the shortest-paths tree and computes shortest-paths distances; the client query methods use those data structures to provide distances and iterable paths to the client.</p>
<p><a id="ch04sec3lev46"/></p>
<h5><a id="page_645"/><em>Test client</em></h5>
<p>A sample client is shown below. It takes an input stream and source vertex index as command-line arguments, reads the edge-weighted digraph from the input stream, computes the SPT of that digraph for the source, and prints the shortest path from the source to each of the other vertices. We assume that all of our shortest-paths implementations include this test client. Our examples use the file <code>tinyEWD.txt</code> shown on the facing page, which defines the edges and weights that are used in the small sample digraph that we use for detailed traces of shortest-paths algorithms. It uses the same file format that we used for MST algorithms: the number of vertices <em>V</em> and the number of edges <em>E</em> followed by <em>E</em> lines, each with two vertex indices and a weight. You can also find on the booksite files that define several larger edge-weighted digraphs, including the file <code>mediumEWD.txt</code> which defines the 250-vertex graph drawn on page <a href="#page_640">640</a>. In the drawing of the graph, every line represents edges in both directions, so this file has twice as many lines as the corresponding file <code>mediumEWG.txt</code> that we examined for MSTs. In the drawing of the SPT, each line represents a directed edge pointing away from the source.</p>
<p class="image"><img alt="image" src="graphics/p0645-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/p0645-02.jpg"/></p>
<p><a id="ch04sec3lev47"/></p>
<h5><a id="page_646"/><em>Data structures for shortest paths.</em></h5>
<p>The data structures that we need to represent shortest paths are straightforward:</p>
<p class="indenthangingB">• <em>Edges on the shortest-paths tree</em>: As for DFS, BFS, and Prim’s algorithm, we use a parent-edge representation in the form of a vertex-indexed array <code>edgeTo[]</code> of <code>DirectedEdge</code> objects, where <code>edgeTo[v]</code> is edge that connects <code>v</code> to its parent in the tree (the last edge on a shortest path from <code>s</code> to <code>v</code>).</p>
<p class="indenthangingB">• <em>Distance to the source</em>: We use a vertex-indexed array <code>distTo[]</code> such that <code>distTo[v]</code> is the length of the shortest known path from <code>s</code> to <code>v</code>.</p>
<p>By convention, <code>edgeTo[s]</code> is <code>null</code> and <code>distTo[s]</code> is <code>0</code>. We also adopt the convention that distances to vertices that are not reachable from the source are all <code>Double.POSITIVE_INFINITY</code>. As usual, we will develop data types that build these data structures in the constructor and then support instance methods that use them to support client queries for shortest paths and shortest-path distances.</p>
<p class="image"><img alt="image" src="graphics/04_71-spttinyds.jpg"/></p>
<p><a id="ch04sec3lev48"/></p>
<h5><em>Edge relaxation</em></h5>
<p>Our shortest-paths implementations are based on a simple operation known as <em>relaxation</em>. We start knowing only the graph’s edges and weights, with the <code>distTo[]</code> entry for the source initialized to 0 and all of the other <code>distTo[]</code> entries initialized to <code>Double.POSITIVE_INFINITY</code>. As an algorithm proceeds, it gathers information about the shortest paths that connect the source to each vertex encountered in our <code>edgeTo[]</code> and <code>distTo[]</code> data structures. By updating this information when we encounter edges, we can make new inferences about shortest paths. Specifically, we use <em>edge relaxation</em>, defined as follows: to <em>relax</em> an edge <code>v-&gt;w</code> means to test whether the best known way from <code>s</code> to <code>w</code> is to go from <code>s</code> to <code>v</code>, then take the edge from <code>v</code> to <code>w</code>, and, if so, update our data structures to indicate that to be the case. The code at the right implements this operation. The best known distance to <code>w</code> through <code>v</code> is the sum of <code>distTo[v]</code> and <code>e.weight()</code>—if that value is not smaller than <code>distTo[w]</code>, we say the edge is <em>ineligible</em>, and we ignore it; if it <em>is</em> smaller, we update the data <a id="page_647"/>structures. The figure at the bottom of this page illustrates the two possible outcomes of an edge-relaxation operation. Either the edge is ineligible (as in the example at left) and no changes are made, or the edge <code>v-&gt;w</code> leads to a shorter path to <code>w</code> (as in the example at right) and we update <code>edgeTo[w]</code> and <code>distTo[w]</code> (which might render some other edges ineligible and might create some new eligible edges). The term <em>relaxation</em> follows from the idea of a rubber band stretched tight on a path connecting two vertices: relaxing an edge is akin to relaxing the tension on the rubber band along a shorter path, if possible. We say that an edge <code>e</code> can be <em>successfully relaxed</em> if <code>relax()</code> would change the values of <code>distTo[e.to()]</code> and <code>edgeTo[e.to()]</code>.</p>
<p class="image"><img alt="image" src="graphics/p0646-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/04_72-edgerelax.jpg"/></p>
<p><a id="ch04sec3lev49"/></p>
<h5><a id="page_648"/><em>Vertex relaxation</em></h5>
<p>All of our implementations actually relax <em>all</em> the edges pointing from a given vertex as shown in the (overloaded) implementation of <code>relax()</code> below. Note that any edge from a vertex whose <code>distTo[v]</code> entry is finite to a vertex whose <code>distTo[]</code> entry is infinite is eligible and will be added to <code>edgeTo[]</code> if relaxed. In particular, some edge leaving the source is the first to be added to <code>edgeTo[]</code>. Our algorithms choose vertices judiciously, so that each vertex relaxation finds a shorter path than the best known so far to some vertex, incrementally progressing toward the goal of finding shortest paths to every vertex.</p>
<p class="image"><img alt="image" src="graphics/04_73-vertexrelax.jpg"/></p>
<p class="image"><img alt="image" src="graphics/p0648-01.jpg"/></p>
<p><a id="ch04sec3lev50"/></p>
<h5><a id="page_649"/><em>Client query methods</em></h5>
<p>In a manner similar to our implementations for pathfinding APIs in <a href="ch04.html#ch04sec1lev10"><small>SECTION 4.1</small></a> (and <a href="ch04.html#ch04qa1q13"><small>EXERCISE 4.1.13</small></a>), the <code>edgeTo[]</code> and <code>distTo[]</code> data structures directly support the <code>pathTo()</code>, <code>hasPathTo()</code>, and <code>distTo()</code> client query methods, as shown below. This code is included in all of our shortest-paths implementations. As we have noted already, <code>distTo[v]</code> is only meaningful when <code>v</code> is reachable from <code>s</code> and we adopt the convention that <code>distTo()</code> should return infinity for vertices that are not reachable from s. To implement this convention, we initialize all <code>distTo[]</code> entries to <code>Double.POSITIVE_INFINITY</code> and <code>distTo[s]</code> to <code>0</code>; then our shortest-paths implementations will set <code>distTo[v]</code> to a finite value for all vertices <code>v</code> that are reachable from the source. Thus, we can dispense with the <code>marked[]</code> array that we normally use to mark reachable vertices in a graph search and implement <code>hasPathTo(v)</code> by testing whether <code>distTo[v]</code> equals <code>Double.POSITIVE_INFINITY</code>. For <code>pathTo()</code>, we use the convention that <code>pathTo(v)</code> returns <code>null</code> if <code>v</code> is not reachable from the source and a path with no edges if <code>v</code> <em>is</em> the source. For reachable vertices, we travel up the tree, pushing the edges that we find on a stack, in the same manner as we did for <code>DepthFirstPaths</code> and <code>BreadthFirstPaths</code>. The figure at right shows the discovery of the path <code>0-&gt;2-&gt;7-&gt;3-&gt;6</code> for our example.</p>
<p class="image"><img alt="image" src="graphics/04_74-spttinypath.jpg"/></p>
<p class="image"><img alt="image" src="graphics/p0649-01.jpg"/></p>
<p><a id="ch04sec2lev38"/></p>
<h4><a id="page_650"/>Theoretical basis for shortest-paths algorithms</h4>
<p>Edge relaxation is an easy-to-implement fundamental operation that provides a practical basis for our shortest-paths implementations. It also provides a theoretical basis for understanding the algorithms and an opportunity for us to do our algorithm correctness proofs at the outset.</p>
<p><a id="ch04sec3lev51"/></p>
<h5><em>Optimality conditions</em></h5>
<p>The following proposition shows an equivalence between the <em>global</em> condition that the distances are shortest-paths distances, and the <em>local</em> condition that we test to relax an edge.</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb52"/></p>
<p><strong>Proposition P. (Shortest-paths optimality conditions)</strong> Let <em>G</em> be an edge-weighted digraph, with <code>s</code> a source vertex in <em>G</em> and <code>distTo[]</code> a vertex-indexed array of path lengths in <em>G</em> such that, for all <code>v</code> reachable from <code>s</code>, the value of <code>distTo[v]</code> is the length of <em>some</em> path from <code>s</code> to <code>v</code> with <code>distTo[v]</code> equal to infinity for all <code>v</code> not reachable from <code>s</code>. These values are the lengths of <em>shortest</em> paths if and only if they satisfy <code>distTo[w] &lt;= distTo[v] + e.weight()</code> for each edge <code>e</code> from <code>v</code> to <code>w</code> (or, in other words, no edge is eligible).</p>
<p><strong>Proof:</strong> Suppose that <code>distTo[w]</code> is the length of a shortest path from <code>s</code> to <code>w</code>. If <code>distTo[w] &gt; distTo[v] + e.weight()</code> for some edge <code>e</code> from <code>v</code> to <code>w</code>, then <code>e</code> would give a path from <code>s</code> to <code>w</code> (through <code>v</code>) of length less than <code>distTo[w]</code>, a contradiction. Thus the optimality conditions are necessary.</p>
<p>To prove that the optimality conditions are sufficient, suppose that <code>w</code> is reachable from <code>s</code> and that <code>s = v<sub>0</sub>-&gt;v<sub>1</sub>-&gt;v<sub>2</sub>...-&gt;v<sub>k</sub> = w</code> is a shortest path from <code>s</code> to <code>w</code>, of weight <code>OPT<sub>sw</sub></code>. For <code>i</code> from <code>1</code> to <code>k</code>, denote the edge from <code>v<sub>i-1</sub></code> to <code>v<sub>i</sub></code> by <code>e<sub>i</sub></code>. By the optimality conditions, we have the following sequence of inequalities:</p>
<p class="programlisting5"><img alt="image" src="graphics/p0650-01.jpg"/></p>
<p>Collapsing these inequalities and eliminating <code>distTo[s] = 0.0</code>, we have</p>
<p class="programlisting5">distTo[w] &lt;= e<sub>1</sub>.weight() + ... + e<sub>k</sub>.weight() = OPT<sub>sw</sub>.</p>
<p>Now, <code>distTo[w]</code> is the length of <em>some</em> path from <code>s</code> to <code>w</code>, so it cannot be smaller than the length of a <em>shortest</em> path. Thus, we have shown that</p>
<p class="programlisting5">OPT<sub>sw</sub> &lt;= distTo[w] &lt;= OPT<sub>sw</sub></p>
<p>and equality must hold.</p>
<hr/>
</div>
<p><a id="ch04sec3lev52"/></p>
<h5><a id="page_651"/><em>Certification</em></h5>
<p>An important practical consequence of <a href="#ch04sb52"><small>PROPOSITION P</small></a> is its applicability to certification. However an algorithm computes <code>distTo[]</code>, we can check whether it contains shortest-path lengths in a single pass through the edges of the graph, checking whether the optimality conditions are satisfied. Shortest-paths algorithms can be complicated, and this ability to efficiently test their outcome is crucial. We include a method <code>check()</code> in our implementations on the booksite for this purpose. This method also checks that <code>edgeTo[]</code> specifies paths from the source and is consistent with <code>distTo[]</code>.</p>
<p><a id="ch04sec3lev53"/></p>
<h5><em>Generic algorithm</em></h5>
<p>The optimality conditions lead immediately to a generic algorithm that encompasses all of the shortest-paths algorithms that we consider. For the moment, we restrict attention to nonnegative weights.</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb53"/></p>
<p><strong>Proposition Q. (Generic shortest-paths algorithm)</strong> Initialize <code>distTo[s]</code> to 0 and all other <code>distTo[]</code> values to infinity, and proceed as follows:</p>
<p class="center"><em>Relax any edge in G, continuing until no edge is eligible.</em></p>
<p>For all vertices <code>w</code> reachable from <code>s</code>, the value of <code>distTo[w]</code> after this computation is the length of a shortest path from <code>s</code> to <code>w</code> (and the value of <code>edgeTo[]</code> is the last edge on that path).</p>
<p><strong>Proof:</strong> Relaxing an edge <code>v-&gt;w</code> always sets <code>distTo[w]</code> to the length of some path from <code>s</code> (and <code>edgeTo[w]</code> to the last edge on that path). For any vertex <code>w</code> reachable from <code>s</code>, some edge on the shortest path to <code>w</code> is eligible as long as <code>distTo[w]</code> remains infinite, so the algorithm continues until the <code>distTo[]</code> value of each vertex reachable from <code>s</code> is the length of some path to that vertex. For any vertex <code>v</code> for which the shortest path is well-defined, throughout the algorithm <code>distTo[v]</code> is the length of some (simple) path from <code>s</code> to <code>v</code> and is strictly monotonically decreasing. Thus, it can decrease at most a finite number of times (once for each simple path from <code>s</code> to <code>v</code>). When no edge is eligible, <a href="#ch04sb52"><small>PROPOSITION P</small></a> applies.</p>
<hr/>
</div>
<p>The key reason for considering the optimality conditions and the generic algorithm is that the generic algorithm <em>does not specify in which order the edges are to be relaxed</em>. Thus, all that we need to do to prove that any algorithm computes shortest paths is to prove that it relaxes edges until no edge is eligible.</p>
<p><a id="ch04sec2lev39"/></p>
<h4><a id="page_652"/>Dijkstra’s algorithm</h4>
<p>In <a href="ch04.html#ch04sec1lev12"><small>SECTION 4.3</small></a>, we discussed Prim’s algorithm for finding the minimum spanning tree (MST) of an edge-weighted undirected graph: we build the MST by attaching a new edge to a single growing tree at each step. <em>Dijkstra’s algorithm</em> is an analogous scheme to compute an SPT. We begin by initializing <code>dist[s]</code> to 0 and all other <code>distTo[]</code> entries to positive infinity, then we <em>relax and add to the tree a non-tree vertex with the lowest</em> <code>distTo[]</code> <em>value, continuing until all vertices are on the tree or no non-tree vertex has a finite</em> <code>distTo[]</code> <em>value</em>.</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb54"/></p>
<p><strong>Proposition R.</strong> Dijkstra’s algorithm solves the single-source shortest-paths problem in edge-weighted digraphs with nonnegative weights.</p>
<p><strong>Proof:</strong> If <code>v</code> is reachable from the source, every edge <code>v-&gt;w</code> is relaxed exactly once, when <code>v</code> is relaxed, leaving <code>distTo[w] &lt;= distTo[v] + e.weight()</code>. This inequality holds until the algorithm completes, since <code>distTo[w]</code> can only decrease (any relaxation can only decrease a <code>distTo[]</code> value) and <code>distTo[v]</code> never changes (because edge weights are nonnegative and we choose the lowest <code>distTo[]</code> value at each step, no subsequent relaxation can set any <code>distTo[]</code> entry to a lower value than <code>distTo[v]</code>). Thus, after all vertices reachable from <code>s</code> have been added to the tree, the shortest-paths optimality conditions hold, and <a href="#ch04sb52"><small>PROPOSITION P</small></a> applies.</p>
<hr/>
</div>
<p><a id="ch04sec3lev54"/></p>
<h5><em>Data structures</em></h5>
<p>To implement Dijkstra’s algorithm we add to our <code>distTo[]</code> and <code>edgeTo[]</code> data structures an index priority queue <code>pq</code> to keep track of vertices that are candidates for being the next to be relaxed. Recall that an <code>IndexMinPQ</code> allows us to associate indices with keys (priorities) and to remove and return the index corresponding to the lowest key. For this application, we always associate a vertex <code>v</code> with <code>distTo[v]</code>, and we have a direct and immediate implementation of Dijkstra’s algorithm as stated. Moreover, it is immediate by induction that the <code>edgeTo[]</code> entries corresponding to reachable vertices form a tree, the SPT.</p>
<p class="image"><img alt="image" src="graphics/04_75-dijkstraproof.jpg"/></p>
<p><a id="ch04sec3lev55"/></p>
<h5><em>Alternative viewpoint</em></h5>
<p>Another way to understand the dynamics of the algorithm derives from the proof, diagrammed at left: we have the invariant that <code>distTo[]</code> entries for tree vertices are shortest-paths distances and for each vertex <code>w</code> on the priority queue, <code>distTo[w]</code> is the weight of a shortest path from <code>s</code> to <code>w</code> that uses only <a id="page_653"/>intermediate vertices in the tree and ends in the crossing edge <code>edgeTo[w]</code>. The <code>distTo[]</code> entry for the vertex with the <em>smallest</em> priority is a shortest-path weight, not smaller than the shortest-path weight to any vertex already relaxed, and not larger than the shortest-path weight to any vertex not yet relaxed. That vertex is next to be relaxed. Reachable vertices are relaxed in order of the weight of their shortest path from <code>s</code>.</p>
<p class="image"><img alt="image" src="graphics/04_76-dijkstratrace8eager.jpg"/></p>
<p>The figure at right is a trace for our small sample graph <code>tinyEWD.txt</code>. For this example, the algorithm builds the SPT as follows:</p>
<p class="indenthangingB">• Adds <code>0</code> to the tree and its adjacent vertices <code>2</code> and <code>4</code> to the priority queue.</p>
<p class="indenthangingB">• Removes <code>2</code> from the priority queue, adds <code>0-&gt;2</code> to the tree, and adds <code>7</code> to the priority queue.</p>
<p class="indenthangingB">• Removes <code>4</code> from the priority queue, adds <code>0-&gt;4</code> to the tree, and adds <code>5</code> to the priority queue. Edge <code>4-&gt;7</code> is ineligible.</p>
<p class="indenthangingB">• Removes <code>7</code> from the priority queue, adds <code>2-&gt;7</code> to the tree, and adds <code>3</code> to the priority queue. Edge <code>7-&gt;5</code> is ineligible.</p>
<p class="indenthangingB">• Removes <code>5</code> from the priority queue, adds <code>4-&gt;5</code> to the tree, and adds <code>1</code> to the priority queue. Edge <code>5-&gt;7</code> is ineligible.</p>
<p class="indenthangingB">• Removes <code>3</code> from the priority queue, adds <code>7-&gt;3</code> to the tree, and adds <code>6</code> to the priority queue.</p>
<p class="indenthangingB">• Removes <code>1</code> from the priority queue and adds <code>5-&gt;1</code> to the tree. Edge <code>1-&gt;3</code> is ineligible.</p>
<p class="indenthangingB">• Removes <code>6</code> from the priority queue and adds <code>3-&gt;6</code> to the tree.</p>
<p>Vertices are added to the SPT in increasing order of their distance from the source, as indicated by the red arrows at the right edge of the diagram.</p>
<p><a id="page_654"/>The implementation of Dijkstra’s algorithm in <code>DijkstraSP</code> (<a href="#ch04sb56"><small>ALGORITHM 4.9</small></a>) is a rendition in code of the one-sentence description of the algorithm, enabled by adding one statement to <code>relax()</code> to handle two cases: either the <code>to()</code> vertex on an edge is not yet on the priority queue, in which case we use <code>insert()</code> to add it to the priority queue, or it is already on the priority queue and its priority lowered, in which case <code>change()</code> does so.</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb55"/></p>
<p><strong>Proposition R (continued).</strong> Dijkstra’s algorithm uses extra space proportional to <em>V</em> and time proportional to <em>E</em> log <em>V</em> (in the worst case) to solve the single-source shortest paths problem in an edge-weighted digraph with <em>E</em> edges and <em>V</em> vertices.</p>
<p><strong>Proof:</strong> Same as for Prim’s algorithm (see <a href="ch04.html#ch04sb44"><small>PROPOSITION N</small></a>).</p>
<hr/>
</div>
<p><small>AS WE HAVE INDICATED, ANOTHER WAY TO THINK ABOUT</small> Dijkstra’s algorithm is to compare it to Prim’s MST algorithm from <a href="ch04.html#ch04sec1lev12"><small>SECTION 4.3</small></a> (see page <a href="ch04.html#ch04sec1lev12">622</a>). Both algorithms build a rooted tree by adding an edge to a growing tree: Prim’s adds next the non-tree vertex that is closest to the <em>tree</em>; Dijkstra’s adds next the non-tree vertex that is closest to the <em>source</em>. The <code>marked[]</code> array is not needed, because the condition <code>!marked[w]</code> is equivalent to the condition that <code>distTo[w]</code> is infinite. In other words, switching to undirected graphs and edges and omitting the references to <code>distTo[v]</code> in the <code>relax()</code> code in <a href="#ch04sb56"><small>ALGORITHM 4.9</small></a> gives an implementation of <a href="ch04.html#ch04sb43"><small>ALGORITHM 4.7</small></a>, the eager version of Prim’s algorithm (!). Also, a lazy version of Dijkstra’s algorithm along the lines of <code>LazyPrimMST</code> (page <a href="ch04.html#ch04sb42">619</a>) is not difficult to develop.</p>
<p><a id="ch04sec3lev56"/></p>
<h5><em>Variants</em></h5>
<p>Our implementation of Dijkstra’s algorithm, with suitable modifications, is effective for solving other versions of the problem, such as the following:</p>
<p class="indenthanging"><strong><em>Single-source shortest paths in undirected graphs.</em></strong> Given an edge-weighted <em>undirected</em> graph and a source vertex <code>s</code>, support queries of the form <em>Is there a path from</em> <code>s</code> <em>to a given target vertex</em> <code>v</code>? If so, find a <em>shortest</em> such path (one whose total weight is minimal).</p>
<p>The solution to this problem is immediate if we view the undirected graph as a digraph. That is, given an undirected graph, build an edge-weighted digraph with the same vertices and with two directed edges (one in each direction) corresponding to each edge in the graph. There is a one-to-one correspondence between paths in the digraph and paths in the graph, and the costs of the paths are the same—the shortest-paths problems are equivalent.</p>
<div class="sidebar">
<hr/>
<p><a id="ch04sb56"/></p>
<h3><a id="page_655"/>Algorithm 4.9 Dijkstra’s shortest-paths algorithm</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0655-01.jpg"/></p>
<p>This implementation of Dijkstra’s algorithm grows the SPT by adding an edge at a time, always choosing the edge from a tree vertex to a non-tree vertex whose destination <code>w</code> is closest to <code>s</code>.</p>
<hr/>
</div>
<p class="indenthanging"><a id="page_656"/><strong><em>Source-sink shortest paths.</em></strong> Given an edge-weighted digraph, a source vertex <code>s</code>, and a target vertex <code>t</code>, find the shortest path from <code>s</code> to <code>t</code>.</p>
<p>To solve this problem, use Dijkstra’s algorithm, but terminate the search as soon as <code>t</code> comes off the priority queue.</p>
<p class="indenthanging"><strong><em>All-pairs shortest paths.</em></strong> Given an edge-weighted digraph, support queries of the form <em>Given a source vertex</em> <code>s</code> <em>and a target vertex</em> <code>t</code>, <em>is there a path from</em> <code>s</code> <em>to</em> <code>t</code>? If so, find a <em>shortest</em> such path (one whose total weight is minimal).</p>
<p>The surprisingly compact implementation at right below solves the all-pairs shortest paths problem, using time and space proportional to <em>E V</em> log <em>V</em>. It builds an array of <code>DijkstraSP</code> objects, one for each vertex as the source. To answer a client query, it uses the source to access the corresponding single-source shortest-paths object and then passes the target as argument to the query.</p>
<p class="indenthanging"><strong><em>Shortest paths in Euclidean graphs.</em></strong> Solve the single-source, source-sink, and all-pairs shortest-paths problems in graphs where vertices are points in the plane and edge weights are proportional to Euclidean distances between vertices.</p>
<p>A simple modification considerably speeds up Dijkstra’s algorithm in this case (see <a href="#ch04qa4q27"><small>EXERCISE 4.4.27</small></a>).</p>
<p><small>THE FIGURES ON THE FACING PAGE</small> show the emergence of the SPT as computed by Dijkstra’s algorithm for the Euclidean graph defined by our test file <code>mediumEWD.txt</code> (see page <a href="#page_645">645</a>) for several different sources. Recall that line segments in this graph represent directed edges in both directions. Again, these figures illustrate a fascinating dynamic process.</p>
<p class="image"><img alt="image" src="graphics/p0656-01.jpg"/></p>
<p>Next, we consider shortest-paths algorithms for acyclic edge-weighted graphs, where we can solve the problem in linear time (faster than Dijkstra’s algorithm) and then for edge-weighted digraphs with negative weights, where Dijkstra’s algorithm does not apply.</p>
<p class="image"><a id="page_657"/><img alt="image" src="graphics/04_77-dijkstratrace250.jpg"/></p>
<p><a id="ch04sec2lev40"/></p>
<h4><a id="page_658"/>Acyclic edge-weighted digraphs</h4>
<p>For many natural applications, edge-weighted digraphs are known to have no directed cycles. For economy, we use the equivalent term <em>edge-weighted DAG</em> to refer to an acyclic edge-weighted digraph. We now consider an algorithm for finding shortest paths that is simpler and faster than Dijkstra’s algorithm for edge-weighted DAGs. Specifically, it</p>
<p class="indenthangingB">• Solves the single-source problem in linear time</p>
<p class="indenthangingB">• Handles negative edge weights</p>
<p class="indenthangingB">• Solves related problems, such as finding <em>longest</em> paths.</p>
<p>These algorithms are straightforward extensions to the algorithm for topological sort in DAGs that we considered in <a href="ch04.html#ch04sec1lev11"><small>SECTION 4.2</small></a>.</p>
<p class="image"><img alt="image" src="graphics/04_78-tinynetworkdag.jpg"/></p>
<p>Specifically, vertex relaxation, in combination with topological sorting, immediately presents a solution to the single-source shortest-paths problem for edge-weighted DAGs. We initialize <code>distTo[s]</code> to 0 and all other <code>distTo[]</code> values to infinity, then relax the vertices, one by one, <em>taking the vertices in topological order</em>. An argument similar to (but simpler than) the argument that we used for Dijkstra’s algorithm on page <a href="#page_652">652</a> establishes the effectiveness of this method:</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb57"/></p>
<p><strong>Proposition S.</strong> By relaxing vertices in topological order, we can solve the single-source shortest-paths problem for edge-weighted DAGs in time proportional to <em>E</em> + <em>V</em>.</p>
<p><strong>Proof:</strong> Every edge <code>v-&gt;w</code> is relaxed exactly once, when <code>v</code> is relaxed, leaving <code>distTo[w] &lt;= distTo[v] + e.weight()</code>. This inequality holds until the algorithm completes, since <code>distTo[v]</code> never changes (because of the topological order, no edge pointing to <code>v</code> will be processed after <code>v</code> is relaxed) and <code>distTo[w]</code> can only decrease (any relaxation can only decrease a <code>distTo[]</code> value). Thus, after all vertices reachable from <code>s</code> have been added to the tree, the shortest-paths optimality conditions hold, and <a href="#ch04sb53"><small>PROPOSITION Q</small></a> applies. The time bound is immediate: <a href="ch04.html#ch04sb28"><small>PROPOSITION G</small></a> on page <a href="ch04.html#page_583">583</a> tells us that the topological sort takes time proportional to <em>E</em> + <em>V</em>, and the second relaxation pass completes the job by relaxing each edge once, again in time proportional to <em>E</em> + <em>V</em>.</p>
<hr/>
</div>
<p><a id="page_659"/>The figure at right is a trace for a sample acyclic edge-weighted digraph <code>tinyEWDAG.txt</code>. For this example, the algorithm builds the shortest-paths tree from vertex <code>5</code> as follows:</p>
<p class="indenthangingB">• Does a DFS to discover the topological order <code>5 1 3 6 4 7 0 2</code>.</p>
<p class="indenthangingB">• Adds to the tree <code>5</code> and all edges leaving it.</p>
<p class="indenthangingB">• Adds to the tree <code>1</code> and <code>1-&gt;3</code>.</p>
<p class="indenthangingB">• Adds to the tree <code>3</code> and <code>3-&gt;6</code>, but not <code>3-&gt;7</code>, which is ineligible.</p>
<p class="indenthangingB">• Adds to the tree <code>6</code> and edges <code>6-&gt;2</code> and <code>6-&gt;0</code>, but not <code>6-&gt;4</code>, which is ineligible.</p>
<p class="indenthangingB">• Adds to the tree <code>4</code> and <code>4-&gt;0</code>, but not <code>4-&gt;7</code>, which is ineligible. Edge <code>6-&gt;0</code> becomes ineligible.</p>
<p class="indenthangingB">• Adds to the tree <code>7</code> and <code>7-&gt;2</code>. Edge <code>6-&gt;2</code> becomes ineligible.</p>
<p class="indenthangingB">• Adds <code>0</code> to the tree, but not its incident edge <code>0-&gt;2</code>, which is ineligible.</p>
<p class="indenthangingB">• Adds <code>2</code> to the tree.</p>
<p class="image"><img alt="image" src="graphics/04_79-acyclicnettrace8.jpg"/></p>
<p>The addition of <code>2</code> to the tree is not depicted; the last vertex in a topological sort has no edges leaving it.</p>
<p>The implementation, shown in <a href="#ch04sb58"><small>ALGORITHM 4.10</small></a>, is a straightforward application of code we have already considered. It assumes that <code>Topological</code> has overloaded methods for the topological sort, using the <code>EdgeWeightedDigraph</code> and <code>DirectedEdge</code> APIs of this section (see <a href="#ch04qa4q12"><small>EXERCISE 4.4.12</small></a>). Note that our boolean array <code>marked[]</code> is not needed in this implementation: since we are processing vertices in an acyclic digraph in topological order, we never re-encounter a vertex that we have already relaxed. <a href="#ch04sb58"><small>ALGORITHM 4.10</small></a> could hardly be more efficient: after the topological sort, the constructor scans the graph, relaxing each edge exactly once. It is the method of choice for finding shortest paths in edge-weighted graphs that are known to be acyclic.</p>
<p><a href="#ch04sb57"><small>PROPOSITION S</small></a> is significant because it provides a concrete example where the absence of cycles <a id="page_661"/>considerably simplifies a problem. For shortest paths, the topological-sort-based method is faster than Dijkstra’s algorithm by a factor proportional to the cost of the priority-queue operations in Dijkstra’s algorithm. Moreover, the proof of <a href="#ch04sb57"><small>PROPOSITION S</small></a> does not depend on the edge weights being nonnegative, so we can remove that restriction for edge-weighted DAGs. Next, we consider implications of this ability to allow negative edge weights, by considering the use of the shortest-paths model to solve two other problems, one of which seems at first blush to be quite removed from graph processing.</p>
<div class="sidebar">
<hr/>
<p><a id="ch04sb58"/></p>
<h3><a id="page_660"/>Algorithm 4.10 Shortest paths in edge-weighted DAGs</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0660-01.jpg"/></p>
<p>This shortest-paths algorithm for edge-weighted DAGs uses a topological sort (<a href="ch04.html#ch04sb26"><small>ALGORITHM 4.5</small></a>, adapted to use <code>EdgeWeightedDigraph</code> and <code>DirectedEdge</code>) to enable it to relax the vertices in topological order, which is all that is needed to compute shortest paths.</p>
<p class="image"><img alt="image" src="graphics/p0660-02.jpg"/></p>
<hr/>
</div>
<p><a id="ch04sec3lev57"/></p>
<h5><em>Longest paths</em></h5>
<p>Consider the problem of finding the <em>longest</em> path in an edge-weighted DAG with edge weights that may be positive or negative.</p>
<p class="indenthanging"><strong><em>Single-source longest paths in edge-weighted DAGs.</em></strong> Given an edge-weighted DAG (with negative weights allowed) and a source vertex <code>s</code>, support queries of the form: <em>Is there a directed path from</em> <code>s</code> <em>to a given target vertex</em> <code>v</code>? If so, find a <em>longest</em> such path (one whose total weight is <em>maximal</em>).</p>
<p>The algorithm just considered provides a quick solution to this problem:</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb59"/></p>
<p><strong>Proposition T.</strong> We can solve the longest-paths problem in edge-weighted DAGs in time proportional to <em>E</em> + <em>V</em>.</p>
<p><strong>Proof:</strong> Given a longest-paths problem, create a copy of the given edge-weighted DAG that is identical to the original, except that all edge weights are negated. Then the <em>shortest</em> path in this copy is the <em>longest</em> path in the original. To transform the solution of the shortest-paths problem to a solution of the longest-paths problem, negate the weights in the solution. The running time follows immediately from <a href="#ch04sb57"><small>PROPOSITION S</small></a>.</p>
<hr/>
</div>
<p>Using this transformation to develop a class <code>AcyclicLP</code> that finds longest paths in edge-weighted DAGs is straightforward. An even simpler way to implement such a class is to copy <code>AcyclicSP</code>, then switch the <code>distTo[]</code> initialization to <code>Double.NEGATIVE_INFINITY</code> and switch the sense of the inequality in <code>relax()</code>. Either way, we get an efficient solution to the longest-paths problem in edge-weighted DAGs. This result is to be compared with the fact that the best known algorithm for finding longest simple paths in general edge-weighted digraphs (where edge weights may be negative) requires <em>exponential</em> time in the worst case (see <a href="ch06.html#ch06"><small>CHAPTER 6</small></a>)! The possibility of cycles seems to make the problem exponentially more difficult.</p>
<p><a id="page_662"/>The figure at right is a trace of the process of finding longest paths in our sample edge-weighted DAG <code>tinyEWDAG.txt</code>, for comparison with the shortest-paths trace for the same DAG on page <a href="#page_659">659</a>. For this example, the algorithm builds the longest-paths tree (LPT) from vertex <code>5</code> as follows:</p>
<p class="indenthangingB">• Does a DFS to discover the topological order <code>5 1 3 6 4 7 0 2</code>.</p>
<p class="indenthangingB">• Adds to the tree <code>5</code> and all edges leaving it.</p>
<p class="indenthangingB">• Adds to the tree <code>1</code> and <code>1-&gt;3</code>.</p>
<p class="indenthangingB">• Adds to the tree <code>3</code> and edges <code>3-&gt;6</code> and <code>3-&gt;7</code>. Edge <code>5-&gt;7</code> becomes ineligible.</p>
<p class="indenthangingB">• Adds to the tree <code>6</code> and edges <code>6-&gt;2</code>, <code>6-&gt;4</code>, and <code>6-&gt;0</code>.</p>
<p class="indenthangingB">• Adds to the tree <code>4</code> and edges <code>4-&gt;0</code> and <code>4-&gt;7</code>. Edges <code>6-&gt;0</code> and <code>3-&gt;7</code> become ineligible.</p>
<p class="indenthangingB">• Adds to the tree <code>7</code> and <code>7-&gt;2</code>. Edge <code>6-&gt;2</code> becomes ineligible</p>
<p class="indenthangingB">• Adds <code>0</code> to the tree, but not <code>0-&gt;2</code>, which is ineligible.</p>
<p class="indenthangingB">• Adds <code>2</code> to the tree (not depicted).</p>
<p class="image"><img alt="image" src="graphics/04_80-acyclicnettracelpt8.jpg"/></p>
<p>The longest-paths algorithm processes the vertices in the same order as the shortest-paths algorithm but produces a completely different result.</p>
<p><a id="ch04sec3lev58"/></p>
<h5><a id="page_663"/><em>Parallel job scheduling</em></h5>
<p>As an example application, we revisit the class of <em>scheduling</em> problems that we first considered in <a href="ch04.html#ch04sec1lev11"><small>SECTION 4.2</small></a> (page <a href="ch04.html#ch04sec1lev11">574</a>). Specifically, consider the following scheduling problem (differences from the problem on page <a href="ch04.html#page_575">575</a> are italicized):</p>
<p class="indenthanging"><strong><em>Parallel precedence-constrained scheduling.</em></strong> Given a set of jobs <em>of specified duration</em> to be completed, with precedence constraints that specify that certain jobs have to be completed before certain other jobs are begun, how can we schedule the jobs <em>on identical processors</em> (<em>as many as needed</em>) such that they are all completed <em>in the minimum amount of time</em> while still respecting the constraints?</p>
<p>Implicit in the model of <a href="ch04.html#ch04sec1lev11"><small>SECTION 4.2</small></a> is a single processor: we schedule the jobs in topological order and the total time required is the total duration of the jobs. Now, we assume that we have sufficient processors to perform as many jobs as possible, limited only by precedence constraints. Again, thousands or even millions of jobs might be involved, so we require an efficient algorithm. Remarkably, a <em>linear</em>-time algorithm is available—an approach known as the <em>critical path method</em> demonstrates that the problem is equivalent to a longest-paths problem in an edge-weighted DAG. This method has been used successfully in countless industrial applications.</p>
<p class="image"><img alt="image" src="graphics/t0663-01.jpg"/></p>
<p>We focus on the earliest possible time that we can schedule each job, assuming that any available processor can handle the job for its duration. For example, consider the problem instance specified in the table at right. The solution below shows that <code>173.0</code> is the minimum possible completion time for any schedule for this problem: the schedule satisfies all the constraints, and no schedule can complete before time <code>173.0</code> because of the job sequence <code>0-&gt;9-&gt;6-&gt;8-&gt;2</code>. This sequence is known as a <em>critical path</em> for this problem. Every sequence of jobs, each constrained to follow the job just preceding it in the sequence, represents a lower bound on the length of the schedule. If we define the length of such a sequence to be its earliest possible completion time (total of the durations of its jobs), the longest sequence is known as a critical path because any delay in the starting time of any job delays the best achievable completion time of the entire project.</p>
<p class="image"><img alt="image" src="graphics/04_81-cpmsched.jpg"/></p>
<p class="image"><a id="page_664"/><img alt="image" src="graphics/04_82-cpmnet.jpg"/></p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb60"/></p>
<p><strong>Definition.</strong> The <em>critical path method</em> for parallel scheduling is to proceed as follows: Create an edge-weighted DAG with a source <code>s</code>, a sink <code>t</code>, and two vertices for each job (a <em>start</em> vertex and an <em>end</em> vertex). For each job, add an edge from its start vertex to its end vertex with weight equal to its duration. For each precedence constraint <code>v-&gt;w</code>, add a zero-weight edge from the end vertex corresponding to <code>v</code> to the beginning vertex corresponding to <code>w</code>. Also add zero-weight edges from the source to each job’s start vertex and from each job’s end vertex to the sink. Now, schedule each job at the time given by the length of its longest path from the source.</p>
<hr/>
</div>
<p>The figure at the top of this page depicts this correspondence for our sample problem, and the figure at the bottom of the page gives the longest-paths solution. As specified, the graph has three edges for each job (zero-weight edges from the source to the start and from the finish to the sink, and an edge from start to finish) and one edge for each precedence constraint. The class <code>CPM</code> on the facing page is a straightforward implementation of the critical path method. It transforms any instance of the job-scheduling problem into an instance of the longest-paths problem in an edge-weighted DAG, uses <code>AcyclicLP</code> to solve it, then prints the job start times and schedule finish time.</p>
<p class="image"><img alt="image" src="graphics/04_83-cpmnetsolution.jpg"/></p>
<div class="sidebar">
<hr/>
<p><a id="ch04sb61"/></p>
<h3><a id="page_665"/>Critical path method for parallel precedence-constrained job scheduling</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0665-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0665-01.jpg"/></p>
<p>This implementation of the critical path method for job scheduling reduces the problem directly to the longest-paths problem in edge-weighted DAGs. It builds an edge-weighted digraph (which must be a DAG) from the job-scheduling problem specification, as prescribed by the critical path method, then uses <code>AcyclicLP</code> (see <a href="#ch04sb59"><small>PROPOSITION T</small></a>) to find the longest-paths tree and to print the longest-paths lengths, which are precisely the start times for each job.</p>
<p class="image"><img alt="image" src="graphics/t0665-02.jpg"/></p>
<hr/>
</div>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb62"/></p>
<p><a id="page_666"/><strong>Proposition U.</strong> The critical path method solves the parallel precedence-constrained scheduling problem in linear time.</p>
<p><strong>Proof:</strong> Why does the CPM approach work? The correctness of the algorithm rests on two facts. First, every path in the DAG is a sequence of job starts and job finishes, separated by zero-weight precedence constraints—the length of any path from the source <code>s</code> to any vertex <code>v</code> in the graph is a lower bound on the start/finish time represented by <code>v</code>, because we could not do better than scheduling those jobs one after another on the same machine. In particular, the length of the longest path from <code>s</code> to the sink <code>t</code> is a <em>lower</em> bound on the finish time of all the jobs. Second, all the start and finish times implied by longest paths are <em>feasible</em>—every job starts after the finish of all the jobs where it appears as a successor in a precedence constraint, because the start time is the length of the <em>longest</em> path from the source to it. In particular, the length of the longest path from <code>s</code> to <code>t</code> is an <em>upper</em> bound on the finish time of all the jobs. The linear-time performance is immediate from <a href="#ch04sb59"><small>PROPOSITION T</small></a>.</p>
<hr/>
</div>
<p class="image"><img alt="image" src="graphics/t0666-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/t0666-02.jpg"/></p>
<p><a id="ch04sec3lev59"/></p>
<h5><em>Parallel job scheduling with relative deadlines</em></h5>
<p>Conventional deadlines are relative to the start time of the first job. Suppose that we allow an additional type of constraint in the job-scheduling problem to specify that a job must begin before a specified amount of time has elapsed, relative to the start time of another job. Such constraints are commonly needed in time-critical manufacturing processes and in many other applications, but they can make the job-scheduling problem considerably more difficult to solve. For example, as shown at left, suppose that we need to add a constraint to our example that job 2 must start no later than 12 time units after job 4 starts. This deadline is actually a constraint on the start time of job 4: it must be no earlier than 12 time units before the start time of job 2. In our example, there is room in the schedule to meet the deadline: we can move the start time of job 4 to 111, 12 time units before the scheduled start time of job 2. Note that, if job 4 were a long job, this change would increase the finish time of the whole schedule. Similarly, if we add to the schedule a deadline that job 2 must start no later than 70 time units after job 7 starts, there is room in the schedule to change the start time of job 7 to 53, without having to reschedule jobs 3 and 8. But if we add a deadline that job 4 must start no later <a id="page_667"/>than 80 time units after job 0, the schedule becomes <em>infeasible</em>: the constraints that 4 must start no more than 80 time units after job 0 and that job 2 must start no more than 12 units after job 4 imply that job 2 must start no more than 93 time units after job 0, but job 2 must start at least 123 time units after job 0 because of the chain 0 (41 time units) precedes 9 (29 time units) precedes 6 (21 time units) precedes 8 (32 time units) precedes 2. Adding more deadlines of course multiplies the possibilities and turns an easy problem into a difficult one.</p>
<p class="image"><img alt="image" src="graphics/t0666-03.jpg"/></p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb63"/></p>
<p><strong>Proposition V.</strong> Parallel job scheduling with relative deadlines is a shortest-paths problem in edge-weighted digraphs (with cycles and negative weights allowed).</p>
<p><strong>Proof:</strong> Use the same construction as in <a href="#ch04sb62"><small>PROPOSITION U</small></a>, adding an edge for each deadline: if job <code>v</code> has to start within <code>d</code> time units of the start of job <code>w</code>, add an edge from <code>v</code> to <code>w</code> with <em>negative</em> weight <code>d</code>. Then convert to a shortest-paths problem by negating all the weights in the digraph. The proof of correctness applies, <em>provided that the schedule is feasible</em>. Determining whether a schedule is feasible is part of the computational burden, as you will see.</p>
<hr/>
</div>
<p>This example illustrates that negative weights can play a critical role in practical application models. It says that if we can find an efficient solution to the shortest-paths problem with negative weights, then we can find an efficient solution to the parallel job scheduling problem with relative deadlines. Neither of the algorithms we have considered can do the job: Dijkstra’s algorithm requires that weights be positive (or zero), and <a href="#ch04sb58"><small>ALGORITHM 4.10</small></a> requires that the digraph be acyclic. Next, we consider the problem of coping with negative edge weights in digraphs that are not necessarily acyclic.</p>
<p class="image"><img alt="image" src="graphics/04_84-cpmnetdeadlines.jpg"/></p>
<p><a id="ch04sec2lev41"/></p>
<h4><a id="page_668"/>Shortest paths in general edge-weighted digraphs</h4>
<p>Our job-scheduling-with-deadlines example just discussed demonstrates that negative weights are not merely a mathematical curiosity; on the contrary, they significantly extend the applicability of the shortest-paths problem as a problem-solving model. Accordingly we now consider algorithms for edge-weighted digraphs that may have <em>both</em> cycles and negative weights. Before doing so, we consider some basic properties of such digraphs to reset our intuition about shortest paths. The figure at left is a small example that illustrates the effects of introducing negative weights on a digraph’s shortest paths. Perhaps the most important effect is that when negative weights are present, low-weight shortest paths tend to have <em>more</em> edges than higher-weight paths. For positive weights, our emphasis was on looking for shortcuts; but when negative weights are present, we seek <em>detours</em> that use negative-weight edges. This effect turns our intuition in seeking “short” paths into a liability in understanding the algorithms, so we need to suppress that line of intuition and consider the problem on a basic abstract level.</p>
<p class="image"><img alt="image" src="graphics/04_85-tinynetworknag.jpg"/></p>
<p><a id="ch04sec3lev60"/></p>
<h5><em>Strawman I</em></h5>
<p>The first idea that suggests itself is to find the smallest (most negative) edge weight, then to add the absolute value of that number to all the edge weights to transform the digraph into one with no negative weights. This naive approach does not work at all, because shortest paths in the new digraph bear little relation to shortest paths in the old one. The more edges a path has, the more it is penalized by this transformation (see <a href="#ch04qa4q14"><small>EXERCISE 4.4.14</small></a>).</p>
<p><a id="ch04sec3lev61"/></p>
<h5><em>Strawman II</em></h5>
<p>The second idea that suggests itself is to try to adapt Dijkstra’s algorithm in some way. The fundamental difficulty with this approach is that the algorithm depends on examining paths in increasing order of their distance from the source. The proof in <a href="#ch04sb54"><small>PROPOSITION R</small></a> that the algorithm is correct assumes that adding an edge to a path makes that path longer. But any edge with negative weight makes the path <em>shorter</em>, so that assumption is unfounded (see <a href="#ch04qa4q14"><small>EXERCISE 4.4.14</small></a>).</p>
<p><a id="ch04sec3lev62"/></p>
<h5><em>Negative cycles</em></h5>
<p>When we consider digraphs that could have negative edge weights, the concept of a shortest path is meaningless if there is a cycle in the digraph that <a id="page_669"/>has negative weight. For example, consider the digraph at left, which is identical to our first example except that edge <code>5-&gt;4</code> has weight <code>-.66</code>. Then, the weight of the cycle <code>4-&gt;7-&gt;5-&gt;4</code> is</p>
<p class="programlisting">37+.28-.66 = -.01</p>
<p class="image"><img alt="image" src="graphics/04_86-tinynetworkneg.jpg"/></p>
<p>We can spin around that cycle to generate arbitrarily short paths! Note that it is not necessary for all the edges on a directed cycle to be of negative weight; what matters is the <em>sum</em> of the edge weights.</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb64"/></p>
<p><strong>Definition.</strong> A <em>negative cycle</em> in an edge-weighted digraph is a directed cycle whose total weight (sum of the weights of its edges) is negative.</p>
<hr/>
</div>
<p>Now, suppose that some vertex on a path from <code>s</code> to a reachable vertex <code>v</code> is also on a negative cycle. In this case, the existence of a shortest path from <code>s</code> to <code>v</code> would be a contradiction, because we could use the cycle to construct a path with weight lower than any given value. In other words, shortest paths can be an ill-posed problem if negative cycles are present.</p>
<p class="image"><img alt="image" src="graphics/04_87-spnegcycle.jpg"/></p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb65"/></p>
<p><strong>Proposition W.</strong> There exists a shortest path from <code>s</code> to <code>v</code> in an edge-weighted digraph if and only if there exists at least one directed path from <code>s</code> to <code>v</code> <em>and</em> no vertex on any directed path from <code>s</code> to <code>v</code> is on a negative cycle.</p>
<p><strong>Proof:</strong> See discussion above and <a href="#ch04qa4q29"><small>EXERCISE 4.4.29</small></a>.</p>
<hr/>
</div>
<p>Note that the requirement that shortest paths have no vertices on negative cycles implies that shortest paths are simple and that we can compute a shortest-paths tree for such vertices, as we have done for positive edge weights.</p>
<p><a id="ch04sec3lev63"/></p>
<h5><a id="page_670"/><em>Strawman III</em></h5>
<p>Whether or not there are negative cycles, there exists a shortest <em>simple</em> path connecting the source to each vertex reachable from the source. Why not define shortest paths so that we seek such paths? Unfortunately, the best known algorithm for solving this problem takes exponential time in the worst case (see <a href="ch06.html#ch06"><small>CHAPTER 6</small></a>). Generally, we consider such problems “too difficult to solve” and study simpler versions.</p>
<p><small>THUS, A WELL-POSED AND TRACTABLE VERSION</small> of the shortest paths problem in edge-weighted digraphs is to require algorithms to</p>
<p class="indenthangingB">• Assign a shortest-path weight of +<em>∞</em> to vertices that are not reachable from the source</p>
<p class="indenthangingB">• Assign a shortest-path weight of −<em>∞</em> to vertices that are on a path from the source that has a vertex that is on a negative cycle</p>
<p class="indenthangingB">• Compute the shortest-path weight (and tree) for all other vertices</p>
<p>Throughout this section, we have been placing restrictions on the shortest-paths problem so that we can develop algorithms to solve it. First, we disallowed negative weights, then we disallowed directed cycles. We now adopt these less stringent restrictions and focus on the following problems in general digraphs:</p>
<p class="indenthanging"><strong><em>Negative cycle detection.</em></strong> Does a given edge-weighted digraph have a negative cycle? If it does, find one such cycle.</p>
<p class="indenthanging"><strong><em>Single-source shortest paths when negative cycles are not reachable.</em></strong> Given an edge-weighted digraph and a source <code>s</code> with no negative cycles reachable from <code>s</code>, support queries of the form <em>Is there a directed path from</em> <code>s</code> <em>to a given target vertex</em> <code>v</code>? If so, find a <em>shortest</em> such path (one whose total weight is minimal).</p>
<p><small>TO SUMMARIZE:</small> while shortest paths in digraphs with directed cycles is an ill-posed problem and we <em>cannot</em> efficiently solve the problem of finding simple shortest paths in such digraphs, we <em>can</em> identify negative cycles in practical situations. For example, in a job-scheduling-with-deadlines problem, we might expect negative cycles to be relatively rare: constraints and deadlines derive from logical real-world constraints, so any negative cycles are likely to stem from an error in the problem statement. Finding negative cycles, correcting errors, and then finding the schedule in a problem with no negative cycles is a reasonable way to proceed. In other cases, finding a negative cycle is the goal of the computation. The following approach, developed by R. Bellman and L. Ford in the late 1950s, provides a simple and effective basis for attacking both of these problems and is also effective for digraphs with positive weights:</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb66"/></p>
<p><a id="page_671"/><strong>Proposition X. (Bellman-Ford algorithm)</strong> The following method solves the single-source shortest-paths problem from a given source <code>s</code> for any edge-weighted digraph with <em>V</em> vertices and no negative cycles reachable from <code>s</code>: Initialize <code>distTo[s]</code> to 0 and all other <code>distTo[]</code> values to infinity. Then, considering the digraph’s edges in any order, relax all edges. Make <em>V</em> such passes.</p>
<p><strong>Proof:</strong> For any vertex <code>t</code> that is reachable from <code>s</code> consider a specific shortest path from <code>s</code> to <code>t</code>: <code>v</code><sub><code>0</code></sub><code>-&gt;v</code><sub><code>1</code></sub><code>-&gt;...-&gt;v</code><sub><code>k</code></sub>, where <code>v</code><sub><code>0</code></sub> is <code>s</code> and <code>v</code><sub><code>k</code></sub> is <code>t</code>. Since there are no negative cycles, such a path exists and <code>k</code> can be no larger than <em>V</em>−1. We show by induction on <code>i</code> that after the <code>i</code>th pass the algorithm computes a shortest path from <code>s</code> to <code>v</code><sub><code>i</code></sub>. The base case (<code>i = 0</code>) is trivial. Assuming the claim to be true for <code>i</code>, <code>v<sub>0</sub>-&gt;v<sub>1</sub>-&gt;...-&gt;v<sub>i</sub></code> is a shortest path from <code>s</code> to <code>v<sub>i</sub></code>, and <code>distTo[v<sub>i</sub>]</code> is its length. Now, we relax every vertex in the <code>i</code>th pass, including <code>v<sub>i</sub></code>, so <code>distTo[v<sub>i+1</sub>]</code> is no greater than <code>distTo[v<sub>i</sub>]</code> plus the weight of <code>v<sub>i</sub>-&gt;v<sub>i+1</sub></code>. Now, after the <code>i</code>th pass, <code>distTo[v<sub>i+1</sub>]</code> must be equal to <code>distTo[v<sub>i</sub>]</code> plus the weight of <code>v<sub>i</sub>-&gt;v<sub>i+1</sub></code>. It cannot be greater because we relax every vertex in the <code>i</code>th pass, in particular <code>v<sub>i</sub></code>, and it cannot be less because that is the length of <code>v</code><sub><code>0</code></sub><code>-&gt;v</code><sub><code>1</code></sub><code>-&gt;...-&gt;v</code><sub><code>i+1</code></sub>, a shortest path. Thus the algorithm computes a shortest path from <code>s</code> to <code>v</code><sub><code>i+1</code></sub> after the <code>(i+1)</code>st pass.</p>
<hr/>
</div>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb67"/></p>
<p><strong>Proposition W (continued).</strong> The Bellman-Ford algorithm takes time proportional to <em>EV</em> and extra space proportional to <em>V</em>.</p>
<p><strong>Proof:</strong> Each of the <em>V</em> passes relaxes <em>E</em> edges.</p>
<hr/>
</div>
<p>This method is very general, since it does not specify the order in which the edges are relaxed. We now restrict attention to a less general method where we always relax all the edges leaving any vertex (in any order). The following code exhibits the simplicity of the approach:</p>
<p class="programlisting5"><img alt="image" src="graphics/p0671-01.jpg"/></p>
<p>We do not consider this version in detail because it <em>always</em> relaxes <em>VE</em> edges, and a simple modification makes the algorithm much more efficient for typical applications.</p>
<p><a id="ch04sec3lev64"/></p>
<h5><a id="page_672"/><em>Queue-based Bellman-Ford</em></h5>
<p>Specifically, we can easily determine <em>a priori</em> that numerous edges are not going to lead to a successful relaxation in any given pass: the only edges that could lead to a change in <code>distTo[]</code> are those leaving a vertex whose <code>distTo[]</code> value changed in the previous pass. To keep track of such vertices, we use a FIFO queue. The operation of the algorithm for our standard example with positive weights is shown at right. Shown at the left of the figure are the queue entries for each pass (in red), followed by the queue entries for the next pass (in black). We start with the source on the queue and then compute the SPT as follows:</p>
<p class="indenthangingB">• Relax <code>1-&gt;3</code> and put <code>3</code> on the queue.</p>
<p class="indenthangingB">• Relax <code>3-&gt;6</code> and put <code>6</code> on the queue.</p>
<p class="indenthangingB">• Relax <code>6-&gt;4</code>, <code>6-&gt;0</code>, and <code>6-&gt;2</code> and put <code>4</code>, <code>0</code>, and <code>2</code> on the queue.</p>
<p class="indenthangingB">• Relax <code>4-&gt;7</code> and <code>4-&gt;5</code> and put <code>7</code> and <code>5</code> on the queue. Then relax <code>0-&gt;4</code> and <code>0-&gt;2</code>, which are ineligible. Then relax <code>2-&gt;7</code> (and recolor <code>4-&gt;7</code>).</p>
<p class="indenthangingB">• Relax <code>7-&gt;5</code> (and recolor <code>4-&gt;5</code>) but do not put <code>5</code> on the queue (it is already there). Then relax <code>7-&gt;3</code>, which is ineligible. Then relax <code>5-&gt;1</code>, <code>5-&gt;4</code>, and <code>5-&gt;7</code>, which are ineligible, leaving the queue empty.</p>
<p class="image"><img alt="image" src="graphics/04_88-bellmanfordtrace8.jpg"/></p>
<p><a id="ch04sec3lev65"/></p>
<h5><em>Implementation</em></h5>
<p>Implementing the Bellman-Ford algorithm along these lines requires remarkably little code, as shown in <a href="#ch04sb69"><small>ALGORITHM 4.11</small></a>. It is based on two additional data structures:</p>
<p class="indenthangingB">• A queue <code>q</code> of vertices to be relaxed</p>
<p class="indenthangingB">• A vertex-indexed <code>boolean</code> array <code>onQ[]</code> that indicates which vertices are on the queue, to avoid duplicates</p>
<p><a id="page_673"/>We start by putting the source <code>s</code> on the queue, then enter a loop where we take a vertex off the queue and relax it. To add vertices to the queue, we augement our <code>relax()</code> implementation from page <a href="#page_646">646</a> to put the vertex pointed to by any edge that successfully relaxes onto the queue, as shown in the code at right. The data structures ensure that</p>
<p class="indenthangingB">• Only one copy of each vertex appears on the queue</p>
<p class="indenthangingB">• Every vertex whose <code>edgeTo[]</code> and <code>distTo[]</code> values change in some pass is processed in the next pass</p>
<p class="image"><img alt="image" src="graphics/p0673-01.jpg"/></p>
<p>To complete the implementation, we need to ensure that the algorithm terminates after <em>V</em> passes. One way to achieve this end is to explicitly keep track of the passes. Our implementation <code>BellmanFordSP</code> (<a href="#ch04sb69"><small>ALGORITHM 4.11</small></a>) uses a different approach that we will consider in detail on page <a href="#page_677">677</a>: it checks for negative cycles in the subset of digraph edges in <code>edgeTo[]</code> and terminates if it finds one.</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb68"/></p>
<p><strong>Proposition Y.</strong> The queue-based implementation of the Bellman-Ford algorithm solves the single-source shortest-paths problem from a given source <code>s</code> (or finds a negative cycle reachable from <code>s</code>) for any edge-weighted digraph with <em>E</em> edges and <em>V</em> vertices, in time proportional to <em>EV</em> and extra space proportional to <em>V</em>, in the worst case.</p>
<p><strong>Proof:</strong> If there is no negative cycle reachable from <code>s</code>, the algorithm terminates after relaxations corresponding to the (<em>V</em>–1)st pass of the generic algorithm described in <a href="#ch04sb66"><small>PROPOSITION X</small></a> (since all shortest paths have fewer than <em>V</em>–1 edges). If there does exist a negative cycle reachable from <code>s</code>, the queue never empties. After relaxations corresponding to the <em>V</em>th pass of the generic algorithm described in <a href="#ch04sb66"><small>PROPOSITION X</small></a> the <code>edgeTo[]</code> array has a path with a cycle (connects some vertex <code>w</code> to itself) and that cycle must be negative, since the path from <code>s</code> to the second occurrence of <code>w</code> must be shorter that the path from <code>s</code> to the first occurrence of <code>w</code> for <code>w</code> to be included on the path the second time. In the worst case, the algorithm mimics the general algorithm and relaxes all <em>E</em> edges in each of <em>V</em> passes.</p>
<hr/>
</div>
<div class="sidebar">
<hr/>
<p><a id="ch04sb69"/></p>
<h3><a id="page_674"/>Algorithm 4.11 Bellman-Ford algorithm (queue-based)</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0674-01.jpg"/></p>
<p>This implementation of the Bellman-Ford algorithm uses a version of <code>relax()</code> that puts vertices pointed to by edges that successfully relax on a FIFO queue (avoiding duplicates) and periodically checks for a negative cycle in <code>edgeTo[]</code> (see text).</p>
<hr/>
</div>
<p><a id="page_675"/>The queue-based Bellman-Ford algorithm is an effective and efficient method for solving the shortest-paths problem that is widely used in practice, even for the case when edge weights are positive. For example, as shown in the diagram at right, our 250-vertex example is complete in 14 passes and requires fewer path-length compares than Dijkstra’s algorithm for the same problem.</p>
<p class="image"><img alt="image" src="graphics/04_89-bellmanfordtrace250.jpg"/></p>
<p><a id="ch04sec3lev66"/></p>
<h5><em>Negative weights</em></h5>
<p>The example on the next page traces the progress of the Bellman-Ford algorithm in a digraph with negative weights. We start with the source on <code>q</code> and then compute the SPT as follows:</p>
<p class="indenthangingB">• Relax <code>0-&gt;2</code> and <code>0-&gt;4</code> and put <code>2</code> and <code>4</code> on the queue.</p>
<p class="indenthangingB">• Relax <code>2-&gt;7</code> and put <code>7</code> on the queue. Then relax <code>4-&gt;5</code> and put <code>5</code> on the queue. Then relax <code>4-&gt;7</code>, which is ineligible.</p>
<p class="indenthangingB">• Relax <code>7-&gt;3</code> and <code>5-&gt;1</code> and put <code>3</code> and <code>1</code> on the queue. Then relax <code>5-&gt;4</code> and <code>5-&gt;7</code>, which are ineligible.</p>
<p class="indenthangingB">• Relax <code>3-&gt;6</code> and put <code>6</code> on the queue. Then relax <code>1-&gt;3</code>, which is ineligible.</p>
<p class="indenthangingB">• Relax <code>6-&gt;4</code> and put <code>4</code> on the queue. This negative-weight edge gives a shorter path to 4, so its edges must be relaxed again (they were first relaxed in pass 2). The distances to <code>5</code> and to <code>1</code> are no longer valid but will be corrected in later passes.</p>
<p class="indenthangingB">• Relax <code>4-&gt;5</code> and put <code>5</code> on the queue. Then relax <code>4-&gt;7</code>, which is still ineligible.</p>
<p class="indenthangingB">• Relax <code>5-&gt;1</code> and put <code>1</code> on the queue. Then relax <code>5-&gt;4</code> and <code>5-&gt;7</code>, which are both still ineligible.</p>
<p class="indenthangingB">• Relax <code>1-&gt;3</code>, which is still ineligible, leaving the queue empty.</p>
<p>The shortest-paths tree for this example is a single long path from <code>0</code> to <code>1</code>. The edges from <code>4</code>, <code>5</code>, and <code>1</code> are all relaxed twice for this example. Rereading the proof of <a href="#ch04sb66"><small>PROPOSITION X</small></a> in the context of this example is a good way to better understand it.</p>
<p class="image"><a id="page_676"/><img alt="image" src="graphics/04_90-bellmanfordtrace8.jpg"/></p>
<p><a id="ch04sec3lev67"/></p>
<h5><a id="page_677"/><em>Negative cycle detection</em></h5>
<p>Our implementation <code>BellmanFordSP</code> checks for negative cycles to avoid an infinite loop. We can apply the code that does this check to provide clients with the capability to check for and extract negative cycles, as well. We do so by adding the following methods to the <code>SP</code> API on page <a href="#page_644">644</a>:</p>
<p class="image"><img alt="image" src="graphics/p0677-01.jpg"/></p>
<p>Implementing these methods is not difficult, as shown in the code below. After running the constructor in <code>BellmanFordSP</code>, the proof of <a href="#ch04sb68"><small>PROPOSITION Y</small></a> tells us that the digraph has a negative cycle reachable from the source if and only if the queue is nonempty after the <em>V</em>th pass through all the edges. Moreover, the subgraph of edges in our <code>edgeTo[]</code> array must contain a negative cycle. Accordingly, to implement <code>negativeCycle()</code> we build an edge-weighted digraph from the edges in <code>edgeTo[]</code> and look for a cycle in that digraph. To find the cycle, we use a version of <code>DirectedCycle</code> from <a href="ch04.html#ch04sec1lev12"><small>SECTION 4.3</small></a>, adapted to work for edge-weighted digraphs (see <a href="#ch04qa4q12"><small>EXERCISE 4.4.12</small></a>). We amortize the cost of this check by</p>
<p class="indenthangingB">• Adding an instance variable <code>cycle</code> and a private method <code>findNegativeCycle()</code> that sets <code>cycle</code> to an iterator for the edges of a negative cycle if one is found (and to <code>null</code> if none is found)</p>
<p class="indenthangingB">• Calling <code>findNegativeCycle()</code> every <em>V</em>th call to <code>relax()</code></p>
<p class="image"><img alt="image" src="graphics/p0677-02.jpg"/></p>
<p>This approach ensures that the loop in the constructor terminates. Moreover, clients can call <code>hasNegativeCycle()</code> to learn whether there is a negative cycle reachable from the source (and <code>negativeCycle()</code> to get one such cycle. Adding the capability to detect any negative cycle in the digraph is also a simple extension (see <a href="#ch04qa4q43"><small>EXERCISE 4.4.43</small></a>).</p>
<p><a id="page_678"/>The example below traces the progress of the Bellman-Ford algorithm in a digraph with a negative cycle. The first two passes are the same as for <code>tinyEWDn.txt</code>. In the third pass, after relaxing <code>7-&gt;3</code> and <code>5-&gt;1</code> and putting <code>3</code> and <code>1</code> on <code>queue</code>, it relaxes the negative-weight edge <code>5-&gt;4</code>. <em>This relaxation discovers the negative cycle</em> <code>4-&gt;5-&gt;4</code>. It puts <code>5-&gt;4</code> on the tree and cuts the cycle off from the source <code>0</code> in <code>edgeTo[]</code>. From that point on, the algorithm spins through the cycle, lowering the distances to all the vertices touched, until finishing when the cycle is detected, with the queue not empty. The cycle is in the <code>edgeTo[]</code> array, for discovery by <code>findNegativeCycle()</code>.</p>
<p class="image"><img alt="image" src="graphics/04_91-bellmanfordtrace8.jpg"/></p>
<p><a id="ch04sec3lev68"/></p>
<h5><a id="page_679"/><em>Arbitrage</em></h5>
<p>Consider a market for financial transactions that is based on trading commodities. You can find a familiar example in tables that show conversion rates among currencies, such as the one in our sample file <code>rates.txt</code> shown here. The first line in the file is the number <em>V</em> of currencies; then the file has one line per currency, giving its name followed by the conversion rates to the other currencies. For brevity, this example includes just five of the hundreds of currencies that are traded on modern markets: U.S. dollars (<code>USD</code>), Euros (<code>EUR</code>), British pounds (<code>GBP</code>), Swiss francs (<code>CHF</code>), and Canadian dollars (<code>CAD</code>). The <code>t</code>th number on line <code>s</code> represents a conversion rate: the number of units of the currency named on row <code>t</code> that can be bought with 1 unit of the currency named on row <code>s</code>. For example, our table says that 1,000 U.S. dollars will buy 741 euros. This table is equivalent to a <em>complete edge-weighted digraph</em> with a vertex corresponding to each currency and an edge corresponding to each conversion rate. An edge <code>s-&gt;t</code> with weight <code>x</code> corresponds to a conversion from <code>s</code> to <code>t</code> at exchange rate <code>x</code>. Paths in the digraph specify multistep conversions. For example, combining the conversion just mentioned with an edge <code>t-&gt;u</code> with weight <code>y</code> gives a path <code>s-&gt;t-&gt;u</code> that represents a way to convert 1 unit of currency <code>s</code> into <code>xy</code> units of currency <code>u</code>. For example, we might buy 1,012.206 = 741×1.366 Canadian dollars with our euros. Note that this gives a better rate than directly converting from U.S. dollars to Canadian dollars. You might expect <code>xy</code> to be equal to the weight of <code>s-&gt;u</code> in all such cases, but such tables represent a complex financial system where such consistency cannot be guaranteed. Thus, finding the path from <code>s</code> to <code>u</code> such that the product of the weights is maximal is certainly of interest. Even more interesting is a case where the product of the edge weights is <em>smaller</em> than the weight of the edge from the last vertex back to the first. In our example, suppose that the weight of <code>u-&gt;s</code> is <code>z</code> and <code>xyz &gt; 1</code>. Then cycle <code>s-&gt;t-&gt;u-&gt;s</code> gives a way to convert 1 unit of currency <code>s</code> into more than 1 unit (<code>xyz</code>) of currency <code>s</code>. In other words, we can make a <code>100</code>(<code>xyz - 1</code>) percent profit by converting from <code>s</code> to <code>t</code> to <code>u</code> back to <code>s</code>. For example, if we convert our 1,012.206 Canadian dollars back to US dollars, we get 1,012.206 × .995 = 1,007.14497 dollars, a 7.14497-dollar profit. That might not seem like <a id="page_681"/>much, but a currency trader might have 1 million dollars and be able to execute these transactions every minute, which would lead to profits of over $7,000 per minute, or $420,000 per hour! This situation is an example of an <em>arbitrage</em> opportunity that would allow traders to make unlimited profits were it not for forces outside the model, such as transaction fees or limitations on the size of transactions. Even with these forces, arbitrage is plenty profitable in the real world. What does this problem have to do with shortest paths? The answer to this question is remarkably simple:</p>
<div class="sidebar1">
<hr/>
<p><a id="ch04sb70"/></p>
<p><strong>Proposition Z.</strong> The arbitrage problem is a negative-cycle-detection problem in edge-weighted digraphs.</p>
<p><strong>Proof:</strong> Replace each weight by its <em>logarithm</em>, negated. With this change, computing path weights by multiplying edge weights in the original problem corresponds to adding them in the transformed problem. Specifically, any product <em>w</em><sub>1</sub><em>w</em><sub>2</sub> . . . <em>w<sub>k</sub></em> corresponds to a sum −ln(<em>w</em><sub>1</sub>) − ln(<em>w</em><sub>2</sub>) − . . . − ln(<em>w<sub>k</sub></em>). The transformed edge weights might be negative or positive, a path from <code>v</code> to <code>w</code> gives a way of converting from currency <code>v</code> to currency <code>w</code>, and any negative cycle is an arbitrage opportunity.</p>
<hr/>
</div>
<p class="image"><img alt="image" src="graphics/p0679-01.jpg"/></p>
<p class="image"><img alt="image" src="graphics/04_92-arbitragearbitrage.jpg"/></p>
<div class="sidebar">
<hr/>
<p><a id="ch04sb71"/></p>
<h3><a id="page_680"/>Arbitrage in currency exchange</h3>
<p class="programlisting2"><img alt="image" src="graphics/p0680-01.jpg"/></p>
<p>This <code>BellmanFordSP</code> client finds an arbitrage opportunity in a currency exchange table by constructing a complete-graph representation of the exchange table and then using the Bellman-Ford algorithm to find a negative cycle in the graph.</p>
<p class="image"><img alt="image" src="graphics/p0680-02.jpg"/></p>
<hr/>
</div>
<p>In our example, where all transactions are possible, the digraph is a complete graph, so any negative cycle is reachable from any vertex. In general commodity exchanges, some edges may be absent, so the one-argument constructor described in <a href="#ch04qa4q43"><small>EXERCISE 4.4.43</small></a> is needed. No efficient algorithm for finding the <em>best</em> arbitrage opportunity (the most negative cycle in a digraph) is known (and the graph does not have to be very big for this computational burden to be overwhelming), but the fastest algorithm to find <em>any</em> arbitrage opportunity is crucial—a trader with that algorithm is likely to systematically wipe out numerous opportunities before the second-fastest algorithm finds any.</p>
<p class="image"><img alt="image" src="graphics/04_93-arbitragearbitrage.jpg"/></p>
<p><small>THE TRANSFORMATION IN THE PROOF of</small> <a href="#ch04sb70"><small>PROPOSITION Z</small></a> is useful even in the absence of arbitrage, because it reduces currency conversion to a shortest-paths problem. Since the logarithm function is monotonic (and we negated the logarithms), the product is maximized precisely when the sum is minimized. The edge weights might be negative or positive, and a shortest path from <code>v</code> to <code>w</code> gives a best way of converting from currency <code>v</code> to currency <code>w</code>.</p>
<p><a id="ch04sec2lev42"/></p>
<h4><a id="page_682"/>Perspective</h4>
<p>The table below summarizes the important characteristics of the shortest-paths algorithms that we have considered in this section. The first reason to choose among the algorithms has to do with basic properties of the digraph at hand. Does it have negative weights? Does it have cycles? Does it have negative cycles? Beyond these basic characteristics, the characteristics of edge-weighted digraphs can vary widely, so choosing among the algorithms requires some experimentation when more than one can apply.</p>
<p class="image"><img alt="image" src="graphics/t0682-01.jpg"/></p>
<p><a id="ch04sec3lev69"/></p>
<h5><em>Historical notes</em></h5>
<p>Shortest-paths problems have been intensively studied and widely used since the 1950s. The history of Dijkstra’s algorithm for computing shortest paths is similar (and related) to the history of Prim’s algorithm for computing the MST. The name <em>Dijkstra’s algorithm</em> is commonly used to refer both to the abstract method of building an SPT by adding vertices in order of their distance from the source and to its implementation as the optimal algorithm for the adjacency-matrix representation, because E. W. Dijkstra presented both in his 1959 paper (and also showed that the same approach could compute the MST). Performance improvements for sparse graphs are dependent on later improvements in priority-queue implementations that are not specific to the shortest-paths problem. Improved performance of Dijkstra’s algorithm is one of the most important applications of that technology (for example, with a data structure known as a <em>Fibonacci heap</em>, the worst-case bound can be reduced to <em>E + V</em> log <em>V</em>). The Bellman-Ford algorithm has proven to be useful in practice and has found wide application, particularly for general edge-weighted digraphs. While the running time of the Bellman-Ford algorithm is likely to be linear for typical applications, its worst-case running time is <em>VE</em>. The development of a worst-case linear-time shortest-paths algorithm for sparse graphs remains an open problem. The basic Bellman-Ford algorithm <a id="page_683"/>was developed in the 1950s by L. Ford and R. Bellman; despite the dramatic strides in performance that we have seen for many other graph problems, we have not yet seen algorithms with better worst-case performance for digraphs with negative edge weights (but no negative cycles).</p>
<p><a id="ch04sec2lev43"/></p>
<h4><a id="page_684"/>Q&amp;A</h4>
<p><strong>Q.</strong> Why define separate data types for undirected graphs, directed graphs, edge-weighted undirected graphs, and edge-weighted digraphs?</p>
<p><strong>A.</strong> We do so both for clarity in client code and for simpler and more efficient implementation code in unweighted graphs. In applications or systems where all types of graphs are to be processed, it is a textbook exercise in software engineering to define an ADT from which ADTs can be derived for <code>Graph</code>, the unweighted undirected graphs of <a href="ch04.html#ch04sec1lev10"><small>SECTION 4.1</small></a>; <code>Digraph</code>, the unweighted digraphs of <a href="ch04.html#ch04sec1lev11"><small>SECTION 4.2</small></a>; <code>EdgeWeightedGraph</code>, the edge-weighted undirected graphs of <a href="ch04.html#ch04sec1lev12"><small>SECTION 4.3</small></a>; or <code>EdgeWeightedDigraph</code>, the edge-weighted directed graphs of this section.</p>
<p><strong>Q.</strong> How can we find shortest paths in undirected (edge-weighted) graphs?</p>
<p><strong>A.</strong> For positive edge weights, Dijkstra’s algorithm does the job. We just build an <code>EdgeWeightedDigraph</code> corresponding to the given <code>EdgeWeightedGraph</code> (by adding two directed edges corresponding to each undirected edge, one in each direction) and then run Dijkstra’s algorithm. If edge weights can be negative, efficient algorithms are available, but they are more complicated than the Bellman-Ford algorithm.</p>
<p><a id="ch04sec2lev44"/></p>
<h4><a id="page_685"/>Exercises</h4>
<p><a id="ch04qa4q1"/><strong>4.4.1</strong> True or false: Adding a constant to every edge weight does not change the solution to the single-source shortest-paths problem.</p>
<p><a id="ch04qa4q2"/><strong>4.4.2</strong> Provide an implementation of <code>toString()</code> for <code>EdgeWeightedDigraph</code>.</p>
<p><a id="ch04qa4q3"/><strong>4.4.3</strong> Develop an implementation of <code>EdgeWeightedDigraph</code> for dense graphs that uses an adjacency-matrix (two-dimensional array of weights) representation (see <a href="ch04.html#ch04qa3q9"><small>EXERCISE 4.3.9</small></a>). Ignore parallel edges.</p>
<p><a id="ch04qa4q4"/><strong>4.4.4</strong> Draw the SPT for source <code>0</code> of the edge-weighted digraph obtained by deleting vertex <code>7</code> from <code>tinyEWD.txt</code> (see page <a href="#page_644">644</a>), and give the parent-link representation of the SPT. Answer the question for the same graph with all edge reversed.</p>
<p><a id="ch04qa4q5"/><strong>4.4.5</strong> Change the direction of edge <code>0-&gt;2</code> in <code>tinyEWD.txt</code> (see page <a href="#page_644">644</a>). Draw two different SPTs that are rooted at <code>2</code> for this modified edge-weighted digraph.</p>
<p><a id="ch04qa4q6"/><strong>4.4.6</strong> Give a trace that shows the process of computing the SPT of the digraph defined in <a href="#ch04qa4q5"><small>EXERCISE 4.4.5</small></a> with the eager version of Dijkstra’s algorithm.</p>
<p><a id="ch04qa4q7"/><strong>4.4.7</strong> Develop a version of <code>DijkstraSP</code> that supports a client method that returns a <em>second</em> shortest path from <code>s</code> to <code>t</code> in an edge-weighted digraph (and returns <code>null</code> if there is only one shortest path from <code>s</code> to <code>t</code>).</p>
<p><a id="ch04qa4q8"/><strong>4.4.8</strong> The <em>diameter</em> of a digraph is the length of the maximum-length shortest path connecting two vertices. Write a <code>DijkstraSP</code> client that finds the diameter of a given <code>EdgeWeightedDigraph</code> that has nonnegative weights.</p>
<p><a id="ch04qa4q9"/><strong>4.4.9</strong> The table below, from an old published road map, purports to give the length of the shortest routes connecting the cities. It contains an error. Correct the table. Also, add a table that shows how to achieve the shortest routes.</p>
<p class="image"><img alt="image" src="graphics/t0685-01.jpg"/></p>
<p><a id="page_686"/><a id="ch04qa4q10"/><strong>4.4.10</strong> Consider the edges in the digraph defined in <a href="#ch04qa4q4"><small>EXERCISE 4.4.4</small></a> to be undirected edges such that each edge corresponds to equal-weight edges in both directions in the edge-weighted digraph. Answer <a href="#ch04qa4q6"><small>EXERCISE 4.4.6</small></a> for this corresponding edge-weighted digraph.</p>
<p><a id="ch04qa4q11"/><strong>4.4.11</strong> Use the memory-cost model of <a href="ch01a.html#ch01sec1lev6"><small>SECTION 1.4</small></a> to determine the amount of memory used by <code>EdgeWeightedDigraph</code> to represent a graph with <em>V</em> vertices and <em>E</em> edges,.</p>
<p><a id="ch04qa4q12"/><strong>4.4.12</strong> Adapt the <code>DirectedCycle</code> and <code>Topological</code> classes from <a href="ch04.html#ch04sec1lev11"><small>SECTION 4.2</small></a> to use the <code>EdgeweightedDigraph</code> and <code>DirectedEdge</code> APIs of this section, thus implementing <code>EdgeWeightedDirectedCycle</code> and <code>Topological</code> classes.</p>
<p><a id="ch04qa4q13"/><strong>4.4.13</strong> Show, in the style of the trace in the text, the process of computing the SPT with Dijkstra’s algorithm for the digraph obtained by removing the edge <code>5-&gt;7</code> from <code>tinyEWD.txt</code> (see page <a href="#page_644">644</a>).</p>
<p><a id="ch04qa4q14"/><strong>4.4.14</strong> Show the paths that would be discovered by the two strawman approaches described on page <a href="#page_668">668</a> for the example <code>tinyEWDn.txt</code> shown on that page.</p>
<p><a id="ch04qa4q15"/><strong>4.4.15</strong> What happens to Bellman-Ford if there is a negative cycle on the path from <code>s</code> to <code>v</code> and then you call <code>pathTo(v)</code>?</p>
<p><a id="ch04qa4q16"/><strong>4.4.16</strong> Suppose that we convert an <code>EdgeWeightedGraph</code> into an <code>EdgeWeightedDigraph</code> by creating two <code>DirectedEdge</code> objects in the <code>EdgeWeightedDigraph</code> (one in each direction) for each <code>Edge</code> in the <code>EdgeWeightedGraph</code> (as described for Dijkstra’s algorithm in the <a href="#ch04sec2lev43">Q&amp;A</a> on page <a href="#ch04sec2lev43">684</a>) and then use the Bellman-Ford algorithm. Explain why this approach fails spectacularly.</p>
<p><a id="ch04qa4q17"/><strong>4.4.17</strong> What happens if you allow a vertex to be enqueued more than once in the same pass in the Bellman-Ford algorithm?</p>
<p><em>Answer</em>: The running time of the algorithm can go exponential. For example, consider what happens for the complete edge-weighted digraph whose edge weights are all <code>-1</code>.</p>
<p><a id="ch04qa4q18"/><strong>4.4.18</strong> Write a <code>CPM</code> client that prints all critical paths.</p>
<p><a id="ch04qa4q19"/><strong>4.4.19</strong> Find the lowest-weight cycle (best arbitrage opportunity) in the example shown in the text.</p>
<p><a id="page_687"/><a id="ch04qa4q20"/><strong>4.4.20</strong> Find a currency-conversion table online or in a newspaper. Use it to build an arbitrage table. <em>Note</em>: Avoid tables that are derived (calculated) from a few values and that therefore do not give sufficiently accurate conversion information to be interesting. <em>Extra credit</em>: Make a killing in the money-exchange market!</p>
<p><a id="ch04qa4q21"/><strong>4.4.21</strong> Show, in the style of the trace in the text, the process of computing the SPT with the Bellman-Ford algorithm for the edge-weighted digraph of <a href="#ch04qa4q5"><small>EXERCISE 4.4.5</small></a>.</p>
<p><a id="ch04sec2lev45"/></p>
<h4><a id="page_688"/>Creative Problems</h4>
<p><a id="ch04qa4q22"/><strong>4.4.22</strong> <em>Vertex weights.</em> Show that shortest-paths computations in edge-weighted digraphs with nonnegative weights on vertices (where the weight of a path is defined to be the sum of the weights of the vertices) can be handled by building an edge-weighted digraph that has weights on only the edges.</p>
<p><a id="ch04qa4q23"/><strong>4.4.23</strong> <em>Source-sink shortest paths.</em> Develop an API and implementation that use a version of Dijkstra’s algorithm to solve the <em>source-sink</em> shortest path problem on edge-weighted digraphs.</p>
<p><a id="ch04qa4q24"/><strong>4.4.24</strong> <em>Multisource shortest paths.</em> Develop an API and implementation that uses Dijkstra’s algorithm to solve the <em>multisource</em> shortest-paths problem on edge-weighted digraphs with positive edge weights: given a <em>set</em> of sources, find a shortest-paths forest that enables implementation of a method that returns to clients the shortest path from any source to each vertex. <em>Hint</em>: Add a dummy vertex with a zero-weight edge to each source, or initialize the priority queue with all sources, with their <code>distTo[]</code> entries set to 0.</p>
<p><a id="ch04qa4q25"/><strong>4.4.25</strong> <em>Shortest path between two subsets.</em> Given a digraph with positive edge weights, and two distinguished subsets of vertices <em>S</em> and <em>T</em>, find a shortest path from any vertex in <em>S</em> to any vertex in <em>T</em>. Your algorithm should run in time proportional to <em>E</em> log <em>V</em>, in the worst case.</p>
<p><a id="ch04qa4q26"/><strong>4.4.26</strong> <em>Single-source shortest paths in dense graphs.</em> Develop a version of Dijkstra’s algorithm that can find the SPT from a given vertex in a dense edge-weighted digraph in time proportional to <em>V</em><sup>2</sup>. Use an adjacency-matrix representation (see <a href="#ch04qa4q3"><small>EXERCISE 4.4.3</small></a> and <a href="ch04.html#ch04qa3q29"><small>EXERCISE 4.3.29</small></a>).</p>
<p><a id="ch04qa4q27"/><strong>4.4.27</strong> <em>Shortest paths in Euclidean graphs.</em> Adapt our APIs to speed up Dijkstra’s algorithm in the case where it is known that vertices are points in the plane.</p>
<p><a id="ch04qa4q28"/><strong>4.4.28</strong> <em>Longest paths in DAGs.</em> Develop an implementation <code>AcyclicLP</code> that can solve the <em>longest</em>-paths problem in edge-weighted DAGs, as described in <a href="#ch04sb59"><small>PROPOSITION T</small></a>.</p>
<p><a id="ch04qa4q29"/><strong>4.4.29</strong> <em>General optimality.</em> Complete the proof of <a href="#ch04sb65"><small>PROPOSITION W</small></a> by showing that if there exists a directed path from <code>s</code> to <code>v</code> and no vertex on any path from <code>s</code> to <code>v</code> is on a negative cycle, then there exists a shortest path from <code>s</code> to <code>v</code> (<em>Hint</em>: See <a href="#ch04sb52"><small>PROPOSITION P</small></a>.)</p>
<p><a id="ch04qa4q30"/><strong>4.4.30</strong> <em>All-pairs shortest paths in diagraphs with negative cycles.</em> Articulate an API like the one implemented on page <a href="#page_656">656</a> for the all-pairs shortest-paths problem in graphs with no <a id="page_689"/>negative cycles. Develop an implementation that runs a version of Bellman-Ford to identify weights <code>pi[v]</code> such that for any edge <code>v-&gt;w</code>, the edge weight plus the difference between <code>pi[v]</code> and <code>pi[w]</code> is nonnegative. Then use these weights to reweight the graph, so that Dijkstra’s algorithm is effective for finding all shortest paths in the reweighted graph.</p>
<p><a id="ch04qa4q31"/><strong>4.4.31</strong> <em>All-pairs shortest paths on a line.</em> Given a weighted line graph (undirected connected graph, all vertices of degree 2, except two endpoints which have degree 1), devise an algorithm that preprocesses the graph in linear time and can return the distance of the shortest path between any two vertices in constant time.</p>
<p><a id="ch04qa4q32"/><strong>4.4.32</strong> <em>Parent-checking heuristic.</em> Modify Bellman-Ford to visit a vertex <code>v</code> only if its SPT parent <code>edgeTo[v]</code> is not currently on the queue. This heuristic has been reported by Cherkassky, Goldberg, and Radzik to be useful in practice. Prove that it correctly computes shortest paths and that the worst-case running time is proportional to <em>EV</em>.</p>
<p><a id="ch04qa4q33"/><strong>4.4.33</strong> <em>Shortest path in a grid.</em> Given an <em>N</em>-by-<em>N</em> matrix of positive integers, find the shortest path from the (0, 0) entry to the (<em>N</em>−1, <em>N</em>−1) entry, where the length of the path is the sum of the integers in the path. Repeat the problem but assume you can only move right and down.</p>
<p><a id="ch04qa4q34"/><strong>4.4.34</strong> <em>Monotonic shortest path.</em> Given n edge-weighted digraph, find a <em>monotonic</em> shortest path from <code>s</code> to every other vertex. A path is monotonic if the weight of every edge on the path is either strictly increasing or strictly decreasing. <em>Hint</em>: Relax edges in ascending order and find a best path; then relax edges in descending order and find a best path.</p>
<p><a id="ch04qa4q35"/><strong>4.4.35</strong> <em>Bitonic shortest path.</em> Given an edge-weighted digraph, find a <em>bitonic</em> shortest path from <code>s</code> to every other vertex (if one exists). A path is bitonic if there is an intermediate vertex <code>v</code> such that the weighs of the edges on the path from <code>s</code> to <code>v</code> are strictly increasing and the weights of the edges on the path from <code>v</code> to <code>t</code> are strictly decreasing. The path should be simple (no repeated vertices).</p>
<p><a id="ch04qa4q36"/><strong>4.4.36</strong> <em>Neighbors.</em> Develop an <code>SP</code> client that finds all vertices within a given distance <em>d</em> of a given vertex in a given edge-weighted digraph. The running time of your method should be proportional to the size of the subgraph induced by those vertices and the vertices incident on them, or <em>V</em> (to initialize data structures), whichever is larger.</p>
<p><a id="page_690"/><a id="ch04qa4q37"/><strong>4.4.37</strong> <em>Critical edges.</em> Develop an algorithm for finding an edge whose removal causes maximal increase in the shortest-paths length from one given vertex to another given vertex in a given edge-weighted digraph.</p>
<p><a id="ch04qa4q38"/><strong>4.4.38</strong> <em>Sensitivity.</em> Develop an <code>SP</code> client that performs a sensitivity analysis on the edge-weighted digraph’s edges with respect to a given pair of vertices <code>s</code> and <code>t</code>: Compute a <em>V</em>-by-<em>V</em> boolean matrix such that, for every <code>v</code> and <code>w</code>, the entry in row <code>v</code> and column <code>w</code> is <code>true</code> if <code>v-&gt;w</code> is an edge in the edge-weighted digraphs whose weight can be increased without the shortest-path length from <code>v</code> to <code>w</code> being increased and is <code>false</code> otherwise.</p>
<p><a id="ch04qa4q39"/><strong>4.4.39</strong> <em>Lazy implementation of Dijkstra’s algorithm.</em> Develop an implementation of the lazy version of Dijkstra’s algorithm that is described in the text.</p>
<p><a id="ch04qa4q40"/><strong>4.4.40</strong> <em>Bottleneck SPT.</em> Show that an MST of an undirected graph is equivalent to a bottleneck SPT of the graph: For every pair of vertices <code>v</code> and <code>w</code>, it gives the path connecting them whose longest edge is as short as possible.</p>
<p><a id="ch04qa4q41"/><strong>4.4.41</strong> <em>Bidirectional search.</em> Develop a class for the source-sink shortest-paths problem that is based on code like <a href="#ch04sb56"><small>ALGORITHM 4.9</small></a> but that initializes the priority queue with both the source and the sink. Doing so leads to the growth of an SPT from each vertex; your main task is to decide precisely what to do when the two SPTs collide.</p>
<p><a id="ch04qa4q42"/><strong>4.4.42</strong> <em>Worst case (Dijkstra).</em> Describe a family of graphs with <em>V</em> vertices and <em>E</em> edges for which the worst-case running time of Dijkstra’s algorithm is achieved.</p>
<p><a id="ch04qa4q43"/><strong>4.4.43</strong> <em>Negative cycle detection.</em> Suppose that we add a constructor to <a href="#ch04sb69"><small>ALGORITHM 4.11</small></a> that differs from the constructor given only in that it omits the second argument and that it initializes all <code>distTo[]</code> entries to 0. Show that, if a client uses that constructor, a client call to <code>hasNegativeCycle()</code> returns <code>true</code> if and only if the graph has a negative cycle (and <code>negativeCycle()</code> returns that cycle).</p>
<p><em>Answer</em>: Consider a digraph formed from the original by adding a new source with an edge of weight 0 to all the other vertices. After one pass, all <code>distTo[]</code> entries are 0, and finding a negative cycle reachable from that source is the same as finding a negative cycle anywhere in the original graph.</p>
<p><a id="ch04qa4q44"/><strong>4.4.44</strong> <em>Worst case (Bellman-Ford)</em>. Describe a family of graphs for which <a href="#ch04sb69"><small>ALGORITHM 4.11</small></a> takes time proportional to <em>VE</em>.</p>
<p><a id="page_691"/><a id="ch04qa4q45"/><strong>4.4.45</strong> <em>Fast Bellman-Ford.</em> Develop an algorithm that breaks the linearithmic running time barrier for the single-source shortest-paths problem in general edge-weighted digraphs for the special case where the weights are integers known to be bounded in absolute value by a constant.</p>
<p><a id="ch04qa4q46"/><strong>4.4.46</strong> <em>Animate.</em> Write a client program that does dynamic graphical animations of Dijkstra’s algorithm.</p>
<p><a id="ch04sec2lev46"/></p>
<h4><a id="page_692"/>Experiments</h4>
<p><a id="ch04qa4q47"/><strong>4.4.47</strong> <em>Random sparse edge-weighted digraphs.</em> Modify your solution to <a href="ch04.html#ch04qa3q34"><small>EXERCISE 4.3.34</small></a> to assign a random direction to each edge.</p>
<p><a id="ch04qa4q48"/><strong>4.4.48</strong> <em>Random Euclidean edge-weighted digraphs.</em> Modify your solution to <a href="ch04.html#ch04qa3q35"><small>EXERCISE 4.3.35</small></a> to assign a random direction to each edge.</p>
<p><a id="ch04qa4q49"/><strong>4.4.49</strong> <em>Random grid edge-weighted digraphs.</em> Modify your solution to <a href="ch04.html#ch04qa3q36"><small>EXERCISE 4.3.36</small></a> to assign a random direction to each edge.</p>
<p><a id="ch04qa4q50"/><strong>4.4.50</strong> <em>Negative weights I.</em> Modify your random edge-weighted digraph generators to generate weights between <em>x</em> and <em>y</em> (where <em>x</em> and <em>y</em> are both between −1 and 1) by rescaling.</p>
<p><a id="ch04qa4q51"/><strong>4.4.51</strong> <em>Negative weights II</em>. Modify your random edge-weighted digraph generators to generate negative weights by negating a fixed percentage (whose value is supplied by the client) of the edge weights.</p>
<p><a id="ch04qa4q52"/><strong>4.4.52</strong> <em>Negative weights III.</em> Develop client programs that use your edge-weighted digraph to produce edge-weighted digraphs that have a large percentage of negative weights but have at most a few negative cycles, for as large a range of values of <em>V</em> and <em>E</em> as possible.</p>
<p><a id="page_693"/><em>Testing all algorithms and studying all parameters against all edge-weighted digraph models is unrealistic. For each problem listed below, write a client that addresses the problem for any given input digraph, then choose among the generators above to run experiments for that graph model. Use your judgment in selecting experiments, perhaps in response to results of previous experiments. Write a narrative explaining your results and any conclusions that might be drawn.</em></p>
<p><a id="ch04qa4q53"/><strong>4.4.53</strong> <em>Prediction.</em> Estimate, to within a factor of 10, the largest graph with <em>E</em> = 10<em>V</em> that your computer and programming system could handle if you were to use Dijkstra’s algorithm to compute all its shortest paths in 10 seconds.</p>
<p><a id="ch04qa4q54"/><strong>4.4.54</strong> <em>Cost of laziness.</em> Run empirical studies to compare the performance of the lazy version of Dijkstra’s algorithm with the eager version, for various edge-weighted digraph models.</p>
<p><a id="ch04qa4q55"/><strong>4.4.55</strong> <em>Johnson’s algorithm.</em> Develop a priority-queue implementation that uses a <em>d</em>-way heap. Find the best value of <em>d</em> for various edge-weighted digraph models.</p>
<p><a id="ch04qa4q56"/><strong>4.4.56</strong> <em>Arbitrage model.</em> Develop a model for generating random arbitrage problems. Your goal is to generate tables that are as similar as possible to the tables that you used in <a href="#ch04qa4q20"><small>EXERCISE 4.4.20</small></a>.</p>
<p><a id="ch04qa4q57"/><strong>4.4.57</strong> <em>Parallel job-scheduling-with-deadlines model.</em> Develop a model for generating random instances of the parallel job-scheduling-with-deadlines problem. Your goal is to generate nontrivial problems that are likely to be feasible.</p>
</body>
</html>