<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p331"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="13 Red-Black Trees">
<p class="chapter-title"><a href="toc.xhtml#chap-13"><strong><span class="blue1">13        Red-Black Trees</span></strong></a></p>
<p class="noindent"><a href="chapter012.xhtml">Chapter 12</a> showed that a binary search tree of height <em>h</em> can support any of the basic dynamic-set operations—such as S<small>EARCH</small>, P<small>REDECESSOR</small>, S<small>UCCESSOR</small>, M<small>INIMUM</small>, M<small>AXIMUM</small>, I<small>NSERT</small>, and D<small>ELETE</small>—in <em>O</em>(<em>h</em>) time. Thus, the set operations are fast if the height of the search tree is small. If its height is large, however, the set operations may run no faster than with a linked list. Red-black trees are one of many search-tree schemes that are “balanced” in order to guarantee that basic dynamic-set operations take <em>O</em>(lg <em>n</em>) time in the worst case.</p>
<p class="line1"/>
<section title="13.1 Properties of red-black trees">
<a id="Sec_13.1"/>
<p class="level1" id="h1-74"><a href="toc.xhtml#Rh1-74"><strong>13.1    Properties of red-black trees</strong></a></p>
<p class="noindent">A <strong><em><span class="blue1">red-black tree</span></em></strong> is a binary search tree with one extra bit of storage per node: its <strong><em><span class="blue1">color</span></em></strong>, which can be either <small>RED</small> or <small>BLACK</small>. By constraining the node colors on any simple path from the root to a leaf, red-black trees ensure that no such path is more than twice as long as any other, so that the tree is approximately <strong><em><span class="blue1">balanced</span></em></strong>. Indeed, as we’re about to see, the height of a red-black tree with <em>n</em> keys is at most 2 lg(<em>n</em> + 1), which is <em>O</em>(lg <em>n</em>).</p>
<p>Each node of the tree now contains the attributes <em>color</em>, <em>key</em>, <em>left</em>, <em>right</em>, and <em>p</em>. If a child or the parent of a node does not exist, the corresponding pointer attribute of the node contains the value <small>NIL</small>. Think of these <small>NIL</small>s as pointers to leaves (external nodes) of the binary search tree and the normal, key-bearing nodes as internal nodes of the tree.</p>
<p>A red-black tree is a binary search tree that satisfies the following <strong><em><span class="blue1">red-black properties</span></em></strong>:</p>
<ol class="olnoindent" epub:type="list">
<li>Every node is either red or black.</li>
<li class="litop">The root is black.</li>
<li class="litop">Every leaf (<small>NIL</small>) is black.<a id="p332"/></li>
<li class="litop">If a node is red, then both its children are black.</li>
<li class="litop">For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</li></ol>
<p class="noindent"><a href="chapter013.xhtml#Fig_13-1">Figure 13.1(a)</a> shows an example of a red-black tree.</p>
<p>As a matter of convenience in dealing with boundary conditions in red-black tree code, we use a single sentinel to represent <small>NIL</small> (see page 262). For a red-black tree <em>T</em>, the sentinel <em>T.nil</em> is an object with the same attributes as an ordinary node in the tree. Its <em>color</em> attribute is <small>BLACK</small>, and its other attributes—<em>p</em>, <em>left</em>, <em>right</em>, and <em>key</em>—can take on arbitrary values. As <a href="chapter013.xhtml#Fig_13-1">Figure 13.1(b)</a> shows, all pointers to <small>NIL</small> are replaced by pointers to the sentinel <em>T.nil</em>.</p>
<p>Why use the sentinel? The sentinel makes it possible to treat a <small>NIL</small> child of a node <em>x</em> as an ordinary node whose parent is <em>x</em>. An alternative design would use a distinct sentinel node for each <small>NIL</small> in the tree, so that the parent of each <small>NIL</small> is well defined. That approach needlessly wastes space, however. Instead, just the one sentinel <em>T.nil</em> represents all the <small>NIL</small>s—all leaves and the root’s parent. The values of the attributes <em>p</em>, <em>left</em>, <em>right</em>, and <em>key</em> of the sentinel are immaterial. The red-black tree procedures can place whatever values in the sentinel that yield simpler code.</p>
<p>We generally confine our interest to the internal nodes of a red-black tree, since they hold the key values. The remainder of this chapter omits the leaves in drawings of red-black trees, as shown in <a href="chapter013.xhtml#Fig_13-1">Figure 13.1(c)</a>.</p>
<p>We call the number of black nodes on any simple path from, but not including, a node <em>x</em> down to a leaf the <strong><em><span class="blue1">black-height</span></em></strong> of the node, denoted bh(<em>x</em>). By property 5, the notion of black-height is well defined, since all descending simple paths from the node have the same number of black nodes. The black-height of a red-black tree is the black-height of its root.</p>
<p>The following lemma shows why red-black trees make good search trees.</p>
<p class="lem"><strong><em>Lemma 13.1</em></strong></p>
<p class="noindent">A red-black tree with <em>n</em> internal nodes has height at most 2 lg(<em>n</em> + 1).</p>
<p class="proof"><strong><em>Proof</em></strong>   We start by showing that the subtree rooted at any node <em>x</em> contains at least 2<sup>bh(<em>x</em>)</sup> − 1 internal nodes. We prove this claim by induction on the height of <em>x</em>. If the height of <em>x</em> is 0, then <em>x</em> must be a leaf (<em>T.nil</em>), and the subtree rooted at <em>x</em> indeed contains at least 2<sup>bh(<em>x</em>)</sup> − 1 = 2<sup>0</sup> − 1 = 0 internal nodes. For the inductive step, consider a node <em>x</em> that has positive height and is an internal node. Then node <em>x</em> has two children, either or both of which may be a leaf. If a child is black, then it contributes 1 to <em>x</em>’s black-height but not to its own. If a child is red, then it contributes to neither <em>x</em>’s black-height nor its own. Therefore, each child has a black-height of either bh(<em>x</em>) − 1 (if it’s black) or bh(<em>x</em>) (if it’s red). Since the height of a child of <em>x</em> is less than the height of <em>x</em> itself, we can apply the inductive <a id="p333"/>hypothesis to conclude that each child has at least 2<sup>bh(<em>x</em>)−1</sup> − 1 internal nodes. Thus, the subtree rooted at <em>x</em> contains at least (2<sup>bh(<em>x</em>)−1</sup> − 1) + (2<sup>bh(<em>x</em>)−1</sup> − 1) + 1 = 2<sup>bh(<em>x</em>)</sup> − 1 internal nodes, which proves the claim.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_13-1"><img alt="art" class="width80" src="images/Art_P432.jpg"/></p>
<p class="caption"><strong>Figure 13.1</strong> A red-black tree. Every node in a red-black tree is either red or black, the children of a red node are both black, and every simple path from a node to a descendant leaf contains the same number of black nodes. <strong>(a)</strong> Every leaf, shown as a <small>NIL</small>, is black. Each non-<small>NIL</small> node is marked with its black-height, where <small>NIL</small>s have black-height 0. <strong>(b)</strong> The same red-black tree but with each <small>NIL</small> replaced by the single sentinel <em>T.nil</em>, which is always black, and with black-heights omitted. The root’s parent is also the sentinel. <strong>(c)</strong> The same red-black tree but with leaves and the root’s parent omitted entirely. The remainder of this chapter uses this drawing style.</p>
</div>
<a id="p334"/>
<p>To complete the proof of the lemma, let <em>h</em> be the height of the tree. According to property 4, at least half the nodes on any simple path from the root to a leaf, not including the root, must be black. Consequently, the black-height of the root must be at least <em>h</em>/2, and thus,</p>
<p class="eql"><em>n</em> ≥ 2<sup><em>h</em>/2</sup> − 1.</p>
<p class="noindent">Moving the 1 to the left-hand side and taking logarithms on both sides yields lg(<em>n</em> + 1) ≥ <em>h</em>/2, or <em>h</em> ≤ 2 lg(<em>n</em> + 1).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">As an immediate consequence of this lemma, each of the dynamic-set operations S<small>EARCH</small>, M<small>INIMUM</small>, M<small>AXIMUM</small>, S<small>UCCESSOR</small>, and P<small>REDECESSOR</small> runs in <em>O</em>(lg <em>n</em>) time on a red-black tree, since each can run in <em>O</em>(<em>h</em>) time on a binary search tree of height <em>h</em> (as shown in <a href="chapter012.xhtml">Chapter 12</a>) and any red-black tree on <em>n</em> nodes is a binary search tree with height <em>O</em>(lg <em>n</em>). (Of course, references to <small>NIL</small> in the algorithms of <a href="chapter012.xhtml">Chapter 12</a> have to be replaced by <em>T.nil</em>.) Although the procedures T<small>REE</small>-I<small>NSERT</small> and T<small>REE</small>-D<small>ELETE</small> from <a href="chapter012.xhtml">Chapter 12</a> run in <em>O</em>(lg <em>n</em>) time when given a red-black tree as input, you cannot just use them to implement the dynamic-set operations I<small>NSERT</small> and D<small>ELETE</small>. They do not necessarily maintain the red-black properties, so you might not end up with a legal red-black tree. The remainder of this chapter shows how to insert into and delete from a red-black tree in <em>O</em>(lg <em>n</em>) time.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>13.1-1</em></strong></p>
<p class="noindent">In the style of <a href="chapter013.xhtml#Fig_13-1">Figure 13.1(a)</a>, draw the complete binary search tree of height 3 on the keys {1, 2, …, 15}. Add the <small>NIL</small> leaves and color the nodes in three different ways such that the black-heights of the resulting red-black trees are 2, 3, and 4.</p>
<p class="level3"><strong><em>13.1-2</em></strong></p>
<p class="noindent">Draw the red-black tree that results after T<small>REE</small>-I<small>NSERT</small> is called on the tree in <a href="chapter013.xhtml#Fig_13-1">Figure 13.1</a> with key 36. If the inserted node is colored red, is the resulting tree a red-black tree? What if it is colored black?</p>
<p class="level3"><strong><em>13.1-3</em></strong></p>
<p class="noindent">Define a <strong><em><span class="blue1">relaxed red-black tree</span></em></strong> as a binary search tree that satisfies red-black properties 1, 3, 4, and 5, but whose root may be either red or black. Consider a relaxed red-black tree <em>T</em> whose root is red. If the root of <em>T</em> is changed to black but no other changes occur, is the resulting tree a red-black tree?</p>
<a id="p335"/>
<p class="level3"><strong><em>13.1-4</em></strong></p>
<p class="noindent">Suppose that every black node in a red-black tree “absorbs” all of its red children, so that the children of any red node become children of the black parent. (Ignore what happens to the keys.) What are the possible degrees of a black node after all its red children are absorbed? What can you say about the depths of the leaves of the resulting tree?</p>
<p class="level3"><strong><em>13.1-5</em></strong></p>
<p class="noindent">Show that the longest simple path from a node <em>x</em> in a red-black tree to a descendant leaf has length at most twice that of the shortest simple path from node <em>x</em> to a descendant leaf.</p>
<p class="level3"><strong><em>13.1-6</em></strong></p>
<p class="noindent">What is the largest possible number of internal nodes in a red-black tree with black-height <em>k</em>? What is the smallest possible number?</p>
<p class="level3"><strong><em>13.1-7</em></strong></p>
<p class="noindent">Describe a red-black tree on <em>n</em> keys that realizes the largest possible ratio of red internal nodes to black internal nodes. What is this ratio? What tree has the smallest possible ratio, and what is the ratio?</p>
<p class="level3"><strong><em>13.1-8</em></strong></p>
<p class="noindent">Argue that in a red-black tree, a red node cannot have exactly one non-<small>NIL</small> child.</p>
</section>
<p class="line1"/>
<section title="13.2 Rotations">
<a id="Sec_13.2"/>
<p class="level1" id="h1-75"><a href="toc.xhtml#Rh1-75"><strong>13.2    Rotations</strong></a></p>
<p class="noindent">The search-tree operations T<small>REE</small>-I<small>NSERT</small> and T<small>REE</small>-D<small>ELETE</small>, when run on a red-black tree with <em>n</em> keys, take <em>O</em>(lg <em>n</em>) time. Because they modify the tree, the result may violate the red-black properties enumerated in <a href="chapter013.xhtml#Sec_13.1">Section 13.1</a>. To restore these properties, colors and pointers within nodes need to change.</p>
<p>The pointer structure changes through <strong><em><span class="blue1">rotation</span></em></strong>, which is a local operation in a search tree that preserves the binary-search-tree property. <a href="chapter013.xhtml#Fig_13-2">Figure 13.2</a> shows the two kinds of rotations: left rotations and right rotations. Let’s look at a left rotation on a node <em>x</em>, which transforms the structure on the right side of the figure to the structure on the left. Node <em>x</em> has a right child <em>y</em>, which must not be <em>T.nil</em>. The left rotation changes the subtree originally rooted at <em>x</em> by “twisting” the link between <em>x</em> and <em>y</em> to the left. The new root of the subtree is node <em>y</em>, with <em>x</em> as <em>y</em>’s left child and <em>y</em>’s original left child (the subtree represented by <em>β</em> in the figure) as <em>x</em>’s right child.</p>
<p>The pseudocode for L<small>EFT</small>-R<small>OTATE</small> appearing on the following page assumes that <em>x.right</em> ≠ <em>T.nil</em> and that the root’s parent is <em>T.nil</em>. <a href="chapter013.xhtml#Fig_13-3">Figure 13.3</a> shows an <a id="p336"/>example of how L<small>EFT</small>-R<small>OTATE</small> modifies a binary search tree. The code for R<small>IGHT</small>-R<small>OTATE</small> is symmetric. Both L<small>EFT</small>-R<small>OTATE</small> and R<small>IGHT</small>-R<small>OTATE</small> run in <em>O</em>(1) time. Only pointers are changed by a rotation, and all other attributes in a node remain the same.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_13-2"><img alt="art" src="images/Art_P433.jpg"/></p>
<p class="caption"><strong>Figure 13.2</strong> The rotation operations on a binary search tree. The operation L<small>EFT</small>-R<small>OTATE</small>(<em>T</em>, <em>x</em>) transforms the configuration of the two nodes on the right into the configuration on the left by changing a constant number of pointers. The inverse operation R<small>IGHT</small>-R<small>OTATE</small>(<em>T</em>, <em>y</em>) transforms the configuration on the left into the configuration on the right. The letters <em>α</em>, <em>β</em>, and <em>γ</em> represent arbitrary subtrees. A rotation operation preserves the binary-search-tree property: the keys in <em>α</em> precede <em>x.key</em>, which precedes the keys in <em>β</em>, which precede <em>y.key</em>, which precedes the keys in <em>γ</em>.</p>
</div>
<div class="pull-quote1">
<p class="box-heading">L<small>EFT</small>-R<small>OTATE</small>(<em>T</em>, <em>x</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><em>y</em> = <em>x.right</em></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><em>x.right</em> = <em>y.left</em></td>
<td class="td1"><span class="red"><strong>//</strong> turn <em>y</em>’s left subtree into <em>x</em>’s right subtree</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><strong>if</strong> <em>y.left</em> ≠ <em>T.nil</em></td>
<td class="td1"><span class="red"><strong>//</strong> if <em>y</em>’s left subtree is not empty …</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2"><em>y.left.p</em> = <em>x</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> … then <em>x</em> becomes the parent of the subtree’s root</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><em>y.p</em> = <em>x.p</em></td>
<td class="td1"><span class="red"><strong>//</strong> <em>x</em>’s parent becomes <em>y</em>’s parent</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><strong>if</strong> <em>x.p</em> == <em>T.nil</em></td>
<td class="td1"><span class="red"><strong>//</strong> if <em>x</em> was the root …</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p2"><em>T.root</em> = <em>y</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> … then <em>y</em> becomes the root</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><strong>elseif</strong> <em>x</em> == <em>x.p.left</em></td>
<td class="td1"><span class="red"><strong>//</strong> otherwise, if <em>x</em> was a left child …</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="p2"><em>x.p.left</em> = <em>y</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> … then <em>y</em> becomes a left child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><strong>else</strong> <em>x.p.right</em> = <em>y</em></td>
<td class="td1"><span class="red"><strong>//</strong> otherwise, <em>x</em> was a right child, and now <em>y</em> is</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><em>y.left</em> = <em>x</em></td>
<td class="td1"><span class="red"><strong>//</strong> make <em>x</em> become <em>y</em>’s left child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1"><em>x.p</em> = <em>y</em></td>
<td class="td1"/>
</tr>
</table>
</div>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>13.2-1</em></strong></p>
<p class="noindent">Write pseudocode for R<small>IGHT</small>-R<small>OTATE</small>.</p>
<a id="p337"/>
<div class="divimage">
<p class="fig-imga" id="Fig_13-3"><img alt="art" src="images/Art_P434.jpg"/></p>
<p class="caption"><strong>Figure 13.3</strong> An example of how the procedure L<small>EFT</small>-R<small>OTATE</small>(<em>T</em>, <em>x</em>) modifies a binary search tree. Inorder tree walks of the input tree and the modified tree produce the same listing of key values.</p>
</div>
<p class="level3"><strong><em>13.2-2</em></strong></p>
<p class="noindent">Argue that in every <em>n</em>-node binary search tree, there are exactly <em>n</em> − 1 possible rotations.</p>
<p class="level3"><strong><em>13.2-3</em></strong></p>
<p class="noindent">Let <em>a</em>, <em>b</em>, and <em>c</em> be arbitrary nodes in subtrees <em>α</em>, <em>β</em>, and <em>γ</em>, respectively, in the right tree of <a href="chapter013.xhtml#Fig_13-2">Figure 13.2</a>. How do the depths of <em>a</em>, <em>b</em>, and <em>c</em> change when a left rotation is performed on node <em>x</em> in the figure?</p>
<p class="level3"><strong><em>13.2-4</em></strong></p>
<p class="noindent">Show that any arbitrary <em>n</em>-node binary search tree can be transformed into any other arbitrary <em>n</em>-node binary search tree using <em>O</em>(<em>n</em>) rotations. (<em>Hint:</em> First show that at most <em>n</em> − 1 right rotations suffice to transform the tree into a right-going chain.)</p>
<p class="level3"><span class="font1">★</span> <strong><em>13.2-5</em></strong></p>
<p class="noindent">We say that a binary search tree <em>T</em><sub>1</sub> can be <strong><em><span class="blue1">right-converted</span></em></strong> to binary search tree <em>T</em><sub>2</sub> if it is possible to obtain <em>T</em><sub>2</sub> from <em>T</em><sub>1</sub> via a series of calls to R<small>IGHT</small>-R<small>OTATE</small>. Give an example of two trees <em>T</em><sub>1</sub> and <em>T</em><sub>2</sub> such that <em>T</em><sub>1</sub> cannot be right-converted to <em>T</em><sub>2</sub>. Then, show that if a tree <em>T</em><sub>1</sub> can be right-converted to <em>T</em><sub>2</sub>, it can be right-converted using <em>O</em>(<em>n</em><sup>2</sup>) calls to R<small>IGHT</small>-R<small>OTATE</small>.</p>
<a id="p338"/>
</section>
<p class="line1"/>
<section title="13.3 Insertion">
<a id="Sec_13.3"/>
<p class="level1" id="h1-76"><a href="toc.xhtml#Rh1-76"><strong>13.3    Insertion</strong></a></p>
<p class="noindent">In order to insert a node into a red-black tree with <em>n</em> internal nodes in <em>O</em>(lg <em>n</em>) time and maintain the red-black properties, we’ll need to slightly modify the T<small>REE</small>-I<small>NSERT</small> procedure on page 321. The procedure RB-I<small>NSERT</small> starts by inserting node <em>z</em> into the tree <em>T</em> as if it were an ordinary binary search tree, and then it colors <em>z</em> red. (Exercise 13.3-1 asks you to explain why to make node <em>z</em> red rather than black.) To guarantee that the red-black properties are preserved, an auxiliary procedure RB-I<small>NSERT</small>-F<small>IXUP</small> on the facing page recolors nodes and performs rotations. The call RB-I<small>NSERT</small>(<em>T</em>, <em>z</em>) inserts node <em>z</em>, whose <em>key</em> is assumed to have already been filled in, into the red-black tree <em>T</em>.</p>
<a id="p339"/>
<div class="pull-quote1">
<p class="box-heading">RB-I<small>NSERT</small>(<em>T</em>, <em>z</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><em>x</em> = <em>T.root</em></td>
<td class="td1"><span class="red"><strong>//</strong> node being compared with <em>z</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><em>y</em> = <em>T.nil</em></td>
<td class="td1"><span class="red"><strong>//</strong> <em>y</em> will be parent of <em>z</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><strong>while</strong> <em>x</em> ≠ <em>T.nil</em></td>
<td class="td1"><span class="red"><strong>//</strong> descend until reaching the sentinel</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2"><em>y</em> = <em>x</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>z.key</em> &lt; <em>x.key</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p3"><em>x</em> = <em>x.left</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p2"><strong>else</strong> <em>x</em> = <em>x.right</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><em>z.p</em> = <em>y</em></td>
<td class="td1"><span class="red"><strong>//</strong> found the location—insert <em>z</em> with parent <em>y</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><strong>if</strong> <em>y</em> == <em>T.nil</em></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="p2"><em>T.root</em> = <em>z</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> tree <em>T</em> was empty</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><strong>elseif</strong> <em>z.key</em> &lt; <em>y.key</em></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1"><p class="p2"><em>y.left</em> = <em>z</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1"><strong>else</strong> <em>y.right</em> = <em>z</em></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">14</span></td>
<td class="td1"><em>z.left</em> = <em>T.nil</em></td>
<td class="td1"><span class="red"><strong>//</strong> both of <em>z</em>’s children are the sentinel</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">15</span></td>
<td class="td1"><em>z.right</em> = <em>T.nil</em></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">16</span></td>
<td class="td1"><em>z.color</em> = <small>RED</small></td>
<td class="td1"><span class="red"><strong>//</strong> the new node starts out red</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">17</span></td>
<td class="td1">RB-I<small>NSERT</small>-F<small>IXUP</small>(<em>T</em>, <em>z</em>)</td>
<td class="td1"><span class="red"><strong>//</strong> correct any violations of red-black properties</span></td>
</tr>
</table>
</div>
<p>The procedures T<small>REE</small>-I<small>NSERT</small> and RB-I<small>NSERT</small> differ in four ways. First, all instances of <small>NIL</small> in T<small>REE</small>-I<small>NSERT</small> are replaced by <em>T.nil</em>. Second, lines 14–15 of RB-I<small>NSERT</small> set <em>z.left</em> and <em>z.right</em> to <em>T.nil</em>, in order to maintain the proper tree structure. (T<small>REE</small>-I<small>NSERT</small> assumed that <em>z</em>’s children were already <small>NIL</small>.) Third, line 16 colors <em>z</em> red. Fourth, because coloring <em>z</em> red may cause a violation of one of the red-black properties, line 17 of RB-I<small>NSERT</small> calls RB-I<small>NSERT</small>-F<small>IXUP</small>(<em>T</em>, <em>z</em>) in order to restore the red-black properties.</p>
<div class="pull-quote1">
<p class="box-heading">RB-I<small>NSERT</small>-F<small>IXUP</small>(<em>T</em>, <em>z</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><strong>while</strong> <em>z.p.color</em> == <small>RED</small></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>z.p</em> == <em>z.p.p.left</em></p></td>
<td class="td1" colspan="2"><span class="red"><strong>//</strong> is <em>z</em>’s parent a left child?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><p class="p3"><em>y</em> = <em>z.p.p.right</em></p></td>
<td class="td1" colspan="2"><span class="red"><strong>//</strong> <em>y</em> is <em>z</em>’s uncle</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>y.color</em> == <small>RED</small></p></td>
<td class="td1" colspan="2"><span class="red"><strong>//</strong> are <em>z</em>’s parent and uncle both red?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1" colspan="2">
<p class="p4"><em>z.p.color</em> = <small>BLACK</small></p></td>
<td class="td1" rowspan="4"><p class="indent-a"><img alt="art" src="images/Art_P435.jpg"/></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1" colspan="2">
<p class="p4"><em>y.color</em> = <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1" colspan="2">
<p class="p4"><em>z.p.p.color</em> = <small>RED</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1" colspan="2">
<p class="p4"><em>z</em> = <em>z.p.p</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="p3"><strong>else</strong></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="p4"><strong>if</strong> <em>z</em> == <em>z.p.right</em></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1" colspan="2">
<p class="p5"><em>z</em> = <em>z.p</em></p></td>
<td class="td1" rowspan="2"><p class="indent-a"><img alt="art" src="images/Art_P436.jpg"/></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1" colspan="2">
<p class="p5">L<small>EFT</small>-R<small>OTATE</small>(<em>T</em>, <em>z</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1" colspan="2">
<p class="p4"><em>z.p.color</em> = <small>BLACK</small></p></td>
<td class="td1" rowspan="3"><p class="indent-a"><img alt="art" src="images/Art_P437.jpg"/></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">14</span></td>
<td class="td1" colspan="2">
<p class="p4"><em>z.p.p.color</em> = <small>RED</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">15</span></td>
<td class="td1" colspan="2">
<p class="p4">R<small>IGHT</small>-R<small>OTATE</small>(<em>T</em>, <em>z.p.p</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">16</span></td>
<td class="td1" colspan="3">
<p class="p2"><strong>else</strong> <span class="red"><strong>//</strong> same as lines 3–15, but with “right” and “left” exchanged</span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">17</span></td>
<td class="td1"><p class="p3"><em>y</em> = <em>z.p.p.left</em></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">18</span></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>y.color</em> == <small>RED</small></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">19</span></td>
<td class="td1"><p class="p4"><em>z.p.color</em> = <small>BLACK</small></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">20</span></td>
<td class="td1"><p class="p4"><em>y.color</em> = <small>BLACK</small></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">21</span></td>
<td class="td1"><p class="p4"><em>z.p.p.color</em> = <small>RED</small></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">22</span></td>
<td class="td1"><p class="p4"><em>z</em> = <em>z.p.p</em></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">23</span></td>
<td class="td1"><p class="p3"><strong>else</strong></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">24</span></td>
<td class="td1"><p class="p4"><strong>if</strong> <em>z</em> == <em>z.p.left</em></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">25</span></td>
<td class="td1"><p class="p5"><em>z</em> = <em>z.p</em></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">26</span></td>
<td class="td1"><p class="p5">R<small>IGHT</small>-R<small>OTATE</small>(<em>T</em>, <em>z</em>)</p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">27</span></td>
<td class="td1"><p class="p4"><em>z.p.color</em> = <small>BLACK</small></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">28</span></td>
<td class="td1"><p class="p4"><em>z.p.p.color</em> = <small>RED</small></p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">29</span></td>
<td class="td1"><p class="p4">L<small>EFT</small>-R<small>OTATE</small>(<em>T</em>, <em>z.p.p</em>)</p></td>
<td class="td1" colspan="2"/>
</tr>
<tr>
<td class="td1"><span class="x-small">30</span></td>
<td class="td1"><em>T.root.color</em> = <small>BLACK</small></td>
<td class="td1" colspan="2"/>
</tr>
</table>
</div>
<p>To understand how RB-I<small>NSERT</small>-F<small>IXUP</small> works, let’s examine the code in three major steps. First, we’ll determine which violations of the red-black properties might arise in RB-I<small>NSERT</small> upon inserting node <em>z</em> and coloring it red. Second, we’ll consider the overall goal of the <strong>while</strong> loop in lines 1–29. Finally, we’ll explore each of the three cases within the <strong>while</strong> loop’s body (case 2 falls through into case 3, so these two cases are not mutually exclusive) and see how they accomplish the goal.</p>
<a id="p340"/>
<p>In describing the structure of a red-black tree, we’ll often need to refer to the sibling of a node’s parent. We use the term <strong><em><span class="blue1">uncle</span></em></strong> for such a node.<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup> <a href="chapter013.xhtml#Fig_13-4">Figure 13.4</a> shows how RB-I<small>NSERT</small>-F<small>IXUP</small> operates on a sample red-black tree, with cases depending in part on the colors of a node, its parent, and its uncle.</p>
<p>What violations of the red-black properties might occur upon the call to RB-I<small>NSERT</small>-F<small>IXUP</small>? Property 1 certainly continues to hold (every node is either red or black), as does property 3 (every leaf is black), since both children of the newly inserted red node are the sentinel <em>T.nil</em>. Property 5, which says that the number of black nodes is the same on every simple path from a given node, is satisfied as well, because node <em>z</em> replaces the (black) sentinel, and node <em>z</em> is red with sentinel children. Thus, the only properties that might be violated are property 2, which requires the root to be black, and property 4, which says that a red node cannot have a red child. Both possible violations may arise because <em>z</em> is colored red. Property 2 is violated if <em>z</em> is the root, and property 4 is violated if <em>z</em>’s parent is red. <a href="chapter013.xhtml#Fig_13-4">Figure 13.4(a)</a> shows a violation of property 4 after the node <em>z</em> has been inserted.</p>
<p>The <strong>while</strong> loop of lines 1–29 has two symmetric possibilities: lines 3–15 deal with the situation in which node <em>z</em>’s parent <em>z.p</em> is a left child of <em>z</em>’s grandparent <em>z.p.p</em>, and lines 17–29 apply when <em>z</em>’s parent is a right child. Our proof will focus only on lines 3–15, relying on the symmetry in lines 17–29.</p>
<p>We’ll show that the <strong>while</strong> loop maintains the following three-part invariant at the start of each iteration of the loop:</p>
<p class="nl-1listt">a. Node <em>z</em> is red.</p>
<p class="nl-1listt">b. If <em>z.p</em> is the root, then <em>z.p</em> is black.</p>
<p class="nl-1listt">c. If the tree violates any of the red-black properties, then it violates at most one of them, and the violation is of either property 2 or property 4, but not both. If the tree violates property 2, it is because <em>z</em> is the root and is red. If the tree violates property 4, it is because both <em>z</em> and <em>z.p</em> are red.</p>
<p class="noindent1-top">Part (c), which deals with violations of red-black properties, is more central to showing that RB-I<small>NSERT</small>-F<small>IXUP</small> restores the red-black properties than parts (a) and (b), which we’ll use along the way to understand situations in the code. Because we’ll be focusing on node <em>z</em> and nodes near it in the tree, it helps to know from part (a) that <em>z</em> is red. Part (b) will help show that <em>z</em>’s grandparent <em>z.p.p</em> exists when it’s referenced in lines 2, 3, 7, 8, 14, and 15 (recall that we’re focusing only on lines 3–15).</p>
<a id="p341"/>
<div class="divimage">
<p class="fig-imga" id="Fig_13-4"><img alt="art" src="images/Art_P438.jpg"/></p>
<p class="caption"><strong>Figure 13.4</strong> The operation of RB-I<small>NSERT</small>-F<small>IXUP</small>. <strong>(a)</strong> A node <em>z</em> after insertion. Because both <em>z</em> and its parent <em>z.p</em> are red, a violation of property 4 occurs. Since <em>z</em>’s uncle <em>y</em> is red, case 1 in the code applies. Node <em>z</em>’s grandparent <em>z.p.p</em> must be black, and its blackness transfers down one level to <em>z</em>’s parent and uncle. Once the pointer <em>z</em> moves up two levels in the tree, the tree shown in <strong>(b)</strong> results. Once again, <em>z</em> and its parent are both red, but this time <em>z</em>’s uncle <em>y</em> is black. Since <em>z</em> is the right child of <em>z.p</em>, case 2 applies. Performing a left rotation results in the tree in <strong>(c)</strong>. Now <em>z</em> is the left child of its parent, and case 3 applies. Recoloring and right rotation yield the tree in <strong>(d)</strong>, which is a legal red-black tree.</p>
</div>
<a id="p342"/>
<p>Recall that to use a loop invariant, we need to show that the invariant is true upon entering the first iteration of the loop, that each iteration maintains it, that the loop terminates, and that the loop invariant gives us a useful property at loop termination. We’ll see that each iteration of the loop has two possible outcomes: either the pointer <em>z</em> moves up the tree, or some rotations occur and then the loop terminates.</p>
<p class="para-hang-top"><strong>Initialization:</strong> Before RB-I<small>NSERT</small> is called, the red-black tree has no violations. RB-I<small>NSERT</small> adds a red node <em>z</em> and calls RB-I<small>NSERT</small>-F<small>IXUP</small>. We’ll show that each part of the invariant holds at the time RB-I<small>NSERT</small>-F<small>IXUP</small> is called:</p>
<p class="nl-1list-r">a. When RB-I<small>NSERT</small>-F<small>IXUP</small> is called, <em>z</em> is the red node that was added.</p>
<p class="nl-1list-r">b. If <em>z.p</em> is the root, then <em>z.p</em> started out black and did not change before the call of RB-I<small>NSERT</small>-F<small>IXUP</small>.</p>
<p class="nl-1list-r">c. We have already seen that properties 1, 3, and 5 hold when RB-I<small>NSERT</small>F<small>IXUP</small> is called.</p>
<p class="nl-1list-para">If the tree violates property 2 (the root must be black), then the red root must be the newly added node <em>z</em>, which is the only internal node in the tree. Because the parent and both children of <em>z</em> are the sentinel, which is black, the tree does not also violate property 4 (both children of a red node are black). Thus this violation of property 2 is the only violation of red-black properties in the entire tree.</p>
<p class="nl-1list-para">If the tree violates property 4, then, because the children of node <em>z</em> are black sentinels and the tree had no other violations prior to <em>z</em> being added, the violation must be because both <em>z</em> and <em>z.p</em> are red. Moreover, the tree violates no other red-black properties.</p>
<p class="para-hang1"><strong>Maintenance:</strong> There are six cases within the <strong>while</strong> loop, but we’ll examine only the three cases in lines 3–15, when node <em>z</em>’s parent <em>z.p</em> is a left child of <em>z</em>’s grandparent <em>z.p.p</em>. The proof for lines 17–29 is symmetric. The node <em>z.p.p</em> exists, since by part (b) of the loop invariant, if <em>z.p</em> is the root, then <em>z.p</em> is black. Since RB-I<small>NSERT</small>-F<small>IXUP</small> enters a loop iteration only if <em>z.p</em> is red, we know that <em>z.p</em> cannot be the root. Hence, <em>z.p.p</em> exists.</p>
<p class="php">Case 1 differs from cases 2 and 3 by the color of <em>z</em>’s uncle <em>y</em>. Line 3 makes <em>y</em> point to <em>z</em>’s uncle <em>z.p.p.right</em>, and line 4 tests <em>y</em>’s color. If <em>y</em> is red, then case 1 executes. Otherwise, control passes to cases 2 and 3. In all three cases, <em>z</em>’s grandparent <em>z.p.p</em> is black, since its parent <em>z.p</em> is red, and property 4 is violated only between <em>z</em> and <em>z.p</em>.</p>
<a id="p343"/>
<div class="divimage">
<p class="fig-imga" id="Fig_13-5"><img alt="art" class="width100" src="images/Art_P439.jpg"/></p>
<p class="caption"><strong>Figure 13.5</strong> Case 1 of the procedure RB-I<small>NSERT</small>-F<small>IXUP</small>. Both <em>z</em> and its parent <em>z.p</em> are red, violating property 4. In case 1, <em>z</em>’s uncle <em>y</em> is red. The same action occurs regardless of whether <strong>(a)</strong> <em>z</em> is a right child or <strong>(b)</strong> <em>z</em> is a left child. Each of the subtrees <em>α</em>, <em>β</em>, <em>γ</em>, <em>δ</em>, and <em><span class="font1">ϵ</span></em> has a black root—possibly the sentinel—and each has the same black-height. The code for case 1 moves the blackness of <em>z</em>’s grandparent down to <em>z</em>’s parent and uncle, preserving property 5: all downward simple paths from a node to a leaf have the same number of blacks. The <strong>while</strong> loop continues with node <em>z</em>’s grandparent <em>z.p.p</em> as the new <em>z</em>. If the action of case 1 causes a new violation of property 4 to occur, it must be only between the new <em>z</em>, which is red, and its parent, if it is red as well.</p>
</div>
<p class="block"/>
<div class="divimage">
<p class="fig-imga" id="Fig_13-6"><img alt="art" src="images/Art_P440.jpg"/></p>
<p class="caption"><strong>Figure 13.6</strong> Cases 2 and 3 of the procedure RB-I<small>NSERT</small>-F<small>IXUP</small>. As in case 1, property 4 is violated in either case 2 or case 3 because <em>z</em> and its parent <em>z.p</em> are both red. Each of the subtrees <em>α</em>, <em>β</em>, <em>γ</em>, and <em>δ</em> has a black root (<em>α</em>, <em>β</em>, and <em>γ</em> from property 4, and <em>δ</em> because otherwise case 1 would apply), and each has the same black-height. Case 2 transforms into case 3 by a left rotation, which preserves property 5: all downward simple paths from a node to a leaf have the same number of blacks. Case 3 causes some color changes and a right rotation, which also preserve property 5. The <strong>while</strong> loop then terminates, because property 4 is satisfied: there are no longer two red nodes in a row.</p>
</div>
<div class="pull-quote">
<p class="pq-noindent"><strong><em>Case 1. z’s uncle y is red</em></strong></p>
<p class="pq-noindent1-top1"><a href="chapter013.xhtml#Fig_13-5">Figure 13.5</a> shows the situation for case 1 (lines 5–8), which occurs when both <em>z.p</em> and <em>y</em> are red. Because <em>z</em>’s grandparent <em>z.p.p</em> is black, its blackness can transfer down one level to both <em>z.p</em> and <em>y</em>, thereby fixing the problem of <em>z</em> and <em>z.p</em> both being red. Having had its blackness transferred down one level, <em>z</em>’s grandparent becomes red, thereby maintaining property 5. The <strong>while</strong> loop repeats with <em>z.p.p</em> as the new node <em>z</em>, so that the pointer <em>z</em> moves up two levels in the tree.</p>
<p class="pq-noindent1-top1">Now, we show that case 1 maintains the loop invariant at the start of the next iteration. We use <em>z</em> to denote node <em>z</em> in the current iteration, and <em>z</em>′ = <em>z.p.p</em> to denote the node that will be called node <em>z</em> at the test in line 1 upon the next iteration.</p>
<p class="nl">a. Because this iteration colors <em>z.p.p</em> red, node <em>z</em>′ is red at the start of the next iteration.</p>
<p class="nl">b. The node <em>z</em>′.<em>p</em> is <em>z.p.p.p</em> in this iteration, and the color of this node does not change. If this node is the root, it was black prior to this iteration, and it remains black at the start of the next iteration.</p>
<a id="p344"/>
<p class="nl">c. We have already argued that case 1 maintains property 5, and it does not introduce a violation of properties 1 or 3.</p>
<p class="nl-parat">If node <em>z</em>′ is the root at the start of the next iteration, then case 1 corrected the lone violation of property 4 in this iteration. Since <em>z</em>′ is red and it is the root, property 2 becomes the only one that is violated, and this violation is due to <em>z</em>′.</p>
<p class="nl-parat">If node <em>z</em>′ is not the root at the start of the next iteration, then case 1 has not created a violation of property 2. Case 1 corrected the lone violation of property 4 that existed at the start of this iteration. It then made <em>z</em>′ red and left <em>z</em>′.<em>p</em> alone. If <em>z</em>′.<em>p</em> was black, there is no violation of property 4. If <em>z</em>′.<em>p</em> was red, coloring <em>z</em>′ red created one violation of property 4, between <em>z</em>′ and <em>z</em>′.<em>p</em>.</p>
<p class="pq-noindent-top"><strong><em>Case 2. z’s uncle y is black and z is a right child</em></strong></p>
<p class="pq-noindent"><strong><em>Case 3. z’s uncle y is black and z is a left child</em></strong></p>
<p class="pq-noindent1-top1">In cases 2 and 3, the color of <em>z</em>’s uncle <em>y</em> is black. We distinguish the two cases, which assume that <em>z</em>’s parent <em>z.p</em> is red and a left child, according to whether <em>z</em> is a right or left child of <em>z.p</em>. Lines 11–12 constitute case 2, which is shown in <a href="chapter013.xhtml#Fig_13-6">Figure 13.6</a> together with case 3. In case 2, node <em>z</em> is a right child of its parent. A left rotation immediately transforms the situation into case 3 (lines 13–15), in which node <em>z</em> is a left child. Because both <em>z</em> and <em>z.p</em> are red, the rotation affects neither the black-heights of nodes nor property 5. Whether case 3 executes directly or through case 2, <em>z</em>’s uncle <em>y</em> is black, since otherwise case 1 would have run. Additionally, the node <em>z.p.p</em> exists, since we have argued that this <a id="p345"/>node existed at the time that lines 2 and 3 were executed, and after moving <em>z</em> up one level in line 11 and then down one level in line 12, the identity of <em>z.p.p</em> remains unchanged. Case 3 performs some color changes and a right rotation, which preserve property 5. At this point, there are no longer two red nodes in a row. The <strong>while</strong> loop terminates upon the next test in line 1, since <em>z.p</em> is now black.</p>
<p class="pq-noindent1-top1">We now show that cases 2 and 3 maintain the loop invariant. (As we have just argued, <em>z.p</em> will be black upon the next test in line 1, and the loop body will not execute again.)</p>
<p class="nl">a. Case 2 makes <em>z</em> point to <em>z.p</em>, which is red. No further change to <em>z</em> or its color occurs in cases 2 and 3.</p>
<p class="nl">b. Case 3 makes <em>z.p</em> black, so that if <em>z.p</em> is the root at the start of the next iteration, it is black.</p>
<p class="nl">c. As in case 1, properties 1, 3, and 5 are maintained in cases 2 and 3.</p>
<p class="nl-parat">Since node <em>z</em> is not the root in cases 2 and 3, we know that there is no violation of property 2. Cases 2 and 3 do not introduce a violation of property 2, since the only node that is made red becomes a child of a black node by the rotation in case 3.</p>
<p class="nl-parat">Cases 2 and 3 correct the lone violation of property 4, and they do not introduce another violation.</p>
</div>
<p class="para-hang1"><strong>Termination:</strong> To see that the loop terminates, observe that if only case 1 occurs, then the node pointer <em>z</em> moves toward the root in each iteration, so that eventually <em>z.p</em> is black. (If <em>z</em> is the root, then <em>z.p</em> is the sentinel <em>T.nil</em>, which is black.) If either case 2 or case 3 occurs, then we’ve seen that the loop terminates. Since the loop terminates because <em>z.p</em> is black, the tree does not violate property 4 at loop termination. By the loop invariant, the only property that might fail to hold is property 2. Line 30 restores this property by coloring the root black, so that when RB-I<small>NSERT</small>-F<small>IXUP</small> terminates, all the red-black properties hold.</p>
<p class="space-break">Thus, we have shown that RB-I<small>NSERT</small>-F<small>IXUP</small> correctly restores the red-black properties.</p>
<p class="level4"><strong>Analysis</strong></p>
<p class="noindent">What is the running time of RB-I<small>NSERT</small>? Since the height of a red-black tree on <em>n</em> nodes is <em>O</em>(lg <em>n</em>), lines 1–16 of RB-I<small>NSERT</small> take <em>O</em>(lg <em>n</em>) time. In RB-I<small>NSERT</small>F<small>IXUP</small>, the <strong>while</strong> loop repeats only if case 1 occurs, and then the pointer <em>z</em> moves two levels up the tree. The total number of times the <strong>while</strong> loop can be executed is therefore <em>O</em>(lg <em>n</em>). Thus, RB-I<small>NSERT</small> takes a total of <em>O</em>(lg <em>n</em>) time. Moreover, it <a id="p346"/>never performs more than two rotations, since the <strong>while</strong> loop terminates if case 2 or case 3 is executed.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>13.3-1</em></strong></p>
<p class="noindent">Line 16 of RB-I<small>NSERT</small> sets the color of the newly inserted node <em>z</em> to red. If instead <em>z</em>’s color were set to black, then property 4 of a red-black tree would not be violated. Why not set <em>z</em>’s color to black?</p>
<p class="level3"><strong><em>13.3-2</em></strong></p>
<p class="noindent">Show the red-black trees that result after successively inserting the keys 41, 38, 31, 12, 19, 8 into an initially empty red-black tree.</p>
<p class="level3"><strong><em>13.3-3</em></strong></p>
<p class="noindent">Suppose that the black-height of each of the subtrees <em>α</em>, <em>β</em>, <em>γ</em>, <em>δ</em>, <em><span class="font1">ϵ</span></em> in <a href="chapter013.xhtml#Fig_13-5">Figures 13.5</a> and <a href="chapter013.xhtml#Fig_13-6">13.6</a> is <em>k</em>. Label each node in each figure with its black-height to verify that the indicated transformation preserves property 5.</p>
<p class="level3"><strong><em>13.3-4</em></strong></p>
<p class="noindent">Professor Teach is concerned that RB-I<small>NSERT</small>-F<small>IXUP</small> might set <em>T.nil.color</em> to <small>RED</small>, in which case the test in line 1 would not cause the loop to terminate when <em>z</em> is the root. Show that the professor’s concern is unfounded by arguing that RB-I<small>NSERT</small>-F<small>IXUP</small> never sets <em>T.nil.color</em> to <small>RED</small>.</p>
<p class="level3"><strong><em>13.3-5</em></strong></p>
<p class="noindent">Consider a red-black tree formed by inserting <em>n</em> nodes with RB-I<small>NSERT</small>. Argue that if <em>n</em> &gt; 1, the tree has at least one red node.</p>
<p class="level3"><strong><em>13.3-6</em></strong></p>
<p class="noindent">Suggest how to implement RB-I<small>NSERT</small> efficiently if the representation for red-black trees includes no storage for parent pointers.</p>
</section>
<p class="line1"/>
<section title="13.4 Deletion">
<a id="Sec_13.4"/>
<p class="level1" id="h1-77"><a href="toc.xhtml#Rh1-77"><strong>13.4    Deletion</strong></a></p>
<p class="noindent">Like the other basic operations on an <em>n</em>-node red-black tree, deletion of a node takes <em>O</em>(lg <em>n</em>) time. Deleting a node from a red-black tree is more complicated than inserting a node.</p>
<p>The procedure for deleting a node from a red-black tree is based on the T<small>REE</small>-D<small>ELETE</small> procedure on page 325. First, we need to customize the T<small>RANSPLANT</small> <a id="p347"/>subroutine on page 324 that T<small>REE</small>-D<small>ELETE</small> calls so that it applies to a red-black tree. Like T<small>RANSPLANT</small>, the new procedure RB-T<small>RANSPLANT</small> replaces the subtree rooted at node <em>u</em> by the subtree rooted at node <em>v</em>. The RB-T<small>RANSPLANT</small> procedure differs from T<small>RANSPLANT</small> in two ways. First, line 1 references the sentinel <em>T.nil</em> instead of <small>NIL</small>. Second, the assignment to <em>v.p</em> in line 6 occurs unconditionally: the procedure can assign to <em>v.p</em> even if <em>v</em> points to the sentinel. We’ll take advantage of the ability to assign to <em>v.p</em> when <em>v</em> = <em>T.nil</em>.</p>
<div class="pull-quote1">
<p class="box-heading">RB-T<small>RANSPLANT</small>(<em>T</em>, <em>u</em>, <em>v</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>if</strong> <em>u.p</em> == <em>T.nil</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><em>T.root</em> = <em>v</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><strong>elseif</strong> <em>u</em> == <em>u.p.left</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><em>u.p.left</em> = <em>v</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><strong>else</strong> <em>u.p.right</em> = <em>v</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><em>v.p</em> = <em>u.p</em></td>
</tr>
</table>
</div>
<p>The procedure RB-D<small>ELETE</small> on the next page is like the T<small>REE</small>-D<small>ELETE</small> procedure, but with additional lines of pseudocode. The additional lines deal with nodes <em>x</em> and <em>y</em> that may be involved in violations of the red-black properties. When the node <em>z</em> being deleted has at most one child, then <em>y</em> will be <em>z</em>. When <em>z</em> has two children, then, as in T<small>REE</small>-D<small>ELETE</small>, <em>y</em> will be <em>z</em>’s successor, which has no left child and moves into <em>z</em>’s position in the tree. Additionally, <em>y</em> takes on <em>z</em>’s color. In either case, node <em>y</em> has at most one child: node <em>x</em>, which takes <em>y</em>’s place in the tree. (Node <em>x</em> will be the sentinel <em>T.nil</em> if <em>y</em> has no children.) Since node <em>y</em> will be either removed from the tree or moved within the tree, the procedure needs to keep track of <em>y</em>’s original color. If the red-black properties might be violated after deleting node <em>z</em>, RB-D<small>ELETE</small> calls the auxiliary procedure RB-D<small>ELETE</small>-F<small>IXUP</small>, which changes colors and performs rotations to restore the red-black properties.</p>
<p>Although RB-D<small>ELETE</small> contains almost twice as many lines of pseudocode as T<small>REE</small>-D<small>ELETE</small>, the two procedures have the same basic structure. You can find each line of T<small>REE</small>-D<small>ELETE</small> within RB-D<small>ELETE</small> (with the changes of replacing <small>NIL</small> by <em>T.nil</em> and replacing calls to T<small>RANSPLANT</small> by calls to RB-T<small>RANSPLANT</small>), executed under the same conditions.</p>
<p>In detail, here are the other differences between the two procedures:</p>
<ul class="ulnoindent" epub:type="list">
<li>Lines 1 and 9 set node <em>y</em> as described above: line 1 when node <em>z</em> has at most one child and line 9 when <em>z</em> has two children.</li>
<li class="litop">Because node <em>y</em>’s color might change, the variable <em>y-original-color</em> stores <em>y</em>’s color before any changes occur. Lines 2 and 10 set this variable immediately after assignments to <em>y</em>. When node <em>z</em> has two children, then nodes <em>y</em> and <em>z</em> are <a id="p348"/>distinct. In this case, line 17 moves <em>y</em> into <em>z</em>’s original position in the tree (that is, <em>z</em>’s location in the tree at the time RB-D<small>ELETE</small> was called), and line 20 gives <em>y</em> the same color as <em>z</em>. When node <em>y</em> was originally black, removing or moving it could cause violations of the red-black properties, which are corrected by the call of RB-D<small>ELETE</small>-F<small>IXUP</small> in line 22.</li></ul>
<div class="pull-quote1">
<p class="box-heading">RB-D<small>ELETE</small>(<em>T</em>, <em>z</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><em>y</em> = <em>z</em></td>
<td class="td1" colspan="2"><p> </p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><em>y-original-color</em> = <em>y.color</em></td>
<td class="td1" colspan="2"><p> </p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><strong>if</strong> <em>z.left</em> == <em>T.nil</em></td>
<td class="td1" colspan="2"><p> </p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2"><em>x</em> = <em>z.right</em></p></td>
<td class="td1" colspan="2"><p> </p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1" colspan="2"><p class="p2">RB-T<small>RANSPLANT</small>(<em>T</em>, <em>z</em>, <em>z.right</em>)</p></td>
<td class="td1"><span class="red"><strong>//</strong> replace <em>z</em> by its right child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><strong>elseif</strong> <em>z.right</em> == <em>T.nil</em></td>
<td class="td1" colspan="2"><p> </p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p2"><em>x</em> = <em>z.left</em></p></td>
<td class="td1" colspan="2"><p> </p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1" colspan="2"><p class="p2">RB-T<small>RANSPLANT</small>(<em>T</em>, <em>z</em>, <em>z.left</em>)</p></td>
<td class="td1"><span class="red"><strong>//</strong> replace <em>z</em> by its left child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1" colspan="2"><strong>else</strong> <em>y</em> = T<small>REE</small>-M<small>INIMUM</small>(<em>z.right</em>)</td>
<td class="td1"><span class="red"><strong>//</strong> <em>y</em> is <em>z</em>’s successor</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="p2"><em>y-original-color</em> = <em>y.color</em></p></td>
<td class="td1" colspan="2"><p> </p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><p class="p2"><em>x</em> = <em>y.right</em></p></td>
<td class="td1" colspan="2"><p> </p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>y</em> ≠ <em>z.right</em></p></td>
<td class="td1"><p> </p></td>
<td class="td1"><span class="red"><strong>//</strong> is <em>y</em> farther down the tree?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1" colspan="2"><p class="p3">RB-T<small>RANSPLANT</small>(<em>T</em>, <em>y</em>, <em>y.right</em>)</p></td>
<td class="td1"><span class="red"><strong>//</strong> replace <em>y</em> by its right child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">14</span></td>
<td class="td1"><p class="p3"><em>y.right</em> = <em>z.right</em></p></td>
<td class="td1"><p> </p></td>
<td class="td1"><span class="red"><strong>//</strong> <em>z</em>’s right child becomes</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">15</span></td>
<td class="td1"><p class="p3"><em>y.right.p</em> = <em>y</em></p></td>
<td class="td1"><p> </p></td>
<td class="td1"><span class="red"><strong>//</strong>   <em>y</em>’s right child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">16</span></td>
<td class="td1"><p class="p2"><strong>else</strong> <em>x.p</em> = <em>y</em></p></td>
<td class="td1"><p> </p></td>
<td class="td1"><span class="red"><strong>//</strong> in case <em>x</em> is <em>T.nil</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">17</span></td>
<td class="td1"><p class="p2">RB-T<small>RANSPLANT</small>(<em>T</em>, <em>z</em>, <em>y</em>)</p></td>
<td class="td1"><p> </p></td>
<td class="td1"><span class="red"><strong>//</strong> replace <em>z</em> by its successor <em>y</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">18</span></td>
<td class="td1"><p class="p2"><em>y.left</em> = <em>z.left</em></p></td>
<td class="td1"><p> </p></td>
<td class="td1"><span class="red"><strong>//</strong> and give <em>z</em>’s left child to <em>y</em>,</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">19</span></td>
<td class="td1"><p class="p2"><em>y.left.p</em> = <em>y</em></p></td>
<td class="td1"><p> </p></td>
<td class="td1"><span class="red"><strong>//</strong>       which had no left child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">20</span></td>
<td class="td1"><p class="p2"><em>y.color</em> = <em>z.color</em></p></td>
<td class="td1" colspan="2"><p> </p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">21</span></td>
<td class="td1"><strong>if</strong> <em>y-original-color</em> == <small>BLACK</small></td>
<td class="td1" colspan="2"><span class="red"><strong>//</strong> if any red-black violations occurred,</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">22</span></td>
<td class="td1"><p class="p2">RB-D<small>ELETE</small>-F<small>IXUP</small>(<em>T</em>, <em>x</em>)</p></td>
<td class="td1" colspan="2"><span class="red"><strong>//</strong>       correct them</span></td>
</tr>
</table>
</div>
<ul class="ulnoindent" epub:type="list">
<li>As discussed, the procedure keeps track of the node <em>x</em> that moves into node <em>y</em>’s original position at the time of call. The assignments in lines 4, 7, and 11 set <em>x</em> to point to either <em>y</em>’s only child or, if <em>y</em> has no children, the sentinel <em>T.nil</em>.</li>
<li class="litop">Since node <em>x</em> moves into node <em>y</em>’s original position, the attribute <em>x.p</em> must be set correctly. If node <em>z</em> has two children and <em>y</em> is <em>z</em>’s right child, then <em>y</em> just moves into <em>z</em>’s position, with <em>x</em> remaining a child of <em>y</em>. Line 12 checks for this case. Although you might think that setting <em>x.p</em> to <em>y</em> in line 16 is unnecessary since <em>x</em> is a child of <em>y</em>, the call of RB-D<small>ELETE</small>-F<small>IXUP</small> relies on <em>x.p</em> being <em>y</em> even if <em>x</em> is <em>T.nil</em>. Thus, when <em>z</em> has two children and <em>y</em> is <em>z</em>’s right child, executing <a id="p349"/>line 16 is necessary if <em>y</em>’s right child is <em>T.nil</em>, and otherwise it does not change anything.
<p class="lip">Otherwise, node <em>z</em> is either the same as node <em>y</em> or it is a proper ancestor of <em>y</em>’s original parent. In these cases, the calls of RB-T<small>RANSPLANT</small> in lines 5, 8, and 13 set <em>x.p</em> correctly in line 6 of RB-T<small>RANSPLANT</small>. (In these calls of RB-T<small>RANSPLANT</small>, the third parameter passed is the same as <em>x</em>.)</p>
</li>
<li class="litop">Finally, if node <em>y</em> was black, one or more violations of the red-black properties might arise. The call of RB-D<small>ELETE</small>-F<small>IXUP</small> in line 22 restores the red-black properties. If <em>y</em> was red, the red-black properties still hold when <em>y</em> is removed or moved, for the following reasons:
<ol class="olnoindent" epub:type="list">
<li>No black-heights in the tree have changed. (See Exercise 13.4-1.)</li>
<li class="litop">No red nodes have been made adjacent. If <em>z</em> has at most one child, then <em>y</em> and <em>z</em> are the same node. That node is removed, with a child taking its place. If the removed node was red, then neither its parent nor its children can also be red, so moving a child to take its place cannot cause two red nodes to become adjacent. If, on the other hand, <em>z</em> has two children, then <em>y</em> takes <em>z</em>’s place in the tree, along with <em>z</em>’s color, so there cannot be two adjacent red nodes at <em>y</em>’s new position in the tree. In addition, if <em>y</em> was not <em>z</em>’s right child, then <em>y</em>’s original right child <em>x</em> replaces <em>y</em> in the tree. Since <em>y</em> is red, <em>x</em> must be black, and so replacing <em>y</em> by <em>x</em> cannot cause two red nodes to become adjacent.</li>
<li class="litop">Because <em>y</em> could not have been the root if it was red, the root remains black.</li></ol>
</li></ul>
<p>If node <em>y</em> was black, three problems may arise, which the call of RB-D<small>ELETE</small>-F<small>IXUP</small> will remedy. First, if <em>y</em> was the root and a red child of <em>y</em> became the new root, property 2 is violated. Second, if both <em>x</em> and its new parent are red, then a violation of property 4 occurs. Third, moving <em>y</em> within the tree causes any simple path that previously contained <em>y</em> to have one less black node. Thus, property 5 is now violated by any ancestor of <em>y</em> in the tree. We can correct the violation of property 5 by saying that when the black node <em>y</em> is removed or moved, its blackness transfers to the node <em>x</em> that moves into <em>y</em>’s original position, giving <em>x</em> an “extra” black. That is, if we add 1 to the count of black nodes on any simple path that contains <em>x</em>, then under this interpretation, property 5 holds. But now another problem emerges: node <em>x</em> is neither red nor black, thereby violating property 1. Instead, node <em>x</em> is either “doubly black” or “red-and-black,” and it contributes either 2 or 1, respectively, to the count of black nodes on simple paths containing <em>x</em>. The <em>color</em> attribute of <em>x</em> will still be either <small>RED</small> (if <em>x</em> is red-and-black) or <small>BLACK</small> (if <em>x</em> is doubly black). In other words, the extra black on a node is reflected in <em>x</em>’s pointing to the node rather than in the <em>color</em> attribute.</p>
<a id="p350"/>
<p>The procedure RB-D<small>ELETE</small>-F<small>IXUP</small> on the next page restores properties 1, 2, and 4. Exercises 13.4-2 and 13.4-3 ask you to show that the procedure restores properties 2 and 4, and so in the remainder of this section, we focus on property 1. The goal of the <strong>while</strong> loop in lines 1–43 is to move the extra black up the tree until</p>
<ol class="olnoindent" epub:type="list">
<li><em>x</em> points to a red-and-black node, in which case line 44 colors <em>x</em> (singly) black;</li>
<li class="litop"><em>x</em> points to the root, in which case the extra black simply vanishes; or</li>
<li class="litop">having performed suitable rotations and recolorings, the loop exits.</li></ol>
<p class="noindent">Like RB-I<small>NSERT</small>-F<small>IXUP</small>, the RB-D<small>ELETE</small>-F<small>IXUP</small> procedure handles two symmetric situations: lines 3–22 for when node <em>x</em> is a left child, and lines 24–43 for when <em>x</em> is a right child. Our proof focuses on the four cases shown in lines 3–22.</p>
<p>Within the <strong>while</strong> loop, <em>x</em> always points to a nonroot doubly black node. Line 2 determines whether <em>x</em> is a left child or a right child of its parent <em>x.p</em> so that either lines 3–22 or 24–43 will execute in a given iteration. The sibling of <em>x</em> is always denoted by a pointer <em>w</em>. Since node <em>x</em> is doubly black, node <em>w</em> cannot be <em>T.nil</em>, because otherwise, the number of blacks on the simple path from <em>x.p</em> to the (singly black) leaf <em>w</em> would be smaller than the number on the simple path from <em>x.p</em> to <em>x</em>.</p>
<p>Recall that the RB-D<small>ELETE</small> procedure always assigns to <em>x.p</em> before calling RB-D<small>ELETE</small>-F<small>IXUP</small> (either within the call of RB-T<small>RANSPLANT</small> in line 13 or the assignment in line 16), even when node <em>x</em> is the sentinel <em>T.nil</em>. That is because RB-D<small>ELETE</small>-F<small>IXUP</small> references <em>x</em>’s parent <em>x.p</em> in several places, and this attribute must point to the node that became <em>x</em>’s parent in RB-D<small>ELETE</small>—even if <em>x</em> is <em>T.nil</em>.</p>
<p><a href="chapter013.xhtml#Fig_13-7">Figure 13.7</a> demonstrates the four cases in the code when node <em>x</em> is a left child. (As in RB-I<small>NSERT</small>-F<small>IXUP</small>, the cases in RB-D<small>ELETE</small>-F<small>IXUP</small> are not mutually exclusive.) Before examining each case in detail, let’s look more generally at how we can verify that the transformation in each of the cases preserves property 5. The key idea is that in each case, the transformation applied preserves the number of black nodes (including <em>x</em>’s extra black) from (and including) the root of the subtree shown to the roots of each of the subtrees <em>α</em>, <em>β</em>, …, <em>ζ</em>. Thus, if property 5 holds prior to the transformation, it continues to hold afterward. For example, in <a href="chapter013.xhtml#Fig_13-7">Figure 13.7(a)</a>, which illustrates case 1, the number of black nodes from the root to the root of either subtree <em>α</em> or <em>β</em> is 3, both before and after the transformation. (Again, remember that node <em>x</em> adds an extra black.) Similarly, the number of black nodes from the root to the root of any of <em>γ</em>, <em>δ</em>, <em><span class="font1">ϵ</span></em>, and <em>ζ</em> is 2, both before and after the transformation.<sup><a epub:type="footnote" href="#footnote_2" id="footnote_ref_2">2</a></sup> In <a href="chapter013.xhtml#Fig_13-7">Figure 13.7(b)</a>, the counting must involve the value <em>c</em> of the <em>color</em> attribute of the root of the subtree shown, which can be either <small>RED</small> or <small>BLACK</small>.</p>
<a id="p351"/>
<div class="pull-quote1">
<p class="box-heading">RB-D<small>ELETE</small>-F<small>IXUP</small>(<em>T</em>, <em>x</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1" colspan="2"><strong>while</strong> <em>x</em> ≠ <em>T.root</em> and <em>x.color</em> == <small>BLACK</small></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>x</em> == <em>x.p.left</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> is <em>x</em> a left child?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><p class="p3"><em>w</em> = <em>x.p.right</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> <em>w</em> is <em>x</em>’s sibling</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1" colspan="2"><p class="p3"><strong>if</strong> <em>w.color</em> == <small>RED</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="p4"><em>w.color</em> = <small>BLACK</small></p></td>
<td class="td1" rowspan="4"><p class="indent-a"><img alt="art" src="images/Art_P441.jpg"/></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p4"><em>x.p.color</em> = <small>RED</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p4">L<small>EFT</small>-R<small>OTATE</small>(<em>T</em>, <em>x.p</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="p4"><em>w</em> = <em>x.p.right</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>w.left.color</em> == <small>BLACK</small> and <em>w.right.color</em> == <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="p4"><em>w.color</em> = <small>RED</small></p></td>
<td class="td1" rowspan="2"><p class="indent-a"><img alt="art" src="images/Art_P442.jpg"/></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><p class="p4"><em>x</em> = <em>x.p</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1" colspan="2"><p class="p3"><strong>else</strong></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1" colspan="2"><p class="p4"><strong>if</strong> <em>w.right.color</em> == <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">14</span></td>
<td class="td1"><p class="p5"><em>w.left.color</em> = <small>BLACK</small></p></td>
<td class="td1" rowspan="4"><p class="indent-a"><img alt="art" src="images/Art_P443.jpg"/></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">15</span></td>
<td class="td1"><p class="p5"><em>w.color</em> = <small>RED</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">16</span></td>
<td class="td1"><p class="p5">R<small>IGHT</small>-R<small>OTATE</small>(<em>T</em>, <em>w</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">17</span></td>
<td class="td1"><p class="p5"><em>w</em> = <em>x.p.right</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">18</span></td>
<td class="td1"><p class="p4"><em>w.color</em> = <em>x.p.color</em></p></td>
<td class="td1" rowspan="5"><p class="indent-a"><img alt="art" src="images/Art_P444.jpg"/></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">19</span></td>
<td class="td1"><p class="p4"><em>x.p.color</em> = <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">20</span></td>
<td class="td1"><p class="p4"><em>w.right.color</em> = <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">21</span></td>
<td class="td1"><p class="p4">L<small>EFT</small>-R<small>OTATE</small>(<em>T</em>, <em>x.p</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">22</span></td>
<td class="td1"><p class="p4"><em>x</em> = <em>T.root</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">23</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>else</strong> <span class="red"><strong>//</strong> same as lines 3–22, but with “right” and “left” exchanged</span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">24</span></td>
<td class="td1" colspan="2"><p class="p3"><em>w</em> = <em>x.p.left</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">25</span></td>
<td class="td1" colspan="2"><p class="p3"><strong>if</strong> <em>w.color</em> == <small>RED</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">26</span></td>
<td class="td1" colspan="2"><p class="p4"><em>w.color</em> = <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">27</span></td>
<td class="td1" colspan="2"><p class="p4"><em>x.p.color</em> = <small>RED</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">28</span></td>
<td class="td1" colspan="2"><p class="p4">R<small>IGHT</small>-R<small>OTATE</small>(<em>T</em>, <em>x.p</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">29</span></td>
<td class="td1" colspan="2"><p class="p4"><em>w</em> = <em>x.p.left</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">30</span></td>
<td class="td1" colspan="2"><p class="p3"><strong>if</strong> <em>w.right.color</em> == <small>BLACK</small> and <em>w.left.color</em> == <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">31</span></td>
<td class="td1" colspan="2"><p class="p4"><em>w.color</em> = <small>RED</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">32</span></td>
<td class="td1" colspan="2"><p class="p4"><em>x</em> = <em>x.p</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">33</span></td>
<td class="td1" colspan="2"><p class="p3"><strong>else</strong></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">34</span></td>
<td class="td1" colspan="2"><p class="p4"><strong>if</strong> <em>w.left.color</em> == <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">35</span></td>
<td class="td1" colspan="2"><p class="p5"><em>w.right.color</em> = <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">36</span></td>
<td class="td1" colspan="2"><p class="p5"><em>w.color</em> = <small>RED</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">37</span></td>
<td class="td1" colspan="2"><p class="p5">L<small>EFT</small>-R<small>OTATE</small>(<em>T</em>, <em>w</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">38</span></td>
<td class="td1" colspan="2"><p class="p5"><em>w</em> = <em>x.p.left</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">39</span></td>
<td class="td1" colspan="2"><p class="p4"><em>w.color</em> = <em>x.p.color</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">40</span></td>
<td class="td1" colspan="2"><p class="p4"><em>x.p.color</em> = <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">41</span></td>
<td class="td1" colspan="2"><p class="p4"><em>w.left.color</em> = <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">42</span></td>
<td class="td1" colspan="2"><p class="p4">R<small>IGHT</small>-R<small>OTATE</small>(<em>T</em>, <em>x.p</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">43</span></td>
<td class="td1" colspan="2"><p class="p4"><em>x</em> = <em>T.root</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">44</span></td>
<td class="td1" colspan="2"><em>x.color</em> = <small>BLACK</small></td>
</tr>
</table>
</div>
<a id="p352"/>
<div class="divimage">
<p class="fig-imga" id="Fig_13-7"><img alt="art" class="width100" src="images/Art_P445.jpg"/></p>
<p class="caption"><strong>Figure 13.7</strong> The cases in lines 3–22 of the procedure RB-D<small>ELETE</small>-F<small>IXUP</small>. Brown nodes have <em>color</em> attributes represented by <em>c</em> and <em>c</em>′, which may be either <small>RED</small> or <small>BLACK</small>. The letters <em>α</em>, <em>β</em>, …, <em>ζ</em> represent arbitrary subtrees. Each case transforms the configuration on the left into the configuration on the right by changing some colors and/or performing a rotation. Any node pointed to by <em>x</em> has an extra black and is either doubly black or red-and-black. Only case 2 causes the loop to repeat. <strong>(a)</strong> Case 1 is transformed into case 2, 3, or 4 by exchanging the colors of nodes <em>B</em> and <em>D</em> and performing a left rotation. <strong>(b)</strong> In case 2, the extra black represented by the pointer <em>x</em> moves up the tree by coloring node <em>D</em> red and setting <em>x</em> to point to node <em>B</em>. If case 2 is entered through case 1, the <strong>while</strong> loop terminates because the new node <em>x</em> is red-and-black, and therefore the value <em>c</em> of its <em>color</em> attribute is <small>RED</small>. <strong>(c)</strong> Case 3 is transformed to case 4 by exchanging the colors of nodes <em>C</em> and <em>D</em> and performing a right rotation. <strong>(d)</strong> Case 4 removes the extra black represented by <em>x</em> by changing some colors and performing a left rotation (without violating the red-black properties), and then the loop terminates.</p>
</div>
<a id="p353"/>
<p class="noindent">If we define count(<small>RED</small>) = 0 and count(<small>BLACK</small>) = 1, then the number of black nodes from the root to <em>α</em> is 2 + count(<em>c</em>), both before and after the transformation. In this case, after the transformation, the new node <em>x</em> has <em>color</em> attribute <em>c</em>, but this node is really either red-and-black (if <em>c</em> = <small>RED</small>) or doubly black (if <em>c</em> = <small>BLACK</small>). You can verify the other cases similarly (see Exercise 13.4-6).</p>
<p class="case"><strong><em>Case 1. x’s sibling w is red</em></strong></p>
<p class="noindent">Case 1 (lines 5–8 and <a href="chapter013.xhtml#Fig_13-7">Figure 13.7(a)</a>) occurs when node <em>w</em>, the sibling of node <em>x</em>, is red. Because <em>w</em> is red, it must have black children. This case switches the colors of <em>w</em> and <em>x.p</em> and then performs a left-rotation on <em>x.p</em> without violating any of the red-black properties. The new sibling of <em>x</em>, which is one of <em>w</em>’s children prior to the rotation, is now black, and thus case 1 converts into one of cases 2, 3, or 4.</p>
<p class="space-break">Cases 2, 3, and 4 occur when node <em>w</em> is black and are distinguished by the colors of <em>w</em>’s children.</p>
<p class="case"><strong><em>Case 2. x’s sibling w is black, and both of w’s children are black</em></strong></p>
<p class="noindent">In case 2 (lines 10–11 and <a href="chapter013.xhtml#Fig_13-7">Figure 13.7(b)</a>), both of <em>w</em>’s children are black. Since <em>w</em> is also black, this case removes one black from both <em>x</em> and <em>w</em>, leaving <em>x</em> with only one black and leaving <em>w</em> red. To compensate for <em>x</em> and <em>w</em> each losing one black, <em>x</em>’s parent <em>x.p</em> can take on an extra black. Line 11 does so by moving <em>x</em> up one level, so that the <strong>while</strong> loop repeats with <em>x.p</em> as the new node <em>x</em>. If case 2 enters through case 1, the new node <em>x</em> is red-and-black, since the original <em>x.p</em> was red. Hence, the value <em>c</em> of the <em>color</em> attribute of the new node <em>x</em> is <small>RED</small>, and the loop terminates when it tests the loop condition. Line 44 then colors the new node <em>x</em> (singly) black.</p>
<p class="case"><strong><em>Case 3. x’s sibling w is black, w’s left child is red, and w’s right child is black</em></strong></p>
<p class="noindent">Case 3 (lines 14–17 and <a href="chapter013.xhtml#Fig_13-7">Figure 13.7(c)</a>) occurs when <em>w</em> is black, its left child is red, and its right child is black. This case switches the colors of <em>w</em> and its left child <em>w.left</em> and then performs a right rotation on <em>w</em> without violating any of the red-black properties. The new sibling <em>w</em> of <em>x</em> is now a black node with a red right child, and thus case 3 falls through into case 4.</p>
<p class="case"><strong><em>Case 4. x’s sibling w is black, and w’s right child is red</em></strong></p>
<p class="noindent">Case 4 (lines 18–22 and <a href="chapter013.xhtml#Fig_13-7">Figure 13.7(d)</a>) occurs when node <em>x</em>’s sibling <em>w</em> is black and <em>w</em>’s right child is red. Some color changes and a left rotation on <em>x.p</em> allow the extra black on <em>x</em> to vanish, making it singly black, without violating any of the red-black properties. Line 22 sets <em>x</em> to be the root, and the <strong>while</strong> loop terminates when it next tests the loop condition.</p>
<a id="p354"/>
<p class="level4"><strong>Analysis</strong></p>
<p class="noindent">What is the running time of RB-D<small>ELETE</small>? Since the height of a red-black tree of <em>n</em> nodes is <em>O</em>(lg <em>n</em>), the total cost of the procedure without the call to RB-D<small>ELETE</small>-F<small>IXUP</small> takes <em>O</em>(lg <em>n</em>) time. Within RB-D<small>ELETE</small>-F<small>IXUP</small>, each of cases 1, 3, and 4 lead to termination after performing a constant number of color changes and at most three rotations. Case 2 is the only case in which the <strong>while</strong> loop can be repeated, and then the pointer <em>x</em> moves up the tree at most <em>O</em>(lg <em>n</em>) times, performing no rotations. Thus, the procedure RB-D<small>ELETE</small>-F<small>IXUP</small> takes <em>O</em>(lg <em>n</em>) time and performs at most three rotations, and the overall time for RB-D<small>ELETE</small> is therefore also <em>O</em>(lg <em>n</em>).</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>13.4-1</em></strong></p>
<p class="noindent">Show that if node <em>y</em> in RB-D<small>ELETE</small> is red, then no black-heights change.</p>
<p class="level3"><strong><em>13.4-2</em></strong></p>
<p class="noindent">Argue that after RB-D<small>ELETE</small>-F<small>IXUP</small> executes, the root of the tree must be black.</p>
<p class="level3"><strong><em>13.4-3</em></strong></p>
<p class="noindent">Argue that if in RB-D<small>ELETE</small> both <em>x</em> and <em>x.p</em> are red, then property 4 is restored by the call to RB-D<small>ELETE</small>-F<small>IXUP</small>(<em>T</em>, <em>x</em>).</p>
<p class="level3"><strong><em>13.4-4</em></strong></p>
<p class="noindent">In Exercise 13.3-2 on page 346, you found the red-black tree that results from successively inserting the keys 41, 38, 31, 12, 19, 8 into an initially empty tree. Now show the red-black trees that result from the successive deletion of the keys in the order 8, 12, 19, 31, 38, 41.</p>
<p class="level3"><strong><em>13.4-5</em></strong></p>
<p class="noindent">Which lines of the code for RB-D<small>ELETE</small>-F<small>IXUP</small> might examine or modify the sentinel <em>T.nil</em>?</p>
<p class="level3"><strong><em>13.4-6</em></strong></p>
<p class="noindent">In each of the cases of <a href="chapter013.xhtml#Fig_13-7">Figure 13.7</a>, give the count of black nodes from the root of the subtree shown to the roots of each of the subtrees <em>α</em>, <em>β</em>, …, <em>ζ</em>, and verify that each count remains the same after the transformation. When a node has a <em>color</em> attribute <em>c</em> or <em>c</em>′, use the notation count(<em>c</em>) or count(<em>c</em>′) symbolically in your count.</p>
<p class="level3"><strong><em>13.4-7</em></strong></p>
<p class="noindent">Professors Skelton and Baron worry that at the start of case 1 of RB-D<small>ELETE</small>-F<small>IXUP</small>, the node <em>x.p</em> might not be black. If <em>x.p</em> is not black, then lines 5–6 are <a id="p355"/>wrong. Show that <em>x.p</em> must be black at the start of case 1, so that the professors need not be concerned.</p>
<p class="level3"><strong><em>13.4-8</em></strong></p>
<p class="noindent">A node <em>x</em> is inserted into a red-black tree with RB-I<small>NSERT</small> and then is immediately deleted with RB-D<small>ELETE</small>. Is the resulting red-black tree always the same as the initial red-black tree? Justify your answer.</p>
<p class="level3"><span class="font1">★</span> <strong><em>13.4-9</em></strong></p>
<p class="noindent">Consider the operation RB-E<small>NUMERATE</small>(<em>T</em>, <em>r</em>, <em>a</em>, <em>b</em>), which outputs all the keys <em>k</em> such that <em>a</em> ≤ <em>k</em> ≤ <em>b</em> in a subtree rooted at node <em>r</em> in an <em>n</em>-node red-black tree <em>T</em>. Describe how to implement RB-E<small>NUMERATE</small> in Θ(<em>m</em> + lg <em>n</em>) time, where <em>m</em> is the number of keys that are output. Assume that the keys in <em>T</em> are unique and that the values <em>a</em> and <em>b</em> appear as keys in <em>T</em>. How does your solution change if <em>a</em> and <em>b</em> might not appear in <em>T</em>?</p>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-78"><strong>Problems</strong></p>
<section title="13-1 Persistent dynamic sets">
<p class="level2"><strong><em>13-1     Persistent dynamic sets</em></strong></p>
<p class="noindent">During the course of an algorithm, you sometimes find that you need to maintain past versions of a dynamic set as it is updated. We call such a set <strong><em><span class="blue1">persistent</span></em></strong>. One way to implement a persistent set is to copy the entire set whenever it is modified, but this approach can slow down a program and also consume a lot of space. Sometimes, you can do much better.</p>
<p>Consider a persistent set <em>S</em> with the operations I<small>NSERT</small>, D<small>ELETE</small>, and S<small>EARCH</small>, which you implement using binary search trees as shown in <a href="chapter013.xhtml#Fig_13-8">Figure 13.8(a)</a>. Maintain a separate root for every version of the set. In order to insert the key 5 into the set, create a new node with key 5. This node becomes the left child of a new node with key 7, since you cannot modify the existing node with key 7. Similarly, the new node with key 7 becomes the left child of a new node with key 8 whose right child is the existing node with key 10. The new node with key 8 becomes, in turn, the right child of a new root <em>r</em>′ with key 4 whose left child is the existing node with key 3. Thus, you copy only part of the tree and share some of the nodes with the original tree, as shown in <a href="chapter013.xhtml#Fig_13-8">Figure 13.8(b)</a>.</p>
<p>Assume that each tree node has the attributes <em>key</em>, <em>left</em>, and <em>right</em> but no parent. (See also Exercise 13.3-6 on page 346.)</p>
<p class="nl"><strong><em>a.</em></strong> For a persistent binary search tree (not a red-black tree, just a binary search tree), identify the nodes that need to change to insert or delete a node.</p>
<a id="p356"/>
<div class="divimage">
<p class="fig-imga" id="Fig_13-8"><img alt="art" src="images/Art_P446.jpg"/></p>
<p class="caption"><strong>Figure 13.8 (a)</strong> A binary search tree with keys 2, 3, 4, 7, 8, 10. <strong>(b)</strong> The persistent binary search tree that results from the insertion of key 5. The most recent version of the set consists of the nodes reachable from the root <em>r</em>′, and the previous version consists of the nodes reachable from <em>r</em>. Blue nodes are added when key 5 is inserted.</p>
</div>
<p class="nl"><strong><em>b.</em></strong> Write a procedure P<small>ERSISTENT</small>-T<small>REE</small>-I<small>NSERT</small>(<em>T</em>, <em>z</em>) that, given a persistent binary search tree <em>T</em> and a node <em>z</em> to insert, returns a new persistent tree <em>T</em>′ that is the result of inserting <em>z</em> into <em>T</em>. Assume that you have a procedure C<small>OPY</small>-N<small>ODE</small>(<em>x</em>) that makes a copy of node <em>x</em>, including all of its attributes.</p>
<p class="nl"><strong><em>c.</em></strong> If the height of the persistent binary search tree <em>T</em> is <em>h</em>, what are the time and space requirements of your implementation of P<small>ERSISTENT</small>-T<small>REE</small>-I<small>NSERT</small>? (The space requirement is proportional to the number of nodes that are copied.)</p>
<p class="nl"><strong><em>d.</em></strong> Suppose that you include the parent attribute in each node. In this case, the P<small>ERSISTENT</small>-T<small>REE</small>-I<small>NSERT</small> procedure needs to perform additional copying. Prove that P<small>ERSISTENT</small>-T<small>REE</small>-I<small>NSERT</small> then requires Ω(<em>n</em>) time and space, where <em>n</em> is the number of nodes in the tree.</p>
<p class="nl"><strong><em>e.</em></strong> Show how to use red-black trees to guarantee that the worst-case running time and space are <em>O</em>(lg <em>n</em>) per insertion or deletion. You may assume that all keys are distinct.</p>
</section>
<section title="13-2 Join operation on red-black trees">
<p class="level2"><strong><em>13-2     Join operation on red-black trees</em></strong></p>
<p class="noindent">The <strong><em><span class="blue1">join</span></em></strong> operation takes two dynamic sets <em>S</em><sub>1</sub> and <em>S</em><sub>2</sub> and an element <em>x</em> such that for any <em>x</em><sub>1</sub> ∈ <em>S</em><sub>1</sub> and <em>x</em><sub>2</sub> ∈ <em>S</em><sub>2</sub>, we have <em>x</em><sub>1</sub>.<em>key</em> ≤ <em>x.key</em> ≤ <em>x</em><sub>2</sub>.<em>key</em>. It returns a set <em>S</em> = <em>S</em><sub>1</sub> <span class="font1">⋃</span> {<em>x</em>} <span class="font1">⋃</span> <em>S</em><sub>2</sub>. In this problem, we investigate how to implement the join operation on red-black trees.</p>
<p class="nl"><strong><em>a.</em></strong> Suppose that you store the black-height of a red-black tree <em>T</em> as the new attribute <em>T.bh</em>. Argue that RB-I<small>NSERT</small> and RB-D<small>ELETE</small> can maintain the <em>bh</em> <a id="p357"/>attribute without requiring extra storage in the nodes of the tree and without increasing the asymptotic running times. Show how to determine the black-height of each node visited while descending through <em>T</em>, using <em>O</em>(1) time per node visited.</p>
<p class="noindent1-top">Let <em>T</em><sub>1</sub> and <em>T</em><sub>2</sub> be red-black trees and <em>x</em> be a key value such that for any nodes <em>x</em><sub>1</sub> in <em>T</em><sub>1</sub> and <em>x</em><sub>2</sub> in <em>T</em><sub>2</sub>, we have <em>x</em><sub>1</sub>.<em>key</em> ≤ <em>x.key</em> ≤ <em>x</em><sub>2</sub>.<em>key</em>. You will show how to implement the operation RB-J<small>OIN</small>(<em>T</em><sub>1</sub>, <em>x</em>, <em>T</em><sub>2</sub>), which destroys <em>T</em><sub>1</sub> and <em>T</em><sub>2</sub> and returns a red-black tree <em>T</em> = <em>T</em><sub>1</sub> <span class="font1">⋃</span> {<em>x</em>} <span class="font1">⋃</span> <em>T</em><sub>2</sub>. Let <em>n</em> be the total number of nodes in <em>T</em><sub>1</sub> and <em>T</em><sub>2</sub>.</p>
<p class="nl"><strong><em>b.</em></strong> Assume that <em>T</em><sub>1</sub>.<em>bh</em> ≥ <em>T</em><sub>2</sub>.<em>bh</em>. Describe an <em>O</em>(lg <em>n</em>)-time algorithm that finds a black node <em>y</em> in <em>T</em><sub>1</sub> with the largest key from among those nodes whose black-height is <em>T</em><sub>2</sub>.<em>bh</em>.</p>
<p class="nl"><strong><em>c.</em></strong> Let <em>T<sub>y</sub></em> be the subtree rooted at <em>y</em>. Describe how <em>T<sub>y</sub></em> <span class="font1">⋃</span> {<em>x</em>} <span class="font1">⋃</span> <em>T</em><sub>2</sub> can replace <em>T<sub>y</sub></em> in <em>O</em>(1) time without destroying the binary-search-tree property.</p>
<p class="nl"><strong><em>d.</em></strong> What color should you make <em>x</em> so that red-black properties 1, 3, and 5 are maintained? Describe how to enforce properties 2 and 4 in <em>O</em>(lg <em>n</em>) time.</p>
<p class="nl"><strong><em>e.</em></strong> Argue that no generality is lost by making the assumption in part (b). Describe the symmetric situation that arises when <em>T</em><sub>1</sub>.<em>bh</em> ≤ <em>T</em><sub>2</sub>.<em>bh</em>.</p>
<p class="nl"><strong><em>f.</em></strong> Argue that the running time of RB-J<small>OIN</small> is <em>O</em>(lg <em>n</em>).</p>
</section>
<section title="13-3 AVL trees">
<p class="level2"><strong><em>13-3     AVL trees</em></strong></p>
<p class="noindent">An <strong><em><span class="blue1">AVL tree</span></em></strong> is a binary search tree that is <strong><em><span class="blue1">height balanced</span></em></strong>: for each node <em>x</em>, the heights of the left and right subtrees of <em>x</em> differ by at most 1. To implement an AVL tree, maintain an extra attribute <em>h</em> in each node such that <em>x.h</em> is the height of node <em>x</em>. As for any other binary search tree <em>T</em>, assume that <em>T.root</em> points to the root node.</p>
<p class="nl"><strong><em>a.</em></strong> Prove that an AVL tree with <em>n</em> nodes has height <em>O</em>(lg <em>n</em>). (<em>Hint:</em> Prove that an AVL tree of height <em>h</em> has at least <em>F<sub>h</sub></em> nodes, where <em>F<sub>h</sub></em> is the <em>h</em>th Fibonacci number.)</p>
<p class="nl"><strong><em>b.</em></strong> To insert into an AVL tree, first place a node into the appropriate place in binary search tree order. Afterward, the tree might no longer be height balanced. Specifically, the heights of the left and right children of some node might differ by 2. Describe a procedure B<small>ALANCE</small>(<em>x</em>), which takes a subtree rooted at <em>x</em> whose left and right children are height balanced and have heights that differ <a id="p358"/>by at most 2, so that |<em>x.right.h</em> − <em>x.left.h</em>| ≤ 2, and alters the subtree rooted at <em>x</em> to be height balanced. The procedure should return a pointer to the node that is the root of the subtree after alterations occur. (<em>Hint:</em> Use rotations.)</p>
<p class="nl"><strong><em>c.</em></strong> Using part (b), describe a recursive procedure AVL-I<small>NSERT</small>(<em>T</em>, <em>z</em>) that takes an AVL tree <em>T</em> and a newly created node <em>z</em> (whose key has already been filled in), and adds <em>z</em> into <em>T</em>, maintaining the property that <em>T</em> is an AVL tree. As in T<small>REE</small>-I<small>NSERT</small> from <a href="chapter012.xhtml#Sec_12.3">Section 12.3</a>, assume that <em>z.key</em> has already been filled in and that <em>z.left</em> = <small>NIL</small> and <em>z.right</em> = <small>NIL</small>. Assume as well that <em>z.h</em> = 0.</p>
<p class="nl"><strong><em>d.</em></strong> Show that AVL-I<small>NSERT</small>, run on an <em>n</em>-node AVL tree, takes <em>O</em>(lg <em>n</em>) time and performs <em>O</em>(lg <em>n</em>) rotations.</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-79"><strong>Chapter notes</strong></p>
<p class="noindent">The idea of balancing a search tree is due to Adel’son-Vel’ski<span class="font1">ĭ</span> and Landis [<a epub:type="noteref" href="bibliography001.xhtml#endnote_2">2</a>], who introduced a class of balanced search trees called “AVL trees” in 1962, described in Problem 13-3. Another class of search trees, called “2-3 trees,” was introduced by J. E. Hopcroft (unpublished) in 1970. A 2-3 tree maintains balance by manipulating the degrees of nodes in the tree, where each node has either two or three children. <a href="chapter018.xhtml">Chapter 18</a> covers a generalization of 2-3 trees introduced by Bayer and McCreight [<a epub:type="noteref" href="bibliography001.xhtml#endnote_39">39</a>], called “B-trees.”</p>
<p>Red-black trees were invented by Bayer [<a epub:type="noteref" href="bibliography001.xhtml#endnote_38">38</a>] under the name “symmetric binary B-trees.” Guibas and Sedgewick [<a epub:type="noteref" href="bibliography001.xhtml#endnote_202">202</a>] studied their properties at length and introduced the red/black color convention. Andersson [<a epub:type="noteref" href="bibliography001.xhtml#endnote_16">16</a>] gives a simpler-to-code variant of red-black trees. Weiss [<a epub:type="noteref" href="bibliography001.xhtml#endnote_451">451</a>] calls this variant AA-trees. An AA-tree is similar to a red-black tree except that left children can never be red.</p>
<p>Sedgewick and Wayne [<a epub:type="noteref" href="bibliography001.xhtml#endnote_402">402</a>] present red-black trees as a modified version of 2-3 trees in which a node with three children is split into two nodes with two children each. One of these nodes becomes the left child of the other, and only left children can be red. They call this structure a “left-leaning red-black binary search tree.” Although the code for left-leaning red-black binary search trees is more concise than the red-black tree pseudocode in this chapter, operations on left-leaning red-black binary search trees do not limit the number of rotations per operation to a constant. This distinction will matter in <a href="chapter017.xhtml">Chapter 17</a>.</p>
<p>Treaps, a hybrid of binary search trees and heaps, were proposed by Seidel and Aragon [<a epub:type="noteref" href="bibliography001.xhtml#endnote_404">404</a>]. They are the default implementation of a dictionary in LEDA [<a epub:type="noteref" href="bibliography001.xhtml#endnote_324">324</a>], which is a well-implemented collection of data structures and algorithms.</p>
<p>There are many other variations on balanced binary trees, including weight-balanced trees [<a epub:type="noteref" href="bibliography001.xhtml#endnote_344">344</a>], <em>k</em>-neighbor trees [<a epub:type="noteref" href="bibliography001.xhtml#endnote_318">318</a>], and scapegoat trees [<a epub:type="noteref" href="bibliography001.xhtml#endnote_174">174</a>]. Perhaps <a id="p359"/>the most intriguing are the “splay trees” introduced by Sleator and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_418">418</a>], which are “self-adjusting.” (See Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_429">429</a>] for a good description of splay trees.) Splay trees maintain balance without any explicit balance condition such as color. Instead, “splay operations” (which involve rotations) are performed within the tree every time an access is made. The amortized cost (see <a href="chapter016.xhtml">Chapter 16</a>) of each operation on an <em>n</em>-node tree is <em>O</em>(lg <em>n</em>). Splay trees have been conjectured to perform within a constant factor of the best offline rotation-based tree. The best known competitive ratio (see <a href="chapter027.xhtml">Chapter 27</a>) for a rotation-based tree is the Tango Tree of Demaine et al. [<a epub:type="noteref" href="bibliography001.xhtml#endnote_109">109</a>].</p>
<p>Skip lists [<a epub:type="noteref" href="bibliography001.xhtml#endnote_369">369</a>] provide an alternative to balanced binary trees. A skip list is a linked list that is augmented with a number of additional pointers. Each dictionary operation runs in <em>O</em>(lg <em>n</em>) expected time on a skip list of <em>n</em> items.</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> Although we try to avoid gendered language in this book, the English language lacks a gender-neutral word for a parent’s sibling.</p>
<p class="footnote1" id="footnote_2"><a href="#footnote_ref_2"><sup>2</sup></a> If property 5 holds, we can assume that paths from the roots of <em>γ</em>, <em>δ</em>, <em><span class="font1">ϵ</span></em>, and <em>ζ</em> down to leaves contain one more black than do paths from the roots of <em>α</em> and <em>β</em> down to leaves.</p>
</section>
</section>
</div>
</body>
</html>