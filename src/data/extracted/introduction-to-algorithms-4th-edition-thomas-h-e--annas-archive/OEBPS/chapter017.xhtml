<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p480"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="17 Augmenting Data Structures">
<p class="chapter-title"><a href="toc.xhtml#chap-17"><strong><span class="blue1">17        Augmenting Data Structures</span></strong></a></p>
<p class="noindent">Some solutions require no more than a “textbook” data structure—such as a doubly linked list, a hash table, or a binary search tree—but many others require a dash of creativity. Rarely will you need to create an entirely new type of data structure, though. More often, you can augment a textbook data structure by storing additional information in it. You can then program new operations for the data structure to support your application. Augmenting a data structure is not always straightforward, however, since the added information must be updated and maintained by the ordinary operations on the data structure.</p>
<p>This chapter discusses two data structures based on red-black trees that are augmented with additional information. <a href="chapter017.xhtml#Sec_17.1">Section 17.1</a> describes a data structure that supports general order-statistic operations on a dynamic set: quickly finding the <em>i</em>th smallest number or the rank of a given element. <a href="chapter017.xhtml#Sec_17.2">Section 17.2</a> abstracts the process of augmenting a data structure and provides a theorem that you can use when augmenting red-black trees. <a href="chapter017.xhtml#Sec_17.3">Section 17.3</a> uses this theorem to help design a data structure for maintaining a dynamic set of intervals, such as time intervals. You can use this data structure to quickly find an interval that overlaps a given query interval.</p>
<p class="line1"/>
<section title="17.1 Dynamic order statistics">
<a id="Sec_17.1"/>
<p class="level1" id="h1-101"><a href="toc.xhtml#Rh1-101"><strong>17.1    Dynamic order statistics</strong></a></p>
<p class="noindent"><a href="chapter009.xhtml">Chapter 9</a> introduced the notion of an order statistic. Specifically, the <em>i</em>th order statistic of a set of <em>n</em> elements, where <em>i</em> ∈ {1, 2, … , <em>n</em>}, is simply the element in the set with the <em>i</em>th smallest key. In <a href="chapter009.xhtml">Chapter 9</a>, you saw how to determine any order statistic in <em>O</em>(<em>n</em>) time from an unordered set. This section shows how to modify red-black trees so that you can determine any order statistic for a dynamic set in <em>O</em>(lg <em>n</em>) time and also compute the <span class="blue"><strong><em>rank</em></strong></span> of an element—its position in the linear order of the set—in <em>O</em>(lg <em>n</em>) time.</p>
<a id="p481"/>
<div class="divimage">
<p class="fig-imga" id="Fig_17-1"><img alt="art" class="width100" src="images/Art_P533.jpg"/></p>
<p class="caption"><strong>Figure 17.1</strong> An order-statistic tree, which is an augmented red-black tree. In addition to its usual attributes, each node <em>x</em> has an attribute <em>x</em>.<em>size</em>, which is the number of nodes, other than the sentinel, in the subtree rooted at <em>x</em>.</p>
</div>
<p><a href="chapter017.xhtml#Fig_17-1">Figure 17.1</a> shows a data structure that can support fast order-statistic operations. An <span class="blue"><strong><em>order-statistic tree</em></strong></span> <em>T</em> is simply a red-black tree with additional information stored in each node. Each node <em>x</em> contains the usual red-black tree attributes <em>x</em>.<em>key</em>, <em>x</em>.<em>color</em>, <em>x</em>.<em>p</em>, <em>x</em>.<em>left</em>, and <em>x</em>.<em>right</em>, along with a new attribute, <em>x</em>.<em>size</em>. This attribute contains the number of internal nodes in the subtree rooted at <em>x</em> (including <em>x</em> itself, but not including any sentinels), that is, the size of the subtree. If we define the sentinel’s size to be 0—that is, we set <em>T</em>.<em>nil</em>.<em>size</em> to be 0—then we have the identity</p>
<p class="eql"><em>x</em>.<em>size</em> = <em>x</em>.<em>left</em>.<em>size</em> + <em>x</em>.<em>right</em>.<em>size</em> + 1.</p>
<p>Keys need not be distinct in an order-statistic tree. For example, the tree in <a href="chapter017.xhtml#Fig_17-1">Figure 17.1</a> has two keys with value 14 and two keys with value 21. When equal keys are present, the above notion of rank is not well defined. We remove this ambiguity for an order-statistic tree by defining the rank of an element as the position at which it would be printed in an inorder walk of the tree. In <a href="chapter017.xhtml#Fig_17-1">Figure 17.1</a>, for example, the key 14 stored in a black node has rank 5, and the key 14 stored in a red node has rank 6.</p>
<p class="level4"><strong>Retrieving the element with a given rank</strong></p>
<p class="noindent">Before we show how to maintain the size information during insertion and deletion, let’s see how to implement two order-statistic queries that use this additional information. We begin with an operation that retrieves the element with a given rank. The procedure OS-S<small>ELECT</small>(<em>x</em>, <em>i</em>) on the following page returns a pointer to the node containing the <em>i</em>th smallest key in the subtree rooted at <em>x</em>. To find the node with the <em>i</em>th smallest key in an order-statistic tree <em>T</em>, call OS-S<small>ELECT</small>(<em>T</em>.<em>root</em>, <em>i</em>).</p>
<p>Here is how OS-S<small>ELECT</small> works. Line 1 computes <em>r</em>, the rank of node <em>x</em> within the subtree rooted at <em>x</em>. The value of <em>x</em>.<em>left</em>.<em>size</em> is the number of nodes that come <a id="p482"/>before <em>x</em> in an inorder tree walk of the subtree rooted at <em>x</em>. Thus, <em>x</em>.<em>left</em>.<em>size</em> + 1 is the rank of <em>x</em> within the subtree rooted at <em>x</em>. If <em>i</em> = <em>r</em>, then node <em>x</em> is the <em>i</em>th smallest element, and so line 3 returns <em>x</em>. If <em>i &lt; r</em>, then the <em>i</em>th smallest element resides in <em>x</em>’s left subtree, and therefore, line 5 recurses on <em>x</em>.<em>left</em>. If <em>i &gt; r</em>, then the <em>i</em>th smallest element resides in <em>x</em>’s right subtree. Since the subtree rooted at <em>x</em> contains <em>r</em> elements that come before <em>x</em>’s right subtree in an inorder tree walk, the <em>i</em>th smallest element in the subtree rooted at <em>x</em> is the (<em>i</em> − <em>r</em>)th smallest element in the subtree rooted at <em>x</em>.<em>right</em>. Line 6 determines this element recursively.</p>
<div class="pull-quote1">
<p class="box-heading">OS-S<small>ELECT</small>(<em>x</em>, <em>i</em>)</p>
<table class="table1a1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><em>r</em> = <em>x</em>.<em>left</em>.<em>size</em> + 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> rank of <em>x</em> within the subtree rooted at <em>x</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1" colspan="2"><p class="noindent"><strong>if</strong> <em>i</em> == <em>r</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>return</strong> <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1" colspan="2"><p class="noindent"><strong>elseif</strong> <em>i</em> &lt; <em>r</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>return</strong> OS-S<small>ELECT</small>(<em>x</em>.<em>left</em>, <em>i</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1" colspan="2"><p class="noindent"><strong>else return</strong> OS-S<small>ELECT</small>(<em>x</em>.<em>right</em>, <em>i</em> − <em>r</em>)</p></td>
</tr>
</table>
</div>
<p>As an example of how OS-S<small>ELECT</small> operates, consider a search for the 17th smallest element in the order-statistic tree of <a href="chapter017.xhtml#Fig_17-1">Figure 17.1</a>. The search starts with <em>x</em> as the root, whose key is 26, and with <em>i</em> = 17. Since the size of 26’s left subtree is 12, its rank is 13. Thus, the node with rank 17 is the 17 − 13 = 4th smallest element in 26’s right subtree. In the recursive call, <em>x</em> is the node with key 41, and <em>i</em> = 4. Since the size of 41’s left subtree is 5, its rank within its subtree is 6. Therefore, the node with rank 4 is the 4th smallest element in 41’s left subtree. In the recursive call, <em>x</em> is the node with key 30, and its rank within its subtree is 2. The procedure recurses once again to find the 4 − 2 = 2nd smallest element in the subtree rooted at the node with key 38. Its left subtree has size 1, which means it is the second smallest element. Thus, the procedure returns a pointer to the node with key 38.</p>
<p>Because each recursive call goes down one level in the order-statistic tree, the total time for OS-S<small>ELECT</small> is at worst proportional to the height of the tree. Since the tree is a red-black tree, its height is <em>O</em>(lg <em>n</em>), where <em>n</em> is the number of nodes. Thus, the running time of OS-S<small>ELECT</small> is <em>O</em>(lg <em>n</em>) for a dynamic set of <em>n</em> elements.</p>
<p class="level4"><strong>Determining the rank of an element</strong></p>
<p class="noindent">Given a pointer to a node <em>x</em> in an order-statistic tree <em>T</em>, the procedure OS-R<small>ANK</small> on the facing page returns the position of <em>x</em> in the linear order determined by an inorder tree walk of <em>T</em>.</p>
<a id="p483"/>
<div class="pull-quote1">
<p class="box-heading">OS-R<small>ANK</small>(<em>T</em>, <em>x</em>)</p>
<table class="table1a1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><em>r</em> = <em>x</em>.<em>left</em>.<em>size</em> + 1</p></td>
<td class="td1" colspan="2"><span class="red"><strong>//</strong> rank of <em>x</em> within the subtree rooted at <em>x</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="noindent"><em>y</em> = <em>x</em></p></td>
<td class="td1" colspan="2"><span class="red"><strong>//</strong> root of subtree being examined</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1" colspan="3"><p class="noindent"><strong>while</strong> <em>y</em> ≠ <em>T</em>.<em>root</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>y</em> == <em>y</em>.<em>p</em>.<em>right</em></p></td>
<td class="td1"><p> </p></td>
<td class="td1"><span class="red"><strong>//</strong> if root of a right subtree …</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p3"><em>r</em> = <em>r</em> + <em>y</em>.<em>p</em>.<em>left</em>.<em>size</em> + 1</p></td>
<td class="td1"><p> </p></td>
<td class="td1"><span class="red"><strong>//</strong> … add in parent and its left subtree</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><p class="p2"><em>y</em> = <em>y</em>.<em>p</em></p></td>
<td class="td1"><p> </p></td>
<td class="td1"><span class="red"><strong>//</strong> move <em>y</em> toward the root</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">7</span></td>
<td class="td1" colspan="3"><p class="noindent"><strong>return</strong> <em>r</em></p></td>
</tr>
</table>
</div>
<p>The OS-R<small>ANK</small> procedure works as follows. You can think of node <em>x</em>’s rank as the number of nodes preceding <em>x</em> in an inorder tree walk, plus 1 for <em>x</em> itself. OS-R<small>ANK</small> maintains the following loop invariant:</p>
<div class="pull-quote">
<p class="pq-noindent">At the start of each iteration of the <strong>while</strong> loop of lines 3–6, <em>r</em> is the rank of <em>x</em>.<em>key</em> in the subtree rooted at node <em>y</em>.</p>
</div>
<p class="noindent">We use this loop invariant to show that OS-R<small>ANK</small> works correctly as follows:</p>
<p class="para-hang1"><strong>Initialization:</strong> Prior to the first iteration, line 1 sets <em>r</em> to be the rank of <em>x</em>.<em>key</em> within the subtree rooted at <em>x</em>. Setting <em>y</em> = <em>x</em> in line 2 makes the invariant true the first time the test in line 3 executes.</p>
<p class="para-hang1"><strong>Maintenance:</strong> At the end of each iteration of the <strong>while</strong> loop, line 6 sets <em>y</em> = <em>y</em>.<em>p</em>. Thus, we must show that if <em>r</em> is the rank of <em>x</em>.<em>key</em> in the subtree rooted at <em>y</em> at the start of the loop body, then <em>r</em> is the rank of <em>x</em>.<em>key</em> in the subtree rooted at <em>y</em>.<em>p</em> at the end of the loop body. In each iteration of the <strong>while</strong> loop, consider the subtree rooted at <em>y</em>.<em>p</em>. The value of <em>r</em> already includes the number of nodes in the subtree rooted at node <em>y</em> that precede <em>x</em> in an inorder walk, and so the procedure must add the nodes in the subtree rooted at <em>y</em>’s sibling that precede <em>x</em> in an inorder walk, plus 1 for <em>y</em>.<em>p</em> if it, too, precedes <em>x</em>. If <em>y</em> is a left child, then neither <em>y</em>.<em>p</em> nor any node in <em>y</em>.<em>p</em>’s right subtree precedes <em>x</em>, and so OS-R<small>ANK</small> leaves <em>r</em> alone. Otherwise, <em>y</em> is a right child and all the nodes in <em>y</em>.<em>p</em>’s left subtree precede <em>x</em>, as does <em>y</em>.<em>p</em> itself. In this case, line 5 adds <em>y</em>.<em>p</em>.<em>left</em>.<em>size</em> + 1 to the current value of <em>r</em>.</p>
<p class="para-hang1"><strong>Termination:</strong> Because each iteration of the loop moves <em>y</em> toward the root and the loop terminates when <em>y</em> = <em>T</em>.<em>root</em>, the loop eventually terminates. Moreover, the subtree rooted at <em>y</em> is the entire tree. Thus, the value of <em>r</em> is the rank of <em>x</em>.<em>key</em> in the entire tree.</p>
<p class="space-break">As an example, when OS-R<small>ANK</small> runs on the order-statistic tree of <a href="chapter017.xhtml#Fig_17-1">Figure 17.1</a> to find the rank of the node with key 38, the following sequence of values of <em>y</em>.<em>key</em> and <em>r</em> occurs at the top of the <strong>while</strong> loop:</p>
<a id="p484"/>
<table class="table3a">
<tr>
<td class="td1b"><p class="center">iteration</p></td>
<td class="td1b"><p class="center"><em>y</em>.<em>key</em></p></td>
<td class="td1b"><p class="center"><em>r</em></p></td>
</tr>
<tr>
<td class="td1"><p class="center">1</p></td>
<td class="td1"><p class="center">38</p></td>
<td class="td1"><p class="center">2</p></td>
</tr>
<tr>
<td class="td1"><p class="center">2</p></td>
<td class="td1"><p class="center">30</p></td>
<td class="td1"><p class="center">4</p></td>
</tr>
<tr>
<td class="td1"><p class="center">3</p></td>
<td class="td1"><p class="center">41</p></td>
<td class="td1"><p class="center">4</p></td>
</tr>
<tr>
<td class="td1"><p class="center">4</p></td>
<td class="td1"><p class="center">26</p></td>
<td class="td1"><p class="center">17</p></td>
</tr>
</table>
<p class="noindent">The procedure returns the rank 17.</p>
<p>Since each iteration of the <strong>while</strong> loop takes <em>O</em>(1) time, and <em>y</em> goes up one level in the tree with each iteration, the running time of OS-R<small>ANK</small> is at worst proportional to the height of the tree: <em>O</em>(lg <em>n</em>) on an <em>n</em>-node order-statistic tree.</p>
<p class="level4"><strong>Maintaining subtree sizes</strong></p>
<p class="noindent">Given the <em>size</em> attribute in each node, OS-S<small>ELECT</small> and OS-R<small>ANK</small> can quickly compute order-statistic information. But if the basic modifying operations on red-black trees cannot efficiently maintain the <em>size</em> attribute, our work will have been for naught. Let’s see how to maintain subtree sizes for both insertion and deletion without affecting the asymptotic running time of either operation.</p>
<p>Recall from <a href="chapter013.xhtml#Sec_13.3">Section 13.3</a> that insertion into a red-black tree consists of two phases. The first phase goes down the tree from the root, inserting the new node as a child of an existing node. The second phase goes up the tree, changing colors and performing rotations to maintain the red-black properties.</p>
<p>To maintain the subtree sizes in the first phase, simply increment <em>x</em>.<em>size</em> for each node <em>x</em> on the simple path traversed from the root down toward the leaves. The new node added gets a <em>size</em> of 1. Since there are <em>O</em>(lg <em>n</em>) nodes on the traversed path, the additional cost of maintaining the <em>size</em> attributes is <em>O</em>(lg <em>n</em>).</p>
<p>In the second phase, the only structural changes to the underlying red-black tree are caused by rotations, of which there are at most two. Moreover, a rotation is a local operation: only two nodes have their <em>size</em> attributes invalidated. The link around which the rotation is performed is incident on these two nodes. Referring to the code for L<small>EFT</small>-R<small>OTATE</small>(<em>T</em>, <em>x</em>) on page 336, add the following lines:</p>
<div class="pull-quote1">
<table class="table1">
<tr>
<td class="td1w">13</td>
<td class="td1"><em>y</em>.<em>size</em> = <em>x</em>.<em>size</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">14</span></td>
<td class="td1"><em>x</em>.<em>size</em> = <em>x</em>.<em>left</em>.<em>size</em> + <em>x</em>.<em>right</em>.<em>size</em> + 1</td>
</tr>
</table>
</div>
<p class="noindent"><a href="chapter017.xhtml#Fig_17-2">Figure 17.2</a> illustrates how the attributes are updated. The change to R<small>IGHT</small>-R<small>OTATE</small> is symmetric.</p>
<p>Since inserting into a red-black tree requires at most two rotations, updating the <em>size</em> attributes in the second phase costs only <em>O</em>(1) additional time. Thus, the total time for insertion into an <em>n</em>-node order-statistic tree is <em>O</em>(lg <em>n</em>), which is asymptotically the same as for an ordinary red-black tree.</p>
<a id="p485"/>
<div class="divimage">
<p class="fig-imga" id="Fig_17-2"><img alt="art" src="images/Art_P534.jpg"/></p>
<p class="caption"><strong>Figure 17.2</strong> Updating subtree sizes during rotations. The updates are local, requiring only the <em>size</em> information stored in <em>x</em>, <em>y</em>, and the roots of the subtrees shown as triangles.</p>
</div>
<p>Deletion from a red-black tree also consists of two phases: the first operates on the underlying search tree, and the second causes at most three rotations and otherwise performs no structural changes. (See <a href="chapter013.xhtml#Sec_13.4">Section 13.4</a>.) The first phase removes one node <em>z</em> from the tree and could move at most two other nodes within the tree (nodes <em>y</em> and <em>x</em> in <a href="chapter012.xhtml#Fig_12-4">Figure 12.4</a> on page 323). To update the subtree sizes, simply traverse a simple path from the lowest node that moves (starting from its original position within the tree) up to the root, decrementing the <em>size</em> attribute of each node on the path. Since this path has length <em>O</em>(lg <em>n</em>) in an <em>n</em>-node red-black tree, the additional time spent maintaining <em>size</em> attributes in the first phase is <em>O</em>(lg <em>n</em>). For the <em>O</em>(1) rotations in the second phase of deletion, handle them in the same manner as for insertion. Thus, both insertion and deletion, including maintaining the <em>size</em> attributes, take <em>O</em>(lg <em>n</em>) time for an <em>n</em>-node order-statistic tree.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>17.1-1</em></strong></p>
<p class="noindent">Show how OS-S<small>ELECT</small>(<em>T</em>.<em>root</em>, 10) operates on the red-black tree <em>T</em> shown in <a href="chapter017.xhtml#Fig_17-1">Figure 17.1</a>.</p>
<p class="level3"><strong><em>17.1-2</em></strong></p>
<p class="noindent">Show how OS-R<small>ANK</small>(<em>T</em>, <em>x</em>) operates on the red-black tree <em>T</em> shown in <a href="chapter017.xhtml#Fig_17-1">Figure 17.1</a> and the node <em>x</em> with <em>x</em>.<em>key</em> = 35.</p>
<p class="level3"><strong><em>17.1-3</em></strong></p>
<p class="noindent">Write a nonrecursive version of OS-S<small>ELECT</small>.</p>
<p class="level3"><strong><em>17.1-4</em></strong></p>
<p class="noindent">Write a procedure OS-K<small>EY</small>-R<small>ANK</small>(<em>T</em>, <em>k</em>) that takes an order-statistic tree <em>T</em> and a key <em>k</em> and returns the rank of <em>k</em> in the dynamic set represented by <em>T</em>. Assume that the keys of <em>T</em> are distinct.</p>
<a id="p486"/>
<p class="level3"><strong><em>17.1-5</em></strong></p>
<p class="noindent">Given an element <em>x</em> in an <em>n</em>-node order-statistic tree and a natural number <em>i</em>, show how to determine the <em>i</em>th successor of <em>x</em> in the linear order of the tree in <em>O</em>(lg <em>n</em>) time.</p>
<p class="level3"><strong><em>17.1-6</em></strong></p>
<p class="noindent">The procedures OS-S<small>ELECT</small> and OS-R<small>ANK</small> use the <em>size</em> attribute of a node only to compute a rank. Suppose that you store in each node its rank in the subtree of which it is the root instead of the <em>size</em> attribute. Show how to maintain this information during insertion and deletion. (Remember that these two operations can cause rotations.)</p>
<p class="level3"><strong><em>17.1-7</em></strong></p>
<p class="noindent">Show how to use an order-statistic tree to count the number of inversions (see Problem 2-4 on page 47) in an array of <em>n</em> distinct elements in <em>O</em>(<em>n</em> lg <em>n</em>) time.</p>
<p class="level3"><span class="font1">★</span> <strong><em>17.1-8</em></strong></p>
<p class="noindent">Consider <em>n</em> chords on a circle, each defined by its endpoints. Describe an <em>O</em>(<em>n</em> lg <em>n</em>)-time algorithm to determine the number of pairs of chords that intersect inside the circle. (For example, if the <em>n</em> chords are all diameters that meet at the center, then the answer is <img alt="art" src="images/Art_P535.jpg"/>.) Assume that no two chords share an endpoint.</p>
</section>
<p class="line1"/>
<section title="17.2 How to augment a data structure">
<a id="Sec_17.2"/>
<p class="level1" id="h1-102"><a href="toc.xhtml#Rh1-102"><strong>17.2    How to augment a data structure</strong></a></p>
<p class="noindent">The process of augmenting a basic data structure to support additional functionality occurs quite frequently in algorithm design. We’ll use it again in the next section to design a data structure that supports operations on intervals. This section examines the steps involved in such augmentation. It includes a useful theorem that allows you to augment red-black trees easily in many cases.</p>
<p>You can break the process of augmenting a data structure into four steps:</p>
<ol class="olnoindent" epub:type="list">
<li>Choose an underlying data structure.</li>
<li class="litop">Determine additional information to maintain in the underlying data structure.</li>
<li class="litop">Verify that you can maintain the additional information for the basic modifying operations on the underlying data structure.</li>
<li class="litop">Develop new operations.</li></ol>
<p class="noindent">As with any prescriptive design method, you’ll rarely be able to follow the steps precisely in the order given. Most design work contains an element of trial and error, and progress on all steps usually proceeds in parallel. There is no point, <a id="p487"/>for example, in determining additional information and developing new operations (steps 2 and 4) if you cannot maintain the additional information efficiently. Nevertheless, this four-step method provides a good focus for your efforts in augmenting a data structure, and it is also a good framework for documenting an augmented data structure.</p>
<p>We followed these four steps in <a href="chapter017.xhtml#Sec_17.1">Section 17.1</a> to design order-statistic trees. For step 1, we chose red-black trees as the underlying data structure. Red-black trees seemed like a good starting point because they efficiently support other dynamic-set operations on a total order, such as M<small>INIMUM</small>, M<small>AXIMUM</small>, S<small>UCCESSOR</small>, and P<small>REDECESSOR</small>.</p>
<p>In Step 2, we added the <em>size</em> attribute, so that each node <em>x</em> stores the size of the subtree rooted at <em>x</em>. Generally, the additional information makes operations more efficient. For example, it is possible to implement OS-S<small>ELECT</small> and OS-R<small>ANK</small> using just the keys stored in the tree, but then they would not run in <em>O</em>(lg <em>n</em>) time. Sometimes, the additional information is pointer information rather than data, as in Exercise 17.2-1.</p>
<p>For step 3, we ensured that insertion and deletion can maintain the <em>size</em> attributes while still running in <em>O</em>(lg <em>n</em>) time. Ideally, you would like to update only a few elements of the data structure in order to maintain the additional information. For example, if each node simply stores its rank in the tree, the OS-S<small>ELECT</small> and OS-R<small>ANK</small> procedures run quickly, but inserting a new minimum element might cause a change to this information in every node of the tree. Because we chose to store subtree sizes instead, inserting a new element causes information to change in only <em>O</em>(lg <em>n</em>) nodes.</p>
<p>In Step 4, we developed the operations OS-S<small>ELECT</small> and OS-R<small>ANK</small>. After all, the need for new operations is why anyone bothers to augment a data structure in the first place. Occasionally, rather than developing new operations, you can use the additional information to expedite existing ones, as in Exercise 17.2-1.</p>
<p class="level4"><strong>Augmenting red-black trees</strong></p>
<p class="noindent">When red-black trees underlie an augmented data structure, we can prove that insertion and deletion can always efficiently maintain certain kinds of additional information, thereby simplifying step 3. The proof of the following theorem is similar to the argument from <a href="chapter017.xhtml#Sec_17.1">Section 17.1</a> that we can maintain the <em>size</em> attribute for order-statistic trees.</p>
<p class="theorem"><strong><em>Theorem 17.1 (Augmenting a red-black tree)</em></strong></p>
<p class="noindent">Let <em>f</em> be an attribute that augments a red-black tree <em>T</em> of <em>n</em> nodes, and suppose that the value of <em>f</em> for each node <em>x</em> depends only the information in nodes <em>x</em>, <em>x</em>.<em>left</em>, and <em>x</em>.<em>right</em> (possibly including <em>x</em>.<em>left</em>.<em>f</em> and <em>x</em>.<em>right</em>.<em>f</em>), and that the value of <em>x</em>.<em>f</em> can <a id="p488"/>be computed from this information in <em>O</em>(1) time. Then, the insertion and deletion operations can maintain the values of <em>f</em> in all nodes of <em>T</em> without asymptotically affecting the <em>O</em>(lg <em>n</em>) running times of these operations.</p>
<p class="proof"><strong><em>Proof</em></strong>   The main idea of the proof is that a change to an <em>f</em> attribute in a node <em>x</em> propagates only to ancestors of <em>x</em> in the tree. That is, changing <em>x</em>.<em>f</em> may require <em>x</em>.<em>p</em>.<em>f</em> to be updated, but nothing else; updating <em>x</em>.<em>p</em>.<em>f</em> may require <em>x</em>.<em>p</em>.<em>p</em>.<em>f</em> to be updated, but nothing else; and so on up the tree. After updating <em>T</em>.<em>root</em>.<em>f</em>, no other node depends on the new value, and so the process terminates. Since the height of a red-black tree is <em>O</em>(lg <em>n</em>), changing an <em>f</em> attribute in a node costs <em>O</em>(lg <em>n</em>) time in updating all nodes that depend on the change.</p>
<p>As we saw in <a href="chapter013.xhtml#Sec_13.3">Section 13.3</a>, insertion of a node <em>x</em> into red-black tree <em>T</em> consists of two phases. If the tree <em>T</em> is empty, then the first phase simply makes <em>x</em> be the root of <em>T</em>. If <em>T</em> is not empty, then the first phase inserts <em>x</em> as a child of an existing node. Because we assume that the value of <em>x</em>.<em>f</em> depends only on information in the other attributes of <em>x</em> itself and the information in <em>x</em>’s children, and because <em>x</em>’s children are both the sentinel <em>T</em>.<em>nil</em>, it takes only <em>O</em>(1) time to compute the value of <em>x</em>.<em>f</em>. Having computed <em>x</em>.<em>f</em>, the change propagates up the tree. Thus, the total time for the first phase of insertion is <em>O</em>(lg <em>n</em>). During the second phase, the only structural changes to the tree come from rotations. Since only two nodes change in a rotation, but a change to an attribute might need to propagate up to the root, the total time for updating the <em>f</em> attributes is <em>O</em>(lg <em>n</em>) per rotation. Since the number of rotations during insertion is at most two, the total time for insertion is <em>O</em>(lg <em>n</em>).</p>
<p>Like insertion, deletion has two phases, as <a href="chapter013.xhtml#Sec_13.4">Section 13.4</a> discusses. In the first phase, changes to the tree occur when a node is deleted, and at most two other nodes could move within the tree. Propagating the updates to <em>f</em> caused by these changes costs at most <em>O</em>(lg <em>n</em>), since the changes modify the tree locally along a simple path from the lowest changed node to the root. Fixing up the red-black tree during the second phase requires at most three rotations, and each rotation requires at most <em>O</em>(lg <em>n</em>) time to propagate the updates to <em>f</em>. Thus, like insertion, the total time for deletion is <em>O</em>(lg <em>n</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">In many cases, such as maintaining the <em>size</em> attributes in order-statistic trees, the cost of updating after a rotation is <em>O</em>(1), rather than the <em>O</em>(lg <em>n</em>) derived in the proof of Theorem 17.1. Exercise 17.2-3 gives an example.</p>
<p>On the other hand, when an update after a rotation requires a traversal all the way up to the root, it is important that insertion into and deletion from a red-black tree require a constant number of rotations. The chapter notes for <a href="chapter013.xhtml">Chapter 13</a> list other schemes for balancing search trees that do not bound the number of rotations per insertion or deletion by a constant. If each operation might require Θ(lg <em>n</em>) rotations <a id="p489"/>and each rotation traverses a path up to the root, then a single operation could require Θ(lg<sup>2</sup><em>n</em>) time, rather than the <em>O</em>(lg <em>n</em>) time bound given by Theorem 17.1.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>17.2-1</em></strong></p>
<p class="noindent">Show, by adding pointers to the nodes, how to support each of the dynamic-set queries M<small>INIMUM</small>, M<small>AXIMUM</small>, S<small>UCCESSOR</small>, and P<small>REDECESSOR</small> in <em>O</em>(1) worst-case time on an augmented order-statistic tree. The asymptotic performance of other operations on order-statistic trees should not be affected.</p>
<p class="level3"><strong><em>17.2-2</em></strong></p>
<p class="noindent">Can you maintain the black-heights of nodes in a red-black tree as attributes in the nodes of the tree without affecting the asymptotic performance of any of the red-black tree operations? Show how, or argue why not. How about maintaining the depths of nodes?</p>
<p class="level3"><strong><em>17.2-3</em></strong></p>
<p class="noindent">Let ⊗ be an associative binary operator, and let <em>a</em> be an attribute maintained in each node of a red-black tree. Suppose that you want to include in each node <em>x</em> an additional attribute <em>f</em> such that <em>x</em>.<em>f</em> = <em>x</em><sub>1</sub>.<em>a</em> ⊗ <em>x</em><sub>2</sub>.<em>a</em> ⊗ … ⊗ <em>x<sub>m</sub></em>.<em>a</em>, where <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, … , <em>x<sub>m</sub></em> is the inorder listing of nodes in the subtree rooted at <em>x</em>. Show how to update the <em>f</em> attributes in <em>O</em>(1) time after a rotation. Modify your argument slightly to apply it to the <em>size</em> attributes in order-statistic trees.</p>
</section>
<p class="line1"/>
<section title="17.3 Interval trees">
<a id="Sec_17.3"/>
<p class="level1" id="h1-103"><a href="toc.xhtml#Rh1-103"><strong>17.3    Interval trees</strong></a></p>
<p class="noindent">This section shows how to augment red-black trees to support operations on dynamic sets of intervals. In this section, we’ll assume that intervals are closed. Extending the results to open and half-open intervals is conceptually straightforward. (See page 1157 for definitions of closed, open, and half-open intervals.)</p>
<p>Intervals are convenient for representing events that each occupy a continuous period of time. For example, you could query a database of time intervals to find out which events occurred during a given interval. The data structure in this section provides an efficient means for maintaining such an interval database.</p>
<p>A simple way to represent an interval [<em>t</em><sub>1</sub>, <em>t</em><sub>2</sub>] is as an object <em>i</em> with attributes <em>i</em>.<em>low</em> = <em>t</em><sub>1</sub> (the <span class="blue"><strong><em>low endpoint</em></strong></span>) and <em>i</em>.<em>high</em> = <em>t</em><sub>2</sub> (the <span class="blue"><strong><em>high endpoint</em></strong></span>). We say that intervals <em>i</em> and <em>i</em>′ <span class="blue"><strong><em>overlap</em></strong></span> if <em>i</em> ∩<em>i</em>′ ≠ ∅, that is, if <em>i</em>.<em>low</em> ≤ <em>i</em>′.<em>high</em> and <em>i</em>′.<em>low</em> ≤ <em>i</em>.<em>high</em>.</p>
<a id="p490"/>
<div class="divimage">
<p class="fig-imga" id="Fig_17-3"><img alt="art" src="images/Art_P536.jpg"/></p>
<p class="caption"><strong>Figure 17.3</strong> The interval trichotomy for two closed intervals <em>i</em> and <em>i</em>′. <strong>(a)</strong> If <em>i</em> and <em>i</em>′ overlap, there are four situations, and in each, <em>i</em>.<em>low</em> ≤ <em>i</em>′.<em>high</em> and <em>i</em>′.<em>low</em> ≤ <em>i</em>.<em>high</em>. <strong>(b)</strong> The intervals do not overlap, and <em>i</em>.<em>high &lt; i</em>′.<em>low</em>. <strong>(c)</strong> The intervals do not overlap, and <em>i</em>′.<em>high &lt; i</em>.<em>low</em>.</p>
</div>
<p class="noindent">As <a href="chapter017.xhtml#Fig_17-3">Figure 17.3</a> shows, any two intervals <em>i</em> and <em>i</em>′ satisfy the <span class="blue"><strong><em>interval trichotomy</em></strong></span>, that is, exactly one of the following three properties holds:</p>
<p class="nl">a. <em>i</em> and <em>i</em>′ overlap,</p>
<p class="nl">b. <em>i</em> is to the left of <em>i</em>′ (i.e., <em>i</em>.<em>high</em> &lt; <em>i</em>′.<em>low</em>),</p>
<p class="nl">c. <em>i</em> is to the right of <em>i</em>′ (i.e., <em>i</em>′.<em>high</em> &lt; <em>i</em>.<em>low</em>).</p>
<p class="space-break">An <span class="blue"><strong><em>interval tree</em></strong></span> is a red-black tree that maintains a dynamic set of elements, with each element <em>x</em> containing an interval <em>x</em>.<em>int</em>. Interval trees support the following operations:</p>
<p class="para-hang1">I<small>NTERVAL</small>-I<small>NSERT</small>(<em>T</em>, <em>x</em>) adds the element <em>x</em>, whose <em>int</em> attribute is assumed to contain an interval, to the interval tree <em>T</em>.</p>
<p class="para-hang1">I<small>NTERVAL</small>-D<small>ELETE</small>(<em>T</em>, <em>x</em>) removes the element <em>x</em> from the interval tree <em>T</em>.</p>
<p class="para-hang1">I<small>NTERVAL</small>-S<small>EARCH</small>(<em>T</em>, <em>i</em>) returns a pointer to an element <em>x</em> in the interval tree <em>T</em> such that <em>x</em>.<em>int</em> overlaps interval <em>i</em>, or a pointer to the sentinel <em>T</em>.<em>nil</em> if no such element belongs to the set.</p>
<p class="noindent1-top"><a href="chapter017.xhtml#Fig_17-4">Figure 17.4</a> shows how an interval tree represents a set of intervals. The four-step method from <a href="chapter017.xhtml#Sec_17.2">Section 17.2</a> will guide our design of an interval tree and the operations that run on it.</p>
<p class="level4"><strong>Step 1: Underlying data structure</strong></p>
<p class="noindent">A red-black tree serves as the underlying data structure. Each node <em>x</em> contains an interval <em>x</em>.<em>int</em>. The key of <em>x</em> is the low endpoint, <em>x</em>.<em>int</em>.<em>low</em>, of the interval. Thus, an inorder tree walk of the data structure lists the intervals in sorted order by low endpoint.</p>
<a id="p491"/>
<div class="divimage">
<p class="fig-imga" id="Fig_17-4"><img alt="art" class="width100" src="images/Art_P537.jpg"/></p>
<p class="caption"><strong>Figure 17.4</strong> An interval tree. <strong>(a)</strong> A set of 10 intervals, shown sorted bottom to top by left endpoint. <strong>(b)</strong> The interval tree that represents them. Each node <em>x</em> contains an interval, shown above the dashed line, and the maximum value of any interval endpoint in the subtree rooted at <em>x</em>, shown below the dashed line. An inorder tree walk of the tree lists the nodes in sorted order by left endpoint.</p>
</div>
<p class="level4"><strong>Step 2: Additional information</strong></p>
<p class="noindent">In addition to the intervals themselves, each node <em>x</em> contains a value <em>x</em>.<em>max</em>, which is the maximum value of any interval endpoint stored in the subtree rooted at <em>x</em>.</p>
<p class="level4"><strong>Step 3: Maintaining the information</strong></p>
<p class="noindent">We must verify that insertion and deletion take <em>O</em>(lg <em>n</em>) time on an interval tree of <em>n</em> nodes. It is simple enough to determine <em>x</em>.<em>max</em> in <em>O</em>(1) time, given interval <em>x</em>.<em>int</em> and the <em>max</em> values of node <em>x</em>’s children:</p>
<p class="eql"><em>x</em>.<em>max</em> = max {<em>x</em>.<em>int</em>.<em>high</em>, <em>x</em>.<em>left</em>.<em>max</em>, <em>x</em>.<em>right</em>.<em>max</em>}.</p>
<a id="p492"/>
<p class="noindent">Thus, by Theorem 17.1, insertion and deletion run in <em>O</em>(lg <em>n</em>) time. In fact, you can use either Exercise 17.2-3 or 17.3-1 to show how to update all the <em>max</em> attributes that change after a rotation in just <em>O</em>(1) time.</p>
<p class="level4"><strong>Step 4: Developing new operations</strong></p>
<p class="noindent">The only new operation is I<small>NTERVAL</small>-S<small>EARCH</small>(<em>T</em>, <em>i</em>), which finds a node in tree <em>T</em> whose interval overlaps interval <em>i</em>. If there is no interval in the tree that overlaps <em>i</em>, the procedure returns a pointer to the sentinel <em>T</em>.<em>nil</em>.</p>
<div class="pull-quote1">
<p class="box-heading">I<small>NTERVAL</small>-S<small>EARCH</small>(<em>T</em>, <em>i</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1" colspan="2"><p class="noindent"><em>x</em> = <em>T</em>.<em>root</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1" colspan="2"><p class="noindent"><strong>while</strong> <em>x</em> ≠ <em>T</em>.<em>nil</em> and <em>i</em> does not overlap <em>x</em>.<em>int</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>if</strong> <em>x</em>.<em>left</em> ≠ <em>T</em>.<em>nil</em> and <em>x</em>.<em>left</em>.<em>max</em> ≥ <em>i</em>.<em>low</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p3"><em>x</em> = <em>x</em>.<em>left</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> overlap in left subtree or no overlap in right subtree</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p2"><strong>else</strong> <em>x</em> = <em>x</em>.<em>right</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> no overlap in left subtree</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1" colspan="2"><p class="noindent"><strong>return</strong> <em>x</em></p></td>
</tr>
</table>
</div>
<p>The search for an interval that overlaps <em>i</em> starts at the root of the tree and proceeds downward. It terminates when either it finds an overlapping interval or it reaches the sentinel <em>T</em>.<em>nil</em>. Since each iteration of the basic loop takes <em>O</em>(1) time, and since the height of an <em>n</em>-node red-black tree is <em>O</em>(lg <em>n</em>), the I<small>NTERVAL</small>-S<small>EARCH</small> procedure takes <em>O</em>(lg <em>n</em>) time.</p>
<p>Before we see why I<small>NTERVAL</small>-S<small>EARCH</small> is correct, let’s examine how it works on the interval tree in <a href="chapter017.xhtml#Fig_17-4">Figure 17.4</a>. Let’s look for an interval that overlaps the interval <em>i</em> = [22, 25]. Begin with <em>x</em> as the root, which contains [16, 21] and does not overlap <em>i</em>. Since <em>x</em>.<em>left</em>.<em>max</em> = 23 is greater than <em>i</em>.<em>low</em> = 22, the loop continues with <em>x</em> as the left child of the root—the node containing [8, 9], which also does not overlap <em>i</em>. This time, <em>x</em>.<em>left</em>.<em>max</em> = 10 is less than <em>i</em>.<em>low</em> = 22, and so the loop continues with the right child of <em>x</em> as the new <em>x</em>. Because the interval [15, 23] stored in this node overlaps <em>i</em>, the procedure returns this node.</p>
<p>Now let’s try an unsuccessful search, for an interval that overlaps <em>i</em> = [11, 14] in the interval tree of <a href="chapter017.xhtml#Fig_17-4">Figure 17.4</a>. Again, begin with <em>x</em> as the root. Since the root’s interval [16, 21] does not overlap <em>i</em>, and since <em>x</em>.<em>left</em>.<em>max</em> = 23 is greater than <em>i</em>.<em>low</em> = 11, go left to the node containing [8, 9]. Interval [8, 9] does not overlap <em>i</em>, and <em>x</em>.<em>left</em>.<em>max</em> = 10 is less than <em>i</em>.<em>low</em> = 11, and so the search goes right. (No interval in the left subtree overlaps <em>i</em>.) Interval [15, 23] does not overlap <em>i</em>, and its left child is <em>T</em>.<em>nil</em>, so again the search goes right, the loop terminates, and I<small>NTERVAL</small>-S<small>EARCH</small> returns the sentinel <em>T</em>.<em>nil</em>.</p>
<a id="p493"/>
<p>To see why I<small>NTERVAL</small>-S<small>EARCH</small> is correct, we must understand why it suffices to examine a single path from the root. The basic idea is that at any node <em>x</em>, if <em>x</em>.<em>int</em> does not overlap <em>i</em>, the search always proceeds in a safe direction: the search will definitely find an overlapping interval if the tree contains one. The following theorem states this property more precisely.</p>
<p class="theorem"><strong><em>Theorem 17.2</em></strong></p>
<p class="noindent">Any execution of I<small>NTERVAL</small>-S<small>EARCH</small>(<em>T</em>, <em>i</em>) either returns a node whose interval overlaps <em>i</em>, or it returns <em>T</em>.<em>nil</em> and the tree <em>T</em> contains no node whose interval overlaps <em>i</em>.</p>
<p class="proof"><strong><em>Proof</em></strong>   The <strong>while</strong> loop of lines 2–5 terminates when either <em>x</em> = <em>T</em>.<em>nil</em> or <em>i</em> overlaps <em>x</em>.<em>int</em>. In the latter case, it is certainly correct to return <em>x</em>. Therefore, we focus on the former case, in which the <strong>while</strong> loop terminates because <em>x</em> = <em>T</em>.<em>nil</em>, which is the node that I<small>NTERVAL</small>-S<small>EARCH</small> returns.</p>
<p>We’ll prove that if the procedure returns <em>T</em>.<em>nil</em>, then it did not miss any intervals in <em>T</em> that overlap <em>i</em>. The idea is to show that whether the search goes left in line 4 or right in line 5, it always heads toward a node containing an interval overlapping <em>i</em>, if any such interval exists. In particular, we’ll prove that</p>
<ol class="olnoindent" epub:type="list">
<li>If the search goes left in line 4, then the left subtree of node <em>x</em> contains an interval that overlaps <em>i</em> or the right subtree of <em>x</em> contains no interval that overlaps <em>i</em>. Therefore, even if <em>x</em>’s left subtree contains no interval that overlaps <em>i</em> but the search goes left, it does not make a mistake, because <em>x</em>’s right subtree does not contain an interval overlapping <em>i</em>, either.</li>
<li class="litop">If the search goes right in line 5, then the left subtree of <em>x</em> contains no interval that overlaps <em>i</em>. Thus, if the search goes right, it does not make a mistake.</li></ol>
<p>For both cases, we rely on the interval trichotomy. Let’s start with the case where the search goes right, whose proof is simpler. By the tests in line 3, we know that <em>x</em>.<em>left</em> = <em>T</em>.<em>nil</em> or <em>x</em>.<em>left</em>.<em>max &lt; i</em>.<em>low</em>. If <em>x</em>.<em>left</em> = <em>T</em>.<em>nil</em>, then <em>x</em>’s left subtree contains no interval that overlaps <em>i</em>, since it contains no intervals at all. Now suppose that <em>x</em>.<em>left</em> ≠ <em>T</em>.<em>nil</em>, so that we must have <em>x</em>.<em>left</em>.<em>max &lt; i</em>.<em>low</em>. Consider any interval <em>i</em>′ in <em>x</em>’s left subtree. Because <em>x</em>.<em>left</em>.<em>max</em> is the maximum endpoint in <em>x</em>’s left subtree, we have <em>i</em>′.<em>high</em> ≤ <em>x</em>.<em>left</em>.<em>max</em>. Thus, as <a href="chapter017.xhtml#Fig_17-5">Figure 17.5(a)</a> shows,</p>
<table class="table2b">
<tr>
<td class="td2"><em>i</em>′.<em>high</em></td>
<td class="td2">≤</td>
<td class="td2"><em>x</em>.<em>left</em>.<em>max</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">&lt;</td>
<td class="td2"><em>i</em>.<em>low</em>.</td>
</tr>
</table>
<p class="noindent">By the interval trichotomy, therefore, intervals <em>i</em> and <em>i</em>′ do not overlap, and so <em>x</em>’s left subtree contains no interval that overlaps <em>i</em>.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_17-5"><img alt="art" src="images/Art_P538.jpg"/></p>
<p class="caption"><strong>Figure 17.5</strong> Intervals in the proof of Theorem 17.2. The value of <em>x</em>.<em>left</em>.<em>max</em> is shown in each case as a dashed line. <strong>(a)</strong> The search goes right. No interval <em>i</em>′ in <em>x</em>’s left subtree can overlap <em>i</em>. <strong>(b)</strong> The search goes left. The left subtree of <em>x</em> contains an interval that overlaps <em>i</em> (situation not shown), or <em>x</em>’s left subtree contains an interval <em>i</em>′ such that <em>i</em>′.<em>high</em> = <em>x</em>.<em>left</em>.<em>max</em>. Since <em>i</em> does not overlap <em>i</em>′, neither does it overlap any interval <em>i</em>″ in <em>x</em>’s right subtree, since <em>i</em>′.<em>low</em> ≤ <em>i</em>″.<em>low</em>.</p>
</div>
<p>Now we examine the case in which the search goes left. If the left subtree of node <em>x</em> contains an interval that overlaps <em>i</em>, we’re done, so let’s assume that no node <a id="p494"/>in <em>x</em>’s left subtree overlaps <em>i</em>. We need to show that in this case, no node in <em>x</em>’s right subtree overlaps <em>i</em>, so that going left will not miss any overlaps in <em>x</em>’s right subtree. By the tests in line 3, the left subtree of <em>x</em> is not empty and <em>x</em>.<em>left</em>.<em>max</em> ≥ <em>i</em>.<em>low</em>. By the definition of the <em>max</em> attribute, <em>x</em>’s left subtree contains some interval <em>i</em>′ such that</p>
<table class="table2b">
<tr>
<td class="td2"><em>i</em>′.<em>high</em></td>
<td class="td2">=</td>
<td class="td2"><em>x</em>.<em>left</em>.<em>max</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2"><em>i</em>.<em>low</em>,</td>
</tr>
</table>
<p class="noindent">as illustrated in <a href="chapter017.xhtml#Fig_17-5">Figure 17.5(b)</a>. Since <em>i</em>′ is in <em>x</em>’s left subtree, it does not overlap <em>i</em>, and since <em>i</em>′.<em>high</em> ≥ <em>i</em>.<em>low</em>, the interval trichotomy tells us that <em>i</em>.<em>high &lt; i</em>′.<em>low</em>. Now we bring in the property that interval trees are keyed on the low endpoints of intervals. Because <em>i</em>′ is in <em>x</em>’s left subtree, we have <em>i</em>′.<em>low</em> ≤ <em>x</em>.<em>int</em>.<em>low</em>. Now consider any interval <em>i</em>″ in <em>x</em>’s right subtree, so that <em>x</em>.<em>int</em>.<em>low</em> ≤ <em>i</em>″.<em>low</em>. Putting inequalities together, we get</p>
<table class="table2b">
<tr>
<td class="td2"><em>i</em>.<em>high</em></td>
<td class="td2">&lt;</td>
<td class="td2"><em>i</em>′.<em>low</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2"><em>x</em>.<em>int</em>.<em>low</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2"><em>i</em>″.<em>low</em>.</td>
</tr>
</table>
<p class="noindent">Because <em>i</em>.<em>high &lt; i</em>″.<em>low</em>, the interval trichotomy tells us that <em>i</em> and <em>i</em>″ do not overlap. Since we chose <em>i</em>″ as any interval in <em>x</em>’s right subtree, no node in <em>x</em>’s right subtree overlaps <em>i</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Thus, the I<small>NTERVAL</small>-S<small>EARCH</small> procedure works correctly.</p>
<a id="p495"/>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>17.3-1</em></strong></p>
<p class="noindent">Write pseudocode for L<small>EFT</small>-R<small>OTATE</small> that operates on nodes in an interval tree and updates all the <em>max</em> attributes that change in <em>O</em>(1) time.</p>
<p class="level3"><strong><em>17.3-2</em></strong></p>
<p class="noindent">Describe an efficient algorithm that, given an interval <em>i</em>, returns an interval overlapping <em>i</em> that has the minimum low endpoint, or <em>T</em>.<em>nil</em> if no such interval exists.</p>
<p class="level3"><strong><em>17.3-3</em></strong></p>
<p class="noindent">Given an interval tree <em>T</em> and an interval <em>i</em>, describe how to list all intervals in <em>T</em> that overlap <em>i</em> in <em>O</em>(min {<em>n</em>, <em>k</em> lg <em>n</em>}) time, where <em>k</em> is the number of intervals in the output list. (<em>Hint</em>: One simple method makes several queries, modifying the tree between queries. A slightly more complicated method does not modify the tree.)</p>
<p class="level3"><strong><em>17.3-4</em></strong></p>
<p class="noindent">Suggest modifications to the interval-tree procedures to support the new operation I<small>NTERVAL</small>-S<small>EARCH</small>-E<small>XACTLY</small>(<em>T</em>, <em>i</em>), where <em>T</em> is an interval tree and <em>i</em> is an interval. The operation should return a pointer to a node <em>x</em> in <em>T</em> such that <em>x</em>.<em>int</em>.<em>low</em> = <em>i</em>.<em>low</em> and <em>x</em>.<em>int</em>.<em>high</em> = <em>i</em>.<em>high</em>, or <em>T</em>.<em>nil</em> if <em>T</em> contains no such node. All operations, including I<small>NTERVAL</small>-S<small>EARCH</small>-E<small>XACTLY</small>, should run in <em>O</em>(lg <em>n</em>) time on an <em>n</em>-node interval tree.</p>
<p class="level3"><strong><em>17.3-5</em></strong></p>
<p class="noindent">Show how to maintain a dynamic set <em>Q</em> of numbers that supports the operation M<small>IN</small>-G<small>AP</small>, which gives the absolute value of the difference of the two closest numbers in <em>Q</em>. For example, if we have <em>Q</em> = {1, 5, 9, 15, 18, 22}, then M<small>IN</small>-G<small>AP</small>(<em>Q</em>) returns 3, since 15 and 18 are the two closest numbers in <em>Q</em>. Make the operations I<small>NSERT</small>, D<small>ELETE</small>, S<small>EARCH</small>, and M<small>IN</small>-G<small>AP</small> as efficient as possible, and analyze their running times.</p>
<p class="level3"><span class="font1">★</span> <strong><em>17.3-6</em></strong></p>
<p class="noindent">VLSI databases commonly represent an integrated circuit as a list of rectangles. Assume that each rectangle is rectilinearly oriented (sides parallel to the <em>x</em>- and <em>y</em>-axes), so that each rectangle is represented by four values: its minimum and maximum <em>x</em>- and <em>y</em>-coordinates. Give an <em>O</em>(<em>n</em> lg <em>n</em>)-time algorithm to decide whether a set of <em>n</em> rectangles so represented contains two rectangles that overlap. Your algorithm need not report all intersecting pairs, but it must report that an overlap exists if one rectangle entirely covers another, even if the boundary lines do not intersect. (<em>Hint</em>: Move a “sweep” line across the set of rectangles.)</p>
<a id="p496"/>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-104"><strong>Problems</strong></p>
<section title="17-1 Point of maximum overlap">
<p class="level2"><strong><em>17-1     Point of maximum overlap</em></strong></p>
<p class="noindent">You wish to keep track of a <span class="blue"><strong><em>point of maximum overlap</em></strong></span> in a set of intervals—a point with the largest number of intervals in the set that overlap it.</p>
<p class="nl"><strong><em>a.</em></strong> Show that there is always a point of maximum overlap that is an endpoint of one of the intervals.</p>
<p class="nl"><strong><em>b.</em></strong> Design a data structure that efficiently supports the operations I<small>NTERVAL</small>-I<small>NSERT</small>, I<small>NTERVAL</small>-D<small>ELETE</small>, and F<small>IND</small>-POM, which returns a point of maximum overlap. (<em>Hint</em>: Keep a red-black tree of all the endpoints. Associate a value of +1 with each left endpoint, and associate a value of −1 with each right endpoint. Augment each node of the tree with some extra information to maintain the point of maximum overlap.)</p>
</section>
<section title="17-2 Josephus permutation">
<p class="level2"><strong><em>17-2     Josephus permutation</em></strong></p>
<p class="noindent">We define the <span class="blue"><strong><em>Josephus problem</em></strong></span> as follows. A group of <em>n</em> people form a circle, and we are given a positive integer <em>m</em> ≤ <em>n</em>. Beginning with a designated first person, proceed around the circle, removing every <em>m</em>th person. After each person is removed, counting continues around the circle that remains. This process continues until nobody remains in the circle. The order in which the people are removed from the circle defines the <span class="blue"><strong>(<em>n</em>, <em>m</em>)-<em>Josephus permutation</em></strong></span> of the integers 1, 2, … , <em>n</em>. For example, the (7, 3)-Josephus permutation is <span class="font1">〈</span>3, 6, 2, 7, 5, 1, 4<span class="font1">〉</span>.</p>
<p class="nl"><strong><em>a.</em></strong> Suppose that <em>m</em> is a constant. Describe an <em>O</em>(<em>n</em>)-time algorithm that, given an integer <em>n</em>, outputs the (<em>n</em>, <em>m</em>)-Josephus permutation.</p>
<p class="nl"><strong><em>b.</em></strong> Suppose that <em>m</em> is not necessarily a constant. Describe an <em>O</em>(<em>n</em> lg <em>n</em>)-time algorithm that, given integers <em>n</em> and <em>m</em>, outputs the (<em>n</em>, <em>m</em>)-Josephus permutation.</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-105"><strong>Chapter notes</strong></p>
<p class="noindent">In their book, Preparata and Shamos [<a epub:type="noteref" href="bibliography001.xhtml#endnote_364">364</a>] describe several of the interval trees that appear in the literature, citing work by H. Edelsbrunner (1980) and E. M. McCreight (1981). The book details an interval tree that, given a static database of <em>n</em> intervals, allows us to enumerate all <em>k</em> intervals that overlap a given query interval in <em>O</em>(<em>k</em> + lg <em>n</em>) time.</p>
</section>
</section>
</div>
</body>
</html>