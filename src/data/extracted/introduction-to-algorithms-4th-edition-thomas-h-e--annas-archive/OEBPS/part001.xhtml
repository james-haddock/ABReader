<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body">
<a id="p1"/><a id="p2"/>
<p class="line-p"/>
<section epub:type="bodymatter part" title="Part I Foundations">
<p class="part-title"><a href="toc.xhtml#part-1"><strong><em><span class="blue1">Part I    Foundations</span></em></strong></a></p>
<a id="p3"/>
<p class="cp"/>
<p class="noindent1-top1"> </p>
<p class="noindent1-top1"> </p>
<section title="Introduction">
<p class="level1a" id="h1-1"><a href="toc.xhtml#Rh1-1"><strong>Introduction</strong></a></p>
<p class="noindent">When you design and analyze algorithms, you need to be able to describe how they operate and how to design them. You also need some mathematical tools to show that your algorithms do the right thing and do it efficiently. This part will get you started. Later parts of this book will build upon this base.</p>
<p><a href="chapter001.xhtml">Chapter 1</a> provides an overview of algorithms and their place in modern computing systems. This chapter defines what an algorithm is and lists some examples. It also makes a case for considering algorithms as a technology, alongside technologies such as fast hardware, graphical user interfaces, object-oriented systems, and networks.</p>
<p>In <a href="chapter002.xhtml">Chapter 2</a>, we see our first algorithms, which solve the problem of sorting a sequence of <em>n</em> numbers. They are written in a pseudocode which, although not directly translatable to any conventional programming language, conveys the structure of the algorithm clearly enough that you should be able to implement it in the language of your choice. The sorting algorithms we examine are insertion sort, which uses an incremental approach, and merge sort, which uses a recursive technique known as “divide-and-conquer.” Although the time each requires increases with the value of <em>n</em>, the rate of increase differs between the two algorithms. We determine these running times in <a href="chapter002.xhtml">Chapter 2</a>, and we develop a useful “asymptotic” notation to express them.</p>
<p><a href="chapter003.xhtml">Chapter 3</a> precisely defines asymptotic notation. We’ll use asymptotic notation to bound the growth of functions—most often, functions that describe the running time of algorithms—from above and below. The chapter starts by informally defining the most commonly used asymptotic notations and giving an example of how to apply them. It then formally defines five asymptotic notations and presents conventions for how to put them together. The rest of <a href="chapter003.xhtml">Chapter 3</a> is primarily a presentation of mathematical notation, more to ensure that your use of notation matches that in this book than to teach you new mathematical concepts.</p>
<a id="p4"/>
<p><a href="chapter004.xhtml">Chapter 4</a> delves further into the divide-and-conquer method introduced in <a href="chapter002.xhtml">Chapter 2</a>. It provides two additional examples of divide-and-conquer algorithms for multiplying square matrices, including Strassen’s surprising method. <a href="chapter004.xhtml">Chapter 4</a> contains methods for solving recurrences, which are useful for describing the running times of recursive algorithms. In the substitution method, you guess an answer and prove it correct. Recursion trees provide one way to generate a guess. <a href="chapter004.xhtml">Chapter 4</a> also presents the powerful technique of the “master method,” which you can often use to solve recurrences that arise from divide-and-conquer algorithms. Although the chapter provides a proof of a foundational theorem on which the master theorem depends, you should feel free to employ the master method without delving into the proof. <a href="chapter004.xhtml">Chapter 4</a> concludes with some advanced topics.</p>
<p><a href="chapter005.xhtml">Chapter 5</a> introduces probabilistic analysis and randomized algorithms. You typically use probabilistic analysis to determine the running time of an algorithm in cases in which, due to the presence of an inherent probability distribution, the running time may differ on different inputs of the same size. In some cases, you might assume that the inputs conform to a known probability distribution, so that you are averaging the running time over all possible inputs. In other cases, the probability distribution comes not from the inputs but from random choices made during the course of the algorithm. An algorithm whose behavior is determined not only by its input but by the values produced by a random-number generator is a randomized algorithm. You can use randomized algorithms to enforce a probability distribution on the inputs—thereby ensuring that no particular input always causes poor performance—or even to bound the error rate of algorithms that are allowed to produce incorrect results on a limited basis.</p>
<p><a href="appendix001.xhtml">Appendices A</a>–<a href="appendix004.xhtml">D</a> contain other mathematical material that you will find helpful as you read this book. You might have seen much of the material in the appendix chapters before having read this book (although the specific definitions and notational conventions we use may differ in some cases from what you have seen in the past), and so you should think of the appendices as reference material. On the other hand, you probably have not already seen most of the material in Part I. All the chapters in Part I and the appendices are written with a tutorial flavor.</p>
</section>
</section>
</div>
</body>
</html>