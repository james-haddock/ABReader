<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p877"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="30 Polynomials and the FFT">
<p class="chapter-title"><a href="toc.xhtml#chap-30"><strong><span class="blue1">30        Polynomials and the FFT</span></strong></a></p>
<p class="noindent">The straightforward method of adding two polynomials of degree <em>n</em> takes Θ(<em>n</em>) time, but the straightforward method of multiplying them takes Θ(<em>n</em><sup>2</sup>) time. This chapter will show how the fast Fourier transform, or FFT, can reduce the time to multiply polynomials to Θ(<em>n</em> lg <em>n</em>).</p>
<p>The most common use for Fourier transforms, and hence the FFT, is in signal processing. A signal is given in the <strong><em><span class="blue1">time domain</span></em></strong>: as a function mapping time to amplitude. Fourier analysis expresses the signal as a weighted sum of phase-shifted sinusoids of varying frequencies. The weights and phases associated with the frequencies characterize the signal in the <strong><em><span class="blue1">frequency domain</span></em></strong>. Among the many everyday applications of FFT’s are compression techniques used to encode digital video and audio information, including MP3 files. Many fine books delve into the rich area of signal processing, and the chapter notes reference a few of them.</p>
<p class="level4"><strong>Polynomials</strong></p>
<p class="noindent">A <strong><em><span class="blue1">polynomial</span></em></strong> in the variable <em>x</em> over an algebraic field <em>F</em> represents a function <em>A</em>(<em>x</em>) as a formal sum:</p>
<p class="eql"><img alt="art" src="images/Art_P1030.jpg"/></p>
<p class="noindent">The values <em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, … , <em>a</em><sub><em>n</em>−1</sub> are the <strong><em><span class="blue1">coefficients</span></em></strong> of the polynomial. The coefficients and <em>x</em> are drawn from a field <em>F</em>, typically the set <span class="font1">ℂ</span> of complex numbers. A polynomial <em>A</em>(<em>x</em>) has <strong><em><span class="blue1">degree</span></em></strong> <em>k</em> if its highest nonzero coefficient is <em>a<sub>k</sub></em>, in which case we say that degree(<em>A</em>) = <em>k</em>. Any integer strictly greater than the degree of a polynomial is a <strong><em><span class="blue1">degree-bound</span></em></strong> of that polynomial. Therefore, the degree of a polynomial of degree-bound <em>n</em> may be any integer between 0 and <em>n</em> − 1, inclusive.</p>
<p>A variety of operations extend to polynomials. For <strong><em><span class="blue1">polynomial addition</span></em></strong>, if <em>A</em>(<em>x</em>) and <em>B</em>(<em>x</em>) are polynomials of degree-bound <em>n</em>, their <strong><em><span class="blue1">sum</span></em></strong> is a polynomial <em>C</em>(<em>x</em>), also <a id="p878"/>of degree-bound <em>n</em>, such that <em>C</em>(<em>x</em>) = <em>A</em>(<em>x</em>)+<em>B</em>(<em>x</em>) for all <em>x</em> in the underlying field. That is, if</p>
<p class="eql"><img alt="art" src="images/Art_P1031.jpg"/></p>
<p class="noindent">then</p>
<p class="eql"><img alt="art" src="images/Art_P1032.jpg"/></p>
<p class="noindent">where <em>c<sub>j</sub></em> = <em>a<sub>j</sub></em> + <em>b<sub>j</sub></em> for <em>j</em> = 0, 1, … , <em>n</em> − 1. For example, given the polynomials <em>A</em>(<em>x</em>) = 6<em>x</em><sup>3</sup> + 7<em>x</em><sup>2</sup> − 10<em>x</em> + 9 and <em>B</em>(<em>x</em>) = −2<em>x</em><sup>3</sup> + 4<em>x</em> − 5, their sum is <em>C</em>(<em>x</em>) = 4<em>x</em><sup>3</sup> + 7<em>x</em><sup>2</sup> − 6<em>x</em> + 4.</p>
<p>For <strong><em><span class="blue1">polynomial multiplication</span></em></strong>, if <em>A</em>(<em>x</em>) and <em>B</em>(<em>x</em>) are polynomials of degree-bound <em>n</em>, their <strong><em><span class="blue1">product</span></em></strong> <em>C</em>(<em>x</em>) is a polynomial of degree-bound 2<em>n</em> − 1 such that <em>C</em>(<em>x</em>) = <em>A</em>(<em>x</em>)<em>B</em>(<em>x</em>) for all <em>x</em> in the underlying field. You probably have multiplied polynomials before, by multiplying each term in <em>A</em>(<em>x</em>) by each term in <em>B</em>(<em>x</em>) and then combining terms with equal powers. For example, you can multiply <em>A</em>(<em>x</em>) = 6<em>x</em><sup>3</sup> + 7<em>x</em><sup>2</sup> − 10<em>x</em> + 9 and <em>B</em>(<em>x</em>) = −2<em>x</em><sup>3</sup> + 4<em>x</em> − 5 as follows:</p>
<p class="eqr"><img alt="art" src="images/Art_P1033.jpg"/></p>
<p class="noindent">Another way to express the product <em>C</em>(<em>x</em>) is</p>
<p class="eqr"><img alt="art" src="images/Art_P1034.jpg"/></p>
<p class="noindent">where</p>
<p class="eqr"><img alt="art" src="images/Art_P1035.jpg"/></p>
<p class="noindent">(By the definition of degree, <em>a<sub>k</sub></em> = 0 for all <em>k</em> &gt; degree(<em>A</em>) and <em>b<sub>k</sub></em> = 0 for all <em>k</em> &gt; degree(<em>B</em>).) If <em>A</em> is a polynomial of degree-bound <em>n</em><sub>a</sub> and <em>B</em> is a polynomial of degree-bound <em>n<sub>b</sub></em>, then <em>C</em> must be a polynomial of degree-bound <em>n</em><sub>a</sub> + <em>n<sub>b</sub></em> − 1, because degree(<em>C</em>) = degree(<em>A</em>) + degree(<em>B</em>). Since a polynomial of degree-bound <em>k</em> is also a polynomial of degree-bound <em>k</em> + 1, we normally make the somewhat simpler statement that the product polynomial <em>C</em> is a polynomial of degree-bound <em>n</em><sub>a</sub> + <em>n<sub>b</sub></em>.</p>
<a id="p879"/>
<p class="level4"><strong>Chapter outline</strong></p>
<p class="noindent"><a href="chapter030.xhtml#Sec_30.1">Section 30.1</a> presents two ways to represent polynomials: the coefficient representation and the point-value representation. The straightforward method for multiplying polynomials of degree <em>n</em>—equations (30.1) and (30.2)—takes Θ(<em>n</em><sup>2</sup>) time with polynomials represented in coefficient form, but only Θ(<em>n</em>) time with point-value form. Converting between the two representations, however, reduces the time to multiply polynomials to just Θ(<em>n</em> lg <em>n</em>). To see why this approach works, you must first understand complex roots of unity, which <a href="chapter030.xhtml#Sec_30.2">Section 30.2</a> covers. <a href="chapter030.xhtml#Sec_30.2">Section 30.2</a> then uses the FFT and its inverse to perform the conversions. Because the FFT is used so often in signal processing, it is often implemented as a circuit in hardware, and <a href="chapter030.xhtml#Sec_30.3">Section 30.3</a> illustrates the structure of such circuits.</p>
<p>This chapter relies on complex numbers, and within this chapter the symbol <em>i</em> denotes <img alt="art" src="images/Art_P1036.jpg"/> exclusively.</p>
<p class="line1"/>
<section title="30.1 Representing polynomials">
<a id="Sec_30.1"/>
<p class="level1" id="h1-172"><a href="toc.xhtml#Rh1-172"><strong>30.1    Representing polynomials</strong></a></p>
<p class="noindent">The coefficient and point-value representations of polynomials are in a sense equivalent: a polynomial in point-value form has a unique counterpart in coefficient form. This section introduces the two representations and shows how to combine them in order to multiply two degree-bound <em>n</em> polynomials in Θ(<em>n</em> lg <em>n</em>) time.</p>
<p class="level4"><strong>Coefficient representation</strong></p>
<p class="noindent">A <strong><em><span class="blue1">coefficient representation</span></em></strong> of a polynomial <img alt="art" src="images/Art_P1037.jpg"/> of degree-bound <em>n</em> is a vector of coefficients <em>a</em> = (<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, … , <em>a</em><sub><em>n</em>−1</sub>). Matrix equations in this chapter generally treat vectors as column vectors.</p>
<p>The coefficient representation is convenient for certain operations on polynomials. For example, the operation of <strong><em><span class="blue1">evaluating</span></em></strong> the polynomial <em>A</em>(<em>x</em>) at a given point <em>x</em><sub>0</sub> consists of computing the value of <em>A</em>(<em>x</em><sub>0</sub>). To evaluate a polynomial in Θ(<em>n</em>) time, use <strong><em><span class="blue1">Horner’s rule</span></em></strong>:</p>
<p class="eql"><img alt="art" src="images/Art_P1038.jpg"/></p>
<p class="noindent">Similarly, adding two polynomials represented by the coefficient vectors <em>a</em> = (<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, … , <em>a</em><sub><em>n</em>−1</sub>) and <em>b</em> = (<em>b</em><sub>0</sub>, <em>b</em><sub>1</sub>, … , <em>b</em><sub><em>n</em>−1</sub>) takes Θ(<em>n</em>) time: just produce the coefficient vector <em>c</em> = (<em>c</em><sub>0</sub>, <em>c</em><sub>1</sub>, … , <em>c</em><sub><em>n</em>−1</sub>), where <em>c<sub>j</sub></em> = <em>a<sub>j</sub></em> + <em>b<sub>j</sub></em> for <em>j</em> = 0, 1, … , <em>n</em>− 1.</p>
<p>Now, consider multiplying two degree-bound <em>n</em> polynomials <em>A</em>(<em>x</em>) and <em>B</em>(<em>x</em>) represented in coefficient form. The method described by equations (30.1) and (30.2) takes Θ(<em>n</em><sup>2</sup>) time, since it multiplies each coefficient in the vector <em>a</em> by each coefficient <a id="p880"/>in the vector <em>b</em>. The operation of multiplying polynomials in coefficient form seems to be considerably more difficult than that of evaluating a polynomial or adding two polynomials. The resulting coefficient vector <em>c</em>, given by equation (30.2), is also called the <strong><em><span class="blue1">convolution</span></em></strong> of the input vectors <em>a</em> and <em>b</em>, denoted <em>c</em> = <em>a</em> ⊗ <em>b</em>. Since multiplying polynomials and computing convolutions are fundamental computational problems of considerable practical importance, this chapter concentrates on efficient algorithms for them.</p>
<p class="level4"><strong>Point-value representation</strong></p>
<p class="noindent">A <strong><em><span class="blue1">point-value representation</span></em></strong> of a polynomial <em>A</em>(<em>x</em>) of degree-bound <em>n</em> is a set of <em>n</em> <strong><em><span class="blue1">point-value pairs</span></em></strong></p>
<p class="eql">{(<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>), (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), … , (<em>x</em><sub><em>n</em>−1</sub>, <em>y</em><sub><em>n</em>−1</sub>)}</p>
<p class="noindent">such that all of the <em>x<sub>k</sub></em> are distinct and</p>
<p class="eqr"><img alt="art" src="images/Art_P1039.jpg"/></p>
<p class="noindent">for <em>k</em> = 0, 1, … , <em>n</em> − 1. A polynomial has many different point-value representations, since any set of <em>n</em> distinct points <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, … , <em>x</em><sub><em>n</em>−1</sub> can serve as a basis for the representation.</p>
<p>Computing a point-value representation for a polynomial given in coefficient form is in principle straightforward, since all you have to do is select <em>n</em> distinct points <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, … , <em>x</em><sub><em>n</em>−1</sub> and then evaluate <em>A</em>(<em>x<sub>k</sub></em>) for <em>k</em> = 0, 1, … , <em>n</em> − 1. With Horner’s method, evaluating a polynomial at <em>n</em> points takes Θ(<em>n</em><sup>2</sup>) time. We’ll see later that if you choose the points <em>x<sub>k</sub></em> cleverly, you can accelerate this computation to run in Θ(<em>n</em> lg <em>n</em>) time.</p>
<p>The inverse of evaluation—determining the coefficient form of a polynomial from a point-value representation—is <strong><em><span class="blue1">interpolation</span></em></strong>. The following theorem shows that interpolation is well defined when the desired interpolating polynomial must have a degree-bound equal to the given number of point-value pairs.</p>
<p class="theo"><strong><em>Theorem 30.1 (Uniqueness of an interpolating polynomial)</em></strong></p>
<p class="noindent">For any set {(<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>), (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), … , (<em>x</em><sub><em>n</em>−1</sub>, <em>y</em><sub><em>n</em>−1</sub>)} of <em>n</em> point-value pairs such that all the <em>x<sub>k</sub></em> values are distinct, there is a unique polynomial <em>A</em>(<em>x</em>) of degree-bound <em>n</em> such that <em>y<sub>k</sub></em> = <em>A</em>(<em>x<sub>k</sub></em>) for <em>k</em> = 0, 1, … , <em>n</em> − 1.</p>
<p class="prof"><strong><em>Proof</em></strong>   The proof relies on the existence of the inverse of a certain matrix. Equation (30.3) is equivalent to the matrix equation</p>
<a id="p881"/>
<p class="eqr"><img alt="art" src="images/Art_P1040.jpg"/></p>
<p>The matrix on the left is denoted <em>V</em>(<em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, … , <em>x</em><sub><em>n</em>−1</sub>) and is known as a <strong><em><span class="blue1">Vandermonde matrix</span></em></strong>. By Problem D-1 on page 1223, this matrix has determinant</p>
<p class="eql"><img alt="art" src="images/Art_P1041.jpg"/></p>
<p class="noindent">and therefore, by Theorem D.5 on page 1221, it is invertible (that is, nonsingular) if the <em>x<sub>k</sub></em> are distinct. To solve for the coefficients <em>a<sub>j</sub></em> uniquely given the point-value representation, use the inverse of the Vandermonde matrix:</p>
<p class="eql"><em>a</em> = <em>V</em>(<em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, … , <em>x</em><sub><em>n</em>−1</sub>)<sup>−1</sup><em>y</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The proof of Theorem 30.1 describes an algorithm for interpolation based on solving the set (30.4) of linear equations. <a href="chapter028.xhtml#Sec_28.1">Section 28.1</a> shows how to solve these equations in <em>O</em>(<em>n</em><sup>3</sup>) time.</p>
<p>A faster algorithm for <em>n</em>-point interpolation is based on <strong><em><span class="blue1">Lagrange’s formula</span></em></strong>:</p>
<p class="eqr"><img alt="art" src="images/Art_P1042.jpg"/></p>
<p class="noindent">You might want to verify that the right-hand side of equation (30.5) is a polynomial of degree-bound <em>n</em> that satisfies <em>A</em>(<em>x<sub>k</sub></em>) = <em>y<sub>k</sub></em> for all <em>k</em>. Exercise 30.1-5 asks you how to compute the coefficients of <em>A</em> using Lagrange’s formula in Θ(<em>n</em><sup>2</sup>) time.</p>
<p>Thus, <em>n</em>-point evaluation and interpolation are well-defined inverse operations that transform between the coefficient representation of a polynomial and a point-value representation.<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup> The algorithms described above for these problems take Θ(<em>n</em><sup>2</sup>) time.</p>
<p>The point-value representation is quite convenient for many operations on polynomials. For addition, if <em>C</em>(<em>x</em>) = <em>A</em>(<em>x</em>) + <em>B</em>(<em>x</em>), then <em>C</em>(<em>x<sub>k</sub></em>) = <em>A</em>(<em>x<sub>k</sub></em>) + <em>B</em>(<em>x<sub>k</sub></em>) for any point <em>x<sub>k</sub></em>. More precisely, given point-value representations for <em>A</em>,</p>
<p class="eql">{(<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>), (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), … , (<em>x</em><sub><em>n</em>−1</sub>, <em>y</em><sub><em>n</em>−1</sub>)},</p>
<a id="p882"/>
<p class="noindent">and for <em>B</em>,</p>
<p class="eql"><img alt="art" src="images/Art_P1043.jpg"/></p>
<p class="noindent">where <em>A</em> and <em>B</em> are evaluated at the <em>same n</em> points, then a point-value representation for <em>C</em> is</p>
<p class="eql"><img alt="art" src="images/Art_P1044.jpg"/></p>
<p class="noindent">Thus the time to add two polynomials of degree-bound <em>n</em> in point-value form is Θ(<em>n</em>).</p>
<p>Similarly, the point-value representation is convenient for multiplying polynomials. If <em>C</em>(<em>x</em>) = <em>A</em>(<em>x</em>)<em>B</em>(<em>x</em>), then <em>C</em>(<em>x<sub>k</sub></em>) = <em>A</em>(<em>x<sub>k</sub></em>)<em>B</em>(<em>x<sub>k</sub></em>) for any point <em>x<sub>k</sub></em>, and to obtain a point-value representation for <em>C</em>, just pointwise multiply a point-value representation for <em>A</em> by a point-value representation for <em>B</em>. Polynomial multiplication differs from polynomial addition in one key aspect, however: degree(<em>C</em>) = degree(<em>A</em>) + degree(<em>B</em>), so that if <em>A</em> and <em>B</em> have degree-bound <em>n</em>, then <em>C</em> has degree-bound 2<em>n</em>. A standard point-value representation for <em>A</em> and <em>B</em> consists of <em>n</em> point-value pairs for each polynomial. Multiplying these together gives <em>n</em> point-value pairs, but 2<em>n</em> pairs are necessary to interpolate a unique polynomial <em>C</em> of degree-bound 2<em>n</em>. (See Exercise 30.1-4.) Instead, begin with “extended” point-value representations for <em>A</em> and for <em>B</em> consisting of 2<em>n</em> point-value pairs each. Given an extended point-value representation for <em>A</em>,</p>
<p class="eql">{(<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>), (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), … , (<em>x</em><sub>2<em>n</em>−1</sub>, <em>y</em><sub>2<em>n</em>−1</sub>)},</p>
<p class="noindent">and a corresponding extended point-value representation for <em>B</em>,</p>
<p class="eql"><img alt="art" src="images/Art_P1045.jpg"/></p>
<p class="noindent">then a point-value representation for <em>C</em> is</p>
<p class="eql"><img alt="art" src="images/Art_P1046.jpg"/></p>
<p class="noindent">Given two input polynomials in extended point-value form, multiplying them to obtain the point-value form of the result takes just Θ(<em>n</em>) time, much less than the Θ(<em>n</em><sup>2</sup>) time required to multiply polynomials in coefficient form.</p>
<p>Finally, let’s consider how to evaluate a polynomial given in point-value form at a new point. For this problem, the simplest approach known is to first convert the polynomial to coefficient form and then evaluate it at the new point.</p>
<p class="level4"><strong>Fast multiplication of polynomials in coefficient form</strong></p>
<p class="noindent">Can the linear-time multiplication method for polynomials in point-value form expedite polynomial multiplication in coefficient form? The answer hinges on <a id="p883"/>whether it is possible convert a polynomial quickly from coefficient form to point-value form (evaluate) and vice versa (interpolate).</p>
<div class="divimage">
<p class="fig-imga" id="Fig_30-1"><img alt="art" src="images/Art_P1047.jpg"/></p>
<p class="caption"><strong>Figure 30.1</strong> A graphical outline of an efficient polynomial-multiplication process. Representations on the top are in coefficient form, and those on the bottom are in point-value form. The arrows from left to right correspond to the multiplication operation. The <em>ω</em><sub>2<em>n</em></sub> terms are complex (2<em>n</em>)th roots of unity.</p>
</div>
<p>Any points can serve as evaluation points, but certain evaluation points allow conversion between representations in only Θ(<em>n</em> lg <em>n</em>) time. As we’ll see in <a href="chapter030.xhtml#Sec_30.2">Section 30.2</a>, if “complex roots of unity” are the evaluation points, then the discrete Fourier transform (or DFT) evaluates and the inverse DFT interpolates. <a href="chapter030.xhtml#Sec_30.2">Section 30.2</a> shows how the FFT accomplishes the DFT and inverse DFT operations in Θ(<em>n</em> lg <em>n</em>) time.</p>
<p><a href="chapter030.xhtml#Fig_30-1">Figure 30.1</a> shows this strategy graphically. One minor detail concerns degree-bounds. The product of two polynomials of degree-bound <em>n</em> is a polynomial of degree-bound 2<em>n</em>. Before evaluating the input polynomials <em>A</em> and <em>B</em>, therefore, first double their degree-bounds to 2<em>n</em> by adding <em>n</em> high-order coefficients of 0. Because the vectors have 2<em>n</em> elements, use “complex (2<em>n</em>)th roots of unity,” which are denoted by the <em>ω</em><sub>2<em>n</em></sub> terms in <a href="chapter030.xhtml#Fig_30-1">Figure 30.1</a>.</p>
<p>The following procedure takes advantage of the FFT to multiply two polynomials <em>A</em>(<em>x</em>) and <em>B</em>(<em>x</em>) of degree-bound <em>n</em> in Θ(<em>n</em> lg <em>n</em>)-time, where the input and output representations are in coefficient form. The procedure assumes that <em>n</em> is an exact power of 2, so if it isn’t, just add high-order zero coefficients.</p>
<ol class="olnoindent" epub:type="list">
<li><strong>Double degree-bound:</strong> Create coefficient representations of <em>A</em>(<em>x</em>) and <em>B</em>(<em>x</em>) as degree-bound 2<em>n</em> polynomials by adding <em>n</em> high-order zero coefficients to each.<a id="p884"/></li>
<li class="litop"><strong>Evaluate:</strong> Compute point-value representations of <em>A</em>(<em>x</em>) and <em>B</em>(<em>x</em>) of length 2<em>n</em> by applying the FFT of order 2<em>n</em> on each polynomial. These representations contain the values of the two polynomials at the (2<em>n</em>)th roots of unity.</li>
<li class="litop"><strong>Pointwise multiply:</strong> Compute a point-value representation for the polynomial <em>C</em>(<em>x</em>) = <em>A</em>(<em>x</em>)<em>B</em>(<em>x</em>) by multiplying these values together pointwise. This representation contains the value of <em>C</em>(<em>x</em>) at each (2<em>n</em>)th root of unity.</li>
<li class="litop"><strong>Interpolate:</strong> Create the coefficient representation of the polynomial <em>C</em>(<em>x</em>) by applying the FFT on 2<em>n</em> point-value pairs to compute the inverse DFT.</li></ol>
<p class="noindent">Steps (1) and (3) take Θ(<em>n</em>) time, and steps (2) and (4) take Θ(<em>n</em> lg <em>n</em>) time. Thus, once we show how to use the FFT, we will have proven the following.</p>
<p class="theo"><strong><em>Theorem 30.2</em></strong></p>
<p class="noindent">Two polynomials of degree-bound <em>n</em> with both the input and output representations in coefficient form can be multiplied in Θ(<em>n</em> lg <em>n</em>) time.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>30.1-1</em></strong></p>
<p class="noindent">Multiply the polynomials <em>A</em>(<em>x</em>) = 7<em>x</em><sup>3</sup> − <em>x</em><sup>2</sup> + <em>x</em> − 10 and <em>B</em>(<em>x</em>) = 8<em>x</em><sup>3</sup> − 6<em>x</em> + 3 using equations (30.1) and (30.2).</p>
<p class="level3"><strong><em>30.1-2</em></strong></p>
<p class="noindent">Another way to evaluate a polynomial <em>A</em>(<em>x</em>) of degree-bound <em>n</em> at a given point <em>x</em><sub>0</sub> is to divide <em>A</em>(<em>x</em>) by the polynomial (<em>x</em> − <em>x</em><sub>0</sub>), obtaining a quotient polynomial <em>q</em>(<em>x</em>) of degree-bound <em>n</em> − 1 and a remainder <em>r</em>, such that</p>
<p class="eql"><em>A</em>(<em>x</em>) = <em>q</em>(<em>x</em>)(<em>x</em> − <em>x</em><sub>0</sub>) + <em>r</em>.</p>
<p class="noindent">Then we have <em>A</em>(<em>x</em><sub>0</sub>) = <em>r</em>. Show how to compute the remainder <em>r</em> and the coefficients of <em>q</em>(<em>x</em>) from <em>x</em><sub>0</sub> and the coefficients of <em>A</em> in Θ(<em>n</em>) time.</p>
<p class="level3"><strong><em>30.1-3</em></strong></p>
<p class="noindent">Given a polynomial <img alt="art" src="images/Art_P1048.jpg"/>, define <img alt="art" src="images/Art_P1049.jpg"/>. Show how to derive a point-value representation for <em>A</em><sup>rev</sup>(<em>x</em>) from a point-value representation for <em>A</em>(<em>x</em>), assuming that none of the points is 0.</p>
<p class="level3"><strong><em>30.1-4</em></strong></p>
<p class="noindent">Prove that <em>n</em> distinct point-value pairs are necessary to uniquely specify a polynomial of degree-bound <em>n</em>, that is, if fewer than <em>n</em> distinct point-value pairs are given, they fail to specify a unique polynomial of degree-bound <em>n</em>. (<em>Hint:</em> Using Theorem 30.1, what can you say about a set of <em>n</em> − 1 point-value pairs to which you add one more arbitrarily chosen point-value pair?)</p>
<a id="p885"/>
<p class="level3"><strong><em>30.1-5</em></strong></p>
<p class="noindent">Show how to use equation (30.5) to interpolate in Θ(<em>n</em><sup>2</sup>) time. (<em>Hint:</em> First compute the coefficient representation of the polynomial ∏<em><sub>j</sub></em>(<em>x</em> − <em>x<sub>j</sub></em>) and then divide by (<em>x</em> − <em>x<sub>k</sub></em>) as necessary for the numerator of each term (see Exercise 30.1-2). You can compute each of the <em>n</em> denominators in <em>O</em>(<em>n</em>) time.)</p>
<p class="level3"><strong><em>30.1-6</em></strong></p>
<p class="noindent">Explain what is wrong with the “obvious” approach to polynomial division using a point-value representation: dividing the corresponding <em>y</em> values. Discuss separately the case in which the division comes out exactly and the case in which it doesn’t.</p>
<p class="level3"><strong><em>30.1-7</em></strong></p>
<p class="noindent">Consider two sets <em>A</em> and <em>B</em>, each having <em>n</em> integers in the range from 0 to 10<em>n</em>. The <strong><em><span class="blue1">Cartesian sum</span></em></strong> of <em>A</em> and <em>B</em> is defined by</p>
<p class="eql"><em>C</em> = {<em>x</em> + <em>y</em> : <em>x</em> ∈ <em>A</em> and <em>y</em> ∈ <em>B</em>}.</p>
<p class="noindent">The integers in <em>C</em> lie in the range from 0 to 20<em>n</em>. Show how, in <em>O</em>(<em>n</em> lg <em>n</em>) time, to find the elements of <em>C</em> and the number of times each element of <em>C</em> is realized as a sum of elements in <em>A</em> and <em>B</em>. (<em>Hint:</em> Represent <em>A</em> and <em>B</em> as polynomials of degree at most 10<em>n</em>.)</p>
</section>
<p class="line1"/>
<section title="30.2 The DFT and FFT">
<a id="Sec_30.2"/>
<p class="level1" id="h1-173"><a href="toc.xhtml#Rh1-173"><strong>30.2    The DFT and FFT</strong></a></p>
<p class="noindent">In <a href="chapter030.xhtml#Sec_30.1">Section 30.1</a>, we claimed that by computing the DFT and its inverse by using the FFT, it is possible to evaluate and interpolate a degree <em>n</em> polynomial at the complex roots of unity in Θ(<em>n</em> lg <em>n</em>) time. This section defines complex roots of unity, studies their properties, defines the DFT, and then shows how the FFT computes the DFT and its inverse in Θ(<em>n</em> lg <em>n</em>) time.</p>
<p class="level4"><strong>Complex roots of unity</strong></p>
<p class="noindent">A <strong><em><span class="blue1">complex nth root of unity</span></em></strong> is a complex number <em>ω</em> such that</p>
<p class="eql"><em>ω<sup>n</sup></em> = 1.</p>
<p class="noindent">There are exactly <em>n</em> complex <em>n</em>th roots of unity: <em>e</em><sup>2<em>πik</em>/<em>n</em></sup> for <em>k</em> = 0, 1, … , <em>n</em> − 1. To interpret this formula, use the definition of the exponential of a complex number:</p>
<p class="eql"><em>e<sup>iu</sup></em> = cos(<em>u</em>) + <em>i</em> sin(<em>u</em>).</p>
<p class="noindent"><a href="chapter030.xhtml#Fig_30-2">Figure 30.2</a> shows that the <em>n</em> complex roots of unity are equally spaced around the circle of unit radius centered at the origin of the complex plane. The value</p>
<a id="p886"/>
<div class="divimage">
<p class="fig-imga" id="Fig_30-2"><img alt="art" src="images/Art_P1050.jpg"/></p>
<p class="caption"><strong>Figure 30.2</strong> The values of <img alt="art" src="images/Art_P1051.jpg"/> in the complex plane, where <em>ω</em><sub>8</sub> = <em>e</em><sup>2<em>πi</em>/8</sup> is the principal 8th root of unity.</p>
</div>
<p class="eqr"><img alt="art" src="images/Art_P1052.jpg"/></p>
<p class="noindent">is the <strong><em><span class="blue1">principal nth root of unity</span></em></strong>.<sup><a epub:type="footnote" href="#footnote_2" id="footnote_ref_2">2</a></sup> All other complex <em>n</em>th roots of unity are powers of <em>ω<sub>n</sub></em>.</p>
<p>The <em>n</em> complex <em>n</em>th roots of unity,</p>
<p class="eql"><img alt="art" src="images/Art_P1053.jpg"/></p>
<p class="noindent">form a group under multiplication (see <a href="chapter031.xhtml#Sec_31.3">Section 31.3</a>). This group has the same structure as the additive group (<span class="double"><span class="font1">ℤ</span></span><em><sub>n</sub></em>, +) modulo <em>n</em>, since <img alt="art" src="images/Art_P1054.jpg"/> implies that <img alt="art" src="images/Art_P1055.jpg"/>. Similarly, <img alt="art" src="images/Art_P1056.jpg"/>. The following lemmas furnish some essential properties of the complex <em>n</em>th roots of unity.</p>
<p class="lem"><strong><em>Lemma 30.3 (Cancellation lemma)</em></strong></p>
<p class="noindent">For any integers <em>n</em> &gt; 0, <em>k</em> ≥ 0, and <em>d</em> &gt; 0,</p>
<p class="eqr"><img alt="art" src="images/Art_P1057.jpg"/></p>
<p class="prof"><strong><em>Proof</em></strong>   The lemma follows directly from equation (30.6), since</p>
<p class="eql"><img alt="art" src="images/Art_P1058.jpg"/></p>
<p class="right"><span class="font1">▪</span></p>
<a id="p887"/>
<p class="cor"><strong><em><span class="blue1">Corollary 30.4</span></em></strong></p>
<p class="noindent">For any even integer <em>n</em> &gt; 0,</p>
<p class="eql"><img alt="art" src="images/Art_P1059.jpg"/></p>
<p class="prof"><strong><em>Proof</em></strong>   The proof is left as Exercise 30.2-1.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="lem"><strong><em>Lemma 30.5 (Halving lemma)</em></strong></p>
<p class="noindent">If <em>n</em> &gt; 0 is even, then the squares of the <em>n</em> complex <em>n</em>th roots of unity are the <em>n</em>/2 complex (<em>n</em>/2)th roots of unity.</p>
<p class="prof"><strong><em>Proof</em></strong>   By the cancellation lemma, <img alt="art" src="images/Art_P1060.jpg"/> for any nonnegative integer <em>k</em>. Squaring all of the complex <em>n</em>th roots of unity produces each (<em>n</em>/2)th root of unity exactly twice, since</p>
<p class="eql"><img alt="art" src="images/Art_P1061.jpg"/></p>
<p class="noindent">Thus <img alt="art" src="images/omega.jpg"/> and <img alt="art" src="images/Art_P1062.jpg"/> have the same square. We could also have used Corollary 30.4 to prove this property, since <img alt="art" src="images/Art_P1063.jpg"/> implies <img alt="art" src="images/Art_P1064.jpg"/>, and thus <img alt="art" src="images/Art_P1065.jpg"/>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">As we’ll see, the halving lemma is essential to the divide-and-conquer approach for converting between coefficient and point-value representations of polynomials, since it guarantees that the recursive subproblems are only half as large.</p>
<p class="lem"><strong><em>Lemma 30.6 (Summation lemma)</em></strong></p>
<p class="noindent">For any integer <em>n</em> ≥ 1 and nonzero integer <em>k</em> not divisible by <em>n</em>,</p>
<p class="eql"><img alt="art" src="images/Art_P1066.jpg"/></p>
<p class="prof"><strong><em>Proof</em></strong>   Equation (A.6) on page 1142 applies to complex values as well as to reals, giving</p>
<a id="p888"/>
<p class="eql"><img alt="art" src="images/Art_P1067.jpg"/></p>
<p class="noindent">To see that the denominator is not 0, note that <img alt="art" src="images/Art_P1068.jpg"/> only when <em>k</em> is divisible by <em>n</em>, which the lemma statement prohibits.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>The DFT</strong></p>
<p class="noindent">Recall the goal of evaluating a polynomial</p>
<p class="eql"><img alt="art" src="images/Art_P1069.jpg"/></p>
<p class="noindent">of degree-bound <em>n</em> at <img alt="art" src="images/Art_P1070.jpg"/>, <img alt="art" src="images/Art_P1071.jpg"/>, <img alt="art" src="images/Art_P1072.jpg"/> (that is, at the <em>n</em> complex <em>n</em>th roots of unity).<sup><a epub:type="footnote" href="#footnote_3" id="footnote_ref_3">3</a></sup> The polynomial <em>A</em> is given in coefficient form: <em>a</em> = (<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, … , <em>a</em><sub><em>n</em>−1</sub>). Let us define the results <em>y<sub>k</sub></em>, for <em>k</em> = 0, 1, … , <em>n</em> − 1, by</p>
<p class="eqr"><img alt="art" src="images/Art_P1073.jpg"/></p>
<p class="noindent">The vector <em>y</em> = (<em>y</em><sub>0</sub>, <em>y</em><sub>1</sub>, … , <em>y</em><sub><em>n</em>−1</sub>) is the <strong><em><span class="blue1">discrete Fourier transform (DFT)</span></em></strong> of the coefficient vector <em>a</em> = (<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, … , <em>a</em><sub><em>n</em>−1</sub>). We also write <em>y</em> = DFT<em><sub>n</sub></em>(<em>a</em>).</p>
<p class="level4"><strong>The FFT</strong></p>
<p class="noindent">The <strong><em><span class="blue1">fast Fourier transform (FFT)</span></em></strong> takes advantage of the special properties of the complex roots of unity to compute DFT<em><sub>n</sub></em>(<em>a</em>) in Θ(<em>n</em> lg <em>n</em>) time, as opposed to the Θ(<em>n</em><sup>2</sup>) time of the straightforward method. Assume throughout that <em>n</em> is an exact power of 2. Although strategies for dealing with sizes that are not exact powers of 2 are known, they are beyond the scope of this book.</p>
<a id="p889"/>
<p>The FFT method employs a divide-and-conquer strategy, using the even-indexed and odd-indexed coefficients of <em>A</em>(<em>x</em>) separately to define the two new polynomials <em>A</em><sup>even</sup>(<em>x</em>) and <em>A</em><sup>odd</sup>(<em>x</em>) of degree-bound <em>n</em>/2:</p>
<p class="eql"><em>A</em><sup>even</sup>(<em>x</em>) = <em>a</em><sub>0</sub> + <em>a</em><sub>2</sub><em>x</em> + <em>a</em><sub>4</sub><em>x</em><sup>2</sup> + <span class="font1">⋯</span> + <em>a</em><sub><em>n</em>−2</sub><em>x</em><sup><em>n</em>/2−1</sup>,</p>
<p class="eql"><em>A</em><sup>odd</sup>(<em>x</em>) = <em>a</em><sub>1</sub> + <em>a</em><sub>3</sub><em>x</em> + <em>a</em><sub>5</sub><em>x</em><sup>2</sup> + <span class="font1">⋯</span> + <em>a</em><sub><em>n</em>−1</sub><em>x</em><sup><em>n</em>/2−1</sup>.</p>
<p class="noindent">Note that <em>A</em><sup>even</sup> contains all the even-indexed coefficients of <em>A</em> (the binary representation of the index ends in 0) and <em>A</em><sup>odd</sup> contains all the odd-indexed coefficients (the binary representation of the index ends in 1). It follows that</p>
<p class="eqr"><img alt="art" src="images/Art_P1074.jpg"/></p>
<p class="noindent">so that the problem of evaluating <em>A</em>(<em>x</em>) at <img alt="art" src="images/Art_P1075.jpg"/>, <img alt="art" src="images/Art_P1076.jpg"/> reduces to</p>
<ol class="olnoindent" epub:type="list">
<li>evaluating the degree-bound <em>n</em>/2 polynomials <em>A</em><sup>even</sup>(<em>x</em>) and <em>A</em><sup>odd</sup>(<em>x</em>) at the points
<p class="eqr"><img alt="art" src="images/Art_P1077.jpg"/></p>
<p class="noindent">and then</p>
</li>
<li class="litop">combining the results according to equation (30.9).</li></ol>
<p>By the halving lemma, the list of values (30.10) consists not of <em>n</em> distinct values but only of the <em>n</em>/2 complex (<em>n</em>/2)th roots of unity, with each root occurring exactly twice. Therefore, the FFT recursively evaluates the polynomials <em>A</em><sup>even</sup> and <em>A</em><sup>odd</sup> of degree-bound <em>n</em>/2 at the <em>n</em>/2 complex (<em>n</em>/2)th roots of unity. These subproblems have exactly the same form as the original problem, but are half the size, dividing an <em>n</em>-element DFT<em><sub>n</sub></em> computation into two <em>n</em>/2-element DFT<sub><em>n</em>/2</sub> computations. This decomposition is the basis for the FFT procedure on the next page, which computes the DFT of an <em>n</em>-element vector <em>a</em> = (<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, … , <em>a</em><sub><em>n</em>−1</sub>), where <em>n</em> is an exact power of 2.</p>
<p>The FFT procedure works as follows. Lines 1–2 represent the base case of the recursion. The DFT of 1 element is the element itself, since in this case</p>
<table class="table2b">
<tr>
<td class="td2"><em>y</em><sub>0</sub></td>
<td class="td2">=</td>
<td class="td2"><img alt="art" src="images/Art_P1078.jpg"/></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>a</em><sub>0</sub> · 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>a</em><sub>0</sub>.</td>
</tr>
</table>
<p class="noindent">Lines 5–6 define the coefficient vectors for the polynomials <em>A</em><sup>even</sup> and <em>A</em><sup>odd</sup>. Lines 3, 4, and 12 guarantee that <em>ω</em> is updated properly so that whenever lines 10–11 are executed, <img alt="art" src="images/Art_P1079.jpg"/>. (Keeping a running value of <em>ω</em> from iteration to iteration saves <a id="p890"/>time over computing <img alt="art" src="images/omega.jpg"/> from scratch each time through the <strong>for</strong> loop.<sup><a epub:type="footnote" href="#footnote_4" id="footnote_ref_4">4</a></sup>) Lines 7–8 perform the recursive DFT<sub><em>n</em>/2</sub> computations, setting, for <em>k</em> = 0, 1, … , <em>n</em>/2 − 1,</p>
<div class="pull-quote1">
<p class="box-heading">FFT(<em>a</em>, <em>n</em>)</p>
<table class="table1">
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>n</em> == 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> <em>a</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> DFT of 1 element is the element itself</span></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="noindent"><em>ω<sub>n</sub></em> = <em>e</em><sup>2<em>πi</em>/<em>n</em></sup></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="noindent"><em>ω</em> = 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="noindent"><em>a</em><sup>even</sup> = (<em>a</em><sub>0</sub>, <em>a</em><sub>2</sub>, … , <em>a</em><sub><em>n</em>−2</sub>)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="noindent"><em>a</em><sup>odd</sup> = (<em>a</em><sub>1</sub>, <em>a</em><sub>3</sub>, … , <em>a</em><sub><em>n</em>−1</sub>)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="noindent"><em>y</em><sup>even</sup> = FFT(<em>a</em><sup>even</sup>, <em>n</em>/2)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="noindent"><em>y</em><sup>odd</sup> = FFT(<em>a</em><sup>odd</sup>, <em>n</em>/2)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>k</em> = 0 <strong>to</strong> <em>n</em>/2 − 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> at this point</span>, <img alt="art" src="images/Art_P1080.jpg"/></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><p class="p2"><img alt="art" src="images/Art_P1081.jpg"/></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><p class="p2"><img alt="art" src="images/Art_P1082.jpg"/></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1"><p class="p2"><em>ω</em> = <em>ωω<sub>n</sub></em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1"><strong>return</strong> <em>y</em></td>
<td class="td1"/>
</tr>
</table>
</div>
<p class="eql"><img alt="art" src="images/Art_P1083.jpg"/></p>
<p class="noindent">or, since <img alt="art" src="images/Art_P1084.jpg"/> by the cancellation lemma,</p>
<p class="eql"><img alt="art" src="images/Art_P1085.jpg"/></p>
<p class="noindent">Lines 10–11 combine the results of the recursive DFT<sub><em>n</em>/2</sub> calculations. For the first <em>n</em>/2 results <em>y</em><sub>0</sub>, <em>y</em><sub>1</sub>, … , <em>y</em><sub><em>n</em>/2−1</sub>, line 10 yields</p>
<p class="eql"><img alt="art" src="images/Art_P1086.jpg"/></p>
<p class="noindent">For <em>y</em><sub><em>n</em>/2</sub>, <em>y</em><sub><em>n</em>/2+1</sub>, … , <em>y</em><sub><em>n</em>−1</sub>, letting <em>k</em> = 0, 1, … , <em>n</em>/2 − 1, line 11 yields</p>
<a id="p891"/>
<p class="eql"><img alt="art" src="images/Art_P1087.jpg"/></p>
<p class="noindent">Thus the vector <em>y</em> returned by FFT is indeed the DFT of the input vector <em>a</em>.</p>
<p>Lines 10 and 11 multiply each value <img alt="art" src="images/Art_P1088.jpg"/> by <img alt="art" src="images/omega.jpg"/>, for <em>k</em> = 0, 1, … , <em>n</em>/2 − 1. Line 10 adds this product to <img alt="art" src="images/Art_P1089.jpg"/>, and line 11 subtracts it. Because each factor <img alt="art" src="images/omega.jpg"/> appears in both its positive and negative forms, we call the factors <img alt="art" src="images/omega.jpg"/> <strong><em><span class="blue1">twiddle factors</span></em></strong>.</p>
<p>To determine the running time of the procedure FFT, note that exclusive of the recursive calls, each invocation takes Θ(<em>n</em>) time, where <em>n</em> is the length of the input vector. The recurrence for the running time is therefore</p>
<table class="table2b">
<tr>
<td class="td2"><em>T</em>(<em>n</em>)</td>
<td class="td2">=</td>
<td class="td2">2<em>T</em>(<em>n</em>/2) + Θ(<em>n</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">Θ(<em>n</em> lg <em>n</em>),</td>
</tr>
</table>
<p class="noindent">by case 2 of the master theorem (Theorem 4.1). Thus the FFT can evaluate a polynomial of degree-bound <em>n</em> at the complex <em>n</em>th roots of unity in Θ(<em>n</em> lg <em>n</em>) time.</p>
<p class="level4"><strong>Interpolation at the complex roots of unity</strong></p>
<p class="noindent">The polynomial multiplication scheme entails converting from coefficient form to point-value form by evaluating the polynomial at the complex roots of unity, pointwise multiplying, and finally converting from point-value form back to coefficient form by interpolating. We’ve just seen how to evaluate, so now we’ll see how to interpolate the complex roots of unity by a polynomial. To interpolate, we’ll write the DFT as a matrix equation and then look at the form of the matrix inverse.</p>
<p>From equation (30.4), we can write the DFT as the matrix product <em>y</em> = <em>V<sub>n</sub>a</em>, where <em>V<sub>n</sub></em> is a Vandermonde matrix containing the appropriate powers of <em>ω<sub>n</sub></em>:</p>
<p class="eql"><img alt="art" src="images/Art_P1090.jpg"/></p>
<p class="noindent">The (<em>k</em>, <em>j</em>) entry of <em>V<sub>n</sub></em> is <img alt="art" src="images/Art_P1091.jpg"/>, for <em>j</em>, <em>k</em> = 0, 1, … , <em>n</em> − 1. The exponents of the entries of <em>V<sub>n</sub></em> form a multiplication table for factors 0 to <em>n</em> − 1.</p>
<a id="p892"/>
<p>For the inverse operation, which we write as <img alt="art" src="images/Art_P1092.jpg"/>, multiply <em>y</em> by the matrix <img alt="art" src="images/V1.jpg"/>, the inverse of <em>V<sub>n</sub></em>.</p>
<p class="theo"><strong><em>Theorem 30.7</em></strong></p>
<p class="noindent">For <em>j</em>, <em>k</em> = 0, 1, … , <em>n</em> − 1, the (<em>j</em>, <em>k</em>) entry of <img alt="art" src="images/V1.jpg"/> is <img alt="art" src="images/Art_P1093.jpg"/>.</p>
<p class="prof"><strong><em>Proof</em></strong>   We show that <img alt="art" src="images/Art_P1094.jpg"/>, the <em>n</em> × <em>n</em> identity matrix. Consider the (<em>k</em>, <em>k</em>′) entry of <img alt="art" src="images/Art_P1095.jpg"/>:</p>
<p class="eql"><img alt="art" src="images/Art_P1096.jpg"/></p>
<p class="noindent">This summation equals 1 if <em>k</em>′ = <em>k</em>, and it is 0 otherwise by the summation lemma (Lemma 30.6). Note that in order for the summation lemma to apply, <em>k</em>′ − <em>k</em> must not be divisible by <em>n</em>. Indeed, it is not, since −(<em>n</em> − 1) ≤ <em>k</em>′ − <em>k</em> ≤ <em>n</em> − 1.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">With the inverse matrix <img alt="art" src="images/V1.jpg"/> defined, <img alt="art" src="images/Art_P1097.jpg"/> is given by</p>
<p class="eqr"><img alt="art" src="images/Art_P1098.jpg"/></p>
<p class="noindent">for <em>j</em> = 0, 1, … , <em>n</em> − 1. By comparing equations (30.8) and (30.11), you can see that if you modify the FFT algorithm to switch the roles of <em>a</em> and <em>y</em>, replace <em>ω<sub>n</sub></em> by <img alt="art" src="images/Art_P1099.jpg"/>, and divide each element of the result by <em>n</em>, you get the inverse DFT (see Exercise 30.2-4). Thus, <img alt="art" src="images/DFT.jpg"/> is computable in Θ(<em>n</em> lg <em>n</em>) time as well.</p>
<p>Thus, the FFT and the inverse FFT provide a way to transform a polynomial of degree-bound <em>n</em> back and forth between its coefficient representation and a point-value representation in only Θ(<em>n</em> lg <em>n</em>) time. In the context of polynomial multiplication, we have shown the following about the convolution <em>a</em> ⊗ <em>b</em> of vectors <em>a</em> and <em>b</em>:</p>
<p class="theo"><strong><em>Theorem 30.8 (Convolution theorem)</em></strong></p>
<p class="noindent">For any two vectors <em>a</em> and <em>b</em> of length <em>n</em>, where <em>n</em> is an exact power of 2,</p>
<p class="eql"><img alt="art" src="images/Art_P1100.jpg"/></p>
<p class="noindent">where the vectors <em>a</em> and <em>b</em> are padded with 0s to length 2<em>n</em> and · denotes the componentwise product of two 2<em>n</em>-element vectors.</p>
<p class="right"><span class="font1">▪</span></p>
<a id="p893"/>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>30.2-1</em></strong></p>
<p class="noindent">Prove Corollary 30.4.</p>
<p class="level3"><strong><em>30.2-2</em></strong></p>
<p class="noindent">Compute the DFT of the vector (0, 1, 2, 3).</p>
<p class="level3"><strong><em>30.2-3</em></strong></p>
<p class="noindent">Do Exercise 30.1-1 by using the Θ(<em>n</em> lg <em>n</em>)-time scheme.</p>
<p class="level3"><strong><em>30.2-4</em></strong></p>
<p class="noindent">Write pseudocode to compute <img alt="art" src="images/DFT.jpg"/> in Θ(<em>n</em> lg <em>n</em>) time.</p>
<p class="level3"><strong><em>30.2-5</em></strong></p>
<p class="noindent">Describe the generalization of the FFT procedure to the case in which <em>n</em> is an exact power of 3. Give a recurrence for the running time, and solve the recurrence.</p>
<p class="level3"><span class="font1">★</span> <strong><em>30.2-6</em></strong></p>
<p class="noindent">Instead of performing an <em>n</em>-element FFT over the field of complex numbers (where <em>n</em> is an exact power of 2), let’s use the ring <span class="double"><span class="font1">ℤ</span></span><em><sub>m</sub></em> of integers modulo <em>m</em>, where <em>m</em> = 2<sup><em>tn</em>/2</sup> + 1 and <em>t</em> is an arbitrary positive integer. We can use <em>ω</em> = 2<em><sup>t</sup></em> instead of <em>ω<sub>n</sub></em> as a principal <em>n</em>th root of unity, modulo <em>m</em>. Prove that the DFT and the inverse DFT are well defined in this system.</p>
<p class="level3"><strong><em>30.2-7</em></strong></p>
<p class="noindent">Given a list of values <em>z</em><sub>0</sub>, <em>z</em><sub>1</sub>, … , <em>z</em><sub><em>n</em>−1</sub> (possibly with repetitions), show how to find the coefficients of a polynomial <em>P</em>(<em>x</em>) of degree-bound <em>n</em> + 1 that has zeros only at <em>z</em><sub>0</sub>, <em>z</em><sub>1</sub>, … , <em>z</em><sub><em>n</em>−1</sub> (possibly with repetitions). Your procedure should run in <em>O</em>(<em>n</em> lg<sup>2</sup> <em>n</em>) time. (<em>Hint:</em> The polynomial <em>P</em>(<em>x</em>) has a zero at <em>z<sub>j</sub></em> if and only if <em>P</em>(<em>x</em>) is a multiple of (<em>x</em> − <em>z<sub>j</sub></em>).)</p>
<p class="level3"><span class="font1">★</span> <strong><em>30.2-8</em></strong></p>
<p class="noindent">The <strong><em><span class="blue1">chirp transform</span></em></strong> of a vector <em>a</em> = (<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, … , <em>a</em><sub><em>n</em>−1</sub>) is the vector <em>y</em> = (<em>y</em><sub>0</sub>, <em>y</em><sub>1</sub>, … , <em>y</em><sub><em>n</em>−1</sub>), where <img alt="art" src="images/Art_P1101.jpg"/> and <em>z</em> is any complex number. The DFT is therefore a special case of the chirp transform, obtained by taking <em>z</em> = <em>ω<sub>n</sub></em>. Show how to evaluate the chirp transform for any complex number <em>z</em> in <em>O</em>(<em>n</em> lg <em>n</em>) time. (<em>Hint:</em> Use the equation</p>
<p class="eql"><img alt="art" src="images/Art_P1102.jpg"/></p>
<p class="noindent">to view the chirp transform as a convolution.)</p>
<a id="p894"/>
</section>
<p class="line1"/>
<section title="30.3 FFT circuits">
<a id="Sec_30.3"/>
<p class="level1" id="h1-174"><a href="toc.xhtml#Rh1-174"><strong>30.3    FFT circuits</strong></a></p>
<p class="noindent">Many of the FFT’s applications in signal processing require the utmost speed, and so the FFT is often implemented as a circuit in hardware. The FFT’s divide-and-conquer structure enables the circuit to have a parallel structure so that the <strong><em><span class="blue1">depth</span></em></strong> of the circuit—the maximum number of computational elements between any output and any input that can reach it—is Θ(lg <em>n</em>). Moreover, the structure of the FFT circuit has several interesting mathematical properties, which we won’t go into here.</p>
<p class="level4"><strong>Butterfly operations</strong></p>
<p class="noindent">Notice that the <strong>for</strong> loop of lines 9–12 of the FFT procedure computes the value <img alt="art" src="images/Art_P1103.jpg"/> twice per iteration: once in line 10 and once in line 11. A good optimizing compiler produces code that evaluates this <strong><em><span class="blue1">common subexpression</span></em></strong> just once, storing its value into a temporary variable, so that lines 10–11 are treated like the three lines</p>
<div class="pull-quote1">
<p class="pq-indent"><img alt="art" src="images/Art_P1104.jpg"/></p>
</div>
<p class="noindent">This operation, multiplying the twiddle factor <img alt="art" src="images/Art_P1105.jpg"/> by <img alt="art" src="images/Art_P1106.jpg"/>, storing the product into the temporary variable <em>t</em>, and adding and subtracting <em>t</em> from <img alt="art" src="images/Art_P1107.jpg"/>, is known as a <strong><em><span class="blue1">butterfly operation</span></em></strong>. <a href="chapter030.xhtml#Fig_30-3">Figure 30.3</a> shows it as a circuit, and you can see how it vaguely resembles the shape of a butterfly. (Although less colorfully, it could have been called a “bowtie” operation.)</p>
<div class="divimage">
<p class="fig-imga" id="Fig_30-3"><img alt="art" src="images/Art_P1108.jpg"/></p>
<p class="caption"><strong>Figure 30.3</strong> A circuit for a butterfly operation. <strong>(a)</strong> The two input values enter from the left, the twiddle factor <img alt="art" src="images/omega.jpg"/> is multiplied by <img alt="art" src="images/Art_P1109.jpg"/>, and the sum and difference are output on the right. <strong>(b)</strong> A simplified drawing of a butterfly operation, which we’ll use when drawing the parallel FFT circuit.</p>
</div>
<a id="p895"/>
<p class="block"/>
<div class="divimage">
<p class="fig-imga" id="Fig_30-4"><img alt="art" src="images/Art_P1110.jpg"/></p>
<p class="caption"><strong>Figure 30.4</strong> The schema for the conquer and combine steps of an <em>n</em>-input, <em>n</em>-output FFT circuit, FFT<em><sub>n</sub></em>, shown for <em>n</em> = 8. Inputs enter from the left, and outputs exit from the right. The input values first go through two FFT<sub><em>n</em>/2</sub> circuits, and then <em>n</em>/2 butterfly circuits combine the results. Only the top and bottom wires entering a butterfly interact with it: wires that pass through the middle of a butterfly do not affect that butterfly, nor are their values changed by that butterfly.</p>
</div>
<p class="level4"><strong>Recursive circuit structure</strong></p>
<p class="noindent">The FFT procedure follows the divide-and-conquer strategy that we first saw in <a href="chapter002.xhtml#Sec_2.3.1">Section 2.3.1</a>:</p>
<p class="para-hang-d"><strong>Divide</strong> the <em>n</em>-element input vector into its <em>n</em>/2 even-indexed and <em>n</em>/2 odd-indexed elements.</p>
<p class="para-hang-d"><strong>Conquer</strong> by recursively computing the DFTs of the two subproblems, each of size <em>n</em>/2.</p>
<p class="para-hang-d"><strong>Combine</strong> by performing <em>n</em>/2 butterfly operations. These butterfly operations work with twiddle factors <img alt="art" src="images/Art_P1111.jpg"/>, <img alt="art" src="images/Art_P1112.jpg"/>.</p>
<p class="space-break">The circuit schema in <a href="chapter030.xhtml#Fig_30-4">Figure 30.4</a> follows the conquer and combine steps of this pattern for an FFT circuit with <em>n</em> inputs and <em>n</em> outputs, denoted by FFT<em><sub>n</sub></em>. Each line is a wire that carries a value. Inputs enter from the left, one per wire, and outputs exit from the right. The conquer step runs the inputs through two FFT<sub><em>n</em>/2</sub> circuits, which are also constructed recursively. The values produced by the two FFT<sub><em>n</em>/2</sub> circuits feed into <em>n</em>/2 butterfly circuits, with twiddle factors <img alt="art" src="images/Art_P1113.jpg"/>, <img alt="art" src="images/Art_P1114.jpg"/>, <a id="p896"/>to combine the results. The base case of the recursion occurs when <em>n</em> = 1, where the sole output value equals the sole input value. An FFT<sub>1</sub> circuit, therefore, does nothing, and so the smallest nontrivial FFT circuit is FFT<sub>2</sub>, a single butterfly operation whose twiddle factor is <img alt="art" src="images/Art_P1115.jpg"/>.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_30-5"><img alt="art" src="images/Art_P1116.jpg"/></p>
<p class="caption"><strong>Figure 30.5</strong> The tree of input vectors to the recursive calls of the FFT procedure. The initial invocation is for <em>n</em> = 8.</p>
</div>
<p class="level4"><strong>Permuting the inputs</strong></p>
<p class="noindent">How does the divide step enter into the circuit design? Let’s examine how input vectors to the various recursive calls of the FFT procedure relate to the original input vector, so that the circuit can emulate the divide step at the start for all levels of recursion. <a href="chapter030.xhtml#Fig_30-5">Figure 30.5</a> arranges the input vectors to the recursive calls in an invocation of FFT in a tree structure, where the initial call is for <em>n</em> = 8. The tree has one node for each call of the procedure, labeled by the elements of the initial call as they appear in the corresponding input vector. Each FFT invocation makes two recursive calls, unless it has received a 1-element vector. The first call appears in the left child, and the second call appears in the right child.</p>
<p>Looking at the tree, observe that if you arrange the elements of the initial vector <em>a</em> into the order in which they appear in the leaves, you can trace the execution of the FFT procedure, but bottom up instead of top down. First, take the elements in pairs, compute the DFT of each pair using one butterfly operation, and replace the pair with its DFT. The vector then holds <em>n</em>/2 two-element DFTs. Next, take these <em>n</em>/2 DFTs in pairs and compute the DFT of the four vector elements they come from by executing two butterfly operations, replacing two two-element DFTs with one four-element DFT. The vector then holds <em>n</em>/4 four-element DFTs. Continue in this manner until the vector holds two (<em>n</em>/2)-element DFTs, which <em>n</em>/2 butterfly operations combine into the final <em>n</em>-element DFT. In other words, you can start with the elements of the initial vector <em>a</em>, but rearranged as in the leaves of <a href="chapter030.xhtml#Fig_30-5">Figure 30.5</a>, and then feed them directly into a circuit that follows the schema in <a href="chapter030.xhtml#Fig_30-4">Figure 30.4</a>.</p>
<a id="p897"/>
<p>Let’s think about the permutation that rearranges the input vector. The order in which the leaves appear in <a href="chapter030.xhtml#Fig_30-5">Figure 30.5</a> is a <strong><em><span class="blue1">bit-reversal permutation</span></em></strong>. That is, letting rev(<em>k</em>) be the lg <em>n</em>-bit integer formed by reversing the bits of the binary representation of <em>k</em>, then vector element <em>a<sub>k</sub></em> moves to position rev(<em>k</em>). In <a href="chapter030.xhtml#Fig_30-5">Figure 30.5</a>, for example, the leaves appear in the order 0, 4, 2, 6, 1, 5, 3, 7. This sequence in binary is 000, 100, 010, 110, 001, 101, 011, 111, and you can obtain it by reversing the bits of each number in the sequence 0, 1, 2, 3, 4, 6, 7 or, in binary, 000, 001, 010, 011, 100, 101, 110, 111. To see in general that the input vector should be rearranged by a bit-reversal permutation, note that at the top level of the tree, indices whose low-order bit is 0 go into the left subtree and indices whose low-order bit is 1 go into the right subtree. Stripping off the low-order bit at each level, continue this process down the tree, until you get the order given by the bit-reversal permutation at the leaves.</p>
<p class="level4"><strong>The full FFT circuit</strong></p>
<p class="noindent"><a href="chapter030.xhtml#Fig_30-6">Figure 30.6</a> depicts the entire circuit for <em>n</em> = 8. The circuit begins with a bit-reversal permutation of the inputs, followed by lg <em>n</em> stages, each stage consisting of <em>n</em>/2 butterflies executed in parallel. Assuming that each butterfly circuit has constant depth, the full circuit has depth Θ(lg <em>n</em>). The butterfly operations at each level of recursion in the FFT procedure are independent, and so the circuit performs them in parallel. The figure shows wires running from left to right, carrying values through the lg <em>n</em> stages. For <em>s</em> = 1, 2, … , lg <em>n</em>, stage <em>s</em> consists of <em>n</em>/2<em><sup>s</sup></em> groups of butterflies, with 2<sup><em>s</em>−1</sup> butterflies per group. The twiddle factors in stage <em>s</em> are <img alt="art" src="images/Art_P1117.jpg"/>, <img alt="art" src="images/Art_P1118.jpg"/>, where <em>m</em> = 2<em><sup>s</sup></em>.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>30.3-1</em></strong></p>
<p class="noindent">Show the values on the wires for each butterfly input and output in the FFT circuit of <a href="chapter030.xhtml#Fig_30-6">Figure 30.6</a>, given the input vector (0, 2, 3, −1, 4, 5, 7, 9).</p>
<p class="level3"><strong><em>30.3-2</em></strong></p>
<p class="noindent">Consider an FFT<em><sub>n</sub></em> circuit, such as in <a href="chapter030.xhtml#Fig_30-6">Figure 30.6</a>, with wires 0, 1, … , <em>n</em>−1 (wire <em>j</em> has output <em>y<sub>j</sub></em>) and stages numbered as in the figure. Stage <em>s</em>, for <em>s</em> = 1, 2 … , lg <em>n</em>, consists of <em>n</em>/2<em><sup>s</sup></em> groups of butterflies. Which two wires are inputs and outputs for the <em>j</em>th butterfly circuit in the <em>g</em>th group in stage <em>s</em>?</p>
<p class="level3"><strong><em>30.3-3</em></strong></p>
<p class="noindent">Consider a <em>b</em>-bit integer <em>k</em> in the range 0 ≤ <em>k</em> &lt; 2<em><sup>b</sup></em>. Treating <em>k</em> as a <em>b</em>-element vector over {0, 1}, describe a <em>b</em> × <em>b</em> matrix <em>M</em> such that the matrix-vector product <em>Mk</em> is the binary representation of rev(<em>k</em>).</p>
<a id="p898"/>
<div class="divimage">
<p class="fig-imga" id="Fig_30-6"><img alt="art" src="images/Art_P1119.jpg"/></p>
<p class="caption"><strong>Figure 30.6</strong> A full circuit that computes the FFT in parallel, here shown for <em>n</em> = 8 inputs. It has lg <em>n</em> stages, and each stage comprises <em>n</em>/2 butterflies that can operate in parallel. As in <a href="chapter030.xhtml#Fig_30-4">Figure 30.4</a>, only the top and bottom wires entering a butterfly interact with it. For example, the top butterfly in stage 2 has inputs and outputs only on wires 0 and 2 (the wires with outputs <em>y</em><sub>0</sub> and <em>y</em><sub>2</sub>, respectively). This circuit has depth Θ(lg <em>n</em>) and performs Θ(<em>n</em> lg <em>n</em>) butterfly operations altogether.</p>
</div>
<p class="level3"><strong><em>30.3-4</em></strong></p>
<p class="noindent">Write pseudocode for the procedure B<small>IT</small>-R<small>EVERSE</small>-P<small>ERMUTATION</small>(<em>a</em>, <em>n</em>), which performs the bit-reversal permutation on a vector <em>a</em> of length <em>n</em> in-place. Assume that you may call the procedure B<small>IT</small>-R<small>EVERSE</small>-O<small>F</small>(<em>k</em>, <em>b</em>), which returns an integer that is the <em>b</em>-bit reversal of the nonnegative integer <em>k</em>, where 0 ≤ <em>k</em> &lt; 2<em><sup>b</sup></em>.</p>
<p class="level3"><span class="font1">★</span> <strong><em>30.3-5</em></strong></p>
<p class="noindent">Suppose that the adders within the butterfly operations of a given FFT circuit sometimes fail in such a manner that they always produce a 0 output, independent of their inputs. In addition, suppose that exactly one adder has failed, but you don’t know which one. Describe how you can identify the failed adder by supplying inputs to the overall FFT circuit and observing the outputs. How efficient is your method?</p>
<a id="p899"/>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-175"><strong>Problems</strong></p>
<section title="30-1 Divide-and-conquer multiplication">
<p class="level2"><strong><em>30-1     Divide-and-conquer multiplication</em></strong></p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Show how to multiply two linear polynomials <em>ax</em> + <em>b</em> and <em>cx</em> + <em>d</em> using only three multiplications. (<em>Hint:</em> One of the multiplications is (<em>a</em> + <em>b</em>) · (<em>c</em> + <em>d</em>).)</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Give two divide-and-conquer algorithms for multiplying two polynomials of degree-bound <em>n</em> in Θ(<em>n</em><sup>lg 3</sup>) time. The first algorithm should divide the input polynomial coefficients into a high half and a low half, and the second algorithm should divide them according to whether their index is odd or even.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Show how to multiply two <em>n</em>-bit integers in <em>O</em>(<em>n</em><sup>lg 3</sup>) steps, where each step operates on at most a constant number of 1-bit values.</p>
</section>
<section title="30-2 Multidimensional fast Fourier transform">
<p class="level2"><strong><em>30-2     Multidimensional fast Fourier transform</em></strong></p>
<p class="noindent">The 1-dimensional discrete Fourier transform defined by equation (30.8) generalizes to <em>d</em> dimensions. The input is a <em>d</em>-dimensional array <em>A</em> = (<em>a</em><sub><em>j</em>1,<em>j</em>2,…,<em>j<sub>d</sub></em></sub>) whose dimensions are <em>n</em><sub>1</sub>, <em>n</em><sub>2</sub>, … , <em>n<sub>d</sub></em>, where <em>n</em><sub>1</sub><em>n</em><sub>2</sub> <span class="font1">⋯</span> <em>n<sub>d</sub></em> = <em>n</em>. The <em>d</em>-dimensional discrete Fourier transform is defined by the equation</p>
<p class="eql"><img alt="art" src="images/Art_P1120.jpg"/></p>
<p class="noindent">for 0 ≤ <em>k</em><sub>1</sub> &lt; <em>n</em><sub>1</sub>, 0 ≤ <em>k</em><sub>2</sub> &lt; <em>n</em><sub>2</sub>, … , 0 ≤ <em>k<sub>d</sub></em> &lt; <em>n<sub>d</sub></em>.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Show how to produce a <em>d</em>-dimensional DFT by computing 1-dimensional DFTs on each dimension in turn. That is, first compute <em>n</em>/<em>n</em><sub>1</sub> separate 1-dimensional DFTs along dimension 1. Then, using the result of the DFTs along dimension 1 as the input, compute <em>n</em>/<em>n</em><sub>2</sub> separate 1-dimensional DFTs along dimension 2. Using this result as the input, compute <em>n</em>/<em>n</em><sub>3</sub> separate 1-dimensional DFTs along dimension 3, and so on, through dimension <em>d</em>.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Show that the ordering of dimensions does not matter, so that if you compute the 1-dimensional DFTs in any order of the <em>d</em> dimensions, you compute the <em>d</em>-dimensional DFT.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Show that if you compute each 1-dimensional DFT by computing the fast Fourier transform, the total time to compute a <em>d</em>-dimensional DFT is <em>O</em>(<em>n</em> lg <em>n</em>), independent of <em>d</em>.</p>
<a id="p900"/>
</section>
<section title="30-3 Evaluating all derivatives of a polynomial at a point">
<p class="level2"><strong><em>30-3     Evaluating all derivatives of a polynomial at a point</em></strong></p>
<p class="noindent">Given a polynomial <em>A</em>(<em>x</em>) of degree-bound <em>n</em>, we define its <em>t</em>th derivative by</p>
<p class="eql"><img alt="art" src="images/Art_P1121.jpg"/></p>
<p class="noindent">In this problem, you will show how to determine <em>A</em><sup>(<em>t</em>)</sup>(<em>x</em><sub>0</sub>) for <em>t</em> = 0, 1, … , <em>n</em> − 1, given the coefficient representation (<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, … , <em>a</em><sub><em>n</em>−1</sub>) of <em>A</em>(<em>x</em>) and a point <em>x</em><sub>0</sub>.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Given coefficients <em>b</em><sub>0</sub>, <em>b</em><sub>1</sub>, … , <em>b</em><sub><em>n</em>−1</sub> such that</p>
<p class="nl-1list-dp1"><img alt="art" src="images/Art_P1122.jpg"/></p>
<p class="nl-1list-dp1">show how to compute <em>A</em><sup>(<em>t</em>)</sup>(<em>x</em><sub>0</sub>), for <em>t</em> = 0, 1, … , <em>n</em> − 1, in <em>O</em>(<em>n</em>) time.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Explain how to find <em>b</em><sub>0</sub>, <em>b</em><sub>1</sub>, … , <em>b</em><sub><em>n</em>−1</sub> in <em>O</em>(<em>n</em> lg <em>n</em>) time, given <img alt="art" src="images/Art_P1123.jpg"/> for <em>k</em> = 0, 1, … , <em>n</em> − 1.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Prove that</p>
<p class="nl-1list-dp1"><img alt="art" src="images/Art_P1124.jpg"/></p>
<p class="nl-1list-dp1">where <em>f</em>(<em>j</em>) = <em>a<sub>j</sub></em> · <em>j</em>! and</p>
<p class="nl-1list-dp1"><img alt="art" src="images/Art_P1125.jpg"/></p>
<p class="nl-1list-d"><strong><em>d.</em></strong> Explain how to evaluate <img alt="art" src="images/Art_P1126.jpg"/> for <em>k</em> = 0, 1, … , <em>n</em> − 1 in <em>O</em>(<em>n</em> lg <em>n</em>) time. Conclude that you can evaluate all nontrivial derivatives of <em>A</em>(<em>x</em>) at <em>x</em><sub>0</sub> in <em>O</em>(<em>n</em> lg <em>n</em>) time.</p>
</section>
<section title="30-4 Polynomial evaluation at multiple points">
<p class="level2"><strong><em>30-4     Polynomial evaluation at multiple points</em></strong></p>
<p class="noindent">Problem 2-3 showed how to evaluate a polynomial of degree-bound <em>n</em> at a single point in <em>O</em>(<em>n</em>) time using Horner’s rule. This chapter described how to evaluate such a polynomial at all <em>n</em> complex roots of unity in <em>O</em>(<em>n</em> lg <em>n</em>) time using the FFT. Now, you will show how to evaluate a polynomial of degree-bound <em>n</em> at <em>n</em> arbitrary points in <em>O</em>(<em>n</em> lg<sup>2</sup> <em>n</em>) time.</p>
<a id="p901"/>
<p>To do so, assume that you can compute the polynomial remainder when one such polynomial is divided by another in <em>O</em>(<em>n</em> lg <em>n</em>) time. For example, the remainder of 3<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> − 3<em>x</em> + 1 when divided by <em>x</em><sup>2</sup> + <em>x</em> + 2 is</p>
<p class="eql">(3<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> − 3<em>x</em> + 1) mod (<em>x</em><sup>2</sup> + <em>x</em> + 2) = −7<em>x</em> + 5.</p>
<p>Given the coefficient representation of a polynomial <img alt="art" src="images/Art_P1127.jpg"/> and <em>n</em> points <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, … , <em>x</em><sub><em>n</em>−1</sub>, your goal is to compute the <em>n</em> values <em>A</em>(<em>x</em><sub>0</sub>), <em>A</em>(<em>x</em><sub>1</sub>), … , <em>A</em>(<em>x</em><sub><em>n</em>−1</sub>). For 0 ≤ <em>i</em> ≤ <em>j</em> ≤ <em>n</em> − 1, define the polynomials <img alt="art" src="images/Art_P1128.jpg"/> and <em>Q<sub>ij</sub></em>(<em>x</em>) = <em>A</em>(<em>x</em>) mod <em>P<sub>ij</sub></em>(<em>x</em>). Note that <em>Q<sub>ij</sub></em>(<em>x</em>) has degree at most <em>j</em> − <em>i</em>.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Prove that <em>A</em>(<em>x</em>) mod (<em>x</em> − <em>z</em>) = <em>A</em>(<em>z</em>) for any point <em>z</em>.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Prove that <em>Q<sub>kk</sub></em>(<em>x</em>) = <em>A</em>(<em>x<sub>k</sub></em>) and that <em>Q</em><sub>0,<em>n</em>−1</sub>(<em>x</em>) = <em>A</em>(<em>x</em>).</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Prove that for <em>i</em> ≤ <em>k</em> ≤ <em>j</em>, we have both <em>Q<sub>ik</sub></em>(<em>x</em>) = <em>Q<sub>ij</sub></em>(<em>x</em>) mod <em>P<sub>ik</sub></em>(<em>x</em>) and <em>Q<sub>kj</sub></em>(<em>x</em>) = <em>Q<sub>ij</sub></em>(<em>x</em>) mod <em>P<sub>kj</sub></em>(<em>x</em>).</p>
<p class="nl-1list-d"><strong><em>d.</em></strong> Give an <em>O</em>(<em>n</em> lg<sup>2</sup> <em>n</em>)-time algorithm to evaluate <em>A</em>(<em>x</em><sub>0</sub>), <em>A</em>(<em>x</em><sub>1</sub>), … , <em>A</em>(<em>x</em><sub><em>n</em>−1</sub>).</p>
</section>
<section title="30-5 FFT using modular arithmetic">
<p class="level2"><strong><em>30-5     FFT using modular arithmetic</em></strong></p>
<p class="noindent">As defined, the discrete Fourier transform requires computation with complex numbers, which can result in a loss of precision due to round-off errors. For some problems, the answer is known to contain only integers, and a variant of the FFT based on modular arithmetic can guarantee that the answer is calculated exactly. An example of such a problem is that of multiplying two polynomials with integer coefficients. Exercise 30.2-6 gives one approach, using a modulus of length Ω(<em>n</em>) bits to handle a DFT on <em>n</em> points. This problem explores another approach that uses a modulus of the more reasonable length <em>O</em>(lg <em>n</em>), but it requires that you understand the material of <a href="chapter031.xhtml">Chapter 31</a>. Let <em>n</em> be an exact power of 2.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> You wish to search for the smallest <em>k</em> such that <em>p</em> = <em>kn</em> + 1 is prime. Give a simple heuristic argument why you might expect <em>k</em> to be approximately ln <em>n</em>. (The value of <em>k</em> might be much larger or smaller, but you can reasonably expect to examine <em>O</em>(lg <em>n</em>) candidate values of <em>k</em> on average.) How does the expected length of <em>p</em> compare to the length of <em>n</em>?</p>
<p class="noindent">Let <em>g</em> be a generator of <img alt="art" src="images/Art_P1129.jpg"/>, and let <em>w</em> = <em>g<sup>k</sup></em> mod <em>p</em>.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Argue that the DFT and the inverse DFT are well-defined inverse operations modulo <em>p</em>, where <em>w</em> is used as a principal <em>n</em>th root of unity.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Show how to make the FFT and its inverse work modulo <em>p</em> in <em>O</em>(<em>n</em> lg <em>n</em>) time, where operations on words of <em>O</em>(lg <em>n</em>) bits take unit time. Assume that the algorithm is given <em>p</em> and <em>w</em>.</p>
<a id="p902"/>
<p class="nl-1list-d"><strong><em>d.</em></strong> Compute the DFT modulo <em>p</em> = 17 of the vector (0, 5, 3, 7, 7, 2, 1, 6). (<em>Hint:</em> Verify and use the fact that <em>g</em> = 3 is a generator of <img alt="art" src="images/Art_P1130.jpg"/>.)</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-176"><strong>Chapter notes</strong></p>
<p class="noindent">Van Loan’s book [<a epub:type="noteref" href="bibliography001.xhtml#endnote_442">442</a>] provides an outstanding treatment of the fast Fourier transform. Press, Teukolsky, Vetterling, and Flannery [<a epub:type="noteref" href="bibliography001.xhtml#endnote_365">365</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_366">366</a>] offer a good description of the fast Fourier transform and its applications. For an excellent introduction to signal processing, a popular FFT application area, see the texts by Oppenheim and Schafer [<a epub:type="noteref" href="bibliography001.xhtml#endnote_347">347</a>] and Oppenheim and Willsky [<a epub:type="noteref" href="bibliography001.xhtml#endnote_348">348</a>]. The Oppenheim and Schafer book also shows how to handle cases in which <em>n</em> is not an exact power of 2.</p>
<p>Fourier analysis is not limited to 1-dimensional data. It is widely used in image processing to analyze data in two or more dimensions. The books by Gonzalez and Woods [<a epub:type="noteref" href="bibliography001.xhtml#endnote_194">194</a>] and Pratt [<a epub:type="noteref" href="bibliography001.xhtml#endnote_363">363</a>] discuss multidimensional Fourier transforms and their use in image processing, and books by Tolimieri, An, and Lu [<a epub:type="noteref" href="bibliography001.xhtml#endnote_439">439</a>] and Van Loan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_442">442</a>] discuss the mathematics of multidimensional fast Fourier transforms.</p>
<p>Cooley and Tukey [<a epub:type="noteref" href="bibliography001.xhtml#endnote_101">101</a>] are widely credited with devising the FFT in the 1960s. The FFT had in fact been discovered many times previously, but its importance was not fully realized before the advent of modern digital computers. Although Press, Teukolsky, Vetterling, and Flannery attribute the origins of the method to Runge and König in 1924, an article by Heideman, Johnson, and Burrus [<a epub:type="noteref" href="bibliography001.xhtml#endnote_211">211</a>] traces the history of the FFT as far back as C. F. Gauss in 1805.</p>
<p>Frigo and Johnson [<a epub:type="noteref" href="bibliography001.xhtml#endnote_161">161</a>] developed a fast and flexible implementation of the FFT, called FFTW (“fastest Fourier transform in the West”). FFTW is designed for situations requiring multiple DFT computations on the same problem size. Before actually computing the DFTs, FFTW executes a “planner,” which, by a series of trial runs, determines how best to decompose the FFT computation for the given problem size on the host machine. FFTW adapts to use the hardware cache efficiently, and once subproblems are small enough, FFTW solves them with optimized, straight-line code. Moreover, FFTW has the advantage of taking Θ(<em>n</em> lg <em>n</em>) time for any problem size <em>n</em>, even when <em>n</em> is a large prime.</p>
<p>Although the standard Fourier transform assumes that the input represents points that are uniformly spaced in the time domain, other techniques can approximate the FFT on “nonequispaced” data. The article by Ware [<a epub:type="noteref" href="bibliography001.xhtml#endnote_449">449</a>] provides an overview.</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> Interpolation is a notoriously tricky problem from the point of view of numerical stability. Although the approaches described here are mathematically correct, small differences in the inputs or round-off errors during computation can cause large differences in the result.</p>
<p class="footnote1" id="footnote_2"><a href="#footnote_ref_2"><sup>2</sup></a> Many other authors define <em>ω<sub>n</sub></em> differently: <em>ω<sub>n</sub></em> = <em>e</em><sup>−2<em>πi</em>/<em>n</em></sup>. This alternative definition tends to be used for signal-processing applications. The underlying mathematics is substantially the same with either definition of <em>ω<sub>n</sub></em>.</p>
<p class="footnote1" id="footnote_3"><a href="#footnote_ref_3"><sup>3</sup></a> The length <em>n</em> is actually what <a href="chapter030.xhtml#Sec_30.1">Section 30.1</a> referred to as 2<em>n</em>, since the degree-bound of the given polynomials doubles prior to evaluation. In the context of polynomial multiplication, therefore, we are actually working with complex (2<em>n</em>)th roots of unity.</p>
<p class="footnote1" id="footnote_4"><a href="#footnote_ref_4"><sup>4</sup></a> The downside of iteratively updating <em>ω</em> is that round-off errors can accumulate, especially for larger input sizes. Several techniques to limit the magnitude of FFT round-off errors have been proposed, but are beyond the scope of this book. If several FFTs are going to be run on inputs of the same size, then it might be worthwhile to directly precompute a table of all <em>n</em>/2 values of <img alt="art" src="images/omega.jpg"/>.</p>
</section>
</section>
</div>
</body>
</html>