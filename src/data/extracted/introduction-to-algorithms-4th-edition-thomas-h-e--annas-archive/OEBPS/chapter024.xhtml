<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p670"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="24 Maximum Flow">
<p class="chapter-title"><a href="toc.xhtml#chap-24"><strong><span class="blue1">24        Maximum Flow</span></strong></a></p>
<p class="noindent">Just as you can model a road map as a directed graph in order to find the shortest path from one point to another, you can also interpret a directed graph as a “flow network” and use it to answer questions about material flows. Imagine a material coursing through a system from a source, where the material is produced, to a sink, where it is consumed. The source produces the material at some steady rate, and the sink consumes the material at the same rate. The “flow” of the material at any point in the system is intuitively the rate at which the material moves. Flow networks can model many problems, including liquids flowing through pipes, parts through assembly lines, current through electrical networks, and information through communication networks.</p>
<p>You can think of each directed edge in a flow network as a conduit for the material. Each conduit has a stated capacity, given as a maximum rate at which the material can flow through the conduit, such as 200 gallons of liquid per hour through a pipe or 20 amperes of electrical current through a wire. Vertices are conduit junctions, and other than the source and sink, material flows through the vertices without collecting in them. In other words, the rate at which material enters a vertex must equal the rate at which it leaves the vertex. We call this property “flow conservation,” and it is equivalent to Kirchhoff’s current law when the material is electrical current.</p>
<p>The goal of the maximum-flow problem is to compute the greatest rate for shipping material from the source to the sink without violating any capacity constraints. It is one of the simplest problems concerning flow networks and, as we shall see in this chapter, this problem can be solved by efficient algorithms. Moreover, other network-flow problems are solvable by adapting the basic techniques used in maximum-flow algorithms.</p>
<p>This chapter presents two general methods for solving the maximum-flow problem. <a href="chapter024.xhtml#Sec_24.1">Section 24.1</a> formalizes the notions of flow networks and flows, formally defining the maximum-flow problem. <a href="chapter024.xhtml#Sec_24.2">Section 24.2</a> describes the classical method <a id="p671"/>of Ford and Fulkerson for finding maximum flows. We finish up with a simple application of this method, finding a maximum matching in an undirected bipartite graph, in <a href="chapter024.xhtml#Sec_24.3">Section 24.3</a>. (<a href="chapter025.xhtml#Sec_25.1">Section 25.1</a> will give a more efficient algorithm that is specifically designed to find a maximum matching in a bipartite graph.)</p>
<p class="line1"/>
<section title="24.1 Flow networks">
<a id="Sec_24.1"/>
<p class="level1" id="h1-141"><a href="toc.xhtml#Rh1-141"><strong>24.1    Flow networks</strong></a></p>
<p class="noindent">This section gives a graph-theoretic definition of flow networks, discusses their properties, and defines the maximum-flow problem precisely. It also introduces some helpful notation.</p>
<p class="level4"><strong>Flow networks and flows</strong></p>
<p class="noindent">A <strong><em><span class="blue">flow network</span></em></strong> <em>G</em> = (<em>V</em>, <em>E</em>) is a directed graph in which each edge (<em>u</em>, <em>v</em>) ∈ <em>E</em> has a nonnegative <strong><em><span class="blue">capacity</span></em></strong> <em>c</em>(<em>u</em>, <em>v</em>) ≥ 0. We further require that if <em>E</em> contains an edge (<em>u</em>, <em>v</em>), then there is no edge (<em>v</em>, <em>u</em>) in the reverse direction. (We’ll see shortly how to work around this restriction.) If (<em>u</em>, <em>v</em>) ∉ <em>E</em>, then for convenience we define <em>c</em>(<em>u</em>, <em>v</em>) = 0, and we disallow self-loops. Each flow network contains two distinguished vertices: a <strong><em><span class="blue">source</span></em></strong> <em>s</em> and a <strong><em><span class="blue">sink</span></em></strong> <em>t</em>. For convenience, we assume that each vertex lies on some path from the source to the sink. That is, for each vertex <em>v</em> ∈ <em>V</em>, the flow network contains a path <em>s</em> <span class="font1">⇝</span> <em>v</em> <span class="font1">⇝</span> <em>t</em>. Because each vertex other than <em>s</em> has at least one entering edge, we have |<em>E</em>| ≥ |<em>V</em> | − 1. <a href="chapter024.xhtml#Fig_24-1">Figure 24.1</a> shows an example of a flow network.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_24-1"><img alt="art" src="images/Art_P753.jpg"/></p>
<p class="caption"><strong>Figure 24.1 (a)</strong> A flow network <em>G</em> = (<em>V</em>, <em>E</em>) for the Lucky Puck Company’s trucking problem. The Vancouver factory is the source <em>s</em>, and the Winnipeg warehouse is the sink <em>t</em>. The company ships pucks through intermediate cities, but only <em>c</em>(<em>u</em>, <em>v</em>) crates per day can go from city <em>u</em> to city <em>v</em>. Each edge is labeled with its capacity. <strong>(b)</strong> A flow <em>f</em> in <em>G</em> with value |<em>f</em> | = 19. Each edge (<em>u</em>, <em>v</em>) is labeled by <em>f</em> (<em>u</em>, <em>v</em>)/<em>c</em>(<em>u</em>, <em>v</em>). The slash notation merely separates the flow and capacity and does not indicate division.</p>
</div>
<a id="p672"/>
<p>We are now ready to define flows more formally. Let <em>G</em> = (<em>V</em>, <em>E</em>) be a flow network with a capacity function <em>c</em>. Let <em>s</em> be the source of the network, and let <em>t</em> be the sink. A <strong><em><span class="blue">flow</span></em></strong> in <em>G</em> is a real-valued function <em>f</em> : <em>V</em> × <em>V</em> → <span class="font1">ℝ</span> that satisfies the following two properties:</p>
<p class="para-hang-d"><strong>Capacity constraint:</strong> For all <em>u</em>, <em>v</em> ∈ <em>V</em>, we require</p>
<p class="para-hang-dp1">0 ≤ <em>f</em>(<em>u</em>, <em>v</em>) ≤ <em>c</em>(<em>u</em>, <em>v</em>).</p>
<p class="para-hang-dp1">The flow from one vertex to another must be nonnegative and must not exceed the given capacity.</p>
<p class="para-hang-d"><strong>Flow conservation:</strong> For all <em>u</em> ∈ <em>V</em> − {<em>s</em>, <em>t</em>}, we require</p>
<p class="para-hang-dp1"><img alt="art" src="images/Art_P754.jpg"/></p>
<p class="para-hang-dp1">The total flow into a vertex other than the source or sink must equal the total flow out of that vertex—informally, “flow in equals flow out.”</p>
<p class="noindent1-top">When (<em>u</em>, <em>v</em>) ∉ <em>E</em>, there can be no flow from <em>u</em> to <em>v</em>, and <em>f</em> (<em>u</em>, <em>v</em>) = 0.</p>
<p>We call the nonnegative quantity <em>f</em> (<em>u</em>, <em>v</em>) the flow from vertex <em>u</em> to vertex <em>v</em>. The <strong><em><span class="blue">value</span></em></strong> |<em>f</em> | of a flow <em>f</em> is defined as</p>
<p class="eqr"><img alt="art" src="images/Art_P755.jpg"/></p>
<p class="noindent">that is, the total flow out of the source minus the flow into the source. (Here, the |·| notation denotes flow value, not absolute value or cardinality.) Typically, a flow network does not have any edges into the source, and the flow into the source, given by the summation Σ<sub><em>v</em>∈<em>V</em></sub> <em>f</em>(<em>v</em>, <em>s</em>), is 0. We include it, however, because when we introduce residual networks later in this chapter, the flow into the source can be positive. In the <strong><em><span class="blue">maximum-flow problem</span></em></strong>, the input is a flow network <em>G</em> with source <em>s</em> and sink <em>t</em>, and the goal is to find a flow of maximum value.</p>
<p class="level4"><strong>An example of flow</strong></p>
<p>A flow network can model the trucking problem shown in <a href="chapter024.xhtml#Fig_24-1">Figure 24.1(a)</a>. The Lucky Puck Company has a factory (source <em>s</em>) in Vancouver that manufactures hockey pucks, and it has a warehouse (sink <em>t</em>) in Winnipeg that stocks them. Lucky Puck leases space on trucks from another firm to ship the pucks from the factory to the warehouse. Because the trucks travel over specified routes (edges) between cities (vertices) and have a limited capacity, Lucky Puck can ship at most <em>c</em>(<em>u</em>, <em>v</em>) crates per day between each pair of cities <em>u</em> and <em>v</em> in <a href="chapter024.xhtml#Fig_24-1">Figure 24.1(a)</a>. Lucky Puck <a id="p673"/>has no control over these routes and capacities, and so the company cannot alter the flow network shown in <a href="chapter024.xhtml#Fig_24-1">Figure 24.1(a)</a>. They need to determine the largest number <em>p</em> of crates per day that they can ship and then to produce this amount, since there is no point in producing more pucks than they can ship to their warehouse. Lucky Puck is not concerned with how long it takes for a given puck to get from the factory to the warehouse. They care only that <em>p</em> crates per day leave the factory and <em>p</em> crates per day arrive at the warehouse.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_24-2"><img alt="art" src="images/Art_P756.jpg"/></p>
<p class="caption"><strong>Figure 24.2</strong> Converting a network with antiparallel edges to an equivalent one with no antiparallel edges. <strong>(a)</strong> A flow network containing both the edges (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>) and (<em>v</em><sub>2</sub>, <em>v</em><sub>1</sub>). <strong>(b)</strong> An equivalent network with no antiparallel edges. A new vertex <em>v</em>′ was added, and edge (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>) was replaced by the pair of edges (<em>v</em><sub>1</sub>, <em>v</em>′) and (<em>v</em>′, <em>v</em><sub>2</sub>), both with the same capacity as (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>).</p>
</div>
<p>A flow in this network models the “flow” of shipments because the number of crates shipped per day from one city to another is subject to a capacity constraint. Additionally, the model must obey flow conservation, for in a steady state, the rate at which pucks enter an intermediate city must equal the rate at which they leave. Otherwise, crates would accumulate at intermediate cities.</p>
<p class="level4"><strong>Modeling problems with antiparallel edges</strong></p>
<p class="noindent">Suppose that the trucking firm offers Lucky Puck the opportunity to lease space for 10 crates in trucks going from Edmonton to Calgary. It might seem natural to add this opportunity to our example and form the network shown in <a href="chapter024.xhtml#Fig_24-2">Figure 24.2(a)</a>. This network suffers from one problem, however: it violates the original assumption that if edge (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>) ∈ <em>E</em>, then (<em>v</em><sub>2</sub>, <em>v</em><sub>1</sub>) ∉ <em>E</em>. We call the two edges (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>) and (<em>v</em><sub>2</sub>, <em>v</em><sub>1</sub>) <strong><em><span class="blue">antiparallel</span></em></strong>. Thus, to model a flow problem with antiparallel edges, the network must be transformed into an equivalent one containing no antiparallel edges. <a href="chapter024.xhtml#Fig_24-2">Figure 24.2(b)</a> displays this equivalent network. To transform the network, choose one of the two antiparallel edges, in this case (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>), and split it by adding a new vertex <em>v</em>′ and replacing edge (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>) with the pair of edges (<em>v</em><sub>1</sub>, <em>v</em>′) and (<em>v</em>′, <em>v</em><sub>2</sub>). Also set the capacity of both new edges to the capacity of the original edge. The resulting network satisfies the property that if an edge belongs to <a id="p674"/>the network, the reverse edge does not. As Exercise 24.1-1 asks you to prove, the resulting network is equivalent to the original one.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_24-3"><img alt="art" src="images/Art_P757.jpg"/></p>
<p class="caption"><strong>Figure 24.3</strong> Converting a multiple-source, multiple-sink maximum-flow problem into a problem with a single source and a single sink. <strong>(a)</strong> A flow network with three sources <em>S</em> = {<em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, <em>s</em><sub>3</sub>} and two sinks <em>T</em> = {<em>t</em><sub>1</sub>, <em>t</em><sub>2</sub>}. <strong>(b)</strong> An equivalent single-source, single-sink flow network. Add a supersource <em>s</em> and an edge with infinite capacity from <em>s</em> to each of the multiple sources. Also add a supersink <em>t</em> and an edge with infinite capacity from each of the multiple sinks to <em>t</em>.</p>
</div>
<p class="level4"><strong>Networks with multiple sources and sinks</strong></p>
<p class="noindent">A maximum-flow problem may have several sources and sinks, rather than just one of each. The Lucky Puck Company, for example, might actually have a set of <em>m</em> factories {<em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, …, <em>s</em><sub><em>m</em></sub>} and a set of <em>n</em> warehouses {<em>t</em><sub>1</sub>, <em>t</em><sub>2</sub>, …, <em>t</em><sub><em>n</em></sub>}, as shown in <a href="chapter024.xhtml#Fig_24-3">Figure 24.3(a)</a>. Fortunately, this problem is no harder than ordinary maximum flow.</p>
<p>The problem of determining a maximum flow in a network with multiple sources and multiple sinks reduces to an ordinary maximum-flow problem. <a href="chapter024.xhtml#Fig_24-3">Figure 24.3(b)</a> shows how to convert the network from (a) to an ordinary flow network with only a single source and a single sink. Add a <strong><em><span class="blue">supersource</span></em></strong> <em>s</em> and add a directed edge (<em>s</em>, <em>s</em><sub><em>i</em></sub>) with capacity <em>c</em>(<em>s</em>, <em>s</em><sub><em>i</em></sub>) = ∞ for each <em>i</em> = 1, 2, …, <em>m</em>. Similarly, create a new <strong><em><span class="blue">supersink</span></em></strong> <em>t</em> and add a directed edge (<em>t</em><sub><em>i</em></sub>, <em>t</em>) with capacity <em>c</em>(<em>t</em><sub><em>i</em></sub>, <em>t</em>) = ∞ for each <em>i</em> = 1, 2, …, <em>n</em>. Intuitively, any flow in the network in (a) corresponds to a flow in the network in (b), and vice versa. The single supersource <em>s</em> provides as much flow as desired for the multiple sources <em>s</em><sub><em>i</em></sub>, and the single supersink <em>t</em> likewise consumes as much flow as desired for the multiple sinks <em>t</em><sub><em>i</em></sub>. Exercise 24.1-2 asks you to prove formally that the two problems are equivalent.</p>
<a id="p675"/>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>24.1-1</em></strong></p>
<p class="noindent">Show that splitting an edge in a flow network yields an equivalent network. More formally, suppose that flow network <em>G</em> contains edge (<em>u</em>, <em>v</em>), and define a new flow network <em>G</em>′ by creating a new vertex <em>x</em> and replacing (<em>u</em>, <em>v</em>) by new edges (<em>u</em>, <em>x</em>) and (<em>x</em>, <em>v</em>) with <em>c</em>(<em>u</em>, <em>x</em>) = <em>c</em>(<em>x</em>, <em>v</em>) = <em>c</em>(<em>u</em>, <em>v</em>). Show that a maximum flow in <em>G</em>′ has the same value as a maximum flow in <em>G</em>.</p>
<p class="level3"><strong><em>24.1-2</em></strong></p>
<p class="noindent">Extend the flow properties and definitions to the multiple-source, multiple-sink problem. Show that any flow in a multiple-source, multiple-sink flow network corresponds to a flow of identical value in the single-source, single-sink network obtained by adding a supersource and a supersink, and vice versa.</p>
<p class="level3"><strong><em>24.1-3</em></strong></p>
<p class="noindent">Suppose that a flow network <em>G</em> = (<em>V</em>, <em>E</em>) violates the assumption that the network contains a path <em>s</em> <span class="font1">⇝</span> <em>v</em> <span class="font1">⇝</span> <em>t</em> for all vertices <em>v</em> ∈ <em>V</em>. Let <em>u</em> be a vertex for which there is no path <em>s</em> <span class="font1">⇝</span> <em>u</em> <span class="font1">⇝</span> <em>t</em>. Show that there must exist a maximum flow <em>f</em> in <em>G</em> such that <em>f</em> (<em>u</em>, <em>v</em>) = <em>f</em> (<em>v</em>, <em>u</em>) = 0 for all vertices <em>v</em> ∈ <em>V</em>.</p>
<p class="level3"><strong><em>24.1-4</em></strong></p>
<p class="noindent">Let <em>f</em> be a flow in a network, and let <em>α</em> be a real number. The <strong><em><span class="blue">scalar flow product</span></em></strong>, denoted <em>αf</em>, is a function from <em>V</em> × <em>V</em> to <span class="font1">ℝ</span> defined by</p>
<p class="eql">(<em>αf</em>)(<em>u</em>, <em>v</em>) = <em>α</em> · <em>f</em> (<em>u</em>, <em>v</em>).</p>
<p class="noindent">Prove that the flows in a network form a <strong><em><span class="blue">convex set</span></em></strong>. That is, show that if <em>f</em><sub>1</sub> and <em>f</em><sub>2</sub> are flows, then so is <em>αf</em><sub>1</sub> + (1 − <em>α</em>) <em>f</em><sub>2</sub> for all <em>α</em> in the range 0 ≤ <em>α</em> ≤ 1.</p>
<p class="level3"><strong><em>24.1-5</em></strong></p>
<p class="noindent">State the maximum-flow problem as a linear-programming problem.</p>
<p class="level3"><strong><em>24.1-6</em></strong></p>
<p class="noindent">Professor Adam has two children who, unfortunately, dislike each other. The problem is so severe that not only do they refuse to walk to school together, but in fact each one refuses to walk on any block that the other child has stepped on that day. The children have no problem with their paths crossing at a corner. Fortunately both the professor’s house and the school are on corners, but beyond that he is not sure if it is going to be possible to send both of his children to the same school. The professor has a map of his town. Show how to formulate the problem of determining whether both his children can go to the same school as a maximum-flow problem.</p>
<a id="p676"/>
<p class="level3"><strong><em>24.1-7</em></strong></p>
<p class="noindent">Suppose that, in addition to edge capacities, a flow network has <strong><em><span class="blue">vertex capacities</span></em></strong>. That is each vertex <em>v</em> has a limit <em>l</em>(<em>v</em>) on how much flow can pass through <em>v</em>. Show how to transform a flow network <em>G</em> = (<em>V</em>, <em>E</em>) with vertex capacities into an equivalent flow network <em>G</em>′ = (<em>V</em>′, <em>E</em>′) without vertex capacities, such that a maximum flow in <em>G</em>′ has the same value as a maximum flow in <em>G</em>. How many vertices and edges does <em>G</em>′ have?</p>
</section>
<p class="line1"/>
<section title="24.2 The Ford-Fulkerson method">
<a id="Sec_24.2"/>
<p class="level1" id="h1-142"><a href="toc.xhtml#Rh1-142"><strong>24.2    The Ford-Fulkerson method</strong></a></p>
<p class="noindent">This section presents the Ford-Fulkerson method for solving the maximum-flow problem. We call it a “method” rather than an “algorithm” because it encompasses several implementations with differing running times. The Ford-Fulkerson method depends on three important ideas that transcend the method and are relevant to many flow algorithms and problems: residual networks, augmenting paths, and cuts. These ideas are essential to the important max-flow min-cut theorem (Theorem 24.6), which characterizes the value of a maximum flow in terms of cuts of the flow network. We end this section by presenting one specific implementation of the Ford-Fulkerson method and analyzing its running time.</p>
<p>The Ford-Fulkerson method iteratively increases the value of the flow. It starts with <em>f</em> (<em>u</em>, <em>v</em>) = 0 for all <em>u</em>, <em>v</em> ∈ <em>V</em>, giving an initial flow of value 0. Each iteration increases the flow value in <em>G</em> by finding an “augmenting path” in an associated “residual network” <em>G</em><sub><em>f</em></sub>. The edges of the augmenting path in <em>G</em><sub><em>f</em></sub> indicate on which edges in <em>G</em> to update the flow in order to increase the flow value. Although each iteration of the Ford-Fulkerson method increases the value of the flow, we’ll see that the flow on any particular edge of <em>G</em> may increase or decrease. Although it might seem counterintuitive to decrease the flow on an edge, doing so may enable flow to increase on other edges, allowing more flow to travel from the source to the sink. The Ford-Fulkerson method, given in the procedure F<small>ORD</small>-F<small>ULKERSON</small>-M<small>ETHOD</small>, repeatedly augments the flow until the residual network has no more augmenting paths. The max-flow min-cut theorem shows that upon termination, this process yields a maximum flow.</p>
<div class="pull-quote1">
<p class="box-heading">F<small>ORD</small>-F<small>ULKERSON</small>-M<small>ETHOD</small> (<em>G</em>, <em>s</em>, <em>t</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent">initialize flow <em>f</em> to 0</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> there exists an augmenting path <em>p</em> in the residual network <em>G</em><sub><em>f</em></sub></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2">augment flow <em>f</em> along <em>p</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>f</em></p></td>
</tr>
</table>
</div>
<a id="p677"/>
<p>In order to implement and analyze the Ford-Fulkerson method, we need to introduce several additional concepts.</p>
<p class="level4"><strong>Residual networks</strong></p>
<p class="noindent">Intuitively, given a flow network <em>G</em> and a flow <em>f</em>, the residual network <em>G</em><sub><em>f</em></sub> consists of edges whose capacities represent how the flow can change on edges of <em>G</em>. An edge of the flow network can admit an amount of additional flow equal to the edge’s capacity minus the flow on that edge. If that value is positive, that edge goes into <em>G</em><sub><em>f</em></sub> with a “residual capacity” of <em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) = <em>c</em>(<em>u</em>, <em>v</em>) − <em>f</em> (<em>u</em>, <em>v</em>). The only edges of <em>G</em> that belong to <em>G</em><sub><em>f</em></sub> are those that can admit more flow. Those edges (<em>u</em>, <em>v</em>) whose flow equals their capacity have <em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) = 0, and they do not belong to <em>G</em><sub><em>f</em></sub>.</p>
<p>You might be surprised that the residual network <em>G</em><sub><em>f</em></sub> can also contain edges that are not in <em>G</em>. As an algorithm manipulates the flow, with the goal of increasing the total flow, it might need to decrease the flow on a particular edge in order to increase the flow elsewhere. In order to represent a possible decrease in the positive flow <em>f</em> (<em>u</em>, <em>v</em>) on an edge in <em>G</em>, the residual network <em>G</em><sub><em>f</em></sub> contains an edge (<em>v</em>, <em>u</em>) with residual capacity <em>c</em><sub><em>f</em></sub> (<em>v</em>, <em>u</em>) = <em>f</em> (<em>u</em>, <em>v</em>)—that is, an edge that can admit flow in the opposite direction to (<em>u</em>, <em>v</em>), at most canceling out the flow on (<em>u</em>, <em>v</em>). These reverse edges in the residual network allow an algorithm to send back flow it has already sent along an edge. Sending flow back along an edge is equivalent to <em>decreasing</em> the flow on the edge, which is a necessary operation in many algorithms.</p>
<p>More formally, for a flow network <em>G</em> = (<em>V</em>, <em>E</em>) with source <em>s</em>, sink <em>t</em>, and a flow <em>f</em>, consider a pair of vertices <em>u</em>, <em>v</em> ∈ <em>V</em>. We define the <strong><em><span class="blue">residual capacity</span></em></strong> <em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) by</p>
<p class="eqr"><img alt="art" src="images/Art_P758.jpg"/></p>
<p class="noindent">In a flow network, (<em>u</em>, <em>v</em>) ∈ <em>E</em> implies (<em>v</em>, <em>u</em>) ∉ <em>E</em>, and so exactly one case in equation (24.2) applies to each ordered pair of vertices.</p>
<p>As an example of equation (24.2), if <em>c</em>(<em>u</em>, <em>v</em>) = 16 and <em>f</em> (<em>u</em>, <em>v</em>) = 11, then <em>f</em> (<em>u</em>, <em>v</em>) can increase by up to <em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) = 5 units before exceeding the capacity constraint on edge (<em>u</em>, <em>v</em>). Alternatively, up to 11 units of flow can return from <em>v</em> to <em>u</em>, so that <em>c</em><sub><em>f</em></sub> (<em>v</em>, <em>u</em>) = 11.</p>
<p>Given a flow network <em>G</em> = (<em>V</em>, <em>E</em>) and a flow <em>f</em>, the <strong><em><span class="blue">residual network</span></em></strong> of <em>G</em> induced by <em>f</em> is <em>G</em><sub><em>f</em></sub> = (<em>V</em>, <em>E</em><sub><em>f</em></sub>), where</p>
<p class="eqr"><img alt="art" src="images/Art_P759.jpg"/></p>
<a id="p678"/>
<div class="divimage">
<p class="fig-imga" id="Fig_24-4"><img alt="art" src="images/Art_P760.jpg"/></p>
<p class="caption"><strong>Figure 24.4 (a)</strong> The flow network <em>G</em> and flow <em>f</em> of <a href="chapter024.xhtml#Fig_24-1">Figure 24.1(b)</a>. <strong>(b)</strong> The residual network <em>G</em><sub><em>f</em></sub> with augmenting path <em>p</em>, having residual capacity <em>c</em><sub><em>f</em></sub> (<em>p</em>) = <em>c</em><sub><em>f</em></sub> (<em>v</em><sub>2</sub>, <em>v</em><sub>3</sub>) = 4, in blue. Edges with residual capacity equal to 0, such as (<em>v</em><sub>1</sub>, <em>v</em><sub>3</sub>), are not shown, a convention we follow in the remainder of this section. <strong>(c)</strong> The flow in <em>G</em> that results from augmenting along path <em>p</em> by its residual capacity 4. Edges carrying no flow, such as (<em>v</em><sub>3</sub>, <em>v</em><sub>2</sub>), are labeled only by their capacity, another convention we follow throughout. <strong>(d)</strong> The residual network induced by the flow in (c).</p>
</div>
<p class="noindent">That is, as promised above, each edge of the residual network, or <strong><em><span class="blue">residual edge</span></em></strong>, can admit a flow that is greater than 0. <a href="chapter024.xhtml#Fig_24-4">Figure 24.4(a)</a> repeats the flow network <em>G</em> and flow <em>f</em> of <a href="chapter024.xhtml#Fig_24-1">Figure 24.1(b)</a>, and <a href="chapter024.xhtml#Fig_24-4">Figure 24.4(b)</a> shows the corresponding residual network <em>G</em><sub><em>f</em></sub>. The edges in <em>E</em><sub><em>f</em></sub> are either edges in <em>E</em> or their reversals, and thus</p>
<p class="eql">|<em>E</em><sub><em>f</em></sub>| ≤ 2 |<em>E</em>|.</p>
<p>Observe that the residual network <em>G</em><sub><em>f</em></sub> is similar to a flow network with capacities given by <em>c</em><sub><em>f</em></sub>. It does not satisfy the definition of a flow network, however, because it could contain antiparallel edges. Other than this difference, a residual network has the same properties as a flow network, and we can define a flow in the residual network as one that satisfies the definition of a flow, but with respect to capacities <em>c</em><sub><em>f</em></sub> in the residual network <em>G</em><sub><em>f</em></sub>.</p>
<p>A flow in a residual network provides a roadmap for adding flow to the original flow network. If <em>f</em> is a flow in <em>G</em> and <em>f</em>′ is a flow in the corresponding residual network <em>G</em><sub><em>f</em></sub>, we define <em>f</em> ↑ <em>f</em>′, the <strong><em><span class="blue">augmentation</span></em></strong> of flow <em>f</em> by <em>f</em> ′, to be a function from <em>V</em> × <em>V</em> to <span class="font1">ℝ</span>, defined by</p>
<a id="p679"/>
<p class="eqr"><img alt="art" src="images/Art_P761.jpg"/></p>
<p>The intuition behind this definition follows the definition of the residual network. The flow on (<em>u</em>, <em>v</em>) increases by <em>f</em> ′(<em>u</em>, <em>v</em>), but decreases by <em>f</em> ′(<em>v</em>, <em>u</em>) because pushing flow on the reverse edge in the residual network signifies decreasing the flow in the original network. Pushing flow on the reverse edge in the residual network is also known as <strong><em><span class="blue">cancellation</span></em></strong>. For example, suppose that 5 crates of hockey pucks go from <em>u</em> to <em>v</em> and 2 crates go from <em>v</em> to <em>u</em>. That is equivalent (from the perspective of the final result) to sending 3 crates from <em>u</em> to <em>v</em> and none from <em>v</em> to <em>u</em>. Cancellation of this type is crucial for any maximum-flow algorithm.</p>
<p>The following lemma shows that augmenting a flow in <em>G</em> by a flow in <em>G</em><sub><em>f</em></sub> yields a new flow in <em>G</em> with a greater flow value.</p>
<p class="lem"><strong><em>Lemma 24.1</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a flow network with source <em>s</em> and sink <em>t</em>, and let <em>f</em> be a flow in <em>G</em>. Let <em>G</em><sub><em>f</em></sub> be the residual network of <em>G</em> induced by <em>f</em>, and let <em>f</em> ′ be a flow in <em>G</em><sub><em>f</em></sub>. Then the function <em>f</em> ↑ <em>f</em> ′ defined in equation (24.4) is a flow in <em>G</em> with value |<em>f</em> ↑ <em>f</em> ′| = |<em>f</em> | + |<em>f</em> ′|.</p>
<p class="prof"><strong><em>Proof</em></strong>   We first verify that <em>f</em> ↑ <em>f</em> ′ obeys the capacity constraint for each edge in <em>E</em> and flow conservation at each vertex in <em>V</em> − {<em>s</em>, <em>t</em>}.</p>
<p>For the capacity constraint, first observe that if (<em>u</em>, <em>v</em>) ∈ <em>E</em>, then <em>c</em><sub><em>f</em></sub> (<em>v</em>, <em>u</em>) = <em>f</em> (<em>u</em>, <em>v</em>). Because <em>f</em> ′ is a flow in <em>G</em><sub><em>f</em></sub>, we have <em>f</em> ′(<em>v</em>, <em>u</em>) ≤ <em>c</em><sub><em>f</em></sub> (<em>v</em>, <em>u</em>), which gives <em>f</em> ′(<em>v</em>, <em>u</em>) ≤ <em>f</em> (<em>u</em>, <em>v</em>). Therefore,</p>
<table class="table2b">
<tr>
<td class="td2">(<em>f</em> ↑ <em>f</em>′)(<em>u</em>, <em>v</em>)</td>
<td class="td2">=</td>
<td class="td2"><em>f</em> (<em>u</em>, <em>v</em>) + <em>f</em> ′(<em>u</em>, <em>v</em>) − <em>f</em> ′(<em>v</em>, <em>u</em>)</td>
<td class="td2">(by equation (24.4))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2"><em>f</em> (<em>u</em>, <em>v</em>) + <em>f</em> ′(<em>u</em>, <em>v</em>) − <em>f</em> (<em>u</em>, <em>v</em>)</td>
<td class="td2">(because <em>f</em> ′(<em>v</em>, <em>u</em>) ≤ <em>f</em> (<em>u</em>, <em>v</em>))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>f</em> ′(<em>u</em>, <em>v</em>)</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2">0.</td>
<td class="td2"/>
</tr>
</table>
<p class="noindent">In addition,</p>
<table class="table2b">
<tr>
<td class="td2" colspan="4">(<em>f</em> ↑ <em>f</em>′)(<em>u</em>, <em>v</em>)</td>
</tr>
<tr>
<td class="td2-d"/>
<td class="td2">=</td>
<td class="td2"><em>f</em> (<em>u</em>, <em>v</em>) + <em>f</em> ′(<em>u</em>, <em>v</em>) − <em>f</em> ′(<em>v</em>, <em>u</em>)</td>
<td class="td2">(by equation (24.4))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2"><em>f</em> (<em>u</em>, <em>v</em>) + <em>f</em> ′(<em>u</em>, <em>v</em>)</td>
<td class="td2">(because flows are nonnegative)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2"><em>f</em> (<em>u</em>, <em>v</em>) + <em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>)</td>
<td class="td2">(capacity constraint)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>f</em> (<em>u</em>, <em>v</em>) + <em>c</em>(<em>u</em>, <em>v</em>) − <em>f</em> (<em>u</em>, <em>v</em>)</td>
<td class="td2">(definition of <em>c</em><sub><em>f</em></sub>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>c</em>(<em>u</em>, <em>v</em>).</td>
<td class="td2"/>
</tr>
</table>
<p>To show that flow conservation holds and that |<em>f</em> ↑ <em>f</em> ′| = |<em>f</em> | + |<em>f</em> ′|, we first prove the claim that for all <em>u</em> ∈ <em>V</em>, we have</p>
<a id="p680"/>
<p class="eqr"><img alt="art" src="images/Art_P762.jpg"/></p>
<p class="noindent">Because we disallow antiparallel edges in <em>G</em> (but not in <em>G</em><sub><em>f</em></sub>), we know that for each vertex <em>u</em>, there can be an edge (<em>u</em>, <em>v</em>) or (<em>v</em>, <em>u</em>) in <em>G</em>, but never both. For a fixed vertex <em>u</em>, define <em>V</em><sub><em>l</em></sub>(<em>u</em>) = {<em>v</em> : (<em>u</em>, <em>v</em>) ∈ <em>E</em>} to be the set of vertices with edges in <em>G</em> leaving <em>u</em>, and define <em>V</em><sub><em>e</em></sub>(<em>u</em>) = {<em>v</em> : (<em>v</em>, <em>u</em>) ∈ <em>E</em>} to be the set of vertices with edges in <em>G</em> entering <em>u</em>. We have <em>V</em><sub><em>l</em></sub>(<em>u</em>) ∪ <em>V</em><sub><em>e</em></sub>(<em>u</em>) ⊆ <em>V</em> and, because <em>G</em> contains no antiparallel edges, <em>V</em><sub><em>l</em></sub>(<em>u</em>) ∩ <em>V</em><sub><em>e</em></sub>(<em>u</em>) = ∅. By the definition of flow augmentation in equation (24.4), only vertices <em>v</em> in <em>V</em><sub><em>l</em></sub>(<em>u</em>) can have positive (<em>f</em> ↑ <em>f</em>′)(<em>u</em>, <em>v</em>), and only vertices <em>v</em> in <em>V</em><sub><em>e</em></sub>(<em>u</em>) can have positive (<em>f</em> ↑ <em>f</em> ′)(<em>v</em>, <em>u</em>). Starting from the left-hand side of equation (24.5), we use this fact and then reorder and group terms, giving</p>
<p class="eqr"><img alt="art" src="images/Art_P763.jpg"/></p>
<p class="noindent">In equation (24.6), all four summations can extend to sum over <em>V</em>, since each additional term has value 0. (Exercise 24.2-1 asks you to prove this formally.) Taking all four summations over <em>V</em>, instead of just subsets of <em>V</em>, proves the claim in equation (24.5).</p>
<p>Now we are ready to prove flow conservation for <em>f</em> ↑ <em>f</em> ′ and that |<em>f</em> ↑ <em>f</em>′| = | <em>f</em> | + |<em>f</em> ′|. For the latter property, let <em>u</em> = <em>s</em> in equation (24.5). Then, we have</p>
<a id="p681"/>
<p class="eql"><img alt="art" src="images/Art_P764.jpg"/></p>
<p class="noindent">For flow conservation, observe that for any vertex <em>u</em> that is neither <em>s</em> nor <em>t</em>, flow conservation for <em>f</em> and <em>f</em> ′ means that the right-hand side of equation (24.5) is 0, and thus Σ<sub><em>v</em>∈<em>V</em></sub> (<em>f</em> ↑ <em>f</em>′)(<em>u</em>, <em>v</em>) = Σ<sub><em>v</em>∈<em>V</em></sub> (<em>f</em> ↑ <em>f</em>′)(<em>v</em>, <em>u</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Augmenting paths</strong></p>
<p class="noindent">Given a flow network <em>G</em> = (<em>V</em>, <em>E</em>) and a flow <em>f</em>, an <strong><em><span class="blue">augmenting path</span></em></strong> <em>p</em> is a simple path from <em>s</em> to <em>t</em> in the residual network <em>G</em><sub><em>f</em></sub>. By the definition of the residual network, the flow on an edge (<em>u</em>, <em>v</em>) of an augmenting path may increase by up to <em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) without violating the capacity constraint on whichever of (<em>u</em>, <em>v</em>) and (<em>v</em>, <em>u</em>) belongs to the original flow network <em>G</em>.</p>
<p>The blue path in <a href="chapter024.xhtml#Fig_24-4">Figure 24.4(b)</a> is an augmenting path. Treating the residual network <em>G</em><sub><em>f</em></sub> in the figure as a flow network, the flow through each edge of this path can increase by up to 4 units without violating a capacity constraint, since the smallest residual capacity on this path is <em>c</em><sub><em>f</em></sub> (<em>v</em><sub>2</sub>, <em>v</em><sub>3</sub>) = 4. We call the maximum amount by which we can increase the flow on each edge in an augmenting path <em>p</em> the <strong><em><span class="blue">residual capacity</span></em></strong> of <em>p</em>, given by</p>
<p class="eql"><em>c</em><sub><em>f</em></sub> (<em>p</em>) = min {<em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) : (<em>u</em>, <em>v</em>) is in <em>p</em>}.</p>
<p class="noindent">The following lemma, which Exercise 24.2-7 asks you to prove, makes the above argument more precise.</p>
<p class="lem"><strong><em>Lemma 24.2</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a flow network, let <em>f</em> be a flow in <em>G</em>, and let <em>p</em> be an augmenting path in <em>G</em><sub><em>f</em></sub>. Define a function <em>f</em><sub><em>p</em></sub> : <em>V</em> × <em>V</em> → <span class="font1">ℝ</span> by</p>
<p class="eqr"><img alt="art" src="images/Art_P765.jpg"/></p>
<p class="noindent">Then, <em>f</em><sub><em>p</em></sub> is a flow in <em>G</em><sub><em>f</em></sub> with value |<em>f</em><sub><em>p</em></sub>| = <em>c</em><sub><em>f</em></sub> (<em>p</em>) &gt; 0.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The following corollary shows that augmenting <em>f</em> by <em>f</em><sub><em>p</em></sub> produces another flow in <em>G</em> whose value is closer to the maximum. <a href="chapter024.xhtml#Fig_24-4">Figure 24.4(c)</a> shows the result of augmenting the flow <em>f</em> from <a href="chapter024.xhtml#Fig_24-4">Figure 24.4(a)</a> by the flow <em>f</em><sub><em>p</em></sub> in <a href="chapter024.xhtml#Fig_24-4">Figure 24.4(b)</a>, and <a href="chapter024.xhtml#Fig_24-4">Figure 24.4(d)</a> shows the ensuing residual network.</p>
<a id="p682"/>
<p class="cor"><strong><em>Corollary 24.3</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a flow network, let <em>f</em> be a flow in <em>G</em>, and let <em>p</em> be an augmenting path in <em>G</em><sub><em>f</em></sub>. Let <em>f</em><sub><em>p</em></sub> be defined as in equation (24.7), and suppose that <em>f</em> is augmented by <em>f</em><sub><em>p</em></sub>. Then the function <em>f</em> ↑ <em>f</em><sub><em>p</em></sub> is a flow in <em>G</em> with value |<em>f</em> ↑ <em>f</em><sub><em>p</em></sub>| = |<em>f</em>| + |<em>f</em><sub><em>p</em></sub>| &gt; |<em>f</em>|.</p>
<p class="prof"><strong><em>Proof</em></strong>   Immediate from Lemmas 24.1 and 24.2.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Cuts of flow networks</strong></p>
<p class="noindent">The Ford-Fulkerson method repeatedly augments the flow along augmenting paths until it has found a maximum flow. How do we know that when the algorithm terminates, it has actually found a maximum flow? The max-flow min-cut theorem, which we will prove shortly, tells us that a flow is maximum if and only if its residual network contains no augmenting path. To prove this theorem, though, we must first explore the notion of a cut of a flow network.</p>
<p>A <strong><em><span class="blue">cut</span></em></strong> (<em>S</em>, <em>T</em>) of flow network <em>G</em> = (<em>V</em>, <em>E</em>) is a partition of <em>V</em> into <em>S</em> and <em>T</em> = <em>V</em> − <em>S</em> such that <em>s</em> ∈ <em>S</em> and <em>t</em> ∈ <em>T</em>. (This definition is similar to the definition of “cut” that we used for minimum spanning trees in <a href="chapter021.xhtml">Chapter 21</a>, except that here we are cutting a directed graph rather than an undirected graph, and we insist that <em>s</em> ∈ <em>S</em> and <em>t</em> ∈ <em>T</em>.) If <em>f</em> is a flow, then the <strong><em><span class="blue">net flow</span></em></strong> <em>f</em>(<em>S</em>, <em>T</em>) across the cut (<em>S</em>, <em>T</em>) is defined to be</p>
<p class="eqr"><img alt="art" src="images/Art_P766.jpg"/></p>
<p class="noindent">The <strong><em><span class="blue">capacity</span></em></strong> of the cut (<em>S</em>, <em>T</em>) is</p>
<p class="eqr"><img alt="art" src="images/Art_P767.jpg"/></p>
<p class="noindent">A <strong><em><span class="blue">minimum cut</span></em></strong> of a network is a cut whose capacity is minimum over all cuts of the network.</p>
<p>You probably noticed that the definitions of flow across a cut and capacity of a cut differ in that flow counts edges going in both directions across the cut, but capacity counts only edges going from the source side of the cut toward the sink side. This asymmetry is intentional and important. The reason for this difference will become apparent later in this section.</p>
<p><a href="chapter024.xhtml#Fig_24-5">Figure 24.5</a> shows the cut ({<em>s</em>, <em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>}, {<em>v</em><sub>3</sub>, <em>v</em><sub>4</sub>, <em>t</em>}) in the flow network of <a href="chapter024.xhtml#Fig_24-1">Figure 24.1(b)</a>. The net flow across this cut is</p>
<table class="table2b">
<tr>
<td class="td2"><em>f</em> (<em>v</em><sub>1</sub>, <em>v</em><sub>3</sub>) + <em>f</em> (<em>v</em><sub>2</sub>, <em>v</em><sub>4</sub>) − <em>f</em> (<em>v</em><sub>3</sub>, <em>v</em><sub>2</sub>)</td>
<td class="td2">=</td>
<td class="td2">12 + 11 − 4</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">19,</td>
</tr>
</table>
<p class="noindent">and the capacity of this cut is</p>
<a id="p683"/>
<div class="divimage">
<p class="fig-imga" id="Fig_24-5"><img alt="art" src="images/Art_P768.jpg"/></p>
<p class="caption"><strong>Figure 24.5</strong> A cut (<em>S</em>, <em>T</em>) in the flow network of <a href="chapter024.xhtml#Fig_24-1">Figure 24.1(b)</a>, where <em>S</em> = {<em>s</em>, <em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>} and <em>T</em> = {<em>v</em><sub>3</sub>, <em>v</em><sub>4</sub>, <em>t</em>}. The vertices in <em>S</em> are orange, and the vertices in <em>T</em> are tan. The net flow across (<em>S</em>, <em>T</em>) is <em>f</em> (<em>S</em>, <em>T</em>) = 19, and the capacity is <em>c</em>(<em>S</em>, <em>T</em>) = 26.</p>
</div>
<table class="table2b">
<tr>
<td class="td2"><em>c</em>(<em>v</em><sub>1</sub>, <em>v</em><sub>3</sub>) + <em>c</em>(<em>v</em><sub>2</sub>, <em>v</em><sub>4</sub>)</td>
<td class="td2">=</td>
<td class="td2">12 + 14</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">26.</td>
</tr>
</table>
<p>The following lemma shows that, for a given flow <em>f</em>, the net flow across any cut is the same, and it equals |<em>f</em>|, the value of the flow.</p>
<p class="lem"><strong><em>Lemma 24.4</em></strong></p>
<p class="noindent">Let <em>f</em> be a flow in a flow network <em>G</em> with source <em>s</em> and sink <em>t</em>, and let (<em>S</em>, <em>T</em>) be any cut of <em>G</em>. Then the net flow across (<em>S</em>, <em>T</em>) is <em>f</em> (<em>S</em>, <em>T</em>) =| <em>f</em>|.</p>
<p class="prof"><strong><em>Proof</em></strong>   For any vertex <em>u</em> ∈ <em>V</em> − {<em>s</em>, <em>t</em>}, rewrite the flow-conservation condition as</p>
<p class="eqr"><img alt="art" src="images/Art_P769.jpg"/></p>
<p class="noindent">Taking the definition of| <em>f</em>| from equation (24.1) and adding the left-hand side of equation (24.10), which equals 0, summed over all vertices in <em>S</em> − {<em>s</em>}, gives</p>
<p class="eql"><img alt="art" src="images/Art_P770.jpg"/></p>
<p class="noindent">Expanding the right-hand summation and regrouping terms yields</p>
<p class="eql"><img alt="art" src="images/Art_P771.jpg"/></p>
<a id="p684"/>
<p class="noindent">Because <em>V</em> = <em>S</em> ∪ <em>T</em> and <em>S</em> ∩ <em>T</em> = ∅, splitting each summation over <em>V</em> into summations over <em>S</em> and <em>T</em> gives</p>
<p class="eql"><img alt="art" src="images/Art_P772.jpg"/></p>
<p class="noindent">The two summations within the parentheses are actually the same, since for all vertices <em>x</em>, <em>y</em> ∈ <em>S</em>, the term <em>f</em> (<em>x</em>, <em>y</em>) appears once in each summation. Hence, these summations cancel, yielding</p>
<p class="eql"><img alt="art" src="images/Art_P773.jpg"/></p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">A corollary to Lemma 24.4 shows how cut capacities bound the value of a flow.</p>
<p class="cor"><strong><em>Corollary 24.5</em></strong></p>
<p class="noindent">The value of any flow <em>f</em> in a flow network <em>G</em> is bounded from above by the capacity of any cut of <em>G</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   Let (<em>S</em>, <em>T</em>) be any cut of <em>G</em> and let <em>f</em> be any flow. By Lemma 24.4 and the capacity constraint,</p>
<p class="eql"><img alt="art" src="images/Art_P774.jpg"/></p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Corollary 24.5 yields the immediate consequence that the value of a maximum flow in a network is bounded from above by the capacity of a minimum cut of the network. The important max-flow min-cut theorem, which we now state and prove, says that the value of a maximum flow is in fact equal to the capacity of a minimum cut.</p>
<a id="p685"/>
<p class="theo"><strong><em>Theorem 24.6 (Max-flow min-cut theorem)</em></strong></p>
<p class="noindent">If <em>f</em> is a flow in a flow network <em>G</em> = (<em>V</em>, <em>E</em>) with source <em>s</em> and sink <em>t</em>, then the following conditions are equivalent:</p>
<ol class="olnoindent" epub:type="list">
<li><em>f</em> is a maximum flow in <em>G</em>.</li>
<li class="litop">The residual network <em>G</em><sub><em>f</em></sub> contains no augmenting paths.</li>
<li class="litop">|<em>f</em>| = <em>c</em>(<em>S</em>, <em>T</em>) for some cut (<em>S</em>, <em>T</em>) of <em>G</em>.</li></ol>
<p class="prof"><strong><em>Proof</em></strong>   (1) ⇒ (2): Suppose for the sake of contradiction that <em>f</em> is a maximum flow in <em>G</em> but that <em>G</em><sub><em>f</em></sub> has an augmenting path <em>p</em>. Then, by Corollary 24.3, the flow found by augmenting <em>f</em> by <em>f</em><sub><em>p</em></sub>, where <em>f</em><sub><em>p</em></sub> is given by equation (24.7), is a flow in <em>G</em> with value strictly greater than |<em>f</em>|, contradicting the assumption that <em>f</em> is a maximum flow.</p>
<p>(2) ⇒ (3): Suppose that <em>G</em><sub><em>f</em></sub> has no augmenting path, that is, that <em>G</em><sub><em>f</em></sub> contains no path from <em>s</em> to <em>t</em>. Define</p>
<p class="eql"><em>S</em> = {<em>v</em> ∈ <em>V</em> : there exists a path from <em>s</em> to <em>v</em> in <em>G</em><sub><em>f</em></sub> }</p>
<p class="noindent">and <em>T</em> = <em>V</em> − <em>S</em>. The partition (<em>S</em>, <em>T</em>) is a cut: we have <em>s</em> ∈ <em>S</em> trivially and <em>t</em> ∉ <em>S</em> because there is no path from <em>s</em> to <em>t</em> in <em>G</em><sub><em>f</em></sub>. Now consider a pair of vertices <em>u</em> ∈ <em>S</em> and <em>v</em> ∈ <em>T</em>. If (<em>u</em>, <em>v</em>) ∈ <em>E</em>, we must have <em>f</em> (<em>u</em>, <em>v</em>) = <em>c</em>(<em>u</em>, <em>v</em>), since otherwise (<em>u</em>, <em>v</em>) ∈ <em>E</em><sub><em>f</em></sub>, which would place <em>v</em> in set <em>S</em>. If (<em>v</em>, <em>u</em>) ∈ <em>E</em>, we must have <em>f</em> (<em>v</em>, <em>u</em>) = 0, because otherwise <em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) = <em>f</em> (<em>v</em>, <em>u</em>) would be positive and we would have (<em>u</em>, <em>v</em>) ∈ <em>E</em><sub><em>f</em></sub>, which again would place <em>v</em> in <em>S</em>. Of course, if neither (<em>u</em>, <em>v</em>) nor (<em>v</em>, <em>u</em>) belongs to <em>E</em>, then <em>f</em> (<em>u</em>, <em>v</em>) = <em>f</em> (<em>v</em>, <em>u</em>) = 0. We thus have</p>
<p class="eql"><img alt="art" src="images/Art_P775.jpg"/></p>
<p class="noindent">By Lemma 24.4, therefore, |<em>f</em>| = <em>f</em> (<em>S</em>, <em>T</em>) = <em>c</em>(<em>S</em>, <em>T</em>).</p>
<p>(3) ⇒ (1): By Corollary 24.5, |<em>f</em>| ≤ <em>c</em>(<em>S</em>, <em>T</em>) for all cuts (<em>S</em>, <em>T</em>). The condition |<em>f</em>| = <em>c</em>(<em>S</em>, <em>T</em>) thus implies that <em>f</em> is a maximum flow.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>The basic Ford-Fulkerson algorithm</strong></p>
<p class="noindent">Each iteration of the Ford-Fulkerson method finds <em>some</em> augmenting path <em>p</em> and uses <em>p</em> to modify the flow <em>f</em>. As Lemma 24.2 and Corollary 24.3 suggest, replacing <em>f</em> by <em>f</em> ↑ <em>f</em><sub><em>p</em></sub> produces a new flow whose value is |<em>f</em>| + |<em>f</em><sub><em>p</em></sub>|. The procedure F<small>ORD</small>-F<small>ULKERSON</small> on the next page implements the method by updating the flow <a id="p686"/>attribute (<em>u</em>, <em>v</em>).<em>f</em> for each edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>.<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup> It assumes implicitly that (<em>u</em>, <em>v</em>).<em>f</em> = 0 if (<em>u</em>, <em>v</em>) ∉ <em>E</em>. The procedure also assumes that the capacities <em>c</em>(<em>u</em>, <em>v</em>) come with the flow network, and that <em>c</em>(<em>u</em>, <em>v</em>) = 0 if (<em>u</em>, <em>v</em>) ∉ <em>E</em>. The procedure computes the residual capacity <em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) in accordance with the formula (24.2). The expression <em>c</em><sub><em>f</em></sub> (<em>p</em>) in the code is just a temporary variable that stores the residual capacity of the path <em>p</em>.</p>
<div class="pull-quote1">
<p class="box-heading">F<small>ORD</small>-F<small>ULKERSON</small> (<em>G</em>, <em>s</em>, <em>t</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each edge (<em>u</em>, <em>v</em>) ∈ <em>G</em>.<em>E</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2">(<em>u</em>, <em>v</em>).<em>f</em> = 0</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> there exists a path <em>p</em> from <em>s</em> to <em>t</em> in the residual network <em>G</em><sub><em>f</em></sub></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><em>c</em><sub><em>f</em></sub> (<em>p</em>) = min {<em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) : (<em>u</em>, <em>v</em>) is in <em>p</em>}</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p2"><strong>for</strong> each edge (<em>u</em>, <em>v</em>) in <em>p</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="p3"><strong>if</strong> (<em>u</em>, <em>v</em>) ∈ <em>G</em>.<em>E</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1"><p class="p4">(<em>u</em>, <em>v</em>).<em>f</em> = (<em>u</em>, <em>v</em>).<em>f</em> + <em>c</em><sub><em>f</em></sub> (<em>p</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">8</span></p></td>
<td class="td1"><p class="p3"><strong>else</strong> (<em>v</em>, <em>u</em>).<em>f</em> = (<em>v</em>, <em>u</em>).<em>f</em> − <em>c</em><sub><em>f</em></sub> (<em>p</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">9</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>f</em></p></td>
</tr>
</table>
</div>
<p>The F<small>ORD</small>-F<small>ULKERSON</small> procedure simply expands on the F<small>ORD</small>-F<small>ULKERSON</small>-M<small>ETHOD</small> pseudocode given earlier. <a href="chapter024.xhtml#Fig_24-6">Figure 24.6</a> shows the result of each iteration in a sample run. Lines 1–2 initialize the flow <em>f</em> to 0. The <strong>while</strong> loop of lines 3–8 repeatedly finds an augmenting path <em>p</em> in <em>G</em><sub><em>f</em></sub> and augments flow <em>f</em> along <em>p</em> by the residual capacity <em>c</em><sub><em>f</em></sub> (<em>p</em>). Each residual edge in path <em>p</em> is either an edge in the original network or the reversal of an edge in the original network. Lines 6–8 update the flow in each case appropriately, adding flow when the residual edge is an original edge and subtracting it otherwise. When no augmenting paths exist, the flow <em>f</em> is a maximum flow.</p>
<p class="level4"><strong>Analysis of Ford-Fulkerson</strong></p>
<p class="noindent">The running time of F<small>ORD</small>-F<small>ULKERSON</small> depends on the augmenting path <em>p</em> and how it’s found in line 3. If the edge capacities are irrational numbers, it’s possible to choose the augmenting path so that the algorithm never terminates: the value of the flow increases with successive augmentations, but never converges to the maximum flow value. The good news is that if the algorithm finds the augmenting path by using a breadth-first search (which we saw in <a href="chapter020.xhtml#Sec_20.2">Section 20.2</a>), it runs in <a id="p687"/>polynomial time. Before proving this result, we obtain a simple bound for the case in which all capacities are integers and the algorithm finds any augmenting path.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_24-6"><img alt="art" src="images/Art_P776.jpg"/></p>
<p class="caption"><strong>Figure 24.6</strong> The execution of the basic Ford-Fulkerson algorithm. <strong>(a)–(e)</strong> Successive iterations of the <strong>while</strong> loop. The left side of each part shows the residual network <em>G</em><sub><em>f</em></sub> from line 3 with a blue augmenting path <em>p</em>. The right side of each part shows the new flow <em>f</em> that results from augmenting <em>f</em> by <em>f</em><sub><em>p</em></sub>. The residual network in (a) is the input flow network <em>G</em>. <strong>(f)</strong> The residual network at the last <strong>while</strong> loop test. It has no augmenting paths, and the flow <em>f</em> shown in (e) is therefore a maximum flow. The value of the maximum flow found is 23.</p>
</div>
<p class="block"/>
<a id="p688"/>
<div class="divimage">
<p class="fig-imga" id="Fig_24-7"><img alt="art" src="images/Art_P777.jpg"/></p>
<p class="caption"><strong>Figure 24.7 (a)</strong> A flow network for which F<small>ORD</small>-F<small>ULKERSON</small> can take Θ(<em>E</em> | <em>f</em>*|) time, where <em>f</em>* is a maximum flow, shown here with |<em>f</em>*| = 2,000,000. The blue path is an augmenting path with residual capacity 1. <strong>(b)</strong> The resulting residual network, with another augmenting path whose residual capacity is 1. <strong>(c)</strong> The resulting residual network.</p>
</div>
<p>In practice, the maximum-flow problem often arises with integer capacities. If the capacities are rational numbers, an appropriate scaling transformation can make them all integers. If <em>f</em>* denotes a maximum flow in the transformed network, then a straightforward implementation of F<small>ORD</small>-F<small>ULKERSON</small> executes the <strong>while</strong> loop of lines 3–8 at most |<em>f</em>*| times, since the flow value increases by at least 1 unit in each iteration.</p>
<p>A good implementation should perform the work done within the <strong>while</strong> loop efficiently. It should represent the flow network <em>G</em> = (<em>V</em>, <em>E</em>) with the right data structure and find an augmenting path by a linear-time algorithm. Let’s assume that the implementation keeps a data structure corresponding to a directed graph <em>G</em>′ = (<em>V</em>, <em>E</em>′), where <em>E</em>′ = {(<em>u</em>, <em>v</em>) : (<em>u</em>, <em>v</em>) ∈ <em>E</em> or (<em>v</em>, <em>u</em>) ∈ <em>E</em>}. Edges in the network <em>G</em> are also edges in <em>G</em>′, making it straightforward to maintain capacities and flows in this data structure. Given a flow <em>f</em> on <em>G</em>, the edges in the residual network <em>G</em><sub><em>f</em></sub> consist of all edges (<em>u</em>, <em>v</em>) of <em>G</em>′ such that <em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) &gt; 0, where <em>c</em><sub><em>f</em></sub> conforms to equation (24.2). The time to find a path in a residual network is therefore <em>O</em>(<em>V</em> + <em>E</em>′) = <em>O</em>(<em>E</em>) using either depth-first search or breadth-first search. Each iteration of the <strong>while</strong> loop thus takes <em>O</em>(<em>E</em>) time, as does the initialization in lines 1–2, making the total running time of the F<small>ORD</small>-F<small>ULKERSON</small> algorithm <em>O</em>(<em>E</em> |<em>f</em>*|).</p>
<p>When the capacities are integers and the optimal flow value |<em>f</em>*| is small, the running time of the Ford-Fulkerson algorithm is good. <a href="chapter024.xhtml#Fig_24-7">Figure 24.7(a)</a> shows an example of what can happen on a simple flow network for which |<em>f</em>*| is large. A maximum flow in this network has value 2,000,000: 1,000,000 units of flow traverse the path <em>s</em> → <em>u</em> → <em>t</em>, and another 1,000,000 units traverse the path <em>s</em> → <em>v</em> → <em>t</em>. If the first augmenting path found by F<small>ORD</small>-F<small>ULKERSON</small> is <em>s</em> → <em>u</em> → <em>v</em> → <em>t</em>, shown <a id="p689"/>in <a href="chapter024.xhtml#Fig_24-7">Figure 24.7(a)</a>, the flow has value 1 after the first iteration. The resulting residual network appears in <a href="chapter024.xhtml#Fig_24-7">Figure 24.7(b)</a>. If the second iteration finds the augmenting path <em>s</em> → <em>v</em> → <em>u</em> → <em>t</em>, as shown in <a href="chapter024.xhtml#Fig_24-7">Figure 24.7(b)</a>, the flow then has value 2. <a href="chapter024.xhtml#Fig_24-7">Figure 24.7(c)</a> shows the resulting residual network. If the algorithm continues alternately choosing the augmenting paths <em>s</em> → <em>u</em> → <em>v</em> → <em>t</em> and <em>s</em> → <em>v</em> → <em>u</em> → <em>t</em>, it performs a total of 2,000,000 augmentations, increasing the flow value by only 1 unit in each.</p>
<p class="level4"><strong>The Edmonds-Karp algorithm</strong></p>
<p class="noindent">In the example of <a href="chapter024.xhtml#Fig_24-7">Figure 24.7</a>, the algorithm never chooses the augmenting path with the fewest edges. It should have. By using breadth-first search to find an augmenting path in the residual network, the algorithm runs in polynomial time, independent of the maximum flow value. We call the Ford-Fulkerson method so implemented the <strong><em><span class="blue">Edmonds-Karp algorithm</span></em></strong>.</p>
<p>Let’s now prove that the Edmonds-Karp algorithm runs in <em>O</em>(<em>VE</em><sup>2</sup>) time. The analysis depends on the distances to vertices in the residual network <em>G</em><sub><em>f</em></sub>. The notation <em>δ</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>) denotes the shortest-path distance from <em>u</em> to <em>v</em> in <em>G</em><sub><em>f</em></sub>, where each edge has unit distance.</p>
<p class="lem"><strong><em>Lemma 24.7</em></strong></p>
<p class="noindent">If the Edmonds-Karp algorithm is run on a flow network <em>G</em> = (<em>V</em>, <em>E</em>) with source <em>s</em> and sink <em>t</em>, then for all vertices <em>v</em> ∈ <em>V</em> − {<em>s</em>, <em>t</em>}, the shortest-path distance <em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>v</em>) in the residual network <em>G</em><sub><em>f</em></sub> increases monotonically with each flow augmentation.</p>
<p class="prof"><strong><em>Proof</em></strong>   We’ll suppose that a flow augmentation occurs that causes the shortest-path distance from <em>s</em> to some vertex <em>v</em> ∈ <em>V</em> − {<em>s</em>, <em>t</em>} to decrease and then derive a contradiction. Let <em>f</em> be the flow just before an augmentation that decreases some shortest-path distance, and let <em>f</em>′ be the flow just afterward. Let <em>v</em> be a vertex with the minimum <em>δ</em><sub><em>f′</em></sub> (<em>s</em>, <em>v</em>) whose distance was decreased by the augmentation, so that <em>δ</em><sub><em>f</em></sub>′ (<em>s</em>, <em>v</em>) &lt; <em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>v</em>). Let <em>p</em> = <em>s</em> <span class="font1">⇝</span> <em>u</em> → <em>v</em> be a shortest path from <em>s</em> to <em>v</em> in <em>G</em><sub><em>f</em></sub>′, so that (<em>u</em>, <em>v</em>) ∈ <em>E</em><sub><em>f</em></sub>′ and</p>
<p class="eqr"><img alt="art" src="images/Art_P778.jpg"/></p>
<p class="noindent">Because of how we chose <em>v</em>, we know that the distance of vertex <em>u</em> from the source <em>s</em> did not decrease, that is,</p>
<p class="eqr"><img alt="art" src="images/Art_P779.jpg"/></p>
<p class="noindent">We claim that (<em>u</em>, <em>v</em>) ∉ <em>E</em><sub><em>f</em></sub>. Why? If we have (<em>u</em>, <em>v</em>) ∈ <em>E</em><sub><em>f</em></sub>, then we also have</p>
<a id="p690"/>
<table class="table2b">
<tr>
<td class="td2"><em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>v</em>)</td>
<td class="td2">≤</td>
<td class="td2"><em>δ<sub>f</sub></em> (<em>s</em>, <em>u</em>) + 1</td>
<td class="td2">(by Lemma 22.10, the triangle inequality)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2"><em>δ<sub>f</sub></em>′ (<em>s</em>, <em>u</em>) + 1</td>
<td class="td2">(by inequality (24.12))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>δ</em><sub><em>f</em></sub>′ (<em>s</em>, <em>v</em>)</td>
<td class="td2">(by equation (24.11)),</td>
</tr>
</table>
<p class="noindent">which contradicts our assumption that <em>δ</em><sub><em>f</em>′</sub> (<em>s</em>, <em>v</em>) &lt; <em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>v</em>).</p>
<p>How can we have (<em>u</em>, <em>v</em>) ∉ <em>E</em><sub><em>f</em></sub> and (<em>u</em>, <em>v</em>) ∈ <em>E</em><sub><em>f</em>′</sub>? The augmentation must have increased the flow from <em>v</em> to <em>u</em>, so that edge (<em>v</em>, <em>u</em>) was in the augmenting path. The augmenting path was a shortest path from <em>s</em> to <em>t</em> in <em>G</em><sub><em>f</em></sub>, and since any subpath of a shortest path is itself a shortest path, this augmenting path includes a shortest path from <em>s</em> to <em>u</em> in <em>G</em><sub><em>f</em></sub> that has (<em>v</em>, <em>u</em>) as its last edge. Therefore,</p>
<table class="table2b">
<tr>
<td class="td2"><em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>v</em>)</td>
<td class="td2">=</td>
<td class="td2"><em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>u</em>) − 1</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2"><em>δ</em><sub><em>f</em>′</sub> (<em>s</em>, <em>u</em>) − 1</td>
<td class="td2">(by inequality (24.12))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>δ</em><sub><em>f</em>′</sub> (<em>s</em>, <em>v</em>) − 2</td>
<td class="td2">(by equation (24.11)),</td>
</tr>
</table>
<p class="noindent">so that <em>δ</em><sub><em>f</em>′</sub> (<em>s</em>, <em>v</em>) &gt; <em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>v</em>), contradicting our assumption that <em>δ</em><sub><em>f</em>′</sub> (<em>s</em>, <em>v</em>) &lt; <em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>v</em>). We conclude that our assumption that such a vertex <em>v</em> exists is incorrect.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The next theorem bounds the number of iterations of the Edmonds-Karp algorithm.</p>
<p class="theo"><strong><em>Theorem 24.8</em></strong></p>
<p class="noindent">If the Edmonds-Karp algorithm is run on a flow network <em>G</em> = (<em>V</em>, <em>E</em>) with source <em>s</em> and sink <em>t</em>, then the total number of flow augmentations performed by the algorithm is <em>O</em>(<em>VE</em>).</p>
<p class="prof"><strong><em>Proof</em></strong>   We say that an edge (<em>u</em>, <em>v</em>) in a residual network <em>G</em><sub><em>f</em></sub> is <strong><em><span class="blue">critical</span></em></strong> on an augmenting path <em>p</em> if the residual capacity of <em>p</em> is the residual capacity of (<em>u</em>, <em>v</em>), that is, if <em>c</em><sub><em>f</em></sub> (<em>p</em>) = <em>c</em><sub><em>f</em></sub> (<em>u</em>, <em>v</em>). After flow is augmented along an augmenting path, any critical edge on the path disappears from the residual network. Moreover, at least one edge on any augmenting path must be critical. We’ll show that each of the |<em>E</em>| edges can become critical at most |<em>V</em>|/2 times.</p>
<p>Let <em>u</em> and <em>v</em> be vertices in <em>V</em> that are connected by an edge in <em>E</em>. Since augmenting paths are shortest paths, when (<em>u</em>, <em>v</em>) is critical for the first time, we have</p>
<p class="eql"><em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>v</em>) = <em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>u</em>) + 1.</p>
<p class="noindent">Once the flow is augmented, the edge (<em>u</em>, <em>v</em>) disappears from the residual network. It cannot reappear later on another augmenting path until after the flow from <em>u</em> to <em>v</em> is decreased, which occurs only if (<em>v</em>, <em>u</em>) appears on an augmenting path. If <em>f</em> ′ is the flow in <em>G</em> when this event occurs, then we have</p>
<p class="eql"><em>δ</em><sub><em>f</em>′</sub> (<em>s</em>, <em>u</em>) = <em>δ</em><sub><em>f</em>′</sub> (<em>s</em>, <em>v</em>) + 1.</p>
<a id="p691"/>
<p class="noindent">Since <em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>v</em>) ≤ <em>δ</em><sub><em>f</em>′</sub> (<em>s</em>, <em>v</em>) by Lemma 24.7, we have</p>
<table class="table2b">
<tr>
<td class="td2"><em>δ</em><sub><em>f</em>′</sub> (<em>s</em>, <em>u</em>)</td>
<td class="td2">=</td>
<td class="td2"><em>δ</em><sub><em>f</em>′</sub> (<em>s</em>, <em>v</em>) + 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2"><em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>v</em>) + 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>δ</em><sub><em>f</em></sub> (<em>s</em>, <em>u</em>) + 2.</td>
</tr>
</table>
<p>Consequently, from the time (<em>u</em>, <em>v</em>) becomes critical to the time when it next becomes critical, the distance of <em>u</em> from the source increases by at least 2. The distance of <em>u</em> from the source is initially at least 0. Because edge (<em>u</em>, <em>v</em>) is on an augmenting path, and augmenting paths end at <em>t</em>, we know that <em>u</em> cannot be <em>t</em>, so that in any residual network that has a path from <em>s</em> to <em>u</em>, the shortest such path has at most |<em>V</em>| − 2 edges. Thus, after the first time that (<em>u</em>, <em>v</em>) becomes critical, it can become critical at most (|<em>V</em>| − 2)/2 = |<em>V</em>|/2 − 1 times more, for a total of at most |<em>V</em>|/2 times. Since there are <em>O</em>(<em>E</em>) pairs of vertices that can have an edge between them in a residual network, the total number of critical edges during the entire execution of the Edmonds-Karp algorithm is <em>O</em>(<em>VE</em>). Each augmenting path has at least one critical edge, and hence the theorem follows.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Because each iteration of F<small>ORD</small>-F<small>ULKERSON</small> takes <em>O</em>(<em>E</em>) time when it uses breadth-first search to find the augmenting path, the total running time of the Edmonds-Karp algorithm is <em>O</em>(<em>VE</em><sup>2</sup>).</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>24.2-1</em></strong></p>
<p class="noindent">Prove that the summations in equation (24.6) equal the summations on the right-hand side of equation (24.5).</p>
<p class="level3"><strong><em>24.2-2</em></strong></p>
<p class="noindent">In <a href="chapter024.xhtml#Fig_24-1">Figure 24.1(b)</a>, what is the net flow across the cut ({<em>s</em>, <em>v</em><sub>2</sub>, <em>v</em><sub>4</sub>}, {<em>v</em><sub>1</sub>, <em>v</em><sub>3</sub>, <em>t</em>})? What is the capacity of this cut?</p>
<p class="level3"><strong><em>24.2-3</em></strong></p>
<p class="noindent">Show the execution of the Edmonds-Karp algorithm on the flow network of <a href="chapter024.xhtml#Fig_24-1">Figure 24.1(a)</a>.</p>
<p class="level3"><strong><em>24.2-4</em></strong></p>
<p class="noindent">In the example of <a href="chapter024.xhtml#Fig_24-6">Figure 24.6</a>, what is the minimum cut corresponding to the maximum flow shown? Of the augmenting paths appearing in the example, which one cancels flow?</p>
<a id="p692"/>
<p class="level3"><strong><em>24.2-5</em></strong></p>
<p class="noindent">The construction in <a href="chapter024.xhtml#Sec_24.1">Section 24.1</a> to convert a flow network with multiple sources and sinks into a single-source, single-sink network adds edges with infinite capacity. Prove that any flow in the resulting network has a finite value if the edges of the original network with multiple sources and sinks have finite capacity.</p>
<p class="level3"><strong><em>24.2-6</em></strong></p>
<p class="noindent">Suppose that each source <em>s</em><sub><em>i</em></sub> in a flow network with multiple sources and sinks produces exactly <em>p</em><sub><em>i</em></sub> units of flow, so that Σ<sub><em>v</em>∈<em>V</em></sub> <em>f</em> (<em>s</em><sub><em>i</em></sub>, <em>v</em>) = <em>p</em><sub><em>i</em></sub>. Suppose also that each sink <em>t</em><sub><em>j</em></sub> consumes exactly <em>q</em><sub><em>j</em></sub> units, so that Σ<sub><em>v</em>∈<em>V</em></sub> <em>f</em> (<em>v</em>, <em>t</em><sub><em>j</em></sub>) = <em>q</em><sub><em>j</em></sub>, where Σ<sub><em>i</em></sub> <em>p<sub>i</sub></em> = Σ<sub><em>j</em></sub> <em>q<sub>j</sub></em>. Show how to convert the problem of finding a flow <em>f</em> that obeys these additional constraints into the problem of finding a maximum flow in a single-source, single-sink flow network.</p>
<p class="level3"><strong><em>24.2-7</em></strong></p>
<p class="noindent">Prove Lemma 24.2.</p>
<p class="level3"><strong><em>24.2-8</em></strong></p>
<p class="noindent">Suppose that we redefine the residual network to disallow edges into <em>s</em>. Argue that the procedure F<small>ORD</small>-F<small>ULKERSON</small> still correctly computes a maximum flow.</p>
<p class="level3"><strong><em>24.2-9</em></strong></p>
<p class="noindent">Suppose that both <em>f</em> and <em>f</em> ′ are flows in a flow network. Does the augmented flow <em>f</em> ↑ <em>f</em> ′ satisfy the flow conservation property? Does it satisfy the capacity constraint?</p>
<p class="level3"><strong><em>24.2-10</em></strong></p>
<p class="noindent">Show how to find a maximum flow in a flow network <em>G</em> = (<em>V</em>, <em>E</em>) by a sequence of at most |<em>E</em>| augmenting paths. (<em>Hint:</em> Determine the paths <em>after</em> finding the maximum flow.)</p>
<p class="level3"><strong><em>24.2-11</em></strong></p>
<p class="noindent">The <strong><em><span class="blue">edge connectivity</span></em></strong> of an undirected graph is the minimum number <em>k</em> of edges that must be removed to disconnect the graph. For example, the edge connectivity of a tree is 1, and the edge connectivity of a cyclic chain of vertices is 2. Show how to determine the edge connectivity of an undirected graph <em>G</em> = (<em>V</em>, <em>E</em>) by running a maximum-flow algorithm on at most |<em>V</em>| flow networks, each having <em>O</em>(<em>V</em> + <em>E</em>) vertices and <em>O</em>(<em>E</em>) edges.</p>
<p class="level3"><strong><em>24.2-12</em></strong></p>
<p class="noindent">You are given a flow network <em>G</em>, where <em>G</em> contains edges entering the source <em>s</em>. Let <em>f</em> be a flow in <em>G</em> with |<em>f</em>| ≥ 0 in which one of the edges (<em>v</em>, <em>s</em>) entering <a id="p693"/>the source has <em>f</em> (<em>v</em>, <em>s</em>) = 1. Prove that there must exist another flow <em>f</em> ′ with <em>f</em> ′(<em>v</em>, <em>s</em>) = 0 such that |<em>f</em>| = |<em>f</em>′|. Give an <em>O</em>(<em>E</em>)-time algorithm to compute <em>f</em>′, given <em>f</em> and assuming that all edge capacities are integers.</p>
<p class="level3"><strong><em>24.2-13</em></strong></p>
<p class="noindent">Suppose that you wish to find, among all minimum cuts in a flow network <em>G</em> with integer capacities, one that contains the smallest number of edges. Show how to modify the capacities of <em>G</em> to create a new flow network <em>G</em>′ in which any minimum cut in <em>G</em>′ is a minimum cut with the smallest number of edges in <em>G</em>.</p>
</section>
<p class="line1"/>
<section title="24.3 Maximum bipartite matching">
<a id="Sec_24.3"/>
<p class="level1" id="h1-143"><a href="toc.xhtml#Rh1-143"><strong>24.3    Maximum bipartite matching</strong></a></p>
<p class="noindent">Some combinatorial problems can be cast as maximum-flow problems, such as the multiple-source, multiple-sink maximum-flow problem from <a href="chapter024.xhtml#Sec_24.1">Section 24.1</a>. Other combinatorial problems seem on the surface to have little to do with flow networks, but they can in fact be reduced to maximum-flow problems. This section presents one such problem: finding a maximum matching in a bipartite graph. In order to solve this problem, we’ll take advantage of an integrality property provided by the Ford-Fulkerson method. We’ll also see how to use the Ford-Fulkerson method to solve the maximum-bipartite-matching problem on a graph <em>G</em> = (<em>V</em>, <em>E</em>) in <em>O</em>(<em>VE</em>) time. <a href="chapter025.xhtml#Sec_25.1">Section 25.1</a> will present an algorithm specifically designed to solve this problem.</p>
<p class="level4"><strong>The maximum-bipartite-matching problem</strong></p>
<p class="noindent">Given an undirected graph <em>G</em> = (<em>V</em>, <em>E</em>), a <strong><em><span class="blue">matching</span></em></strong> is a subset of edges <em>M</em> ⊆ <em>E</em> such that for all vertices <em>v</em> ∈ <em>V</em>, at most one edge of <em>M</em> is incident on <em>v</em>. We say that a vertex <em>v</em> ∈ <em>V</em> is <strong><em><span class="blue">matched</span></em></strong> by the matching <em>M</em> if some edge in <em>M</em> is incident on <em>v</em>, and otherwise, <em>v</em> is <strong><em><span class="blue">unmatched</span></em></strong>. A <strong><em><span class="blue">maximum matching</span></em></strong> is a matching of maximum cardinality, that is, a matching <em>M</em> such that for any matching <em>M</em>′, we have |<em>M</em>| ≥ |<em>M</em>′|. In this section, we restrict our attention to finding maximum matchings in bipartite graphs: graphs in which the vertex set can be partitioned into <em>V</em> = <em>L</em> ∪ <em>R</em>, where <em>L</em> and <em>R</em> are disjoint and all edges in <em>E</em> go between <em>L</em> and <em>R</em>. We further assume that every vertex in <em>V</em> has at least one incident edge. <a href="chapter024.xhtml#Fig_24-8">Figure 24.8</a> illustrates the notion of a matching in a bipartite graph.</p>
<p>The problem of finding a maximum matching in a bipartite graph has many practical applications. As an example, consider matching a set <em>L</em> of machines with a set <em>R</em> of tasks to be performed simultaneously. An edge (<em>u</em>, <em>v</em>) in <em>E</em> signifies that <a id="p694"/>a particular machine <em>u</em> ∈ <em>L</em> is capable of performing a particular task <em>v</em> ∈ <em>R</em>. A maximum matching provides work for as many machines as possible.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_24-8"><img alt="art" src="images/Art_P780.jpg"/></p>
<p class="caption"><strong>Figure 24.8</strong> A bipartite graph <em>G</em> = (<em>V</em>, <em>E</em>) with vertex partition <em>V</em> = <em>L</em> ∪ <em>R</em>. <strong>(a)</strong> A matching with cardinality 2, indicated by blue edges. <strong>(b)</strong> A maximum matching with cardinality 3. <strong>(c)</strong> The corresponding flow network <em>G</em>′ with a maximum flow shown. Each edge has unit capacity. Blue edges have a flow of 1, and all other edges carry no flow. The blue edges from <em>L</em> to <em>R</em> correspond to those in the maximum matching from (b).</p>
</div>
<p class="level4"><strong>Finding a maximum bipartite matching</strong></p>
<p class="noindent">The Ford-Fulkerson method provides a basis for finding a maximum matching in an undirected bipartite graph <em>G</em> = (<em>V</em>, <em>E</em>) in time polynomial in |<em>V</em>| and |<em>E</em>|. The trick is to construct a flow network in which flows correspond to matchings, as shown in <a href="chapter024.xhtml#Fig_24-8">Figure 24.8(c)</a>. We define the <strong><em><span class="blue">corresponding flow network</span></em></strong> <em>G</em>′ = (<em>V</em>′, <em>E</em>′) for the bipartite graph <em>G</em> as follows. Let the source <em>s</em> and sink <em>t</em> be new vertices not in <em>V</em>, and let <em>V</em>′ = <em>V</em> ∪ {<em>s</em>, <em>t</em>}. If the vertex partition of <em>G</em> is <em>V</em> = <em>L</em> ∪ <em>R</em>, the directed edges of <em>G</em>′ are the edges of <em>E</em>, directed from <em>L</em> to <em>R</em>, along with |<em>V</em> | new directed edges:</p>
<table class="table2b">
<tr>
<td class="td2"><em>E</em>′</td>
<td class="td2">=</td>
<td class="td2">{(<em>s</em>, <em>u</em>) : <em>u</em> ∈ <em>L</em>}</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2"/>
<td class="td2">∪ {(<em>u</em>, <em>v</em>) : <em>u</em> ∈ <em>L</em>, <em>v</em> ∈ <em>R</em>, and (<em>u</em>, <em>v</em>) ∈ <em>E</em>}</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2"/>
<td class="td2">∪ {(<em>v</em>, <em>t</em>) : <em>v</em> ∈ <em>R</em>}.</td>
</tr>
</table>
<p class="noindent">To complete the construction, assign unit capacity to each edge in <em>E</em>′. Since each vertex in <em>V</em> has at least one incident edge, |<em>E</em>| ≥ |<em>V</em>|/2. Thus, |<em>E</em>| ≤ |<em>E</em>′| = |<em>E</em>| + |<em>V</em>| ≤ 3 |<em>E</em>|, and so |<em>E</em>′| = Θ(<em>E</em>).</p>
<a id="p695"/>
<p>The following lemma shows that a matching in <em>G</em> corresponds directly to a flow in <em>G</em>’s corresponding flow network <em>G</em>′. We say that a flow <em>f</em> on a flow network <em>G</em> = (<em>V</em>, <em>E</em>) is <strong><em><span class="blue">integer-valued</span></em></strong> if <em>f</em> (<em>u</em>, <em>v</em>) is an integer for all (<em>u</em>, <em>v</em>) ∈ <em>V</em> × <em>V</em>.</p>
<p class="lem"><strong><em>Lemma 24.9</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a bipartite graph with vertex partition <em>V</em> = <em>L</em> ∪ <em>R</em>, and let <em>G</em>′ = (<em>V</em>′, <em>E</em>′) be its corresponding flow network. If <em>M</em> is a matching in <em>G</em>, then there is an integer-valued flow <em>f</em> in <em>G</em>′ with value |<em>f</em>| = |<em>M</em>|. Conversely, if <em>f</em> is an integer-valued flow in <em>G</em>′, then there is a matching <em>M</em> in <em>G</em> with cardinality |<em>M</em>| = |<em>f</em>| consisting of edges (<em>u</em>, <em>v</em>) ∈ <em>E</em> such that <em>f</em> (<em>u</em>, <em>v</em>) &gt; 0.</p>
<p class="prof"><strong><em>Proof</em></strong>   We first show that a matching <em>M</em> in <em>G</em> corresponds to an integer-valued flow <em>f</em> in <em>G</em>′. Define <em>f</em> as follows. If (<em>u</em>, <em>v</em>) ∈ <em>M</em>, then <em>f</em> (<em>s</em>, <em>u</em>) = <em>f</em> (<em>u</em>, <em>v</em>) = <em>f</em> (<em>v</em>, <em>t</em>) = 1. For all other edges (<em>u</em>, <em>v</em>) ∈ <em>E</em>′, define <em>f</em> (<em>u</em>, <em>v</em>) = 0. It is simple to verify that <em>f</em> satisfies the capacity constraint and flow conservation.</p>
<p>Intuitively, each edge (<em>u</em>, <em>v</em>) ∈ <em>M</em> corresponds to 1 unit of flow in <em>G</em>′ that traverses the path <em>s</em> → <em>u</em> → <em>v</em> → <em>t</em>. Moreover, the paths induced by edges in <em>M</em> are vertex-disjoint, except for <em>s</em> and <em>t</em>. The net flow across cut (<em>L</em> ∪ {<em>s</em>}, <em>R</em> ∪ {<em>t</em>}) is equal to |<em>M</em>|, and thus, by Lemma 24.4, the value of the flow is |<em>f</em>| = |<em>M</em>|.</p>
<p>To prove the converse, let <em>f</em> be an integer-valued flow in <em>G</em>′ and, as in the statement of the lemma, let</p>
<p class="eql"><em>M</em> = {(<em>u</em>, <em>v</em>) : <em>u</em> ∈ <em>L</em>, <em>v</em> ∈ <em>R</em>, and <em>f</em> (<em>u</em>, <em>v</em>) &gt; 0}.</p>
<p class="noindent">Each vertex <em>u</em> ∈ <em>L</em> has only one entering edge, namely (<em>s</em>, <em>u</em>), and its capacity is 1. Thus, each <em>u</em> ∈ <em>L</em> has at most 1 unit of flow entering it, and if 1 unit of flow does enter, by flow conservation, 1 unit of flow must leave. Furthermore, since the flow <em>f</em> is integer-valued, for each <em>u</em> ∈ <em>L</em>, the 1 unit of flow can enter on at most one edge and can leave on at most one edge. Thus, 1 unit of flow enters <em>u</em> if and only if there is exactly one vertex <em>v</em> ∈ <em>R</em> such that <em>f</em> (<em>u</em>, <em>v</em>) = 1, and at most one edge leaving each <em>u</em> ∈ <em>L</em> carries positive flow. A symmetric argument applies to each <em>v</em> ∈ <em>R</em>. The set <em>M</em> is therefore a matching.</p>
<p>To see that |<em>M</em>| = |<em>f</em>|, observe that of the edges (<em>u</em>, <em>v</em>) ∈ <em>E</em>′ such that <em>u</em> ∈ <em>L</em> and <em>v</em> ∈ <em>R</em>,</p>
<p class="eql"><img alt="art" src="images/Art_P781.jpg"/></p>
<p class="noindent">Consequently, <em>f</em> (<em>L</em> ∪ {<em>s</em>}, <em>R</em> ∪ {<em>t</em>}), the net flow across cut (<em>L</em> ∪ {<em>s</em>}, <em>R</em> ∪ {<em>t</em>}), is equal to |<em>M</em>|. Lemma 24.4 gives that |<em>f</em>| = <em>f</em> (<em>L</em> ∪ {<em>s</em>}, <em>R</em> ∪ {<em>t</em>}) = |<em>M</em>|.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Based on Lemma 24.9, we would like to conclude that a maximum matching in a bipartite graph <em>G</em> corresponds to a maximum flow in its corresponding flow <a id="p696"/>network <em>G</em>′, and therefore running a maximum-flow algorithm on <em>G</em>′ provides a maximum matching in <em>G</em>. The only hitch in this reasoning is that the maximum-flow algorithm might return a flow in <em>G</em>′ for which some <em>f</em> (<em>u</em>, <em>v</em>) is not an integer, even though the flow value |<em>f</em>| must be an integer. The following theorem shows that the Ford-Fulkerson method cannot produce a solution with this problem.</p>
<p class="theo"><strong><em>Theorem 24.10 (Integrality theorem)</em></strong></p>
<p class="noindent">If the capacity function <em>c</em> takes on only integer values, then the maximum flow <em>f</em> produced by the Ford-Fulkerson method has the property that |<em>f</em>| is an integer. Moreover, for all vertices <em>u</em> and <em>v</em>, the value of <em>f</em> (<em>u</em>, <em>v</em>) is an integer.</p>
<p class="prof"><strong><em>Proof</em></strong>   Exercise 24.3-2 asks you to provide the proof by induction on the number of iterations.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">We can now prove the following corollary to Lemma 24.9.</p>
<p class="cor"><strong><em>Corollary 24.11</em></strong></p>
<p class="noindent">The cardinality of a maximum matching <em>M</em> in a bipartite graph <em>G</em> equals the value of a maximum flow <em>f</em> in its corresponding flow network <em>G</em>′.</p>
<p class="prof"><strong><em>Proof</em></strong>   We use the nomenclature from Lemma 24.9. Suppose that <em>M</em> is a maximum matching in <em>G</em> and that the corresponding flow <em>f</em> in <em>G</em>′ is not maximum. Then there is a maximum flow <em>f</em>′ in <em>G</em>′ such that |<em>f</em>′| &gt; |<em>f</em>|. Since the capacities in <em>G</em>′ are integer-valued, by Theorem 24.10, we can assume that <em>f</em>′ is integer-valued. Thus, <em>f</em>′ corresponds to a matching <em>M</em>′ in <em>G</em> with cardinality |<em>M</em>′| = |<em>f</em>′| &gt; |<em>f</em>| = |<em>M</em>|, contradicting our assumption that <em>M</em> is a maximum matching. In a similar manner, we can show that if <em>f</em> is a maximum flow in <em>G</em>′, its corresponding matching is a maximum matching on <em>G</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Thus, to find a maximum matching in a bipartite undirected graph <em>G</em>, create the flow network <em>G</em>′, run the Ford-Fulkerson method on <em>G</em>′, and convert the integer-valued maximum flow found into a maximum matching for <em>G</em>. Since any matching in a bipartite graph has cardinality at most min {|<em>L</em>|, |<em>R</em>|} = <em>O</em>(<em>V</em>), the value of the maximum flow in <em>G</em>′ is <em>O</em>(<em>V</em>). Therefore, finding a maximum matching in a bipartite graph takes <em>O</em>(<em>VE</em>′) = <em>O</em>(<em>VE</em>) time, since |<em>E</em>′| = Θ(<em>E</em>).</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>24.3-1</em></strong></p>
<p class="noindent">Run the Ford-Fulkerson algorithm on the flow network in <a href="chapter024.xhtml#Fig_24-8">Figure 24.8(c)</a> and show the residual network after each flow augmentation. Number the vertices in <em>L</em> top <a id="p697"/>to bottom from 1 to 5 and in <em>R</em> top to bottom from 6 to 9. For each iteration, pick the augmenting path that is lexicographically smallest.</p>
<p class="level3"><strong><em>24.3-2</em></strong></p>
<p class="noindent">Prove Theorem 24.10. Use induction on the number of iterations of the Ford-Fulkerson method.</p>
<p class="level3"><strong><em>24.3-3</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a bipartite graph with vertex partition <em>V</em> = <em>L</em> ∪ <em>R</em>, and let <em>G</em>′ be its corresponding flow network. Give a good upper bound on the length of any augmenting path found in <em>G</em>′ during the execution of F<small>ORD</small>-F<small>ULKERSON</small>.</p>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-144"><strong>Problems</strong></p>
<section title="24-1 Escape problem">
<p class="level2"><strong><em>24-1     Escape problem</em></strong></p>
<p class="noindent">An <em>n</em>×<em>n</em> <strong><em><span class="blue">grid</span></em></strong> is an undirected graph consisting of <em>n</em> rows and <em>n</em> columns of vertices, as shown in <a href="chapter024.xhtml#Fig_24-9">Figure 24.9</a>. We denote the vertex in the <em>i</em>th row and the <em>j</em> th column by (<em>i</em>, <em>j</em>). All vertices in a grid have exactly four neighbors, except for the boundary vertices, which are the points (<em>i</em>, <em>j</em>) for which <em>i</em> = 1, <em>i</em> = <em>n</em>, <em>j</em> = 1, or <em>j</em> = <em>n</em>.</p>
<p>Given <em>m</em> ≤ <em>n</em><sup>2</sup> starting points (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>), …, (<em>x</em><sub><em>m</em></sub>, <em>y</em><sub><em>m</em></sub>) in the grid, the <strong><em><span class="blue">escape problem</span></em></strong> is to determine whether there are <em>m</em> vertex-disjoint paths from the starting points to any <em>m</em> different points on the boundary. For example, the grid in <a href="chapter024.xhtml#Fig_24-9">Figure 24.9(a)</a> has an escape, but the grid in <a href="chapter024.xhtml#Fig_24-9">Figure 24.9(b)</a> does not.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_24-9"><img alt="art" src="images/Art_P782.jpg"/></p>
<p class="caption"><strong>Figure 24.9</strong> Grids for the escape problem. Starting points are blue, and other grid vertices are tan. <strong>(a)</strong> A grid with an escape, shown by blue paths. <strong>(b)</strong> A grid with no escape.</p>
</div>
<a id="p698"/>
<p class="nl-1list-d"><strong><em>a.</em></strong> Consider a flow network in which vertices, as well as edges, have capacities. That is, the total positive flow entering any given vertex is subject to a capacity constraint. Show how to reduce the problem of determining the maximum flow in a network with edge and vertex capacities to an ordinary maximum-flow problem on a flow network of comparable size.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Describe an efficient algorithm to solve the escape problem, and analyze its running time.</p>
</section>
<section title="24-2 Minimum path cover">
<p class="level2"><strong><em>24-2     Minimum path cover</em></strong></p>
<p class="noindent">A <strong><em><span class="blue">path cover</span></em></strong> of a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) is a set <em>P</em> of vertex-disjoint paths such that every vertex in <em>V</em> is included in exactly one path in <em>P</em>. Paths may start and end anywhere, and they may be of any length, including 0. A <strong><em><span class="blue">minimum path cover</span></em></strong> of <em>G</em> is a path cover containing the fewest possible paths.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Give an efficient algorithm to find a minimum path cover of a directed acyclic graph <em>G</em> = (<em>V</em>, <em>E</em>). (<em>Hint:</em> Assuming that <em>V</em> = {1, 2, …, <em>n</em>}, construct a flow network based on the graph <em>G</em>′ = (<em>V</em>′, <em>E</em>′), where</p>
<p class="nl-1list-dp1"><em>V</em>′ = {<em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, …, <em>x</em><sub><em>n</em></sub>} ∪ {<em>y</em><sub>0</sub>, <em>y</em><sub>1</sub>, …, <em>y</em><sub><em>n</em></sub>},</p>
<p class="nl-1list-dp"><em>E</em>′ = {(<em>x</em><sub>0</sub>, <em>x</em><sub><em>i</em></sub>) : <em>i</em> ∈ <em>V</em> } ∪ {(<em>y</em><sub><em>i</em></sub>, <em>y</em><sub>0</sub>) : <em>i</em> ∈ <em>V</em> } ∪ {(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) : (<em>i</em>, <em>j</em>) ∈ <em>E</em>},</p>
<p class="nl-1list-dp1">and run a maximum-flow algorithm.)</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Does your algorithm work for directed graphs that contain cycles? Explain.</p>
</section>
<section title="24-3 Hiring consulting experts">
<p class="level2"><strong><em>24-3     Hiring consulting experts</em></strong></p>
<p class="noindent">Professor Fieri wants to open a consulting company for the food industry. He has identified <em>n</em> important food categories, which he represents by the set <em>C</em> = {<em>C</em><sub>1</sub>, <em>C</em><sub>2</sub>, …, <em>C</em><sub><em>n</em></sub>}. In each category <em>C</em><sub><em>k</em></sub>, he can hire an expert in that category for <em>e</em><sub><em>k</em></sub> &gt; 0 dollars. The consulting company has lined up a set <em>J</em> = {<em>J</em><sub>1</sub>, <em>J</em><sub>2</sub>, …, <em>J</em><sub><em>m</em></sub>} of potential jobs. In order to perform job <em>J</em><sub><em>i</em></sub>, the company needs to have hired experts in a subset <em>R</em><sub><em>i</em></sub> ⊆ <em>C</em> of categories. Each expert can work on multiple jobs simultaneously. If the company chooses to accept job <em>J</em><sub><em>i</em></sub>, it must have hired experts in all categories in <em>R</em><sub><em>i</em></sub>, and it takes in revenue of <em>p</em><sub><em>i</em></sub> &gt; 0 dollars.</p>
<p>Professor Fieri’s job is to determine which categories to hire experts in and which jobs to accept in order to maximize the net revenue, which is the total income from jobs accepted minus the total cost of employing the experts.</p>
<p>Consider the following flow network <em>G</em>. It contains a source vertex <em>s</em>, vertices <em>C</em><sub>1</sub>, <em>C</em><sub>2</sub>, …, <em>C</em><sub><em>n</em></sub>, vertices <em>J</em><sub>1</sub>, <em>J</em><sub>2</sub>, …, <em>J</em><sub><em>m</em></sub>, and a sink vertex <em>t</em>. For <em>k</em> = 1, 2 …, <em>n</em>, the flow network contains an edge (<em>s</em>, <em>C</em><sub><em>k</em></sub>) with capacity <em>c</em>(<em>s</em>, <em>C<sub>k</sub></em>) = <em>e</em><sub><em>k</em></sub>, and for <em>i</em> = 1, 2, …, <em>m</em>, the flow network contains an edge (<em>J</em><sub><em>i</em></sub>, <em>t</em>) with capacity <a id="p699"/><em>c</em>(<em>J<sub>i</sub></em>, <em>t</em>) = <em>p</em><sub><em>i</em></sub>. For <em>k</em> = 1, 2, …, <em>n</em> and <em>i</em> = 1, 2, …, <em>m</em>, if <em>C</em><sub><em>k</em></sub> ∈ <em>R</em><sub><em>i</em></sub>, then <em>G</em> contains an edge (<em>C</em><sub><em>k</em></sub>, <em>J</em><sub><em>i</em></sub>) with capacity <em>c</em>(<em>C</em><sub><em>k</em></sub>, <em>J</em><sub><em>i</em></sub>) = ∞.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Show that if <em>J</em><sub><em>i</em></sub> ∈ <em>T</em> for a finite-capacity cut (<em>S</em>, <em>T</em>) of <em>G</em>, then <em>C</em><sub><em>k</em></sub> ∈ <em>T</em> for each <em>C</em><sub><em>k</em></sub> ∈ <em>R</em><sub><em>i</em></sub>.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Show how to determine the maximum net revenue from the capacity of a minimum cut of <em>G</em> and the given <em>p</em><sub><em>i</em></sub> values.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Give an efficient algorithm to determine which jobs to accept and which experts to hire. Analyze the running time of your algorithm in terms of <em>m</em>, <em>n</em>, and <img alt="art" src="images/Art_P783.jpg"/>.</p>
</section>
<section title="24-4 Updating maximum flow">
<p class="level2"><strong><em>24-4     Updating maximum flow</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a flow network with source <em>s</em>, sink <em>t</em>, and integer capacities. Suppose that you are given a maximum flow in <em>G</em>.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Suppose that the capacity of a single edge (<em>u</em>, <em>v</em>) ∈ <em>E</em> increases by 1. Give an <em>O</em>(<em>V</em> + <em>E</em>)-time algorithm to update the maximum flow.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Suppose that the capacity of a single edge (<em>u</em>, <em>v</em>) ∈ <em>E</em> decreases by 1. Give an <em>O</em>(<em>V</em> + <em>E</em>)-time algorithm to update the maximum flow.</p>
</section>
<section title="24-5 Maximum flow by scaling">
<p class="level2"><strong><em>24-5     Maximum flow by scaling</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a flow network with source <em>s</em>, sink <em>t</em>, and an integer capacity <em>c</em>(<em>u</em>, <em>v</em>) on each edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>. Let <em>C</em> = max {<em>c</em>(<em>u</em>, <em>v</em>) : (<em>u</em>, <em>v</em>) ∈ <em>E</em>}.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Argue that a minimum cut of <em>G</em> has capacity at most <em>C</em> |<em>E</em>|.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> For a given number <em>K</em>, show how to find an augmenting path of capacity at least <em>K</em> in <em>O</em>(<em>E</em>) time, if such a path exists.</p>
<p class="noindent1-top">The procedure M<small>AX</small>-F<small>LOW</small>-B<small>Y</small>-S<small>CALING</small> appearing on the following page modifies the basic F<small>ORD</small>-F<small>ULKERSON</small>-M<small>ETHOD</small> procedure to compute a maximum flow in <em>G</em>.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Argue that M<small>AX</small>-F<small>LOW</small>-B<small>Y</small>-S<small>CALING</small> returns a maximum flow.</p>
<p class="nl-1list-d"><strong><em>d.</em></strong> Show that the capacity of a minimum cut of the residual network <em>G</em><sub><em>f</em></sub> is less than 2<em>K</em> |<em>E</em>| each time line 4 executes.</p>
<p class="nl-1list-d"><strong><em>e.</em></strong> Argue that the inner <strong>while</strong> loop of lines 5–6 executes <em>O</em>(<em>E</em>) times for each value of <em>K</em>.</p>
<a id="p700"/>
<div class="pull-quote1">
<p class="box-heading">M<small>AX</small>-F<small>LOW</small>-B<small>Y</small>-S<small>CALING</small> (<em>G</em>, <em>s</em>, <em>t</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>C</em> = max {<em>c</em>(<em>u</em>, <em>v</em>) : (<em>u</em>, <em>v</em>) ∈ <em>E</em>}</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent">initialize flow <em>f</em> to 0</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><em>K</em> = 2<sup>⌊lg <em>C</em>⌋</sup></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> <em>K</em> ≥ 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p2"><strong>while</strong> there exists an augmenting path <em>p</em> of capacity at least <em>K</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="p3">augment flow <em>f</em> along <em>p</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1"><p class="p2"><em>K</em> = <em>K</em>/2</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">8</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>f</em></p></td>
</tr>
</table>
</div>
<p class="nl-1list-d"><strong><em>f.</em></strong> Conclude that M<small>AX</small>-F<small>LOW</small>-B<small>Y</small>-S<small>CALING</small> can be implemented so that it runs in <em>O</em>(<em>E</em><sup>2</sup> lg <em>C</em>) time.</p>
</section>
<section title="24-6 Widest augmenting path">
<p class="level2"><strong><em>24-6     Widest augmenting path</em></strong></p>
<p class="noindent">The Edmonds-Karp algorithm implements the Ford-Fulkerson algorithm by always choosing a shortest augmenting path in the residual network. Suppose instead that the Ford-Fulkerson algorithm chooses a <strong><em><span class="blue">widest augmenting path</span></em></strong>: an augmenting path with the greatest residual capacity. Assume that <em>G</em> = (<em>V</em>, <em>E</em>) is a flow network with source <em>s</em> and sink <em>t</em>, that all capacities are integer, and that the largest capacity is <em>C</em>. In this problem, you will show that choosing a widest augmenting path results in at most |<em>E</em>| ln |<em>f</em>*| augmentations to find a maximum flow <em>f</em>*.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Show how to adjust Dijkstra’s algorithm to find the widest augmenting path in the residual network.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Show that a maximum flow in <em>G</em> can be formed by successive flow augmentations along at most |<em>E</em>| paths from <em>s</em> to <em>t</em>.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Given a flow <em>f</em>, argue that the residual network <em>G</em><sub><em>f</em></sub> has an augmenting path <em>p</em> with residual capacity <em>c</em><sub><em>f</em></sub> (<em>p</em>) ≥ (|<em>f</em>*| − |<em>f</em>|)/|<em>E</em>|.</p>
<p class="nl-1list-d"><strong><em>d.</em></strong> Assuming that each augmenting path is a widest augmenting path, let <em>f</em><sub><em>i</em></sub> be the flow after augmenting the flow by the <em>i</em>th augmenting path, where <em>f</em><sub>0</sub> has <em>f</em> (<em>u</em>, <em>v</em>) = 0 for all edges (<em>u</em>, <em>v</em>). Show that |<em>f</em>*| − |<em>f</em><sub><em>i</em></sub>| ≤ |<em>f</em>*| (1 − 1/|<em>E</em>|)<sup><em>i</em></sup>.</p>
<p class="nl-1list-d"><strong><em>e.</em></strong> Show that |<em>f</em>* | − |<em>f</em><sub><em>i</em></sub>| &lt; |<em>f</em>*| <em>e</em><sup>−<em>i</em>/|<em>E</em>|</sup>.</p>
<p class="nl-1list-d"><strong><em>f.</em></strong> Conclude that after the flow is augmented at most |<em>E</em>| ln |<em>f</em>*| times, the flow is a maximum flow.</p>
<a id="p701"/>
</section>
<section title="24-7 Global minimum cut">
<p class="level2"><strong><em>24-7     Global minimum cut</em></strong></p>
<p class="noindent">A <strong><em><span class="blue">global cut</span></em></strong> in an undirected graph <em>G</em> = (<em>V</em>, <em>E</em>) is a partition (see page 1156) of <em>V</em> into two nonempty sets <em>V</em><sub>1</sub> and <em>V</em><sub>2</sub>. This definition is like the definition of cut that we have used in this chapter, except that we no longer have distinguished vertices <em>s</em> and <em>t</em>. Any edge (<em>u</em>, <em>v</em>) with <em>u</em> ∈ <em>V</em><sub>1</sub> and <em>v</em> ∈ <em>V</em><sub>2</sub> is said to <strong><em><span class="blue">cross</span></em></strong> the cut.</p>
<p>We can extend this definition of a cut to a multigraph <em>G</em> = (<em>V</em>, <em>E</em>) (see page 1167), and we denote by <em>c</em>(<em>u</em>, <em>v</em>) the number of edges in the multigraph with endpoints <em>u</em> and <em>v</em>. A global cut in a multigraph is still a partition of the vertices, and the value of a global cut (<em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>) is <img alt="art" src="images/Art_P784.jpg"/>. A solution to the <strong><em><span class="blue">global-minimum-cut problem</span></em></strong> is a cut (<em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>) such that <em>c</em>(<em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>) is minimum. Let <em>μ</em>(<em>G</em>) denote the value of a global minimum cut in a graph or multigraph <em>G</em>.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Show how to find a global minimum cut of a graph <em>G</em> = (<em>V</em>, <em>E</em>) by solving <img alt="art" src="images/Art_P785.jpg"/> maximum-flow problems, each with a different pair of vertices as the source and sink, and taking the mininum value of the cuts found.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Give an algorithm to find a global minimum cut by solving only Θ(<em>V</em>) maximum-flow problems. What is the running time of your algorithm?</p>
<p class="space-break">The remainder of this problem develops an algorithm for the global-minimum-cut problem that does not use any maximum-flow computations. It uses the notion of an edge contraction, defined on page 1168, with one crucial difference. The algorithm maintains a multigraph, so that upon contracting an edge (<em>u</em>, <em>v</em>), it creates a new vertex <em>x</em>, and for any other vertex <em>y</em> ∈ <em>V</em>, the number of edges between <em>x</em> and <em>y</em> is <em>c</em>(<em>u</em>, <em>y</em>) + <em>c</em>(<em>v</em>, <em>y</em>). The algorithm does not maintain self-loops, and so it sets <em>c</em>(<em>x</em>, <em>x</em>) to 0. Denote by <em>G</em>/(<em>u</em>, <em>v</em>) the multigraph that results from contracting edge (<em>u</em>, <em>v</em>) in multigraph <em>G</em>.</p>
<p>Consider what can happen to the minimum cut when an edge is contracted. Assume that, at all points, the minimum cut in a multigraph <em>G</em> is unique. We’ll remove this assumption later.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Show that for any edge (<em>u</em>, <em>v</em>), we have <em>μ</em>(<em>G</em>/(<em>u</em>, <em>v</em>)) ≤ <em>μ</em>(<em>G</em>). Under what conditions is <em>μ</em>(<em>G</em>/(<em>u</em>, <em>v</em>)) &lt; <em>μ</em>(<em>G</em>)?</p>
<p class="space-break">Next, you will show that if you pick an edge uniformly at random, the probability that it belongs to the minimum cut is small.</p>
<p class="nl-1list-d"><strong><em>d.</em></strong> Show that for any multigraph <em>G</em> = (<em>V</em>, <em>E</em>), the value of the global minimum cut is at most the average degree of a vertex: that <em>μ</em>(<em>G</em>) ≤ 2 |<em>E</em>|/|<em>V</em>|, where |<em>E</em>| denotes the total number of edges in the multigraph.</p>
<a id="p702"/>
<p class="nl-1list-d"><strong><em>e.</em></strong> Using the results from parts (c) and (d), show that, if we pick an edge (<em>u</em>, <em>v</em>) uniformly at random, then the probability that (<em>u</em>, <em>v</em>) belongs to the minimum cut is at most 2/<em>V</em>.</p>
<p class="space-break">Consider the algorithm that repeatedly chooses an edge at random and contracts it until the multigraph has exactly two vertices, say <em>u</em> and <em>v</em>. At that point, the multigraph corresponds to a cut in the original graph, with vertex <em>u</em> representing all the nodes in one side of the original graph, and <em>v</em> representing all the vertices on the other side. The number of edges given by <em>c</em>(<em>u</em>, <em>v</em>) corresponds exactly to the number of edges crossing the corresponding cut in the original graph. We call this algorithm the <strong><em><span class="blue">contraction algorithm</span></em></strong>.</p>
<p class="nl-1list-d"><strong><em>f.</em></strong> Suppose that the contraction algorithm terminates with a multigraph whose only vertices are <em>u</em> and <em>v</em>. Show that <img alt="art" src="images/Art_P786.jpg"/>.</p>
<p class="nl-1list-d"><strong><em>g.</em></strong> Prove that if the contraction algorithm repeats <img alt="art" src="images/Art_P787.jpg"/> times, then the probability that at least one of the runs returns the minimum cut is at least 1 − 1/|<em>V</em>|.</p>
<p class="nl-1list-d"><strong><em>h.</em></strong> Give a detailed implementation of the contraction algorithm that runs in <em>O</em>(<em>V</em><sup>2</sup>) time.</p>
<p class="nl-1list-d"><strong><em>i.</em></strong> Combine the previous parts and remove the assumption that the minimum cut must be unique, to conclude that running the contraction algorithm <img alt="art" src="images/Art_P788.jpg"/> times yields an algorithm that runs in <em>O</em>(<em>V</em><sup>4</sup> lg <em>V</em>) time and returns a minimum cut with probability at least 1 − 1/<em>V</em>.</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-145"><strong>Chapter notes</strong></p>
<p class="noindent">Ahuja, Magnanti, and Orlin [<a epub:type="noteref" href="bibliography001.xhtml#endnote_7">7</a>], Even [<a epub:type="noteref" href="bibliography001.xhtml#endnote_137">137</a>], Lawler [<a epub:type="noteref" href="bibliography001.xhtml#endnote_276">276</a>], Papadimitriou and Steiglitz [<a epub:type="noteref" href="bibliography001.xhtml#endnote_353">353</a>], Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_429">429</a>], and Williamson [<a epub:type="noteref" href="bibliography001.xhtml#endnote_458">458</a>] are good references for network flows and related algorithms. Schrijver [<a epub:type="noteref" href="bibliography001.xhtml#endnote_399">399</a>] has written an interesting review of historical developments in the field of network flows.</p>
<p>The Ford-Fulkerson method is due to Ford and Fulkerson [<a epub:type="noteref" href="bibliography001.xhtml#endnote_149">149</a>], who originated the formal study of many of the problems in the area of network flow, including the maximum-flow and bipartite-matching problems. Many early implementations of the Ford-Fulkerson method found augmenting paths using breadth-first search. Edmonds and Karp [<a epub:type="noteref" href="bibliography001.xhtml#endnote_132">132</a>], and independently Dinic [<a epub:type="noteref" href="bibliography001.xhtml#endnote_119">119</a>], proved that this strategy yields a polynomial-time algorithm. A related idea, that of using “blocking flows,” was also first developed by Dinic [<a epub:type="noteref" href="bibliography001.xhtml#endnote_119">119</a>].</p>
<p>A class of algorithms known as <strong><em><span class="blue">push-relabel algorithms</span></em></strong>, due to Goldberg [<a epub:type="noteref" href="bibliography001.xhtml#endnote_185">185</a>] and Goldberg and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_188">188</a>], takes a different approach from the Ford-Fulkerson <a id="p703"/>method. Push-relabel algorithms allow flow conservation to be violated at vertices other than the source and sink as they execute. Using an idea first developed by Karzonov [<a epub:type="noteref" href="bibliography001.xhtml#endnote_251">251</a>], they allow a <strong><em><span class="blue">preflow</span></em></strong> in which the flow into a vertex may exceed the flow out of the vertex. Such a vertex is said to be <strong><em><span class="blue">overflowing</span></em></strong>. Initially, every edge leaving the source is filled to capacity, so that all neighbors of the source are overflowing. In a push-relabel algorithm, each vertex is assigned an integer height. An overflowing vertex may push flow to a neighboring vertex to which it has a residual edge provided that it is higher than the neighbor. If all residual edges from an overflowing vertex go to neighbors with equal or greater heights, then the vertex may increase its height. Once all vertices other than the sink are no longer overflowing, the preflow is not only a legal flow, but also a maximum flow.</p>
<p>Goldberg and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_188">188</a>] gave an <em>O</em>(<em>V</em><sup>3</sup>)-time algorithm that uses a queue to maintain the set of overflowing vertices, as well as an algorithm that uses dynamic trees to achieve a running time of <em>O</em>(<em>VE</em> lg(<em>V</em><sup>2</sup>/<em>E</em> + 2)). Several other researchers developed improved variants and implementations [<a epub:type="noteref" href="bibliography001.xhtml#endnote_9">9</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_10">10</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_15">15</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_86">86</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_87">87</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_255">255</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_358">358</a>], the fastest of which, by King, Rao, and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_255">255</a>], runs in <em>O</em>(<em>VE</em> log<sub><em>E</em>/(<em>V</em> lg <em>V</em>)</sub> <em>V</em>) time.</p>
<p>Another efficient algorithm for maximum flow, by Goldberg and Rao [<a epub:type="noteref" href="bibliography001.xhtml#endnote_187">187</a>], runs in <em>O</em> (min{<em>V</em><sup>2/3</sup>, <em>E</em><sup>1/2</sup>} <em>E</em> lg (<em>V</em><sup>2</sup>/<em>E</em> + 2) lg <em>C</em>) time, where <em>C</em> is the maximum capacity any edge. Orlin [<a epub:type="noteref" href="bibliography001.xhtml#endnote_350">350</a>] gave an algorithm in the same spirit as this algorithm that runs in <em>O</em>(<em>VE</em> + <em>E</em><sup>31/16</sup> lg<sup>2</sup> <em>V</em>) time. Combining it with the algorithm of King, Rao, and Tarjan results in an <em>O</em>(<em>VE</em>)-time algorithm.</p>
<p>A different approach to maximum flows and related problems is to use techniques from continuous optimization including electrical flows and interior-point methods. The first breakthrough in this line of work is due to Madry [<a epub:type="noteref" href="bibliography001.xhtml#endnote_308">308</a>], who gave an <em>Õ</em>(<em>E</em><sup>10/7</sup>)-time algorithm for unit-capacity maximum flow and bipartite maximum matching. (See Problem 3-6 on page 73 for a definition of <em>Õ</em>.) There has been a series of papers in this area for matchings, maximum flows, and minimum-cost flows. The fastest algorithm to date in this line of work for maximum flow is due to Lee and Sidford [<a epub:type="noteref" href="bibliography001.xhtml#endnote_285">285</a>], taking <img alt="art" src="images/Art_P789.jpg"/> time. If the capacities are not too large, this algorithm is faster than the <em>O</em>(<em>VE</em>)-time algorithm mentioned above. Another algorithm, due to Liu and Sidford [<a epub:type="noteref" href="bibliography001.xhtml#endnote_303">303</a>] runs in <em>Õ</em>(<em>E</em><sup>11/8</sup><em>C</em><sup>1/4</sup>) time, where <em>C</em> is the maximum capacity of any edge. This algorithm does not run in polynomial time, but for small enough capacities, it is faster than the previous ones.</p>
<p>In practice, push-relabel algorithms currently dominate algorithms based on augmenting paths, continuous-optimization, and linear programming for the maximum-flow problem [<a epub:type="noteref" href="bibliography001.xhtml#endnote_88">88</a>].</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> Recall from <a href="chapter020.xhtml#Sec_20.1">Section 20.1</a> that we represent an attribute <em>f</em> for edge (<em>u</em>, <em>v</em>) with the same style of notation—(<em>u</em>, <em>v</em>).<em>f</em>—that we use for an attribute of any other object.</p>
</section>
</section>
</div>
</body>
</html>