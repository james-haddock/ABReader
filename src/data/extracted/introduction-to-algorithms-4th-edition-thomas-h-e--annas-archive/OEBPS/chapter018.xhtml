<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p497"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="18 B-Trees">
<p class="chapter-title"><a href="toc.xhtml#chap-18"><strong><span class="blue1">18        B-Trees</span></strong></a></p>
<p class="noindent">B-trees are balanced search trees designed to work well on disk drives or other direct-access secondary storage devices. B-trees are similar to red-black trees (<a href="chapter013.xhtml">Chapter 13</a>), but they are better at minimizing the number of operations that access disks. (We often say just “disk” instead of “disk drive.”) Many database systems use B-trees, or variants of B-trees, to store information.</p>
<p>B-trees differ from red-black trees in that B-tree nodes may have many children, from a few to thousands. That is, the “branching factor” of a B-tree can be quite large, although it usually depends on characteristics of the disk drive used. B-trees are similar to red-black trees in that every <em>n</em>-node B-tree has height <em>O</em>(lg <em>n</em>), so that B-trees can implement many dynamic-set operations in <em>O</em>(lg <em>n</em>) time. But a B-tree has a larger branching factor than a red-black tree, so the base of the logarithm that expresses its height is larger, and hence its height can be considerably lower.</p>
<p>B-trees generalize binary search trees in a natural manner. <a href="chapter018.xhtml#Fig_18-1">Figure 18.1</a> shows a simple B-tree. If an internal B-tree node <em>x</em> contains <em>x</em>.<em>n</em> keys, then <em>x</em> has <em>x</em>.<em>n</em> + 1 children. The keys in node <em>x</em> serve as dividing points separating the range of keys handled by <em>x</em> into <em>x</em>.<em>n</em> + 1 subranges, each handled by one child of <em>x</em>. A search for a key in a B-tree makes an (<em>x</em>.<em>n</em> + 1)-way decision based on comparisons with the <em>x</em>.<em>n</em> keys stored at node <em>x</em>. An internal node contains pointers to its children, but a leaf node does not.</p>
<p><a href="chapter018.xhtml#Sec_18.1">Section 18.1</a> gives a precise definition of B-trees and proves that the height of a B-tree grows only logarithmically with the number of nodes it contains. <a href="chapter018.xhtml#Sec_18.2">Section 18.2</a> describes how to search for a key and insert a key into a B-tree, and <a href="chapter018.xhtml#Sec_18.3">Section 18.3</a> discusses deletion. Before proceeding, however, we need to ask why we evaluate data structures designed to work on a disk drive differently from data structures designed to work in main random-access memory.</p>
<a id="p498"/>
<div class="divimage">
<p class="fig-imga" id="Fig_18-1"><img alt="art" src="images/Art_P539.jpg"/></p>
<p class="caption"><strong>Figure 18.1</strong> A B-tree whose keys are the consonants of English. An internal node <em>x</em> containing <em>x</em>.<em>n</em> keys has <em>x</em>.<em>n</em> + 1 children. All leaves are at the same depth in the tree. The blue nodes are examined in a search for the letter <em>R</em>.</p>
</div>
<p class="level4"><strong>Data structures on secondary storage</strong></p>
<p class="noindent">Computer systems take advantage of various technologies that provide memory capacity. The <span class="blue"><strong><em>main memory</em></strong></span> of a computer system normally consists of silicon memory chips. This technology is typically more than an order of magnitude more expensive per bit stored than magnetic storage technology, such as tapes or disk drives. Most computer systems also have <span class="blue"><strong><em>secondary storage</em></strong></span> based on solid-state drives (SSDs) or magnetic disk drives. The amount of such secondary storage often exceeds the amount of primary memory by one to two orders of magnitude. SSDs have faster access times than magnetic disk drives, which are mechanical devices. In recent years, SSD capacities have increased while their prices have decreased. Magnetic disk drives typically have much higher capacities than SSDs, and they remain a more cost-effective means for storing massive amounts of information. Disk drives that store several terabytes<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup> can be found for under $100.</p>
<p><a href="chapter018.xhtml#Fig_18-2">Figure 18.2</a> shows a typical disk drive. The drive consists of one or more <span class="blue"><strong><em>platters</em></strong></span>, which rotate at a constant speed around a common <span class="blue"><strong><em>spindle</em></strong></span>. A magnetizable material covers the surface of each platter. The drive reads and writes each platter by a <span class="blue"><strong><em>head</em></strong></span> at the end of an <span class="blue"><strong><em>arm</em></strong></span>. The arms can move their heads toward or away from the spindle. The surface that passes underneath a given head when it is stationary is called a <span class="blue"><strong><em>track</em></strong></span>.</p>
<p>Although disk drives are cheaper and have higher capacity than main memory, they are much, much slower because they have moving mechanical parts. The mechanical motion has two components: platter rotation and arm movement. As of this writing, commodity disk drives rotate at speeds of 5400–15,000 revolutions per minute (RPM). Typical speeds are 15,000 RPM in server-grade drives, 7200 RPM <a id="p499"/>in drives for desktops, and 5400 RPM in drives for laptops. Although 7200 RPM may seem fast, one rotation takes 8.33 milliseconds, which is over 5 orders of magnitude longer than the 50 nanosecond access times (more or less) commonly found for main memory. In other words, if a computer waits a full rotation for a particular item to come under the read/write head, it could access main memory more than 100,000 times during that span. The average wait is only half a rotation, but still, the difference in access times for main memory compared with disk drives is enormous. Moving the arms also takes some time. As of this writing, average access times for commodity disk drives are around 4 milliseconds.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_18-2"><img alt="art" src="images/Art_P540.jpg"/></p>
<p class="caption"><strong>Figure 18.2</strong> A typical magnetic disk drive. It consists of one or more platters covered with a magnetizable material (two platters are shown here) that rotate around a spindle. Each platter is read and written with a head, shown in red, at the end of an arm. Arms rotate around a common pivot axis. A track, drawn in blue, is the surface that passes beneath the read/write head when the head is stationary.</p>
</div>
<p>In order to amortize the time spent waiting for mechanical movements, also known as <span class="blue"><strong><em>latency</em></strong></span>, disk drives access not just one item but several at a time. Information is divided into a number of equal-sized <span class="blue"><strong><em>blocks</em></strong></span> of bits that appear consecutively within tracks, and each disk read or write is of one or more entire blocks.<sup><a epub:type="footnote" href="#footnote_2" id="footnote_ref_2">2</a></sup> Typical disk drives have block sizes running from 512 to 4096 bytes. Once the read/write head is positioned correctly and the platter has rotated to the beginning of the desired block, reading or writing a magnetic disk drive is entirely electronic (aside from the rotation of the platter), and the disk drive can quickly read or write large amounts of data.</p>
<a id="p500"/>
<p>Often, accessing a block of information and reading it from a disk drive takes longer than processing all the information read. For this reason, in this chapter we’ll look separately at the two principal components of the running time:</p>
<ul class="ulnoindent" epub:type="list">
<li>the number of disk accesses, and</li>
<li class="litop">the CPU (computing) time.</li></ul>
<p class="noindent">We measure the number of disk accesses in terms of the number of blocks of information that need to be read from or written to the disk drive. Although disk-access time is not constant—it depends on the distance between the current track and the desired track and also on the initial rotational position of the platters—the number of blocks read or written provides a good first-order approximation of the total time spent accessing the disk drive.</p>
<p>In a typical B-tree application, the amount of data handled is so large that all the data do not fit into main memory at once. The B-tree algorithms copy selected blocks from disk into main memory as needed and write back onto disk the blocks that have changed. B-tree algorithms keep only a constant number of blocks in main memory at any time, and thus the size of main memory does not limit the size of B-trees that can be handled.</p>
<p>B-tree procedures need to be able to read information from disk into main memory and write information from main memory to disk. Consider some object <em>x</em>. If <em>x</em> is currently in the computer’s main memory, then the code can refer to the attributes of <em>x</em> as usual: <em>x</em>.<em>key</em>, for example. If <em>x</em> resides on disk, however, then the procedure must perform the operation D<small>ISK</small>-R<small>EAD</small>(<em>x</em>) to read the block containing object <em>x</em> into main memory before it can refer to <em>x</em>’s attributes. (Assume that if <em>x</em> is already in main memory, then D<small>ISK</small>-R<small>EAD</small>(<em>x</em>) requires no disk accesses: it is a “no-op.”) Similarly, procedures call D<small>ISK</small>-W<small>RITE</small>(<em>x</em>) to save any changes that have been made to the attributes of object <em>x</em> by writing to disk the block containing <em>x</em>. Thus, the typical pattern for working with an object is as follows:</p>
<div class="pull-quote1a">
<table class="table1">
<tr>
<td class="td1" colspan="2"><p class="noindent"><em>x</em> = a pointer to some object</p></td>
</tr>
<tr>
<td class="td1" colspan="2"><p class="noindent">D<small>ISK</small>-R<small>EAD</small>(<em>x</em>)</p></td>
</tr>
<tr>
<td class="td1" colspan="2"><p class="noindent">operations that access and/or modify the attributes of <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent">D<small>ISK</small>-W<small>RITE</small>(<em>x</em>)</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> omitted if no attributes of <em>x</em> were changed</span></p></td>
</tr>
<tr>
<td class="td1" colspan="2"><p class="noindent">other operations that access but do not modify attributes of <em>x</em></p></td>
</tr>
</table>
</div>
<p class="noindent">The system can keep only a limited number of blocks in main memory at any one time. Our B-tree algorithms assume that the system automatically flushes from main memory blocks that are no longer in use.</p>
<p>Since in most systems the running time of a B-tree algorithm depends primarily on the number of D<small>ISK</small>-R<small>EAD</small> and D<small>ISK</small>-W<small>RITE</small> operations it performs, we <a id="p501"/>typically want each of these operations to read or write as much information as possible. Thus, a B-tree node is usually as large as a whole disk block, and this size limits the number of children a B-tree node can have.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_18-3"><img alt="art" src="images/Art_P541.jpg"/></p>
<p class="caption"><strong>Figure 18.3</strong> A B-tree of height 2 containing over one billion keys. Shown inside each node <em>x</em> is <em>x</em>.<em>n</em>, the number of keys in <em>x</em>. Each internal node and leaf contains 1000 keys. This B-tree has 1001 nodes at depth 1 and over one million leaves at depth 2.</p>
</div>
<p>Large B-trees stored on disk drives often have branching factors between 50 and 2000, depending on the size of a key relative to the size of a block. A large branching factor dramatically reduces both the height of the tree and the number of disk accesses required to find any key. <a href="chapter018.xhtml#Fig_18-3">Figure 18.3</a> shows a B-tree with a branching factor of 1001 and height 2 that can store over one billion keys. Nevertheless, if the root node is kept permanently in main memory, at most two disk accesses suffice to find any key in this tree.</p>
<p class="line1"/>
<section title="18.1 Definition of B-trees">
<a id="Sec_18.1"/>
<p class="level1" id="h1-106"><a href="toc.xhtml#Rh1-106"><strong>18.1    Definition of B-trees</strong></a></p>
<p class="noindent">To keep things simple, let’s assume, as we have for binary search trees and red-black trees, that any satellite information associated with a key resides in the same node as the key. In practice, you might actually store with each key just a pointer to another disk block containing the satellite information for that key. The pseudocode in this chapter implicitly assumes that the satellite information associated with a key, or the pointer to such satellite information, travels with the key whenever the key is moved from node to node. A common variant on a B-tree, known as a <span class="blue"><strong><em>B</em><sup>+</sup>-<em>tree</em></strong></span>, stores all the satellite information in the leaves and stores only keys and child pointers in the internal nodes, thus maximizing the branching factor of the internal nodes.</p>
<p>A <span class="blue"><strong><em>B-tree</em></strong></span> <em>T</em> is a rooted tree with root <em>T</em>.<em>root</em> having the following properties:</p>
<a id="p502"/>
<ol class="olnoindent" epub:type="list">
<li>Every node <em>x</em> has the following attributes:
<p class="nl">a. <em>x</em>.<em>n</em>, the number of keys currently stored in node <em>x</em>,</p>
<p class="nl">b. the <em>x</em>.<em>n</em> keys themselves, <em>x</em>.<em>key</em><sub>1</sub>, <em>x</em>.<em>key</em><sub>2</sub>, … , <em>x</em>.<em>key</em><sub><em>x</em>.<em>n</em></sub>, stored in monotonically increasing order, so that <em>x</em>.<em>key</em><sub>1</sub> ≤ <em>x</em>.<em>key</em><sub>2</sub> ≤ <span class="font1">⋯</span> ≤ <em>x</em>.<em>key</em><sub><em>x</em>.<em>n</em></sub>,</p>
<p class="nl">c. <em>x</em>.<em>leaf</em>, a boolean value that is <small>TRUE</small> if <em>x</em> is a leaf and <small>FALSE</small> if <em>x</em> is an internal node.</p>
</li>
<li class="litop">Each internal node <em>x</em> also contains <em>x</em>.<em>n</em> + 1 pointers <em>x</em>.<em>c</em><sub>1</sub>, <em>x</em>.<em>c</em><sub>2</sub>, … , <em>x</em>.<em>c</em><sub><em>x</em>.<em>n</em>+1</sub> to its children. Leaf nodes have no children, and so their <em>c<sub>i</sub></em> attributes are undefined.</li>
<li class="litop">The keys <em>x</em>.<em>key<sub>i</sub></em> separate the ranges of keys stored in each subtree: if <em>k<sub>i</sub></em> is any key stored in the subtree with root <em>x</em>.<em>c<sub>i</sub></em>, then
<p class="eql"><em>k</em><sub>1</sub> ≤ <em>x</em>.<em>key</em><sub>1</sub> ≤ <em>k</em><sub>2</sub> ≤ <em>x</em>.<em>key</em><sub>2</sub> ≤ <span class="font1">⋯</span> ≤ <em>x</em>.<em>key</em><sub><em>x</em>.<em>n</em></sub> ≤ <em>k</em><sub><em>x</em>.<em>n</em>+1</sub>.</p>
</li>
<li class="litop">All leaves have the same depth, which is the tree’s height <em>h</em>.</li>
<li class="litop">Nodes have lower and upper bounds on the number of keys they can contain, expressed in terms of a fixed integer <em>t</em> ≥ 2 called the <span class="blue"><strong><em>minimum degree</em></strong></span> of the B-tree:
<p class="nl">a. Every node other than the root must have at least <em>t</em> − 1 keys. Every internal node other than the root thus has at least <em>t</em> children. If the tree is nonempty, the root must have at least one key.</p>
<p class="nl">b. Every node may contain at most 2<em>t</em> − 1 keys. Therefore, an internal node may have at most 2<em>t</em> children. We say that a node is <span class="blue"><strong><em>full</em></strong></span> if it contains exactly 2<em>t</em> − 1 keys.<sup><a epub:type="footnote" href="#footnote_3" id="footnote_ref_3">3</a></sup></p>
</li></ol>
<p>The simplest B-tree occurs when <em>t</em> = 2. Every internal node then has either 2, 3, or 4 children, and it is a <span class="blue"><strong><em>2-3-4 tree</em></strong></span>. In practice, however, much larger values of <em>t</em> yield B-trees with smaller height.</p>
<p class="level4"><strong>The height of a B-tree</strong></p>
<p class="noindent">The number of disk accesses required for most operations on a B-tree is proportional to the height of the B-tree. The following theorem bounds the worst-case height of a B-tree.</p>
<a id="p503"/>
<div class="divimage">
<p class="fig-imga" id="Fig_18-4"><img alt="art" class="width100" src="images/Art_P542.jpg"/></p>
<p class="caption"><strong>Figure 18.4</strong> A B-tree of height 3 containing a minimum possible number of keys. Shown inside each node <em>x</em> is <em>x</em>.<em>n</em>.</p>
</div>
<p class="theorem"><strong><em>Theorem 18.1</em></strong></p>
<p class="noindent">If <em>n</em> ≥ 1, then for any <em>n</em>-key B-tree <em>T</em> of height <em>h</em> and minimum degree <em>t</em> ≥ 2,</p>
<p class="eql"><img alt="art" src="images/Art_P543.jpg"/></p>
<p class="proof"><strong><em>Proof</em></strong>   By definition, the root of a nonempty B-tree <em>T</em> contains at least one key, and all other nodes contain at least <em>t</em> − 1 keys. Let <em>h</em> be the height of <em>T</em>. Then <em>T</em> contains at least 2 nodes at depth 1, at least 2<em>t</em> nodes at depth 2, at least 2<em>t</em><sub>2</sub> nodes at depth 3, and so on, until at depth <em>h</em>, it has at least 2<em>t</em><sup><em>h</em>−1</sup> nodes. <a href="chapter018.xhtml#Fig_18-4">Figure 18.4</a> illustrates such a tree for <em>h</em> = 3. The number <em>n</em> of keys therefore satisfies the inequality</p>
<p class="eql"><img alt="art" src="images/Art_P544.jpg"/></p>
<p class="noindent">so that <em>t<sup>h</sup></em> ≤ (<em>n</em> + 1)/2. Taking base-<em>t</em> logarithms of both sides proves the theorem.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">You can see the power of B-trees as compared with red-black trees. Although the height of the tree grows as <em>O</em>(log <em>n</em>) in both cases (recall that <em>t</em> is a constant), for B-trees the base of the logarithm can be many times larger. Thus, B-trees save <a id="p504"/>a factor of about lg <em>t</em> over red-black trees in the number of nodes examined for most tree operations. Because examining an arbitrary node in a tree usually entails accessing the disk, B-trees avoid a substantial number of disk accesses.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>18.1-1</em></strong></p>
<p class="noindent">Why isn’t a minimum degree of <em>t</em> = 1 allowed?</p>
<p class="level3"><strong><em>18.1-2</em></strong></p>
<p class="noindent">For what values of <em>t</em> is the tree of <a href="chapter018.xhtml#Fig_18-1">Figure 18.1</a> a legal B-tree?</p>
<p class="level3"><strong><em>18.1-3</em></strong></p>
<p class="noindent">Show all legal B-trees of minimum degree 2 that store the keys 1, 2, 3, 4, 5.</p>
<p class="level3"><strong><em>18.1-4</em></strong></p>
<p class="noindent">As a function of the minimum degree <em>t</em>, what is the maximum number of keys that can be stored in a B-tree of height <em>h</em>?</p>
<p class="level3"><strong><em>18.1-5</em></strong></p>
<p class="noindent">Describe the data structure that results if each black node in a red-black tree absorbs its red children, incorporating their children with its own.</p>
</section>
<p class="line1"/>
<section title="18.2 Basic operations on B-trees">
<a id="Sec_18.2"/>
<p class="level1" id="h1-107"><a href="toc.xhtml#Rh1-107"><strong>18.2    Basic operations on B-trees</strong></a></p>
<p class="noindent">This section presents the details of the operations B-T<small>REE</small>-S<small>EARCH</small>, B-T<small>REE</small>-C<small>REATE</small>, and B-T<small>REE</small>-I<small>NSERT</small>. These procedures observe two conventions:</p>
<ul class="ulnoindent" epub:type="list">
<li>The root of the B-tree is always in main memory, so that no procedure ever needs to perform a D<small>ISK</small>-R<small>EAD</small> on the root. If any changes to the root node occur, however, then D<small>ISK</small>-W<small>RITE</small> must be called on the root.</li>
<li class="litop">Any nodes that are passed as parameters must already have had a D<small>ISK</small>-R<small>EAD</small> operation performed on them.</li></ul>
<p class="noindent">The procedures are all “one-pass” algorithms that proceed downward from the root of the tree, without having to back up.</p>
<p class="level4"><strong>Searching a B-tree</strong></p>
<p class="noindent">Searching a B-tree is much like searching a binary search tree, except that instead of making a binary, or “two-way,” branching decision at each node, the search <a id="p505"/>makes a multiway branching decision according to the number of the node’s children. More precisely, at each internal node <em>x</em>, the search makes an (<em>x</em>.<em>n</em> + 1)-way branching decision.</p>
<p>The procedure B-T<small>REE</small>-S<small>EARCH</small> generalizes the T<small>REE</small>-S<small>EARCH</small> procedure defined for binary search trees on page 316. It takes as input a pointer to the root node <em>x</em> of a subtree and a key <em>k</em> to be searched for in that subtree. The top-level call is thus of the form B-T<small>REE</small>-S<small>EARCH</small>(<em>T</em>.<em>root</em>, <em>k</em>). If <em>k</em> is in the B-tree, then B-T<small>REE</small>-S<small>EARCH</small> returns the ordered pair (<em>y</em>, <em>i</em>) consisting of a node <em>y</em> and an index <em>i</em> such that <em>y</em>.<em>key<sub>i</sub></em> = <em>k</em>. Otherwise, the procedure returns <small>NIL</small>.</p>
<div class="pull-quote1">
<p class="box-heading">B-T<small>REE</small>-S<small>EARCH</small>(<em>x</em>, <em>k</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><em>i</em> = 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="noindent"><strong>while</strong> <em>i</em> ≤ <em>x</em>.<em>n</em> and <em>k &gt; x</em>.<em>key<sub>i</sub></em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p2"><em>i</em> = <em>i</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>i</em> ≤ <em>x</em>.<em>n</em> and <em>k</em> == <em>x</em>.<em>key<sub>i</sub></em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p2"><strong>return</strong> (<em>x</em>, <em>i</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><p class="noindent"><strong>elseif</strong> <em>x</em>.<em>leaf</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">7</span></td>
<td class="td1"><p class="p2"><strong>return</strong><small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">8</span></td>
<td class="td1"><p class="noindent"><strong>else</strong> D<small>ISK</small>-R<small>EAD</small>(<em>x</em>.<em>c<sub>i</sub></em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">9</span></td>
<td class="td1"><p class="p2"><strong>return</strong> B-T<small>REE</small>-S<small>EARCH</small>(<em>x</em>.<em>c<sub>i</sub></em>, <em>k</em>)</p></td>
</tr>
</table>
</div>
<p>Using a linear-search procedure, lines 1–3 of B-T<small>REE</small>-S<small>EARCH</small> find the smallest index <em>i</em> such that <em>k</em> ≤ <em>x</em>.<em>key<sub>i</sub></em>, or else they set <em>i</em> to <em>x</em>.<em>n</em> + 1. Lines 4–5 check to see whether the search has discovered the key, returning if it has. Otherwise, if <em>x</em> is a leaf, then line 7 terminates the search unsuccessfully, and if <em>x</em> is an internal node, lines 8–9 recurse to search the appropriate subtree of <em>x</em>, after performing the necessary D<small>ISK</small>-R<small>EAD</small> on that child. <a href="chapter018.xhtml#Fig_18-1">Figure 18.1</a> illustrates the operation of B-T<small>REE</small>-S<small>EARCH</small>. The blue nodes are those examined during a search for the key <em>R</em>.</p>
<p>As in the T<small>REE</small>-S<small>EARCH</small> procedure for binary search trees, the nodes encountered during the recursion form a simple path downward from the root of the tree. The B-T<small>REE</small>-S<small>EARCH</small> procedure therefore accesses <em>O</em>(<em>h</em>) = <em>O</em>(log<em><sub>t</sub> n</em>) disk blocks, where <em>h</em> is the height of the B-tree and <em>n</em> is the number of keys in the B-tree. Since <em>x</em>.<em>n</em> &lt; 2<em>t</em>, the <strong>while</strong> loop of lines 2–3 takes <em>O</em>(<em>t</em>) time within each node, and the total CPU time is <em>O</em>(<em>th</em>) = <em>O</em>(<em>t</em> log<em><sub>t</sub>n</em>).</p>
<p class="level4"><strong>Creating an empty B-tree</strong></p>
<p class="noindent">To build a B-tree <em>T</em>, first use the B-T<small>REE</small>-C<small>REATE</small> procedure on the next page to create an empty root node and then call the B-T<small>REE</small>-I<small>NSERT</small> procedure on <a id="p506"/>page 508 to add new keys. Both of these procedures use an auxiliary procedure A<small>LLOCATE</small>-N<small>ODE</small>, whose pseudocode we omit and which allocates one disk block to be used as a new node in <em>O</em>(1) time. A node created by A<small>LLOCATE</small>-N<small>ODE</small> requires no D<small>ISK</small>-R<small>EAD</small>, since there is as yet no useful information stored on the disk for that node. B-T<small>REE</small>-C<small>REATE</small> requires <em>O</em>(1) disk operations and <em>O</em>(1) CPU time.</p>
<div class="pull-quote1">
<p class="box-heading">B-T<small>REE</small>-C<small>REATE</small>(<em>T</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><em>x</em> = A<small>LLOCATE</small>-N<small>ODE</small>()</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="noindent"><em>x</em>.<em>leaf</em> = <small><small>TRUE</small></small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="noindent"><em>x</em>.<em>n</em> = 0</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="noindent">D<small>ISK</small>-W<small>RITE</small>(<em>x</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="noindent"><em>T</em>.<em>root</em> = <em>x</em></p></td>
</tr>
</table>
</div>
<p class="level4"><strong>Inserting a key into a B-tree</strong></p>
<p class="noindent">Inserting a key into a B-tree is significantly more complicated than inserting a key into a binary search tree. As with binary search trees, you search for the leaf position at which to insert the new key. With a B-tree, however, you cannot simply create a new leaf node and insert it, as the resulting tree would fail to be a valid B-tree. Instead, you insert the new key into an existing leaf node. Since you cannot insert a key into a leaf node that is full, you need an operation that <span class="blue"><strong><em>splits</em></strong></span> a full node <em>y</em> (having 2<em>t</em> − 1 keys) around its <span class="blue"><strong><em>median key</em></strong></span> <em>y</em>.<em>key<sub>t</sub></em> into two nodes having only <em>t</em> − 1 keys each. The median key moves up into <em>y</em>’s parent to identify the dividing point between the two new trees. But if <em>y</em>’s parent is also full, you must split it before you can insert the new key, and thus you could end up splitting full nodes all the way up the tree.</p>
<p>To avoid having to go back up the tree, just split every full node you encounter as you go down the tree. In this way, whenever you need to split a full node, you are assured that its parent is not full. Inserting a key into a B-tree then requires only a single pass down the tree from the root to a leaf.</p>
<p class="level4"><strong><em>Splitting a node in a B-tree</em></strong></p>
<p class="noindent">The procedure B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small> on the facing page takes as input a <em>nonfull</em> internal node <em>x</em> (assumed to reside in main memory) and an index <em>i</em> such that <em>x</em>.<em>c<sub>i</sub></em> (also assumed to reside in main memory) is a <em>full</em> child of <em>x</em>. The procedure splits this child in two and adjusts <em>x</em> so that it has an additional child. To split a full root, you first need to make the root a child of a new empty root node, so that you can <a id="p507"/>use B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small>. The tree thus grows in height by 1: splitting is the only means by which the tree grows taller.</p>
<div class="pull-quote1">
<p class="box-heading">B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small>(<em>x</em>, <em>i</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><p class="noindent"><em>y</em> = <em>x</em>.<em>c<sub>i</sub></em></p></td>
<td class="td1"><span class="red"><strong>//</strong> full node to split</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><p class="noindent"><em>z</em> = A<small>LLOCATE</small>-N<small>ODE</small>()</p></td>
<td class="td1"><span class="red"><strong>//</strong> <em>z</em> will take half of <em>y</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><p class="noindent"><em>z</em>.<em>leaf</em> = <em>y</em>.<em>leaf</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="noindent"><em>z</em>.<em>n</em> = <em>t</em> − 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>j</em> = 1 <strong>to</strong> <em>t</em> − 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> <em>z</em> gets <em>y</em>’s greatest keys …</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p2"><em>z</em>.<em>key<sub>j</sub></em> = <em>y</em>.<em>key</em><sub><em>j</em>+<em>t</em></sub></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><strong>if</strong> not <em>y</em>.<em>leaf</em></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="p2"><strong>for</strong> <em>j</em> = 1 <strong>to</strong> <em>t</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> … and its corresponding children</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="p3"><em>z</em>.<em>c<sub>j</sub></em> = <em>y</em>.<em>c</em><sub><em>j</em>+<em>t</em></sub></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="noindent"><em>y</em>.<em>n</em> = <em>t</em> − 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> <em>y</em> keeps <em>t</em> − 1 keys</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>j</em> = <em>x</em>.<em>n</em> + 1 <strong>downto</strong> <em>i</em> + 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> shift <em>x</em>’s children to the right …</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1"><p class="p2"><em>x</em>.<em>c</em><sub><em>j</em>+1</sub> = <em>x</em>.<em>c<sub>j</sub></em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1"><p class="noindent"><em>x</em>.<em>c</em><sub><em>i</em>+1</sub> = <em>z</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> … to make room for <em>z</em> as a child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">14</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>j</em> = <em>x</em>.<em>n</em><strong>downto</strong> <em>i</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> shift the corresponding keys in <em>x</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">15</span></td>
<td class="td1"><p class="p2"><em>x</em>.<em>key</em><sub><em>j</em>+1</sub> = <em>x</em>.<em>key<sub>j</sub></em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">16</span></td>
<td class="td1"><p class="noindent"><em>x</em>.<em>key<sub>i</sub></em> = <em>y</em>.<em>key<sub>t</sub></em></p></td>
<td class="td1"><span class="red"><strong>//</strong> insert <em>y</em>’s median key</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">17</span></td>
<td class="td1"><p class="noindent"><em>x</em>.<em>n</em> = <em>x</em>.<em>n</em> + 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> <em>x</em> has gained a child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">18</span></td>
<td class="td1"><p class="noindent">D<small>ISK</small>-W<small>RITE</small>(<em>y</em>)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">19</span></td>
<td class="td1"><p class="noindent">D<small>ISK</small>-W<small>RITE</small>(<em>z</em>)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">20</span></td>
<td class="td1"><p class="noindent">D<small>ISK</small>-W<small>RITE</small>(<em>x</em>)</p></td>
<td class="td1"/>
</tr>
</table>
</div>
<p><a href="chapter018.xhtml#Fig_18-5">Figure 18.5</a> illustrates how a node splits. B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small> splits the full node <em>y</em> = <em>x</em>.<em>c<sub>i</sub></em> about its median key (<em>S</em> in the figure), which moves up into <em>y</em>’s parent node <em>x</em>. Those keys in <em>y</em> that are greater than the median key move into a new node <em>z</em>, which becomes a new child of <em>x</em>.</p>
<p>B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small> works by straightforward cutting and pasting. Node <em>x</em> is the parent of the node <em>y</em> being split, which is <em>x</em>’s <em>i</em>th child (set in line 1). Node <em>y</em> originally has 2<em>t</em> children and 2<em>t</em> − 1 keys, but splitting reduces <em>y</em> to <em>t</em> children and <em>t</em> − 1 keys. The <em>t</em> largest children and <em>t</em> − 1 keys of node <em>y</em> move over to node <em>z</em>, which becomes a new child of <em>x</em>, positioned just after <em>y</em> in <em>x</em>’s table of children. The median key of <em>y</em> moves up to become the key in node <em>x</em> that separates the pointers to nodes <em>y</em> and <em>z</em>.</p>
<p>Lines 2–9 create node <em>z</em> and give it the largest <em>t</em> − 1 keys and, if <em>y</em> and <em>z</em> are internal nodes, the corresponding <em>t</em> children of <em>y</em>. Line 10 adjusts the key count for <em>y</em>. Then, lines 11–17 shift keys and child pointers in <em>x</em> to the right in order to make room for <em>x</em>’s new child, insert <em>z</em> as a new child of <em>x</em>, move the median key <a id="p508"/>from <em>y</em> up to <em>x</em> in order to separate <em>y</em> from <em>z</em>, and adjust <em>x</em>’s key count. Lines 18–20 write out all modified disk blocks. The CPU time used by B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small> is Θ(<em>t</em>), due to the <strong>for</strong> loops in lines 5–6 and 8–9. (The <strong>for</strong> loops in lines 11–12 and 14–15 also run for <em>O</em>(<em>t</em>) iterations.) The procedure performs <em>O</em>(1) disk operations.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_18-5"><img alt="art" src="images/Art_P545.jpg"/></p>
<p class="caption"><strong>Figure 18.5</strong> Splitting a node with <em>t</em> = 4. Node <em>y</em> = <em>x</em>.<em>c<sub>i</sub></em> splits into two nodes, <em>y</em> and <em>z</em>, and the median key <em>S</em> of <em>y</em> moves up into <em>y</em>’s parent.</p>
</div>
<p class="level4"><strong><em>Inserting a key into a B-tree in a single pass down the tree</em></strong></p>
<p class="noindent">Inserting a key <em>k</em> into a B-tree <em>T</em> of height <em>h</em> requires just a single pass down the tree and <em>O</em>(<em>h</em>) disk accesses. The CPU time required is <em>O</em>(<em>th</em>) = <em>O</em>(<em>t</em> log<em><sub>t</sub> n</em>). The B-T<small>REE</small>-I<small>NSERT</small> procedure uses B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small> to guarantee that the recursion never descends to a full node. If the root is full, B-T<small>REE</small>-I<small>NSERT</small> splits it by calling the procedure B-T<small>REE</small>-S<small>PLIT</small>-R<small>OOT</small> on the facing page.</p>
<div class="pull-quote1">
<p class="box-heading">B-T<small>REE</small>-I<small>NSERT</small>(<em>T</em>, <em>k</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><em>r</em> = <em>T</em>.<em>root</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>r</em>.<em>n</em> == 2<em>t</em> − 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p2"><em>s</em> = B-T<small>REE</small>-S<small>PLIT</small>-R<small>OOT</small>(<em>T</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2">B-T<small>REE</small>-I<small>NSERT</small>-N<small>ONFULL</small>(<em>s</em>, <em>k</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="noindent"><strong>else</strong> B-T<small>REE</small>-I<small>NSERT</small>-N<small>ONFULL</small>(<em>r</em>, <em>k</em>)</p></td>
</tr>
</table>
</div>
<p>B-T<small>REE</small>-I<small>NSERT</small> works as follows. If the root is full, then line 3 calls B-T<small>REE</small>-S<small>PLIT</small>-R<small>OOT</small> in line 3 to split it. A new node <em>s</em> (with two children) becomes the root and is returned by B-T<small>REE</small>-S<small>PLIT</small>-R<small>OOT</small>. Splitting the root, illustrated in <a href="chapter018.xhtml#Fig_18-6">Figure 18.6</a>, is the only way to increase the height of a B-tree. Unlike a binary search tree, a B-tree increases in height at the top instead of at the bottom. Regardless of whether the root split, B-T<small>REE</small>-I<small>NSERT</small> finishes by calling B-T<small>REE</small>-I<small>NSERT</small>-N<small>ONFULL</small> to insert key <em>k</em> into the tree rooted at the nonfull root node, <a id="p509"/>which is either the new root (the call in line 4) or the original root (the call in line 5).</p>
<div class="divimage">
<p class="fig-imga" id="Fig_18-6"><img alt="art" src="images/Art_P546.jpg"/></p>
<p class="caption"><strong>Figure 18.6</strong> Splitting the root with <em>t</em> = 4. Root node <em>r</em> splits in two, and a new root node <em>s</em> is created. The new root contains the median key of <em>r</em> and has the two halves of <em>r</em> as children. The B-tree grows in height by one when the root is split. A B-tree’s height increases only when the root splits.</p>
</div>
<div class="pull-quote1">
<p class="box-heading">B-T<small>REE</small>-S<small>PLIT</small>-R<small>OOT</small>(<em>T</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><em>s</em> = A<small>LLOCATE</small>-N<small>ODE</small>()</td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><em>s</em>.<em>leaf</em> = <small>FALSE</small></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><em>s</em>.<em>n</em> = 0</td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><em>s</em>.<em>c</em><sub>1</sub> = <em>T</em>.<em>root</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><em>T</em>.<em>root</em> = <em>s</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1">B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small>(<em>s</em>, 1)</td>
</tr>
<tr>
<td class="td1"><span class="x-small">7</span></td>
<td class="td1"><strong>return</strong> <em>s</em></td>
</tr>
</table>
</div>
<p>The auxiliary procedure B-T<small>REE</small>-I<small>NSERT</small>-N<small>ONFULL</small> on page 511 inserts key <em>k</em> into node <em>x</em>, which is assumed to be nonfull when the procedure is called. B-T<small>REE</small>I<small>NSERT</small>-N<small>ONFULL</small> recurses as necessary down the tree, at all times guaranteeing that the node to which it recurses is not full by calling B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small> as necessary. The operation of B-T<small>REE</small>-I<small>NSERT</small> and the recursive operation of B-T<small>REE</small>-I<small>NSERT</small>-N<small>ONFULL</small> guarantee that this assumption is true.</p>
<p><a href="chapter018.xhtml#Fig_18-7">Figure 18.7</a> illustrates the various cases of how B-T<small>REE</small>-I<small>NSERT</small>-N<small>ONFULL</small> inserts a key into a B-tree. Lines 3–8 handle the case in which <em>x</em> is a leaf node by inserting key <em>k</em> into <em>x</em>, shifting to the right all keys in <em>x</em> that are greater than <em>k</em>. If <em>x</em> is not a leaf node, then <em>k</em> should go into the appropriate leaf node in the subtree rooted at internal node <em>x</em>. Lines 9–11 determine the child <em>x</em>.<em>c<sub>i</sub></em> to which the recursion descends. Line 13 detects whether the recursion would descend to a full child, in which case line 14 calls B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small> to split that child into two nonfull <a id="p510"/>children, and lines 15–16 determine which of the two children is the correct one to descend to. (Note that D<small>ISK</small>-R<small>EAD</small>(<em>x</em>.<em>c<sub>i</sub></em>) is not needed after line 16 increments <em>i</em>, since the recursion descends in this case to a child that was just created by B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small>.) The net effect of lines 13–16 is thus to guarantee that the procedure never recurses to a full node. Line 17 then recurses to insert <em>k</em> into the appropriate subtree.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_18-7"><img alt="art" src="images/Art_P547.jpg"/></p>
<p class="caption"><strong>Figure 18.7</strong> Inserting keys into a B-tree. The minimum degree <em>t</em> for this B-tree is 3, so that a node can hold at most 5 keys. Blue nodes are modified by the insertion process. <strong>(a)</strong> The initial tree for this example. <strong>(b)</strong> The result of inserting <em>B</em> into the initial tree. This case is a simple insertion into a leaf node. <strong>(c)</strong> The result of inserting <em>Q</em> into the previous tree. The node <em>RST U V</em> splits into two nodes containing <em>RS</em> and <em>U V</em>, the key <em>T</em> moves up to the root, and <em>Q</em> is inserted in the leftmost of the two halves (the <em>RS</em> node). <strong>(d)</strong> The result of inserting <em>L</em> into the previous tree. The root splits right away, since it is full, and the B-tree grows in height by one. Then <em>L</em> is inserted into the leaf containing <em>JK</em>. <strong>(e)</strong> The result of inserting <em>F</em> into the previous tree. The node <em>ABCDE</em> splits before <em>F</em> is inserted into the rightmost of the two halves (the <em>DE</em> node).</p>
</div>
<a id="p511"/>
<div class="pull-quote1">
<p class="box-heading">B-T<small>REE</small>-I<small>NSERT</small>-N<small>ONFULL</small>(<em>x</em>, <em>k</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><p class="noindent"><em>i</em> = <em>x</em>.<em>n</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>x</em>.<em>leaf</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> inserting into a leaf?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><p class="p2"><strong>while</strong> <em>i</em> ≥ 1 and <em>k</em> &lt; <em>x</em>.<em>key<sub>i</sub></em></p></td>
<td class="td1"><span class="red"><strong>//</strong> shift keys in <em>x</em> to make room for <em>k</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p3"><em>x</em>.<em>key</em><sub><em>i</em>+1</sub> = <em>x</em>.<em>key<sub>i</sub></em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="p3"><em>i</em> = <em>i</em> − 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p2"><em>x</em>.<em>key</em><sub><em>i</em>+1</sub> = <em>k</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> insert key <em>k</em> in <em>x</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p2"><em>x</em>.<em>n</em> = <em>x</em>.<em>n</em> + 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> now <em>x</em> has 1 more key</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="p2">D<small>ISK</small>-W<small>RITE</small>(<em>x</em>)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="noindent"><strong>else while</strong> <em>i</em> ≥ 1 and <em>k</em> &lt; <em>x</em>.<em>key<sub>i</sub></em></p></td>
<td class="td1"><span class="red"><strong>//</strong> find the child where <em>k</em> belongs</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1" colspan="2"><p class="p3"><em>i</em> = <em>i</em> − 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1" colspan="2"><p class="p2"><em>i</em> = <em>i</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1" colspan="2"><p class="p2">D<small>ISK</small>-R<small>EAD</small>(<em>x</em>.<em>c<sub>i</sub></em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>x</em>.<em>c<sub>i</sub></em>.<em>n</em> == 2<em>t</em> − 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> split the child if it’s full</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">14</span></td>
<td class="td1" colspan="2"><p class="p3">B-T<small>REE</small>-S<small>PLIT</small>-C<small>HILD</small>(<em>x</em>, <em>i</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">15</span></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>k &gt; x</em>.<em>key<sub>i</sub></em></p></td>
<td class="td1"><span class="red"><strong>//</strong> does <em>k</em> go into <em>x</em>.<em>c<sub>i</sub></em> or <em>x</em>.<em>c</em><sub><em>i</em>+1</sub>?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">16</span></td>
<td class="td1"><p class="p4"><em>i</em> = <em>i</em> + 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">17</span></td>
<td class="td1" colspan="2"><p class="p2">B-T<small>REE</small>-I<small>NSERT</small>-N<small>ONFULL</small>(<em>x</em>.<em>c<sub>i</sub></em>, <em>k</em>)</p></td>
</tr>
</table>
</div>
<p>For a B-tree of height <em>h</em>, B-T<small>REE</small>-I<small>NSERT</small> performs <em>O</em>(<em>h</em>) disk accesses, since only <em>O</em>(1) D<small>ISK</small>-R<small>EAD</small> and D<small>ISK</small>-W<small>RITE</small> operations occur at each level of the tree. The total CPU time used is <em>O</em>(<em>t</em>) in each level of the tree, or <em>O</em>(<em>th</em>) = <em>O</em>(<em>t</em> log<em><sub>t</sub> n</em>) overall. Since B-T<small>REE</small>-I<small>NSERT</small>-N<small>ONFULL</small> is tail-recursive, you can instead implement it with a <strong>while</strong> loop, thereby demonstrating that the number of blocks that need to be in main memory at any time is <em>O</em>(1).</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>18.2-1</em></strong></p>
<p class="noindent">Show the results of inserting the keys</p>
<p class="noindent1-top"><em>F</em>, <em>S</em>, <em>Q</em>, <em>K</em>, <em>C</em>, <em>L</em>, <em>H</em>, <em>T</em>, <em>V</em>, <em>W</em>, <em>M</em>, <em>R</em>, <em>N</em>, <em>P</em>, <em>A</em>, <em>B</em>, <em>X</em>, <em>Y</em>, <em>D</em>, <em>Z</em>, <em>E</em></p>
<a id="p512"/>
<p class="noindent">in order into an empty B-tree with minimum degree 2. Draw only the configurations of the tree just before some node must split, and also draw the final configuration.</p>
<p class="level3"><strong><em>18.2-2</em></strong></p>
<p class="noindent">Explain under what circumstances, if any, redundant D<small>ISK</small>-R<small>EAD</small> or D<small>ISK</small>-W<small>RITE</small> operations occur during the course of executing a call to B-T<small>REE</small>-I<small>NSERT</small>. (A redundant D<small>ISK</small>-R<small>EAD</small> is a D<small>ISK</small>-R<small>EAD</small> for a block that is already in memory. A redundant D<small>ISK</small>-W<small>RITE</small> writes to disk a block of information that is identical to what is already stored there.)</p>
<p class="level3"><strong><em>18.2-3</em></strong></p>
<p class="noindent">Professor Bunyan asserts that the B-T<small>REE</small>-I<small>NSERT</small> procedure always results in a B-tree with the minimum possible height. Show that the professor is mistaken by proving that with <em>t</em> = 2 and the set of keys {1, 2, … , 15}, there is no insertion sequence that results in a B-tree with the minimum possible height.</p>
<p class="level3"><span class="font1">★</span> <strong><em>18.2-4</em></strong></p>
<p class="noindent">If you insert the keys {1, 2, … , <em>n</em>} into an empty B-tree with minimum degree 2, how many nodes does the final B-tree have?</p>
<p class="level3"><strong><em>18.2-5</em></strong></p>
<p class="noindent">Since leaf nodes require no pointers to children, they could conceivably use a different (larger) <em>t</em> value than internal nodes for the same disk block size. Show how to modify the procedures for creating and inserting into a B-tree to handle this variation.</p>
<p class="level3"><strong><em>18.2-6</em></strong></p>
<p class="noindent">Suppose that you implement B-T<small>REE</small>-S<small>EARCH</small> to use binary search rather than linear search within each node. Show that this change makes the required CPU time <em>O</em>(lg <em>n</em>), independent of how <em>t</em> might be chosen as a function of <em>n</em>.</p>
<p class="level3"><strong><em>18.2-7</em></strong></p>
<p class="noindent">Suppose that disk hardware allows you to choose the size of a disk block arbitrarily, but that the time it takes to read the disk block is <em>a</em>+<em>bt</em>, where <em>a</em> and <em>b</em> are specified constants and <em>t</em> is the minimum degree for a B-tree using blocks of the selected size. Describe how to choose <em>t</em> so as to minimize (approximately) the B-tree search time. Suggest an optimal value of <em>t</em> for the case in which <em>a</em> = 5 milliseconds and <em>b</em> = 10 microseconds.</p>
<a id="p513"/>
</section>
<p class="line1"/>
<section title="18.3 Deleting a key from a B-tree">
<a id="Sec_18.3"/>
<p class="level1" id="h1-108"><a href="toc.xhtml#Rh1-108"><strong>18.3    Deleting a key from a B-tree</strong></a></p>
<p class="noindent">Deletion from a B-tree is analogous to insertion but a little more complicated, because you can delete a key from any node—not just a leaf—and when you delete a key from an internal node, you must rearrange the node’s children. As in insertion, you must guard against deletion producing a tree whose structure violates the B-tree properties. Just as a node should not get too big due to insertion, a node must not get too small during deletion (except that the root is allowed to have fewer than the minimum number <em>t</em> − 1 of keys). And just as a simple insertion algorithm might have to back up if a node on the path to where the key is to be inserted is full, a simple approach to deletion might have to back up if a node (other than the root) along the path to where the key is to be deleted has the minimum number of keys.</p>
<p>The procedure B-T<small>REE</small>-D<small>ELETE</small> deletes the key <em>k</em> from the subtree rooted at <em>x</em>. Unlike the procedures T<small>REE</small>-D<small>ELETE</small> on page 325 and RB-D<small>ELETE</small> on page 348, which are given the node to delete—presumably as the result of a prior search—B-T<small>REE</small>-D<small>ELETE</small> combines the search for key <em>k</em> with the deletion process. Why do we combine search and deletion in B-T<small>REE</small>-D<small>ELETE</small>? Just as B-T<small>REE</small>-I<small>NSERT</small> prevents any node from becoming overfull (having more than 2<em>t</em> − 1 keys) while making a single pass down the tree, B-T<small>REE</small>-D<small>ELETE</small> prevents any node from becoming underfull (having fewer than <em>t</em> − 1 keys) while also making a single pass down the tree, searching for and ultimately deleting the key.</p>
<p>To prevent any node from becoming underfull, the design of B-T<small>REE</small>-D<small>ELETE</small> guarantees that whenever it calls itself recursively on a node <em>x</em>, the number of keys in <em>x</em> is at least the minimum degree <em>t</em> at the time of the call. (Although the root may have fewer than <em>t</em> keys and a recursive call may be made <em>from</em> the root, no recursive call is made <em>on</em> the root.) This condition requires one more key than the minimum required by the usual B-tree conditions, and so a key might have to be moved from <em>x</em> into one of its child nodes (still leaving <em>x</em> with at least the minimum <em>t</em> − 1 keys) before a recursive call is made on that child, thus allowing deletion to occur in one downward pass without having to traverse back up the tree.</p>
<p>We describe how the procedure B-T<small>REE</small>-D<small>ELETE</small>(<em>T</em>, <em>k</em>) deletes a key <em>k</em> from a B-tree <em>T</em> instead of presenting detailed pseudocode. We examine three cases, illustrated in <a href="chapter018.xhtml#Fig_18-8">Figure 18.8</a>. The cases are for when the search arrives at a leaf, at an internal node containing key <em>k</em>, and at an internal node not containing key <em>k</em>. As mentioned above, in all three cases node <em>x</em> has at least <em>t</em> keys (with the possible exception of when <em>x</em> is the root). Cases 2 and 3—when <em>x</em> is an internal node—guarantee this property as the recursion descends through the B-tree.</p>
<a id="p514"/>
<div class="divimage">
<p class="fig-imga" id="Fig_18-8"><img alt="art" src="images/Art_P548.jpg"/></p>
<p class="fig-imga"><img alt="art" src="images/Art_P549.jpg"/></p>
<p class="caption"><strong>Figure 18.8</strong> Deleting keys from a B-tree. The minimum degree for this B-tree is <em>t</em> = 3, so that, other than the root, every node must have at least 2 keys. Blue nodes are those that are modified by the deletion process. <strong>(a)</strong> The B-tree of <a href="chapter018.xhtml#Fig_18-7">Figure 18.7(e)</a>. <strong>(b)</strong> Deletion of <em>F</em>, which is case 1: simple deletion from a leaf when all nodes visited during the search (other than the root) have at least <em>t</em> = 3 keys. <strong>(c)</strong> Deletion of <em>M</em>, which is case 2a: the predecessor <em>L</em> of <em>M</em> moves up to take <em>M</em>’s position. <strong>(d)</strong> Deletion of <em>G</em>, which is case 2c: push <em>G</em> down to make node <em>DEGJK</em> and then delete <em>G</em> from this leaf (case 1). <strong>(e)</strong> Deletion of <em>D</em>, which is case 3b: since the recursion cannot descend to node <em>CL</em> because it has only 2 keys, push <em>P</em> down and merge it with <em>CL</em> and <em>TX</em> to form <em>CLP TX</em>. Then delete <em>D</em> from a leaf (case 1). <strong>(e</strong><sup>0</sup><strong>)</strong> After (e), delete the empty root. The tree shrinks in height by 1. <strong>(f)</strong> Deletion of <em>B</em>, which is case 3a: <em>C</em> moves to fill <em>B</em>’s position and <em>E</em> moves to fill <em>C</em>’s position.</p>
</div>
<p class="para-hang1"><strong><em>Case 1:</em></strong> <em>The search arrives at a leaf node x.</em> If <em>x</em> contains key <em>k</em>, then delete <em>k</em> from <em>x</em>. If <em>x</em> does not contain key <em>k</em>, then <em>k</em> was not in the B-tree and nothing else needs to be done.</p>
<p class="para-hang1"><strong><em>Case 2:</em></strong> <em>The search arrives at an internal node x that contains key k.</em> Let <em>k</em> = <em>x</em>.<em>key<sub>i</sub></em>. One of the following three cases applies, depending on the number of keys in <em>x</em>.<em>c<sub>i</sub></em> (the child of <em>x</em> that precedes <em>k</em>) and <em>x</em>.<em>c</em><sub><em>i</em>+1</sub> (the child of <em>x</em> that follows <em>k</em>).</p>
<p class="php"><strong><em>Case 2a:</em></strong> <em>x</em>.<em>c<sub>i</sub> has at least t keys.</em> Find the predecessor <em>k</em>′ of <em>k</em> in the subtree rooted at <em>x</em>.<em>c<sub>i</sub></em>. Recursively delete <em>k</em>′ from <em>x</em>.<em>c<sub>i</sub></em>, and replace <em>k</em> by <em>k</em>′ in <em>x</em>. (Key <em>k</em>′ can be found and deleted in a single downward pass.)</p>
<p class="php"><strong><em>Case 2b:</em></strong> <em>x</em>.<em>c<sub>i</sub> has t</em> − 1 <em>keys and x</em>.<em>c</em><sub><em>i</em>+1</sub><em>has at least t keys.</em> This case is symmetric to case 2a. Find the successor <em>k</em>′ of <em>k</em> in the subtree rooted at <em>x</em>.<em>c</em><sub><em>i</em>+1</sub>. <a id="p515"/>Recursively delete <em>k</em>′ from <em>x</em>.<em>c</em><sub><em>i</em>+1</sub>, and replace <em>k</em> by <em>k</em>′ in <em>x</em>. (Again, finding and deleting <em>k</em>′ can be done in a single downward pass.)</p>
<p class="php"><strong><em>Case 2c</em>:</strong> <em>Both x</em>.<em>c<sub>i</sub> and x</em>.<em>c</em><sub><em>i</em>+1</sub><em>have t − 1 keys.</em> Merge <em>k</em> and all of <em>x</em>.<em>c</em><sub><em>i</em>+1</sub> into <em>x</em>.<em>c<sub>i</sub></em>, so that <em>x</em> loses both <em>k</em> and the pointer to <em>x</em>.<em>c</em><sub><em>i</em>+1</sub>, and <em>x</em>.<em>c<sub>i</sub></em> now contains 2<em>t</em> − 1 keys. Then free <em>x</em>.<em>c</em><sub><em>i</em>+1</sub> and recursively delete <em>k</em> from <em>x</em>.<em>c<sub>i</sub></em>.</p>
<p class="para-hang1"><strong><em>Case 3</em>:</strong> <em>The search arrives at an internal node x that does not contain key k.</em> Continue searching down the tree while ensuring that each node visited has at least <em>t</em> keys. To do so, determine the root <em>x</em>.<em>c<sub>i</sub></em> of the appropriate subtree that must contain <em>k</em>, if <em>k</em> is in the tree at all. If <em>x</em>.<em>c<sub>i</sub></em> has only <em>t</em> − 1 keys, execute <a id="p516"/>case 3a or 3b as necessary to guarantee descending to a node containing at least <em>t</em> keys. Then finish by recursing on the appropriate child of <em>x</em>.</p>
<p class="php"><strong><em>Case 3a</em>:</strong> <em>x</em>.<em>c<sub>i</sub> has only t</em> − 1 <em>keys but has an immediate sibling with at least t keys.</em> Give <em>x</em>.<em>c<sub>i</sub></em> an extra key by moving a key from <em>x</em> down into <em>x</em>.<em>c<sub>i</sub></em>, moving a key from <em>x</em>.<em>c<sub>i</sub></em>’s immediate left or right sibling up into <em>x</em>, and moving the appropriate child pointer from the sibling into <em>x</em>.<em>c<sub>i</sub></em>.</p>
<p class="php"><strong><em>Case 3b</em>:</strong> <em>x</em>.<em>c<sub>i</sub> and each of x</em>.<em>c<sub>i</sub>’s immediate siblings have t</em> − 1 <em>keys.</em> (It is possible for <em>x</em>.<em>c<sub>i</sub></em> to have either one or two siblings.) Merge <em>x</em>.<em>c<sub>i</sub></em> with one sibling, which involves moving a key from <em>x</em> down into the new merged node to become the median key for that node.</p>
<p class="space-break">In cases 2c and 3b, if node <em>x</em> is the root, it could end up having no keys. When this situation occurs, then <em>x</em> is deleted, and <em>x</em>’s only child <em>x</em>.<em>c</em><sub>1</sub> becomes the new root of the tree. This action decreases the height of the tree by one and preserves the property that the root of the tree contains at least one key (unless the tree is empty).</p>
<p>Since most of the keys in a B-tree are in the leaves, deletion operations often end up deleting keys from leaves. The B-T<small>REE</small>-D<small>ELETE</small> procedure then acts in one downward pass through the tree, without having to back up. When deleting a key in an internal node <em>x</em>, however, the procedure might make a downward pass through the tree to find the key’s predecessor or successor and then return to node <em>x</em> to replace the key with its predecessor or successor (cases 2a and 2b). Returning to node <em>x</em> does not require a traversal through all the levels between <em>x</em> and the node containing the predecessor or successor, however, since the procedure can just keep a pointer to <em>x</em> and the key position within <em>x</em> and put the predecessor or successor key directly there.</p>
<p>Although this procedure seems complicated, it involves only <em>O</em>(<em>h</em>) disk operations for a B-tree of height <em>h</em>, since only <em>O</em>(1) calls to D<small>ISK</small>-R<small>EAD</small> and D<small>ISK</small>-W<small>RITE</small> are made between recursive invocations of the procedure. The CPU time required is <em>O</em>(<em>th</em>) = <em>O</em>(<em>t</em> log<sub><em>t</em></sub><em>n</em>).</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>18.3-1</em></strong></p>
<p class="noindent">Show the results of deleting <em>C</em>, <em>P</em>, and <em>V</em>, in order, from the tree of <a href="chapter018.xhtml#Fig_18-8">Figure 18.8(f)</a>.</p>
<p class="level3"><strong><em>18.3-2</em></strong></p>
<p class="noindent">Write pseudocode for B-T<small>REE</small>-D<small>ELETE</small>.</p>
<a id="p517"/>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-109"><strong>Problems</strong></p>
<section title="18-1 Stacks on secondary storage">
<p class="level2"><strong><em>18-1     Stacks on secondary storage</em></strong></p>
<p class="noindent">Consider implementing a stack in a computer that has a relatively small amount of fast primary memory and a relatively large amount of slower disk storage. The operations P<small>USH</small> and P<small>OP</small> work on single-word values. The stack can grow to be much larger than can fit in memory, and thus most of it must be stored on disk.</p>
<p>A simple, but inefficient, stack implementation keeps the entire stack on disk. Maintain in memory a stack pointer, which is the disk address of the top element on the stack. Indexing block numbers and word offsets within blocks from 0, if the pointer has value <em>p</em>, the top element is the (<em>p</em> mod <em>m</em>)th word on block <span class="font1">⌊</span><em>p</em>/<em>m</em><span class="font1">⌋</span> of the disk, where <em>m</em> is the number of words per block.</p>
<p>To implement the P<small>USH</small> operation, increment the stack pointer, read the appropriate block into memory from disk, copy the element to be pushed to the appropriate word on the block, and write the block back to disk. A P<small>OP</small> operation is similar. Read in the appropriate block from disk, save the top of the stack, decrement the stack pointer, and return the saved value. You need not write back the block, since it was not modified, and the word in the block that contained the popped value is ignored.</p>
<p>As in the analyses of B-tree operations, two costs matter: the total number of disk accesses and the total CPU time. A disk access also incurs a cost in CPU time. In particular, any disk access to a block of <em>m</em> words incurs charges of one disk access and Θ(<em>m</em>) CPU time.</p>
<p class="nl"><strong><em>a.</em></strong> Asymptotically, what is the worst-case number of disk accesses for <em>n</em> stack operations using this simple implementation? What is the CPU time for <em>n</em> stack operations? Express your answer in terms of <em>m</em> and <em>n</em> for this and subsequent parts.</p>
<p class="noindent1-top">Now consider a stack implementation in which you keep one block of the stack in memory. (You also maintain a small amount of memory to record which block is currently in memory.) You can perform a stack operation only if the relevant disk block resides in memory. If necessary, you can write the block currently in memory to the disk and read the new block from the disk into memory. If the relevant disk block is already in memory, then no disk accesses are required.</p>
<p class="nl"><strong><em>b.</em></strong> What is the worst-case number of disk accesses required for <em>n</em> P<small>USH</small> operations? What is the CPU time?</p>
<p class="nl"><strong><em>c.</em></strong> What is the worst-case number of disk accesses required for <em>n</em> stack operations? What is the CPU time?</p>
<a id="p518"/>
<p class="noindent1-top">Suppose that you now implement the stack by keeping two blocks in memory (in addition to a small number of words for bookkeeping).</p>
<p class="nl"><strong><em>d.</em></strong> Describe how to manage the stack blocks so that the amortized number of disk accesses for any stack operation is <em>O</em>(1/<em>m</em>) and the amortized CPU time for any stack operation is <em>O</em>(1).</p>
</section>
<section title="18-2 Joining and splitting 2-3-4 trees">
<p class="level2"><strong><em>18-2     Joining and splitting 2-3-4 trees</em></strong></p>
<p class="noindent">The <span class="blue"><strong><em>join</em></strong></span> operation takes two dynamic sets <em>S</em>′ and <em>S</em>″ and an element <em>x</em> such that <em>x</em>′.<em>key &lt; x</em>.<em>key &lt; x</em>″.<em>key</em> for any <em>x</em>′ ∈ <em>S</em>′ and <em>x</em>″ ∈ <em>S</em>″. It returns a set <em>S</em> = <em>S</em>′ ∪ {<em>x</em>} ∪ <em>S</em>″. The <span class="blue"><strong><em>split</em></strong></span> operation is like an “inverse” join: given a dynamic set <em>S</em> and an element <em>x</em> ∈ <em>S</em>, it creates a set <em>S</em>′ that consists of all elements in <em>S</em> − {<em>x</em>} whose keys are less than <em>x</em>.<em>key</em> and another set <em>S</em>″ that consists of all elements in <em>S</em> − {<em>x</em>} whose keys are greater than <em>x</em>.<em>key</em>. This problem investigates how to implement these operations on 2-3-4 trees (B-trees with <em>t</em> = 2). Assume for convenience that elements consist only of keys and that all key values are distinct.</p>
<p class="nl"><strong><em>a.</em></strong> Show how to maintain, for every node <em>x</em> of a 2-3-4 tree, the height of the subtree rooted at <em>x</em> as an attribute <em>x</em>.<em>height</em>. Make sure that your implementation does not affect the asymptotic running times of searching, insertion, and deletion.</p>
<p class="nl"><strong><em>b.</em></strong> Show how to implement the join operation. Given two 2-3-4 trees <em>T</em>′ and <em>T</em>″ and a key <em>k</em>, the join operation should run in <em>O</em>(1 + |<em>h</em>′ − <em>h</em>″|) time, where <em>h</em>′ and <em>h</em>″ are the heights of <em>T</em>′ and <em>T</em>″, respectively.</p>
<p class="nl"><strong><em>c.</em></strong> Consider the simple path <em>p</em> from the root of a 2-3-4 tree <em>T</em> to a given key <em>k</em>, the set <em>S</em>′ of keys in <em>T</em> that are less than <em>k</em>, and the set <em>S</em>″ of keys in <em>T</em> that are greater than <em>k</em>. Show that <em>p</em> breaks <em>S</em>′ into a set of trees <img alt="art" src="images/Art_P550.jpg"/> and a set of keys <img alt="art" src="images/Art_P551.jpg"/> such that <img alt="art" src="images/Art_P552.jpg"/> for <em>i</em> = 1, 2, … , <em>m</em> and any keys <img alt="art" src="images/Art_P553.jpg"/> and <img alt="art" src="images/Art_P554.jpg"/>. What is the relationship between the heights of <img alt="art" src="images/Art_P555.jpg"/> and <img alt="art" src="images/Art_P556.jpg"/>? Describe how <em>p</em> breaks <em>S</em>″ into sets of trees and keys.</p>
<p class="nl"><strong><em>d.</em></strong> Show how to implement the split operation on <em>T</em>. Use the join operation to assemble the keys in <em>S</em>′ into a single 2-3-4 tree <em>T</em>′ and the keys in <em>S</em>″ into a single 2-3-4 tree <em>T</em>″. The running time of the split operation should be <em>O</em>(lg <em>n</em>), where <em>n</em> is the number of keys in <em>T</em>. (<em>Hint</em>: The costs for joining should telescope.)</p>
<a id="p519"/>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-110"><strong>Chapter notes</strong></p>
<p class="noindent">Knuth [<a epub:type="noteref" href="bibliography001.xhtml#endnote_261">261</a>], Aho, Hopcroft, and Ullman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_5">5</a>], and Sedgewick and Wayne [<a epub:type="noteref" href="bibliography001.xhtml#endnote_402">402</a>] give further discussions of balanced-tree schemes and B-trees. Comer [<a epub:type="noteref" href="bibliography001.xhtml#endnote_99">99</a>] provides a comprehensive survey of B-trees. Guibas and Sedgewick [<a epub:type="noteref" href="bibliography001.xhtml#endnote_202">202</a>] discuss the relationships among various kinds of balanced-tree schemes, including red-black trees and 2-3-4 trees.</p>
<p>In 1970, J. E. Hopcroft invented 2-3 trees, a precursor to B-trees and 2-3-4 trees, in which every internal node has either two or three children. Bayer and McCreight [<a epub:type="noteref" href="bibliography001.xhtml#endnote_39">39</a>] introduced B-trees in 1972 with no explanation of their choice of name.</p>
<p>Bender, Demaine, and Farach-Colton [<a epub:type="noteref" href="bibliography001.xhtml#endnote_47">47</a>] studied how to make B-trees perform well in the presence of memory-hierarchy effects. Their <span class="blue"><strong><em>cache-oblivious</em></strong></span> algorithms work efficiently without explicitly knowing the data transfer sizes within the memory hierarchy.</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> When specifying disk capacities, one terabyte is one trillion bytes, rather than 2<sub>40</sub> bytes.</p>
<p class="footnote1" id="footnote_2"><a href="#footnote_ref_2"><sup>2</sup></a> SSDs also exhibit greater latency than main memory and access data in blocks.</p>
<p class="footnote1" id="footnote_3"><a href="#footnote_ref_3"><sup>3</sup></a> Another common variant on a B-tree, known as a <span class="blue"><strong><em>B</em><sup>*</sup>-<em>tree</em></strong></span>, requires each internal node to be at least 2/3 full, rather than at least half full, as a B-tree requires.</p>
</section>
</section>
</div>
</body>
</html>