<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p182"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="7 Quicksort">
<p class="chapter-title"><a href="toc.xhtml#chap-7"><strong><span class="blue1">7          Quicksort</span></strong></a></p>
<p class="noindent">The quicksort algorithm has a worst-case running time of Θ(<em>n</em><sup>2</sup>) on an input array of <em>n</em> numbers. Despite this slow worst-case running time, quicksort is often the best practical choice for sorting because it is remarkably efficient on average: its expected running time is Θ(<em>n</em> lg <em>n</em>) when all numbers are distinct, and the constant factors hidden in the Θ(<em>n</em> lg <em>n</em>) notation are small. Unlike merge sort, it also has the advantage of sorting in place (see page 158), and it works well even in virtual-memory environments.</p>
<p>Our study of quicksort is broken into four sections. <a href="chapter007.xhtml#Sec_7.1">Section 7.1</a> describes the algorithm and an important subroutine used by quicksort for partitioning. Because the behavior of quicksort is complex, we’ll start with an intuitive discussion of its performance in <a href="chapter007.xhtml#Sec_7.2">Section 7.2</a> and analyze it precisely at the end of the chapter. <a href="chapter007.xhtml#Sec_7.3">Section 7.3</a> presents a randomized version of quicksort. When all elements are distinct,<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup> this randomized algorithm has a good expected running time and no particular input elicits its worst-case behavior. (See Problem 7-2 for the case in which elements may be equal.) <a href="chapter007.xhtml#Sec_7.4">Section 7.4</a> analyzes the randomized algorithm, showing that it runs in Θ(<em>n</em><sup>2</sup>) time in the worst case and, assuming distinct elements, in expected <em>O</em>(<em>n</em> lg <em>n</em>) time.</p>
<a id="p183"/>
<p class="line1"/>
<section title="7.1 Description of quicksort">
<a id="Sec_7.1"/>
<p class="level1" id="h1-39"><a href="toc.xhtml#Rh1-39"><strong>7.1      Description of quicksort</strong></a></p>
<p class="noindent">Quicksort, like merge sort, applies the divide-and-conquer method introduced in <a href="chapter002.xhtml#Sec_2.3.1">Section 2.3.1</a>. Here is the three-step divide-and-conquer process for sorting a subarray <em>A</em>[<em>p</em> : <em>r</em>]:</p>
<p class="para-hang1"><strong>Divide</strong> by partitioning (rearranging) the array <em>A</em>[<em>p</em> : <em>r</em>] into two (possibly empty) subarrays <em>A</em>[<em>p</em> : <em>q</em> – 1] (the <strong><em><span class="blue1">low side</span></em></strong>) and <em>A</em>[<em>q</em> + 1 : <em>r</em>] (the <strong><em><span class="blue1">high side</span></em></strong>) such that each element in the low side of the partition is less than or equal to the <strong><em><span class="blue1">pivot</span></em></strong> <em>A</em>[<em>q</em>], which is, in turn, less than or equal to each element in the high side. Compute the index <em>q</em> of the pivot as part of this partitioning procedure.</p>
<p class="para-hang1"><strong>Conquer</strong> by calling quicksort recursively to sort each of the subarrays <em>A</em>[<em>p</em> : <em>q</em> – 1] and <em>A</em>[<em>q</em> + 1 : <em>r</em>].</p>
<p class="para-hang1"><strong>Combine</strong> by doing nothing: because the two subarrays are already sorted, no work is needed to combine them. All elements in <em>A</em>[<em>p</em> : <em>q</em> – 1] are sorted and less than or equal to <em>A</em>[<em>q</em>], and all elements in <em>A</em>[<em>q</em> + 1 : <em>r</em>] are sorted and greater than or equal to the pivot <em>A</em>[<em>q</em>]. The entire subarray <em>A</em>[<em>p</em> : <em>r</em>] cannot help but be sorted!</p>
<p class="space-break">The Q<small>UICKSORT</small> procedure implements quicksort. To sort an entire <em>n</em>-element array <em>A</em>[1 : <em>n</em>], the initial call is Q<small>UICKSORT</small> (<em>A</em>, 1, <em>n</em>).</p>
<div class="pull-quote1">
<p class="box-heading">Q<small>UICKSORT</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p>
<table class="table1a">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>if</strong> <em>p</em> &lt; <em>r</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1" colspan="2"><p class="p2"><span class="red"><strong>//</strong> Partition the subarray around the pivot, which ends up in <em>A</em>[<em>q</em>].</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1" colspan="2"><p class="p2"><em>q</em> = P<small>ARTITION</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2">Q<small>UICKSORT</small>(<em>A</em>, <em>p</em>, <em>q</em> – 1)</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> recursively sort the low side</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p2">Q<small>UICKSORT</small>(<em>A</em>, <em>q</em> + 1, <em>r</em>)</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> recursively sort the high side</span></p></td>
</tr>
</table>
</div>
<p class="level4"><strong>Partitioning the array</strong></p>
<p class="noindent">The key to the algorithm is the P<small>ARTITION</small> procedure on the next page, which rearranges the subarray <em>A</em>[<em>p</em> : <em>r</em>] in place, returning the index of the dividing point between the two sides of the partition.</p>
<p><a href="chapter007.xhtml#Fig_7-1">Figure 7.1</a> shows how P<small>ARTITION</small> works on an 8-element array. P<small>ARTITION</small> always selects the element <em>x</em> = <em>A</em>[<em>r</em>] as the pivot. As the procedure runs, each element falls into exactly one of four regions, some of which may be empty. At the start of each iteration of the <strong>for</strong> loop in lines 3–6, the regions satisfy certain properties, shown in <a href="chapter007.xhtml#Fig_7-2">Figure 7.2</a>. We state these properties as a loop invariant:</p>
<a id="p184"/>
<div class="pull-quote1">
<p class="box-heading">P<small>ARTITION</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>x</em> = <em>A</em>[<em>r</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> the pivot</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><em>i</em> = <em>p</em> – 1</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> highest index into the low side</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>j</em> = <em>p</em> <strong>to</strong> <em>r</em> – 1</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> process each element other than the pivot</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>A</em>[<em>j</em>] ≤ <em>x</em></p></td>
<td class="td1"><p class="p2"><span class="red"><strong>//</strong> does this element belong on the low side?</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p3"><em>i</em> = <em>i</em> + 1</p></td>
<td class="td1"><p class="p2"><span class="red"><strong>//</strong> index of a new slot in the low side</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="p3">exchange <em>A</em>[<em>i</em>] with <em>A</em>[<em>j</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> put this element there</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1"><p class="noindent">exchange <em>A</em>[<em>i</em> + 1] with <em>A</em>[<em>r</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> pivot goes just to the right of the low side</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">8</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>i</em> + 1</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> new index of the pivot</span></p></td>
</tr>
</table>
</div>
<div class="pull-quote">
<p class="pq-noindent">At the beginning of each iteration of the loop of lines 3–6, for any array index <em>k</em>, the following conditions hold:</p>
<ol class="olnoindent" epub:type="list">
<li>if <em>p</em> ≤ <em>k</em> ≤ <em>i</em>, then <em>A</em>[<em>k</em>] ≤ <em>x</em> (the tan region of <a href="chapter007.xhtml#Fig_7-2">Figure 7.2</a>);</li>
<li class="litop">if <em>i</em> + 1 ≤ <em>k</em> ≤ <em>j</em> – 1, then <em>A</em>[<em>k</em>] &gt; <em>x</em> (the blue region);</li>
<li class="litop">if <em>k</em> = <em>r</em>, then <em>A</em>[<em>k</em>] = <em>x</em> (the yellow region).</li></ol>
</div>
<p>We need to show that this loop invariant is true prior to the first iteration, that each iteration of the loop maintains the invariant, that the loop terminates, and that correctness follows from the invariant when the loop terminates.</p>
<p class="para-hang1"><strong>Initialization:</strong> Prior to the first iteration of the loop, we have <em>i</em> = <em>p</em> – 1 and <em>j</em> = <em>p</em>. Because no values lie between <em>p</em> and <em>i</em> and no values lie between <em>i</em> + 1 and <em>j</em> – 1, the first two conditions of the loop invariant are trivially satisfied. The assignment in line 1 satisfies the third condition.</p>
<p class="para-hang1"><strong>Maintenance:</strong> As <a href="chapter007.xhtml#Fig_7-3">Figure 7.3</a> shows, we consider two cases, depending on the outcome of the test in line 4. <a href="chapter007.xhtml#Fig_7-3">Figure 7.3(a)</a> shows what happens when <em>A</em>[<em>j</em>] &gt; <em>x</em>: the only action in the loop is to increment <em>j</em>. After <em>j</em> has been incremented, the second condition holds for <em>A</em>[<em>j</em> – 1] and all other entries remain unchanged. <a href="chapter007.xhtml#Fig_7-3">Figure 7.3(b)</a> shows what happens when <em>A</em>[<em>j</em>] ≤ <em>x</em>: the loop increments <em>i</em>, swaps <em>A</em>[<em>i</em>] and <em>A</em>[<em>j</em>], and then increments <em>j</em>. Because of the swap, we now have that <em>A</em>[<em>i</em>] ≤ <em>x</em>, and condition 1 is satisfied. Similarly, we also have that <em>A</em>[<em>j</em> – 1] &gt; <em>x</em>, since the item that was swapped into <em>A</em>[<em>j</em> – 1] is, by the loop invariant, greater than <em>x</em>.</p>
<p class="para-hang1"><strong>Termination:</strong> Since the loop makes exactly <em>r</em> – <em>p</em> iterations, it terminates, whereupon <em>j</em> = <em>r</em>. At that point, the unexamined subarray <em>A</em>[<em>j</em> : <em>r</em> – 1] is empty, and every entry in the array belongs to one of the other three sets described by the invariant. Thus, the values in the array have been partitioned into three sets: those less than or equal to <em>x</em> (the low side), those greater than <em>x</em> (the high side), and a singleton set containing <em>x</em> (the pivot).</p>
<a id="p185"/>
<div class="divimage">
<p class="fig-imga" id="Fig_7-1"><img alt="art" src="images/Art_P309.jpg"/></p>
<p class="caption"><strong>Figure 7.1</strong> The operation of P<small>ARTITION</small> on a sample array. Array entry <em>A</em>[<em>r</em>] becomes the pivot element <em>x</em>. Tan array elements all belong to the low side of the partition, with values at most <em>x</em>. Blue elements belong to the high side, with values greater than <em>x</em>. White elements have not yet been put into either side of the partition, and the yellow element is the pivot <em>x</em>. <strong>(a)</strong> The initial array and variable settings. None of the elements have been placed into either side of the partition. <strong>(b)</strong> The value 2 is “swapped with itself” and put into the low side. <strong>(c)–(d)</strong> The values 8 and 7 are placed into to high side. <strong>(e)</strong> The values 1 and 8 are swapped, and the low side grows. <strong>(f)</strong> The values 3 and 7 are swapped, and the low side grows. <strong>(g)–(h)</strong> The high side of the partition grows to include 5 and 6, and the loop terminates. <strong>(i)</strong> Line 7 swaps the pivot element so that it lies between the two sides of the partition, and line 8 returns the pivot’s new index.</p>
</div>
<p>The final two lines of P<small>ARTITION</small> finish up by swapping the pivot with the leftmost element greater than <em>x</em>, thereby moving the pivot into its correct place in the partitioned array, and then returning the pivot’s new index. The output of P<small>ARTITION</small> now satisfies the specifications given for the divide step. In fact, it satisfies a slightly stronger condition: after line 3 of Q<small>UICKSORT</small>, <em>A</em>[<em>q</em>] is strictly less than every element of <em>A</em>[<em>q</em> + 1 : <em>r</em>].</p>
<a id="p186"/>
<div class="divimage">
<p class="fig-imga" id="Fig_7-2"><img alt="art" src="images/Art_P310.jpg"/></p>
<p class="caption"><strong>Figure 7.2</strong> The four regions maintained by the procedure P<small>ARTITION</small> on a subarray <em>A</em>[<em>p</em> : <em>r</em>]. The tan values in <em>A</em>[<em>p</em> : <em>i</em>] are all less than or equal to <em>x</em>, the blue values in <em>A</em>[<em>i</em> + 1 : <em>j</em> – 1] are all greater than <em>x</em>, the white values in <em>A</em>[<em>j</em> : <em>r</em> – 1] have unknown relationships to <em>x</em>, and <em>A</em>[<em>r</em>] = <em>x</em>.</p>
</div>
<p class="block"/>
<div class="divimage">
<p class="fig-imga" id="Fig_7-3"><img alt="art" src="images/Art_P311.jpg"/></p>
<p class="caption"><strong>Figure 7.3</strong> The two cases for one iteration of procedure P<small>ARTITION</small>. <strong>(a)</strong> If <em>A</em>[<em>j</em>] &gt; <em>x</em>, the only action is to increment <em>j</em>, which maintains the loop invariant. <strong>(b)</strong> If <em>A</em>[<em>j</em>] ≤ <em>x</em>, index <em>i</em> is incremented, <em>A</em>[<em>i</em>] and <em>A</em>[<em>j</em>] are swapped, and then <em>j</em> is incremented. Again, the loop invariant is maintained.</p>
</div>
<p>Exercise 7.1-3 asks you to show that the running time of P<small>ARTITION</small> on a subarray <em>A</em>[<em>p</em> : <em>r</em>] of <em>n</em> = <em>r</em> – <em>p</em> + 1 elements is Θ(<em>n</em>).</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>7.1-1</em></strong></p>
<p class="noindent">Using <a href="chapter007.xhtml#Fig_7-1">Figure 7.1</a> as a model, illustrate the operation of P<small>ARTITION</small> on the array <em>A</em> = <span class="font1">〈</span>13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11<span class="font1">〉</span>.</p>
<a id="p187"/>
<p class="level3"><strong><em>7.1-2</em></strong></p>
<p class="noindent">What value of <em>q</em> does P<small>ARTITION</small> return when all elements in the subarray <em>A</em>[<em>p</em> : <em>r</em>] have the same value? Modify P<small>ARTITION</small> so that <em>q</em> = <span class="font1">⌊</span>(<em>p</em> + <em>r</em>)/2<span class="font1">⌋</span> when all elements in the subarray <em>A</em>[<em>p</em> : <em>r</em>] have the same value.</p>
<p class="level3"><strong><em>7.1-3</em></strong></p>
<p class="noindent">Give a brief argument that the running time of P<small>ARTITION</small> on a subarray of size <em>n</em> is Θ(<em>n</em>).</p>
<p class="level3"><strong><em>7.1-4</em></strong></p>
<p class="noindent">Modify Q<small>UICKSORT</small> to sort into monotonically decreasing order.</p>
</section>
<p class="line1"/>
<section title="7.2 Performance of quicksort">
<a id="Sec_7.2"/>
<p class="level1" id="h1-40"><a href="toc.xhtml#Rh1-40"><strong>7.2      Performance of quicksort</strong></a></p>
<p class="noindent">The running time of quicksort depends on how balanced each partitioning is, which in turn depends on which elements are used as pivots. If the two sides of a partition are about the same size—the partitioning is balanced—then the algorithm runs asymptotically as fast as merge sort. If the partitioning is unbalanced, however, it can run asymptotically as slowly as insertion sort. To allow you to gain some intuition before diving into a formal analysis, this section informally investigates how quicksort performs under the assumptions of balanced versus unbalanced partitioning.</p>
<p>But first, let’s briefly look at the maximum amount of memory that quicksort requires. Although quicksort sorts in place according to the definition on page 158, the amount of memory it uses—aside from the array being sorted—is not constant. Since each recursive call requires a constant amount of space on the runtime stack, outside of the array being sorted, quicksort requires space proportional to the maximum depth of the recursion. As we’ll see now, that could be as bad as Θ(<em>n</em>) in the worst case.</p>
<p class="level4"><strong>Worst-case partitioning</strong></p>
<p class="noindent">The worst-case behavior for quicksort occurs when the partitioning produces one subproblem with <em>n</em> – 1 elements and one with 0 elements. (See <a href="chapter007.xhtml#Sec_7.4.1">Section 7.4.1</a>.) Let us assume that this unbalanced partitioning arises in each recursive call. The partitioning costs Θ(<em>n</em>) time. Since the recursive call on an array of size 0 just returns without doing anything, <em>T</em> (0) = Θ(1), and the recurrence for the running time is</p>
<a id="p188"/>
<table class="table2b">
<tr>
<td class="td2"><em>T</em> (<em>n</em>)</td>
<td class="td2m">=</td>
<td class="td2"><em>T</em> (<em>n</em> – 1) + <em>T</em> (0) + Θ(<em>n</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2m">=</td>
<td class="td2"><em>T</em> (<em>n</em> – 1) + Θ(<em>n</em>).</td>
</tr>
</table>
<p class="noindent">By summing the costs incurred at each level of the recursion, we obtain an arithmetic series (equation (A.3) on page 1141), which evaluates to Θ(<em>n</em><sup>2</sup>). Indeed, the substitution method can be used to prove that the recurrence <em>T</em> (<em>n</em>) = <em>T</em> (<em>n</em> – 1) + Θ(<em>n</em>) has the solution <em>T</em> (<em>n</em>) = Θ(<em>n</em><sup>2</sup>). (See Exercise 7.2-1.)</p>
<p>Thus, if the partitioning is maximally unbalanced at every recursive level of the algorithm, the running time is Θ(<em>n</em><sup>2</sup>). The worst-case running time of quicksort is therefore no better than that of insertion sort. Moreover, the Θ(<em>n</em><sup>2</sup>) running time occurs when the input array is already completely sorted—a situation in which insertion sort runs in <em>O</em>(<em>n</em>) time.</p>
<p class="level4"><strong>Best-case partitioning</strong></p>
<p class="noindent">In the most even possible split, P<small>ARTITION</small> produces two subproblems, each of size no more than <em>n</em>/2, since one is of size <span class="font1">⌊</span>(<em>n</em> – 1)/2<span class="font1">⌋</span> ≤ <em>n</em>/2 and one of size <span class="font1">⌈</span>(<em>n</em> – 1)/2<span class="font1">⌉</span> – 1 ≤ <em>n</em>/2. In this case, quicksort runs much faster. An upper bound on the running time can then be described by the recurrence</p>
<p class="eql"><em>T</em> (<em>n</em>) = 2<em>T</em> (<em>n</em>/2) + Θ(<em>n</em>).</p>
<p class="noindent">By case 2 of the master theorem (Theorem 4.1 on page 102), this recurrence has the solution <em>T</em> (<em>n</em>) = Θ(<em>n</em> lg <em>n</em>). Thus, if the partitioning is equally balanced at every level of the recursion, an asymptotically faster algorithm results.</p>
<p class="level4"><strong>Balanced partitioning</strong></p>
<p class="noindent">As the analyses in <a href="chapter007.xhtml#Sec_7.4">Section 7.4</a> will show, the average-case running time of quicksort is much closer to the best case than to the worst case. By appreciating how the balance of the partitioning affects the recurrence describing the running time, we can gain an understanding of why.</p>
<p>Suppose, for example, that the partitioning algorithm always produces a 9-to-1 proportional split, which at first blush seems quite unbalanced. We then obtain the recurrence</p>
<p class="eql"><em>T</em> (<em>n</em>) = <em>T</em> (9<em>n</em>/10) + <em>T</em> (<em>n</em>/10) + Θ(<em>n</em>),</p>
<p class="noindent">on the running time of quicksort. <a href="chapter007.xhtml#Fig_7-4">Figure 7.4</a> shows the recursion tree for this recurrence, where for simplicity the Θ(<em>n</em>) driving function has been replaced by <em>n</em>, which won’t affect the asymptotic solution of the recurrence (as Exercise 4.7-1 on page 118 justifies). Every level of the tree has cost <em>n</em>, until the recursion bottoms out in a base case at depth log<sub>10</sub> <em>n</em> = Θ(lg <em>n</em>), and then the levels have cost <a id="p189"/>at most <em>n</em>. The recursion terminates at depth log<sub>10/9</sub> <em>n</em> = Θ(lg <em>n</em>). Thus, with a 9-to-1 proportional split at every level of recursion, which intuitively seems highly unbalanced, quicksort runs in <em>O</em>(<em>n</em> lg <em>n</em>) time—asymptotically the same as if the split were right down the middle. Indeed, even a 99-to-1 split yields an <em>O</em>(<em>n</em> lg <em>n</em>) running time. In fact, any split of <em>constant</em> proportionality yields a recursion tree of depth Θ(lg <em>n</em>), where the cost at each level is <em>O</em>(<em>n</em>). The running time is therefore <em>O</em>(<em>n</em> lg <em>n</em>) whenever the split has constant proportionality. The ratio of the split affects only the constant hidden in the <em>O</em>-notation.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_7-4"><img alt="art" src="images/Art_P312.jpg"/></p>
<p class="caption"><strong>Figure 7.4</strong> A recursion tree for Q<small>UICKSORT</small> in which P<small>ARTITION</small> always produces a 9-to-1 split, yielding a running time of <em>O</em>(<em>n</em> lg <em>n</em>). Nodes show subproblem sizes, with per-level costs on the right.</p>
</div>
<p class="level4"><strong>Intuition for the average case</strong></p>
<p class="noindent">To develop a clear notion of the expected behavior of quicksort, we must assume something about how its inputs are distributed. Because quicksort determines the sorted order using only comparisons between input elements, its behavior depends on the relative ordering of the values in the array elements given as the input, not on the particular values in the array. As in the probabilistic analysis of the hiring problem in <a href="chapter005.xhtml#Sec_5.2">Section 5.2</a>, assume that all permutations of the input numbers are equally likely and that the elements are distinct.</p>
<p>When quicksort runs on a random input array, the partitioning is highly unlikely to happen in the same way at every level, as our informal analysis has assumed. <a id="p190"/>We expect that some of the splits will be reasonably well balanced and that some will be fairly unbalanced. For example, Exercise 7.2-6 asks you to show that about 80% of the time P<small>ARTITION</small> produces a split that is at least as balanced as 9 to 1, and about 20% of the time it produces a split that is less balanced than 9 to 1.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_7-5"><img alt="art" src="images/Art_P313.jpg"/></p>
<p class="caption"><strong>Figure 7.5 (a)</strong> Two levels of a recursion tree for quicksort. The partitioning at the root costs <em>n</em> and produces a “bad” split: two subarrays of sizes 0 and <em>n</em> – 1. The partitioning of the subarray of size <em>n</em> – 1 costs <em>n</em> – 1 and produces a “good” split: subarrays of size (<em>n</em> – 1)/2 – 1 and (<em>n</em> – 1)/2. <strong>(b)</strong> A single level of a recursion tree that is well balanced. In both parts, the partitioning cost for the subproblems shown with blue shading is Θ(<em>n</em>). Yet the subproblems remaining to be solved in (a), shown with tan shading, are no larger than the corresponding subproblems remaining to be solved in (b).</p>
</div>
<p>In the average case, P<small>ARTITION</small> produces a mix of “good” and “bad” splits. In a recursion tree for an average-case execution of P<small>ARTITION</small>, the good and bad splits are distributed randomly throughout the tree. Suppose for the sake of intuition that the good and bad splits alternate levels in the tree, and that the good splits are best-case splits and the bad splits are worst-case splits. <a href="chapter007.xhtml#Fig_7-5">Figure 7.5(a)</a> shows the splits at two consecutive levels in the recursion tree. At the root of the tree, the cost is <em>n</em> for partitioning, and the subarrays produced have sizes <em>n</em> – 1 and 0: the worst case. At the next level, the subarray of size <em>n</em> – 1 undergoes best-case partitioning into subarrays of size (<em>n</em> – 1)/2 – 1 and (<em>n</em> – 1)/2. Let’s assume that the base-case cost is 1 for the subarray of size 0.</p>
<p>The combination of the bad split followed by the good split produces three subarrays of sizes 0, (<em>n</em> – 1)/2 – 1, and (<em>n</em> – 1)/2 at a combined partitioning cost of Θ(<em>n</em>) + Θ(<em>n</em> – 1) = Θ(<em>n</em>). This situation is at most a constant factor worse than that in <a href="chapter007.xhtml#Fig_7-5">Figure 7.5(b)</a>, namely, where a single level of partitioning produces two subarrays of size (<em>n</em> – 1)/2, at a cost of Θ(<em>n</em>). Yet this latter situation is balanced! Intuitively, the Θ(<em>n</em> – 1) cost of the bad split in <a href="chapter007.xhtml#Fig_7-5">Figure 7.5(a)</a> can be absorbed into the Θ(<em>n</em>) cost of the good split, and the resulting split is good. Thus, the running time of quicksort, when levels alternate between good and bad splits, is like the running time for good splits alone: still <em>O</em>(<em>n</em> lg <em>n</em>), but with a slightly larger constant hidden by the <em>O</em>-notation. We’ll analyze the expected running time of a randomized version of quicksort rigorously in <a href="chapter007.xhtml#Sec_7.4.2">Section 7.4.2</a>.</p>
<a id="p191"/>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>7.2-1</em></strong></p>
<p class="noindent">Use the substitution method to prove that the recurrence <em>T</em> (<em>n</em>) = <em>T</em> (<em>n</em> – 1) + Θ(<em>n</em>) has the solution <em>T</em> (<em>n</em>) = Θ(<em>n</em><sup>2</sup>), as claimed at the beginning of <a href="chapter007.xhtml#Sec_7.2">Section 7.2</a>.</p>
<p class="level3"><strong><em>7.2-2</em></strong></p>
<p class="noindent">What is the running time of Q<small>UICKSORT</small> when all elements of array <em>A</em> have the same value?</p>
<p class="level3"><strong><em>7.2-3</em></strong></p>
<p class="noindent">Show that the running time of Q<small>UICKSORT</small> is Θ(<em>n</em><sup>2</sup>) when the array <em>A</em> contains distinct elements and is sorted in decreasing order.</p>
<p class="level3"><strong><em>7.2-4</em></strong></p>
<p class="noindent">Banks often record transactions on an account in order of the times of the transactions, but many people like to receive their bank statements with checks listed in order by check number. People usually write checks in order by check number, and merchants usually cash them with reasonable dispatch. The problem of converting time-of-transaction ordering to check-number ordering is therefore the problem of sorting almost-sorted input. Explain persuasively why the procedure I<small>NSERTION</small>-S<small>ORT</small> might tend to beat the procedure Q<small>UICKSORT</small> on this problem.</p>
<p class="level3"><strong><em>7.2-5</em></strong></p>
<p class="noindent">Suppose that the splits at every level of quicksort are in the constant proportion <em>α</em> to <em>β</em>, where <em>α</em> + <em>β</em> = 1 and 0 &lt; <em>α</em> ≤ <em>β</em> &lt; 1. Show that the minimum depth of a leaf in the recursion tree is approximately log<sub>1/<em>α</em></sub> <em>n</em> and that the maximum depth is approximately log<sub>1/<em>β</em></sub> <em>n</em>. (Don’t worry about integer round-off.)</p>
<p class="level3"><strong><em>7.2-6</em></strong></p>
<p class="noindent">Consider an array with distinct elements and for which all permutations of the elements are equally likely. Argue that for any constant 0 &lt; <em>α</em> ≤ 1/2, the probability is approximately 1 – 2<em>α</em> that P<small>ARTITION</small> produces a split at least as balanced as 1 – <em>α</em> to <em>α</em>.</p>
</section>
<p class="line1"/>
<section title="7.3 A randomized version of quicksort">
<a id="Sec_7.3"/>
<p class="level1" id="h1-41"><a href="toc.xhtml#Rh1-41"><strong>7.3      A randomized version of quicksort</strong></a></p>
<p class="noindent">In exploring the average-case behavior of quicksort, we have assumed that all permutations of the input numbers are equally likely. This assumption does not always hold, however, as, for example, in the situation laid out in the premise for <a id="p192"/>Exercise 7.2-4. <a href="chapter005.xhtml#Sec_5.3">Section 5.3</a> showed that judicious randomization can sometimes be added to an algorithm to obtain good expected performance over all inputs. For quicksort, randomization yields a fast and practical algorithm. Many software libraries provide a randomized version of quicksort as their algorithm of choice for sorting large data sets.</p>
<p>In <a href="chapter005.xhtml#Sec_5.3">Section 5.3</a>, the R<small>ANDOMIZED</small>-H<small>IRE</small>-A<small>SSISTANT</small> procedure explicitly permutes its input and then runs the deterministic H<small>IRE</small>-A<small>SSISTANT</small> procedure. We could do the same for quicksort as well, but a different randomization technique yields a simpler analysis. Instead of always using <em>A</em>[<em>r</em>] as the pivot, a randomized version randomly chooses the pivot from the subarray <em>A</em>[<em>p</em> : <em>r</em>], where each element in <em>A</em>[<em>p</em> : <em>r</em>] has an equal probability of being chosen. It then exchanges that element with <em>A</em>[<em>r</em>] before partitioning. Because the pivot is chosen randomly, we expect the split of the input array to be reasonably well balanced on average.</p>
<p>The changes to P<small>ARTITION</small> and Q<small>UICKSORT</small> are small. The new partitioning procedure, R<small>ANDOMIZED</small>-P<small>ARTITION</small>, simply swaps before performing the partitioning. The new quicksort procedure, R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>, calls R<small>ANDOMIZED</small>-P<small>ARTITION</small> instead of P<small>ARTITION</small>. We’ll analyze this algorithm in the next section.</p>
<div class="pull-quote1">
<p class="box-heading">R<small>ANDOMIZED</small>-P<small>ARTITION</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>i</em> = R<small>ANDOM</small>(<em>p</em>, <em>r</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent">exchange <em>A</em>[<em>r</em>] with <em>A</em>[<em>i</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> P<small>ARTITION</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p></td>
</tr>
</table>
<p class="box-headinga">R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>p</em> &lt; <em>r</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><em>q</em> = R<small>ANDOMIZED</small>-P<small>ARTITION</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2">R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>(<em>A</em>, <em>p</em>, <em>q</em> – 1)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2">R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>(<em>A</em>, <em>q</em> + 1, <em>r</em>)</p></td>
</tr>
</table>
</div>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>7.3-1</em></strong></p>
<p class="noindent">Why do we analyze the expected running time of a randomized algorithm and not its worst-case running time?</p>
<a id="p193"/>
<p class="level3"><strong><em>7.3-2</em></strong></p>
<p class="noindent">When R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> runs, how many calls are made to the random-number generator R<small>ANDOM</small> in the worst case? How about in the best case? Give your answer in terms of Θ-notation.</p>
</section>
<p class="line1"/>
<section title="7.4 Analysis of quicksort">
<a id="Sec_7.4"/>
<p class="level1" id="h1-42"><a href="toc.xhtml#Rh1-42"><strong>7.4      Analysis of quicksort</strong></a></p>
<p class="noindent"><a href="chapter007.xhtml#Sec_7.2">Section 7.2</a> gave some intuition for the worst-case behavior of quicksort and for why we expect the algorithm to run quickly. This section analyzes the behavior of quicksort more rigorously. We begin with a worst-case analysis, which applies to either Q<small>UICKSORT</small> or R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>, and conclude with an analysis of the expected running time of R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>.</p>
<section title="7.4.1 Worst-case analysis">
<p class="level2" id="Sec_7.4.1"><strong>7.4.1    Worst-case analysis</strong></p>
<p class="noindent">We saw in <a href="chapter007.xhtml#Sec_7.2">Section 7.2</a> that a worst-case split at every level of recursion in quicksort produces a Θ(<em>n</em><sup>2</sup>) running time, which, intuitively, is the worst-case running time of the algorithm. We now prove this assertion.</p>
<p>We’ll use the substitution method (see <a href="chapter004.xhtml#Sec_4.3">Section 4.3</a>) to show that the running time of quicksort is <em>O</em>(<em>n</em><sup>2</sup>). Let <em>T</em> (<em>n</em>) be the worst-case time for the procedure Q<small>UICKSORT</small> on an input of size <em>n</em>. Because the procedure P<small>ARTITION</small> produces two subproblems with total size <em>n</em> – 1, we obtain the recurrence</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P314.jpg"/></p>
<p class="noindent">We guess that <em>T</em> (<em>n</em>) ≤ <em>cn</em><sup>2</sup> for some constant <em>c</em> &gt; 0. Substituting this guess into recurrence (7.1) yields</p>
<table class="table2b">
<tr>
<td class="td2"><em>T</em> (<em>n</em>)</td>
<td class="td2">≤</td>
<td class="td2">max {<em>cq</em><sup>2</sup> + <em>c</em>(<em>n</em> – 1 – <em>q</em>)<sup>2</sup> : 0 ≤ <em>q</em> ≤ <em>n</em> – 1} + Θ(<em>n</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2m">=</td>
<td class="td2"><em>c</em> · max {<em>q</em><sup>2</sup> + (<em>n</em> – 1 – <em>q</em>)<sup>2</sup> : 0 ≤ <em>q</em> ≤ <em>n</em> – 1} + Θ(<em>n</em>).</td>
</tr>
</table>
<p>Let’s focus our attention on the maximization. For <em>q</em> = 0, 1, … , <em>n</em> – 1, we have</p>
<table class="table2b">
<tr>
<td class="td2"><em>q</em><sup>2</sup> + (<em>n</em> – 1 – <em>q</em>)<sup>2</sup></td>
<td class="td2m">=</td>
<td class="td2"><em>q</em><sup>2</sup> + (<em>n</em> – 1)<sup>2</sup> – 2<em>q</em>(<em>n</em> – 1) + <em>q</em><sup>2</sup></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2m">=</td>
<td class="td2">(<em>n</em> – 1)<sup>2</sup> + 2<em>q</em>(<em>q</em> – (<em>n</em> – 1))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2">(<em>n</em> – 1)<sup>2</sup></td>
</tr>
</table>
<p class="noindent">because <em>q</em> ≤ <em>n</em> – 1 implies that 2<em>q</em>(<em>q</em> – (<em>n</em> – 1)) ≤ 0. Thus every term in the maximization is bounded by (<em>n</em> – 1)<sup>2</sup>.</p>
<p>Continuing with our analysis of <em>T</em> (<em>n</em>), we obtain</p>
<a id="p194"/>
<table class="table2b">
<tr>
<td class="td2"><em>T</em> (<em>n</em>)</td>
<td class="td2">≤</td>
<td class="td2"><em>c</em>(<em>n</em> – 1)<sup>2</sup> + Θ(<em>n</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2"><em>cn</em><sup>2</sup> – <em>c</em>(2<em>n</em> – 1) + Θ(<em>n</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2"><em>cn</em><sup>2</sup>,</td>
</tr>
</table>
<p class="noindent">by picking the constant <em>c</em> large enough that the <em>c</em>(2<em>n</em> – 1) term dominates the Θ(<em>n</em>) term. Thus <em>T</em> (<em>n</em>) = <em>O</em>(<em>n</em><sup>2</sup>). <a href="chapter007.xhtml#Sec_7.2">Section 7.2</a> showed a specific case where quicksort takes Ω(<em>n</em><sup>2</sup>) time: when partitioning is maximally unbalanced. Thus, the worst-case running time of quicksort is Θ(<em>n</em><sup>2</sup>).</p>
</section>
<section title="7.4.2 Expected running time">
<p class="level2" id="Sec_7.4.2"><strong>7.4.2    Expected running time</strong></p>
<p class="noindent">We have already seen the intuition behind why the expected running time of R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> is <em>O</em>(<em>n</em> lg <em>n</em>): if, in each level of recursion, the split induced by R<small>ANDOMIZED</small>-P<small>ARTITION</small> puts any constant fraction of the elements on one side of the partition, then the recursion tree has depth Θ(lg <em>n</em>) and <em>O</em>(<em>n</em>) work is performed at each level. Even if we add a few new levels with the most unbalanced split possible between these levels, the total time remains <em>O</em>(<em>n</em> lg <em>n</em>). We can analyze the expected running time of R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> precisely by first understanding how the partitioning procedure operates and then using this understanding to derive an <em>O</em>(<em>n</em> lg <em>n</em>) bound on the expected running time. This upper bound on the expected running time, combined with the Θ(<em>n</em> lg <em>n</em>) best-case bound we saw in <a href="chapter007.xhtml#Sec_7.2">Section 7.2</a>, yields a Θ(<em>n</em> lg <em>n</em>) expected running time. We assume throughout that the values of the elements being sorted are distinct.</p>
<p class="level4"><strong>Running time and comparisons</strong></p>
<p class="noindent">The Q<small>UICKSORT</small> and R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> procedures differ only in how they select pivot elements. They are the same in all other respects. We can therefore analyze R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> by considering the Q<small>UICKSORT</small> and P<small>ARTITION</small> procedures, but with the assumption that pivot elements are selected randomly from the subarray passed to R<small>ANDOMIZED</small>-P<small>ARTITION</small>. Let’s start by relating the asymptotic running time of Q<small>UICKSORT</small> to the number of times elements are compared (all in line 4 of P<small>ARTITION</small>), understanding that this analysis also applies to R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>. Note that we are counting the number of times that <em>array elements</em> are compared, not comparisons of indices.</p>
<p class="lemma"><strong><em>Lemma 7.1</em></strong></p>
<p class="noindent">The running time of Q<small>UICKSORT</small> on an <em>n</em>-element array is <em>O</em>(<em>n</em> + <em>X</em>), where <em>X</em> is the number of element comparisons performed.</p>
<a id="p195"/>
<p class="proof"><strong><em>Proof</em></strong>   The running time of Q<small>UICKSORT</small> is dominated by the time spent in the P<small>ARTITION</small> procedure. Each time P<small>ARTITION</small> is called, it selects a pivot element, which is never included in any future recursive calls to Q<small>UICKSORT</small> and P<small>ARTITION</small>. Thus, there can be at most <em>n</em> calls to P<small>ARTITION</small> over the entire execution of the quicksort algorithm. Each time Q<small>UICKSORT</small> calls P<small>ARTITION</small>, it also recursively calls itself twice, so there are at most 2<em>n</em> calls to the Q<small>UICKSORT</small> procedure itself.</p>
<p>One call to P<small>ARTITION</small> takes <em>O</em>(1) time plus an amount of time that is proportional to the number of iterations of the <strong>for</strong> loop in lines 3–6. Each iteration of this <strong>for</strong> loop performs one comparison in line 4, comparing the pivot element to another element of the array <em>A</em>. Therefore, the total time spent in the <strong>for</strong> loop across all executions is proportional to <em>X</em>. Since there are at most <em>n</em> calls to P<small>ARTITION</small> and the time spent outside the <strong>for</strong> loop is <em>O</em>(1) for each call, the total time spent in P<small>ARTITION</small> outside of the <strong>for</strong> loop is <em>O</em>(<em>n</em>). Thus the total time for quicksort is <em>O</em>(<em>n</em> + <em>X</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Our goal for analyzing R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>, therefore, is to compute the expected value E [<em>X</em>] of the random variable <em>X</em> denoting the total number of comparisons performed in all calls to P<small>ARTITION</small>. To do so, we must understand when the quicksort algorithm compares two elements of the array and when it does not. For ease of analysis, let’s index the elements of the array <em>A</em> by their position in the sorted output, rather than their position in the input. That is, although the elements in <em>A</em> may start out in any order, we’ll refer to them by <em>z</em><sub>1</sub>, <em>z</em><sub>2</sub>, … , <em>z<sub>n</sub></em>, where <em>z</em><sub>1</sub> &lt; <em>z</em><sub>2</sub> &lt; <span class="font1">⋯</span> &lt; <em>z<sub>n</sub></em>, with strict inequality because we assume that all elements are distinct. We denote the set {<em>z<sub>i</sub></em>, <em>z</em><sub><em>i</em> + 1</sub>, … , <em>z<sub>j</sub></em>} by <em>Z<sub>ij</sub></em>.</p>
<p>The next lemma characterizes when two elements are compared.</p>
<p class="lemma"><strong><em>Lemma 7.2</em></strong></p>
<p class="noindent">During the execution of R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> on an array of <em>n</em> distinct elements <em>z</em><sub>1</sub> &lt; <em>z</em><sub>2</sub> &lt; <span class="font1">⋯</span> &lt; <em>z<sub>n</sub></em>, an element <em>z<sub>i</sub></em> is compared with an element <em>z<sub>j</sub></em>, where <em>i</em> &lt; <em>j</em>, if and only if one of them is chosen as a pivot before any other element in the set <em>Z<sub>ij</sub></em>. Moreover, no two elements are ever compared twice.</p>
<p class="proof"><strong><em>Proof</em></strong>   Let’s look at the first time that an element <em>x</em> ∈ <em>Z<sub>ij</sub></em> is chosen as a pivot during the execution of the algorithm. There are three cases to consider. If <em>x</em> is neither <em>z<sub>i</sub></em> nor <em>z<sub>j</sub></em>—that is, <em>z<sub>i</sub></em> &lt; <em>x</em> &lt; <em>z<sub>j</sub></em>—then <em>z<sub>i</sub></em> and <em>z<sub>j</sub></em> are not compared at any subsequent time, because they fall into different sides of the partition around <em>x</em>. If <em>x</em> = <em>z<sub>i</sub></em>, then P<small>ARTITION</small> compares <em>z<sub>i</sub></em> with every other item in <em>Z<sub>ij</sub></em>. Similarly, if <em>x</em> = <em>z<sub>j</sub></em>, then P<small>ARTITION</small> compares <em>z<sub>j</sub></em> with every other item in <em>Z<sub>ij</sub></em>. Thus, <em>z<sub>i</sub></em> and <em>z<sub>j</sub></em> are compared if and only if the first element to be chosen as a pivot from <em>Z<sub>ij</sub></em> is either <em>z<sub>i</sub></em> or <em>z<sub>j</sub></em>. In the latter two cases, where one of <em>z<sub>i</sub></em> and <em>z<sub>j</sub></em> is chosen <a id="p196"/>as a pivot, since the pivot is removed from future comparisons, it is never compared again with the other element.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">As an example of this lemma, consider an input to quicksort of the numbers 1 through 10 in some arbitrary order. Suppose that the first pivot element is 7. Then the first call to P<small>ARTITION</small> separates the numbers into two sets: {1, 2, 3, 4, 5, 6} and {8, 9, 10}. In the process, the pivot element 7 is compared with all other elements, but no number from the first set (e.g., 2) is or ever will be compared with any number from the second set (e.g., 9). The values 7 and 9 are compared because 7 is the first item from <em>Z</em><sub>7,9</sub> to be chosen as a pivot. In contrast, 2 and 9 are never compared because the first pivot element chosen from <em>Z</em><sub>2,9</sub> is 7.</p>
<p>The next lemma gives the probability that two elements are compared.</p>
<p class="lemma"><strong><em>Lemma 7.3</em></strong></p>
<p class="noindent">Consider an execution of the procedure R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> on an array of <em>n</em> distinct elements <em>z</em><sub>1</sub> &lt; <em>z</em><sub>2</sub> &lt; <span class="font1">⋯</span> &lt; <em>z<sub>n</sub></em>. Given two arbitrary elements <em>z<sub>i</sub></em> and <em>z<sub>j</sub></em> where <em>i</em> &lt; <em>j</em>, the probability that they are compared is 2/(<em>j</em> – <em>i</em> + 1).</p>
<p class="proof"><strong><em>Proof</em></strong>   Let’s look at the tree of recursive calls that R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> makes, and consider the sets of elements provided as input to each call. Initially, the root set contains all the elements of <em>Z<sub>ij</sub></em>, since the root set contains every element in <em>A</em>. The elements belonging to <em>Z<sub>ij</sub></em> all stay together for each recursive call of R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> until P<small>ARTITION</small> chooses some element <em>x</em> ∈ <em>Z<sub>ij</sub></em> as a pivot. From that point on, the pivot <em>x</em> appears in no subsequent input set. The first time that R<small>ANDOMIZED</small>-S<small>ELECT</small> chooses a pivot <em>x</em> ∈ <em>Z<sub>ij</sub></em> from a set containing all the elements of <em>Z<sub>ij</sub></em>, each element in <em>Z<sub>ij</sub></em> is equally likely to be <em>x</em> because the pivot is chosen uniformly at random. Since |<em>Z<sub>ij</sub></em>| = <em>j</em> – <em>i</em> + 1, the probability is 1/(<em>j</em> – <em>i</em> + 1) that any given element in <em>Z<sub>ij</sub></em> is the first pivot chosen from <em>Z<sub>ij</sub></em>. Thus, by Lemma 7.2, we have</p>
<table class="table2b">
<tr>
<td class="td2">Pr {<em>z<sub>i</sub></em> is compared with <em>z<sub>j</sub></em>}</td>
<td class="td2m">=</td>
<td class="td2">Pr {<em>z<sub>i</sub></em> or <em>z<sub>j</sub></em> is the first pivot chosen from <em>Z<sub>ij</sub></em>}</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2m">=</td>
<td class="td2">Pr {<em>z<sub>i</sub></em> is the first pivot chosen from <em>Z<sub>ij</sub></em>}</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2"/>
<td class="td2"><p class="p2a">+ Pr {<em>z<sub>j</sub></em> is the first pivot chosen from <em>Z<sub>ij</sub></em>}</p></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2m">=</td>
<td class="td2"><img alt="art" src="images/Art_P315.jpg"/>,</td>
</tr>
</table>
<p class="noindent">where the second line follows from the first because the two events are mutually exclusive.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">We can now complete the analysis of randomized quicksort.</p>
<a id="p197"/>
<p class="theo"><strong><em>Theorem 7.4</em></strong></p>
<p class="noindent">The expected running time of R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> on an input of <em>n</em> distinct elements is <em>O</em>(<em>n</em> lg <em>n</em>).</p>
<p class="proof"><strong><em>Proof</em></strong>   The analysis uses indicator random variables (see <a href="chapter005.xhtml#Sec_5.2">Section 5.2</a>). Let the <em>n</em> distinct elements be <em>z</em><sub>1</sub> &lt; <em>z</em><sub>2</sub> &lt; <span class="font1">⋯</span> &lt; <em>z<sub>n</sub></em>, and for 1 ≤ <em>i</em> &lt; <em>j</em> ≤ <em>n</em>, define the indicator random variable <em>X<sub>ij</sub></em> = I {<em>z<sub>i</sub></em> is compared with <em>z<sub>j</sub></em>}. From Lemma 7.2, each pair is compared at most once, and so we can express <em>X</em> as follows:</p>
<p class="eql"><img alt="art" src="images/Art_P316.jpg"/></p>
<p class="noindent">By taking expectations of both sides and using linearity of expectation (equation (C.24) on page 1192) and Lemma 5.1 on page 130, we obtain</p>
<p class="eql"><img alt="art" src="images/Art_P317.jpg"/></p>
<p class="noindent">We can evaluate this sum using a change of variables (<em>k</em> = <em>j</em> – <em>i</em>) and the bound on the harmonic series in equation (A.9) on page 1142:</p>
<p class="eql"><img alt="art" src="images/Art_P318.jpg"/></p>
<a id="p198"/>
<p class="noindent">This bound and Lemma 7.1 allow us to conclude that the expected running time of R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> is <em>O</em>(<em>n</em> lg <em>n</em>) (assuming that the element values are distinct).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>7.4-1</em></strong></p>
<p class="noindent">Show that the recurrence</p>
<p class="eql"><em>T</em> (<em>n</em>) = max {<em>T</em> (<em>q</em>) + <em>T</em> (<em>n</em> – <em>q</em> – 1) : 0 ≤ <em>q</em> ≤ <em>n</em> – 1} + Θ(<em>n</em>)</p>
<p class="noindent">has a lower bound of <em>T</em> (<em>n</em>) = Ω (<em>n</em><sup>2</sup>).</p>
<p class="level3"><strong><em>7.4-2</em></strong></p>
<p class="noindent">Show that quicksort’s best-case running time is Ω(<em>n</em> lg <em>n</em>).</p>
<p class="level3"><strong><em>7.4-3</em></strong></p>
<p class="noindent">Show that the expression <em>q</em><sup>2</sup> + (<em>n</em> – <em>q</em> – 1)<sup>2</sup> achieves its maximum value over <em>q</em> = 0, 1, … , <em>n</em> – 1 when <em>q</em> = 0 or <em>q</em> = <em>n</em> – 1.</p>
<p class="level3"><strong><em>7.4-4</em></strong></p>
<p class="noindent">Show that R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>’s expected running time is Ω(<em>n</em> lg <em>n</em>).</p>
<p class="level3"><strong><em>7.4-5</em></strong></p>
<p class="noindent">Coarsening the recursion, as we did in Problem 2-1 for merge sort, is a common way to improve the running time of quicksort in practice. We modify the base case of the recursion so that if the array has fewer than <em>k</em> elements, the subarray is sorted by insertion sort, rather than by continued recursive calls to quicksort. Argue that the randomized version of this sorting algorithm runs in <em>O</em>(<em>nk</em> + <em>n</em> lg(<em>n</em>/<em>k</em>)) expected time. How should you pick <em>k</em>, both in theory and in practice?</p>
<p class="level3"><span class="font1">★</span> <strong><em>7.4-6</em></strong></p>
<p class="noindent">Consider modifying the P<small>ARTITION</small> procedure by randomly picking three elements from subarray <em>A</em>[<em>p</em> : <em>r</em>] and partitioning about their median (the middle value of the three elements). Approximate the probability of getting worse than an <em>α</em>-to-(1–<em>α</em>) split, as a function of <em>α</em> in the range 0 &lt; <em>α</em> &lt; 1/2.</p>
<a id="p199"/>
</section>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-43"><strong>Problems</strong></p>
<section title="7-1 Hoare partition correctness">
<p class="level2"><strong><em>7-1     Hoare partition correctness</em></strong></p>
<p class="noindent">The version of P<small>ARTITION</small> given in this chapter is not the original partitioning algorithm. Here is the original partitioning algorithm, which is due to C. A. R. Hoare.</p>
<div class="pull-quote1">
<p class="box-heading">H<small>OARE</small>-P<small>ARTITION</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p>
<table class="table1">
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><em>x</em> = <em>A</em>[<em>p</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="noindent"><em>i</em> = <em>p</em> – 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="noindent"><em>j</em> = <em>r</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> <small>TRUE</small></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="p2"><strong>repeat</strong></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="p3"><em>j</em> = <em>j</em> – 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="p2"><strong>until</strong> <em>A</em>[<em>j</em>] ≤ <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="p2"><strong>repeat</strong></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="p3"><em>i</em> = <em>i</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><p class="p2"><strong>until</strong> <em>A</em>[<em>i</em>] ≥ <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">11</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>i</em> &lt; <em>j</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">12</span></p></td>
<td class="td1"><p class="p3">exchange <em>A</em>[<em>i</em>] with <em>A</em>[<em>j</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">13</span></p></td>
<td class="td1"><p class="p2"><strong>else return</strong> <em>j</em></p></td>
</tr>
</table>
</div>
<p class="nl-top"><strong><em>a.</em></strong> Demonstrate the operation of H<small>OARE</small>-P<small>ARTITION</small> on the array <em>A</em> = <span class="font1">〈</span>13, 19, 9, 5, 12, 8, 7, 4, 11, 2, 6, 21<span class="font1">〉</span>, showing the values of the array and the indices <em>i</em> and <em>j</em> after each iteration of the <strong>while</strong> loop in lines 4–13.</p>
<p class="nl"><strong><em>b.</em></strong> Describe how the P<small>ARTITION</small> procedure in <a href="chapter007.xhtml#Sec_7.1">Section 7.1</a> differs from H<small>OARE</small>-P<small>ARTITION</small> when all elements in <em>A</em>[<em>p</em> : <em>r</em>] are equal. Describe a practical advantage of H<small>OARE</small>-P<small>ARTITION</small> over P<small>ARTITION</small> for use in quicksort.</p>
<p class="noindent1-top">The next three questions ask you to give a careful argument that the procedure H<small>OARE</small>-P<small>ARTITION</small> is correct. Assuming that the subarray <em>A</em>[<em>p</em> : <em>r</em>] contains at least two elements, prove the following:</p>
<p class="nl-top"><strong><em>c.</em></strong> The indices <em>i</em> and <em>j</em> are such that the procedure never accesses an element of <em>A</em> outside the subarray <em>A</em>[<em>p</em> : <em>r</em>].</p>
<p class="nl"><strong><em>d.</em></strong> When H<small>OARE</small>-P<small>ARTITION</small> terminates, it returns a value <em>j</em> such that <em>p</em> ≤ <em>j</em> &lt; <em>r</em>.</p>
<p class="nl"><strong><em>e.</em></strong> Every element of <em>A</em>[<em>p</em> : <em>j</em>] is less than or equal to every element of <em>A</em>[<em>j</em> + 1 : <em>r</em>] when H<small>OARE</small>-P<small>ARTITION</small> terminates.</p>
<a id="p200"/>
<p class="noindent1-top">The P<small>ARTITION</small> procedure in <a href="chapter007.xhtml#Sec_7.1">Section 7.1</a> separates the pivot value (originally in <em>A</em>[<em>r</em>]) from the two partitions it forms. The H<small>OARE</small>-P<small>ARTITION</small> procedure, on the other hand, always places the pivot value (originally in <em>A</em>[<em>p</em>]) into one of the two partitions <em>A</em>[<em>p</em> : <em>j</em>] and <em>A</em>[<em>j</em> + 1 : <em>r</em>]. Since <em>p</em> ≤ <em>j</em> &lt; <em>r</em>, neither partition is empty.</p>
<p class="nl-top"><strong><em>f.</em></strong> Rewrite the Q<small>UICKSORT</small> procedure to use H<small>OARE</small>-P<small>ARTITION</small>.</p>
</section>
<section title="7-2 Quicksort with equal element values">
<p class="level2"><strong><em>7-2     Quicksort with equal element values</em></strong></p>
<p class="noindent">The analysis of the expected running time of randomized quicksort in <a href="chapter007.xhtml#Sec_7.4.2">Section 7.4.2</a> assumes that all element values are distinct. This problem examines what happens when they are not.</p>
<p class="nl-top"><strong><em>a.</em></strong> Suppose that all element values are equal. What is randomized quicksort’s running time in this case?</p>
<p class="nl"><strong><em>b.</em></strong> The P<small>ARTITION</small> procedure returns an index <em>q</em> such that each element of <em>A</em>[<em>p</em> : <em>q</em> – 1] is less than or equal to <em>A</em>[<em>q</em>] and each element of <em>A</em>[<em>q</em> + 1 : <em>r</em>] is greater than <em>A</em>[<em>q</em>]. Modify the P<small>ARTITION</small> procedure to produce a procedure P<small>ARTITION</small>′ (<em>A</em>, <em>p</em>, <em>r</em>), which permutes the elements of <em>A</em>[<em>p</em> : <em>r</em>] and returns two indices <em>q</em> and <em>t</em>, where <em>p</em> ≤ <em>q</em> ≤ <em>t</em> ≤ <em>r</em>, such that</p>
<ul class="ulindent1" epub:type="list">
<li>all elements of <em>A</em>[<em>q</em> : <em>t</em>] are equal,</li>
<li>each element of <em>A</em>[<em>p</em> : <em>q</em> – 1] is less than <em>A</em>[<em>q</em>], and</li>
<li>each element of <em>A</em>[<em>t</em> + 1 : <em>r</em>] is greater than <em>A</em>[<em>q</em>].</li></ul>
<p class="nl-para">Like P<small>ARTITION</small>, your P<small>ARTITION</small>′ procedure should take Θ(<em>r</em> – <em>p</em>) time.</p>
<p class="nl-top"><strong><em>c.</em></strong> Modify the R<small>ANDOMIZED</small>-P<small>ARTITION</small> procedure to call P<small>ARTITION</small>′, and name the new procedure R<small>ANDOMIZED</small>-P<small>ARTITION</small>′. Then modify the Q<small>UICKSORT</small> procedure to produce a procedure Q<small>UICKSORT</small>′ (<em>A</em>, <em>p</em>, <em>r</em>) that calls R<small>ANDOMIZED</small>-P<small>ARTITION</small>′ and recurses only on partitions where elements are not known to be equal to each other.</p>
<p class="nl"><strong><em>d.</em></strong> Using Q<small>UICKSORT</small>′, adjust the analysis in <a href="chapter007.xhtml#Sec_7.4.2">Section 7.4.2</a> to avoid the assumption that all elements are distinct.</p>
</section>
<section title="7-3 Alternative quicksort analysis">
<p class="level2"><strong><em>7-3     Alternative quicksort analysis</em></strong></p>
<p class="noindent">An alternative analysis of the running time of randomized quicksort focuses on the expected running time of each individual recursive call to R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>, rather than on the number of comparisons performed. As in the analysis of <a href="chapter007.xhtml#Sec_7.4.2">Section 7.4.2</a>, assume that the values of the elements are distinct.</p>
<a id="p201"/>
<p class="nl-top"><strong><em>a.</em></strong> Argue that, given an array of size <em>n</em>, the probability that any particular element is chosen as the pivot is 1/<em>n</em>. Use this probability to define indicator random variables <em>X<sub>i</sub></em> = I {<em>i</em>th smallest element is chosen as the pivot}. What is E [<em>X<sub>i</sub></em>]?</p>
<p class="nl"><strong><em>b.</em></strong> Let <em>T</em> (<em>n</em>) be a random variable denoting the running time of quicksort on an array of size <em>n</em>. Argue that</p>
<p class="eqr"><img alt="art" src="images/Art_P319.jpg"/></p>
<p class="nl-top"><strong><em>c.</em></strong> Show how to rewrite equation (7.2) as</p>
<p class="eqr"><img alt="art" src="images/Art_P320.jpg"/></p>
<p class="nl-top"><strong><em>d.</em></strong> Show that</p>
<p class="eqr"><img alt="art" src="images/Art_P321.jpg"/></p>
<p class="nl-para">for <em>n</em> ≥ 2. (<em>Hint:</em> Split the summation into two parts, one summation for <em>q</em> = 1, 2, … , <span class="font1">⌈</span><em>n</em>/2<span class="font1">⌉</span> – 1 and one summation for <em>q</em> = <span class="font1">⌈</span><em>n</em>/2<span class="font1">⌉</span> , … , <em>n</em> – 1.)</p>
<p class="nl-top"><strong><em>e.</em></strong> Using the bound from equation (7.4), show that the recurrence in equation (7.3) has the solution E [<em>T</em> (<em>n</em>)] = <em>O</em>(<em>n</em> lg <em>n</em>). (<em>Hint:</em> Show, by substitution, that E [<em>T</em> (<em>n</em>)] ≤ <em>an</em> lg <em>n</em> for sufficiently large <em>n</em> and for some positive constant <em>a</em>.)</p>
</section>
<section title="7-4 Stooge sort">
<p class="level2"><strong><em>7-4     Stooge sort</em></strong></p>
<p class="noindent">Professors Howard, Fine, and Howard have proposed a deceptively simple sorting algorithm, named stooge sort in their honor, appearing on the following page.</p>
<p class="nl-top"><strong><em>a.</em></strong> Argue that the call S<small>TOOGE</small>-S<small>ORT</small>(<em>A</em>, 1, <em>n</em>) correctly sorts the array <em>A</em>[1 : <em>n</em>].</p>
<p class="nl"><strong><em>b.</em></strong> Give a recurrence for the worst-case running time of S<small>TOOGE</small>-S<small>ORT</small> and a tight asymptotic (Θ-notation) bound on the worst-case running time.</p>
<p class="nl"><strong><em>c.</em></strong> Compare the worst-case running time of S<small>TOOGE</small>-S<small>ORT</small> with that of insertion sort, merge sort, heapsort, and quicksort. Do the professors deserve tenure?</p>
<a id="p202"/>
<div class="pull-quote1">
<p class="box-heading">S<small>TOOGE</small>-S<small>ORT</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p>
<table class="table1c">
<tr>
<td class="td1w1"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>A</em>[<em>p</em>] &gt; <em>A</em>[<em>r</em>]</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2">exchange <em>A</em>[<em>p</em>] with <em>A</em>[<em>r</em>]</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>p</em> + 1 &lt; <em>r</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><em>k</em> = <span class="font1">⌊</span>(<em>r</em> – <em>p</em> + 1)/3<span class="font1">⌋</span></p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> round down</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p2">S<small>TOOGE</small>-S<small>ORT</small>(<em>A</em>, <em>p</em>, <em>r</em> – <em>k</em>)</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> first two-thirds</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="p2">S<small>TOOGE</small>-S<small>ORT</small>(<em>A</em>, <em>p</em> + <em>k</em>, <em>r</em>)</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> last two-thirds</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1"><p class="p2">S<small>TOOGE</small>-S<small>ORT</small>(<em>A</em>, <em>p</em>, <em>r</em> – <em>k</em>)</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> first two-thirds again</span></p></td>
</tr>
</table>
</div>
<p class="level2"><strong><em>7-5 Stack depth for quicksort</em></strong></p>
<p class="noindent">The Q<small>UICKSORT</small> procedure of <a href="chapter007.xhtml#Sec_7.1">Section 7.1</a> makes two recursive calls to itself. After Q<small>UICKSORT</small> calls P<small>ARTITION</small>, it recursively sorts the low side of the partition and then it recursively sorts the high side of the partition. The second recursive call in Q<small>UICKSORT</small> is not really necessary, because the procedure can instead use an iterative control structure. This transformation technique, called <strong><em><span class="blue1">tail-recursion elimination</span></em></strong>, is provided automatically by good compilers. Applying tail-recursion elimination transforms Q<small>UICKSORT</small> into the TRE-Q<small>UICKSORT</small> procedure.</p>
<div class="pull-quote1">
<p class="box-heading">TRE-Q<small>UICKSORT</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> <em>p</em> &lt; <em>r</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><span class="red"><strong>//</strong> Partition and then sort the low side.</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2"><em>q</em> = P<small>ARTITION</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2">TRE-Q<small>UICKSORT</small>(<em>A</em>, <em>p</em>, <em>q</em> – 1)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p2"><em>p</em> = <em>q</em> + 1</p></td>
</tr>
</table>
</div>
<p class="nl-top"><strong><em>a.</em></strong> Argue that TRE-Q<small>UICKSORT</small>(<em>A</em>, 1, <em>n</em>) correctly sorts the array <em>A</em>[1 : <em>n</em>].</p>
<p class="noindent1-top">Compilers usually execute recursive procedures by using a <strong><em><span class="blue1">stack</span></em></strong> that contains pertinent information, including the parameter values, for each recursive call. The information for the most recent call is at the top of the stack, and the information for the initial call is at the bottom. When a procedure is called, its information is <strong><em><span class="blue1">pushed</span></em></strong> onto the stack, and when it terminates, its information is <strong><em><span class="blue1">popped</span></em></strong>. Since we assume that array parameters are represented by pointers, the information for each procedure call on the stack requires <em>O</em>(1) stack space. The <strong><em><span class="blue1">stack depth</span></em></strong> is the maximum amount of stack space used at any time during a computation.</p>
<p class="nl-top"><strong><em>b.</em></strong> Describe a scenario in which TRE-Q<small>UICKSORT</small>’s stack depth is Θ(<em>n</em>) on an <em>n</em>-element input array.</p>
<a id="p203"/>
<p class="nl-top"><strong><em>c.</em></strong> Modify TRE-Q<small>UICKSORT</small> so that the worst-case stack depth is Θ(lg <em>n</em>). Maintain the <em>O</em>(<em>n</em> lg <em>n</em>) expected running time of the algorithm.</p>
</section>
<section title="7-6 Median-of-3 partition">
<p class="level2"><strong><em>7-6     Median-of-3 partition</em></strong></p>
<p class="noindent">One way to improve the R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> procedure is to partition around a pivot that is chosen more carefully than by picking a random element from the subarray. A common approach is the <strong><em><span class="blue1">median-of-3</span></em></strong> method: choose the pivot as the median (middle element) of a set of 3 elements randomly selected from the subarray. (See Exercise 7.4-6.) For this problem, assume that the <em>n</em> elements in the input subarray <em>A</em>[<em>p</em> : <em>r</em>] are distinct and that <em>n</em> ≥ 3. Denote the sorted version of <em>A</em>[<em>p</em> : <em>r</em>] by <em>z</em><sub>1</sub>, <em>z</em><sub>2</sub>, … , <em>z<sub>n</sub></em>. Using the median-of-3 method to choose the pivot element <em>x</em>, define <em>p<sub>i</sub></em> = Pr {<em>x</em> = <em>z<sub>i</sub></em>}.</p>
<p class="nl-top"><strong><em>a.</em></strong> Give an exact formula for <em>p<sub>i</sub></em> as a function of <em>n</em> and <em>i</em> for <em>i</em> = 2, 3, … , <em>n</em> – 1. (Observe that <em>p</em><sub>1</sub> = <em>p<sub>n</sub></em> = 0.)</p>
<p class="nl-top"><strong><em>b.</em></strong> By what amount does the median-of-3 method increase the likelihood of choosing the pivot to be <em>x</em> = <em>z</em><sub><span class="font1">⌊</span>(<em>n</em> + 1)/2<span class="font1">⌋</span></sub>, the median of <em>A</em>[<em>p</em> : <em>r</em>], compared with the ordinary implementation? Assume that <em>n</em> → ∞, and give the limiting ratio of these probabilities.</p>
<p class="nl-top"><strong><em>c.</em></strong> Suppose that we define a “good” split to mean choosing the pivot as <em>x</em> = <em>z<sub>i</sub></em>, where <em>n</em>/3 ≤ <em>i</em> ≤ 2<em>n</em>/3. By what amount does the median-of-3 method increase the likelihood of getting a good split compared with the ordinary implementation? (<em>Hint:</em> Approximate the sum by an integral.)</p>
<p class="nl"><strong><em>d.</em></strong> Argue that in the Ω(<em>n</em> lg <em>n</em>) running time of quicksort, the median-of-3 method affects only the constant factor.</p>
</section>
<section title="7-7 Fuzzy sorting of intervals">
<p class="level2"><strong><em>7-7     Fuzzy sorting of intervals</em></strong></p>
<p class="noindent">Consider a sorting problem in which you do not know the numbers exactly. Instead, for each number, you know an interval on the real line to which it belongs. That is, you are given <em>n</em> closed intervals of the form [<em>a<sub>i</sub></em>, <em>b<sub>i</sub></em>], where <em>a<sub>i</sub></em> ≤ <em>b<sub>i</sub></em>. The goal is to <strong><em><span class="blue1">fuzzy-sort</span></em></strong> these intervals: to produce a permutation <span class="font1">〈</span><em>i</em><sub>1</sub>, <em>i</em><sub>2</sub>, … , <em>i<sub>n</sub></em><span class="font1">〉</span> of the intervals such that for <em>j</em> = 1, 2, … , <em>n</em>, there exist <img alt="art" src="images/Art_P322.jpg"/> satisfying <em>c</em><sub>1</sub> ≤ <em>c</em><sub>2</sub> ≤ <span class="font1">⋯</span> ≤ <em>c<sub>n</sub></em>.</p>
<p class="nl-top"><strong><em>a.</em></strong> Design a randomized algorithm for fuzzy-sorting <em>n</em> intervals. Your algorithm should have the general structure of an algorithm that quicksorts the left endpoints (the <em>a<sub>i</sub></em> values), but it should take advantage of overlapping intervals to improve the running time. (As the intervals overlap more and more, the problem <a id="p204"/>of fuzzy-sorting the intervals becomes progressively easier. Your algorithm should take advantage of such overlapping, to the extent that it exists.)</p>
<p class="nl"><strong><em>b.</em></strong> Argue that your algorithm runs in Θ(<em>n</em> lg <em>n</em>) expected time in general, but runs in Θ(<em>n</em>) expected time when all of the intervals overlap (i.e., when there exists a value <em>x</em> such that <em>x</em> ∈ [<em>a<sub>i</sub></em>, <em>b<sub>i</sub></em>] for all <em>i</em>). Your algorithm should not be checking for this case explicitly, but rather, its performance should naturally improve as the amount of overlap increases.</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-44"><strong>Chapter notes</strong></p>
<p class="noindent">Quicksort was invented by Hoare [<a epub:type="noteref" href="bibliography001.xhtml#endnote_219">219</a>], and his version of P<small>ARTITION</small> appears in Problem 7-1. Bentley [<a epub:type="noteref" href="bibliography001.xhtml#endnote_51">51</a>, p. 117] attributes the P<small>ARTITION</small> procedure given in <a href="chapter007.xhtml#Sec_7.1">Section 7.1</a> to N. Lomuto. The analysis in <a href="chapter007.xhtml#Sec_7.4">Section 7.4</a> based on an analysis due to Motwani and Raghavan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_336">336</a>]. Sedgewick [<a epub:type="noteref" href="bibliography001.xhtml#endnote_401">401</a>] and Bentley [<a epub:type="noteref" href="bibliography001.xhtml#endnote_51">51</a>] provide good references on the details of implementation and how they matter.</p>
<p>McIlroy [<a epub:type="noteref" href="bibliography001.xhtml#endnote_323">323</a>] shows how to engineer a “killer adversary” that produces an array on which virtually any implementation of quicksort takes Θ(<em>n</em><sup>2</sup>) time.</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> You can enforce the assumption that the values in an array <em>A</em> are distinct at the cost of Θ(<em>n</em>) additional space and only constant overhead in running time by converting each input value <em>A</em>[<em>i</em>] to an ordered pair (<em>A</em>[<em>i</em>], <em>i</em>) with (<em>A</em>[<em>i</em>], <em>i</em>) &lt; (<em>A</em>[<em>j</em>], <em>j</em>) if <em>A</em>[<em>i</em>] &lt; <em>A</em>[<em>j</em>] or if <em>A</em>[<em>i</em>] = <em>A</em>[<em>j</em>] and <em>i</em> &lt; <em>j</em>. There are also more practical variants of quicksort that work well when elements are not distinct.</p>
</section>
</section>
</div>
</body>
</html>