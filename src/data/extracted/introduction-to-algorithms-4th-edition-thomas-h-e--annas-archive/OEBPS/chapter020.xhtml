<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p549"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="20 Elementary Graph Algorithms">
<p class="chapter-title"><a href="toc.xhtml#chap-20"><strong><span class="blue1">20        Elementary Graph Algorithms</span></strong></a></p>
<p class="noindent">This chapter presents methods for representing a graph and for searching a graph. Searching a graph means systematically following the edges of the graph so as to visit the vertices of the graph. A graph-searching algorithm can discover much about the structure of a graph. Many algorithms begin by searching their input graph to obtain this structural information. Several other graph algorithms elaborate on basic graph searching. Techniques for searching a graph lie at the heart of the field of graph algorithms.</p>
<p><a href="chapter020.xhtml#Sec_20.1">Section 20.1</a> discusses the two most common computational representations of graphs: as adjacency lists and as adjacency matrices. <a href="chapter020.xhtml#Sec_20.2">Section 20.2</a> presents a simple graph-searching algorithm called breadth-first search and shows how to create a breadth-first tree. <a href="chapter020.xhtml#Sec_20.3">Section 20.3</a> presents depth-first search and proves some standard results about the order in which depth-first search visits vertices. <a href="chapter020.xhtml#Sec_20.4">Section 20.4</a> provides our first real application of depth-first search: topologically sorting a directed acyclic graph. A second application of depth-first search, finding the strongly connected components of a directed graph, is the topic of <a href="chapter020.xhtml#Sec_20.5">Section 20.5</a>.</p>
<p class="line1"/>
<section title="20.1 Representations of graphs">
<a id="Sec_20.1"/>
<p class="level1" id="h1-118"><a href="toc.xhtml#Rh1-118"><strong>20.1    Representations of graphs</strong></a></p>
<p class="noindent">You can choose between two standard ways to represent a graph <em>G</em> = (<em>V, E</em>): as a collection of adjacency lists or as an adjacency matrix. Either way applies to both directed and undirected graphs. Because the adjacency-list representation provides a compact way to represent <span class="blue"><strong><em>sparse</em></strong></span> graphs—those for which |<em>E</em>| is much less than |<em>V</em>|<sup>2</sup>—it is usually the method of choice. Most of the graph algorithms presented in this book assume that an input graph is represented in adjacency-list form. You might prefer an adjacency-matrix representation, however, when the graph is <span class="blue"><strong><em>dense</em></strong></span>—|<em>E</em>| is close to |<em>V</em>|<sup>2</sup>—or when you need to be able to tell quickly whether there is an edge connecting two given vertices. For example, two of the <a id="p550"/>all-pairs shortest-paths algorithms presented in <a href="chapter023.xhtml">Chapter 23</a> assume that their input graphs are represented by adjacency matrices.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_20-1"><img alt="art" src="images/Art_P600.jpg"/></p>
<p class="caption"><strong>Figure 20.1</strong> Two representations of an undirected graph. <strong>(a)</strong> An undirected graph <em>G</em> with 5 vertices and 7 edges. <strong>(b)</strong> An adjacency-list representation of <em>G</em>. <strong>(c)</strong> The adjacency-matrix representation of <em>G</em>.</p>
</div>
<p class="block"/>
<div class="divimage">
<p class="fig-imga" id="Fig_20-2"><img alt="art" src="images/Art_P601.jpg"/></p>
<p class="caption"><strong>Figure 20.2</strong> Two representations of a directed graph. <strong>(a)</strong> A directed graph <em>G</em> with 6 vertices and 8 edges. <strong>(b)</strong> An adjacency-list representation of <em>G</em>. <strong>(c)</strong> The adjacency-matrix representation of <em>G</em>.</p>
</div>
<p>The <span class="blue"><strong><em>adjacency-list representation</em></strong></span> of a graph <em>G</em> = (<em>V</em>, <em>E</em>) consists of an array <em>Adj</em> of |<em>V</em>| lists, one for each vertex in <em>V</em>. For each <em>u</em> ∈ <em>V</em>, the adjacency list <em>Adj</em>[<em>u</em>] contains all the vertices <em>v</em> such that there is an edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>. That is, <em>Adj</em>[<em>u</em>] consists of all the vertices adjacent to <em>u</em> in <em>G</em>. (Alternatively, it can contain pointers to these vertices.) Since the adjacency lists represent the edges of a graph, our pseudocode treats the array <em>Adj</em> as an attribute of the graph, just like the edge set <em>E</em>. In pseudocode, therefore, you will see notation such as <em>G</em>.<em>Adj</em>[<em>u</em>]. <a href="chapter020.xhtml#Fig_20-1">Figure 20.1(b)</a> is an adjacency-list representation of the undirected graph in <a href="chapter020.xhtml#Fig_20-1">Figure 20.1(a)</a>. Similarly, <a href="chapter020.xhtml#Fig_20-2">Figure 20.2(b)</a> is an adjacency-list representation of the directed graph in <a href="chapter020.xhtml#Fig_20-2">Figure 20.2(a)</a>.</p>
<p>If <em>G</em> is a directed graph, the sum of the lengths of all the adjacency lists is |<em>E</em>|, since an edge of the form (<em>u</em>, <em>v</em>) is represented by having <em>v</em> appear in <em>Adj</em>[<em>u</em>]. If <em>G</em> is <a id="p551"/>an undirected graph, the sum of the lengths of all the adjacency lists is 2 |<em>E</em>|, since if (<em>u</em>, <em>v</em>) is an undirected edge, then <em>u</em> appears in <em>v</em>’s adjacency list and vice versa. For both directed and undirected graphs, the adjacency-list representation has the desirable property that the amount of memory it requires is Θ(<em>V</em> + <em>E</em>). Finding each edge in the graph also takes Θ(<em>V</em> + <em>E</em>) time, rather than just Θ(<em>E</em>), since each of the |<em>V</em>| adjacency lists must be examined. Of course, if |<em>E</em>| = Ω(<em>V</em>)—such as in a connected, undirected graph or a strongly connected, directed graph—we can say that finding each edge takes Θ(<em>E</em>) time.</p>
<p>Adjacency lists can also represent <span class="blue"><strong><em>weighted graphs</em></strong></span>, that is, graphs for which each edge has an associated <span class="blue"><strong><em>weight</em></strong></span> given by a <span class="blue"><strong><em>weight function</em></strong></span> <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>. For example, let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted graph with weight function <em>w</em>. Then you can simply store the weight <em>w</em>(<em>u</em>, <em>v</em>) of the edge (<em>u</em>, <em>v</em>) ∈ <em>E</em> with vertex <em>v</em> in <em>u</em>’s adjacency list. The adjacency-list representation is quite robust in that you can modify it to support many other graph variants.</p>
<p>A potential disadvantage of the adjacency-list representation is that it provides no quicker way to determine whether a given edge (<em>u</em>, <em>v</em>) is present in the graph than to search for <em>v</em> in the adjacency list <em>Adj</em>[<em>u</em>]. An adjacency-matrix representation of the graph remedies this disadvantage, but at the cost of using asymptotically more memory. (See Exercise 20.1-8 for suggestions of variations on adjacency lists that permit faster edge lookup.)</p>
<p>The <span class="blue"><strong><em>adjacency-matrix representation</em></strong></span> of a graph <em>G</em> = (<em>V</em>, <em>E</em>) assumes that the vertices are numbered 1, 2, … , |<em>V</em>| in some arbitrary manner. Then the adjacency-matrix representation of a graph <em>G</em> consists of a |<em>V</em>| × |<em>V</em>| matrix <em>A</em> = (<em>a<sub>ij</sub></em>) such that</p>
<p class="eql"><img alt="art" src="images/Art_P602.jpg"/></p>
<p class="noindent"><a href="chapter020.xhtml#Fig_20-1">Figures 20.1(c)</a> and <a href="chapter020.xhtml#Fig_20-2">20.2(c)</a> are the adjacency matrices of the undirected and directed graphs in <a href="chapter020.xhtml#Fig_20-1">Figures 20.1(a)</a> and <a href="chapter020.xhtml#Fig_20-2">20.2(a)</a>, respectively. The adjacency matrix of a graph requires Θ(<em>V</em><sup>2</sup>) memory, independent of the number of edges in the graph. Because finding each edge in the graph requires examining the entire adjacency matrix, doing so takes Θ(<em>V</em><sup>2</sup>) time.</p>
<p>Observe the symmetry along the main diagonal of the adjacency matrix in <a href="chapter020.xhtml#Fig_20-1">Figure 20.1(c)</a>. Since in an undirected graph, (<em>u</em>, <em>v</em>) and (<em>v</em>, <em>u</em>) represent the same edge, the adjacency matrix A of an undirected graph is its own transpose: <em>A</em> = <em>A</em><sup>T</sup>. In some applications, it pays to store only the entries on and above the diagonal of the adjacency matrix, thereby cutting the memory needed to store the graph almost in half.</p>
<p>Like the adjacency-list representation of a graph, an adjacency matrix can represent a weighted graph. For example, if <em>G</em> = (<em>V</em>, <em>E</em>) is a weighted graph with edge-weight function <em>w</em>, you can store the weight <em>w</em>(<em>u</em>, <em>v</em>) of the edge (<em>u</em>, <em>v</em>) ∈ <em>E</em> <a id="p552"/>as the entry in row <em>u</em> and column <em>v</em> of the adjacency matrix. If an edge does not exist, you can store a <small>NIL</small> value as its corresponding matrix entry, though for many problems it is convenient to use a value such as 0 or ∞.</p>
<p>Although the adjacency-list representation is asymptotically at least as space-efficient as the adjacency-matrix representation, adjacency matrices are simpler, and so you might prefer them when graphs are reasonably small. Moreover, adjacency matrices carry a further advantage for unweighted graphs: they require only one bit per entry.</p>
<p class="level4"><strong>Representing attributes</strong></p>
<p class="noindent">Most algorithms that operate on graphs need to maintain attributes for vertices and/or edges. We indicate these attributes using our usual notation, such as <em>v.d</em> for an attribute <em>d</em> of a vertex <em>v</em>. When we indicate edges as pairs of vertices, we use the same style of notation. For example, if edges have an attribute <em>f</em>, then we denote this attribute for edge (<em>u</em>, <em>v</em>) by (<em>u</em>, <em>v</em>).<em>f</em>. For the purpose of presenting and understanding algorithms, our attribute notation suffices.</p>
<p>Implementing vertex and edge attributes in real programs can be another story entirely. There is no one best way to store and access vertex and edge attributes. For a given situation, your decision will likely depend on the programming language you are using, the algorithm you are implementing, and how the rest of your program uses the graph. If you represent a graph using adjacency lists, one design choice is to represent vertex attributes in additional arrays, such as an array <em>d</em>[1 : |<em>V</em>|] that parallels the <em>Adj</em> array. If the vertices adjacent to <em>u</em> belong to <em>Adj</em>[<em>u</em>], then the attribute <em>u.d</em> can actually be stored in the array entry <em>d</em>[<em>u</em>]. Many other ways of implementing attributes are possible. For example, in an object-oriented programming language, vertex attributes might be represented as instance variables within a subclass of a Vertex class.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>20.1-1</em></strong></p>
<p class="noindent">Given an adjacency-list representation of a directed graph, how long does it take to compute the out-degree of every vertex? How long does it take to compute the in-degrees?</p>
<p class="level3"><strong><em>20.1-2</em></strong></p>
<p class="noindent">Give an adjacency-list representation for a complete binary tree on 7 vertices. Give an equivalent adjacency-matrix representation. Assume that the edges are undirected and that the vertices are numbered from 1 to 7 as in a binary heap.</p>
<a id="p553"/>
<p class="level3"><strong><em>20.1-3</em></strong></p>
<p class="noindent">The <span class="blue"><strong><em>transpose</em></strong></span> of a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) is the graph G<sup>T</sup> = (<em>V</em>, <em>E</em><sup>T</sup>), where <em>E</em><sup>T</sup> = {(<em>v</em>, <em>u</em>) ∈ <em>V</em> × <em>V</em> : (<em>u</em>, <em>v</em>) ∈ <em>E</em>}. That is, <em>G</em><sup>T</sup> is <em>G</em> with all its edges reversed. Describe efficient algorithms for computing <em>G</em><sup>T</sup> from <em>G</em>, for both the adjacency-list and adjacency-matrix representations of <em>G</em>. Analyze the running times of your algorithms.</p>
<p class="level3"><strong><em>20.1-4</em></strong></p>
<p class="noindent">Given an adjacency-list representation of a multigraph <em>G</em> = (<em>V</em>, <em>E</em>), describe an <em>O</em>(<em>V</em> + <em>E</em>)-time algorithm to compute the adjacency-list representation of the “equivalent” undirected graph <em>G</em>′ = (<em>V</em>, <em>E</em>′), where <em>E</em>′ consists of the edges in <em>E</em> with all multiple edges between two vertices replaced by a single edge and with all self-loops removed.</p>
<p class="level3"><strong><em>20.1-5</em></strong></p>
<p class="noindent">The <span class="blue"><strong><em>square</em></strong></span> of a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) is the graph <em>G</em><sup>2</sup> = (<em>V</em>, <em>E</em><sup>2</sup>) such that (<em>u</em>, <em>v</em>) ∈ <em>E</em><sup>2</sup> if and only if <em>G</em> contains a path with at most two edges between <em>u</em> and <em>v</em>. Describe efficient algorithms for computing <em>G</em><sup>2</sup> from <em>G</em> for both the adjacency-list and adjacency-matrix representations of <em>G</em>. Analyze the running times of your algorithms.</p>
<p class="level3"><strong><em>20.1-6</em></strong></p>
<p class="noindent">Most graph algorithms that take an adjacency-matrix representation as input require Ω(<em>V</em><sup>2</sup>) time, but there are some exceptions. Show how to determine whether a directed graph <em>G</em> contains a <span class="blue"><strong><em>universal sink</em></strong></span>—a vertex with in-degree |<em>V</em>| – 1 and out-degree 0—in <em>O</em>(<em>V</em>) time, given an adjacency matrix for <em>G</em>.</p>
<p class="level3"><strong><em>20.1-7</em></strong></p>
<p class="noindent">The <span class="blue"><strong><em>incidence matrix</em></strong></span> of a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with no self-loops is a |<em>V</em>| × |<em>E</em>| matrix <em>B</em> = (<em>b<sub>ij</sub></em>) such that</p>
<p class="eql"><img alt="art" src="images/Art_P603.jpg"/></p>
<p class="noindent">Describe what the entries of the matrix product <em>BB</em><sup>T</sup> represent, where <em>B</em><sup>T</sup> is the transpose of <em>B</em>.</p>
<p class="level3"><strong><em>20.1-8</em></strong></p>
<p class="noindent">Suppose that instead of a linked list, each array entry <em>Adj</em>[<em>u</em>] is a hash table containing the vertices <em>v</em> for which (<em>u</em>, <em>v</em>) ∈ <em>E</em>, with collisions resolved by chaining. Under the assumption of uniform independent hashing, if all edge lookups are equally likely, what is the expected time to determine whether an edge is in the graph? <a id="p554"/>What disadvantages does this scheme have? Suggest an alternate data structure for each edge list that solves these problems. Does your alternative have disadvantages compared with the hash table?</p>
</section>
<p class="line1"/>
<section title="20.2 Breadth-first search">
<a id="Sec_20.2"/>
<p class="level1" id="h1-119"><a href="toc.xhtml#Rh1-119"><strong>20.2    Breadth-first search</strong></a></p>
<p class="noindent"><span class="blue"><strong><em>Breadth-first search</em></strong></span> is one of the simplest algorithms for searching a graph and the archetype for many important graph algorithms. Prim’s minimum-spanning-tree algorithm (<a href="chapter021.xhtml#Sec_21.2">Section 21.2</a>) and Dijkstra’s single-source shortest-paths algorithm (<a href="chapter022.xhtml#Sec_22.3">Section 22.3</a>) use ideas similar to those in breadth-first search.</p>
<p>Given a graph <em>G</em> = (<em>V</em>, <em>E</em>) and a distinguished <span class="blue"><strong><em>source</em></strong></span> vertex <em>s</em>, breadth-first search systematically explores the edges of <em>G</em> to “discover” every vertex that is reachable from <em>s</em>. It computes the distance from <em>s</em> to each reachable vertex, where the distance to a vertex <em>v</em> equals the smallest number of edges needed to go from <em>s</em> to <em>v</em>. Breadth-first search also produces a “breadth-first tree” with root <em>s</em> that contains all reachable vertices. For any vertex <em>v</em> reachable from <em>s</em>, the simple path in the breadth-first tree from <em>s</em> to <em>v</em> corresponds to a shortest path from <em>s</em> to <em>v</em> in <em>G</em>, that is, a path containing the smallest number of edges. The algorithm works on both directed and undirected graphs.</p>
<p>Breadth-first search is so named because it expands the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier. You can think of it as discovering vertices in waves emanating from the source vertex. That is, starting from <em>s</em>, the algorithm first discovers all neighbors of <em>s</em>, which have distance 1. Then it discovers all vertices with distance 2, then all vertices with distance 3, and so on, until it has discovered every vertex reachable from <em>s</em>.</p>
<p>In order to keep track of the waves of vertices, breadth-first search could maintain separate arrays or lists of the vertices at each distance from the source vertex. Instead, it uses a single first-in, first-out queue (see <a href="chapter010.xhtml#Sec_10.1.3">Section 10.1.3</a>) containing some vertices at a distance <em>k</em>, possibly followed by some vertices at distance <em>k</em> + 1. The queue, therefore, contains portions of two consecutive waves at any time.</p>
<p>To keep track of progress, breadth-first search colors each vertex white, gray, or black. All vertices start out white, and vertices not reachable from the source vertex <em>s</em> stay white the entire time. A vertex that is reachable from <em>s</em> is <span class="blue"><strong><em>discovered</em></strong></span> the first time it is encountered during the search, at which time it becomes gray, indicating that is now on the frontier of the search: the boundary between discovered and undiscovered vertices. The queue contains all the gray vertices. Eventually, all the edges of a gray vertex will be explored, so that all of its neighbors will be <a id="p555"/>discovered. Once all of a vertex’s edges have been explored, the vertex is behind the frontier of the search, and it goes from gray to black.<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup></p>
<p>Breadth-first search constructs a breadth-first tree, initially containing only its root, which is the source vertex <em>s</em>. Whenever the search discovers a white vertex <em>v</em> in the course of scanning the adjacency list of a gray vertex <em>u</em>, the vertex <em>v</em> and the edge (<em>u</em>, <em>v</em>) are added to the tree. We say that <em>u</em> is the <span class="blue"><strong><em>predecessor</em></strong></span> or <span class="blue"><strong><em>parent</em></strong></span> of <em>v</em> in the breadth-first tree. Since every vertex reachable from <em>s</em> is discovered at most once, each vertex reachable from <em>s</em> has exactly one parent. (There is one exception: because <em>s</em> is the root of the breadth-first tree, it has no parent.) Ancestor and descendant relationships in the breadth-first tree are defined relative to the root <em>s</em> as usual: if <em>u</em> is on the simple path in the tree from the root <em>s</em> to vertex <em>v</em>, then <em>u</em> is an ancestor of <em>v</em> and <em>v</em> is a descendant of <em>u</em>.</p>
<p>The breadth-first-search procedure BFS on the following page assumes that the graph <em>G</em> = (<em>V</em>, <em>E</em>) is represented using adjacency lists. It denotes the queue by <em>Q</em>, and it attaches three additional attributes to each vertex <em>v</em> in the graph:</p>
<ul class="ulnoindent" epub:type="list">
<li><em>v.color</em> is the color of <em>v</em>: <small>WHITE</small>, <small>GRAY</small>, or <small>BLACK</small>.</li>
<li class="litop"><em>v.d</em> holds the distance from the source vertex <em>s</em> to <em>v</em>, as computed by the algorithm.</li>
<li class="litop"><em>v</em>.<em>π</em> is <em>v</em>’s predecessor in the breadth-first tree. If <em>v</em> has no predecessor because it is the source vertex or is undiscovered, then <em>v</em>.<em>π</em> <small>NIL</small>.</li></ul>
<p class="noindent"><a href="chapter020.xhtml#Fig_20-3">Figure 20.3</a> illustrates the progress of BFS on an undirected graph.</p>
<p>The procedure BFS works as follows. With the exception of the source vertex <em>s</em>, lines 1–4 paint every vertex white, set <em>u.d</em> = ∞ for each vertex <em>u</em>, and set the parent of every vertex to be <small>NIL</small>. Because the source vertex <em>s</em> is always the first vertex discovered, lines 5–7 paint <em>s</em> gray, set <em>s.d</em> to 0, and set the predecessor of <em>s</em> to <small>NIL</small>. Lines 8–9 create the queue <em>Q</em>, initially containing just the source vertex.</p>
<p>The <strong>while</strong> loop of lines 10–18 iterates as long as there remain gray vertices, which are on the frontier: discovered vertices that have not yet had their adjacency lists fully examined. This <strong>while</strong> loop maintains the following invariant:</p>
<div class="pull-quote">
<p class="pq-noindent">At the test in line 10, the queue <em>Q</em> consists of the set of gray vertices.</p>
</div>
<p class="noindent">Although we won’t use this loop invariant to prove correctness, it is easy to see that it holds prior to the first iteration and that each iteration of the loop maintains the invariant. Prior to the first iteration, the only gray vertex, and the only vertex <a id="p556"/>in <em>Q</em>, is the source vertex <em>s</em>. Line 11 determines the gray vertex <em>u</em> at the head of the queue <em>Q</em> and removes it from <em>Q</em>. The <strong>for</strong> loop of lines 12–17 considers each vertex <em>v</em> in the adjacency list of <em>u</em>. If <em>v</em> is white, then it has not yet been discovered, and the procedure discovers it by executing lines 14–17. These lines paint vertex <em>v</em> gray, set <em>v</em>’s distance <em>v.d</em> to <em>u.d</em> + 1, record <em>u</em> as <em>v</em>’s parent <em>v.π</em>, and place <em>v</em> at the tail of the queue <em>Q</em>. Once the procedure has examined all the vertices on <em>u</em>’s adjacency list, it blackens <em>u</em> in line 18, indicating that <em>u</em> is now behind the frontier. The loop invariant is maintained because whenever a vertex is painted gray (in line 14) it is also enqueued (in line 17), and whenever a vertex is dequeued (in line 11) it is also painted black (in line 18).</p>
<div class="pull-quote1">
<p class="box-heading">BFS(<em>G, s</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>u</em> ∈ <em>G.V</em> – {<em>s</em>}</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="p2"><em>u.color</em> = <small>WHITE</small></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="p2"><em>u.d</em> = ∞</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="p2"><em>u</em>.<em>π</em> <small>NIL</small></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="noindent"><em>s.color</em> = <small>GRAY</small></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="noindent"><em>s.d</em> = 0</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="noindent"><em>s</em>.<em>π</em> <small>NIL</small></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="noindent"><em>Q</em> = Ø</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="noindent">E<small>NQUEUE</small>(<em>Q, s</em>)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> <em>Q</em> ≠ Ø</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">11</span></p></td>
<td class="td1"><p class="p2"><em>u</em> = D<small>EQUEUE</small>(<em>Q</em>)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">12</span></p></td>
<td class="td1"><p class="p2"><strong>for</strong> each vertex <em>v</em> in <em>G.Adj</em>[<em>u</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red">// search the neighbors of <em>u</em></span></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">13</span></p></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>v.color</em> == <small>WHITE</small></p></td>
<td class="td1"><p class="noindent"><span class="red">// is <em>v</em> being discovered now?</span></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">14</span></p></td>
<td class="td1"><p class="p4"><em>v.color</em> = <small>GRAY</small></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">15</span></p></td>
<td class="td1"><p class="p4"><em>v.d</em> = <em>u.d</em> + 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">16</span></p></td>
<td class="td1"><p class="p4"><em>v</em>.<em>π</em> = <em>u</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">17</span></p></td>
<td class="td1"><p class="p4">E<small>NQUEUEd</small>(<em>Q</em>, <em>v</em>)</p></td>
<td class="td1"><p class="noindent"><span class="red">// <em>v</em> is now on the frontier</span></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">18</span></p></td>
<td class="td1"><p class="p2"><em>u.color</em> = <small>BLACK</small></p></td>
<td class="td1"><p class="noindent"><span class="red">// <em>u</em> is now behind the frontier</span></p></td>
</tr>
</table>
</div>
<p>The results of breadth-first search may depend upon the order in which the neighbors of a given vertex are visited in line 12: the breadth-first tree may vary, but the distances <em>d</em> computed by the algorithm do not. (See Exercise 20.2-5.)</p>
<p>A simple change allows the BFS procedure to terminate in many cases before the queue <em>Q</em> becomes empty. Because each vertex is discovered at most once and receives a finite <em>d</em> value only when it is discovered, the algorithm can terminate once every vertex has a finite <em>d</em> value. If BFS keeps count of how many vertices have been discovered, it can terminate once either the queue <em>Q</em> is empty or all |<em>V</em>| vertices are discovered.</p>
<a id="p557"/>
<div class="divimage">
<p class="fig-imga" id="Fig_20-3"><img alt="art" src="images/Art_P604.jpg"/></p>
<p class="caption"><strong>Figure 20.3</strong> The operation of BFS on an undirected graph. Each part shows the graph and the queue <em>Q</em> at the beginning of each iteration of the <strong>while</strong> loop of lines 10–18. Vertex distances appear within each vertex and below vertices in the queue. The tan region surrounds the frontier of the search, consisting of the vertices in the queue. The light blue region surrounds the vertices behind the frontier, which have been dequeued. Each part highlights in orange the vertex dequeued and the breadth-first tree edges added, if any, in the previous iteration. Blue edges belong to the breadth-first tree constructed so far.</p>
</div>
<a id="p558"/>
<p class="level4"><strong>Analysis</strong></p>
<p class="noindent">Before proving the various properties of breadth-first search, let’s take on the easier job of analyzing its running time on an input graph <em>G</em> = (<em>V</em>, <em>E</em>). We use aggregate analysis, as we saw in <a href="chapter016.xhtml#Sec_16.1">Section 16.1</a>. After initialization, breadth-first search never whitens a vertex, and thus the test in line 13 ensures that each vertex is enqueued at most once, and hence dequeued at most once. The operations of enqueuing and dequeuing take <em>O</em>(1) time, and so the total time devoted to queue operations is <em>O</em>(<em>V</em>). Because the procedure scans the adjacency list of each vertex only when the vertex is dequeued, it scans each adjacency list at most once. Since the sum of the lengths of all |<em>V</em>| adjacency lists is Θ(<em>E</em>), the total time spent in scanning adjacency lists is <em>O</em>(<em>V</em> + <em>E</em>). The overhead for initialization is <em>O</em>(<em>V</em>), and thus the total running time of the BFS procedure is <em>O</em>(<em>V</em> + <em>E</em>). Thus, breadth-first search runs in time linear in the size of the adjacency-list representation of <em>G</em>.</p>
<p class="level4"><strong>Shortest paths</strong></p>
<p class="noindent">Now, let’s see why breadth-first search finds the shortest distance from a given source vertex <em>s</em> to each vertex in a graph. Define the <span class="blue"><strong><em>shortest-path distance</em></strong></span> δ(<em>s</em>, <em>v</em>) from <em>s</em> to <em>v</em> as the minimum number of edges in any path from vertex <em>s</em> to vertex <em>v</em>. If there is no path from <em>s</em> to <em>v</em>, then δ(<em>s</em>, <em>v</em>) = ∞. We call a path of length δ(<em>s</em>, <em>v</em>) from <em>s</em> to <em>v</em> a <span class="blue"><strong><em>shortest path</em></strong></span><sup><a epub:type="footnote" href="#footnote_2" id="footnote_ref_2">2</a></sup> from <em>s</em> to <em>v</em>. Before showing that breadth-first search correctly computes shortest-path distances, we investigate an important property of shortest-path distances.</p>
<p class="lem"><strong><em>Lemma 20.1</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a directed or undirected graph, and let <em>s</em> ∈ <em>V</em> be an arbitrary vertex. Then, for any edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>,</p>
<p class="eql">δ(<em>s</em>, <em>v</em>) ≤ δ(<em>s</em>, <em>u</em>) + 1.</p>
<p class="prof"><strong><em>Proof</em></strong>   If <em>u</em> is reachable from <em>s</em>, then so is <em>v</em>. In this case, the shortest path from <em>s</em> to <em>v</em> cannot be longer than the shortest path from <em>s</em> to <em>u</em> followed by the edge (<em>u</em>, <em>v</em>), and thus the inequality holds. If <em>u</em> is not reachable from <em>s</em>, then δ(<em>s</em>, <em>u</em>) = ∞, and again, the inequality holds.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Our goal is to show that the BFS procedure properly computes <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for each vertex <em>v</em> ∈ <em>V</em>. We first show that <em>v.d</em> bounds δ(<em>s</em>, <em>v</em>) from above.</p>
<a id="p559"/>
<p class="lem"><strong><em>Lemma 20.2</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a directed or undirected graph, and suppose that BFS is run on <em>G</em> from a given source vertex <em>s</em> ∈ <em>V</em>. Then, for each vertex <em>v</em> ∈ <em>V</em>, the value <em>v.d</em> computed by BFS satisfies <em>v.d</em> ≥ δ(<em>s</em>, <em>v</em>) at all times, including at termination.</p>
<p class="prof"><strong><em>Proof</em></strong>   The lemma is true intuitively, because any finite value assigned to <em>v.d</em> equals the number of edges on some path from <em>s</em> to <em>v</em>. The formal proof is by induction on the number of E<small>NQUEUE</small> operations. The inductive hypothesis is that <em>v.d</em> ≥ δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>.</p>
<p>The base case of the induction is the situation immediately after enqueuing <em>s</em> in line 9 of BFS. The inductive hypothesis holds here, because <em>s.d</em> = 0 = δ(<em>s</em>, <em>s</em>) and <em>v.d</em> = 1 ∞ δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em> – {<em>s</em>}.</p>
<p>For the inductive step, consider a white vertex <em>v</em> that is discovered during the search from a vertex <em>u</em>. The inductive hypothesis implies that <em>u.d</em> ≥ δ(<em>s</em>, <em>u</em>). The assignment performed by line 15 and Lemma 20.1 give</p>
<table class="table2b">
<tr>
<td class="td2"><em>v.d</em></td>
<td class="td2">=</td>
<td class="td2"><em>u.d</em> + 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2">δ(<em>s</em>, <em>u</em>) + 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2">δ(<em>s</em>, <em>v</em>).</td>
</tr>
</table>
<p class="noindent">Vertex <em>v</em> is then enqueued, and it is never enqueued again because it is also grayed and lines 14–17 execute only for white vertices. Thus, the value of <em>v.d</em> never changes again, and the inductive hypothesis is maintained.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">To prove that <em>v.d</em> = δ(<em>s</em>, <em>v</em>), we first show more precisely how the queue <em>Q</em> operates during the course of BFS. The next lemma shows that at all times, the <em>d</em> values of vertices in the queue either are all the same or form a sequence <span class="font1">〈</span><em>k</em>, <em>k</em>, … , <em>k</em>, <em>k</em> + 1, <em>k</em> + 1, … , <em>k</em> + 1<span class="font1">〉</span> for some integer <em>k</em> ≥ 0.</p>
<p class="lem"><strong><em>Lemma 20.3</em></strong></p>
<p class="noindent">Suppose that during the execution of BFS on a graph <em>G</em> = (<em>V</em>, <em>E</em>), the queue <em>Q</em> contains the vertices <span class="font1">〈</span><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, … , <em>v<sub>r</sub></em><span class="font1">〉</span>, where <em>v</em><sub>1</sub> is the head of <em>Q</em> and <em>v<sub>r</sub></em> is the tail. Then, <em>v<sub>r</sub>.d</em> ≤ <em>v</em><sub>1</sub>.<em>d</em> + 1 and <em>v<sub>i</sub>.d</em> ≤ <em>v</em><sub><em>i</em>+1</sub>.<em>d</em> for <em>i</em> = 1, 2, … , <em>r</em> – 1.</p>
<p class="prof"><strong><em>Proof</em></strong>   The proof is by induction on the number of queue operations. Initially, when the queue contains only <em>s</em>, the lemma trivially holds.</p>
<p>For the inductive step, we must prove that the lemma holds after both dequeuing and enqueuing a vertex. First, we examine dequeuing. When the head <em>v</em><sub>1</sub> of the queue is dequeued, <em>v</em><sub>2</sub> becomes the new head. (If the queue becomes empty, then the lemma holds vacuously.) By the inductive hypothesis, <em>v</em><sub>1</sub>.<em>d</em> ≤ <em>v</em><sub>2</sub>.<em>d</em>. But then we have <em>v<sub>r</sub>.d</em> ≤ <em>v</em><sub>1</sub>.<em>d</em>+1 ≤ <em>v</em><sub>2</sub>.<em>d</em> + 1, and the remaining inequalities are unaffected. Thus, the lemma follows with <em>v</em><sub>2</sub> as the new head.</p>
<a id="p560"/>
<p>Now, we examine enqueuing. When line 17 of BFS enqueues a vertex <em>v</em> onto a queue containing vertices <span class="font1">〈</span><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, … , <em>v<sub>r</sub></em><span class="font1">〉</span>, the enqueued vertex becomes <em>v</em><sub><em>r</em>+1</sub>. If the queue was empty before <em>v</em> was enqueued, then after enqueuing <em>v</em>, we have <em>r</em> = 1 and the lemma trivially holds. Now suppose that the queue was nonempty when <em>v</em> was enqueued. At that time, the procedure has most recently removed vertex <em>u</em>, whose adjacency list is currently being scanned, from the queue <em>Q</em>. Just before <em>u</em> was removed, we had <em>u</em> = <em>v</em><sub>1</sub> and the inductive hypothesis held, so that <em>u.d</em> ≤ <em>v</em><sub>2</sub>.<em>d</em> and <em>v<sub>r</sub>.d</em> ≤ <em>u.d</em> + 1. After <em>u</em> is removed from the queue, the vertex that had been <em>v</em><sub>2</sub> becomes the new head <em>v</em><sub>1</sub> of the queue, so that now <em>u.d</em> ≤ <em>v</em><sub>1</sub>.<em>d</em>. Thus, <em>v</em><sub><em>r</em>+1</sub>.<em>d</em> = <em>v.d</em> = <em>u.d</em> + 1 ≤ <em>v</em><sub>1</sub>.<em>d</em> + 1. Since <em>v<sub>r</sub>.d</em> ≤ <em>u.d</em> + 1, we have <em>v<sub>r</sub>.d</em> ≤ <em>u.d</em> + 1 = <em>v.d</em> = <em>v</em><sub><em>r</em>+1</sub>.<em>d</em>, and the remaining inequalities are unaffected. Thus, the lemma follows when <em>v</em> is enqueued.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The following corollary shows that the <em>d</em> values at the time that vertices are enqueued monotonically increase over time.</p>
<p class="cor"><strong><em>Corollary 20.4</em></strong></p>
<p class="noindent">Suppose that vertices <em>v<sub>i</sub></em> and <em>v<sub>j</sub></em> are enqueued during the execution of BFS, and that <em>v<sub>i</sub></em> is enqueued before <em>v<sub>j</sub></em>. Then <em>v<sub>i</sub>.d</em> ≤ <em>v<sub>j</sub>.d</em> at the time that <em>v<sub>j</sub></em> is enqueued.</p>
<p class="prof"><strong><em>Proof</em></strong>   Immediate from Lemma 20.3 and the property that each vertex receives a finite <em>d</em> value at most once during the course of BFS.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">We can now prove that breadth-first search correctly finds shortest-path distances.</p>
<p class="theo"><strong><em>Theorem 20.5 (Correctness of breadth-first search)</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a directed or undirected graph, and suppose that BFS is run on <em>G</em> from a given source vertex <em>s</em> ∈ <em>V</em>. Then, during its execution, BFS discovers every vertex <em>v</em> ∈ <em>V</em> that is reachable from the source <em>s</em>, and upon termination, <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>. Moreover, for any vertex <em>v</em> ≠ <em>s</em> that is reachable from <em>s</em>, one of the shortest paths from <em>s</em> to <em>v</em> is a shortest path from <em>s</em> to <em>v</em>.<em>π</em> followed by the edge (<em>v</em>.<em>π</em>, <em>v</em>).</p>
<p class="prof"><strong><em>Proof</em></strong>   Assume for the purpose of contradiction that some vertex receives a <em>d</em> value not equal to its shortest-path distance. Of all such vertices, let <em>v</em> be a vertex that has the minimum δ(<em>s</em>, <em>v</em>). By Lemma 20.2, we have <em>v.d</em> ≥ δ(<em>s</em>, <em>v</em>), and thus <em>v.d</em> &gt; δ(<em>s</em>, <em>v</em>). We cannot have <em>v</em> = <em>s</em>, because <em>s.d</em> = 0 and δ(<em>s</em>, <em>s</em>) = 0. Vertex <em>v</em> must be reachable from <em>s</em>, for otherwise we would have δ(<em>s</em>, <em>v</em>) = ∞ ≥ <em>v.d</em>. Let <em>u</em> be the vertex immediately preceding <em>v</em> on some shortest path from <em>s</em> to <em>v</em> (since <em>v</em> ≠ <em>s</em>, vertex <em>u</em> must exist), so that δ(<em>s</em>, <em>v</em>) = δ(<em>s</em>, <em>u</em>)+1. Because δ(<em>s</em>, <em>u</em>) &lt; δ(<em>s</em>, <em>v</em>), <a id="p561"/>and because of how we chose <em>v</em>, we have <em>u.d</em> = δ(<em>s</em>, <em>u</em>). Putting these properties together gives</p>
<p class="eqr"><img alt="art" src="images/Art_P605.jpg"/></p>
<p>Now consider the time when BFS chooses to dequeue vertex <em>u</em> from <em>Q</em> in line 11. At this time, vertex <em>v</em> is either white, gray, or black. We shall show that each of these cases leads to a contradiction of inequality (20.1). If <em>v</em> is white, then line 15 sets <em>v.d</em> = <em>u.d</em> + 1, contradicting inequality (20.1). If <em>v</em> is black, then it was already removed from the queue and, by Corollary 20.4, we have <em>v.d</em> ≤ <em>u.d</em>, again contradicting inequality (20.1). If <em>v</em> is gray, then it was painted gray upon dequeuing some vertex <em>w</em>, which was removed from <em>Q</em> earlier than <em>u</em> and for which <em>v.d</em> = <em>w.d</em> + 1. By Corollary 20.4, however, <em>w.d</em> ≤ <em>u.d</em>, and so <em>v.d</em> = <em>w.d</em> + 1 ≤ <em>u.d</em> + 1, once again contradicting inequality (20.1).</p>
<p>Thus we conclude that <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>. All vertices <em>v</em> reachable from <em>s</em> must be discovered, for otherwise they would have ∞ = <em>v.d</em> &gt; δ(<em>s</em>, <em>v</em>). To conclude the proof of the theorem, observe from lines 15–16 that if <em>v</em>.<em>π</em> = <em>u</em>, then <em>v.d</em> = <em>u.d</em> + 1. Thus, to form a shortest path from <em>s</em> to <em>v</em>, take a shortest path from <em>s</em> to <em>v</em>.<em>π</em> and then traverse the edge (<em>v</em>.<em>π</em> <em>v</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Breadth-first trees</strong></p>
<p class="noindent">The blue edges in <a href="chapter020.xhtml#Fig_20-3">Figure 20.3</a> show the breadth-first tree built by the BFS procedure as it searches the graph. The tree corresponds to the <em>π</em> attributes. More formally, for a graph <em>G</em> = (<em>V</em>, <em>E</em>) with source <em>s</em>, we define the <span class="blue"><strong><em>predecessor subgraph</em></strong></span> of <em>G</em> as <em>G</em><sub><em>π</em></sub> = (<em>V</em><sub><em>π</em></sub>, <em>E</em><sub><em>π</em></sub>), where</p>
<p class="eqr"><img alt="art" src="images/Art_P606.jpg"/></p>
<p class="noindent">and</p>
<p class="eqr"><img alt="art" src="images/Art_P607.jpg"/></p>
<p class="noindent">The predecessor subgraph <em>G</em><sub><em>π</em></sub> is a <span class="blue"><strong><em>breadth-first tree</em></strong></span> if <em>V</em><sub><em>π</em></sub> consists of the vertices reachable from <em>s</em> and, for all <em>v</em> ∈ <em>V</em><sub><em>π</em></sub>, the subgraph <em>G</em><sub><em>π</em></sub> contains a unique simple path from <em>s</em> to <em>v</em> that is also a shortest path from <em>s</em> to <em>v</em> in <em>G</em>. A breadth-first tree is in fact a tree, since it is connected and |<em>E</em><sub><em>π</em></sub>| = |<em>V</em><sub><em>π</em></sub>| − 1 (see Theorem B.2 on page 1169). We call the edges in <em>E</em><sub><em>π</em></sub><span class="blue"><strong><em>tree edges</em></strong></span>.</p>
<p>The following lemma shows that the predecessor subgraph produced by the BFS procedure is a breadth-first tree.</p>
<p class="lem"><strong><em>Lemma 20.6</em></strong></p>
<p class="noindent">When applied to a directed or undirected graph <em>G</em> = (<em>V</em>, <em>E</em>), procedure BFS constructs <em>π</em> so that the predecessor subgraph <em>G</em><sub><em>π</em></sub> = (<em>V</em><sub><em>π</em></sub>, <em>E</em><sub><em>π</em></sub>) is a breadth-first tree.</p>
<a id="p562"/>
<p class="prof"><strong><em>Proof</em></strong>   Line 16 of BFS sets <em>v</em>.<em>π</em> = <em>u</em> if and only if (<em>u</em>, <em>v</em>) = <em>E</em> and δ(<em>s</em>, <em>v</em>) &lt; ∞—that is, if <em>v</em> is reachable from <em>s</em>—and thus <em>V</em><sub><em>π</em></sub> consists of the vertices in <em>V</em> reachable from <em>s</em>. Since the predecessor subgraph <em>G</em><sub><em>π</em></sub> forms a tree, by Theorem B.2, it contains a unique simple path from <em>s</em> to each vertex in <em>V</em><sub><em>π</em></sub>. Applying Theorem 20.5 inductively yields that every such path is a shortest path in <em>G</em>.</p>
<p class="space-break">The P<small>RINT</small>-P<small>ATH</small> procedure prints out the vertices on a shortest path from <em>s</em> to <em>v</em>, assuming that BFS has already computed a breadth-first tree. This procedure runs in time linear in the number of vertices in the path printed, since each recursive call is for a path one vertex shorter.</p>
<div class="pull-quote1">
<p class="box-heading">P<small>RINT</small>-P<small>ATH</small>(<em>G</em>, <em>s</em>, <em>v</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>v</em> == <em>s</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="p2">print <em>s</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="noindent"><strong>elseif</strong> <em>v</em>.<em>π</em> == <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="p2">print “no path from” <em>s</em> “to” <em>v</em> “exists”</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="noindent"><strong>else</strong> P<small>RINT</small>-P<small>ATH</small>(<em>G</em>, <em>s</em>, <em>v</em>.<em>π</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="p2">print <em>v</em></p></td>
</tr>
</table>
</div>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>20.2-1</em></strong></p>
<p class="noindent">Show the <em>d</em> and <em>π</em> values that result from running breadth-first search on the directed graph of <a href="chapter020.xhtml#Fig_20-2">Figure 20.2(a)</a>, using vertex 3 as the source.</p>
<p class="level3"><strong><em>20.2-2</em></strong></p>
<p class="noindent">Show the <em>d</em> and <em>π</em> values that result from running breadth-first search on the undirected graph of <a href="chapter020.xhtml#Fig_20-3">Figure 20.3</a>, using vertex <em>u</em> as the source. Assume that neighbors of a vertex are visited in alphabetical order.</p>
<p class="level3"><strong><em>20.2-3</em></strong></p>
<p class="noindent">Show that using a single bit to store each vertex color suffices by arguing that the BFS procedure produces the same result if line 18 is removed. Then show how to obviate the need for vertex colors altogether.</p>
<p class="level3"><strong><em>20.2-4</em></strong></p>
<p class="noindent">What is the running time of BFS if we represent its input graph by an adjacency matrix and modify the algorithm to handle this form of input?</p>
<a id="p563"/>
<p class="level3"><strong><em>20.2-5</em></strong></p>
<p class="noindent">Argue that in a breadth-first search, the value <em>u.d</em> assigned to a vertex <em>u</em> is independent of the order in which the vertices appear in each adjacency list. Using <a href="chapter020.xhtml#Fig_20-3">Figure 20.3</a> as an example, show that the breadth-first tree computed by BFS can depend on the ordering within adjacency lists.</p>
<p class="level3"><strong><em>20.2-6</em></strong></p>
<p class="noindent">Give an example of a directed graph <em>G</em> = (<em>V</em>, <em>E</em>), a source vertex <em>s</em> ∈ <em>V</em>, and a set of tree edges <em>E</em><sub><em>π</em></sub> ⊆ <em>E</em> such that for each vertex <em>v</em> ∈ <em>V</em>, the unique simple path in the graph (<em>V</em>, <em>E</em><sub><em>π</em></sub>) from <em>s</em> to <em>v</em> is a shortest path in <em>G</em>, yet the set of edges <em>E</em><sub><em>π</em></sub> cannot be produced by running BFS on <em>G</em>, no matter how the vertices are ordered in each adjacency list.</p>
<p class="level3"><strong><em>20.2-7</em></strong></p>
<p class="noindent">There are two types of professional wrestlers: “faces” (short for “babyfaces,” i.e., “good guys”) and “heels” (“bad guys”). Between any pair of professional wrestlers, there may or may not be a rivalry. You are given the names of <em>n</em> professional wrestlers and a list of <em>r</em> pairs of wrestlers for which there are rivalries. Give an <em>O</em>(<em>n</em> + <em>r</em>)-time algorithm that determines whether it is possible to designate some of the wrestlers as faces and the remainder as heels such that each rivalry is between a face and a heel. If it is possible to perform such a designation, your algorithm should produce it.</p>
<p class="level3"><span class="font1">★</span> <strong><em>20.2-8</em></strong></p>
<p class="noindent">The <span class="blue"><strong><em>diameter</em></strong></span> of a tree <em>T</em> = (<em>V</em>, <em>E</em>) is defined as max {δ(<em>u</em>, <em>v</em>) : <em>u</em>, <em>v</em> ∈ <em>V</em>}, that is, the largest of all shortest-path distances in the tree. Give an efficient algorithm to compute the diameter of a tree, and analyze the running time of your algorithm.</p>
</section>
<p class="line1"/>
<section title="20.3 Depth-first search">
<a id="Sec_20.3"/>
<p class="level1" id="h1-120"><a href="toc.xhtml#Rh1-120"><strong>20.3    Depth-first search</strong></a></p>
<p class="noindent">As its name implies, depth-first search searches “deeper” in the graph whenever possible. Depth-first search explores edges out of the most recently discovered vertex <em>v</em> that still has unexplored edges leaving it. Once all of <em>v</em>’s edges have been explored, the search “backtracks” to explore edges leaving the vertex from which <em>v</em> was discovered. This process continues until all vertices that are reachable from the original source vertex have been discovered. If any undiscovered vertices remain, then depth-first search selects one of them as a new source, repeating the search <a id="p564"/>from that source. The algorithm repeats this entire process until it has discovered every vertex.<sup><a epub:type="footnote" href="#footnote_3" id="footnote_ref_3">3</a></sup></p>
<p>As in breadth-first search, whenever depth-first search discovers a vertex <em>v</em> during a scan of the adjacency list of an already discovered vertex <em>u</em>, it records this event by setting <em>v</em>’s predecessor attribute <em>v</em>.<em>π</em> to <em>u</em>. Unlike breadth-first search, whose predecessor subgraph forms a tree, depth-first search produces a predecessor subgraph that might contain several trees, because the search may repeat from multiple sources. Therefore, we define the <span class="blue"><strong><em>predecessor subgraph</em></strong></span> of a depth-first search slightly differently from that of a breadth-first search: it always includes all vertices, and it accounts for multiple sources. Specifically, for a depth-first search the predecessor subgraph is <em>G</em><sub><em>π</em></sub> = (<em>V</em>, <em>E</em><sub><em>π</em></sub>), where</p>
<p class="eql"><em>E</em><sub><em>π</em></sub> = {(<em>v</em>.<em>π</em>, <em>v</em>) : <em>v</em> ∈ <em>V</em> and <em>v</em>.<em>π</em> ≠ <small>NIL</small>}.</p>
<p class="noindent">The predecessor subgraph of a depth-first search forms a <span class="blue"><strong><em>depth-first forest</em></strong></span> comprising several <span class="blue"><strong><em>depth-first trees</em></strong></span>. The edges in <em>E</em><sub><em>π</em></sub> are <span class="blue"><strong><em>tree edges</em></strong></span>.</p>
<p>Like breadth-first search, depth-first search colors vertices during the search to indicate their state. Each vertex is initially white, is grayed when it is <span class="blue"><strong><em>discovered</em></strong></span> in the search, and is blackened when it is <span class="blue"><strong><em>finished</em></strong></span>, that is, when its adjacency list has been examined completely. This technique guarantees that each vertex ends up in exactly one depth-first tree, so that these trees are disjoint.</p>
<p>Besides creating a depth-first forest, depth-first search also <span class="blue"><strong><em>timestamps</em></strong></span> each vertex. Each vertex <em>v</em> has two timestamps: the first timestamp <em>v.d</em> records when <em>v</em> is first discovered (and grayed), and the second timestamp <em>v.f</em> records when the search finishes examining <em>v</em>’s adjacency list (and blackens <em>v</em>). These timestamps provide important information about the structure of the graph and are generally helpful in reasoning about the behavior of depth-first search.</p>
<p>The procedure DFS on the facing page records when it discovers vertex <em>u</em> in the attribute <em>u.d</em> and when it finishes vertex <em>u</em> in the attribute <em>u.f</em>. These timestamps are integers between 1 and 2 |<em>V</em>|, since there is one discovery event and one finishing event for each of the |<em>V</em>| vertices. For every vertex <em>u</em>,</p>
<p class="eqr"><img alt="art" src="images/Art_P608.jpg"/></p>
<p class="noindent">Vertex <em>u</em> is <small>WHITE</small> before time <em>u.d</em>, <small>GRAY</small> between time <em>u.d</em> and time <em>u.f</em>, and <small>BLACK</small> thereafter. In the DFS procedure, the input graph <em>G</em> may be undirected or <a id="p565"/>directed. The variable <em>time</em> is a global variable used for timestamping. <a href="chapter020.xhtml#Fig_20-4">Figure 20.4</a> illustrates the progress of DFS on the graph shown in <a href="chapter020.xhtml#Fig_20-2">Figure 20.2</a> (but with vertices labeled by letters rather than numbers).</p>
<div class="pull-quote1">
<p class="box-heading">DFS(<em>G</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>u</em> ∈ <em>G.V</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="p2"><em>u.color</em> = <small>WHITE</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="p2"><em>u</em>.<em>π</em> = <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="noindent"><em>time</em> = 0</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>u</em> ∈ <em>G.V</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>u.color</em> == <small>WHITE</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="p3">DFS-V<small>ISIT</small>(<em>G</em>, <em>u</em>)</p></td>
</tr>
<tr>
<td class="td1" colspan="2"><p class="box-headinga">DFS-V<small>ISIT</small>(<em>G</em>, <em>u</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><em>time</em> = <em>time</em> + 1</p></td>
<td class="td1"><p class="noindent"><span class="red">// white vertex <em>u</em> has just been discovered</span></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="noindent"><em>u.d</em> = <em>time</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="noindent"><em>u.color</em> = <small>GRAY</small></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>v</em> in <em>G.Adj</em>[<em>u</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red">// explore each edge (<em>u</em>, <em>v</em>)</span></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>v.color</em> == <small>WHITE</small></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="p3"><em>v</em>.<em>π</em> = <em>u</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="p3">DFS-V<small>ISIT</small>(<em>G</em>, <em>v</em>)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="noindent"><em>time</em> = <em>time</em> + 1</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="noindent"><em>u.f</em> = <em>time</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><em>u.color</em> = <small>BLACK</small></td>
<td class="td1"><p class="noindent"><span class="red">// blacken <em>u</em>; it is finished</span></p></td>
</tr>
</table>
</div>
<p>The DFS procedure works as follows. Lines 1–3 paint all vertices white and initialize their <em>π</em> attributes to <small>NIL</small>. Line 4 resets the global time counter. Lines 5–7 check each vertex in <em>V</em> in turn and, when a white vertex is found, visit it by calling DFS-V<small>ISIT</small>. Upon every call of DFS-V<small>ISIT</small>(<em>G</em>, <em>u</em>) in line 7, vertex <em>u</em> becomes the root of a new tree in the depth-first forest. When DFS returns, every vertex <em>u</em> has been assigned a <span class="blue"><strong><em>discovery time</em></strong></span> <em>u.d</em> and a <span class="blue"><strong><em>finish time</em></strong></span> <em>u.f</em>.</p>
<p>In each call DFS-V<small>ISIT</small>(<em>G</em>, <em>u</em>), vertex <em>u</em> is initially white. Lines 1–3 increment the global variable <em>time</em>, record the new value of <em>time</em> as the discovery time <em>u.d</em>, and paint <em>u</em> gray. Lines 4–7 examine each vertex <em>v</em> adjacent to <em>u</em> and recursively visit <em>v</em> if it is white. As line 4 considers each vertex <em>v</em> ∈ <em>Adj</em>[<em>u</em>], the depth-first search <span class="blue"><strong><em>explores</em></strong></span> edge (<em>u</em>, <em>v</em>). Finally, after every edge leaving <em>u</em> has been explored, lines 8–10 increment <em>time</em>, record the finish time in <em>u.f</em>, and paint <em>u</em> black.</p>
<p>The results of depth-first search may depend upon the order in which line 5 of DFS examines the vertices and upon the order in which line 4 of DFS-V<small>ISIT</small> visits the neighbors of a vertex. These different visitation orders tend not to cause problems in practice, because many applications of depth-first search can use the result from any depth-first search.</p>
<a id="p566"/>
<div class="divimage">
<p class="fig-imga" id="Fig_20-4"><img alt="art" src="images/Art_P609.jpg"/></p>
<p class="caption"><strong>Figure 20.4</strong> The progress of the depth-first-search algorithm DFS on a directed graph. Edges are classified as they are explored: tree edges are labeled T, back edges B, forward edges F, and cross edges <em>C</em>. Timestamps within vertices indicate discovery time/finish times. Tree edges are highlighted in blue. Orange highlights indicate vertices whose discovery or finish times change and edges that are explored in each step.</p>
</div>
<p>What is the running time of DFS? The loops on lines 1–3 and lines 5–7 of DFS take Θ(<em>V</em>) time, exclusive of the time to execute the calls to DFS-V<small>ISIT</small>. As we did for breadth-first search, we use aggregate analysis. The procedure DFS-V<small>ISIT</small> is called exactly once for each vertex <em>v</em> ∈ <em>V</em>, since the vertex <em>u</em> on which DFS-V<small>ISIT</small> is invoked must be white and the first thing DFS-V<small>ISIT</small> does is paint vertex <em>u</em> gray. During an execution of DFS-V<small>ISIT</small>(<em>G</em>, <em>v</em>), the loop in lines 4–7 executes |<em>Adj</em>[<em>v</em>]| times. Since Σ<sub><em>v</em>∈<em>V</em></sub> |<em>Adj</em>[<em>v</em>]| = Θ(<em>E</em>) and DFS-V<small>ISIT</small> is called once per vertex, the <a id="p567"/>total cost of executing lines 4–7 of DFS-V<small>ISIT</small> is Θ(<em>V</em> + <em>E</em>). The running time of DFS is therefore Θ(<em>V</em> + <em>E</em>).</p>
<p class="level4"><strong>Properties of depth-first search</strong></p>
<p class="noindent">Depth-first search yields valuable information about the structure of a graph. Perhaps the most basic property of depth-first search is that the predecessor subgraph <em>G</em><sub><em>π</em></sub> does indeed form a forest of trees, since the structure of the depth-first trees exactly mirrors the structure of recursive calls of DFS-V<small>ISIT</small>. That is, <em>u</em> = <em>v</em>.<em>π</em> if and only if DFS-V<small>ISIT</small>(<em>G</em>, <em>v</em>) was called during a search of <em>u</em>’s adjacency list. Additionally, vertex <em>v</em> is a descendant of vertex <em>u</em> in the depth-first forest if and only if <em>v</em> is discovered during the time in which <em>u</em> is gray.</p>
<p>Another important property of depth-first search is that discovery and finish times have <span class="blue"><strong><em>parenthesis structure</em></strong></span>. If the DFS-V<small>ISIT</small> procedure were to print a left parenthesis “(<em>u</em>” when it discovers vertex <em>u</em> and to print a right parenthesis “<em>u</em>)” when it finishes <em>u</em>, then the printed expression would be well formed in the sense that the parentheses are properly nested. For example, the depth-first search of <a href="chapter020.xhtml#Fig_20-5">Figure 20.5(a)</a> corresponds to the parenthesization shown in <a href="chapter020.xhtml#Fig_20-5">Figure 20.5(b)</a>. The following theorem provides another way to characterize the parenthesis structure.</p>
<p class="theo"><strong><em>Theorem 20.7 (Parenthesis theorem)</em></strong></p>
<p class="noindent">In any depth-first search of a (directed or undirected) graph <em>G</em> = (<em>V</em>, <em>E</em>), for any two vertices <em>u</em> and <em>v</em>, exactly one of the following three conditions holds:</p>
<ul class="ulnoindent" epub:type="list">
<li>the intervals [<em>u.d</em>, <em>u.f</em>] and [<em>v.d</em>, <em>v.f</em>] are entirely disjoint, and neither <em>u</em> nor <em>v</em> is a descendant of the other in the depth-first forest,</li>
<li class="litop">the interval [<em>u.d</em>, <em>u.f</em>] is contained entirely within the interval [<em>v.d</em>, <em>v.f</em>], and <em>u</em> is a descendant of <em>v</em> in a depth-first tree, or</li>
<li class="litop">the interval [<em>v.d</em>, <em>v.f</em>] is contained entirely within the interval [<em>u.d</em>, <em>u.f</em>], and <em>v</em> is a descendant of <em>u</em> in a depth-first tree.</li></ul>
<p class="prof"><strong><em>Proof</em></strong>   We begin with the case in which <em>u.d</em> &lt; <em>v.d</em>. We consider two subcases, according to whether <em>v.d</em> &lt; <em>u.f</em>. The first subcase occurs when <em>v.d</em> &lt; <em>u.f</em>, so that <em>v</em> was discovered while <em>u</em> was still gray, which implies that <em>v</em> is a descendant of <em>u</em>. Moreover, since <em>v</em> was discovered after <em>u</em>, all of its outgoing edges are explored, and <em>v</em> is finished, before the search returns to and finishes <em>u</em>. In this case, therefore, the interval [<em>v.d</em>, <em>v.f</em>] is entirely contained within the interval [<em>u.d</em>, <em>u.f</em>]. In the other subcase, <em>u.f</em> &lt; <em>v.d</em>, and by inequality (20.4), <em>u.d</em> &lt; <em>u.f</em> &lt; <em>v.d</em> &lt; <em>v.f</em>, and thus the intervals [<em>u.d</em>, <em>u.f</em>] and [<em>v.d</em>, <em>v.f</em>] are disjoint. Because the intervals are disjoint, neither vertex was discovered while the other was gray, and so neither vertex is a descendant of the other.</p>
<a id="p568"/>
<div class="divimage">
<p class="fig-imga" id="Fig_20-5"><img alt="art" src="images/Art_P610.jpg"/></p>
<p class="caption"><strong>Figure 20.5</strong> Properties of depth-first search. <strong>(a)</strong> The result of a depth-first search of a directed graph. Vertices are timestamped and edge types are indicated as in <a href="chapter020.xhtml#Fig_20-4">Figure 20.4</a>. <strong>(b)</strong> Intervals for the discovery time and finish time of each vertex correspond to the parenthesization shown. Each rectangle spans the interval given by the discovery and finish times of the corresponding vertex. Only tree edges are shown. If two intervals overlap, then one is nested within the other, and the vertex corresponding to the smaller interval is a descendant of the vertex corresponding to the larger. <strong>(c)</strong> The graph of part (a) redrawn with all tree and forward edges going down within a depth-first tree and all back edges going up from a descendant to an ancestor.</p>
</div>
<p>The case in which <em>v.d</em> &lt; <em>u.d</em> is similar, with the roles of <em>u</em> and <em>v</em> reversed in the above argument.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 20.8 (Nesting of descendants’ intervals)</em></strong></p>
<p class="noindent">Vertex <em>v</em> is a proper descendant of vertex <em>u</em> in the depth-first forest for a (directed or undirected) graph <em>G</em> if and only if <em>u.d</em> &lt; <em>v.d</em> &lt; <em>v.f</em> &lt; <em>u.f</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   Immediate from Theorem 20.7.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The next theorem gives another important characterization of when one vertex is a descendant of another in the depth-first forest.</p>
<a id="p569"/>
<p class="theo"><strong><em>Theorem 20.9 (White-path theorem)</em></strong></p>
<p class="noindent">In a depth-first forest of a (directed or undirected) graph <em>G</em> = (<em>V</em>, <em>E</em>), vertex <em>v</em> is a descendant of vertex <em>u</em> if and only if at the time <em>u.d</em> that the search discovers <em>u</em>, there is a path from <em>u</em> to <em>v</em> consisting entirely of white vertices.</p>
<p class="prof"><strong><em>Proof</em></strong>   ⇒: If <em>v</em> = <em>u</em>, then the path from <em>u</em> to <em>v</em> contains just vertex <em>u</em>, which is still white when <em>u.d</em> receives a value. Now, suppose that <em>v</em> is a proper descendant of <em>u</em> in the depth-first forest. By Corollary 20.8, <em>u.d</em> &lt; <em>v.d</em>, and so <em>v</em> is white at time <em>u.d</em>. Since <em>v</em> can be any descendant of <em>u</em>, all vertices on the unique simple path from <em>u</em> to <em>v</em> in the depth-first forest are white at time <em>u.d</em>.</p>
<p>⇐: Suppose that there is a path of white vertices from <em>u</em> to <em>v</em> at time <em>u.d</em>, but <em>v</em> does not become a descendant of <em>u</em> in the depth-first tree. Without loss of generality, assume that every vertex other than <em>v</em> along the path becomes a descendant of <em>u</em>. (Otherwise, let <em>v</em> be the closest vertex to <em>u</em> along the path that doesn’t become a descendant of <em>u</em>.) Let <em>w</em> be the predecessor of <em>v</em> in the path, so that <em>w</em> is a descendant of <em>u</em> (<em>w</em> and <em>u</em> may in fact be the same vertex). By Corollary 20.8, <em>w.f</em> ≤ <em>u.f</em>. Because <em>v</em> must be discovered after <em>u</em> is discovered, but before <em>w</em> is finished, <em>u.d</em> &lt; <em>v.d</em> &lt; <em>w.f</em> ≤ <em>u.f</em>. Theorem 20.7 then implies that the interval [<em>v.d</em>, <em>v.f</em>] is contained entirely within the interval [<em>u.d</em>, <em>u.f</em>]. By Corollary 20.8, <em>v</em> must after all be a descendant of <em>u</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Classification of edges</strong></p>
<p class="noindent">You can obtain important information about a graph by classifying its edges during a depth-first search. For example, <a href="chapter020.xhtml#Sec_20.4">Section 20.4</a> will show that a directed graph is acyclic if and only if a depth-first search yields no “back” edges (Lemma 20.11).</p>
<p>The depth-first forest <em>G</em><sub><em>π</em></sub> produced by a depth-first search on graph <em>G</em> can contain four types of edges:</p>
<ol class="olnoindent" epub:type="list">
<li><span class="blue"><strong><em>Tree edges</em></strong></span> are edges in the depth-first forest <em>G</em><sub><em>π</em></sub>. Edge (<em>u</em>, <em>v</em>) is a tree edge if <em>v</em> was first discovered by exploring edge (<em>u</em>, <em>v</em>).</li>
<li class="litop"><span class="blue"><strong><em>Back edges</em></strong></span> are those edges (<em>u</em>, <em>v</em>) connecting a vertex <em>u</em> to an ancestor <em>v</em> in a depth-first tree. We consider self-loops, which may occur in directed graphs, to be back edges.</li>
<li class="litop"><span class="blue"><strong><em>Forward edges</em></strong></span> are those nontree edges (<em>u</em>, <em>v</em>) connecting a vertex <em>u</em> to a proper descendant <em>v</em> in a depth-first tree.</li>
<li class="litop"><span class="blue"><strong><em>Cross edges</em></strong></span> are all other edges. They can go between vertices in the same depth-first tree, as long as one vertex is not an ancestor of the other, or they can go between vertices in different depth-first trees.</li></ol>
<a id="p570"/>
<p class="noindent">In <a href="chapter020.xhtml#Fig_20-4">Figures 20.4</a> and <a href="chapter020.xhtml#Fig_20-5">20.5</a>, edge labels indicate edge types. <a href="chapter020.xhtml#Fig_20-5">Figure 20.5(c)</a> also shows how to redraw the graph of <a href="chapter020.xhtml#Fig_20-5">Figure 20.5(a)</a> so that all tree and forward edges head downward in a depth-first tree and all back edges go up. You can redraw any graph in this fashion.</p>
<p>The DFS algorithm has enough information to classify some edges as it encounters them. The key idea is that when an edge (<em>u</em>, <em>v</em>) is first explored, the color of vertex <em>v</em> says something about the edge:</p>
<ol class="olnoindent" epub:type="list">
<li><small>WHITE</small> indicates a tree edge,</li>
<li class="litop"><small>GRAY</small> indicates a back edge, and</li>
<li class="litop"><small>BLACK</small> indicates a forward or cross edge.</li></ol>
<p class="noindent">The first case is immediate from the specification of the algorithm. For the second case, observe that the gray vertices always form a linear chain of descendants corresponding to the stack of active DFS-V<small>ISIT</small> invocations. The number of gray vertices is 1 more than the depth in the depth-first forest of the vertex most recently discovered. Depth-first search always explores from the deepest gray vertex, so that an edge that reaches another gray vertex has reached an ancestor. The third case handles the remaining possibility. Exercise 20.3-5 asks you to show that such an edge (<em>u</em>, <em>v</em>) is a forward edge if <em>u.d</em> &lt; <em>v.d</em> and a cross edge if <em>u.d</em> &gt; <em>v.d</em>.</p>
<p>According to the following theorem, forward and cross edges never occur in a depth-first search of an undirected graph.</p>
<p class="theo"><strong><em>Theorem 20.10</em></strong></p>
<p class="noindent">In a depth-first search of an undirected graph <em>G</em>, every edge of <em>G</em> is either a tree edge or a back edge.</p>
<p class="prof"><strong><em>Proof</em></strong>   Let (<em>u</em>, <em>v</em>) be an arbitrary edge of <em>G</em>, and suppose without loss of generality that <em>u.d</em> &lt; <em>v.d</em>. Then, while <em>u</em> is gray, the search must discover and finish <em>v</em> before it finishes <em>u</em>, since <em>v</em> is on u’s adjacency list. If the first time that the search explores edge (<em>u</em>, <em>v</em>), it is in the direction from <em>u</em> to <em>v</em>, then <em>v</em> is undiscovered (white) until that time, for otherwise the search would have explored this edge already in the direction from <em>v</em> to <em>u</em>. Thus, (<em>u</em>, <em>v</em>) becomes a tree edge. If the search explores (<em>u</em>, <em>v</em>) first in the direction from <em>v</em> to <em>u</em>, then (<em>u</em>, <em>v</em>) is a back edge, since there must be a path of tree edges from <em>u</em> to <em>v</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Since (<em>u</em>, <em>v</em>) and (<em>v</em>, <em>u</em>) are really the same edge in an undirected graph, the proof of Theorem 20.10 says how to classify the edge. When searching from a vertex, which must be gray, if the adjacent vertex is white, then the edge is a tree edge. Otherwise, the edge is a back edge.</p>
<p>The next two sections apply the above theorems about depth-first search.</p>
<a id="p571"/>
<div class="divimage">
<p class="fig-imga" id="Fig_20-6"><img alt="art" src="images/Art_P611.jpg"/></p>
<p class="caption"><strong>Figure 20.6</strong> A directed graph for use in Exercises 20.3-2 and 20.5-2.</p>
</div>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>20.3-1</em></strong></p>
<p class="noindent">Make a 3-by-3 chart with row and column labels <small>WHITE</small>, <small>GRAY</small>, and <small>BLACK</small>. In each cell (<em>i</em>, <em>j</em>), indicate whether, at any point during a depth-first search of a directed graph, there can be an edge from a vertex of color <em>i</em> to a vertex of color <em>j</em>. For each possible edge, indicate what edge types it can be. Make a second such chart for depth-first search of an undirected graph.</p>
<p class="level3"><strong><em>20.3-2</em></strong></p>
<p class="noindent">Show how depth-first search works on the graph of <a href="chapter020.xhtml#Fig_20-6">Figure 20.6</a>. Assume that the <strong>for</strong> loop of lines 5–7 of the DFS procedure considers the vertices in alphabetical order, and assume that each adjacency list is ordered alphabetically. Show the discovery and finish times for each vertex, and show the classification of each edge.</p>
<p class="level3"><strong><em>20.3-3</em></strong></p>
<p class="noindent">Show the parenthesis structure of the depth-first search of <a href="chapter020.xhtml#Fig_20-4">Figure 20.4</a>.</p>
<p class="level3"><strong><em>20.3-4</em></strong></p>
<p class="noindent">Show that using a single bit to store each vertex color suffices by arguing that the DFS procedure produces the same result if line 10 of DFS-V<small>ISIT</small> is removed.</p>
<p class="level3"><strong><em>20.3-5</em></strong></p>
<p class="noindent">Show that in a directed graph, edge (<em>u</em>, <em>v</em>) is</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> a tree edge or forward edge if and only if <em>u.d</em> &lt; <em>v.d</em> &lt; <em>v.f</em> &lt; <em>u.f</em>,</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> a back edge if and only if <em>v.d</em> ≤ <em>u.d</em> &lt; <em>u.f</em> ≤ <em>v.f</em>, and</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> a cross edge if and only if <em>v.d</em> &lt; <em>v.f</em> &lt; <em>u.d</em> &lt; <em>u.f</em>.</p>
<a id="p572"/>
<p class="level3"><strong><em>20.3-6</em></strong></p>
<p class="noindent">Rewrite the procedure DFS, using a stack to eliminate recursion.</p>
<p class="level3"><strong><em>20.3-7</em></strong></p>
<p class="noindent">Give a counterexample to the conjecture that if a directed graph <em>G</em> contains a path from <em>u</em> to <em>v</em>, and if <em>u.d</em> &lt; <em>v.d</em> in a depth-first search of <em>G</em>, then <em>v</em> is a descendant of <em>u</em> in the depth-first forest produced.</p>
<p class="level3"><strong><em>20.3-8</em></strong></p>
<p class="noindent">Give a counterexample to the conjecture that if a directed graph <em>G</em> contains a path from <em>u</em> to <em>v</em>, then any depth-first search must result in <em>v.d</em> ≤ <em>u.f</em>.</p>
<p class="level3"><strong><em>20.3-9</em></strong></p>
<p class="noindent">Modify the pseudocode for depth-first search so that it prints out every edge in the directed graph <em>G</em>, together with its type. Show what modifications, if any, you need to make if <em>G</em> is undirected.</p>
<p class="level3"><strong><em>20.3-10</em></strong></p>
<p class="noindent">Explain how a vertex <em>u</em> of a directed graph can end up in a depth-first tree containing only <em>u</em>, even though <em>u</em> has both incoming and outgoing edges in <em>G</em>.</p>
<p class="level3"><strong><em>20.3-11</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a connected, undirected graph. Give an <em>O</em>(<em>V</em> + <em>E</em>)-time algorithm to compute a path in <em>G</em> that traverses each edge in <em>E</em> exactly once in each direction. Describe how you can find your way out of a maze if you are given a large supply of pennies.</p>
<p class="level3"><strong><em>20.3-12</em></strong></p>
<p class="noindent">Show how to use a depth-first search of an undirected graph <em>G</em> to identify the connected components of <em>G</em>, so that the depth-first forest contains as many trees as <em>G</em> has connected components. More precisely, show how to modify depth-first search so that it assigns to each vertex <em>v</em> an integer label <em>v.cc</em> between 1 and <em>k</em>, where <em>k</em> is the number of connected components of <em>G</em>, such that <em>u.cc</em> = <em>v.cc</em> if and only if <em>u</em> and <em>v</em> belong to the same connected component.</p>
<p class="level3"><span class="font1">★</span> <strong><em>20.3-13</em></strong></p>
<p class="noindent">A directed graph <em>G</em> = (<em>V</em>, <em>E</em>) is <span class="blue"><strong><em>singly connected</em></strong></span> if <em>u</em> <span class="font1">⇝</span> <em>v</em> implies that <em>G</em> contains at most one simple path from <em>u</em> to <em>v</em> for all vertices <em>u</em>, <em>v</em> ∈ <em>V</em>. Give an efficient algorithm to determine whether a directed graph is singly connected.</p>
<a id="p573"/>
</section>
<p class="line1"/>
<section title="20.4 Topological sort">
<a id="Sec_20.4"/>
<p class="level1" id="h1-121"><a href="toc.xhtml#Rh1-121"><strong>20.4    Topological sort</strong></a></p>
<p class="noindent">This section shows how to use depth-first search to perform a topological sort of a directed acyclic graph, or a “dag” as it is sometimes called. A <span class="blue"><strong><em>topological sort</em></strong></span> of a dag <em>G</em> = (<em>V</em>, <em>E</em>) is a linear ordering of all its vertices such that if <em>G</em> contains an edge (<em>u</em>, <em>v</em>), then <em>u</em> appears before <em>v</em> in the ordering. Topological sorting is defined only on directed graphs that are acyclic; no linear ordering is possible when a directed graph contains a cycle. Think of a topological sort of a graph as an ordering of its vertices along a horizontal line so that all directed edges go from left to right. Topological sorting is thus different from the usual kind of “sorting” studied in <a href="part002.xhtml">Part II</a>.</p>
<p>Many applications use directed acyclic graphs to indicate precedences among events. <a href="chapter020.xhtml#Fig_20-7">Figure 20.7</a> gives an example that arises when Professor Bumstead gets dressed in the morning. The professor must don certain garments before others (e.g., socks before shoes). Other items may be put on in any order (e.g., socks and pants). A directed edge (<em>u</em>, <em>v</em>) in the dag of <a href="chapter020.xhtml#Fig_20-7">Figure 20.7(a)</a> indicates that garment <em>u</em> must be donned before garment <em>v</em>. A topological sort of this dag therefore gives a possible order for getting dressed. <a href="chapter020.xhtml#Fig_20-7">Figure 20.7(b)</a> shows the topologically sorted dag as an ordering of vertices along a horizontal line such that all directed edges go from left to right.</p>
<p>The procedure T<small>OPOLOGICAL</small>-S<small>ORT</small> topologically sorts a dag. <a href="chapter020.xhtml#Fig_20-7">Figure 20.7(b)</a> shows how the topologically sorted vertices appear in reverse order of their finish times.</p>
<div class="pull-quote1">
<p class="box-heading">T<small>OPOLOGICAL</small>-S<small>ORT</small>(<em>G</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1">call DFS(<em>G</em>) to compute finish times <em>v.f</em> for each vertex <em>v</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1">as each vertex is finished, insert it onto the front of a linked list</td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><strong>return</strong> the linked list of vertices</td>
</tr>
</table>
</div>
<p>The T<small>OPOLOGICAL</small>-S<small>ORT</small> procedure runs in Θ(<em>V</em> + <em>E</em>) time, since depth-first search takes Θ(<em>V</em> + <em>E</em>) time and it takes <em>O</em>(1) time to insert each of the |<em>V</em>| vertices onto the front of the linked list.</p>
<p>To prove the correctness of this remarkably simple and efficient algorithm, we start with the following key lemma characterizing directed acyclic graphs.</p>
<p class="lem"><strong><em>Lemma 20.11</em></strong></p>
<p class="noindent">A directed graph <em>G</em> is acyclic if and only if a depth-first search of <em>G</em> yields no back edges.</p>
<a id="p574"/>
<div class="divimage">
<p class="fig-imga" id="Fig_20-7"><img alt="art" src="images/Art_P612.jpg"/></p>
<p class="caption"><strong>Figure 20.7 (a)</strong> Professor Bumstead topologically sorts his clothing when getting dressed. Each directed edge (<em>u</em>, <em>v</em>) means that garment <em>u</em> must be put on before garment <em>v</em>. The discovery and finish times from a depth-first search are shown next to each vertex. <strong>(b)</strong> The same graph shown topologically sorted, with its vertices arranged from left to right in order of decreasing finish time. All directed edges go from left to right.</p>
</div>
<p class="prof"><strong><em>Proof</em></strong>   ⇒: Suppose that a depth-first search produces a back edge (<em>u</em>, <em>v</em>). Then vertex <em>v</em> is an ancestor of vertex <em>u</em> in the depth-first forest. Thus, <em>G</em> contains a path from <em>v</em> to <em>u</em>, and the back edge (<em>u</em>, <em>v</em>) completes a cycle.</p>
<p>⇐: Suppose that <em>G</em> contains a cycle <em>c</em>. We show that a depth-first search of <em>G</em> yields a back edge. Let <em>v</em> be the first vertex to be discovered in <em>c</em>, and let (<em>u</em>, <em>v</em>) be the preceding edge in <em>c</em>. At time <em>v.d</em>, the vertices of c form a path of white vertices from <em>v</em> to <em>u</em>. By the white-path theorem, vertex <em>u</em> becomes a descendant of <em>v</em> in the depth-first forest. Therefore, (<em>u</em>, <em>v</em>) is a back edge.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="theo"><strong><em>Theorem 20.12</em></strong></p>
<p class="noindent">T<small>OPOLOGICAL</small>-S<small>ORT</small> produces a topological sort of the directed acyclic graph provided as its input.</p>
<p class="prof"><strong><em>Proof</em></strong>   Suppose that DFS is run on a given dag <em>G</em> = (<em>V</em>, <em>E</em>) to determine finish times for its vertices. It suffices to show that for any pair of distinct vertices <em>u</em>, <em>v</em> ∈ <em>V</em>, if <em>G</em> contains an edge from <em>u</em> to <em>v</em>, then <em>v.f</em> &lt; <em>u.f</em>. Consider any edge (<em>u</em>, <em>v</em>) explored by DFS(<em>G</em>). When this edge is explored, <em>v</em> cannot be gray, since then <em>v</em> would be an ancestor of <em>u</em> and (<em>u</em>, <em>v</em>) would be a back edge, contradicting Lemma 20.11. Therefore, <em>v</em> must be either white or black. If <em>v</em> is <a id="p575"/>white, it becomes a descendant of <em>u</em>, and so <em>v.f</em> &lt; <em>u.f</em>. If <em>v</em> is black, it has already been finished, so that <em>v.f</em> has already been set. Because the search is still exploring from <em>u</em>, it has yet to assign a timestamp to <em>u.f</em>, so that the timestamp eventually assigned to <em>u.f</em> is greater than <em>v.f</em>. Thus, <em>v.f</em> &lt; <em>u.f</em> for any edge (<em>u</em>, <em>v</em>) in the dag, proving the theorem.</p>
<p class="right"><span class="font1">▪</span></p>
<div class="divimage">
<p class="fig-imga" id="Fig_20-8"><img alt="art" src="images/Art_P613.jpg"/></p>
<p class="caption"><strong>Figure 20.8</strong> A dag for topological sorting.</p>
</div>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>20.4-1</em></strong></p>
<p class="noindent">Show the ordering of vertices produced by T<small>OPOLOGICAL</small>-S<small>ORT</small> when it is run on the dag of <a href="chapter020.xhtml#Fig_20-8">Figure 20.8</a>. Assume that the <strong>for</strong> loop of lines 5–7 of the DFS procedure considers the vertices in alphabetical order, and assume that each adjacency list is ordered alphabetically.</p>
<p class="level3"><strong><em>20.4-2</em></strong></p>
<p class="noindent">Give a linear-time algorithm that, given a directed acyclic graph <em>G</em> = (<em>V</em>, <em>E</em>) and two vertices <em>a</em>, <em>b</em> ∈ <em>V</em>, returns the number of simple paths from <em>a</em> to <em>b</em> in <em>G</em>. For example, the directed acyclic graph of <a href="chapter020.xhtml#Fig_20-8">Figure 20.8</a> contains exactly four simple paths from vertex <em>p</em> to vertex <em>v</em>: <span class="font1">〈</span><em>p</em>, <em>o</em>, <em>v</em><span class="font1">〉</span>, <span class="font1">〈</span><em>p</em>, <em>o</em>, <em>r</em>, <em>y</em>, <em>v</em><span class="font1">〉</span>, <span class="font1">〈</span><em>p</em>, <em>o</em>, <em>s</em>, <em>r</em>, <em>y</em>, <em>v</em><span class="font1">〉</span>, and <span class="font1">〈</span><em>p</em>, <em>s</em>, <em>r</em>, <em>y</em>, <em>v</em><span class="font1">〉</span>. Your algorithm needs only to count the simple paths, not list them.</p>
<p class="level3"><strong><em>20.4-3</em></strong></p>
<p class="noindent">Give an algorithm that determines whether an undirected graph <em>G</em> = (<em>V</em>, <em>E</em>) contains a simple cycle. Your algorithm should run in <em>O</em>(<em>V</em>) time, independent of |<em>E</em>|.</p>
<p class="level3"><strong><em>20.4-4</em></strong></p>
<p class="noindent">Prove or disprove: If a directed graph <em>G</em> contains cycles, then the vertex ordering produced by T<small>OPOLOGICAL</small>-S<small>ORT</small>(<em>G</em>) minimizes the number of “bad” edges that are inconsistent with the ordering produced.</p>
<a id="p576"/>
<p class="level3"><strong><em>20.4-5</em></strong></p>
<p class="noindent">Another way to topologically sort a directed acyclic graph <em>G</em> = (<em>V</em>, <em>E</em>) is to repeatedly find a vertex of in-degree 0, output it, and remove it and all of its outgoing edges from the graph. Explain how to implement this idea so that it runs in time <em>O</em>(<em>V</em> + <em>E</em>). What happens to this algorithm if <em>G</em> has cycles?</p>
</section>
<p class="line1"/>
<section title="20.5 Strongly connected components">
<a id="Sec_20.5"/>
<p class="level1" id="h1-122"><a href="toc.xhtml#Rh1-122"><strong>20.5    Strongly connected components</strong></a></p>
<p class="noindent">We now consider a classic application of depth-first search: decomposing a directed graph into its strongly connected components. This section shows how to do so using two depth-first searches. Many algorithms that work with directed graphs begin with such a decomposition. After decomposing the graph into strongly connected components, such algorithms run separately on each one and then combine the solutions according to the structure of connections among components.</p>
<p>Recall from <a href="appendix002.xhtml">Appendix B</a> that a strongly connected component of a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) is a maximal set of vertices <em>C</em> ⊆ <em>V</em> such that for every pair of vertices <em>u</em>, <em>v</em> ∈ <em>C</em>, both <em>u</em> <span class="font1">⇝</span> <em>v</em> and <em>v</em> <span class="font1">⇝</span> <em>u</em>, that is, vertices <em>u</em> and <em>v</em> are reachable from each other. <a href="chapter020.xhtml#Fig_20-9">Figure 20.9</a> shows an example.</p>
<p>The algorithm for finding the strongly connected components of a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) uses the transpose of <em>G</em>, which we defined in Exercise 20.1-3 to be the graph <em>G</em><sup>T</sup> = (<em>V</em>, <em>E</em><sup>T</sup>), where <em>E</em><sup>T</sup> = {(<em>u</em>, <em>v</em>) : (<em>v</em>, <em>u</em>) ∈ <em>E</em>}. That is, <em>E</em><sup>T</sup> consists of the edges of <em>G</em> with their directions reversed. Given an adjacency-list representation of <em>G</em>, the time to create <em>G</em><sup>T</sup> is Θ(<em>V</em> + <em>E</em>). The graphs <em>G</em> and <em>G</em><sup>T</sup> have exactly the same strongly connected components: <em>u</em> and <em>v</em> are reachable from each other in <em>G</em> if and only if they are reachable from each other in <em>G</em><sup>T</sup>. <a href="chapter020.xhtml#Fig_20-9">Figure 20.9(b)</a> shows the transpose of the graph in <a href="chapter020.xhtml#Fig_20-9">Figure 20.9(a)</a>, with the strongly connected components shaded blue in both parts.</p>
<p>The linear-time (i.e., Θ(<em>V</em> + <em>E</em>)-time) procedure S<small>TRONGLY</small>-C<small>ONNECTED</small>-C<small>OMPONENTS</small> on the next page computes the strongly connected components of a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) using two depth-first searches, one on <em>G</em> and one on <em>G</em><sup>T</sup>.</p>
<p>The idea behind this algorithm comes from a key property of the <span class="blue"><strong><em>component graph</em></strong></span> <em>G</em><sup>SCC</sup> = (<em>V</em><sup>SCC</sup>, <em>E</em><sup>SCC</sup>), defined as follows. Suppose that <em>G</em> has strongly connected components <em>C</em><sub>1</sub>, <em>C</em><sub>2</sub>, … , <em>C<sub>k</sub></em>. The vertex set <em>V</em><sup>SCC</sup> is {<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, … , <em>v<sub>k</sub></em>}, and it contains one vertex <em>v<sub>i</sub></em> for each strongly connected component <em>C<sub>i</sub></em> of <em>G</em>. There is an edge (<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>) ∈ <em>E</em><sup>SCC</sup> if <em>G</em> contains a directed edge (<em>x</em>, <em>y</em>) for some <em>x</em> ∈ <em>C<sub>i</sub></em> and some <em>y</em> ∈ <em>C<sub>j</sub></em>. Looked at another way, if we contract all edges whose incident vertices are within the same strongly connected component of <em>G</em> so that <a id="p577"/>only a single vertex remains, the resulting graph is <em>G</em><sup>SCC</sup>. <a href="chapter020.xhtml#Fig_20-9">Figure 20.9(c)</a> shows the component graph of the graph in <a href="chapter020.xhtml#Fig_20-9">Figure 20.9(a)</a>.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_20-9"><img alt="art" src="images/Art_P614.jpg"/></p>
<p class="caption"><strong>Figure 20.9 (a)</strong> A directed graph <em>G</em>. Each region shaded light blue is a strongly connected component of <em>G</em>. Each vertex is labeled with its discovery and finish times in a depth-first search, and tree edges are dark blue. <strong>(b)</strong> The graph <em>G</em><sup>T</sup>, the transpose of <em>G</em>, with the depth-first forest computed in line 3 of S<small>TRONGLY</small>-C<small>ONNECTED</small>-C<small>OMPONENTS</small> shown and tree edges shaded dark blue. Each strongly connected component corresponds to one depth-first tree. Orange vertices <em>b</em>, <em>c</em>, <em>g</em>, and <em>h</em> are the roots of the depth-first trees produced by the depth-first search of <em>G</em><sup>T</sup>. <strong>(c)</strong> The acyclic component graph <em>G</em><sup>SCC</sup> obtained by contracting all edges within each strongly connected component of <em>G</em> so that only a single vertex remains in each component.</p>
</div>
<div class="pull-quote1">
<p class="box-heading">S<small>TRONGLY</small>-C<small>ONNECTED</small>-C<small>OMPONENTS</small>(<em>G</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="pqph-d">call DFS(<em>G</em>) to compute finish times <em>u.f</em> for each vertex <em>u</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="pqph-d">create <em>G</em><sup>T</sup></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="pqph-d">call DFS(<em>G</em><sup>T</sup>), but in the main loop of DFS, consider the vertices in order of decreasing <em>u.f</em> (as computed in line 1)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="pqph-d">output the vertices of each tree in the depth-first forest formed in line 3 as a separate strongly connected component</p></td>
</tr>
</table>
</div>
<p>The following lemma gives the key property that the component graph is acyclic. We’ll see that the algorithm uses this property to visit the vertices of the component graph in topologically sorted order, by considering vertices in the second depth-first search in decreasing order of the finish times that were computed in the first depth-first search.</p>
<a id="p578"/>
<p class="lem"><strong><em>Lemma 20.13</em></strong></p>
<p class="noindent">Let <em>C</em> and <em>C</em>′ be distinct strongly connected components in directed graph <em>G</em> = (<em>V</em>, <em>E</em>), let <em>u</em>, <em>v</em> ∈ <em>C</em>, let <em>u</em>′, <em>v</em>′ ∈ <em>C</em>′, and suppose that <em>G</em> contains a path <em>u</em> <span class="font1">⇝</span> <em>u</em>′. Then <em>G</em> cannot also contain a path <em>v</em>′ <span class="font1">⇝</span> <em>v</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   If <em>G</em> contains a path <em>v</em>′ <span class="font1">⇝</span> <em>v</em>, then it contains paths <em>u</em> <span class="font1">⇝</span> <em>u</em>′ <span class="font1">⇝</span> <em>v</em>′ and <em>v</em>′ <span class="font1">⇝</span> <em>v</em> <span class="font1">⇝</span> <em>u</em>. Thus, <em>u</em> and <em>v</em>′ are reachable from each other, thereby contradicting the assumption that <em>C</em> and <em>C</em>′ are distinct strongly connected components.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Because the S<small>TRONGLY</small>-C<small>ONNECTED</small>-C<small>OMPONENTS</small> procedure performs two depth-first searches, there are two distinct sets of discovery and finish times. In this section, discovery and finish times always refer to those computed by the <em>first</em> call of DFS, in line 1.</p>
<p>The notation for discovery and finish times extends to sets of vertices. For a subset <em>U</em> of vertices, <em>d</em>(<em>U</em>) and <em>f</em>(<em>U</em>) are the earliest discovery time and latest finish time, respectively, of any vertex in <em>U</em>: <em>d</em>(<em>U</em>) = min {<em>u.d</em> : <em>u</em> ∈ <em>U</em>} and <em>f</em>(<em>U</em>) = max {<em>u.f</em> : <em>u</em> ∈ <em>U</em>}.</p>
<p>The following lemma and its corollary give a key property relating strongly connected components and finish times in the first depth-first search.</p>
<p class="lem"><strong><em>Lemma 20.14</em></strong></p>
<p class="noindent">Let <em>C</em> and <em>C</em>′ be distinct strongly connected components in directed graph <em>G</em> = (<em>V</em>, <em>E</em>). Suppose that there is an edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>, where <em>u</em> ∈ <em>C</em>′ and <em>v</em> ∈ <em>C</em>. Then <em>f</em>(<em>C</em>′) &gt; <em>f</em>(<em>C</em>).</p>
<p class="prof"><strong><em>Proof</em></strong>   We consider two cases, depending on which strongly connected component, <em>C</em> or <em>C</em>′, had the first discovered vertex during the first depth-first search.</p>
<p>If <em>d</em>(<em>C</em>′) &lt; <em>d</em>(<em>C</em>), let x be the first vertex discovered in <em>C</em>′. At time <em>x.d</em>, all vertices in <em>C</em> and <em>C</em>′ are white. At that time, <em>G</em> contains a path from <em>x</em> to each vertex in <em>C</em>′ consisting only of white vertices. Because (<em>u</em>, <em>v</em>) ∈ <em>E</em>, for any vertex <em>w</em> ∈ <em>C</em>, there is also a path in <em>G</em> at time <em>x.d</em> from <em>x</em> to <em>w</em> consisting only of white vertices: <em>x</em> <span class="font1">⇝</span> <em>u</em> → <em>v</em> <span class="font1">⇝</span> <em>w</em>. By the white-path theorem, all vertices in <em>C</em> and <em>C</em>′ become descendants of <em>x</em> in the depth-first tree. By Corollary 20.8, <em>x</em> has the latest finish time of any of its descendants, and so <em>x.f</em> = <em>f</em>(<em>C</em>′) &gt; <em>f</em>(<em>C</em>).</p>
<p>Otherwise, <em>d</em>(<em>C</em>′) &gt; <em>d</em>(<em>C</em>). Let y be the first vertex discovered in <em>C</em>, so that <em>y.d</em> = <em>d</em>(<em>C</em>). At time <em>y.d</em>, all vertices in <em>C</em> are white and <em>G</em> contains a path from <em>y</em> to each vertex in <em>C</em> consisting only of white vertices. By the white-path theorem, all vertices in <em>C</em> become descendants of <em>y</em> in the depth-first tree, and by Corollary 20.8, <em>y.f</em> = <em>f</em>(<em>C</em>). Because <em>d</em>(<em>C</em>′) &gt; <em>d</em>(<em>C</em>) = <em>y.d</em>, all vertices in <em>C</em>′ are white at time <em>y.d</em>. Since there is an edge (<em>u</em>, <em>v</em>) from <em>C</em>′ to <em>C</em>, Lemma 20.13 implies that there cannot be a path from <em>C</em> to <em>C</em>′. Hence, no vertex in <em>C</em>′ is reachable <a id="p579"/>from <em>y</em>. At time <em>y.f</em>, therefore, all vertices in <em>C</em>′ are still white. Thus, for any vertex <em>w</em> ∈ <em>C</em>′, we have <em>w.f</em> &gt; <em>y.f</em>, which implies that <em>f</em>(<em>C</em>′) &gt; <em>f</em>(<em>C</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 20.15</em></strong></p>
<p class="noindent">Let <em>C</em> and <em>C</em>′ be distinct strongly connected components in directed graph <em>G</em> = (<em>V</em>, <em>E</em>), and suppose that <em>f</em>(<em>C</em>) &gt; <em>f</em>(<em>C</em>′). Then <em>E</em><sup>T</sup> contains no edge (<em>v</em>, <em>u</em>) such that <em>u</em> = <em>C</em>′ and <em>v</em> ∈ <em>C</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   The contrapositive of Lemma 20.14 says that if <em>f</em>(<em>C</em>′) &lt; <em>f</em>(<em>C</em>), then there is no edge (<em>u</em>, <em>v</em>) ∈ <em>E</em> such that <em>u</em> ∈ <em>C</em>′ and <em>v</em> ∈ <em>C</em>. Because the strongly connected components of <em>G</em> and <em>G</em><sup>T</sup> are the same, if there is no such edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>, then there is no edge (<em>v</em>, <em>u</em>) ∈ <em>E</em><sup>T</sup> such that <em>u</em> ∈ <em>C</em>′ and <em>v</em> ∈ <em>C</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Corollary 20.15 provides the key to understanding why the strongly connected components algorithm works. Let’s examine what happens during the second depth-first search, which is on <em>G</em><sup>T</sup>. The search starts from the vertex <em>x</em> whose finish time from the first depth-first search is maximum. This vertex belongs to some strongly connected component <em>C</em>, and since <em>x.f</em> is maximum, <em>f</em>(<em>C</em>) is maximum over all strongly connected components. When the search starts from <em>x</em>, it visits all vertices in <em>C</em>. By Corollary 20.15, <em>G</em><sup>T</sup> contains no edges from <em>C</em> to any other strongly connected component, and so the search from <em>x</em> never visits vertices in any other component. Thus, the tree rooted at <em>x</em> contains exactly the vertices of <em>C</em>. Having completed visiting all vertices in <em>C</em>, the second depth-first search selects as a new root a vertex from some other strongly connected component <em>C</em>′ whose finish time <em>f</em>(<em>C</em>′) is maximum over all components other than <em>C</em>. Again, the search visits all vertices in <em>C</em>′. But by Corollary 20.15, if any edges in <em>G</em><sup>T</sup> go from <em>C</em>′ to any other component, they must go to <em>C</em>, which the second depth-first search has already visited. In general, when the depth-first search of <em>G</em><sup>T</sup> in line 3 visits any strongly connected component, any edges out of that component must be to components that the search has already visited. Each depth-first tree, therefore, corresponds to exactly one strongly connected component. The following theorem formalizes this argument.</p>
<p class="theo"><strong><em>Theorem 20.16</em></strong></p>
<p class="noindent">The S<small>TRONGLY</small>-C<small>ONNECTED</small>-C<small>OMPONENTS</small> procedure correctly computes the strongly connected components of the directed graph <em>G</em> provided as its input.</p>
<p class="prof"><strong><em>Proof</em></strong>   We argue by induction on the number of depth-first trees found in the depth-first search of <em>G</em><sup>T</sup> in line 3 that the vertices of each tree form a strongly connected component. The inductive hypothesis is that the first <em>k</em> trees produced <a id="p580"/>in line 3 are strongly connected components. The basis for the induction, when <em>k</em> = 0, is trivial.</p>
<p>In the inductive step, we assume that each of the first <em>k</em> depth-first trees produced in line 3 is a strongly connected component, and we consider the (<em>k</em> + 1)st tree produced. Let the root of this tree be vertex <em>u</em>, and let <em>u</em> be in strongly connected component <em>C</em>. Because of how the depth-first search chooses roots in line 3, <em>u.f</em> = <em>f</em>(<em>C</em>) &gt; <em>f</em>(<em>C</em>′) for any strongly connected component <em>C</em>′ other than <em>C</em> that has yet to be visited. By the inductive hypothesis, at the time that the search visits <em>u</em>, all other vertices of <em>C</em> are white. By the white-path theorem, therefore, all other vertices of <em>C</em> are descendants of <em>u</em> in its depth-first tree. Moreover, by the inductive hypothesis and by Corollary 20.15, any edges in <em>G</em><sup>T</sup> that leave <em>C</em> must be to strongly connected components that have already been visited. Thus, no vertex in any strongly connected component other than <em>C</em> is a descendant of <em>u</em> during the depth-first search of <em>G</em><sup>T</sup>. The vertices of the depth-first tree in <em>G</em><sup>T</sup> that is rooted at <em>u</em> form exactly one strongly connected component, which completes the inductive step and the proof.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Here is another way to look at how the second depth-first search operates. Consider the component graph (<em>G</em><sup>T</sup>)<sup>SCC</sup> of <em>G</em><sup>T</sup>. If you map each strongly connected component visited in the second depth-first search to a vertex of (<em>G</em><sup>T</sup>)<sup>SCC</sup>, the second depth-first search visits vertices of (<em>G</em><sup>T</sup>)<sup>SCC</sup> in the reverse of a topologically sorted order. If you reverse the edges of (<em>G</em><sup>T</sup>)<sup>SCC</sup>, you get the graph ((<em>G</em><sup>T</sup>)<sup>SCC</sup>)<sup>T</sup>. Because ((<em>G</em><sup>T</sup>)<sup>SCC</sup>)<sup>T</sup> = <em>G</em><sup>SCC</sup> (see Exercise 20.5-4), the second depth-first search visits the vertices of <em>G</em><sup>SCC</sup> in topologically sorted order.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>20.5-1</em></strong></p>
<p class="noindent">How can the number of strongly connected components of a graph change if a new edge is added?</p>
<p class="level3"><strong><em>20.5-2</em></strong></p>
<p class="noindent">Show how the procedure S<small>TRONGLY</small>-C<small>ONNECTED</small>-C<small>OMPONENTS</small> works on the graph of <a href="chapter020.xhtml#Fig_20-6">Figure 20.6</a>. Specifically, show the finish times computed in line 1 and the forest produced in line 3. Assume that the loop of lines 5–7 of DFS considers vertices in alphabetical order and that the adjacency lists are in alphabetical order.</p>
<p class="level3"><strong><em>20.5-3</em></strong></p>
<p class="noindent">Professor Bacon rewrites the algorithm for strongly connected components to use the original (instead of the transpose) graph in the second depth-first search and <a id="p581"/>scan the vertices in order of <em>increasing</em> finish times. Does this modified algorithm always produce correct results?</p>
<p class="level3"><strong><em>20.5-4</em></strong></p>
<p class="noindent">Prove that for any directed graph <em>G</em>, the transpose of the component graph of <em>G</em><sup>T</sup> is the same as the component graph of <em>G</em>. That is, ((<em>G</em><sup>T</sup>)<sup>SCC</sup>)<sup>T</sup> = <em>G</em><sup>SCC</sup>.</p>
<p class="level3"><strong><em>20.5-5</em></strong></p>
<p class="noindent">Give an <em>O</em>(<em>V</em> + <em>E</em>)-time algorithm to compute the component graph of a directed graph <em>G</em> = (<em>V</em>, <em>E</em>). Make sure that there is at most one edge between two vertices in the component graph your algorithm produces.</p>
<p class="level3"><strong><em>20.5-6</em></strong></p>
<p class="noindent">Give an <em>O</em>(<em>V</em> + <em>E</em>)-time algorithm that, given a directed graph <em>G</em> = (<em>V</em>, <em>E</em>), constructs another graph <em>G</em>′ = (<em>V</em>, <em>E</em>′) such that <em>G</em> and <em>G</em>′ have the same strongly connected components, <em>G</em>′ has the same component graph as <em>G</em>, and |<em>E</em>′| is as small as possible.</p>
<p class="level3"><strong><em>20.5-7</em></strong></p>
<p class="noindent">A directed graph <em>G</em> = (<em>V</em>, <em>E</em>) is <span class="blue"><strong><em>semiconnected</em></strong></span> if, for all pairs of vertices <em>u</em>, <em>v</em> ∈ <em>V</em>, we have <em>u</em> <span class="font1">⇝</span> <em>v</em> or <em>v</em> <span class="font1">⇝</span> <em>u</em>. Give an efficient algorithm to determine whether <em>G</em> is semiconnected. Prove that your algorithm is correct, and analyze its running time.</p>
<p class="level3"><strong><em>20.5-8</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a directed graph, and let <em>l</em> : <em>V</em> → <span class="font1">ℝ</span> be a function that assigns a real-valued label <em>l</em> to each vertex. For vertices <em>s</em>, <em>t</em> ∈ <em>V</em>, define</p>
<p class="eql"><img alt="art" src="images/Art_P615.jpg"/></p>
<p class="noindent">Give an <em>O</em>(<em>V</em> + <em>E</em>)-time algorithm to find vertices <em>s</em> and <em>t</em> such that Δ<em>l</em>(<em>s</em>, <em>t</em>) is maximum over all pairs of vertices. (<em>Hint:</em> Use Exercise 20.5-5.)</p>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-123"><strong>Problems</strong></p>
<section title="20-1 Classifying edges by breadth-first search">
<p class="level2"><strong><em>20-1     Classifying edges by breadth-first search</em></strong></p>
<p class="noindent">A depth-first forest classifies the edges of a graph into tree, back, forward, and cross edges. A breadth-first tree can also be used to classify the edges reachable from the source of the search into the same four categories.</p>
<a id="p582"/>
<div class="divimage">
<p class="fig-imga" id="Fig_20-10"><img alt="art" src="images/Art_P616.jpg"/></p>
<p class="caption"><strong>Figure 20.10</strong> The articulation points, bridges, and biconnected components of a connected, undirected graph for use in Problem 20-2. The articulation points are the orange vertices, the bridges are the dark blue edges, and the biconnected components are the edges in the light blue regions, with a <em>bcc</em> numbering shown.</p>
</div>
<p class="nl-1list-d"><strong><em>a.</em></strong> Prove that in a breadth-first search of an undirected graph, the following properties hold:</p>
<p class="nl-2list-dt">1. There are no back edges and no forward edges.</p>
<p class="nl-2list-d">2. If (<em>u</em>, <em>v</em>) is a tree edge, then <em>v.d</em> = <em>u.d</em> + 1.</p>
<p class="nl-2list-d">3. If (<em>u</em>, <em>v</em>) is a cross edge, then <em>v.d</em> = <em>u.d</em> or <em>v.d</em> = <em>u.d</em> + 1.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Prove that in a breadth-first search of a directed graph, the following properties hold:</p>
<p class="nl-2list-dt">1. There are no forward edges.</p>
<p class="nl-2list-d">2. If (<em>u</em>, <em>v</em>) is a tree edge, then <em>v.d</em> = <em>u.d</em> + 1.</p>
<p class="nl-2list-d">3. If (<em>u</em>, <em>v</em>) is a cross edge, then <em>v.d</em> ≤ <em>u.d</em> + 1.</p>
<p class="nl-2list-d">4. If (<em>u</em>, <em>v</em>) is a back edge, then 0 ≤ <em>v.d</em> ≤ <em>u.d</em>.</p>
</section>
<section title="20-2 Articulation points, bridges, and biconnected components">
<p class="level2"><strong><em>20-2     Articulation points, bridges, and biconnected components</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a connected, undirected graph. An <span class="blue"><strong><em>articulation point</em></strong></span> of <em>G</em> is a vertex whose removal disconnects <em>G</em>. A <span class="blue"><strong><em>bridge</em></strong></span> of <em>G</em> is an edge whose removal disconnects <em>G</em>. A <span class="blue"><strong><em>biconnected component</em></strong></span> of <em>G</em> is a maximal set of edges such that any two edges in the set lie on a common simple cycle. <a href="chapter020.xhtml#Fig_20-10">Figure 20.10</a> illustrates these definitions. You can determine articulation points, bridges, and biconnected components using depth-first search. Let <em>G</em><sub><em>π</em></sub> = (<em>V</em>, <em>E</em><sub><em>π</em></sub>) be a depth-first tree of <em>G</em>.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Prove that the root of <em>G</em><sub><em>π</em></sub> is an articulation point of <em>G</em> if and only if it has at least two children in <em>G</em><sub><em>π</em></sub>.</p>
<p class="nl-1list-d"><a id="p583"/><strong><em>b.</em></strong> Let <em>v</em> be a nonroot vertex of <em>G</em><sub><em>π</em></sub>. Prove that <em>v</em> is an articulation point of <em>G</em> if and only if <em>v</em> has a child <em>s</em> such that there is no back edge from <em>s</em> or any descendant of <em>s</em> to a proper ancestor of <em>v</em>.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Let</p>
<p class="nl-para1-d"><img alt="art" src="images/Art_P617.jpg"/></p>
<p class="nl-para1-d">Show how to compute <em>v.low</em> for all vertices <em>v</em> ∈ <em>V</em> in <em>O</em>(<em>E</em>) time.</p>
<p class="nl-1list-d"><strong><em>d.</em></strong> Show how to compute all articulation points in <em>O</em>(<em>E</em>) time.</p>
<p class="nl-1list-d"><strong><em>e.</em></strong> Prove that an edge of <em>G</em> is a bridge if and only if it does not lie on any simple cycle of <em>G</em>.</p>
<p class="nl-1list-d"><strong><em>f.</em></strong> Show how to compute all the bridges of <em>G</em> in <em>O</em>(<em>E</em>) time.</p>
<p class="nl-1list-d"><strong><em>g.</em></strong> Prove that the biconnected components of <em>G</em> partition the nonbridge edges of <em>G</em>.</p>
<p class="nl-1list-d"><strong><em>h.</em></strong> Give an <em>O</em>(<em>E</em>)-time algorithm to label each edge <em>e</em> of <em>G</em> with a positive integer <em>e.bcc</em> such that <em>e</em>.<em>bcc</em> = <em>e</em>′.<em>bcc</em> if and only if <em>e</em> and <em>e</em>′ belong to the same biconnected component.</p>
</section>
<section title="20-3 Euler tour">
<p class="level2"><strong><em>20-3     Euler tour</em></strong></p>
<p class="noindent">An <span class="blue"><strong><em>Euler tour</em></strong></span> of a strongly connected, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) is a cycle that traverses each edge of <em>G</em> exactly once, although it may visit a vertex more than once.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Show that <em>G</em> has an Euler tour if and only if in-degree(<em>v</em>) = out-degree(<em>v</em>) for each vertex <em>v</em> ∈ <em>V</em>.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Describe an <em>O</em>(<em>E</em>)-time algorithm to find an Euler tour of <em>G</em> if one exists. (<em>Hint:</em> Merge edge-disjoint cycles.)</p>
</section>
<section title="20-4 Reachability">
<p class="level2"><strong><em>20-4     Reachability</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a directed graph in which each vertex <em>u</em> ∈ <em>V</em> is labeled with a unique integer <em>L</em>(<em>u</em>) from the set {1, 2, … , |<em>V</em>|}. For each vertex <em>u</em> ∈ <em>V</em>, let <em>R</em>(<em>u</em>) = {<em>v</em> ∈ <em>V</em> : <em>u</em> <span class="font1">⇝</span> <em>v</em>} be the set of vertices that are reachable from <em>u</em>. Define min(<em>u</em>) to be the vertex in <em>R</em>(<em>u</em>) whose label is minimum, that is, min(<em>u</em>) is the vertex <em>v</em> such that <em>L</em>(<em>v</em>) = min {<em>L</em>(<em>w</em>) : <em>w</em> ∈ <em>R</em>(<em>u</em>)}. Give an <em>O</em>(<em>V</em> + <em>E</em>)-time algorithm that computes min(<em>u</em>) for all vertices <em>u</em> ∈ <em>V</em>.</p>
<a id="p584"/>
</section>
<section title="20-5 Inserting and querying vertices in planar graphs">
<p class="level2"><strong><em>20-5 Inserting and querying vertices in planar graphs</em></strong></p>
<p class="noindent">A <span class="blue"><strong><em>planar</em></strong></span> graph is an undirected graph that can be drawn in the plane with no edges crossing. Euler proved that every planar graph has |<em>E</em>| &lt; 3 |<em>V</em>|.</p>
<p>Consider the following two operations on a planar graph <em>G</em>:</p>
<ul class="ulnoindent" epub:type="list">
<li>I<small>NSERT</small>(<em>G</em>, <em>v</em>, <em>neighbors</em>) inserts a new vertex <em>v</em> into <em>G</em>, where <em>neighbors</em> is an array (possibly empty) of vertices that have already been inserted into <em>G</em> and will become all the neighbors of <em>v</em> in <em>G</em> when <em>v</em> is inserted.</li>
<li class="litop">N<small>EWEST</small>-N<small>EIGHBOR</small>(<em>G</em>, <em>v</em>) returns the neighbor of vertex <em>v</em> that was most recently inserted into <em>G</em>, or <small>NIL</small> if <em>v</em> has no neighbors.</li></ul>
<p>Design a data structure that supports these two operations such that N<small>EWEST</small>-N<small>EIGHBOR</small> takes <em>O</em>(1) worst-case time and I<small>NSERT</small> takes <em>O</em>(1) amortized time. Note that the length of the array <em>neighbors</em> given to I<small>NSERT</small> may vary. (<em>Hint:</em> Use a potential function for the amortized analysis.)</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-124"><strong>Chapter notes</strong></p>
<p class="noindent">Even [<a epub:type="noteref" href="bibliography001.xhtml#endnote_137">137</a>] and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_429">429</a>] are excellent references for graph algorithms.</p>
<p>Breadth-first search was discovered by Moore [<a epub:type="noteref" href="bibliography001.xhtml#endnote_334">334</a>] in the context of finding paths through mazes. Lee [<a epub:type="noteref" href="bibliography001.xhtml#endnote_280">280</a>] independently discovered the same algorithm in the context of routing wires on circuit boards.</p>
<p>Hopcroft and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_226">226</a>] advocated the use of the adjacency-list representation over the adjacency-matrix representation for sparse graphs and were the first to recognize the algorithmic importance of depth-first search. Depth-first search has been widely used since the late 1950s, especially in artificial intelligence programs.</p>
<p>Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_426">426</a>] gave a linear-time algorithm for finding strongly connected components. The algorithm for strongly connected components in <a href="chapter020.xhtml#Sec_20.5">Section 20.5</a> is adapted from Aho, Hopcroft, and Ullman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_6">6</a>], who credit it to S. R. Kosaraju (unpublished) and Sharir [<a epub:type="noteref" href="bibliography001.xhtml#endnote_408">408</a>]. Dijkstra [<a epub:type="noteref" href="bibliography001.xhtml#endnote_117">117</a>, <a href="chapter025.xhtml">Chapter 25</a>] also developed an algorithm for strongly connected components that is based on contracting cycles. Subsequently, Gabow [<a epub:type="noteref" href="bibliography001.xhtml#endnote_163">163</a>] rediscovered this algorithm. Knuth [<a epub:type="noteref" href="bibliography001.xhtml#endnote_259">259</a>] was the first to give a linear-time algorithm for topological sorting.</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> We distinguish between gray and black vertices to help us understand how breadth-first search operates. In fact, as Exercise 20.2-3 shows, we get the same result even if we do not distinguish between gray and black vertices.</p>
<p class="footnote1" id="footnote_2"><a href="#footnote_ref_2"><sup>2</sup></a> <a href="chapter022.xhtml">Chapters 22</a> and <a href="chapter023.xhtml">23</a> generalize shortest paths to weighted graphs, in which every edge has a real-valued weight and the weight of a path is the sum of the weights of its constituent edges. The graphs considered in the present chapter are unweighted or, equivalently, all edges have unit weight.</p>
<p class="footnote1" id="footnote_3"><a href="#footnote_ref_3"><sup>3</sup></a> It may seem arbitrary that breadth-first search is limited to only one source whereas depth-first search may search from multiple sources. Although conceptually, breadth-first search could proceed from multiple sources and depth-first search could be limited to one source, our approach reflects how the results of these searches are typically used. Breadth-first search usually serves to find shortest-path distances and the associated predecessor subgraph from a given source. Depth-first search is often a subroutine in another algorithm, as we’ll see later in this chapter.</p>
</section>
</section>
</div>
</body>
</html>