<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p252"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="10 Elementary Data Structures">
<p class="chapter-title"><a href="toc.xhtml#chap-10"><strong><span class="blue1">10        Elementary Data Structures</span></strong></a></p>
<p class="noindent">In this chapter, we examine the representation of dynamic sets by simple data structures that use pointers. Although you can construct many complex data structures using pointers, we present only the rudimentary ones: arrays, matrices, stacks, queues, linked lists, and rooted trees.</p>
<p class="line1"/>
<section title="10.1 Simple array-based data structures: arrays, matrices, stacks, queues">
<a id="Sec_10.1"/>
<p class="level1" id="h1-57"><a href="toc.xhtml#Rh1-57"><strong>10.1    Simple array-based data structures: arrays, matrices, stacks, queues</strong></a></p>
<section title="10.1.1 Arrays">
<p class="level2" id="Sec_10.1.1"><strong>10.1.1    Arrays</strong></p>
<p class="noindent">We assume that, as in most programming languages, an array is stored as a contiguous sequence of bytes in memory. If the first element of an array has index <em>s</em> (for example, in an array with 1-origin indexing, <em>s</em> = 1), the array starts at memory address <em>a</em>, and each array element occupies <em>b</em> bytes, then the <em>i</em>th element occupies bytes <em>a</em> + <em>b</em>(<em>i</em> – <em>s</em>) through <em>a</em> + <em>b</em>(<em>i</em> – <em>s</em> + 1) – 1. Since most of the arrays in this book are indexed starting at 1, and a few starting at 0, we can simplify these formulas a little. When <em>s</em> = 1, the <em>i</em>th element occupies bytes <em>a</em> + <em>b</em>(<em>i</em> – 1) through <em>a</em> + <em>bi</em> – 1, and when <em>s</em> = 0, the <em>i</em>th element occupies bytes <em>a</em> + <em>bi</em> through <em>a</em> + <em>b</em>(<em>i</em> + 1) – 1. Assuming that the computer can access all memory locations in the same amount of time (as in the RAM model described in <a href="chapter002.xhtml#Sec_2.2">Section 2.2</a>), it takes constant time to access any array element, regardless of the index.</p>
<p>Most programming languages require each element of a particular array to be the same size. If the elements of a given array might occupy different numbers of bytes, then the above formulas fail to apply, since the element size <em>b</em> is not a constant. In such cases, the array elements are usually objects of varying sizes, and what actually appears in each array element is a pointer to the object. The number of bytes occupied by a pointer is typically the same, no matter what the pointer references, so that to access an object in an array, the above formulas give the address of the pointer to the object and then the pointer must be followed to access the object itself.</p>
<a id="p253"/>
<div class="divimage">
<p class="fig-imga" id="Fig_10-1"><img alt="art" src="images/Art_P365.jpg"/></p>
<p class="caption"><strong>Figure 10.1</strong> Four ways to store the 2 × 3 matrix <em>M</em> from equation (10.1). <strong>(a)</strong> In row-major order, in a single array. <strong>(b)</strong> In column-major order, in a single array. <strong>(c)</strong> In row-major order, with one array per row (tan) and a single array (blue) of pointers to the row arrays. <strong>(d)</strong> In column-major order, with one array per column (tan) and a single array (blue) of pointers to the column arrays.</p>
</div>
</section>
<section title="10.1.2 Matrices">
<p class="level2" id="Sec_10.1.2"><strong>10.1.2    Matrices</strong></p>
<p class="noindent">We typically represent a matrix or two-dimensional array by one or more one-dimensional arrays. The two most common ways to store a matrix are row-major and column-major order. Let’s consider an <em>m</em> × <em>n</em> matrix—a matrix with <em>m</em> rows and <em>n</em> columns. In <strong><em><span class="blue1">row-major order</span></em></strong>, the matrix is stored row by row, and in <strong><em><span class="blue1">column-major order</span></em></strong>, the matrix is stored column by column. For example, consider the 2 × 3 matrix</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P366.jpg"/></p>
<p class="noindent">Row-major order stores the two rows 1 2 3 and 4 5 6, whereas column-major order stores the three columns 1 4; 2 5; and 3 6.</p>
<p>Parts (a) and (b) of <a href="chapter010.xhtml#Fig_10-1">Figure 10.1</a> show how to store this matrix using a single one-dimensional array. It’s stored in row-major order in part (a) and in column-major order in part (b). If the rows, columns, and the single array all are indexed starting at <em>s</em>, then <em>M</em> [<em>i</em>, <em>j</em>]—the element in row <em>i</em> and column <em>j</em>—is at array index <em>s</em> + (<em>n</em>(<em>i</em> – <em>s</em>)) + (<em>j</em> – <em>s</em>) with row-major order and <em>s</em> + (<em>m</em>(<em>j</em> – <em>s</em>)) + (<em>i</em> – <em>s</em>) with column-major order. When <em>s</em> = 1, the single-array indices are <em>n</em>(<em>i</em> – 1) + <em>j</em> with row-major order and <em>i</em> + <em>m</em>(<em>j</em> – 1) with column-major order. When <em>s</em> = 0, the single-array indices are simpler: <em>ni</em> + <em>j</em> with row-major order and <em>i</em> + <em>mj</em> with column-major order. For the example matrix <em>M</em> with 1-origin indexing, element <em>M</em> [2, 1] is stored at index 3(2 – 1) + 1 = 4 in the single array using row-major order and at index 2 + 2(1 – 1) = 2 using column-major order.</p>
<p>Parts (c) and (d) of <a href="chapter010.xhtml#Fig_10-1">Figure 10.1</a> show multiple-array strategies for storing the example matrix. In part (c), each row is stored in its own array of length <em>n</em>, shown in tan. Another array, with <em>m</em> elements, shown in blue, points to the <em>m</em> row arrays. If we call the blue array <em>A</em>, then <em>A</em>[<em>i</em>] points to the array storing the entries for row <em>i</em> of <em>M</em>, and array element <em>A</em>[<em>i</em>] [<em>j</em>] stores matrix element <em>M</em> [<em>i</em>, <em>j</em>]. Part (d) shows the column-major version of the multiple-array representation, with <em>n</em> arrays, each of <a id="p254"/>length <em>m</em>, representing the <em>n</em> columns. Matrix element <em>M</em> [<em>i</em>, <em>j</em>] is stored in array element <em>A</em>[<em>j</em>] [<em>i</em>].</p>
<p>Single-array representations are typically more efficient on modern machines than multiple-array representations. But multiple-array representations can sometimes be more flexible, for example, allowing for “ragged arrays,” in which the rows in the row-major version may have different lengths, or symmetrically for the column-major version, where columns may have different lengths.</p>
<p>Occasionally, other schemes are used to store matrices. In the <strong><em><span class="blue1">block representation</span></em></strong>, the matrix is divided into blocks, and each block is stored contiguously. For example, a 4 × 4 matrix that is divided into 2 × 2 blocks, such as</p>
<p class="eql"><img alt="art" src="images/Art_P367.jpg"/></p>
<p class="noindent">might be stored in a single array in the order <span class="font1">〈</span>1, 2, 5, 6, 3, 4, 7, 8, 9, 10, 13, 14, 11, 12, 15, 16<span class="font1">〉</span>.</p>
</section>
<section title="10.1.3 Stacks and queues">
<p class="level2" id="Sec_10.1.3"><strong>10.1.3    Stacks and queues</strong></p>
<p class="noindent">Stacks and queues are dynamic sets in which the element removed from the set by the D<small>ELETE</small> operation is prespecified. In a <strong><em><span class="blue1">stack</span></em></strong>, the element deleted from the set is the one most recently inserted: the stack implements a <strong><span class="blue1"><em>last-in</em>, <em>first-out</em></span></strong>, or <strong><em><span class="blue1">LIFO</span></em></strong>, policy. Similarly, in a <strong><em><span class="blue1">queue</span></em></strong>, the element deleted is always the one that has been in the set for the longest time: the queue implements a <strong><em><span class="blue1">first-in, first-out</span></em></strong>, or <strong><em><span class="blue1">FIFO</span></em></strong>, policy. There are several efficient ways to implement stacks and queues on a computer. Here, you will see how to use an array with attributes to store them.</p>
<p class="level4"><strong>Stacks</strong></p>
<p class="noindent">The I<small>NSERT</small> operation on a stack is often called P<small>USH</small>, and the D<small>ELETE</small> operation, which does not take an element argument, is often called P<small>OP</small>. These names are allusions to physical stacks, such as the spring-loaded stacks of plates used in cafeterias. The order in which plates are popped from the stack is the reverse of the order in which they were pushed onto the stack, since only the top plate is accessible.</p>
<p><a href="chapter010.xhtml#Fig_10-2">Figure 10.2</a> shows how to implement a stack of at most <em>n</em> elements with an array <em>S</em>[1 : <em>n</em>]. The stack has attributes <em>S.top</em>, indexing the most recently inserted element, and <em>S.size</em>, equaling the size <em>n</em> of the array. The stack consists of elements <em>S</em>[1 : <em>S.top</em>], where <em>S</em>[1] is the element at the bottom of the stack and <em>S</em>[<em>S.top</em>] is the element at the top.</p>
<a id="p255"/>
<div class="divimage">
<p class="fig-imga" id="Fig_10-2"><img alt="art" class="width100" src="images/Art_P368.jpg"/></p>
<p class="caption"><strong>Figure 10.2</strong> An array implementation of a stack <em>S</em>. Stack elements appear only in the tan positions. <strong>(a)</strong> Stack <em>S</em> has 4 elements. The top element is 9. <strong>(b)</strong> Stack <em>S</em> after the calls P<small>USH</small>(<em>S</em>, 17) and P<small>USH</small>(<em>S</em>, 3). <strong>(c)</strong> Stack <em>S</em> after the call P<small>OP</small>(<em>S</em>) has returned the element 3, which is the one most recently pushed. Although element 3 still appears in the array, it is no longer in the stack. The top is element 17.</p>
</div>
<p>When <em>S.top</em> = 0, the stack contains no elements and is <strong><em><span class="blue1">empty</span></em></strong>. We can test whether the stack is empty with the query operation S<small>TACK</small>-E<small>MPTY</small>. Upon an attempt to pop an empty stack, the stack <strong><em><span class="blue1">underflows</span></em></strong>, which is normally an error. If <em>S.top</em> exceeds <em>S.size</em>, the stack <strong><em><span class="blue1">overflows</span></em></strong>.</p>
<p>The procedures S<small>TACK</small>-E<small>MPTY</small>, P<small>USH</small>, and P<small>OP</small> implement each of the stack operations with just a few lines of code. <a href="chapter010.xhtml#Fig_10-2">Figure 10.2</a> shows the effects of the modifying operations P<small>USH</small> and P<small>OP</small>. Each of the three stack operations takes <em>O</em>(1) time.</p>
<div class="pull-quote1">
<p class="box-heading">S<small>TACK</small>-E<small>MPTY</small>(<em>S</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>S.top</em> == 0</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> T<small>RUE</small></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>else return</strong> F<small>ALSE</small></p></td>
</tr>
</table>
<p class="box-headinga">P<small>USH</small>(<em>S</em>, <em>x</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>S.top</em> == <em>S.size</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><strong>error</strong> “overflow”</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>else</strong> <em>S.top</em> = <em>S.top</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><em>S</em>[<em>S.top</em>] = <em>x</em></p></td>
</tr>
</table>
<p class="box-headinga">P<small>OP</small>(<em>S</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> S<small>TACK</small>-E<small>MPTY</small>(<em>S</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><strong>error</strong> “underflow”</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>else</strong> <em>S.top</em> = <em>S.top</em> – 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> <em>S</em>[<em>S.top</em> + 1]</p></td>
</tr>
</table>
</div>
<a id="p256"/>
<div class="divimage">
<p class="fig-imga" id="Fig_10-3"><img alt="art" src="images/Art_P369.jpg"/></p>
<p class="caption"><strong>Figure 10.3</strong> A queue implemented using an array <em>Q</em>[1 : 12]. Queue elements appear only in the tan positions. <strong>(a)</strong> The queue has 5 elements, in locations <em>Q</em>[7 : 11]. <strong>(b)</strong> The configuration of the queue after the calls E<small>NQUEUE</small>(<em>Q</em>, 17), E<small>NQUEUE</small>(<em>Q</em>, 3), and E<small>NQUEUE</small>(<em>Q</em>, 5). <strong>(c)</strong> The configuration of the queue after the call D<small>EQUEUE</small>(<em>Q</em>) returns the key value 15 formerly at the head of the queue. The new head has key 6.</p>
</div>
<p class="level4"><strong>Queues</strong></p>
<p class="noindent">We call the I<small>NSERT</small> operation on a queue E<small>NQUEUE</small>, and we call the D<small>ELETE</small> operation D<small>EQUEUE</small>. Like the stack operation P<small>OP</small>, D<small>EQUEUE</small> takes no element argument. The FIFO property of a queue causes it to operate like a line of customers waiting for service. The queue has a <strong><em><span class="blue1">head</span></em></strong> and a <strong><em><span class="blue1">tail</span></em></strong>. When an element is enqueued, it takes its place at the tail of the queue, just as a newly arriving customer takes a place at the end of the line. The element dequeued is always the one at the head of the queue, like the customer at the head of the line, who has waited the longest.</p>
<p><a href="chapter010.xhtml#Fig_10-3">Figure 10.3</a> shows one way to implement a queue of at most <em>n</em> – 1 elements using an array <em>Q</em>[1 : <em>n</em>], with the attribute <em>Q.size</em> equaling the size <em>n</em> of the array. The queue has an attribute <em>Q.head</em> that indexes, or points to, its head. The attribute <em>Q.tail</em> indexes the next location at which a newly arriving element will be inserted into the queue. The elements in the queue reside in locations <em>Q.head</em>, <em>Q.head</em> + 1, … , <em>Q.tail</em> – 1, where we “wrap around” in the sense that location 1 immediately follows location <em>n</em> in a circular order. When <em>Q.head</em> = <em>Q.tail</em>, the queue is empty. Initially, we have <em>Q.head</em> = <em>Q.tail</em> = 1. An attempt to dequeue an element from an empty queue causes the queue to underflow. When <em>Q.head</em> = <em>Q.tail</em> + 1 or both <a id="p257"/><em>Q.head</em> = 1 and <em>Q.tail</em> = <em>Q.size</em>, the queue is full, and an attempt to enqueue an element causes the queue to overflow.</p>
<p>In the procedures E<small>NQUEUE</small> and D<small>EQUEUE</small>, we have omitted the error checking for underflow and overflow. (Exercise 10.1-5 asks you to supply these checks.) <a href="chapter010.xhtml#Fig_10-3">Figure 10.3</a> shows the effects of the E<small>NQUEUE</small> and D<small>EQUEUE</small> operations. Each operation takes <em>O</em>(1) time.</p>
<div class="pull-quote1">
<p class="box-heading">E<small>NQUEUE</small>(<em>Q</em>, <em>x</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>Q</em>[<em>Q.tail</em>] = <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>Q.tail</em> == <em>Q.size</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2"><em>Q.tail</em> = 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent"><strong>else</strong> <em>Q.tail</em> = <em>Q.tail</em> + 1</p></td>
</tr>
</table>
<p class="box-headinga">D<small>EQUEUE</small>(<em>Q</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>x</em> = <em>Q</em>[<em>Q.head</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>Q.head</em> == <em>Q.size</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2"><em>Q.head</em> = 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent"><strong>else</strong> <em>Q.head</em> = <em>Q.head</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>x</em></p></td>
</tr>
</table>
</div>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>10.1-1</em></strong></p>
<p class="noindent">Consider an <em>m</em> × <em>n</em> matrix in row-major order, where both <em>m</em> and <em>n</em> are powers of 2 and rows and columns are indexed from 0. We can represent a row index <em>i</em> in binary by the lg <em>m</em> bits <span class="font1">〈</span><em>i</em><sub>lg <em>m</em> – 1</sub>, <em>i</em><sub>lg <em>m</em> – 2</sub>, … , <em>i</em><sub>0</sub><span class="font1">〉</span> and a column index <em>j</em> in binary by the lg <em>n</em> bits <span class="font1">〈</span><em>j</em><sub>lg <em>n</em> – 1</sub>, <em>j</em><sub>lg <em>n</em> – 2</sub>, … , <em>j</em><sub>0</sub><span class="font1">〉</span>. Suppose that this matrix is a 2 × 2 block matrix, where each block has <em>m</em>/2 rows and <em>n</em>/2 columns, and it is to be represented by a single array with 0-origin indexing. Show how to construct the binary representation of the (lg <em>m</em> + lg <em>n</em>)-bit index into the single array from the binary representations of <em>i</em> and <em>j</em>.</p>
<p class="level3"><strong><em>10.1-2</em></strong></p>
<p class="noindent">Using <a href="chapter010.xhtml#Fig_10-2">Figure 10.2</a> as a model, illustrate the result of each operation in the sequence P<small>USH</small>(<em>S</em>, 4), P<small>USH</small>(<em>S</em>, 1), P<small>USH</small>(<em>S</em>, 3), P<small>OP</small>(<em>S</em>), P<small>USH</small>(<em>S</em>, 8), and P<small>OP</small>(<em>S</em>) on an initially empty stack <em>S</em> stored in array <em>S</em>[1 : 6]</p>
<a id="p258"/>
<p class="level3"><strong><em>10.1-3</em></strong></p>
<p class="noindent">Explain how to implement two stacks in one array <em>A</em>[1 : <em>n</em>] in such a way that neither stack overflows unless the total number of elements in both stacks together is <em>n</em>. The P<small>USH</small> and P<small>OP</small> operations should run in <em>O</em>(1) time.</p>
<p class="level3"><strong><em>10.1-4</em></strong></p>
<p class="noindent">Using <a href="chapter010.xhtml#Fig_10-3">Figure 10.3</a> as a model, illustrate the result of each operation in the sequence E<small>NQUEUE</small>(<em>Q</em>, 4), E<small>NQUEUE</small>(<em>Q</em>, 1), E<small>NQUEUE</small>(<em>Q</em>, 3), D<small>EQUEUE</small>(<em>Q</em>), E<small>NQUEUE</small>(<em>Q</em>, 8), and D<small>EQUEUE</small>(<em>Q</em>) on an initially empty queue <em>Q</em> stored in array <em>Q</em>[1 : 6].</p>
<p class="level3"><strong><em>10.1-5</em></strong></p>
<p class="noindent">Rewrite E<small>NQUEUE</small> and D<small>EQUEUE</small> to detect underflow and overflow of a queue.</p>
<p class="level3"><strong><em>10.1-6</em></strong></p>
<p class="noindent">Whereas a stack allows insertion and deletion of elements at only one end, and a queue allows insertion at one end and deletion at the other end, a <strong><em><span class="blue1">deque</span></em></strong> (double-ended queue, pronounced like “deck”) allows insertion and deletion at both ends. Write four <em>O</em>(1)-time procedures to insert elements into and delete elements from both ends of a deque implemented by an array.</p>
<p class="level3"><strong><em>10.1-7</em></strong></p>
<p class="noindent">Show how to implement a queue using two stacks. Analyze the running time of the queue operations.</p>
<p class="level3"><strong><em>10.1-8</em></strong></p>
<p class="noindent">Show how to implement a stack using two queues. Analyze the running time of the stack operations.</p>
</section>
</section>
<p class="line1"/>
<section title="10.2 Linked lists">
<a id="Sec_10.2"/>
<p class="level1" id="h1-58"><a href="toc.xhtml#Rh1-58"><strong>10.2    Linked lists</strong></a></p>
<p class="noindent">A <strong><em><span class="blue1">linked list</span></em></strong> is a data structure in which the objects are arranged in a linear order. Unlike an array, however, in which the linear order is determined by the array indices, the order in a linked list is determined by a pointer in each object. Since the elements of linked lists often contain keys that can be searched for, linked lists are sometimes called <strong><em><span class="blue1">search lists</span></em></strong>. Linked lists provide a simple, flexible representation for dynamic sets, supporting (though not necessarily efficiently) all the operations listed on page 250.</p>
<p>As shown in <a href="chapter010.xhtml#Fig_10-4">Figure 10.4</a>, each element of a <strong><em><span class="blue1">doubly linked list</span></em></strong> <em>L</em> is an object with an attribute <em>key</em> and two pointer attributes: <em>next</em> and <em>prev</em>. The object may <a id="p259"/>also contain other satellite data. Given an element <em>x</em> in the list, <em>x.next</em> points to its successor in the linked list, and <em>x.prev</em> points to its predecessor. If <em>x.prev</em> = <small>NIL</small>, the element <em>x</em> has no predecessor and is therefore the first element, or <strong><em><span class="blue1">head</span></em></strong>, of the list. If <em>x.next</em> = <small>NIL</small>, the element <em>x</em> has no successor and is therefore the last element, or <strong><em><span class="blue1">tail</span></em></strong>, of the list. An attribute <em>L.head</em> points to the first element of the list. If <em>L.head</em> = <small>NIL</small>, the list is empty.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_10-4"><img alt="art" class="width100" src="images/Art_P370.jpg"/></p>
<p class="caption"><strong>Figure 10.4 (a)</strong> A doubly linked list <em>L</em> representing the dynamic set {1, 4, 9, 16}. Each element in the list is an object with attributes for the key and pointers (shown by arrows) to the next and previous objects. The <em>next</em> attribute of the tail and the <em>prev</em> attribute of the head are <small>NIL</small>, indicated by a diagonal slash. The attribute <em>L.head</em> points to the head. <strong>(b)</strong> Following the execution of L<small>IST</small>-P<small>REPEND</small>(<em>L</em>, <em>x</em>), where <em>x.key</em> = 25, the linked list has an object with key 25 as the new head. This new object points to the old head with key 9. <strong>(c)</strong> The result of calling L<small>IST</small>-I<small>NSERT</small>(<em>x</em>, <em>y</em>), where <em>x.key</em> = 36 and <em>y</em> points to the object with key 9. <strong>(d)</strong> The result of the subsequent call L<small>IST</small>-D<small>ELETE</small>(<em>L</em>, <em>x</em>), where <em>x</em> points to the object with key 4.</p>
</div>
<p>A list may have one of several forms. It may be either singly linked or doubly linked, it may be sorted or not, and it may be circular or not. If a list is <strong><em><span class="blue1">singly linked</span></em></strong>, each element has a <em>next</em> pointer but not a <em>prev</em> pointer. If a list is <strong><em><span class="blue1">sorted</span></em></strong>, the linear order of the list corresponds to the linear order of keys stored in elements of the list. The minimum element is then the head of the list, and the maximum element is the tail. If the list is <strong><em><span class="blue1">unsorted</span></em></strong>, the elements can appear in any order. In a <strong><em><span class="blue1">circular list</span></em></strong>, the <em>prev</em> pointer of the head of the list points to the tail, and the <em>next</em> pointer of the tail of the list points to the head. You can think of a circular list as a ring of elements. In the remainder of this section, we assume that the lists we are working with are unsorted and doubly linked.</p>
<a id="p260"/>
<p class="level4"><strong>Searching a linked list</strong></p>
<p class="noindent">The procedure L<small>IST</small>-S<small>EARCH</small>(<em>L</em>, <em>k</em>) finds the first element with key <em>k</em> in list <em>L</em> by a simple linear search, returning a pointer to this element. If no object with key <em>k</em> appears in the list, then the procedure returns N<small>IL</small>. For the linked list in <a href="chapter010.xhtml#Fig_10-4">Figure 10.4(a)</a>, the call L<small>IST</small>-S<small>EARCH</small>(<em>L</em>, 4) returns a pointer to the third element, and the call L<small>IST</small>-S<small>EARCH</small>(<em>L</em>, 7) returns <small>NIL</small>. To search a list of <em>n</em> objects, the L<small>IST</small>-S<small>EARCH</small> procedure takes Θ(<em>n</em>) time in the worst case, since it may have to search the entire list.</p>
<div class="pull-quote1">
<p class="box-heading">L<small>IST</small>-S<small>EARCH</small>(<em>L</em>, <em>k</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>x</em> = <em>L.head</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> <em>x</em> ≠ <small>NIL</small> and <em>x.key</em> ≠ <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2"><em>x</em> = <em>x.next</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>x</em></p></td>
</tr>
</table>
</div>
<p class="level4"><strong>Inserting into a linked list</strong></p>
<p class="noindent">Given an element <em>x</em> whose <em>key</em> attribute has already been set, the L<small>IST</small>-P<small>REPEND</small> procedure adds <em>x</em> to the front of the linked list, as shown in <a href="chapter010.xhtml#Fig_10-4">Figure 10.4(b)</a>. (Recall that our attribute notation can cascade, so that <em>L.head.prev</em> denotes the <em>prev</em> attribute of the object that <em>L.head</em> points to.) The running time for L<small>IST</small>-P<small>REPEND</small> on a list of <em>n</em> elements is <em>O</em>(1).</p>
<div class="pull-quote1">
<p class="box-heading">L<small>IST</small>-P<small>REPEND</small>(<em>L</em>, <em>x</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>x.next</em> = <em>L.head</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><em>x.prev</em> = <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>L.head</em> ≠ <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><em>L.head.prev</em> = <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><em>L.head</em> = <em>x</em></p></td>
</tr>
</table>
</div>
<p>You can insert anywhere within a linked list. As <a href="chapter010.xhtml#Fig_10-4">Figure 10.4(c)</a> shows, if you have a pointer <em>y</em> to an object in the list, the L<small>IST</small>-I<small>NSERT</small> procedure on the facing page “splices” a new element <em>x</em> into the list, immediately following <em>y</em>, in <em>O</em>(1) time. Since L<small>IST</small>-I<small>NSERT</small> never references the list object <em>L</em>, it is not supplied as a parameter.</p>
<a id="p261"/>
<div class="pull-quote1">
<p class="box-heading">L<small>IST</small>-I<small>NSERT</small>(<em>x</em>, <em>y</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>x.next</em> = <em>y.next</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><em>x.prev</em> = <em>y</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>y.next</em> ≠ <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><em>y.next.prev</em> = <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><em>y.next</em> = <em>x</em></p></td>
</tr>
</table>
</div>
<p class="level4"><strong>Deleting from a linked list</strong></p>
<p class="noindent">The procedure L<small>IST</small>-D<small>ELETE</small> removes an element <em>x</em> from a linked list <em>L</em>. It must be given a pointer to <em>x</em>, and it then “‘splices” <em>x</em> out of the list by updating pointers. To delete an element with a given key, first call L<small>IST</small>-S<small>EARCH</small> to retrieve a pointer to the element. <a href="chapter010.xhtml#Fig_10-4">Figure 10.4(d)</a> shows how an element is deleted from a linked list. L<small>IST</small>-D<small>ELETE</small> runs in <em>O</em>(1) time, but to delete an element with a given key, the call to L<small>IST</small>-S<small>EARCH</small> makes the worst-case running time be Θ(<em>n</em>).</p>
<div class="pull-quote1">
<p class="box-heading">L<small>IST</small>-D<small>ELETE</small>(<em>L</em>, <em>x</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>x.prev</em> ≠ <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><em>x.prev.next</em> = <em>x.next</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>else</strong> <em>L.head</em> = <em>x.next</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>x.next</em> ≠ <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p2"><em>x.next.prev</em> = <em>x.prev</em></p></td>
</tr>
</table>
</div>
<p>Insertion and deletion are faster operations on doubly linked lists than on arrays. If you want to insert a new first element into an array or delete the first element in an array, maintaining the relative order of all the existing elements, then each of the existing elements needs to be moved by one position. In the worst case, therefore, insertion and deletion take Θ(<em>n</em>) time in an array, compared with <em>O</em>(1) time for a doubly linked list. (Exercise 10.2-1 asks you to show that deleting an element from a singly linked list takes Θ(<em>n</em>) time in the worst case.) If, however, you want to find the <em>k</em>th element in the linear order, it takes just <em>O</em>(1) time in an array regardless of <em>k</em>, but in a linked list, you’d have to traverse <em>k</em> elements, taking Θ(<em>k</em>) time.</p>
<p class="level4"><strong>Sentinels</strong></p>
<p class="noindent">The code for L<small>IST</small>-D<small>ELETE</small> is simpler if you ignore the boundary conditions at the head and tail of the list:</p>
<a id="p262"/>
<div class="divimage">
<p class="fig-imga" id="Fig_10-5"><img alt="art" class="width100" src="images/Art_P371.jpg"/></p>
<p class="caption"><strong>Figure 10.5</strong> A circular, doubly linked list with a sentinel. The sentinel <em>L.nil</em>, in blue, appears between the head and tail. The attribute <em>L.head</em> is no longer needed, since the head of the list is <em>L.nil.next</em>. <strong>(a)</strong> An empty list. <strong>(b)</strong> The linked list from <a href="chapter010.xhtml#Fig_10-4">Figure 10.4(a)</a>, with key 9 at the head and key 1 at the tail. <strong>(c)</strong> The list after executing L<small>IST</small>-I<small>NSERT</small>′ (<em>x</em>, <em>L.nil</em>), where <em>x.key</em> = 25. The new object becomes the head of the list. <strong>(d)</strong> The list after deleting the object with key 1. The new tail is the object with key 4. <strong>(e)</strong> The list after executing L<small>IST</small>-I<small>NSERT</small>′ (<em>x</em>, <em>y</em>), where <em>x.key</em> = 36 and <em>y</em> points to the object with key 9.</p>
</div>
<div class="pull-quote1">
<p class="box-heading">L<small>IST</small>-D<small>ELETE</small>′ (<em>x</em>)</p>
<table class="table1n">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>x.prev.next</em> = <em>x.next</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><em>x.next.prev</em> = <em>x.prev</em></p></td>
</tr>
</table>
</div>
<p>A <strong><em><span class="blue1">sentinel</span></em></strong> is a dummy object that allows us to simplify boundary conditions. In a linked list <em>L</em>, the sentinel is an object <em>L.nil</em> that represents <small>NIL</small> but has all the attributes of the other objects in the list. References to <small>NIL</small> are replaced by references to the sentinel <em>L.nil</em>. As shown in <a href="chapter010.xhtml#Fig_10-5">Figure 10.5</a>, this change turns a regular doubly linked list into a <strong><em><span class="blue1">circular, doubly linked list with a sentinel</span></em></strong>, in which the sentinel <em>L.nil</em> lies between the head and tail. The attribute <em>L.nil.next</em> points to the head of the list, and <em>L.nil.prev</em> points to the tail. Similarly, both the <em>next</em> attribute of the tail and the <em>prev</em> attribute of the head point to <em>L.nil</em>. Since <em>L.nil.next</em> points to the head, the attribute <em>L.head</em> is eliminated altogether, with references to it replaced by references to <em>L.nil.next</em>. <a href="chapter010.xhtml#Fig_10-5">Figure 10.5(a)</a> shows that an empty list consists of just the sentinel, and both <em>L.nil.next</em> and <em>L.nil.prev</em> point to <em>L.nil</em>.</p>
<p>To delete an element from the list, just use the two-line procedure L<small>IST</small>-D<small>ELETE</small>′ from before. Just as L<small>IST</small>-I<small>NSERT</small> never references the list object <em>L</em>, neither does <a id="p263"/>L<small>IST</small>-D<small>ELETE</small>′. You should never delete the sentinel <em>L.nil</em> unless you are deleting the entire list!</p>
<p>The L<small>IST</small>-I<small>NSERT</small>′ procedure inserts an element <em>x</em> into the list following object <em>y</em>. No separate procedure for prepending is necessary: to insert at the head of the list, let <em>y</em> be <em>L.nil</em>; and to insert at the tail, let <em>y</em> be <em>L.nil.prev</em>. <a href="chapter010.xhtml#Fig_10-5">Figure 10.5</a> shows the effects of L<small>IST</small>-I<small>NSERT</small>′ and L<small>IST</small>-D<small>ELETE</small>′ on a sample list.</p>
<div class="pull-quote1">
<p class="box-heading">L<small>IST</small>-I<small>NSERT</small>′ (<em>x</em>, <em>y</em>)</p>
<table class="table1n">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>x.next</em> = <em>y.next</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><em>x.prev</em> = <em>y</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><em>y.next.prev</em> = <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent"><em>y.next</em> = <em>x</em></p></td>
</tr>
</table>
</div>
<p>Searching a circular, doubly linked list with a sentinel has the same asymptotic running time as without a sentinel, but it is possible to decrease the constant factor. The test in line 2 of L<small>IST</small>-S<small>EARCH</small> makes two comparisons: one to check whether the search has run off the end of the list and, if not, one to check whether the key resides in the current element <em>x</em>. Suppose that you <em>know</em> that the key is somewhere in the list. Then you do not need to check whether the search runs off the end of the list, thereby eliminating one comparison in each iteration of the <strong>while</strong> loop.</p>
<p>The sentinel provides a place to put the key before starting the search. The search starts at the head <em>L.nil.next</em> of list <em>L</em>, and it stops if it finds the key somewhere in the list. Now the search is guaranteed to find the key, either in the sentinel or before reaching the sentinel. If the key is found before reaching the sentinel, then it really is in the element where the search stops. If, however, the search goes through all the elements in the list and finds the key only in the sentinel, then the key is not really in the list, and the search returns <small>NIL</small>. The procedure L<small>IST</small>-S<small>EARCH</small>′ embodies this idea. (If your sentinel requires its <em>key</em> attribute to be <small>NIL</small>, then you might want to assign <em>L.nil.key</em> = <small>NIL</small> before line 5.)</p>
<div class="pull-quote1">
<p class="box-heading">L<small>IST</small>-S<small>EARCH</small>′ (<em>L</em>, <em>k</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>L.nil.key</em> = <em>k</em></p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> store the key in the sentinel to guarantee it is in list</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><em>x</em> = <em>L.nil.next</em></p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> start at the head of the list</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> <em>x.key</em> ≠ <em>k</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><em>x</em> = <em>x.next</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>x</em> == <em>L.nil</em></p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> found <em>k</em> in the sentinel</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> <small>NIL</small></p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> <em>k</em> was not really in the list</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1"><p class="noindent"><strong>else return</strong> <em>x</em></p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> found <em>k</em> in element <em>x</em></span></p></td>
</tr>
</table>
</div>
<a id="p264"/>
<p>Sentinels often simplify code and, as in searching a linked list, they might speed up code by a small constant factor, but they don’t typically improve the asymptotic running time. Use them judiciously. When there are many small lists, the extra storage used by their sentinels can represent significant wasted memory. In this book, we use sentinels only when they significantly simplify the code.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>10.2-1</em></strong></p>
<p class="noindent">Explain why the dynamic-set operation I<small>NSERT</small> on a singly linked list can be implemented in <em>O</em>(1) time, but the worst-case time for D<small>ELETE</small> is Θ(<em>n</em>).</p>
<p class="level3"><strong><em>10.2-2</em></strong></p>
<p class="noindent">Implement a stack using a singly linked list. The operations P<small>USH</small> and P<small>OP</small> should still take <em>O</em>(1) time. Do you need to add any attributes to the list?</p>
<p class="level3"><strong><em>10.2-3</em></strong></p>
<p class="noindent">Implement a queue using a singly linked list. The operations E<small>NQUEUE</small> and D<small>EQUEUE</small> should still take <em>O</em>(1) time. Do you need to add any attributes to the list?</p>
<p class="level3"><strong><em>10.2-4</em></strong></p>
<p class="noindent">The dynamic-set operation U<small>NION</small> takes two disjoint sets <em>S</em><sub>1</sub> and <em>S</em><sub>2</sub> as input, and it returns a set <em>S</em> = <em>S</em><sub>1</sub> <span class="font1">⋃</span> <em>S</em><sub>2</sub> consisting of all the elements of <em>S</em><sub>1</sub> and <em>S</em><sub>2</sub>. The sets <em>S</em><sub>1</sub> and <em>S</em><sub>2</sub> are usually destroyed by the operation. Show how to support U<small>NION</small> in <em>O</em>(1) time using a suitable list data structure.</p>
<p class="level3"><strong><em>10.2-5</em></strong></p>
<p class="noindent">Give a Θ(<em>n</em>)-time nonrecursive procedure that reverses a singly linked list of <em>n</em> elements. The procedure should use no more than constant storage beyond that needed for the list itself.</p>
<p class="level3"><span class="font1">★</span> <strong><em>10.2-6</em></strong></p>
<p class="noindent">Explain how to implement doubly linked lists using only one pointer value <em>x.np</em> per item instead of the usual two (<em>next</em> and <em>prev</em>). Assume that all pointer values can be interpreted as <em>k</em>-bit integers, and define <em>x.np</em> = <em>x.next</em> XOR <em>x.prev</em>, the <em>k</em>-bit “exclusive-or” of <em>x.next</em> and <em>x.prev</em>. The value <small>NIL</small> is represented by 0. Be sure to describe what information you need to access the head of the list. Show how to implement the S<small>EARCH</small>, I<small>NSERT</small>, and D<small>ELETE</small> operations on such a list. Also show how to reverse such a list in <em>O</em>(1) time.</p>
<a id="p265"/>
</section>
<p class="line1"/>
<section title="10.3 Representing rooted trees">
<a id="Sec_10.3"/>
<p class="level1" id="h1-59"><a href="toc.xhtml#Rh1-59"><strong>10.3    Representing rooted trees</strong></a></p>
<p class="noindent">Linked lists work well for representing linear relationships, but not all relationships are linear. In this section, we look specifically at the problem of representing rooted trees by linked data structures. We first look at binary trees, and then we present a method for rooted trees in which nodes can have an arbitrary number of children.</p>
<p>We represent each node of a tree by an object. As with linked lists, we assume that each node contains a <em>key</em> attribute. The remaining attributes of interest are pointers to other nodes, and they vary according to the type of tree.</p>
<p class="level4"><strong>Binary trees</strong></p>
<p class="noindent"><a href="chapter010.xhtml#Fig_10-6">Figure 10.6</a> shows how to use the attributes <em>p</em>, <em>left</em>, and <em>right</em> to store pointers to the parent, left child, and right child of each node in a binary tree <em>T</em>. If <em>x.p</em> = <small>NIL</small>, then <em>x</em> is the root. If node <em>x</em> has no left child, then <em>x.left</em> = <small>NIL</small>, and similarly for the right child. The root of the entire tree <em>T</em> is pointed to by the attribute <em>T.root</em>. If <em>T.root</em> = <small>NIL</small>, then the tree is empty.</p>
<p class="level4"><strong>Rooted trees with unbounded branching</strong></p>
<p class="noindent">It’s simple to extend the scheme for representing a binary tree to any class of trees in which the number of children of each node is at most some constant <em>k</em>: replace the <em>left</em> and <em>right</em> attributes by <em>child</em><sub>1</sub>, <em>child</em><sub>2</sub>, … , <em>child<sub>k</sub></em>. This scheme no longer works when the number of children of a node is unbounded, however, since we do not know how many attributes to allocate in advance. Moreover, if <em>k</em>, the number of children, is bounded by a large constant but most nodes have a small number of children, we may waste a lot of memory.</p>
<p>Fortunately, there is a clever scheme to represent trees with arbitrary numbers of children. It has the advantage of using only <em>O</em>(<em>n</em>) space for any <em>n</em>-node rooted tree. The <strong><em><span class="blue1">left-child, right-sibling representation</span></em></strong> appears in <a href="chapter010.xhtml#Fig_10-7">Figure 10.7</a>. As before, each node contains a parent pointer <em>p</em>, and <em>T.root</em> points to the root of tree <em>T</em>. Instead of having a pointer to each of its children, however, each node <em>x</em> has only two pointers:</p>
<ol class="olnoindent" epub:type="list">
<li><em>x.left-child</em> points to the leftmost child of node <em>x</em>, and</li>
<li class="litop"><em>x.right-sibling</em> points to the sibling of <em>x</em> immediately to its right.</li></ol>
<p class="noindent">If node <em>x</em> has no children, then <em>x.left-child</em> = <small>NIL</small>, and if node <em>x</em> is the rightmost child of its parent, then <em>x.right-sibling</em> = <small>NIL</small>.</p>
<a id="p266"/>
<div class="divimage">
<p class="fig-imga" id="Fig_10-6"><img alt="art" src="images/Art_P372.jpg"/></p>
<p class="caption"><strong>Figure 10.6</strong> The representation of a binary tree <em>T</em>. Each node <em>x</em> has the attributes <em>x.p</em> (top), <em>x.left</em> (lower left), and <em>x.right</em> (lower right). The <em>key</em> attributes are not shown.</p>
</div>
<p class="block"/>
<div class="divimage">
<p class="fig-imga" id="Fig_10-7"><img alt="art" class="width100" src="images/Art_P373.jpg"/></p>
<p class="caption"><strong>Figure 10.7</strong> The left-child, right-sibling representation of a tree <em>T</em>. Each node <em>x</em> has attributes <em>x.p</em> (top), <em>x.left-child</em> (lower left), and <em>x.right-sibling</em> (lower right). The <em>key</em> attributes are not shown.</p>
</div>
<a id="p267"/>
<p class="level4"><strong>Other tree representations</strong></p>
<p class="noindent">We sometimes represent rooted trees in other ways. In <a href="chapter006.xhtml">Chapter 6</a>, for example, we represented a heap, which is based on a complete binary tree, by a single array along with an attribute giving the index of the last node in the heap. The trees that appear in <a href="chapter019.xhtml">Chapter 19</a> are traversed only toward the root, and so only the parent pointers are present: there are no pointers to children. Many other schemes are possible. Which scheme is best depends on the application.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>10.3-1</em></strong></p>
<p class="noindent">Draw the binary tree rooted at index 6 that is represented by the following attributes:</p>
<table class="table3a">
<tr>
<td class="th1"><p class="noindent">index</p></td>
<td class="th1"><p class="center"><em>key</em></p></td>
<td class="th1"><p class="center"><em>left</em></p></td>
<td class="th1"><p class="center"><em>right</em></p></td>
</tr>
<tr>
<td class="td1"><p class="center">1</p></td>
<td class="td1"><p class="center">17</p></td>
<td class="td1"><p class="center">8</p></td>
<td class="td1"><p class="center">9</p></td>
</tr>
<tr>
<td class="td1"><p class="center">2</p></td>
<td class="td1"><p class="center">14</p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="center">3</p></td>
<td class="td1"><p class="center">12</p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="center">4</p></td>
<td class="td1"><p class="center">20</p></td>
<td class="td1"><p class="center">10</p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="center">5</p></td>
<td class="td1"><p class="center">33</p></td>
<td class="td1"><p class="center">2</p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="center">6</p></td>
<td class="td1"><p class="center">15</p></td>
<td class="td1"><p class="center">1</p></td>
<td class="td1"><p class="center">4</p></td>
</tr>
<tr>
<td class="td1"><p class="center">7</p></td>
<td class="td1"><p class="center">28</p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="center">8</p></td>
<td class="td1"><p class="center">22</p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="center">9</p></td>
<td class="td1"><p class="center">13</p></td>
<td class="td1"><p class="center">3</p></td>
<td class="td1"><p class="center">7</p></td>
</tr>
<tr>
<td class="td1"><p class="center">10</p></td>
<td class="td1"><p class="center">25</p></td>
<td class="td1"><p class="center"><small>NIL</small></p></td>
<td class="td1"><p class="center">5</p></td>
</tr>
</table>
<p class="level3"><strong><em>10.3-2</em></strong></p>
<p class="noindent">Write an <em>O</em>(<em>n</em>)-time recursive procedure that, given an <em>n</em>-node binary tree, prints out the key of each node in the tree.</p>
<p class="level3"><strong><em>10.3-3</em></strong></p>
<p class="noindent">Write an <em>O</em>(<em>n</em>)-time nonrecursive procedure that, given an <em>n</em>-node binary tree, prints out the key of each node in the tree. Use a stack as an auxiliary data structure.</p>
<p class="level3"><strong><em>10.3-4</em></strong></p>
<p class="noindent">Write an <em>O</em>(<em>n</em>)-time procedure that prints out all the keys of an arbitrary rooted tree with <em>n</em> nodes, where the tree is stored using the left-child, right-sibling representation.</p>
<p class="level3"><span class="font1">★</span> <strong><em>10.3-5</em></strong></p>
<p class="noindent">Write an <em>O</em>(<em>n</em>)-time nonrecursive procedure that, given an <em>n</em>-node binary tree, prints out the key of each node. Use no more than constant extra space outside <a id="p268"/>of the tree itself and do not modify the tree, even temporarily, during the procedure.</p>
<p class="level3"><span class="font1">★</span> <strong><em>10.3-6</em></strong></p>
<p class="noindent">The left-child, right-sibling representation of an arbitrary rooted tree uses three pointers in each node: <em>left-child</em>, <em>right-sibling</em>, and <em>parent</em>. From any node, its parent can be accessed in constant time and all its children can be accessed in time linear in the number of children. Show how to use only two pointers and one boolean value in each node <em>x</em> so that <em>x</em>’s parent or all of <em>x</em>’s children can be accessed in time linear in the number of <em>x</em>’s children.</p>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-60"><strong>Problems</strong></p>
<section title="10-1 Comparisons among lists">
<p class="level2"><strong><em>10-1     Comparisons among lists</em></strong></p>
<p class="noindent">For each of the four types of lists in the following table, what is the asymptotic worst-case running time for each dynamic-set operation listed?</p>
<table class="table1a">
<tr>
<td class="td1br"> </td>
<td class="td1br"><p class="center">unsorted, singly linked</p></td>
<td class="td1br"><p class="center">sorted, singly linked</p></td>
<td class="td1br"><p class="center">unsorted, doubly linked</p></td>
<td class="td1br"><p class="center">sorted, doubly linked</p></td>
</tr>
<tr>
<td class="td1br"><p class="noindent">S<small>EARCH</small></p></td>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
</tr>
<tr>
<td class="td1br"><p class="noindent">I<small>NSERT</small></p></td>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
</tr>
<tr>
<td class="td1br"><p class="noindent">D<small>ELETE</small></p></td>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
</tr>
<tr>
<td class="td1br"><p class="noindent">S<small>UCCESSOR</small></p></td>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
</tr>
<tr>
<td class="td1br"><p class="noindent">P<small>REDECESSOR</small></p></td>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
</tr>
<tr>
<td class="td1br"><p class="noindent">M<small>INIMUM</small></p></td>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
</tr>
<tr>
<td class="td1br"><p class="noindent">M<small>AXIMUM</small></p></td>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
<td class="td1br"/>
</tr>
</table>
</section>
<section title="10-2 Mergeable heaps using linked lists">
<p class="level2"><strong><em>10-2     Mergeable heaps using linked lists</em></strong></p>
<p class="noindent">A <strong><em><span class="blue1">mergeable heap</span></em></strong> supports the following operations: M<small>AKE</small>-H<small>EAP</small> (which creates an empty mergeable heap), I<small>NSERT</small>, M<small>INIMUM</small>, E<small>XTRACT</small>-M<small>IN</small>, and U<small>NION</small>.<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup> <a id="p269"/>Show how to implement mergeable heaps using linked lists in each of the following cases. Try to make each operation as efficient as possible. Analyze the running time of each operation in terms of the size of the dynamic set(s) being operated on.</p>
<p class="nl"><strong><em>a.</em></strong> Lists are sorted.</p>
<p class="nl"><strong><em>b.</em></strong> Lists are unsorted.</p>
<p class="nl"><strong><em>c.</em></strong> Lists are unsorted, and dynamic sets to be merged are disjoint.</p>
</section>
<section title="10-3 Searching a sorted compact list">
<p class="level2"><strong><em>10-3     Searching a sorted compact list</em></strong></p>
<p class="noindent">We can represent a singly linked list with two arrays, <em>key</em> and <em>next</em>. Given the index <em>i</em> of an element, its value is stored in <em>key</em>[<em>i</em>], and the index of its successor is given by <em>next</em>[<em>i</em>], where <em>next</em>[<em>i</em>] = <small>NIL</small> for the last element. We also need the index <em>head</em> of the first element in the list. An <em>n</em>-element list stored in this way is <strong><em><span class="blue1">compact</span></em></strong> if it is stored only in positions 1 through <em>n</em> of the <em>key</em> and <em>next</em> arrays.</p>
<p>Let’s assume that all keys are distinct and that the compact list is also sorted, that is, <em>key</em>[<em>i</em>] &lt; <em>key</em>[<em>next</em>[<em>i</em>]] for all <em>i</em> = 1, 2, … , <em>n</em> such that <em>next</em>[<em>i</em>] ≠ <small>NIL</small>. Under these assumptions, you will show that the randomized algorithm C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small> searches the list for key <em>k</em> in <img alt="art" src="images/Art_P374.jpg"/> expected time.</p>
<div class="pull-quote1">
<p class="box-heading">C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small>(<em>key</em>, <em>next</em>, <em>head</em>, <em>n</em>, <em>k</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><em>i</em> = <em>head</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> <em>i</em> ≠ <small>NIL</small> and <em>key</em>[<em>i</em>] &lt; <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="p2"><em>j</em> = R<small>ANDOM</small>(1, <em>n</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>key</em>[<em>i</em>] &lt; <em>key</em>[<em>j</em>] and <em>key</em>[<em>j</em>] ≤ <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="p3"><em>i</em> = <em>j</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>key</em>[<em>i</em>] == <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="p4"><strong>return</strong> <em>i</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="p2"><em>i</em> = <em>next</em>[<em>i</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>i</em> == <small>NIL</small> or <em>key</em>[<em>i</em>] &gt; <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">11</span></p></td>
<td class="td1"><p class="noindent"><strong>else return</strong> <em>i</em></p></td>
</tr>
</table>
</div>
<p>If you ignore lines 3–7 of the procedure, you can see that it’s an ordinary algorithm for searching a sorted linked list, in which index <em>i</em> points to each position of the list in turn. The search terminates once the index <em>i</em> “falls off” the end of the list or once <em>key</em>[<em>i</em>] ≥ <em>k</em>. In the latter case, if <em>key</em>[<em>i</em>] = <em>k</em>, the procedure has found a key with the value <em>k</em>. If, however, <em>key</em>[<em>i</em>] &gt; <em>k</em>, then the search will never find a key with the value <em>k</em>, so that terminating the search was the correct action.</p>
<a id="p270"/>
<p>Lines 3–7 attempt to skip ahead to a randomly chosen position <em>j</em>. Such a skip helps if <em>key</em>[<em>j</em>] is larger than <em>key</em>[<em>i</em>] and no larger than <em>k</em>. In such a case, <em>j</em> marks a position in the list that <em>i</em> would reach during an ordinary list search. Because the list is compact, we know that any choice of <em>j</em> between 1 and <em>n</em> indexes some element in the list.</p>
<p>Instead of analyzing the performance of C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small> directly, you will analyze a related algorithm, C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small>, which executes two separate loops. This algorithm takes an additional parameter <em>t</em>, which specifies an upper bound on the number of iterations of the first loop.</p>
<div class="pull-quote1">
<p class="box-heading">C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small>′ (<em>key</em>, <em>next</em>, <em>head</em>, <em>n</em>, <em>k</em>, <em>t</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><em>i</em> = <em>head</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>q</em> = 1 <strong>to</strong> <em>t</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="p2"><em>j</em> = R<small>ANDOM</small>(1, <em>n</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>key</em>[<em>i</em>] &lt; <em>key</em>[<em>j</em>] and <em>key</em>[<em>j</em>] ≤ <em>k</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="p3"><em>i</em> = <em>j</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>key</em>[<em>i</em>] == <em>k</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="p4"><strong>return</strong> <em>i</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> <em>i</em> ≠ <small>NIL</small> and <em>key</em>[<em>i</em>] &lt; <em>k</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="p2"><em>i</em> = <em>next</em>[<em>i</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>i</em> == <small>NIL</small> or <em>key</em>[<em>i</em>] &gt; <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">11</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">12</span></p></td>
<td class="td1"><p class="noindent"><strong>else return</strong> <em>i</em></p></td>
</tr>
</table>
</div>
<p>To compare the execution of the two algorithms, assume that the sequence of calls of R<small>ANDOM</small>(1, <em>n</em>) yields the same sequence of integers for both algorithms.</p>
<p class="nl"><strong><em>a.</em></strong> Argue that for any value of <em>t</em>, C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small>(<em>key</em>, <em>next</em>, <em>head</em>, <em>n</em>, <em>k</em>) and C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small>′ (<em>key</em>, <em>next</em>, <em>head</em>, <em>n</em>, <em>k</em>, <em>t</em>) return the same result and that the number of iterations of the <strong>while</strong> loop of lines 2–8 in C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small> is at most the total number of iterations of both the <strong>for</strong> and <strong>while</strong> loops in C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small>′.</p>
<p class="noindent1-top">In the call C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small>′ (<em>key</em>, <em>next</em>, <em>head</em>, <em>n</em>, <em>k</em>, <em>t</em>), let <em>X<sub>t</sub></em> be the random variable that describes the distance in the linked list (that is, through the chain of <em>next</em> pointers) from position <em>i</em> to the desired key <em>k</em> after <em>t</em> iterations of the <strong>for</strong> loop of lines 2–7 have occurred.</p>
<p class="nl"><strong><em>b.</em></strong> Argue that C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small>′ (<em>key</em>, <em>next</em>, <em>head</em>, <em>n</em>, <em>k</em>, <em>t</em>) has an expected running time of <em>O</em>(<em>t</em> + E [<em>X<sub>t</sub></em>]).</p>
<p class="nl"><strong><em>c.</em></strong> Show that <img alt="art" src="images/Art_P375.jpg"/>. (<em>Hint:</em> Use equation (C.28) on page 1193.)</p>
<a id="p271"/>
<p class="nl"><strong><em>d.</em></strong> Show that <img alt="art" src="images/Art_P376.jpg"/>. (<em>Hint:</em> Use inequality (A.18) on page 1150.)</p>
<p class="nl"><strong><em>e.</em></strong> Prove that E [<em>X<sub>t</sub></em>] ≤ <em>n</em>/(<em>t</em> + 1).</p>
<p class="nl"><strong><em>f.</em></strong> Show that C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small>′ (<em>key</em>, <em>next</em>, <em>head</em>, <em>n</em>, <em>k</em>, <em>t</em>) has an expected running time of <em>O</em>(<em>t</em> + <em>n</em>/<em>t</em>).</p>
<p class="nl"><strong><em>g.</em></strong> Conclude that C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small> runs in <img alt="art" src="images/Art_P377.jpg"/> expected time.</p>
<p class="nl"><strong><em>h.</em></strong> Why do we assume that all keys are distinct in C<small>OMPACT</small>-L<small>IST</small>-S<small>EARCH</small>? Argue that random skips do not necessarily help asymptotically when the list contains repeated key values.</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-61"><strong>Chapter notes</strong></p>
<p class="noindent">Aho, Hopcroft, and Ullman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_6">6</a>] and Knuth [<a epub:type="noteref" href="bibliography001.xhtml#endnote_259">259</a>] are excellent references for elementary data structures. Many other texts cover both basic data structures and their implementation in a particular programming language. Examples of these types of textbooks include Goodrich and Tamassia [<a epub:type="noteref" href="bibliography001.xhtml#endnote_196">196</a>], Main [<a epub:type="noteref" href="bibliography001.xhtml#endnote_311">311</a>], Shaffer [<a epub:type="noteref" href="bibliography001.xhtml#endnote_406">406</a>], and Weiss [<a epub:type="noteref" href="bibliography001.xhtml#endnote_452">452</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_453">453</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_454">454</a>]. The book by Gonnet and Baeza-Yates [<a epub:type="noteref" href="bibliography001.xhtml#endnote_193">193</a>] provides experimental data on the performance of many data-structure operations.</p>
<p>The origin of stacks and queues as data structures in computer science is unclear, since corresponding notions already existed in mathematics and paper-based business practices before the introduction of digital computers. Knuth [<a epub:type="noteref" href="bibliography001.xhtml#endnote_259">259</a>] cites A. M. Turing for the development of stacks for subroutine linkage in 1947.</p>
<p>Pointer-based data structures also seem to be a folk invention. According to Knuth, pointers were apparently used in early computers with drum memories. The A-1 language developed by G. M. Hopper in 1951 represented algebraic formulas as binary trees. Knuth credits the IPL-II language, developed in 1956 by A. Newell, J. C. Shaw, and H. A. Simon, for recognizing the importance and promoting the use of pointers. Their IPL-III language, developed in 1957, included explicit stack operations.</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> Because we have defined a mergeable heap to support M<small>INIMUM</small> and E<small>XTRACT</small>-M<small>IN</small>, we can also refer to it as a <strong><em><span class="blue1">mergeable min-heap</span></em></strong>. Alternatively, if it supports M<small>AXIMUM</small> and E<small>XTRACT</small>-M<small>AX</small>, it is a <strong><em><span class="blue1">mergeable max-heap</span></em></strong>.</p>
</section>
</section>
</div>
</body>
</html>