<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p957"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="32 String Matching">
<p class="chapter-title"><a href="toc.xhtml#chap-32"><strong><span class="blue1">32        String Matching</span></strong></a></p>
<p class="noindent">Text-editing programs frequently need to find all occurrences of a pattern in the text. Typically, the text is a document being edited, and the pattern searched for is a particular word supplied by the user. Efficient algorithms for this problem—called “string matching”—can greatly aid the responsiveness of the text-editing program. Among their many other applications, string-matching algorithms search for particular patterns in DNA sequences. Internet search engines also use them to find web pages relevant to queries.</p>
<p>The string-matching problem can be stated formally as follows. The text is given as an array <em>T</em>[1 : <em>n</em>] of length <em>n</em>, and the pattern is an array <em>P</em>[1 : <em>m</em>] of length <em>m</em> ≤ <em>n</em>. The elements of <em>P</em> and <em>T</em> are characters drawn from an alphabet ∑, which is a finite set of characters. For example, ∑ could be the set {<span class="courierfont">0</span>, <span class="courierfont">1</span>}, or it could be the set {<span class="courierfont">a</span>, <span class="courierfont">b</span>, …, <span class="courierfont">z</span>}. The character arrays <em>P</em> and <em>T</em> are often called <span class="blue"><strong><em>strings</em></strong></span> of characters.</p>
<p>As <a href="chapter032.xhtml#Fig_32-1">Figure 32.1</a> shows, pattern <em>P</em> <span class="blue"><strong><em>occurs with shift s</em></strong></span> in text <em>T</em> (or, equivalently, that pattern <em>P</em> <span class="blue"><strong><em>occurs beginning at position s</em> + 1</strong></span> in text <em>T</em>) if 0 ≤ <em>s</em> ≤ <em>n</em> – <em>m</em> and <em>T</em>[<em>s</em> + 1:<em>s</em> + <em>m</em>] = <em>P</em>[1:<em>m</em>], that is, if <em>T</em>[<em>s</em> + <em>j</em>] = <em>P</em>[<em>j</em>], for 1 ≤ <em>j</em> ≤ <em>m</em>. If <em>P</em> occurs with shift <em>s</em> in <em>T</em>, then <em>s</em> is a <span class="blue"><strong><em>valid shift</em></strong></span>, and otherwise, <em>s</em> is an <span class="blue"><strong><em>invalid shift</em></strong></span>. The <span class="blue"><strong><em>string-matching problem</em></strong></span> is the problem of finding all valid shifts with which a given pattern <em>P</em> occurs in a given text <em>T</em>.</p>
<div class="divimage">
<p class="fig-img1" id="Fig_32-1"><img alt="art" src="images/Art_P1288.jpg"/></p>
<p class="caption"><strong>Figure 32.1</strong> An example of the string-matching problem to find all occurrences of the pattern <em>P</em> = <span class="courierfont">abaa</span> in the text <em>T</em> = <span class="courierfont">abcabaabcabac</span>. The pattern occurs only once in the text, at shift <em>s</em> = 3, which is a valid shift. A vertical line connects each character of the pattern to its matching character in the text, and all matched characters are shaded blue.</p>
</div>
<a id="p958"/>
<p>Except for the naive brute-force algorithm in <a href="chapter032.xhtml#Sec_32.1">Section 32.1</a>, each string-matching algorithm in this chapter performs some preprocessing based on the pattern and then finds all valid shifts. We call this latter phase “matching.” Here are the preprocessing and matching times for each of the string-matching algorithms in this chapter. The total running time of each algorithm is the sum of the preprocessing and matching times:</p>
<table class="table1a">
<tr>
<td class="th1b">Algorithm</td>
<td class="th1b"><p class="center">Preprocessing time</p></td>
<td class="th1b"><p class="center">Matching time</p></td>
</tr>
<tr>
<td class="td1">Naive</td>
<td class="td1"><p class="center">0</p></td>
<td class="td1"><p class="center"><em>O</em>((<em>n</em> – <em>m</em> + 1)<em>m</em>)</p></td>
</tr>
<tr>
<td class="td1">Rabin-Karp</td>
<td class="td1"><p class="center">Θ(<em>m</em>)</p></td>
<td class="td1"><p class="center"><em>O</em>((<em>n</em> – <em>m</em> + 1)<em>m</em>)</p></td>
</tr>
<tr>
<td class="td1">Finite automaton</td>
<td class="td1"><p class="center"><em>O</em>(<em>m</em> |∑|)</p></td>
<td class="td1"><p class="center">Θ(<em>n</em>)</p></td>
</tr>
<tr>
<td class="td1">Knuth-Morris-Pratt</td>
<td class="td1"><p class="center">Θ(<em>m</em>)</p></td>
<td class="td1"><p class="center">Θ(<em>n</em>)</p></td>
</tr>
<tr>
<td class="td1">Suffix array<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup></td>
<td class="td1"><p class="center"><em>O</em>(<em>n</em> 1g <em>n</em>)</p></td>
<td class="td1"><p class="center"><em>O</em>(<em>m</em> 1g <em>n</em> + <em>km</em>)</p></td>
</tr>
</table>
<p class="noindent"><a href="chapter032.xhtml#Sec_32.2">Section 32.2</a> presents an interesting string-matching algorithm, due to Rabin and Karp. Although the Θ((<em>n</em> – <em>m</em> + 1)<em>m</em>) worst-case running time of this algorithm is no better than that of the naive method, it works much better on average and in practice. It also generalizes nicely to other pattern-matching problems. <a href="chapter032.xhtml#Sec_32.3">Section 32.3</a> then describes a string-matching algorithm that begins by constructing a finite automaton specifically designed to search for occurrences of the given pattern <em>P</em> in a text. This algorithm takes <em>O</em>(<em>m</em> |∑|) preprocessing time, but only Θ(<em>n</em>) matching time. <a href="chapter032.xhtml#Sec_32.4">Section 32.4</a> presents the similar, but much cleverer, Knuth-Morris-Pratt (or KMP) algorithm, which has the same Θ(<em>n</em>) matching time, but it reduces the preprocessing time to only Θ(<em>m</em>).</p>
<p>A completely different approach appears in <a href="chapter032.xhtml#Sec_32.5">Section 32.5</a>, which examines suffix arrays and the longest common prefix array. You can use these arrays not only to find a pattern in a text, but also to answer other questions, such as what is the longest repeated substring in the text and what is the longest common substring between two texts. The algorithm to form the suffix array in <a href="chapter032.xhtml#Sec_32.5">Section 32.5</a> takes <em>O</em>(<em>n</em> 1g <em>n</em>) time and, given the suffix array, the section shows how to compute the longest common prefix array in <em>O</em>(<em>n</em>) time.</p>
<p class="level4"><strong>Notation and terminology</strong></p>
<p class="noindent">We denote by ∑* (read “sigma-star”) the set of all finite-length strings formed using characters from the alphabet ∑. This chapter considers only finite-length <a id="p959"/>strings. The 0-length <span class="blue"><strong><em>empty string</em></strong></span>, denoted <em><span class="font1">ϵ</span></em>, also belongs to ∑*. The length of a string <em>x</em> is denoted |<em>x</em>|. The <span class="blue"><strong><em>concatenation</em></strong></span> of two strings <em>x</em> and <em>y</em>, denoted <em>xy</em>, has length |<em>x</em>| + |<em>y</em>| and consists of the characters from <em>x</em> followed by the characters from <em>y</em>.</p>
<div class="divimage">
<p class="fig-img1" id="Fig_32-2"><img alt="art" src="images/Art_P1289.jpg"/></p>
<p class="caption"><strong>Figure 32.2</strong> A graphical proof of Lemma 32.1. Suppose that <em>x</em> <span class="font1">⊐</span> <em>z</em> and <em>y</em> <span class="font1">⊐</span> <em>z</em>. The three parts of the figure illustrate the three cases of the lemma. Vertical lines connect matching regions (shown in blue) of the strings. <strong>(a)</strong> If |<em>x</em>| ≤ |<em>y</em>|, then <em>x</em> <span class="font1">⊐</span> <em>y</em>. <strong>(b)</strong> If |<em>x</em>| ≥ |<em>y</em>|, then <em>y</em> <span class="font1">⊐</span> <em>x</em>. <strong>(c)</strong> If |<em>x</em>| = |<em>y</em>|, then <em>x</em> = <em>y</em>.</p>
</div>
<p>A string <em>w</em> is a <span class="blue"><strong><em>prefix</em></strong></span> of a string <em>x</em>, denoted <em>w</em> <span class="font1">⊏</span> <em>x</em>, if <em>x</em> = <em>wy</em> for some string <em>y</em> ∈ ∑*. Note that if <em>w</em> <span class="font1">⊏</span> <em>x</em>, then |<em>w</em>| ≤ |<em>x</em>|. Similarly, a string <em>w</em> is a <span class="blue"><strong><em>suffix</em></strong></span> of a string <em>x</em>, denoted <em>w</em> <span class="font1">⊐</span> <em>x</em>, if <em>x</em> = <em>yw</em> for some <em>y</em> ∈ ∑*. As with a prefix, <em>w</em> <span class="font1">⊐</span> <em>x</em> implies |<em>w</em>| ≤ |<em>x</em>|. For example, <span class="courierfont">ab</span> <span class="font1">⊏</span> <span class="courierfont">abcca</span> and <span class="courierfont">cca</span> <span class="font1">⊐</span> <span class="courierfont">abcca</span>. A string <em>w</em> is a <span class="blue"><strong><em>proper prefix</em></strong></span> of <em>x</em> if <em>w</em> <span class="font1">⊏</span> <em>x</em> and |<em>w</em>| &lt; |<em>x</em>|, and likewise for a <span class="blue"><strong><em>proper suffix</em></strong></span>. The empty string <em><span class="font1">ϵ</span></em> is both a suffix and a prefix of every string. For any strings <em>x</em> and <em>y</em> and any character <em>a</em>, we have <em>x</em> <span class="font1">⊐</span> <em>y</em> if and only if <em>xa</em> <span class="font1">⊐</span> <em>ya</em>. The <span class="font1">⊏</span> and <span class="font1">⊐</span> relations are transitive. The following lemma will be useful later.</p>
<p class="lem"><strong><em>Lemma 32.1 (Overlapping-suffix lemma)</em></strong></p>
<p class="noindent">Suppose that <em>x</em>, <em>y</em>, and <em>z</em> are strings such that <em>x</em> <span class="font1">⊐</span> <em>z</em> and <em>y</em> <span class="font1">⊐</span> <em>z</em>. If |<em>x</em>| ≤ |<em>y</em>|, then <em>x</em> <span class="font1">⊐</span> <em>y</em>. If |<em>x</em>| ≥ |<em>y</em>|, then <em>y</em> <span class="font1">⊐</span> <em>x</em>. If |<em>x</em>| = |<em>y</em>|, then <em>x</em> = <em>y</em>.</p>
<p class="proof"><strong><em>Proof</em></strong>   See <a href="chapter032.xhtml#Fig_32-2">Figure 32.2</a> for a graphical proof.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">For convenience, denote the <em>k</em>-character prefix <em>P</em>[1:<em>k</em>] of the pattern <em>P</em>[1:<em>m</em>] by <em>P</em>[:<em>k</em>]. Thus, we can write <em>P</em>[:0] = <em><span class="font1">ϵ</span></em> and <em>P</em>[:<em>m</em>] = <em>P</em> = <em>P</em>[1:<em>m</em>]. Similarly, denote the <em>k</em>-character prefix of the text <em>T</em> by <em>T</em>[:<em>k</em>]. Using this notation, we <a id="p960"/>can state the string-matching problem as that of finding all shifts <em>s</em> in the range 0 ≤ <em>s</em> ≤ <em>n</em> – <em>m</em> such that <em>P</em> <span class="font1">⊐</span> <em>T</em>[:<em>s</em> + <em>m</em>].</p>
<p>Our pseudocode allows two equal-length strings to be compared for equality as a primitive operation. If the strings are compared from left to right and the comparison stops when a mismatch is discovered, we assume that the time taken by such a test is a linear function of the number of matching characters discovered. To be precise, the test “<em>x</em> == <em>y</em>” is assumed to take Θ(<em>t</em>) time, where <em>t</em> is the length of the longest string <em>z</em> such that <em>z</em> <span class="font1">⊏</span> <em>x</em> and <em>z</em> <span class="font1">⊏</span> <em>y</em>.</p>
<p class="line1"/>
<section title="32.1 The naive string-matching algorithm">
<a id="Sec_32.1"/>
<p class="level1" id="h1-187"><a href="toc.xhtml#Rh1-187"><strong>32.1    The naive string-matching algorithm</strong></a></p>
<p class="noindent">The N<small>AIVE</small>-S<small>TRING</small>-M<small>ATCHER</small> procedure finds all valid shifts using a loop that checks the condition <em>P</em>[1:<em>m</em>] = <em>T</em>[<em>s</em>+1:<em>s</em>+<em>m</em>] for each of the <em>n</em>−<em>m</em>+1 possible values of <em>s</em>.</p>
<div class="pull-quote1">
<p class="box-heading">N<small>AIVE</small>-S<small>TRING</small>-M<small>ATCHER</small>(<em>T</em>, <em>P</em>, <em>n</em>, <em>m</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>for</strong> <em>s</em> = 0 <strong>to</strong> <em>n</em> – <em>m</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>P</em>[1:<em>m</em>] == <em>T</em>[<em>s</em> + 1:<em>s</em> + <em>m</em>]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p3">print “Pattern occurs with shift” <em>s</em></p></td>
</tr>
</table>
</div>
<p><a href="chapter032.xhtml#Fig_32-3">Figure 32.3</a> portrays the naive string-matching procedure as sliding a “template” containing the pattern over the text, noting for which shifts all of the characters on the template equal the corresponding characters in the text. The <strong>for</strong> loop of lines 1–3 considers each possible shift explicitly. The test in line 2 determines whether the current shift is valid. This test implicitly loops to check corresponding character positions until all positions match successfully or a mismatch is found. Line 3 prints out each valid shift <em>s</em>.</p>
<p>Procedure N<small>AIVE</small>-S<small>TRING</small>-M<small>ATCHER</small> takes <em>O</em>((<em>n</em> – <em>m</em> + 1)<em>m</em>) time, and this bound is tight in the worst case. For example, consider the text string <span class="courierfont">a</span><sup><em>n</em></sup> (a string of <em>n</em><span class="courierfont">a</span>’s) and the pattern <span class="courierfont">a</span><sup><em>m</em></sup>. For each of the <em>n</em>−<em>m</em>+1 possible values of the shift <em>s</em>, the implicit loop on line 2 to compare corresponding characters must execute <em>m</em> times to validate the shift. The worst-case running time is thus Θ((<em>n</em> − <em>m</em> + 1)<em>m</em>), which is Θ(<em>n</em><sup>2</sup>) if <em>m</em> = <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span>. Because it requires no preprocessing, N<small>AIVE</small>-S<small>TRING</small>-M<small>ATCHER</small>’s running time equals its matching time.</p>
<p>N<small>AIVE</small>-S<small>TRING</small>-M<small>ATCHER</small> is far from an optimal procedure for this problem. Indeed, this chapter will show that the Knuth-Morris-Pratt algorithm is much better in the worst case. The naive string-matcher is inefficient because it entirely ignores information gained about the text for one value of <em>s</em> when it considers other values of <em>s</em>. Such information can be quite valuable, however. For example, if <em>P</em> = <span class="courierfont">aaab</span> <a id="p961"/>and <em>s</em> = 0 is valid, then none of the shifts 1, 2, or 3 are valid, since <em>T</em>[4] = <span class="courierfont">b</span>. The following sections examine several ways to make effective use of this sort of information.</p>
<div class="divimage">
<p class="fig-img1" id="Fig_32-3"><img alt="art" class="width100" src="images/Art_P1290.jpg"/></p>
<p class="caption"><strong>Figure 32.3</strong> The operation of the N<small>AIVE</small>-S<small>TRING</small>-M<small>ATCHER</small> procedure for the pattern <em>P</em> = <span class="courierfont">aab</span> and the text <em>T</em> = <span class="courierfont">acaabc</span>. Imagine the pattern <em>P</em> as a template that slides next to the text. <strong>(a)–(d)</strong> The four successive alignments tried by the naive string matcher. In each part, vertical lines connect corresponding regions found to match (shown in blue), and a red jagged line connects the first mismatched character found, if any. The algorithm finds one occurrence of the pattern, at shift <em>s</em> = 2, shown in part (c).</p>
</div>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>32.1-1</em></strong></p>
<p class="noindent">Show the comparisons the naive string matcher makes for the pattern <em>P</em> = <span class="courierfont">0001</span> in the text <em>T</em> = <span class="courierfont">000010001010001</span>.</p>
<p class="level3"><strong><em>32.1-2</em></strong></p>
<p class="noindent">Suppose that all characters in the pattern <em>P</em> are different. Show how to accelerate N<small>AIVE</small>-S<small>TRING</small>-M<small>ATCHER</small> to run in <em>O</em>(<em>n</em>) time on an <em>n</em>-character text <em>T</em>.</p>
<p class="level3"><strong><em>32.1-3</em></strong></p>
<p class="noindent">Suppose that pattern <em>P</em> and text <em>T</em> are <em>randomly</em> chosen strings of length <em>m</em> and <em>n</em>, respectively, from the <em>d</em>-ary alphabet ∑<sub><em>d</em></sub> = {0, 1, …, <em>d</em> – 1}, where <em>d</em> ≥ 2. Show that the <em>expected</em> number of character-to-character comparisons made by the implicit loop in line 2 of the naive algorithm is</p>
<p class="eql"><img alt="art" src="images/Art_P1291.jpg"/></p>
<p class="noindent">over all executions of this loop. (Assume that the naive algorithm stops comparing characters for a given shift once it finds a mismatch or matches the entire pattern.) Thus, for randomly chosen strings, the naive algorithm is quite efficient.</p>
<p class="level3"><strong><em>32.1-4</em></strong></p>
<p class="noindent">Suppose that the pattern <em>P</em> may contain occurrences of a <span class="blue"><strong><em>gap character</em></strong></span> <span class="font1">♢</span> that can match an <em>arbitrary</em> string of characters (even one of 0 length). For example, the pattern <span class="courierfont">ab<span class="font1">♢</span>ba<span class="font1">♢</span>c</span> occurs in the text <span class="courierfont">cabccbacbacab</span> as</p>
<a id="p962"/>
<p class="eql"><img alt="art" src="images/Art_P1292.jpg"/></p>
<p class="noindent">and as</p>
<p class="eql"><img alt="art" src="images/Art_P1293.jpg"/></p>
<p class="noindent">The gap character may occur an arbitrary number of times in the pattern but not at all in the text. Give a polynomial-time algorithm to determine whether such a pattern <em>P</em> occurs in a given text <em>T</em>, and analyze the running time of your algorithm.</p>
</section>
<p class="line1"/>
<section title="32.2 The Rabin-Karp algorithm">
<a id="Sec_32.2"/>
<p class="level1" id="h1-188"><a href="toc.xhtml#Rh1-188"><strong>32.2    The Rabin-Karp algorithm</strong></a></p>
<p class="noindent">Rabin and Karp proposed a string-matching algorithm that performs well in practice and that also generalizes to other algorithms for related problems, such as two-dimensional pattern matching. The Rabin-Karp algorithm uses Θ(<em>m</em>) preprocessing time, and its worst-case running time is Θ((<em>n</em>−<em>m</em>+1)<em>m</em>). Based on certain assumptions, however, its average-case running time is better.</p>
<p>This algorithm makes use of elementary number-theoretic notions such as the equivalence of two numbers modulo a third number. You might want to refer to <a href="chapter031.xhtml#Sec_31.1">Section 31.1</a> for the relevant definitions.</p>
<p>For expository purposes, let’s assume that ∑ = {<span class="courierfont">0</span>, <span class="courierfont">1</span>, <span class="courierfont">2</span>, …, <span class="courierfont">9</span>}, so that each character is a decimal digit. (In the general case, you can assume that each character is a digit in radix-<em>d</em> notation, so that it has a numerical value in the range 0 to <em>d</em> – 1, where <em>d</em> = |∑|.) You can then view a string of <em>k</em> consecutive characters as representing a length-<em>k</em> decimal number. For example, the character string <span class="courierfont">31415</span> corresponds to the decimal number 31,415. Because we interpret the input characters as both graphical symbols and digits, it will be convenient in this section to denote them as digits in standard text font.</p>
<p>Given a pattern <em>P</em>[1:<em>m</em>], let <em>p</em> denote its corresponding decimal value. In a similar manner, given a text <em>T</em>[1:<em>n</em>], let <em>t</em><sub><em>s</em></sub> denote the decimal value of the length-<em>m</em> substring <em>T</em>[<em>s</em> + 1:<em>s</em> + <em>m</em>], for <em>s</em> = 0, 1, …, <em>n</em> – <em>m</em>. Certainly, <em>t</em><sub><em>s</em></sub> = <em>p</em> if and only if <em>T</em> [<em>s</em> + 1:<em>s</em> + <em>m</em>] = <em>P</em>[1:<em>m</em>], and thus, <em>s</em> is a valid shift if and only if <em>t</em><sub><em>s</em></sub> = <em>p</em>. If you could compute <em>p</em> in Θ(<em>m</em>) time and all the <em>t</em><sub><em>s</em></sub> values in a total of Θ(<em>n</em> – <em>m</em> + 1) time,<sup><a epub:type="footnote" href="#footnote_2" id="footnote_ref_2">2</a></sup> then you could determine all valid shifts <em>s</em> in Θ(<em>m</em>)+Θ(<em>n</em> − <em>m</em> + 1) = Θ(<em>n</em>) <a id="p963"/>time by comparing <em>p</em> with each of the <em>t</em><sub><em>s</em></sub> values. (For the moment, let’s not worry about the possibility that <em>p</em> and the <em>t</em><sub><em>s</em></sub> values might be very large numbers.)</p>
<p>Indeed, you can compute <em>p</em> in Θ(<em>m</em>) time using Horner’s rule (see Problem 2-3):</p>
<p class="eql"><img alt="art" src="images/Art_P1294.jpg"/></p>
<p class="noindent">Similarly, you can compute <em>t</em><sub>0</sub> from <em>T</em>[1:<em>m</em>] in Θ(<em>m</em>) time.</p>
<p>To compute the remaining values <em>t</em><sub>1</sub>, <em>t</em><sub>2</sub>, …, <em>t</em><sub><em>n</em>–<em>m</em></sub> in Θ(<em>n</em> – <em>m</em>) time, observe that you can compute <em>t</em><sub><em>s</em>+1</sub> from <em>t</em><sub><em>s</em></sub> in constant time, since</p>
<p class="eqr"><img alt="art" src="images/Art_P1295.jpg"/></p>
<p class="noindent">Subtracting 10<sup><em>m</em>−1</sup><em>T</em> [<em>s</em> + 1] removes the high-order digit from <em>t</em><sub><em>s</em></sub>, multiplying the result by 10 shifts the number left by one digit position, and adding <em>T</em>[<em>s</em> + <em>m</em> + 1] brings in the appropriate low-order digit. For example, suppose that <em>m</em> = 5, <em>t</em><sub><em>s</em></sub> = 31415, and the new low-order digit is <em>T</em>[<em>s</em> + 5 + 1] = 2. The high-order digit to remove is <em>T</em>[<em>s</em> + 1] = 3, and so</p>
<table class="table2b">
<tr>
<td class="td2"><em>t</em><sub><em>s</em>+1</sub></td>
<td class="td2">=</td>
<td class="td2">10 (31415 − 10000 · 3) + 2</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">14152.</td>
</tr>
</table>
<p class="noindent">If you precompute the constant 10<sup><em>m</em>−1</sup> (which you can do in <em>O</em>(1g <em>m</em>) time using the techniques of <a href="chapter031.xhtml#Sec_31.6">Section 31.6</a>, although for this application a straightforward <em>O</em>(<em>m</em>)-time method suffices), then each execution of equation (32.1) takes a constant number of arithmetic operations. Thus, you can compute <em>p</em> in Θ(<em>m</em>) time, and you can compute all of <em>t</em><sub>0</sub>, <em>t</em><sub>1</sub>, …, <em>t</em><sub><em>n</em>−<em>m</em></sub> in Θ(<em>n</em> − <em>m</em> + 1) time. Therefore, you can find all occurrences of the pattern <em>P</em>[1:<em>m</em>] in the text <em>T</em>[1: <em>n</em>] with Θ(<em>m</em>) preprocessing time and Θ(<em>n</em> − <em>m</em> + 1) matching time.</p>
<p>This scheme works well if <em>P</em> is short enough and the alphabet ∑ is small enough that arithmetic operations on <em>p</em> and <em>t</em><sub><em>s</em></sub> take constant time. But what if <em>P</em> is long, or if the size of ∑ means that instead of powers of 10 in equation (32.1) you have to use powers of a larger number (such as powers of 256 for the extended ASCII character set)? Then the values of <em>p</em> and <em>t</em><sub><em>s</em></sub> might be too large to work with in constant time. Fortunately, this problem can be solved, as <a href="chapter032.xhtml#Fig_32-4">Figure 32.4</a> shows: compute <em>p</em> and the <em>t</em><sub><em>s</em></sub> values modulo a suitable modulus <em>q</em>. You can compute <em>p</em> modulo <em>q</em> in Θ(<em>m</em>) time and all the <em>t</em><sub><em>s</em></sub> values modulo <em>q</em> in Θ(<em>n</em> − <em>m</em> + 1) time. With |∑| = 10, if you choose the modulus <em>q</em> as a prime such that 10<em>q</em> just fits within one computer word, then you can perform all the necessary computations with single-precision arithmetic. In general, with a <em>d</em>-ary alphabet {0, 1, …, <em>d</em> – 1}, choose <em>q</em> so that <em>dq</em> fits within a computer word and adjust the recurrence equation (32.1) to work modulo <em>q</em>, so that it becomes</p>
<p class="eqr"><img alt="art" src="images/Art_P1296.jpg"/></p>
<a id="p964"/>
<div class="divimage">
<p class="fig-img1" id="Fig_32-4"><img alt="art" src="images/Art_P1297.jpg"/></p>
<p class="caption"><strong>Figure 32.4</strong> The Rabin-Karp algorithm. Each character is a decimal digit. Values are computed modulo 13. <strong>(a)</strong> A text string. A window of length 5 is shaded blue. The numerical value of the blue number, computed modulo 13, yields the value 7. <strong>(b)</strong> The same text string with values computed modulo 13 for each possible position of a length-5 window. Assuming the pattern <em>P</em> = 31415, look for windows whose value modulo 13 is 7, since 31415 = 7 (mod 13). The algorithm finds two such windows, shaded blue in the figure. The first, beginning at text position 7, is indeed an occurrence of the pattern. The second window, beginning at text position 13, is a spurious hit. <strong>(c)</strong> How to compute the value for a window in constant time, given the value for the previous window. The first window has value 31415. Dropping the high-order digit 3, shifting left (multiplying by 10), and then adding in the low-order digit 2 gives the new value 14152. Because all computations are performed modulo 13, the value for the first window is 7, and the value for the new window is 8.</p>
</div>
<a id="p965"/>
<p class="noindent">where <em>h</em> = <em>d</em><sup><em>m</em>−1</sup> mod <em>q</em> is the value of the digit “1” in the high-order position of an <em>m</em>-digit text window.</p>
<p>The solution of working modulo <em>q</em> is not perfect, however: <em>t</em><sub><em>s</em></sub> = <em>p</em> (mod <em>q</em>) does not automatically mean that <em>t</em><sub><em>s</em></sub> = <em>p</em>. On the other hand, if <em>t</em><sub><em>s</em></sub> ≠ <em>p</em> (mod <em>q</em>), then you definitely know that <em>t</em><sub><em>s</em></sub> ≠ <em>p</em>, so that shift <em>s</em> is invalid. Thus you can use the test <em>t</em><sub><em>s</em></sub> = <em>p</em> (mod <em>q</em>) as a fast heuristic test to rule out invalid shifts. If <em>t</em><sub><em>s</em></sub> = <em>p</em> (mod <em>q</em>)—a <span class="blue"><strong><em>hit</em></strong></span>—then you need to test further to see whether <em>s</em> is really valid or you just have a <span class="blue"><strong><em>spurious hit</em></strong></span>. This additional test explicitly checks the condition <em>P</em>[1:<em>m</em>] = <em>T</em>[<em>s</em> + 1:<em>s</em> + <em>m</em>]. If <em>q</em> is large enough, then you would hope that spurious hits occur infrequently enough that the cost of the extra checking is low.</p>
<p>The procedure R<small>ABIN</small>-K<small>ARP</small>-M<small>ATCHER</small> on the next page makes these ideas precise. The inputs to the procedure are the text <em>T</em>, the pattern <em>P</em>, their lengths <em>n</em> and <em>m</em>, the radix <em>d</em> to use (which is typically taken to be |∑|), and the prime <em>q</em> to use. The procedure works as follows. All characters are interpreted as radix-<em>d</em> digits. The subscripts on <em>t</em> are provided only for clarity: the procedure works correctly if all the subscripts are dropped. Line 1 initializes <em>h</em> to the value of the high-order digit position of an <em>m</em>-digit window. Lines 2–6 compute <em>p</em> as the value of <em>P</em>[1:<em>m</em>] mod <em>q</em> and <em>t</em><sub>0</sub> as the value of <em>T</em>[1:<em>m</em>] mod <em>q</em>. The <strong>for</strong> loop of lines 7–12 iterates through all possible shifts <em>s</em>, maintaining the following invariant:</p>
<p class="eqi">Whenever line 8 is executed, <em>t</em><sub><em>s</em></sub> = <em>T</em>[<em>s</em> + 1:<em>s</em> + <em>m</em>] mod <em>q</em>.</p>
<p class="noindent">If a hit occurs because <em>p</em> = <em>t</em><sub><em>s</em></sub> in line 8, then line 9 determines whether <em>s</em> is a valid shift or the hit was spurious via the test <em>P</em>[1:<em>m</em>] == <em>T</em>[<em>s</em> +1:<em>s</em> +<em>m</em>]. Line 10 prints out any valid shifts that are found. If <em>s</em> &lt; <em>n</em> – <em>m</em> (checked in line 11), then the <strong>for</strong> loop will iterate at least one more time, and so line 12 first executes to ensure that the loop invariant holds upon the next iteration. Line 12 computes the value of <em>t</em><sub><em>s</em>+1</sub> mod <em>q</em> from the value of <em>t</em><sub><em>s</em></sub> mod <em>q</em> in constant time using equation (32.2) directly.</p>
<p>R<small>ABIN</small>-K<small>ARP</small>-M<small>ATCHER</small> takes Θ(<em>m</em>) preprocessing time, and its matching time is Θ((<em>n</em> − <em>m</em> + 1)<em>m</em>) in the worst case, since (like the naive string-matching algorithm) the Rabin-Karp algorithm explicitly verifies every valid shift. If <em>P</em> = <span class="courierfont">a</span><sup><em>m</em></sup> and <em>T</em> = <span class="courierfont">a</span><sup><em>n</em></sup>, then verifying takes Θ((<em>n</em>−<em>m</em>+1)<em>m</em>) time, since each of the <em>n</em>−<em>m</em>+1 possible shifts is valid.</p>
<p>In many applications, you expect few valid shifts—perhaps some constant <em>c</em> of them. In such applications, the expected matching time of the algorithm is only <em>O</em>((<em>n</em>−<em>m</em>+1)+<em>cm</em>) = <em>O</em>(<em>n</em>+<em>m</em>), plus the time required to process spurious hits. We can base a heuristic analysis on the assumption that reducing values modulo <em>q</em> acts like a random mapping from ∑* to <span class="font1">ℤ</span><sub><em>q</em></sub>. The expected number of spurious hits is then <em>O</em>(<em>n</em>/<em>q</em>), because we can estimate the chance that an arbitrary <em>t</em><sub><em>s</em></sub> will be equivalent to <em>p</em>, modulo <em>q</em>, as 1/<em>q</em>. Since there are <em>O</em>(<em>n</em>) positions at which the <a id="p966"/>test of line 8 fails (actually, at most <em>n</em> − <em>m</em> + 1 positions) and checking each hit takes <em>O</em>(<em>m</em>) time in line 9, the expected matching time taken by the Rabin-Karp algorithm is</p>
<div class="pull-quote1">
<p class="box-heading">R<small>ABIN</small>-K<small>ARP</small>-M<small>ATCHER</small>(<em>T</em>, <em>P</em>, <em>n</em>, <em>m</em>, <em>d</em>, <em>q</em>)</p>
<table class="table1">
<tr>
<td class="td1w1a"><span class="x-small">  1</span></td>
<td class="td1" colspan="2"><em>h</em> = <em>d</em><sup><em>m</em>−1</sup> mod <em>q</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1" colspan="2"><em>p</em> = 0</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1" colspan="2"><em>t</em><sub>0</sub> = 0</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> <em>m</em></td>
<td class="td1"><span class="red"><strong>//</strong> preprocessing</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1" colspan="2"><p class="p2"><em>p</em> = (<em>dp</em> + <em>P</em>[<em>i</em>]) mod <em>q</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1" colspan="2"><p class="p2"><em>t</em><sub>0</sub> = (<em>dt</em><sub>0</sub> + <em>T</em>[<em>i</em>]) mod <em>q</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><strong>for</strong> <em>s</em> = 0 <strong>to</strong> <em>n</em> – <em>m</em></td>
<td class="td1"><span class="red"><strong>//</strong> matching—try all possible shifts</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>p</em> == <em>t</em><sub><em>s</em></sub></p></td>
<td class="td1"><span class="red"><strong>//</strong> a hit?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>P</em>[1:<em>m</em>] == <em>T</em>[<em>s</em> + 1:<em>s</em> + <em>m</em>]</p></td>
<td class="td1"><span class="red"><strong>//</strong> valid shift?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1" colspan="2"><p class="p4">print “Pattern occurs with shift” <em>s</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>if</strong> <em>s</em> &lt; <em>n</em> – <em>m</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1" colspan="2"><p class="p3"><img alt="art" src="images/Art_P1298.jpg"/></p></td>
</tr>
</table>
</div>
<p class="eql"><em>O</em>(<em>n</em>) + <em>O</em>(<em>m</em>(<em>v</em> + <em>n</em>/<em>q</em>)),</p>
<p class="noindent">where <em>v</em> is the number of valid shifts. This running time is <em>O</em>(<em>n</em>) if <em>v</em> = <em>O</em>(1) and you choose <em>q</em> ≥ <em>m</em>. That is, if the expected number of valid shifts is small (<em>O</em>(1)) and you choose the prime <em>q</em> to be larger than the length of the pattern, then you can expect the Rabin-Karp procedure to use only <em>O</em>(<em>n</em> + <em>m</em>) matching time. Since <em>m</em> ≤ <em>n</em>, this expected matching time is <em>O</em>(<em>n</em>).</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>32.2-1</em></strong></p>
<p class="noindent">Working modulo <em>q</em> = 11, how many spurious hits does the Rabin-Karp matcher encounter in the text <em>T</em> = 3141592653589793 when looking for the pattern <em>P</em> = 26?</p>
<p class="level3"><strong><em>32.2-2</em></strong></p>
<p class="noindent">Describe how to extend the Rabin-Karp method to the problem of searching a text string for an occurrence of any one of a given set of <em>k</em> patterns. Start by assuming that all <em>k</em> patterns have the same length. Then generalize your solution to allow the patterns to have different lengths.</p>
<p class="level3"><strong><em>32.2-3</em></strong></p>
<p class="noindent">Show how to extend the Rabin-Karp method to handle the problem of looking for a given <em>m</em> × <em>m</em> pattern in an <em>n</em> × <em>n</em> array of characters. (The pattern may be shifted vertically and horizontally, but it may not be rotated.)</p>
<a id="p967"/>
<p class="level3"><strong><em>32.2-4</em></strong></p>
<p class="noindent">Alice has a copy of a long <em>n</em>-bit file <em>A</em> = <span class="font1">〈</span><em>a</em><sub><em>n</em>–1</sub>, <em>a</em><sub><em>n</em>–2</sub>, …, <em>a</em><sub>0</sub><span class="font1">〉</span>, and Bob similarly has an <em>n</em>-bit file <em>B</em> = <span class="font1">〈</span><em>b</em><sub><em>n</em>–1</sub>, <em>b</em><sub><em>n</em>–2</sub>, …, <em>b</em><sub>0</sub><span class="font1">〉</span>. Alice and Bob wish to know if their files are identical. To avoid transmitting all of <em>A</em> or <em>B</em>, they use the following fast probabilistic check. Together, they select a prime <em>q</em> &gt; 1000<em>n</em> and randomly select an integer <em>x</em> from {0, 1, …, <em>q</em> – 1}. Letting</p>
<p class="eql"><img alt="art" src="images/Art_P1299.jpg"/></p>
<p class="noindent">Alice evaluates <em>A</em>(<em>x</em>) and Bob evaluates <em>B</em>(<em>x</em>). Prove that if <em>A</em> ≠ <em>B</em>, there is at most one chance in 1000 that <em>A</em>(<em>x</em>) = <em>B</em>(<em>x</em>), whereas if the two files are the same, <em>A</em>(<em>x</em>) is necessarily the same as <em>B</em>(<em>x</em>). (<em>Hint:</em> See Exercise 31.4-4.)</p>
</section>
<p class="line1"/>
<section title="32.3 String matching with finite automata">
<a id="Sec_32.3"/>
<p class="level1" id="h1-189"><a href="toc.xhtml#Rh1-189"><strong>32.3    String matching with finite automata</strong></a></p>
<p class="noindent">Many string-matching algorithms build a finite automaton—a simple machine for processing information—that scans the text string <em>T</em> for all occurrences of the pattern <em>P</em>. This section presents a method for building such an automaton. These string-matching automata are efficient: they examine each text character <em>exactly once</em>, taking constant time per text character. The matching time used—after preprocessing the pattern to build the automaton—is therefore Θ(<em>n</em>). The time to build the automaton, however, can be large if ∑ is large. <a href="chapter032.xhtml#Sec_32.4">Section 32.4</a> describes a clever way around this problem.</p>
<p>We begin this section with the definition of a finite automaton. We then examine a special string-matching automaton and show how to use it to find occurrences of a pattern in a text. Finally, we’ll see how to construct the string-matching automaton for a given input pattern.</p>
<p class="level4"><strong>Finite automata</strong></p>
<p class="noindent">A <span class="blue"><strong><em>finite automaton</em></strong></span> <em>M</em>, illustrated in <a href="chapter032.xhtml#Fig_32-5">Figure 32.5</a>, is a 5-tuple (<em>Q</em>, <em>q</em><sub>0</sub>, <em>A</em>, ∑, <em>δ</em>), where</p>
<ul class="ulnoindent" epub:type="list">
<li><em>Q</em> is a finite set of <span class="blue"><strong><em>states</em></strong></span>,</li>
<li class="litop"><em>q</em><sub>0</sub> ∈ <em>Q</em> is the <span class="blue"><strong><em>start state</em></strong></span>,</li>
<li class="litop"><em>A</em> ⊆ <em>Q</em> is a distinguished set of <span class="blue"><strong><em>accepting states</em></strong></span>,</li>
<li class="litop">∑ is a finite <span class="blue"><strong><em>input alphabet</em></strong></span>,</li>
<li class="litop"><em>δ</em> is a function from <em>Q</em> × ∑ into <em>Q</em>, called the <span class="blue"><strong><em>transition function</em></strong></span> of <em>M</em>.</li></ul>
<a id="p968"/>
<div class="divimage">
<p class="fig-img1" id="Fig_32-5"><img alt="art" src="images/Art_P1300.jpg"/></p>
<p class="caption"><strong>Figure 32.5</strong> A simple two-state finite automaton with state set <em>Q</em> = {0, 1}, start state <em>q</em><sub>0</sub> = 0, and input alphabet ∑ = {<span class="courierfont">a</span>, <span class="courierfont">b</span>}. <strong>(a)</strong> A tabular representation of the transition function <em>δ</em>. <strong>(b)</strong> An equivalent state-transition diagram. State 1, in orange, is the only accepting state. Directed edges represent transitions. For example, the edge from state 1 to state 0 labeled b indicates that <em>δ</em>(1, <span class="courierfont">b</span>) = 0. This automaton accepts those strings that end in an odd number of a’s. More precisely, it accepts a string <em>x</em> if and only if <em>x</em> = <em>yz</em>, where <em>y</em> = <em><span class="font1">ϵ</span></em> or <em>y</em> ends with a b, and <em>z</em> = <span class="courierfont">a</span><sup><em>k</em></sup>, where <em>k</em> is odd. For example, on input <span class="courierfont">abaaa</span>, including the start state, this automaton enters the sequence of states <span class="font1">〈</span>0, 1, 0, 1, 0, 1<span class="font1">〉</span>, and so it accepts this input. For input <span class="courierfont">abbaa</span>, it enters the sequence of states <span class="font1">〈</span>0, 1, 0, 0, 1, 0<span class="font1">〉</span>, and so it rejects this input.</p>
</div>
<p>The finite automaton begins in state <em>q</em><sub>0</sub> and reads the characters of its input string one at a time. If the automaton is in state <em>q</em> and reads input character <em>a</em>, it moves (“makes a transition”) from state <em>q</em> to state <em>δ</em>(<em>q</em>, <em>a</em>). Whenever its current state <em>q</em> is a member of <em>A</em>, the machine <em>M</em> has <span class="blue"><strong><em>accepted</em></strong></span> the string read so far. An input that is not accepted is <span class="blue"><strong><em>rejected</em></strong></span>.</p>
<p>A finite automaton <em>M</em> induces a function <em><span class="symbolfont">ϕ</span></em>, called the <span class="blue"><strong><em>final-state function</em></strong></span>, from ∑* to <em>Q</em> such that <em><span class="symbolfont">ϕ</span></em>(<em>w</em>) is the state <em>M</em> ends up in after reading the string <em>w</em>. Thus, <em>M</em> accepts a string <em>w</em> if and only if <em><span class="symbolfont">ϕ</span></em>(<em>w</em>) ∈ <em>A</em>. We define the function <em><span class="symbolfont">ϕ</span></em> recursively, using the transition function:</p>
<table class="table2b">
<tr>
<td class="td2"><p class="right"><em><span class="symbolfont">ϕ</span></em>(<em><span class="font1">ϵ</span></em>)</p></td>
<td class="td2">=</td>
<td class="td2"><em>q</em><sub>0</sub>,</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"><p class="right"><em><span class="symbolfont">ϕ</span></em>(<em>wa</em>)</p></td>
<td class="td2">=</td>
<td class="td2"><em>δ</em>(<em><span class="symbolfont">ϕ</span></em>(<em>w</em>), <em>a</em>)</td>
<td class="td2">for <em>w</em> ∈ ∑*, <em>a</em> ∈ ∑.</td>
</tr>
</table>
<p class="level4"><strong>String-matching automata</strong></p>
<p class="noindent">For a given pattern <em>P</em>, a preprocessing step constructs a string-matching automaton specific to <em>P</em>. The automaton then searches the text string for occurrences of <em>P</em>. <a href="chapter032.xhtml#Fig_32-6">Figure 32.6</a> illustrates the automaton for the pattern <em>P</em> = <span class="courierfont">ababaca</span>. From now on, let’s assume that <em>P</em> is fixed, and for brevity, we won’t bother to indicate the dependence upon <em>P</em> in our notation.</p>
<p>In order to specify the string-matching automaton corresponding to a given pattern <em>P</em>[1:<em>m</em>], we first define an auxiliary function <em>σ</em>, called the <span class="blue"><strong><em>suffix function</em></strong></span> corresponding to the pattern <em>P</em>. The function <em>σ</em> maps ∑* to {0, 1, …, <em>m</em>} such that <em>σ</em>(<em>x</em>) is the length of the longest prefix of <em>P</em> that is also a suffix of <em>x</em>:</p>
<p class="eqr"><img alt="art" src="images/Art_P1301.jpg"/></p>
<a id="p969"/>
<div class="divimage">
<p class="fig-img1" id="Fig_32-6"><img alt="art" src="images/Art_P1302.jpg"/></p>
<p class="caption"><strong>Figure 32.6 (a)</strong> A state-transition diagram for the string-matching automaton that accepts all strings ending in the string <span class="courierfont">ababaca</span>. State 0 is the start state, and state 7 (in orange) is the only accepting state. The transition function <em>δ</em> is defined by equation (32.4), and a directed edge from state <em>i</em> to state <em>j</em> labeled <em>a</em> represents <em>δ</em>(<em>i</em>, <em>a</em>) = <em>j</em>. The right-going edges forming the “spine” of the automaton, shown in blue, correspond to successful matches between pattern and input characters. Except for the edges from state 7 to states 1 and 2, the left-going edges correspond to mismatches. Some edges corresponding to mismatches are omitted: by convention, if a state <em>i</em> has no outgoing edge labeled <em>a</em> for some <em>a</em> ∈ ∑, then <em>δ</em>(<em>i</em>, <em>a</em>) = 0. <strong>(b)</strong> The corresponding transition function <em>δ</em>, and the pattern string <em>P</em> = <span class="courierfont">ababaca</span>. The entries corresponding to successful matches between pattern and input characters are shown in blue. <strong>(c)</strong> The operation of the automaton on the text <em>T</em> = <span class="courierfont">abababacaba</span>. Under each text character <em>T</em>[<em>i</em>] appears the state <em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]) that the automaton is in after processing the prefix <em>T</em>[:<em>i</em>]. The substring of the pattern that occurs in the text is highlighted in blue. The automaton finds this one occurrence of the pattern, ending in position 9.</p>
</div>
<p class="noindent">The suffix function <em>σ</em> is well defined since the empty string <em>P</em>[:0] = <em><span class="font1">ϵ</span></em> is a suffix of every string. As examples, for the pattern <em>P</em> = <span class="courierfont">ab</span>, we have <em>σ</em>(<em>ε</em>) = 0, <em>σ</em>(<span class="courierfont">ccaca</span>) = 1, and <em>σ</em>(<span class="courierfont">ccab</span>) = 2. For a pattern <em>P</em> of length <em>m</em>, we have <em>σ</em>(<em>x</em>) = <em>m</em> if and only if <em>P</em> <span class="font1">⊐</span> <em>x</em>. From the definition of the suffix function, <em>x</em> <span class="font1">⊐</span> <em>y</em> implies <em>σ</em>(<em>x</em>) ≤ <em>σ</em>(<em>y</em>) (see Exercise 32.3-4).</p>
<p>We are now ready to define the string-matching automaton that corresponds to a given pattern <em>P</em>[1:<em>m</em>]:</p>
<a id="p970"/>
<ul class="ulnoindent" epub:type="list">
<li>The state set <em>Q</em> is {0, 1, …, <em>m</em>}. The start state <em>q</em><sub>0</sub> is state 0, and state <em>m</em> is the only accepting state.</li>
<li class="litop">The transition function <em>δ</em> is defined, for any state <em>q</em> and character <em>a</em>, by</li></ul>
<p class="eqr"><img alt="art" src="images/Art_P1303.jpg"/></p>
<p>As the automaton consumes characters of the text <em>T</em>, it is trying to build a match of the pattern <em>P</em> against the most recently seen characters of <em>T</em>. At any time, the state number <em>q</em> gives the length of the longest prefix of <em>P</em> that matches the most recently seen text characters. Whenever the automaton reaches state <em>m</em>, the <em>m</em> most recently seen text characters match the first <em>m</em> characters of <em>P</em>. Since <em>P</em> has length <em>m</em>, reaching state <em>m</em> means that the <em>m</em> most recently seen text characters match the entire pattern, so that the automaton has found a match.</p>
<p>With this intuition behind the design of the automaton, here is the reasoning behind defining <em>δ</em>(<em>q</em>, <em>a</em>) = <em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>). Suppose that the automaton is in state <em>q</em> after reading the first <em>i</em> characters of the text, that is, <em>q</em> = <em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]). The intuitive idea then says that <em>q</em> also equals the length of the longest prefix of <em>P</em> that matches a suffix of <em>T</em>[:<em>i</em>] or, equivalently, that <em>q</em> = <em>σ</em>(<em>T</em>[:<em>i</em>]). Thus, since <em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]) and <em>σ</em>(<em>T</em>[:<em>i</em>]) both equal <em>q</em>, we will see (in Theorem 32.4 on page 973) that the automaton maintains the following invariant:</p>
<p class="eqr"><img alt="art" src="images/Art_P1304.jpg"/></p>
<p class="noindent">If the automaton is in state <em>q</em> and reads the next character <em>T</em>[<em>i</em> + 1] = <em>a</em>, then the transition should lead to the state corresponding to the longest prefix of <em>P</em> that is a suffix of <em>T</em>[:<em>i</em>]<em>a</em>. That state is <em>σ</em>(<em>T</em>[:<em>i</em>]<em>a</em>), and equation (32.5) gives <em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]<em>a</em>) = <em>σ</em>(<em>T</em>[:<em>i</em>]<em>a</em>). Because <em>P</em>[:<em>q</em>] is the longest prefix of <em>P</em> that is a suffix of <em>T</em>[:<em>i</em>], the longest prefix of <em>P</em> that is a suffix of <em>T</em>[:<em>i</em>]<em>a</em> has length not only <em>σ</em>(<em>T</em>[:<em>i</em>]<em>a</em>), but also <em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>), and so <em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]<em>a</em>) = <em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>). (Lemma 32.3 on page 972 will prove that <em>σ</em>(<em>T</em>[:<em>i</em>]<em>a</em>) = <em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>).) Thus, when the automaton is in state <em>q</em>, the transition function <em>δ</em> on character <em>a</em> should take the automaton to state <em>δ</em>(<em>q</em>, <em>a</em>) = <em>δ</em>(<em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]), <em>a</em>) = <em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]<em>a</em>) = <em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>) (with the last equality following from equation (32.5)).</p>
<p>There are two cases to consider, depending on whether the next character continues to match the pattern. In the first case, <em>a</em> = <em>P</em>[<em>q</em> + 1], so that the character <em>a</em> continues to match the pattern. In this case, because <em>δ</em>(<em>q</em>, <em>a</em>) = <em>q</em> + 1, the transition continues to go along the “spine” of the automaton (the blue edges in <a href="chapter032.xhtml#Fig_32-6">Figure 32.6(a)</a>). In the second case, <em>a</em> ≠ <em>P</em>[<em>q</em> + 1], so that <em>a</em> does not extend the match being built. In this case, we need to find the longest prefix of <em>P</em> that is also a suffix of <em>T</em>[:<em>i</em>]<em>a</em>, which will have length at most <em>q</em>. The preprocessing step matches the pattern against itself when creating the string-matching automaton, so that the transition function can quickly identify the longest such smaller prefix of <em>P</em>.</p>
<a id="p971"/>
<p>Let’s look at an example. Consider state 5 in the string-matching automaton of <a href="chapter032.xhtml#Fig_32-6">Figure 32.6</a>. In state 5, the five most recently read characters of <em>T</em> are <span class="courierfont">ababa</span>, the characters along the spine of the automaton that reach state 5. If the next character of <em>T</em> is <span class="courierfont">c</span>, then the most recently read characters of <em>T</em> are <span class="courierfont">ababac</span>, which is the prefix of <em>P</em> with length 6. The automaton should continue along the spine to state 6. This is the first case, in which the match continues, and <em>δ</em>(5, <span class="courierfont">c</span>) = 6. To illustrate the second case, suppose that in state 5, the next character of <em>T</em> is <span class="courierfont">b</span>, so the most recently read characters of <em>T</em> are <span class="courierfont">ababab</span>. Here, the longest prefix of <em>P</em> that matches the most recently read characters of <em>T</em>—that is, a suffix of the portion of <em>T</em> read so far—is <span class="courierfont">abab</span>, with length 4, so <em>δ</em>(5, <span class="courierfont">b</span>) = 4.</p>
<p>To clarify the operation of a string-matching automaton, the simple and efficient procedure F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small> simulates the behavior of such an automaton (represented by its transition function <em>δ</em>) in finding occurrences of a pattern <em>P</em> of length <em>m</em> in an input text <em>T</em>[1:<em>n</em>]. As for any string-matching automaton for a pattern of length <em>m</em>, the state set <em>Q</em> is {0, 1, …, <em>m</em>}, the start state is 0, and the only accepting state is state <em>m</em>. From the simple loop structure of F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>, you can see that its matching time on a text string of length <em>n</em> is Θ(<em>n</em>), assuming that each lookup of the transition function <em>δ</em> takes constant time. This matching time, however, does not include the preprocessing time required to compute the transition function. We address this problem later, after first proving that the procedure F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small> operates correctly.</p>
<div class="pull-quote1">
<p class="box-heading">F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>(<em>T</em>, <em>δ</em>, <em>n</em>, <em>m</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><em>q</em> = 0</td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> <em>n</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p2"><em>q</em> = <em>δ</em>(<em>q</em>, <em>T</em>[<em>i</em>])</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>q</em> == <em>m</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p3">print “Pattern occurs with shift” <em>i</em> – <em>m</em></p></td>
</tr>
</table>
</div>
<p>Let’s examine how the automaton operates on an input text <em>T</em>[1:<em>n</em>]. We will prove that the automaton is in state <em>σ</em>(<em>T</em>[:<em>i</em>]) after reading character <em>T</em>[<em>i</em>]. Since <em>σ</em>(<em>T</em>[:<em>i</em>]) = <em>m</em> if and only if <em>P</em> <span class="font1">⊐</span> <em>T</em>[:<em>i</em>], the machine is in the accepting state <em>m</em> if and only if it has just read the pattern <em>P</em>. We start with two lemmas about the suffix function <em>σ</em>.</p>
<p class="lem"><strong><em>Lemma 32.2 (Suffix-function inequality)</em></strong></p>
<p class="noindent">For any string <em>x</em> and character <em>a</em>, we have <em>σ</em>(<em>xa</em>) ≤ <em>σ</em>(<em>x</em>) + 1.</p>
<a id="p972"/>
<div class="divimage">
<p class="fig-img1" id="Fig_32-7"><img alt="art" src="images/Art_P1305.jpg"/></p>
<p class="caption"><strong>Figure 32.7</strong> An illustration for the proof of Lemma 32.2. The figure shows that <em>r</em> ≤ <em>σ</em>(<em>x</em>) + 1, where <em>r</em> = <em>σ</em>(<em>xa</em>).</p>
</div>
<p class="block"/>
<div class="divimage">
<p class="fig-img1" id="Fig_32-8"><img alt="art" src="images/Art_P1306.jpg"/></p>
<p class="caption"><strong>Figure 32.8</strong> An illustration for the proof of Lemma 32.3. The figure shows that <em>r</em> = <em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>), where <em>q</em> = <em>σ</em>(<em>x</em>) and <em>r</em> = <em>σ</em>(<em>xa</em>).</p>
</div>
<p class="proof"><strong><em>Proof</em></strong>   Referring to <a href="chapter032.xhtml#Fig_32-7">Figure 32.7</a>, let <em>r</em> = <em>σ</em>(<em>xa</em>). If <em>r</em> = 0, then the conclusion <em>σ</em>(<em>xa</em>) = <em>r</em> ≤ <em>σ</em>(<em>x</em>)+1 is trivially satisfied since <em>σ</em>(<em>x</em>) is nonnegative. Now assume that <em>r</em> &gt; 0. Then, <em>P</em>[:<em>r</em>] <span class="font1">⊐</span> <em>xa</em>, by the definition of <em>σ</em>. Thus, <em>P</em>[:<em>r</em> − 1] <span class="font1">⊐</span> <em>x</em>, by dropping the <em>a</em> from both the end of <em>P</em>[:<em>r</em>] and the end of <em>xa</em>. Therefore, <em>r</em> – 1 ≤ <em>σ</em>(<em>x</em>), since <em>σ</em>(<em>x</em>) is the largest <em>k</em> such that <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>x</em>, and thus <em>σ</em>(<em>xa</em>) = <em>r</em> ≤ <em>σ</em>(<em>x</em>) + 1.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="lem"><strong><em>Lemma 32.3 (Suffix-function recursion lemma)</em></strong></p>
<p class="noindent">For any string <em>x</em> and character <em>a</em>, if <em>q</em> = <em>σ</em>(<em>x</em>), then <em>σ</em>(<em>xa</em>) = <em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>).</p>
<p class="proof"><strong><em>Proof</em></strong>   The definition of <em>σ</em> gives that <em>P</em>[:<em>q</em>] <span class="font1">⊐</span> <em>x</em>. As <a href="chapter032.xhtml#Fig_32-8">Figure 32.8</a> shows, we also have <em>P</em>[:<em>q</em>]<em>a</em> <span class="font1">⊐</span> <em>xa</em>. Let <em>r</em> = <em>σ</em>(<em>xa</em>). Then <em>P</em>[:<em>r</em>] <span class="font1">⊐</span> <em>xa</em> and, by Lemma 32.2, <em>r</em> ≤ <em>q</em> + 1. Thus, we have |<em>P</em>[:<em>r</em>]| = <em>r</em> ≤ <em>q</em> + 1 = |<em>P</em>[:<em>q</em>]<em>a</em>|. Since <em>P</em>[:<em>q</em>]<em>a</em> <span class="font1">⊐</span> <em>xa</em>, <em>P</em>[:<em>r</em>] <span class="font1">⊐</span> <em>xa</em>, and |<em>P</em>[:<em>r</em>]| ≤ |<em>P</em>[:<em>q</em>]<em>a</em>|, Lemma 32.1 on page 959 implies that <em>P</em>[:<em>r</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]<em>a</em>. Therefore, <em>r</em> ≤ (<em>P</em>[:<em>q</em>]<em>a</em>), that is, <em>σ</em>(<em>xa</em>) ≤ <em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>). But we also have <em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>) ≤ <em>σ</em>(<em>xa</em>), since <em>P</em>[:<em>q</em>]<em>a</em> <span class="font1">⊐</span> <em>xa</em>. Thus, <em>σ</em>(<em>xa</em>) = <em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<a id="p973"/>
<p>We are now ready to prove the main theorem characterizing the behavior of a string-matching automaton on a given input text. As noted above, this theorem shows that the automaton is merely keeping track, at each step, of the longest prefix of the pattern that is a suffix of what has been read so far. In other words, the automaton maintains the invariant (32.5).</p>
<p class="theo"><strong><em>Theorem 32.4</em></strong></p>
<p class="noindent">If <em><span class="symbolfont">ϕ</span></em> is the final-state function of a string-matching automaton for a given pattern <em>P</em> and <em>T</em>[1:<em>n</em>] is an input text for the automaton, then</p>
<p class="eql"><em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]) = <em>σ</em>(<em>T</em>[:<em>i</em>])</p>
<p class="noindent">for <em>i</em> = 0, 1, …, <em>n</em>.</p>
<p class="proof"><strong><em>Proof</em></strong>   The proof is by induction on <em>i</em>. For <em>i</em> = 0, the theorem is trivially true, since <em>T</em>[:0] = <em>ε</em>. Thus, <em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:0]) = 0 = <em>σ</em>(<em>T</em>[:0]).</p>
<p>Now assume that <em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]) = <em>σ</em>(<em>T</em>[:<em>i</em>]). We will prove that <em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em> + 1]) = <em>σ</em>(<em>T</em>[:<em>i</em> + 1]). Let <em>q</em> denote <em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]), so that <em>q</em> = <em>σ</em>(<em>T</em>[:<em>i</em>]), and let <em>a</em> denote <em>T</em>[<em>i</em> + 1]. Then,</p>
<table class="table2b">
<tr>
<td class="td2"><em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em> + 1])</td>
<td class="td2">=</td>
<td class="td2"><em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]<em>a</em>)</td>
<td class="td2">(by the definitions of <em>T</em>[:<em>i</em> + 1] and <em>a</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>δ</em>(<em><span class="symbolfont">ϕ</span></em>(<em>T</em>[:<em>i</em>]), <em>a</em>)</td>
<td class="td2">(by the definition of <em><span class="symbolfont">ϕ</span></em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>δ</em>(<em>q</em>, <em>a</em>)</td>
<td class="td2">(by the definition of <em>q</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>σ</em>(<em>P</em>[:<em>q</em>]<em>a</em>)</td>
<td class="td2">(by the definition (32.4) of <em>δ</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>σ</em>(<em>T</em>[:<em>i</em>]<em>a</em>)</td>
<td class="td2">(by Lemma 32.3)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">(<em>T</em>[:<em>i</em> + 1])</td>
<td class="td2">(by the definition of <em>T</em>[:<em>i</em> + 1]).</td>
</tr>
</table>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">By Theorem 32.4, if the machine enters state <em>q</em> on line 3, then <em>q</em> is the largest value such that <em>P</em>[:<em>q</em>] <span class="font1">⊐</span> <em>T</em>[:<em>i</em>]. Thus, in line 4, <em>q</em> = <em>m</em> if and only if the machine has just read an occurrence of the pattern <em>P</em>. Therefore, F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small> operates correctly.</p>
<p class="level4"><strong>Computing the transition function</strong></p>
<p class="noindent">The procedure C<small>OMPUTE</small>-T<small>RANSITION</small>-F<small>UNCTION</small> on the following page computes the transition function <em>δ</em> from a given pattern <em>P</em>[1:<em>m</em>]. It computes <em>δ</em>(<em>q</em>, <em>a</em>) in a straightforward manner according to its definition in equation (32.4). The nested loops beginning on lines 1 and 2 consider all states <em>q</em> and all characters <em>a</em>, and lines 3–6 set <em>δ</em>(<em>q</em>, <em>a</em>) to be the largest <em>k</em> such that <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]<em>a</em>. The code starts with the largest conceivable value of <em>k</em>, which is <em>q</em>+1, unless <em>q</em> = <em>m</em>, in which case <em>k</em> cannot be larger than <em>m</em>. It then decreases <em>k</em> until <em>P</em>[:<em>k</em>] is a suffix of <em>P</em>[:<em>q</em>]<em>a</em>, which must eventually occur, since <em>P</em>[:0] = <em>ε</em> is a suffix of every string.</p>
<a id="p974"/>
<div class="pull-quote1">
<p class="box-heading">C<small>OMPUTE</small>-T<small>RANSITION</small>-F<small>UNCTION</small>(<em>P</em>, ∑, <em>m</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>for</strong> <em>q</em> = 0 <strong>to</strong> <em>m</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><strong>for</strong> each character <em>a</em> ∈ ∑</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p3"><em>k</em> = min {<em>m</em>, <em>q</em> + 1}</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p3"><strong>while</strong> <em>P</em>[:<em>k</em>] is not a suffix of <em>P</em>[:<em>q</em>]<em>a</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p4"><em>k</em> = <em>k</em> – 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><p class="p3"><em>δ</em>(<em>q</em>, <em>a</em>) = <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">7</span></td>
<td class="td1"><strong>return</strong> <em>δ</em></td>
</tr>
</table>
</div>
<p>The running time of C<small>OMPUTE</small>-T<small>RANSITION</small>-F<small>UNCTION</small> is <em>O</em>(<em>m</em><sup>3</sup> |∑|), because the outer loops contribute a factor of <em>m</em> |∑|, the inner <strong>while</strong> loop can run at most <em>m</em> + 1 times, and the test for whether <em>P</em>[:<em>k</em>] is a suffix of <em>P</em>[:<em>q</em>]<em>a</em> on line 4 can require comparing up to <em>m</em> characters. Much faster procedures exist. By utilizing some cleverly computed information about the pattern <em>P</em> (see Exercise 32.4-8), the time required to compute <em>δ</em> from <em>P</em> improves to <em>O</em>(<em>m</em> |∑|). This improved procedure for computing <em>δ</em> provides a way to find all occurrences of a length-<em>m</em> pattern in a length-<em>n</em> text over an alphabet ∑ with <em>O</em>(<em>m</em> |∑|) preprocessing time and Θ(<em>n</em>) matching time.</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>32.3-1</em></strong></p>
<p class="noindent">Draw a state-transition diagram for the string-matching automaton for the pattern <em>P</em> = <span class="courierfont">aabab</span> over the alphabet ∑ = {<span class="courierfont">a</span>, <span class="courierfont">b</span>} and illustrate its operation on the text string <em>T</em> = <span class="courierfont">aaababaabaababaab</span>.</p>
<p class="level3"><strong><em>32.3-2</em></strong></p>
<p class="noindent">Draw a state-transition diagram for the string-matching automaton for the pattern <em>P</em> = <span class="courierfont">ababbabbababbababbabb</span> over the alphabet ∑ = {<span class="courierfont">a</span>, <span class="courierfont">b</span>}.</p>
<p class="level3"><strong><em>32.3-3</em></strong></p>
<p class="noindent">A pattern <em>P</em> is <span class="blue"><strong><em>nonoverlappable</em></strong></span> if <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>] implies <em>k</em> = 0 or <em>k</em> = <em>q</em>. Describe the state-transition diagram of the string-matching automaton for a nonoverlappable pattern.</p>
<p class="level3"><strong><em>32.3-4</em></strong></p>
<p class="noindent">Let <em>x</em> and <em>y</em> be prefixes of the pattern <em>P</em>. Prove that <em>x</em> <span class="font1">⊐</span> <em>y</em> implies <em>σ</em>(<em>x</em>) ≤ <em>σ</em>(<em>y</em>).</p>
<a id="p975"/>
<p class="level3"><span class="font1">★</span> <strong><em>32.3-5</em></strong></p>
<p class="noindent">Given two patterns <em>P</em> and <em>P</em>′, describe how to construct a finite automaton that determines all occurrences of <em>either</em> pattern. Try to minimize the number of states in your automaton.</p>
<p class="level3"><strong><em>32.3-6</em></strong></p>
<p class="noindent">Given a pattern <em>P</em> containing gap characters (see Exercise 32.1-4), show how to build a finite automaton that can find an occurrence of <em>P</em> in a text <em>T</em> in <em>O</em>(<em>n</em>) matching time, where <em>n</em> = |<em>T</em>|.</p>
</section>
<p class="line1"/>
<section title="⋆ 32.4 The Knuth-Morris-Pratt algorithm">
<a id="Sec_32.4"/>
<p class="level1" id="h1-190"><a href="toc.xhtml#Rh1-190"><span class="font1">★</span> <strong>32.4 The Knuth-Morris-Pratt algorithm</strong></a></p>
<p class="noindent">Knuth, Morris, and Pratt developed a linear-time string matching algorithm that avoids computing the transition function <em>δ</em> altogether. Instead, the KMP algorithm uses an auxiliary function <em>π</em>, which it precomputes from the pattern in Θ(<em>m</em>) time and stores in an array <em>π</em>[1:<em>m</em>]. The array <em>π</em> allows the algorithm to compute the transition function <em>δ</em> efficiently (in an amortized sense) “on the fly” as needed. Loosely speaking, for any state <em>q</em> = 0, 1, …, <em>m</em> and any character <em>a</em> ∈ ∑, the value <em>π</em>[<em>q</em>] contains the information needed to compute <em>δ</em>(<em>q</em>, <em>a</em>) but that does not depend on <em>a</em>. Since the array <em>π</em> has only <em>m</em> entries, whereas <em>δ</em> has Θ(<em>m</em> |∑|) entries, the KMP algorithm saves a factor of |∑| in the preprocessing time by computing <em>π</em> rather than <em>δ</em>. Like the procedure F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>, once preprocessing has completed, the KMP algorithm uses Θ(<em>n</em>) matching time.</p>
<p class="level4"><strong>The prefix function for a pattern</strong></p>
<p class="noindent">The prefix function <em>π</em> for a pattern encapsulates knowledge about how the pattern matches against shifts of itself. The KMP algorithm takes advantage of this information to avoid testing useless shifts in the naive pattern-matching algorithm and to avoid precomputing the full transition function <em>δ</em> for a string-matching automaton.</p>
<p>Consider the operation of the naive string matcher. <a href="chapter032.xhtml#Fig_32-9">Figure 32.9(a)</a> shows a particular shift <em>s</em> of a template containing the pattern <em>P</em> = <span class="courierfont">ababaca</span> against a text <em>T</em>. For this example, <em>q</em> = 5 of the characters have matched successfully, but the 6th pattern character fails to match the corresponding text character. The information that <em>q</em> characters have matched successfully determines the corresponding text characters. Because these <em>q</em> text characters match, certain shifts must be invalid. In the example of the figure, the shift <em>s</em> + 1 is necessarily invalid, since the first pattern character (<span class="courierfont">a</span>) would be aligned with a text character that does not match the first pattern character, but does match the second pattern character (<span class="courierfont">b</span>). The shift <a id="p976"/><em>s</em>′ = <em>s</em> + 2 shown in part (b) of the figure, however, aligns the first three pattern characters with three text characters that necessarily match.</p>
<p>More generally, suppose that you know that <em>P</em>[:<em>q</em>] <span class="font1">⊐</span> <em>T</em>[:<em>s</em> + <em>q</em>] or, equivalently, that <em>P</em>[1:<em>q</em>] = <em>T</em>[<em>s</em> + 1:<em>s</em> + <em>q</em>]. You want to shift <em>P</em> so that some shorter prefix <em>P</em>[:<em>k</em>] of <em>P</em> matches a suffix of <em>T</em>[:<em>s</em> +<em>q</em>], if possible. You might have more than one choice for how much to shift, however. In <a href="chapter032.xhtml#Fig_32-9">Figure 32.9(b)</a>, shifting <em>P</em> by 2 positions works, so that <em>P</em>[:3] <span class="font1">⊐</span> <em>T</em>[:<em>s</em> + <em>q</em>], but so does shifting <em>P</em> by 4 positions, so that <em>P</em>[:1] <span class="font1">⊐</span> <em>T</em>[:<em>s</em> +<em>q</em>] in <a href="chapter032.xhtml#Fig_32-9">Figure 32.9(c)</a>. If more than one shift amount works, you should choose the smallest shift amount so that you do not miss any potential matches. Put more precisely, you want to answer this question:</p>
<div class="pull-quote">
<p class="pq-noindent">Given that pattern characters <em>P</em>[1:<em>q</em>] match text characters <em>T</em>[<em>s</em> + 1:<em>s</em> + <em>q</em>] (that is, <em>P</em>[:<em>q</em>] <span class="font1">⊐</span> <em>T</em>[:<em>s</em> + <em>q</em>]), what is the least shift <em>s</em>′ &gt; <em>s</em> such that for some <em>k</em> &lt; <em>q</em>,</p>
<p class="eqr"><img alt="art" src="images/Art_P1307.jpg"/></p>
<p class="pq-noindent">(that is, <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>T</em>[:<em>s</em>′ + <em>k</em>]), where <em>s</em>′ + <em>k</em> = <em>s</em> + <em>q</em>?</p>
</div>
<p>Here’s another way to look at this question. If you know <em>P</em>[:<em>q</em>] <span class="font1">⊐</span> <em>T</em>[:<em>s</em> + <em>q</em>], then how do you find the longest proper prefix <em>P</em>[:<em>k</em>] of <em>P</em>[:<em>q</em>] that is also a suffix of <em>T</em>[:<em>s</em> + <em>q</em>]? These questions are equivalent because given <em>s</em> and <em>q</em>, requiring <em>s</em>′ + <em>k</em> = <em>s</em> + <em>q</em> means that finding the smallest shift <em>s</em>′ (2 in <a href="chapter032.xhtml#Fig_32-9">Figure 32.9(b)</a>) is tantamount to finding the longest prefix length <em>k</em> (3 in <a href="chapter032.xhtml#Fig_32-9">Figure 32.9(b)</a>). If you add the difference <em>q</em> – <em>k</em> in the lengths of these prefixes of <em>P</em> to the shift <em>s</em>, you get the new shift <em>s</em>′, so that <em>s</em>′ = <em>s</em> + (<em>q</em> – <em>k</em>). In the best case, <em>k</em> = 0, so that <em>s</em>′ = <em>s</em> + <em>q</em>, immediately ruling out shifts <em>s</em> + 1, <em>s</em> + 2, …, <em>s</em> + <em>q</em> − 1. In any case, at the new shift <em>s</em>′, it is redundant to compare the first <em>k</em> characters of <em>P</em> with the corresponding characters of <em>T</em>, since equation (32.6) guarantees that they match.</p>
<p>As <a href="chapter032.xhtml#Fig_32-9">Figure 32.9(d)</a> demonstrates, you can precompute the necessary information by comparing the pattern against itself. Since <em>T</em>[<em>s</em>′ + 1:<em>s</em>′ + <em>k</em>] is part of the matched portion of the text, it is a suffix of the string <em>P</em>[:<em>q</em>]. Therefore, think of equation (32.6) as asking for the greatest <em>k</em> &lt; <em>q</em> such that <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]. Then, the new shift <em>s</em>′ = <em>s</em> + (<em>q</em> – <em>k</em>) is the next potentially valid shift. It will be convenient to store, for each value of <em>q</em>, the number <em>k</em> of matching characters at the new shift <em>s</em>′, rather than storing, say, the amount <em>s</em>′ – <em>s</em> to shift by.</p>
<p>Let’s look at the precomputed information a little more formally. For a given pattern <em>P</em>[1:<em>m</em>], the <span class="blue"><strong><em>prefix function</em></strong></span> for <em>P</em> is the function <em>π</em> : {1, 2, …, <em>m</em>} → {0, 1, …, <em>m</em> –} such that</p>
<p class="eql"><em>π</em>[<em>q</em>] = max{<em>k</em> : <em>k</em> &lt; <em>q</em> and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]}.</p>
<p class="noindent">That is, <em>π</em>[<em>q</em>] is the length of the longest prefix of <em>P</em> that is a proper suffix of <em>P</em>[:<em>q</em>]. Here is the complete prefix function <em>π</em> for the pattern <span class="courierfont">ababaca</span>:</p>
<a id="p977"/>
<div class="divimage">
<p class="fig-img1" id="Fig_32-9"><img alt="art" class="width100" src="images/Art_P1308.jpg"/></p>
<p class="caption"><strong>Figure 32.9</strong> The prefix function <em>π</em>. <strong>(a)</strong> The pattern <em>P</em> = <span class="courierfont">ababaca</span> aligns with a text <em>T</em> so that the first <em>q</em> = 5 characters match. Matching characters, in blue, are connected by blue lines. <strong>(b)</strong> Knowing these particular 5 matched characters (<em>P</em>[:5]) suffices to deduce that a shift of <em>s</em> + 1 is invalid, but that a shift of <em>s</em>′ = <em>s</em> + 2 is consistent with everything known about the text and therefore is potentially valid. The prefix <em>P</em>[:<em>k</em>], where <em>k</em> = 3, aligns with the text seen so far. <strong>(c)</strong> A shift of <em>s</em> + 4 is also potentially valid, but it leaves only the prefix <em>P</em>[:1] aligned with the text seen so far. <strong>(d)</strong> To precompute useful information for such deductions, compare the pattern with itself. Here, the longest prefix of <em>P</em> that is also a proper suffix of <em>P</em>[:5] is <em>P</em>[:3]. The array <em>π</em> represents this precomputed information, so that <em>π</em>[5] = 3. Given that <em>q</em> characters have matched successfully at shift <em>s</em>, the next potentially valid shift is at <em>s</em>′ = <em>s</em> + (<em>q</em> – <em>π</em>[<em>q</em>]) as shown in part (b).</p>
</div>
<p class="eql"><img alt="art" src="images/Art_P1308a.jpg"/></p>
<p>The procedure KMP-M<small>ATCHER</small> on the following page gives the Knuth-Morris-Pratt matching algorithm. The procedure follows from F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small> for the most part. To compute <em>π</em>, KMP-M<small>ATCHER</small> calls the auxiliary procedure C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small>. These two procedures have much in common, because both match a string against the pattern <em>P</em>: KMP-M<small>ATCHER</small> matches the text <em>T</em> against <em>P</em>, and C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small> matches <em>P</em> against itself.</p>
<p>Next, let’s analyze the running times of these procedures. Then we’ll prove them correct, which will be more complicated.</p>
<p class="level4"><strong>Running-time analysis</strong></p>
<p class="noindent">The running time of C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small> is Θ(<em>m</em>), which we show by using the aggregate method of amortized analysis (see <a href="chapter016.xhtml#Sec_16.1">Section 16.1</a>). The only tricky part is showing that the <strong>while</strong> loop of lines 5–6 executes <em>O</em>(<em>m</em>) times altogether. <a id="p978"/>Starting with some observations about <em>k</em>, we’ll show that it makes at most <em>m</em>–1 iterations. First, line 3 starts <em>k</em> at 0, and the only way that <em>k</em> increases is by the increment operation in line 8, which executes at most once per iteration of the <strong>for</strong> loop of lines 4–9. Thus, the total increase in <em>k</em> is at most <em>m</em>–1. Second, since <em>k</em> &lt; <em>q</em> upon entering the <strong>for</strong> loop and each iteration of the loop increments <em>q</em>, we always have <em>k</em> &lt; <em>q</em>. Therefore, the assignments in lines 2 and 9 ensure that <em>π</em>[<em>q</em>] &lt; <em>q</em> for all <em>q</em> = 1, 2, …, <em>m</em>, which means that each iteration of the <strong>while</strong> loop decreases <em>k</em>. Third, <em>k</em> never becomes negative. Putting these facts together, we see that the total decrease in <em>k</em> from the <strong>while</strong> loop is bounded from above by the total increase in <em>k</em> over all iterations of the <strong>for</strong> loop, which is <em>m</em> – 1. Thus, the <strong>while</strong> loop iterates at most <em>m</em> – 1 times in all, and C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small> runs in Θ(<em>m</em>) time.</p>
<div class="pull-quote1">
<p class="box-heading">KMP-M<small>ATCHER</small>(<em>T</em>, <em>P</em>, <em>n</em>, <em>m</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1" colspan="2"><em>π</em> = C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small>(<em>P</em>, <em>m</em>)</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><em>q</em> = 0</td>
<td class="td1"><span class="red"><strong>//</strong> number of characters matched</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> <em>n</em></td>
<td class="td1"><span class="red"><strong>//</strong> scan the text from left to right</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>while</strong> <em>q</em> &gt; 0 and <em>P</em>[<em>q</em> + 1] ≠ <em>T</em>[<em>i</em>]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="p3"><em>q</em> = <em>π</em>[<em>q</em>]</p></td>
<td class="td1"><span class="red"><strong>//</strong> next character does not match</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>if</strong> <em>P</em>[<em>q</em> + 1] == <em>T</em>[<em>i</em>]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p3"><em>q</em> = <em>q</em> + 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> next character matches</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>q</em> == <em>m</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> is all of <em>P</em> matched?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1" colspan="2"><p class="p3">print “Pattern occurs with shift” <em>i</em> – <em>m</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="p3"><em>q</em> = <em>π</em>[<em>q</em>]</p></td>
<td class="td1"><span class="red"><strong>//</strong> look for the next match</span></td>
</tr>
<tr>
<td class="td1" colspan="3"><p class="box-headinga">C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small>(<em>P</em>, <em>m</em>)</p></td>
</tr>
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1" colspan="2">let <em>π</em>[1:<em>m</em>] be a new array</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1" colspan="2"><em>π</em>[1] = 0</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1" colspan="2"><em>k</em> = 0</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1" colspan="2"><strong>for</strong> <em>q</em> = 2 <strong>to</strong> <em>m</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>while</strong> <em>k</em> &gt; 0 and <em>P</em>[<em>k</em> + 1] ≠ <em>P</em>[<em>q</em>]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1" colspan="2"><p class="p3"><em>k</em> = <em>π</em>[<em>k</em>]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>if</strong> <em>P</em>[<em>k</em> + 1] == <em>P</em>[<em>q</em>]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1" colspan="2"><p class="p3"><em>k</em> = <em>k</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1" colspan="2"><p class="p2"><em>π</em>[<em>q</em>] = <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1" colspan="2"><strong>return</strong> <em>π</em></td>
</tr>
</table>
</div>
<p>Exercise 32.4-4 asks you to show, by a similar aggregate analysis, that the matching time of KMP-M<small>ATCHER</small> is Θ(<em>n</em>).</p>
<a id="p979"/>
<div class="divimage">
<p class="fig-img1" id="Fig_32-10"><img alt="art" class="width100" src="images/Art_P1309.jpg"/></p>
<p class="caption"><strong>Figure 32.10</strong> An illustration of Lemma 32.5 for the pattern <em>P</em> = <span class="courierfont">ababaca</span> and <em>q</em> = 5. <strong>(a)</strong> The <em>π</em> function for the given pattern. Since <em>π</em>[5] = 3, <em>π</em>[3] = 1, and <em>π</em>[1]= 0, iterating <em>π</em> gives <em>π</em>*[5] = {3, 1, 0}. <strong>(b)</strong> Sliding the template containing the pattern <em>P</em> to the right and noting when some prefix <em>P</em>[:<em>k</em>] of <em>P</em> matches up with some proper suffix of <em>P</em>[:5]. Matches occur when <em>k</em> = 3, 1, and 0. In the figure, the first row gives <em>P</em>, and the vertical red line is drawn just after <em>P</em>[:5]. Successive rows show all the shifts of <em>P</em> that cause some prefix <em>P</em>[:<em>k</em>] of <em>P</em> to match some suffix of <em>P</em>[:5]. Successfully matched characters are shown in blue. Blue lines connect aligned matching characters. Thus, {<em>k</em> : <em>k</em> &lt; 5 and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:5]} = {3, 1, 0}. Lemma 32.5 claims that <em>π</em>*[<em>q</em>] = {<em>k</em> : <em>k</em> &lt; <em>q</em> and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]} for all <em>q</em>.</p>
</div>
<p>Compared with F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>, by using <em>π</em> rather than <em>δ</em>, the KMP algorithm reduces the time for preprocessing the pattern from <em>O</em>(<em>m</em> |∑|) to Θ(<em>m</em>), while keeping the actual matching time bounded by Θ(<em>n</em>).</p>
<p class="level4"><strong>Correctness of the prefix-function computation</strong></p>
<p class="noindent">We’ll see a little later that the prefix function <em>π</em> helps to simulate the transition function <em>δ</em> in a string-matching automaton. But first, we need to prove that the procedure C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small> does indeed compute the prefix function correctly. Doing so requires finding all prefixes <em>P</em>[:<em>k</em>] that are proper suffixes of a given prefix <em>P</em>[:<em>q</em>]. The value of <em>π</em>[<em>q</em>] gives us the length of the longest such prefix, but the following lemma, illustrated in <a href="chapter032.xhtml#Fig_32-10">Figure 32.10</a>, shows that iterating the prefix function <em>π</em> generates all the prefixes <em>P</em>[:<em>k</em>] that are proper suffixes of <em>P</em>[:<em>q</em>]. Let</p>
<p class="eql"><em>π</em>*[<em>q</em>] = {<em>π</em>[<em>q</em>], <em>π</em><sup>(2)</sup>[<em>q</em>], <em>π</em><sup>(3)</sup>[<em>q</em>], …, <em>π</em><sup>(<em>t</em>)</sup>[<em>q</em>]},</p>
<p class="noindent">where <em>π</em><sup>(<em>i</em>)</sup>[<em>q</em>] is defined in terms of functional iteration, so that <em>π</em><sup>(0)</sup>[<em>q</em>] = <em>q</em> and <em>π</em><sup>(<em>i</em>)</sup>[<em>q</em>] = <em>π</em>[<em>π</em><sup>(<em>i</em>−1)</sup>[<em>q</em>]] for <em>i</em> ≥ 1 (so that <em>π</em>[<em>q</em>] = <em>π</em><sup>(1)</sup>[<em>q</em>]), and where the sequence in <em>π</em>*[<em>q</em>] stops upon reaching <em>π</em><sup>(<em>t</em>)</sup>[<em>q</em>] = 0 for some <em>t</em> ≥ 1.</p>
<a id="p980"/>
<p class="lem"><strong><em>Lemma 32.5 (Prefix-function iteration lemma)</em></strong></p>
<p class="noindent">Let <em>P</em> be a pattern of length <em>m</em> with prefix function <em>π</em>. Then, for <em>q</em> = 1, 2, …, <em>m</em>, we have <em>π</em>*[<em>q</em>] = {<em>k</em> : <em>k</em> &lt; <em>q</em> and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]}.</p>
<p class="proof"><strong><em>Proof</em></strong>   We first prove that <em>π</em>*[<em>q</em>] ⊆ {<em>k</em> : <em>k</em> &lt; <em>q</em> and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]} or, equivalently,</p>
<p class="eqr"><img alt="art" src="images/Art_P1310.jpg"/></p>
<p>If <em>i</em> ∈ <em>π</em>*[<em>q</em>], then <em>i</em> = <em>π</em><sup>(<em>u</em>)</sup>[<em>q</em>] for some <em>u</em> &gt; 0. We prove equation (32.7) by induction on <em>u</em>. For <em>u</em> = 1, we have <em>i</em> = <em>π</em>[<em>q</em>], and the claim follows since <em>i</em> &lt; <em>q</em> and <em>P</em>[:<em>π</em>[<em>q</em>]] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>] by the definition of <em>π</em>. Now consider some <em>u</em> ≥ 1 such that both <em>π</em><sup>(<em>u</em>)</sup>[<em>q</em>] and <em>π</em><sup>(<em>u</em>+1)</sup>[<em>q</em>] belong to <em>π</em>*[<em>q</em>]. Let <em>i</em> = <em>π</em><sup>(<em>u</em>)</sup>[<em>q</em>], so that <em>π</em>[<em>i</em>] = <em>π</em><sup>(<em>u</em>+1)</sup>[<em>q</em>]. The inductive hypothesis is that <em>P</em>[:<em>i</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]. Because the relations &lt; and <span class="font1">⊐</span> are transitive, we have <em>π</em>[<em>i</em>] &lt; <em>i</em> &lt; <em>q</em> and <em>P</em>[:<em>π</em>[<em>i</em>]] <span class="font1">⊐</span> <em>P</em>[:<em>i</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>], which establishes equation (32.7) for all <em>i</em> in <em>π</em>*[<em>q</em>]. Therefore, <em>π</em>*[<em>q</em>] ⊆ {<em>k</em> : <em>k</em> &lt; <em>q</em> and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]}.</p>
<p>We now prove that {<em>k</em> : <em>k</em> &lt; <em>q</em> and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]} ⊆ <em>π</em>*[<em>q</em>] by contradiction. Suppose to the contrary that the set {<em>k</em> : <em>k</em> &lt; <em>q</em> and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]} – <em>π</em>*[<em>q</em>] is nonempty, and let <em>j</em> be the largest number in the set. Because <em>π</em>[<em>q</em>] is the largest value in {<em>k</em> : <em>k</em> &lt; <em>q</em> and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]} and <em>π</em>*[<em>q</em>] ∈ <em>π</em>*[<em>q</em>], it must be the case that <em>j</em> &lt; [<em>q</em>]. Having established that <em>π</em>*[<em>q</em>] contains at least one integer greater than <em>j</em>, let <em>j</em>′ denote the smallest such integer. (We can choose <em>j</em>′ = <em>π</em>[<em>q</em>] if no other number in <em>π</em>*[<em>q</em>] is greater than <em>j</em>.) We have <em>P</em>[:<em>j</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>] because <em>j</em> ∈ {<em>k</em> : <em>k</em> &lt; <em>q</em> and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]}, and from <em>j</em>′ ∈ <em>π</em>*[<em>q</em>] and equation (32.7), we have <em>P</em>[:<em>j</em>′] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]. Thus, <em>P</em>[:<em>j</em>] <span class="font1">⊐</span> <em>P</em>[:<em>j</em>′] by Lemma 32.1, and <em>j</em> is the largest value less than <em>j</em>′ with this property. Therefore, we must have <em>π</em>[<em>j</em>′] = <em>j</em> and, since <em>j</em>′ ∈ <em>π</em>*[<em>q</em>], we must have <em>j</em> ∈ <em>π</em>*[<em>q</em>] as well. This contradiction proves the lemma.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The algorithm C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small> computes <em>π</em>[<em>q</em>], in order, for <em>q</em> = 1, 2, …, <em>m</em>. Setting <em>π</em>[1] to 0 in line 2 of C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small> is certainly correct, since <em>π</em>[<em>q</em>] &lt; <em>q</em> for all <em>q</em>. We’ll use the following lemma and its corollary to prove that C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small> computes <em>π</em>[<em>q</em>] correctly for <em>q</em> &gt; 1.</p>
<p class="lem"><strong><em>Lemma 32.6</em></strong></p>
<p class="noindent">Let <em>P</em> be a pattern of length <em>m</em>, and let <em>π</em> be the prefix function for <em>P</em>. For <em>q</em> = 1, 2, …, <em>m</em>, if <em>π</em>[<em>q</em>] &gt; 0, then <em>π</em>[<em>q</em>] – 1 ∈ <em>π</em>*[<em>q</em> – 1].</p>
<p class="proof"><strong><em>Proof</em></strong>   Let <em>r</em> = <em>π</em>[<em>q</em>] &gt; 0, so that <em>r</em> &lt; <em>q</em> and <em>P</em>[:<em>r</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>], and thus, <em>r</em> – 1 &lt; <em>q</em> – 1 and <em>P</em>[:<em>r</em> – 1] <span class="font1">⊐</span> <em>P</em>[:<em>q</em> – 1] (by dropping the last character from <a id="p981"/><em>P</em>[:<em>r</em>] and <em>P</em>[:<em>q</em>], which we can do because <em>r</em> &gt; 0). By Lemma 32.5, therefore, <em>r</em> – 1 ∈ <em>π</em>*[<em>q</em> – 1]. Thus, we have <em>π</em>[<em>q</em>] – 1 = <em>r</em> – 1 ∈ <em>π</em>*[<em>q</em> – 1].</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">For <em>q</em> = 2, 3, …, <em>m</em>, define the subset <em>E</em><sub><em>q</em>–1</sub> ⊆ <em>π</em>*[<em>q</em> – 1] by</p>
<table class="table2b">
<tr>
<td class="td2"><em>E</em><sub><em>q</em>–1</sub></td>
<td class="td2">=</td>
<td class="td2">{<em>k</em> ∈ <em>π</em>*[<em>q</em> – 1]: <em>P</em>[<em>k</em> + 1] = <em>P</em>[<em>q</em>]}</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><p class="noindent">{<em>k</em> : <em>k</em> &lt; <em>q</em> – 1 and <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em> – 1] and <em>P</em>[<em>k</em> + 1] = <em>P</em>[<em>q</em>]}</p>
<p class="indent3">(by Lemma 32.5)</p></td>
</tr>
<tr>
<td class="td1"/>
<td class="td1">=</td>
<td class="td1">{<em>k</em> : <em>k</em> &lt; <em>q</em> – 1 and <em>P</em>[:<em>k</em> + 1] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]}.</td>
</tr>
</table>
<p class="noindent">The set <em>E</em><sub><em>q</em>–1</sub> consists of the values <em>k</em> &lt; <em>q</em> – 1 for which <em>P</em>[:<em>k</em>] <span class="font1">⊐</span> <em>P</em>[:<em>q</em> – 1] and for which, because <em>P</em>[<em>k</em> + 1] = <em>P</em>[<em>q</em>], we have <em>P</em>[:<em>k</em> + 1] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]. Thus, <em>E</em><sub><em>q</em>–1</sub> consists of those values <em>k</em> ∈ <em>π</em>*[<em>q</em> – 1] such that extending <em>P</em>[:<em>k</em>] to <em>P</em>[:<em>k</em> + 1] produces a proper suffix of <em>P</em>[:<em>q</em>].</p>
<p class="cor"><strong><em>Corollary 32.7</em></strong></p>
<p class="noindent">Let <em>P</em> be a pattern of length <em>m</em>, and let <em>π</em> be the prefix function for <em>P</em>. Then, for <em>q</em> = 2, 3, …, <em>m</em>,</p>
<p class="eql"><img alt="art" src="images/Art_P1311.jpg"/></p>
<p class="proof"><strong><em>Proof</em></strong>   If <em>E</em><sub><em>q</em>–1</sub> is empty, there is no <em>k</em> ∈ <em>π</em>*[<em>q</em> – 1] (including <em>k</em> = 0) such that extending <em>P</em>[:<em>k</em>] to <em>P</em>[:<em>k</em> + 1] produces a proper suffix of <em>P</em>[:<em>q</em>]. Therefore, <em>π</em>[<em>q</em>]= 0.</p>
<p>If, instead, <em>E</em><sub><em>q</em>–1</sub> is nonempty, then for each <em>k</em> ∈ <em>E</em><sub><em>q</em>–1</sub>, we have <em>k</em> + 1 &lt; <em>q</em> and <em>P</em>[:<em>k</em> + 1] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]. Therefore, the definition of <em>π</em>[<em>q</em>] gives</p>
<p class="eqr"><img alt="art" src="images/Art_P1312.jpg"/></p>
<p class="noindent">Note that <em>π</em>[<em>q</em>] &gt; 0. Let <em>r</em> = <em>π</em>[<em>q</em>] – 1, so that <em>r</em> + 1 = <em>π</em>[<em>q</em>] &gt; 0, and therefore <em>P</em>[:<em>r</em> + 1] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>]. If a nonempty string is a suffix of another, then the two strings must have the same last character. Since <em>r</em> + 1 &gt; 0, the prefix <em>P</em>[:<em>r</em> + 1] is nonempty, and so <em>P</em>[<em>r</em> + 1] = <em>P</em>[<em>q</em>]. Furthermore, <em>r</em> ∈ <em>π</em>*[<em>q</em> – 1] by Lemma 32.6. Therefore, <em>r</em> ∈ <em>E</em><sub><em>q</em>–1</sub>, and so <em>π</em>[<em>q</em>] – 1 = <em>r</em> ≤ max <em>E</em><sub><em>q</em>–1</sub> or, equivalently,</p>
<p class="eqr"><img alt="art" src="images/Art_P1313.jpg"/></p>
<p class="noindent">Combining equations (32.8) and (32.9) completes the proof.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">We now finish the proof that C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small> computes <em>π</em> correctly. The key is to combine the definition of <em>E</em><sub><em>q</em>–1</sub> with the statement of Corollary 32.7, so that <em>π</em>[<em>q</em>] equals 1 plus the greatest value of <em>k</em> in <em>π</em>*[<em>q</em> – 1] such that <a id="p982"/><em>P</em>[<em>k</em> + 1] = <em>P</em>[<em>q</em>]. First, in C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small>, <em>k</em> = <em>π</em>[<em>q</em> – 1] at the start of each iteration of the <strong>for</strong> loop of lines 4–9. This condition is enforced by lines 2 and 3 when the loop is first entered, and it remains true in each successive iteration because of line 9. Lines 5–8 adjust <em>k</em> so that it becomes the correct value of <em>π</em>[<em>q</em>]. The <strong>while</strong> loop of lines 5–6 searches through all values <em>k</em> ∈ <em>π</em>*[<em>q</em> – 1] in decreasing order to find the value of <em>π</em>[<em>q</em>]. The loop terminates either because <em>k</em> reaches 0 or <em>P</em>[<em>k</em> + 1] = <em>P</em>[<em>q</em>]. Because the “and” operator short-circuits, if the loop terminates because <em>P</em>[<em>k</em> + 1] = <em>P</em>[<em>q</em>], then <em>k</em> must have also been positive, and so <em>k</em> is the greatest value in <em>E</em><sub><em>q</em>–1</sub>. In this case, lines 7–9 set <em>π</em>[<em>q</em>] to <em>k</em> + 1, according to Corollary 32.7. If, instead, the <strong>while</strong> loop terminates because <em>k</em> = 0, then there are two possibilities. If <em>P</em>[1] = <em>P</em>[<em>q</em>], then <em>E</em><sub><em>q</em>–1</sub> = {0}, and lines 7–9 set both <em>k</em> and <em>π</em>[<em>q</em>] to 1. If <em>k</em> = 0 and <em>P</em>[1] ≠ <em>P</em>[<em>q</em>], however, then <em>E</em><sub><em>q</em>–1</sub> = ø;. In this case, line 9 sets <em>π</em>[<em>q</em>] to 0, again according to Corollary 32.7, which completes the proof of the correctness of C<small>OMPUTE</small>-P<small>REFIX</small>-F<small>UNCTION</small>.</p>
<p class="level4"><strong>Correctness of the Knuth-Morris-Pratt algorithm</strong></p>
<p class="noindent">You can think of the procedure KMP-M<small>ATCHER</small> as a reimplemented version of the procedure F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>, but using the prefix function <em>π</em> to compute state transitions. Specifically, we’ll prove that in the <em>i</em>th iteration of the <strong>for</strong> loops of both KMP-M<small>ATCHER</small> and F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>, the state <em>q</em> has the same value upon testing for equality with <em>m</em> (at line 8 in KMP-M<small>ATCHER</small> and at line 4 in F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>). Once we have argued that KMP-M<small>ATCHER</small> simulates the behavior of F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>, the correctness of KMP-M<small>ATCHER</small> follows from the correctness of F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small> (though we’ll see a little later why line 10 in KMP-M<small>ATCHER</small> is necessary).</p>
<p>Before formally proving that KMP-M<small>ATCHER</small> correctly simulates F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>, let’s take a moment to understand how the prefix function <em>π</em> replaces the <em>δ</em> transition function. Recall that when a string-matching automaton is in state <em>q</em> and it scans a character <em>a</em> = <em>T</em>[<em>i</em>], it moves to a new state <em>δ</em>(<em>q</em>, <em>a</em>). If <em>a</em> = <em>P</em>[<em>q</em> + 1], so that <em>a</em> continues to match the pattern, then the state number is incremented: <em>δ</em>(<em>q</em>, <em>a</em>) = <em>q</em> + 1. Otherwise, <em>a</em> ≠ <em>P</em>[<em>q</em> + 1], so that <em>a</em> does not continue to match the pattern, and the state number does not increase: 0 ≤ <em>δ</em>(<em>q</em>, <em>a</em>) ≤ <em>q</em>. In the first case, when <em>a</em> continues to match, KMP-M<small>ATCHER</small> moves to state <em>q</em> + 1 without referring to the <em>π</em> function: the <strong>while</strong> loop test in line 4 immediately comes up false, the test in line 6 comes up true, and line 7 increments <em>q</em>.</p>
<p>The <em>π</em> function comes into play when the character <em>a</em> does not continue to match the pattern, so that the new state <em>δ</em>(<em>q</em>, <em>a</em>) is either <em>q</em> or to the left of <em>q</em> along the spine of the automaton. The <strong>while</strong> loop of lines 4–5 in KMP-M<small>ATCHER</small> iterates through <a id="p983"/>the states in <em>π</em>*[<em>q</em>], stopping either when it arrives in a state, say <em>q</em>′, such that <em>a</em> matches <em>P</em>[<em>q</em>′ + 1] or <em>q</em>′ has gone all the way down to 0. If <em>a</em> matches <em>P</em>[<em>q</em>′ + 1], then line 7 sets the new state to <em>q</em>′+1, which should equal <em>δ</em>(<em>q</em>, <em>a</em>) for the simulation to work correctly. In other words, the new state <em>δ</em>(<em>q</em>, <em>a</em>) should be either state 0 or a state numbered 1 more than some state in <em>π</em>*[<em>q</em>].</p>
<p>Let’s look at the example in <a href="#Fig_32-6">Figures 32.6</a> and <a href="#Fig_32-10">32.10</a>, which are for the pattern <em>P</em> = <span class="courierfont">ababaca</span>. Suppose that the automaton is in state <em>q</em> = 5, having matched <span class="courierfont">ababa</span>. The states in <em>π</em>*[5] are, in descending order, 3, 1, and 0. If the next character scanned is <span class="courierfont">c</span>, then you can see that the automaton moves to state <em>δ</em>(5, <span class="courierfont">c</span>) = 6 in both F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small> (line 3) and KMP-M<small>ATCHER</small> (line 7). Now suppose that the next character scanned is instead <span class="courierfont">b</span>, so that the automaton should move to state <em>δ</em>(5, <span class="courierfont">b</span>) = 4. The <strong>while</strong> loop in KMP-M<small>ATCHER</small> exits after executing line 5 once, and the automaton arrives in state <em>q</em>′ = <em>π</em>[5] = 3. Since <em>P</em>[<em>q</em>′ + 1] = <em>P</em>[4] = <span class="courierfont">b</span>, the test in line 6 comes up true, and the automaton moves to the new state <em>q</em>′ + 1 = 4 = <em>δ</em>(5, <span class="courierfont">b</span>). Finally, suppose that the next character scanned is instead <span class="courierfont">a</span>, so that the automaton should move to state <em>δ</em>(5, <span class="courierfont">a</span>) = 1. The first three times that the test in line 4 executes, the test comes up true. The first time finds that <em>P</em>[6] = <span class="courierfont">c</span> ≠ <span class="courierfont">a</span>, and the automaton moves to state <em>π</em>[5] = 3 (the first state in <em>π</em>*[5]). The second time finds that <em>P</em>[4] = <span class="courierfont">b</span> ≠ <span class="courierfont">a</span>, and the automaton moves to state <em>π</em>[3] = 1 (the second state in <em>π</em>*[5]). The third time finds that <em>P</em>[2] = <span class="courierfont">b</span> ≠ <span class="courierfont">a</span>, and the automaton moves to state <em>π</em>[1] = 0 (the last state in <em>π</em>*[5]). The <strong>while</strong> loop exits once it arrives in state <em>q</em>′ = 0. Now line 6 finds that <em>P</em>[<em>q</em>′ + 1] = <em>P</em>[1] = <span class="courierfont">a</span>, and line 7 moves the automaton to the new state <em>q</em>′ + 1 = 1 = <em>δ</em>(5, <span class="courierfont">a</span>).</p>
<p>Thus, the intuition is that KMP-M<small>ATCHER</small> iterates through the states in <em>π</em>*[<em>q</em>] in decreasing order, stopping at some state <em>q</em>′ and then possibly moving to state <em>q</em>′+1. Although that might seem like a lot of work just to simulate computing <em>δ</em>(<em>q</em>, <em>a</em>), bear in mind that asymptotically, KMP-M<small>ATCHER</small> is no slower than F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>.</p>
<p>We are now ready to formally prove the correctness of the Knuth-Morris-Pratt algorithm. By Theorem 32.4, we have that <em>q</em> = <em>σ</em>(<em>T</em>[:<em>i</em>]) after each time line 3 of F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small> executes. Therefore, it suffices to show that the same property holds with regard to the <strong>for</strong> loop in KMP-M<small>ATCHER</small>. The proof proceeds by induction on the number of loop iterations. Initially, both procedures set <em>q</em> to 0 as they enter their respective <strong>for</strong> loops for the first time. Consider iteration <em>i</em> of the <strong>for</strong> loop in KMP-M<small>ATCHER</small>. By the inductive hypothesis, the state number <em>q</em> equals <em>σ</em>(<em>T</em>[:<em>i</em> – 1]) at the start of the loop iteration. We need to show that when line 8 is reached, the new value of <em>q</em> is <em>σ</em>(<em>T</em>[:<em>i</em>]). (Again, we’ll handle line 10 separately.)</p>
<p>Considering <em>q</em> to be the state number at the start of the <strong>for</strong> loop iteration, when KMP-M<small>ATCHER</small> considers the character <em>T</em>[<em>i</em>], the longest prefix of <em>P</em> that is a suffix of <em>T</em>[:<em>i</em>] is either <em>P</em>[:<em>q</em> + 1] (if <em>P</em>[<em>q</em> + 1] = <em>T</em>[<em>i</em>]) or some prefix (not <a id="p984"/>necessarily proper, and possibly empty) of <em>P</em>[:<em>q</em>]. We consider separately the three cases in which <em>σ</em>(<em>T</em>[:<em>i</em>]) = 0, <em>σ</em>(<em>T</em>[:<em>i</em>]) = <em>q</em> + 1, and 0 &lt; <em>σ</em>(<em>T</em>[:<em>i</em>]) ≤ <em>q</em>.</p>
<ul class="ulnoindent" epub:type="list">
<li>If <em>σ</em>(<em>T</em>[:<em>i</em>]) = 0, then <em>P</em>[:0] = <em><span class="font1">ϵ</span></em> is the only prefix of <em>P</em> that is a suffix of <em>T</em>[:<em>i</em>]. The <strong>while</strong> loop of lines 4–5 iterates through each value <em>q</em>′ in <em>π</em>*[<em>q</em>], but although <em>P</em>[:<em>q</em>′] <span class="font1">⊐</span> <em>P</em>[:<em>q</em>] <span class="font1">⊐</span> <em>T</em>[:<em>i</em> – 1] for every <em>q</em>′ ∈ <em>π</em>*[<em>q</em>] (because &lt; are <span class="font1">⊐</span> are transitive relations), the loop never finds a <em>q</em>′ such that <em>P</em>[<em>q</em>′ + 1] = <em>T</em>[<em>i</em>]. The loop terminates when <em>q</em> reaches 0, and of course line 7 does not execute. Therefore, <em>q</em> = 0 at line 8, so that now <em>q</em> = <em>σ</em>(<em>T</em>[:<em>i</em>]).</li>
<li>If <em>σ</em>(<em>T</em>[:<em>i</em>]) = <em>q</em>+1, then <em>P</em>[<em>q</em>+1] = <em>T</em>[<em>i</em>], and the <strong>while</strong> loop test in line 4 fails the first time through. Line 7 executes, incrementing the state number to <em>q</em> + 1, which equals <em>σ</em>(<em>T</em>[:<em>i</em>]).</li>
<li>If 0 &lt; <em>σ</em>(<em>T</em>[:<em>i</em>]) ≤ <em>q</em>′, then the <strong>while</strong> loop of lines 4–5 iterates at least once, checking in decreasing order each value in <em>π</em>*[<em>q</em>] until it stops at some <em>q</em>′ &lt; <em>q</em>. Thus, <em>P</em>[:<em>q</em>′] is the longest prefix of <em>P</em>[:<em>q</em>] for which <em>P</em>[<em>q</em>′ + 1] = <em>T</em>[<em>i</em>], so that when the <strong>while</strong> loop terminates, <em>q</em>′ + 1 = <em>σ</em>(<em>P</em>[:<em>q</em>]<em>T</em>[<em>i</em>]). Since <em>q</em> = <em>σ</em>(<em>T</em>[:<em>i</em> – 1]), Lemma 32.3 implies that <em>σ</em>(<em>T</em>[:<em>i</em> – 1]<em>T</em>[<em>i</em>]) = <em>σ</em>(<em>P</em>[:<em>q</em>]<em>T</em>[<em>i</em>]). Thus we have
<table class="table2b">
<tr>
<td class="td2"><em>q</em>′ + 1</td>
<td class="td2">=</td>
<td class="td2"><em>σ</em>(<em>P</em>[:<em>q</em>]<em>T</em>[<em>i</em>])</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>σ</em>(<em>T</em>[:<em>i</em> – 1]<em>T</em>[<em>i</em>])</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>σ</em>(<em>T</em>[:<em>i</em>])</td>
</tr>
</table>
<p class="noindent">when the <strong>while</strong> loop terminates. After line 7 increments <em>q</em>, the new state number <em>q</em> equals <em>σ</em>(<em>T</em>[:<em>i</em>]).</p></li>
</ul>
<p>Line 10 is necessary in KMP-M<small>ATCHER</small>, because otherwise, line 4 might try to reference <em>P</em>[<em>m</em> + 1] after finding an occurrence of <em>P</em>. (The argument that <em>q</em> = <em>σ</em>(<em>T</em>[:<em>i</em> – 1]) upon the next execution of line 4 remains valid by the hint given in Exercise 32.4-8: that <em>δ</em>(<em>m</em>, <em>a</em>) = <em>δ</em>(<em>π</em>[<em>m</em>], <em>a</em>) or, equivalently, <em>σ</em>(<em>Pa</em>) = <em>σ</em>(<em>P</em>[:<em>π</em>[<em>m</em>]]<em>a</em>) for any <em>a</em> ∈ ∑.) The remaining argument for the correctness of the Knuth-Morris-Pratt algorithm follows from the correctness of F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>, since we have shown that KMP-M<small>ATCHER</small> simulates the behavior of F<small>INITE</small>-A<small>UTOMATON</small>-M<small>ATCHER</small>.</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>32.4-1</em></strong></p>
<p class="noindent">Compute the prefix function <em>π</em> for the pattern <span class="courierfont">ababbabbabbababbabb</span>.</p>
<p class="level3"><strong><em>32.4-2</em></strong></p>
<p class="noindent">Give an upper bound on the size of <em>π</em>*[<em>q</em>] as a function of <em>q</em>. Give an example to show that your bound is tight.</p>
<a id="p985"/>
<p class="level3"><strong><em>32.4-3</em></strong></p>
<p class="noindent">Explain how to determine the occurrences of pattern <em>P</em> in the text <em>T</em> by examining the <em>π</em> function for the string <em>PT</em> (the string of length <em>m</em>+<em>n</em> that is the concatenation of <em>P</em> and <em>T</em>).</p>
<p class="level3"><strong><em>32.4-4</em></strong></p>
<p class="noindent">Use an aggregate analysis to show that the running time of KMP-M<small>ATCHER</small> is Θ(<em>n</em>).</p>
<p class="level3"><strong><em>32.4-5</em></strong></p>
<p class="noindent">Use a potential function to show that the running time of KMP-M<small>ATCHER</small> is Θ(<em>n</em>).</p>
<p class="level3"><strong><em>32.4-6</em></strong></p>
<p class="noindent">Show how to improve KMP-M<small>ATCHER</small> by replacing the occurrence of <em>π</em> in line 5 (but not line 10) by <em>π</em>′, where <em>π</em>′ is defined recursively for <em>q</em> = 1, 2, …, <em>m</em> – 1 by the equation</p>
<p class="eql"><img alt="art" src="images/Art_P1314.jpg"/></p>
<p class="noindent">Explain why the modified algorithm is correct, and explain in what sense this change constitutes an improvement.</p>
<p class="level3"><strong><em>32.4-7</em></strong></p>
<p class="noindent">Give a linear-time algorithm to determine whether a text <em>T</em> is a cyclic rotation of another string <em>T</em>′. For example, <span class="courierfont">braze</span> and <span class="courierfont">zebra</span> are cyclic rotations of each other.</p>
<p class="level3"><span class="font1">★</span> <strong><em>32.4-8</em></strong></p>
<p class="noindent">Give an <em>O</em>(<em>m</em> |∑|)-time algorithm for computing the transition function <em>δ</em> for the string-matching automaton corresponding to a given pattern <em>P</em>. (<em>Hint:</em> Prove that <em>δ</em>(<em>q</em>, <em>a</em>) = <em>δ</em>(<em>π</em>[<em>q</em>], <em>a</em>) if <em>q</em> = <em>m</em> or <em>P</em>[<em>q</em> + 1] ≠ <em>a</em>.)</p>
</section>
<p class="line1"/>
<section title="32.5 Suffix arrays">
<a id="Sec_32.5"/>
<p class="level1" id="h1-191"><a href="toc.xhtml#Rh1-191"><strong>32.5    Suffix arrays</strong></a></p>
<p class="noindent">The algorithms we have seen thus far in this chapter can efficiently find all occurrences of a pattern in a text. That is, however, all they can do. This section presents a different approach—suffix arrays—with which you can find all occurrences of a pattern in a text, but also quite a bit more. A suffix array won’t find all occurrences <a id="p986"/>of a pattern as quickly as, say, the Knuth-Morris-Pratt algorithm, but its additional flexibility makes it well worth studying.</p>
<div class="divimage">
<p class="fig-img1" id="Fig_32-11"><img alt="art" src="images/Art_P1315.jpg"/></p>
<p class="caption"><strong>Figure 32.11</strong> The suffix array <em>SA</em>, rank array <em>rank</em>, longest common prefix array <em>LCP</em>, and lexicographically sorted suffixes of the text <em>T</em> = <span class="courierfont">ratatat</span> with length <em>n</em> = 7. The value of <em>rank</em>[<em>i</em>] indicates the position of the suffix <em>T</em>[<em>i</em>:] in the lexicographically sorted order: <em>rank</em>[<em>SA</em>[<em>i</em>]] = <em>i</em> for <em>i</em> = 1, 2, …, <em>n</em>. The <em>rank</em> array is used to compute the <em>LCP</em> array.</p>
</div>
<p>A suffix array is simply a compact way to represent the lexicographically sorted order of all <em>n</em> suffixes of a length-<em>n</em> text. Given a text <em>T</em>[1:<em>n</em>], let <em>T</em>[<em>i</em>:] denote the suffix <em>T</em>[<em>i</em>:<em>n</em>]. The <span class="blue"><strong><em>suffix array</em></strong></span> <em>SA</em>[1:<em>n</em>] of <em>T</em> is defined such that if <em>SA</em>[<em>i</em>] = <em>j</em>, then <em>T</em>[<em>j</em>:] is the <em>i</em>th suffix of <em>T</em> in lexicographic order.<sup><a epub:type="footnote" href="#footnote_3" id="footnote_ref_3">3</a></sup> That is, the <em>i</em>th suffix of <em>T</em> in lexicographic order is <em>T</em>[<em>SA</em>[<em>i</em>]:]. Along with the suffix array, another useful array is the <span class="blue"><strong><em>longest common prefix array</em></strong></span> <em>LCPOE</em>[1:<em>n</em>]. The entry <em>LCP</em>[<em>i</em>] gives the length of the longest common prefix between the <em>i</em>th and (<em>i</em> – 1)st suffixes in the sorted order (with <em>LCP</em>[<em>SA</em>[1]] defined to be 0, since there is no prefix lexicographically smaller than <em>T</em>[<em>SA</em>[1]:]). <a href="chapter032.xhtml#Fig_32-11">Figure 32.11</a> shows the suffix array and longest common prefix array for the 7-character text <span class="courierfont">ratatat</span>.</p>
<p>Given the suffix array for a text, you can search for a pattern via binary search on the suffix array. Each occurrence of a pattern in the text starts some suffix of the text, and because the suffix array is in lexicographically sorted order, all occurrences of a pattern will appear at the start of consecutive entries of the suffix array. For example, in <a href="chapter032.xhtml#Fig_32-11">Figure 32.11</a>, the three occurrences of <span class="courierfont">at in ratatat</span> appear in entries 1 through 3 of the suffix array. If you find the length-<em>m</em> pattern in the length-<em>n</em> suffix array via binary search (taking <em>O</em>(<em>m</em> 1g <em>n</em>) time because each comparison takes <em>O</em>(<em>m</em>) time), then you can find all occurrences of the pattern in the text by searching backward and forward from that spot until you find a suffix that does not start with the pattern (or you go beyond the bounds of the suffix array). If the pattern occurs <em>k</em> times, then the time to find all <em>k</em> occurrences is <em>O</em>(<em>m</em> 1g <em>n</em> + <em>km</em>).</p>
<a id="p987"/>
<p>With the longest common prefix array, you can find a longest repeated substring, that is, the longest substring that occurs more than once in the text. If <em>LCP</em>[<em>i</em>] contains a maximum value in the <em>LCP</em> array, then a longest repeated substring appears in <em>T</em>[<em>SA</em>[<em>i</em>]:<em>SA</em>[<em>i</em>] + <em>LCP</em>[<em>i</em>] – 1]. In the example of <a href="chapter032.xhtml#Fig_32-11">Figure 32.11</a>, the <em>LCP</em> array has one maximum value: <em>LCP</em>[3] = 4. Therefore, since <em>SA</em>[3] = 2, the longest repeated substring is <em>T</em>[2:5] = <span class="courierfont">atat</span>. Exercise 32.5-3 asks you to use the suffix array and longest common prefix array to find the longest common substrings between two texts. Next, we’ll see how to compute the suffix array for an <em>n</em>-character text in <em>O</em>(<em>n</em> 1g <em>n</em>) time and, given the suffix array and the text, how to compute the longest common prefix array in Θ(<em>n</em>) time.</p>
<p class="level4"><strong>Computing the suffix array</strong></p>
<p class="noindent">There are several algorithms to compute the suffix array of a length-<em>n</em> text. Some run in linear time, but are rather complicated. One such algorithm is given in Problem 32-2. Here we’ll explore a simpler algorithm that runs in Θ(<em>n</em> 1g <em>n</em>) time.</p>
<p>The idea behind the <em>O</em>(<em>n</em> 1g <em>n</em>)-time procedure C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small> on the following page is to lexicographically sort substrings of the text with increasing lengths. The procedure makes several passes over the text, with the substring length doubling each time. By the <span class="font1">⌈</span>1g <em>n</em><span class="font1">⌉</span>th pass, the procedure is sorting all the suffixes, thereby gaining the information needed to construct the suffix array. The key to attaining an <em>O</em>(<em>n</em> 1g <em>n</em>)-time algorithm will be to have each pass after the first sort in linear time, which will indeed be possible by using radix sort.</p>
<p>Let’s start with a simple observation. Consider any two strings, <em>s</em><sub>1</sub> and <em>s</em><sub>2</sub>. Decompose <em>s</em><sub>1</sub> into <img alt="art" src="images/Art_sprime1.jpg"/> and <img alt="art" src="images/Art_sdprime1.jpg"/>, so that <em>s</em><sub>1</sub> is <img alt="art" src="images/Art_sprime1.jpg"/> concatenated with <img alt="art" src="images/Art_sdprime1.jpg"/>. Likewise, let <em>s</em><sub>2</sub> be <img alt="art" src="images/Art_sprime2.jpg"/> concatenated with <img alt="art" src="images/Art_sdprime2.jpg"/>. Now, suppose that <img alt="art" src="images/Art_sprime1.jpg"/> is lexicographically smaller than <img alt="art" src="images/Art_sprime2.jpg"/>. Then, regardless of <img alt="art" src="images/Art_sdprime1.jpg"/> and <img alt="art" src="images/Art_sdprime2.jpg"/>, it must be the case that <em>s</em><sub>1</sub> is lexicographically smaller than <em>s</em><sub>2</sub>. For example, let <em>s</em><sub>1</sub> = <span class="courierfont">aaz</span> and <em>s</em><sub>2</sub> = <span class="courierfont">aba</span>, and decompose <em>s</em><sub>1</sub> into <img alt="art" src="images/Art_P1316.jpg"/> and <img alt="art" src="images/Art_P1317.jpg"/> and <em>s</em><sub>2</sub> into <img alt="art" src="images/Art_P1318.jpg"/> and <img alt="art" src="images/Art_P1319.jpg"/>. Because <img alt="art" src="images/Art_sprime1.jpg"/> is lexicographically smaller than <img alt="art" src="images/Art_sprime2.jpg"/>, it follows that <em>s</em><sub>1</sub> is lexicographically smaller than <em>s</em><sub>2</sub>, even though <img alt="art" src="images/Art_sdprime2.jpg"/> is lexicographically smaller than <img alt="art" src="images/Art_sdprime1.jpg"/>.</p>
<p>Instead of comparing substrings directly, C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small> represents substrings of the text with integer <span class="blue"><strong><em>ranks</em></strong></span>. Ranks have the simple property that one substring is lexicographically smaller then another if and only if it has a smaller rank. Identical substrings have equal ranks.</p>
<p>Where do these ranks come from? Initially, the substrings being considered are just single characters from the text. Assume that, as in many programming languages, there is a function, ord, that maps a character to its underlying encoding, which is a positive integer. The ord function could be the ASCII or Unicode encodings or any other function that produces a relative ordering of the characters. For example if all the characters are known to be lowercase letters, then ord(<span class="courierfont">a</span>) = 1, ord(<span class="courierfont">b</span>) = 2, …, ord(<span class="courierfont">z</span>) = 26 would work. Once the substrings being considered contain multiple characters, their ranks will be positive integers less than or equal to <em>n</em>, coming from their relative order after being sorted. An empty substring always has rank 0, since it is lexicographically less than any nonempty substring.</p>
<a id="p988"/>
<div class="pull-quote1">
<p class="box-heading">C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small>(<em>T</em>, <em>n</em>)</p>
<table class="table1">
<tr>
<td class="td1w1"><span class="x-small">  1</span></td>
<td class="td1">allocate arrays <em>substr-rank</em>[1:<em>n</em>], <em>rank</em>[1:<em>n</em>], and <em>SA</em>[1:<em>n</em>]</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> <em>n</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><p class="p2"><em>substr-rank</em>[<em>i</em>].<em>left-rank</em> = ord(<em>T</em>[<em>i</em>])</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>i</em> &lt; <em>n</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="p3"><em>substr-rank</em>[<em>i</em>].<em>right-rank</em> = ord(<em>T</em>[<em>i</em> + 1])</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p2"><strong>else</strong> <em>substr-rank</em>[<em>i</em>].<em>right-rank</em> = 0</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p2"><em>substr-rank</em>[<em>i</em>].<em>index</em> = <em>i</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="tdph">sort the array <em>substr-rank</em> into monotonically increasing order based on the <em>left-rank</em> attributes, using the <em>right-rank</em> attributes to break ties; if still a tie, the order does not matter</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><em>l</em> = 2</td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><strong>while</strong> <em>l</em> &lt; <em>n</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><p class="p2">M<small>AKE</small>-R<small>ANKS</small>(<em>substr-rank</em>, <em>rank</em>, <em>n</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1"><p class="p2"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> <em>n</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1"><p class="p3"><em>substr-rank</em>[<em>i</em>].<em>left-rank</em> = <em>rank</em>[<em>i</em>]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">14</span></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>i</em> + <em>l</em> ≤ <em>n</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">15</span></td>
<td class="td1"><p class="p4"><em>substr-rank</em>[<em>i</em>].<em>right-rank</em> = <em>rank</em>[<em>i</em> + <em>l</em>]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">16</span></td>
<td class="td1"><p class="p3"><strong>else</strong> <em>substr-rank</em>[<em>i</em>].<em>right-rank</em> = 0</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">17</span></td>
<td class="td1"><p class="p3"><em>substr-rank</em>[<em>i</em>].<em>index</em> = <em>i</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">18</span></p></td>
<td class="td1"><p class="p2">sort the array <em>substr-rank</em> into monotonically increasing order based on the <em>left-rank</em> attributes, using the <em>right-rank</em> attributes to break ties; if still a tie, the order does not matter</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">19</span></td>
<td class="td1"><p class="p2"><em>l</em> = 2<em>l</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">20</span></td>
<td class="td1"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> <em>n</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">21</span></td>
<td class="td1"><p class="p2"><em>SA</em>[<em>i</em>] = <em>substr-rank</em>[<em>i</em>].<em>index</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">22</span></td>
<td class="td1"><strong>return</strong> <em>SA</em></td>
</tr>
<tr>
<td class="td1" colspan="2"><p class="box-headinga">M<small>AKE</small>-R<small>ANKS</small>(<em>substr-rank</em>, <em>rank</em>, <em>n</em>)</p></td>
</tr>
<tr>
<td class="td1w1"><span class="x-small">  1</span></td>
<td class="td1"><em>r</em> = 1</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><em>rank</em>[<em>substr-rank</em>[1].<em>index</em>] = <em>r</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><strong>for</strong> <em>i</em> = 2 <strong>to</strong> <em>n</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>substr-rank</em>[<em>i</em>].<em>left-rank</em> ≠ <em>substr-rank</em>[<em>i</em> – 1].<em>left-rank</em></p></td>
</tr>
<tr>
<td class="td1">  </td>
<td class="td1"><p class="p4">or <em>substr-rank</em>[<em>i</em>].<em>right-rank</em> ≠ <em>substr-rank</em>[<em>i</em> – 1].<em>right-rank</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="p3"><em>r</em> = <em>r</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p2"><em>rank</em>[<em>substr-rank</em>[<em>i</em>].<em>index</em>] = <em>r</em></p></td>
</tr>
</table>
</div>
<a id="p989"/>
<div class="divimage">
<p class="fig-img1" id="Fig_32-12"><img alt="art" src="images/Art_P1320.jpg"/></p>
<p class="caption"><strong>Figure 32.12</strong> The <em>substr-rank</em> array for indices <em>i</em> = 1, 2, …, 7 after the <strong>for</strong> loop of lines 2–7 and after the sorting step in line 8 for input string <em>T</em> = <span class="courierfont">ratatat</span>.</p>
</div>
<p>The C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small> procedure uses objects internally to keep track of the relative ordering of the substrings according to their ranks. When considering substrings of a given length, the procedure creates and sorts an array <em>substr-rank</em>[1:<em>n</em>] of <em>n</em> objects, each with the following attributes:</p>
<ul class="ulnoindent" epub:type="list">
<li><em>left-rank</em> contains the rank of the left part of the substring.</li>
<li class="litop"><em>right-rank</em> contains the rank of the right part of the substring.</li>
<li class="litop"><em>index</em> contains the index into the text <em>T</em> of where the substring starts.</li></ul>
<p>Before delving into the details of how the procedure works, let’s look at how it operates on the input text <span class="courierfont">ratatat</span>, with <em>n</em> = 7. Assuming that the ord function returns the ASCII code for a character, <a href="chapter032.xhtml#Fig_32-12">Figure 32.12</a> shows the <em>substr-rank</em> array after the <strong>for</strong> loop of lines 2–7 and then after the sorting step in line 8. The <em>left-rank</em> and <em>right-rank</em> values after lines 2–7 are the ranks of length-1 substrings in positions <em>i</em> and <em>i</em> + 1, for <em>i</em> = 1, 2, …, <em>n</em>. These initial ranks are the ASCII values of the characters. At this point, the <em>left-rank</em> and <em>right-rank</em> values give the ranks of the left and right part of each substring of length 2. Because the substring starting at index 7 consists of only one character, its right part is empty and so its <em>right-rank</em> is 0. After the sorting step in line 8, the <em>substr-rank</em> array gives the relative lexicographic order of all the substrings of length 2, with starting points of these substrings in the <em>index</em> attribute. For example, the lexicographically smallest length-2 substring is <span class="courierfont">at</span>, which starts at position <em>substr-rank</em>[1].<em>index</em>, which equals 2. This substring also occurs at positions <em>substr-rank</em>[2].<em>index</em> = 4 and <em>substr-rank</em>[3].<em>index</em> = 6.</p>
<p>The procedure then enters the <strong>while</strong> loop of lines 10–19. The loop variable <em>l</em> gives an upper bound on the length of substrings that have been sorted thus far. <a id="p990"/>Entering the <strong>while</strong> loop, therefore, the substrings of length at most <em>l</em> = 2 are sorted. The call of M<small>AKE</small>-R<small>ANKS</small> in line 11 gives each of these substrings its rank in the sorted order, from 1 up to the number of unique length-2 substrings, based on the values it finds in the <em>substr-rank</em> array. With <em>l</em> = 2, M<small>AKE</small>-R<small>ANKS</small> sets <em>rank</em>[<em>i</em>] to be the rank of the length-2 substring <em>T</em>[<em>i</em>:<em>i</em> + 1]. <a href="chapter032.xhtml#Fig_32-13">Figure 32.13</a> shows these new ranks, which are not necessarily unique. For example, since the length-2 substring <span class="courierfont">at</span> occurs at positions 2, 4, and 6, M<small>AKE</small>-R<small>ANKS</small> finds that <em>substr-rank</em>[1], <em>substr-rank</em>[2], and <em>substr-rank</em>[3] have equal values in <em>left-rank</em> and in <em>right-rank</em>. Since <em>substr-rank</em>[1].<em>index</em> = 2, <em>substr-rank</em>[2].<em>index</em> = 4, and <em>substr-rank</em>[3].<em>index</em> = 6, and since <span class="courierfont">at</span> is the smallest substring in lexicographic order, M<small>AKE</small>-R<small>ANKS</small> sets <em>rank</em>[2] = <em>rank</em>[4] = <em>rank</em>[6] = 1.</p>
<div class="divimage">
<p class="fig-img1" id="Fig_32-13"><img alt="art" src="images/Art_P1321.jpg"/></p>
<p class="caption"><strong>Figure 32.13</strong> The <em>rank</em> array after line 11 and the <em>substr-rank</em> array after lines 12–17 and after line 18 in the first iteration of the <strong>while</strong> loop of lines 10–19, where <em>l</em> = 2.</p>
</div>
<p>This iteration of the <strong>while</strong> loop will sort the substrings of length at most 4 based on the ranks from sorting the substrings of length at most 2. The <strong>for</strong> loop of lines 12–17 reconstitutes the <em>substr-rank</em> array, with <em>substr-rank</em>[<em>i</em>].<em>left-rank</em> based on <em>rank</em>[<em>i</em>] (the rank of the length-2 substring <em>T</em>[<em>i</em>:<em>i</em>+1]) and <em>substr-rank</em>[<em>i</em>].<em>right-rank</em> based on <em>rank</em>[<em>i</em> + 2] (the rank of the length-2 substring <em>T</em>[<em>i</em> + 2:<em>i</em> + 3], which is 0 if this substring starts beyond the end of the length-<em>n</em> text). Together, these two ranks give the relative rank of the length-4 substring <em>T</em>[<em>i</em>:<em>i</em> + 3]. <a href="chapter032.xhtml#Fig_32-13">Figure 32.13</a> shows the effect of lines 12–17. The figure also shows the result of sorting the <em>substr-rank</em> array in line 18, based on the <em>left-rank</em> attribute, and using the <em>right-rank</em> attribute to break ties. Now <em>substr-rank</em> gives the lexicographically sorted order of all substrings with length at most 4.</p>
<p>The next iteration of the <strong>while</strong> loop, with <em>l</em> = 4, sorts the substrings of length at most 8 based on the ranks from sorting the substrings of length at most<sup><a epub:type="footnote" href="#footnote_4" id="footnote_ref_4">4</a></sup> 4. <a href="chapter032.xhtml#Fig_32-14">Figure 32.14</a> shows the ranks of the length-4 substrings and the <em>substr-rank</em> array <a id="p991"/>before and after sorting. This iteration is the final one, since with the length <em>n</em> of the text equaling 7, the procedure has sorted all substrings.</p>
<div class="divimage">
<p class="fig-img1" id="Fig_32-14"><img alt="art" src="images/Art_P1322.jpg"/></p>
<p class="caption"><strong>Figure 32.14</strong> The <em>rank</em> array after line 11 and the <em>substr-rank</em> array after lines 12–17 and after line 18 in the second—and final—iteration of the <strong>while</strong> loop of lines 10–19, where <em>l</em> = 4.</p>
</div>
<p>In general, as the loop variable <em>l</em> increases, more and more of the right parts of the substrings are empty. Therefore, more of the <em>right-rank</em> values are 0. Because <em>i</em> is at most <em>n</em> within the loop of lines 12–17, the left part of each substring is always nonempty, and so all <em>left-rank</em> values are always positive.</p>
<p>This example illuminates why the C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small> procedure works. The initial ranks established in lines 2–7 are simply the ord values of the characters in the text, and so when line 8 sorts the <em>substr-rank</em> array, its ordering corresponds to the lexicographic ordering of the length-2 substrings. Each iteration of the <strong>while</strong> loop of lines 10–19 takes sorted substrings of length <em>l</em> and produces sorted substrings of length 2<em>l</em>. Once <em>l</em> reaches or exceeds <em>n</em>, all substrings have been sorted.</p>
<p>Within an iteration of the <strong>while</strong> loop, the M<small>AKE</small>-R<small>ANKS</small> procedure “re-ranks” the substrings that were sorted, either by line 8 before the first iteration or by line 18 in the previous iteration. M<small>AKE</small>-R<small>ANKS</small> takes a <em>substr-rank</em> array, which has been sorted, and fills in an array <em>rank</em>[1:<em>n</em>] so that <em>rank</em>[<em>i</em>] is the rank of the <em>i</em>th substring represented in the <em>substr-rank</em> array. Each rank is a positive integer, starting from 1, and going up to the number of unique substrings of length 2<em>l</em>. Substrings with equal values of <em>left-rank</em> and <em>right-rank</em> receive the same rank. Otherwise, a substring that is lexicographically smaller than another appears earlier in the <em>substr-rank</em> array, and it receives a smaller rank. Once the substrings of length 2<em>l</em> are re-ranked, line 18 sorts them by rank, preparing for the next iteration of the <strong>while</strong> loop.</p>
<p>Once <em>l</em> reaches or exceeds <em>n</em> and all substrings are sorted, the values in the <em>index</em> attributes give the starting positions of the sorted substrings. These indices are precisely the values that constitute the suffix array.</p>
<p>Let’s analyze the running time of C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small>. Lines 1–7 take Θ(<em>n</em>) time. Line 8 takes <em>O</em>(<em>n</em> 1g <em>n</em>) time, using either merge sort (see <a href="chapter002.xhtml#Sec_2.3.1">Section 2.3.1</a>) or heapsort (see <a href="chapter006.xhtml">Chapter 6</a>). Because the value of <em>l</em> doubles in each iteration of <a id="p992"/>the <strong>while</strong> loop of lines 10–19, this loop makes <span class="font1">⌈</span>1g <em>n</em><span class="font1">⌉</span> – 1 iterations. Within each iteration, the call of M<small>AKE</small>-R<small>ANKS</small> takes Θ(<em>n</em>) time, as does the <strong>for</strong> loop of lines 12–17. Line 18, like line 8, takes <em>O</em>(<em>n</em> 1g <em>n</em>) time, using either merge sort or heapsort. Finally, the <strong>for</strong> loop of lines 20–21 takes Θ(<em>n</em>) time. The total time works out to <em>O</em>(<em>n</em> 1g<sup>2</sup> <em>n</em>).</p>
<p>A simple observation allows us to reduce the running time to Θ(<em>n</em> 1g <em>n</em>). The values of <em>left-rank</em> and <em>right-rank</em> being sorted in line 18 are always integers in the range 0 to <em>n</em>. Therefore, radix sort can sort the <em>substr-rank</em> array in Θ(<em>n</em>) time by first running counting sort (see <a href="chapter008.xhtml">Chapter 8</a>) based on <em>right-rank</em> and then running counting sort based on <em>left-rank</em>. Now each iteration of the <strong>while</strong> loop of lines 10–19 takes only Θ(<em>n</em>) time, giving a total time of Θ(<em>n</em> 1g <em>n</em>).</p>
<p>Exercise 32.5-2 asks you to make a simple modification to C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small> that allows the <strong>while</strong> loop of lines 10–19 to iterate fewer than <span class="font1">⌈</span>1g <em>n</em><span class="font1">⌉</span> – 1 times for certain inputs.</p>
<p class="level4"><strong>Computing the <em>LCP</em> array</strong></p>
<p class="noindent">Recall that <em>LCP</em>[<em>i</em>] is defined as the length of the longest common prefix of the (<em>i</em> – 1)st and <em>i</em>th lexicographically smallest suffixes <em>T</em>[<em>SA</em>[<em>i</em> – 1]:] and <em>T</em>[<em>SA</em>[<em>i</em>]:]. Because <em>T</em>[<em>SA</em>[1]:] is the lexicographically smallest suffix, we define <em>LCP</em>[1] to be 0.</p>
<p>In order to compute the <em>LCP</em> array, we need an array <em>rank</em> that is the inverse of the <em>SA</em> array, just like the final <em>rank</em> array in C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small>: if <em>SA</em>[<em>i</em>] = <em>j</em>, then <em>rank</em>[<em>j</em>] = <em>i</em>. That is, we have <em>rank</em>[<em>SA</em>[<em>i</em>]] = <em>i</em> for <em>i</em> = 1, 2, …, <em>n</em>. For a suffix <em>T</em>[<em>i</em>:], the value of <em>rank</em>[<em>i</em>] gives the position of this suffix in the lexicographically sorted order. <a href="chapter032.xhtml#Fig_32-11">Figure 32.11</a> includes the <em>rank</em> array for the <span class="courierfont">ratatat</span> example. For example, the suffix <span class="courierfont">tat</span> is <em>T</em>[5:]. To find this suffix’s position in the sorted order, look up <em>rank</em>[5] = 6.</p>
<p>To compute the <em>LCP</em> array, we will need to determine where in the lexicographically sorted order a suffix appears, but with its first character removed. The <em>rank</em> array helps. Consider the <em>i</em>th smallest suffix, which is <em>T</em>[<em>SA</em>[<em>i</em>]:]. Dropping its first character gives the suffix <em>T</em>[<em>SA</em>[<em>i</em>] + 1:], that is, the suffix starting at position <em>SA</em>[<em>i</em>] + 1 in the text. The location of this suffix in the sorted order is given by <em>rank</em>[<em>SA</em>[<em>i</em>] + 1]. For example, for the suffix <span class="courierfont">atat</span>, let’s see where to find <span class="courierfont">tat</span> (<span class="courierfont">atat</span> with its first character removed) in the lexicographically sorted order. The suffix <span class="courierfont">atat</span> appears in position 2 of the suffix array, and <em>SA</em>[2] = 4. Thus, <em>rank</em>[<em>SA</em>[2] + 1] = <em>rank</em>[5] = 6, and sure enough the suffix <span class="courierfont">tat</span> appears in location 6 in the sorted order.</p>
<p>The procedure C<small>OMPUTE</small>-LCP on the next page produces the <em>LCP</em> array. The following lemma helps show that the procedure is correct.</p>
<a id="p993"/>
<div class="pull-quote1">
<p class="box-heading">C<small>OMPUTE</small>-LCP(<em>T</em>, <em>SA</em>, <em>n</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1" colspan="2">allocate arrays <em>rank</em>[1:<em>n</em>] and <em>LCP</em>[1:<em>n</em>]</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1" colspan="2"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> <em>n</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><p class="p2"><em>rank</em>[<em>SA</em>[<em>i</em>]] = <em>i</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> by definition</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><em>LCP</em>[1] = 0</td>
<td class="td1"><span class="red"><strong>//</strong> also by definition</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><em>l</em> = 0</td>
<td class="td1"><span class="red"><strong>//</strong> initialize length of LCP</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1" colspan="2"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> <em>n</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>if</strong> <em>rank</em>[<em>i</em>] &gt; 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="p3"><em>j</em> = <em>SA</em>[<em>rank</em>[<em>i</em>] – 1]</p></td>
<td class="td1"><span class="red"><strong>//</strong> <em>T</em>[<em>j</em>:] precedes <em>T</em>[<em>i</em>:] lexicographically</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1" colspan="2"><p class="p3"><em>m</em> = max {<em>i</em>, <em>j</em> }</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1" colspan="2"><p class="p3"><strong>while</strong> <em>m</em> + <em>l</em> ≤ <em>n</em> and <em>T</em>[<em>i</em> + <em>l</em>] == <em>T</em>[<em>j</em> + <em>l</em>]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><p class="p4"><em>l</em> = <em>l</em> + 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> next character is in common prefix</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1"><p class="p3"><em>LCP</em>[<em>rank</em>[<em>i</em>]] = <em>l</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> length of LCP of <em>T</em>[<em>j</em>:] and <em>T</em>[<em>i</em>:]</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1" colspan="2"><p class="p3"><strong>if</strong> <em>l</em> &gt; 0</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">14</span></td>
<td class="td1"><p class="p4"><em>l</em> = <em>l</em> – 1</p></td>
<td class="td1"><span class="red"><strong>//</strong> peel off first character of common prefix</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">15</span></td>
<td class="td1" colspan="2"><strong>return</strong> <em>LCP</em></td>
</tr>
</table>
</div>
<p class="lem"><strong><em>Lemma 32.8</em></strong></p>
<p class="noindent">Consider suffixes <em>T</em>[<em>i</em> – 1:] and <em>T</em>[<em>i</em>:], which appear at positions <em>rank</em>[<em>i</em> – 1] and <em>rank</em>[<em>i</em>], respectively, in the lexicographically sorted order of suffixes. If <em>LCP</em>[<em>rank</em>[<em>i</em> – 1]] = <em>l</em> &gt; 1, then the suffix <em>T</em>[<em>i</em>:], which is <em>T</em>[<em>i</em> – 1:] with its first character removed, has <em>LCP</em>[<em>rank</em>[<em>i</em>]] ≥ <em>l</em> – 1.</p>
<p class="proof"><strong><em>Proof</em></strong>   The suffix <em>T</em>[<em>i</em> – 1:] appears at position <em>rank</em>[<em>i</em> – 1] in the lexicographically sorted order. The suffix immediately preceding it in the sorted order appears at position <em>rank</em>[<em>i</em> – 1] – 1 and is <em>T</em>[<em>SA</em>[<em>rank</em>[<em>i</em> – 1] – 1]:]. By assumption and the definition of the <em>LCP</em> array, these two suffixes, <em>T</em>[<em>SA</em>[<em>rank</em>[<em>i</em>–1]–1]:] and <em>T</em>[<em>i</em>–1:], have a longest common prefix of length <em>l</em> &gt; 1. Removing the first character from each of these suffixes gives the suffixes <em>T</em>[<em>SA</em>[<em>rank</em>[<em>i</em> – 1] – 1] + 1:] and <em>T</em>[<em>i</em>:], respectively. These suffixes have a longest common prefix of length <em>l</em> – 1. If <em>T</em>[<em>SA</em>[<em>rank</em>[<em>i</em> – 1] – 1] + 1:] immediately precedes <em>T</em>[<em>i</em>:] in the lexicographically sorted order (that is, if <em>rank</em>[<em>SA</em>[<em>rank</em>[<em>i</em> – 1] – 1] + 1] = <em>rank</em>[<em>i</em>] – 1), then the lemma is proven.</p>
<p>So now assume that <em>T</em>[<em>SA</em>[<em>rank</em>[<em>i</em> – 1] – 1] + 1:] does not immediately precede <em>T</em>[<em>i</em>:] in the sorted order. Since <em>T</em>[<em>SA</em>[<em>rank</em>[<em>i</em> – 1] – 1]:] immediately precedes <em>T</em>[<em>i</em>–1:] and they have the same first <em>l</em> &gt; 1 characters, <em>T</em>[<em>SA</em>[<em>rank</em>[<em>i</em> – 1] – 1] + 1:] must appear in the sorted order somewhere before <em>T</em>[<em>i</em>:], with one or more other suffixes intervening. Each of these suffixes must start with the same <em>l</em> – 1 characters as <em>T</em>[<em>SA</em>[<em>rank</em>[<em>i</em> – 1] – 1] + 1:] and <em>T</em>[<em>i</em>:], for otherwise it would appear either before <a id="p994"/><em>T</em>[<em>SA</em>[<em>rank</em>[<em>i</em> – 1] – 1] + 1:] or after <em>T</em>[<em>i</em>:]. Therefore, whichever suffix appears in position <em>rank</em>[<em>i</em>] – 1, immediately before <em>T</em>[<em>i</em>:], has at least its first <em>l</em> – 1 characters in common with <em>T</em>[<em>i</em>:]. Thus, <em>LCP</em>[<em>rank</em>[<em>i</em>]] ≥ <em>l</em> – 1.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The C<small>OMPUTE</small>-LCP procedure works as follows. After allocating the <em>rank</em> and <em>LCP</em> arrays in line 1, lines 2–3 fill in the <em>rank</em> array and line 4 pegs <em>LCP</em>[1] to 0, per the definition of the <em>LCP</em> array.</p>
<p>The <strong>for</strong> loop of lines 6–14 fills in the rest of the <em>LCP</em> array going by decreasing-length suffixes. That is, it fills the position of the <em>LCP</em> array in the order <em>rank</em>[1], <em>rank</em>[2], <em>rank</em>[3], …, <em>rank</em>[<em>n</em>], with the assignment occurring in line 12. Upon considering a suffix <em>T</em>[<em>i</em>:], line 8 determines the suffix <em>T</em>[<em>j</em>:] that immediately precedes <em>T</em>[<em>i</em>:] in the lexicographically sorted order. At this point, the longest common prefix of <em>T</em>[<em>j</em>:] and <em>T</em>[<em>i</em>:] has length at least <em>l</em>. This property certainly holds upon the first iteration of the <strong>for</strong> loop, when <em>l</em> = 0. Assuming that line 12 sets <em>LCP</em>[<em>rank</em>[<em>i</em>]] correctly, line 14 (which decrements <em>l</em> if it is positive) and Lemma 32.8 maintain this property for the next iteration. The longest common prefix of <em>T</em>[<em>j</em>:] and <em>T</em>[<em>i</em>:] might be even longer than the value of <em>l</em> at the start of the iteration, however. Lines 9–11 increment <em>l</em> for each additional character the prefixes have in common so that it achieves the length of the longest common prefix. The index <em>m</em> is set in line 9 and used in the test in line 10 to make sure that the test <em>T</em>[<em>i</em> + <em>l</em>] == <em>T</em>[<em>j</em> + <em>l</em>] for extending the longest common prefix does not run off the end of the text <em>T</em>. When the <strong>while</strong> loop of lines 10–11 terminates, <em>l</em> is the length of the longest common prefix of <em>T</em>[<em>j</em>:] and <em>T</em>[<em>i</em>:].</p>
<p>As a simple aggregate analysis shows, the C<small>OMPUTE</small>-LCP procedure runs in Θ(<em>n</em>) time. Each of the two <strong>for</strong> loops iterates <em>n</em> times, and so it remains only to bound the total number of iterations by the <strong>while</strong> loop of lines 10–11. Each iteration increases <em>l</em> by 1, and the test <em>m</em> + <em>l</em> ≤ <em>n</em> ensures that <em>l</em> is always less than <em>n</em>. Because <em>l</em> has an initial value of 0 and decreases at most <em>n</em> – 1 times in line 14, line 11 increments <em>l</em> fewer than 2<em>n</em> times. Thus, C<small>OMPUTE</small>-LCP takes Θ(<em>n</em>) time.</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>32.5-1</em></strong></p>
<p class="noindent">Show the <em>substr-rank</em> and <em>rank</em> arrays before each iteration of the <strong>while</strong> loop of lines 10–19 and after the last iteration of the <strong>while</strong> loop, the suffix array <em>SA</em> returned, and the sorted suffixes when C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small> is run on the text <span class="courierfont">hippityhoppity</span>. Use the position of each letter in the alphabet as its ord value, so that ord(<span class="courierfont">b</span>) = 2. Then show the <em>LCP</em> array after each iteration of the <strong>for</strong> loop of lines 6–14 of C<small>OMPUTE</small>-LCP given the text <span class="courierfont">hippityhoppity</span> and its suffix array.</p>
<a id="p995"/>
<p class="level3"><strong><em>32.5-2</em></strong></p>
<p class="noindent">For some inputs, the C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small> procedure can produce the correct result with fewer than <span class="font1">⌈</span>1g <em>n</em><span class="font1">⌉</span> – 1 iterations of the <strong>while</strong> loop of lines 10–19. Modify C<small>OMPUTE</small>-S<small>UFFIX</small>-A<small>RRAY</small> (and, if necessary, M<small>AKE</small>-R<small>ANKS</small>) so that the procedure can stop before making all <span class="font1">⌈</span>1g <em>n</em><span class="font1">⌉</span> – 1 iterations in some cases. Describe an input that allows the procedure to make <em>O</em>(1) iterations. Describe an input that forces the procedure to make the maximum number of iterations.</p>
<p class="level3"><strong><em>32.5-3</em></strong></p>
<p class="noindent">Given two texts, <em>T</em><sub>1</sub> of length <em>n</em><sub>1</sub> and <em>T</em><sub>2</sub> of length <em>n</em><sub>2</sub>, show how to use the suffix array and longest common prefix array to find all of the <span class="blue"><strong><em>longest common substrings</em></strong></span>, that is, the longest substrings that appear in both <em>T</em><sub>1</sub> and <em>T</em><sub>2</sub>. Your algorithm should run in <em>O</em>(<em>n</em> 1g <em>n</em> + <em>kl</em>) time, where <em>n</em> = <em>n</em><sub>1</sub> + <em>n</em><sub>2</sub> and there are <em>k</em> such longest substrings, each with length <em>l</em>.</p>
<p class="level3"><strong><em>32.5-4</em></strong></p>
<p class="noindent">Professor Markram proposes the following method to find the longest palindromes in a string <em>T</em>[1:<em>n</em>] by using its suffix array and LCP array. (Recall from Problem 14-2 that a palindrome is a nonempty string that reads the same forward and backward.)</p>
<div class="pull-quote">
<p class="pq-noindent">Let <span class="courierfont">@</span> be a character that does not appear in <em>T</em>. Construct the text <em>T</em>′ as the concatenation of <em>T</em>, <span class="courierfont">@</span>, and the reverse of <em>T</em>. Denote the length of <em>T</em>′ by <em>n</em>′ = 2<em>n</em> + 1. Create the suffix array <em>SA</em> and <em>LCP</em> array <em>LCP</em> for <em>T</em>′. Since the indices for a palindrome and its reverse appear in consecutive positions in the suffix array, find the entries with the maximum <em>LCP</em> value <em>LCP</em>[<em>i</em>] such that <em>SA</em>[<em>i</em> – 1] = <em>n</em>′ – <em>SA</em>[<em>i</em>] – <em>LCP</em>[<em>i</em>] + 2. (This constraint prevents a substring—and its reverse—from being construed as a palindrome unless it really is one.) For each such index <em>i</em>, one of the longest palindromes is <em>T</em>′[<em>SA</em>[<em>i</em>]:<em>SA</em>[<em>i</em>] + <em>LCP</em>[<em>i</em>] – 1].</p>
</div>
<p>For example, if the text <em>T</em> is <span class="courierfont">unreferenced</span>, with <em>n</em> = 12, then the text <em>T</em>′ is <span class="courierfont">unreferenced@decnerefernu</span>, with <em>n</em>′ = 25 and the following suffix array and LCP array:</p>
<p class="eql"><img alt="art" src="images/Art_P1322a.jpg"/></p>
<p class="noindent">The maximum <em>LCP</em> value is achieved at <em>LCP</em>[21] = 5, and <em>SA</em>[20] = 3 = <em>n</em>′ – <em>SA</em>[21] – <em>LCP</em>[21] + 2. The suffixes of <em>T</em>′ starting at indices <em>SA</em>[20] and <em>SA</em>[21] are <span class="courierfont">referenced@decnerefernu</span> and <span class="courierfont">refernu</span>, both of which start with the length-5 palindrome <span class="courierfont">refer</span>.</p>
<a id="p996"/>
<p>Alas, this method is not foolproof. Give an input string <em>T</em> that causes this method to give results that are shorter than the longest palindrome contained within <em>T</em>, and explain why your input causes the method to fail.</p>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-192"><strong>Problems</strong></p>
<section title="32-1 String matching based on repetition factors">
<p class="level2"><strong><em>32-1     String matching based on repetition factors</em></strong></p>
<p class="noindent">Let <em>y</em><sup><em>i</em></sup> denote the concatenation of string <em>y</em> with itself <em>i</em> times. For example, (<span class="courierfont">ab</span>)<sup>3</sup> = <span class="courierfont">ababab</span>. We say that a string <em>x</em> ∈ ∑* has <span class="blue"><strong><em>repetition factor</em></strong></span> <em>r</em> if <em>x</em> = <em>y</em><sup><em>r</em></sup> for some string <em>y</em> ∈ ∑* and some <em>r</em> &gt; 0. Let <em>ρ</em>(<em>x</em>) denote the largest <em>r</em> such that <em>x</em> has repetition factor <em>r</em>.</p>
<p class="nl"><strong><em>a.</em></strong> Give an efficient algorithm that takes as input a pattern <em>P</em>[1:<em>m</em>] and computes the value <em>ρ</em>(<em>P</em>[:<em>i</em>]) for <em>i</em> = 1, 2, …, <em>m</em>. What is the running time of your algorithm?</p>
<p class="nl"><strong><em>b.</em></strong> For any pattern <em>P</em>[1:<em>m</em>], let <em>ρ</em>*(<em>P</em>) be defined as max {<em>ρ</em>(<em>P</em>[:<em>i</em>]) : 1 ≤ <em>i</em> ≤ <em>m</em>}. Prove that if the pattern <em>P</em> is chosen randomly from the set of all binary strings of length <em>m</em>, then the expected value of <em>ρ</em>*(<em>P</em>) is <em>O</em>(1).</p>
<p class="nl"><strong><em>c.</em></strong> Argue that the procedure R<small>EPETITION</small>-M<small>ATCHER</small> correctly finds all occurrences of pattern <em>P</em>[1:<em>m</em>] in text <em>T</em>[1:<em>n</em>] in <em>O</em>(<em>ρ</em>*(<em>P</em>)<em>n</em> + <em>m</em>) time. (This algorithm is due to Galil and Seiferas. By extending these ideas greatly, they obtained a linear-time string-matching algorithm that uses only <em>O</em>(1) storage beyond what is required for <em>P</em> and <em>T</em>.)</p>
<div class="pull-quote1">
<p class="box-heading">R<small>EPETITION</small>-M<small>ATCHER</small>(<em>T</em>, <em>P</em>, <em>n</em>, <em>m</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><em>k</em> = 1 + <em>ρ</em>*(<em>P</em>)</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><em>q</em> = 0</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><em>s</em> = 0</td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><strong>while</strong> <em>s</em> ≤ <em>n</em> – <em>m</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>T</em>[<em>s</em> + <em>q</em> + 1] == <em>P</em>[<em>q</em> + 1]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p3"><em>q</em> = <em>q</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>q</em> == <em>m</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="p4">print “Pattern occurs with shift” <em>s</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>q</em> == <em>m</em> or <em>T</em>[<em>s</em> + <em>q</em> + 1] ≠ <em>P</em>[<em>q</em> + 1]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="p3"><em>s</em> = <em>s</em> + max {1, <span class="font1">⌈</span><em>q</em>/<em>k</em><span class="font1">⌉</span>}</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><p class="p3"><em>q</em> = 0</p></td>
</tr>
</table>
</div>
<a id="p997"/>
</section>
<section title="32-2 A linear-time suffix-array algorithm">
<p class="level2"><strong><em>32-2     A linear-time suffix-array algorithm</em></strong></p>
<p class="noindent">In this problem, you will develop and analyze a linear-time divide-and-conquer algorithm to compute the suffix array of a text <em>T</em>[1:<em>n</em>]. As in <a href="chapter032.xhtml#Sec_32.5">Section 32.5</a>, assume that each character in the text is represented by an underlying encoding, which is a positive integer.</p>
<p>The idea behind the linear-time algorithm is to compute the suffix array for the suffixes starting at 2/3 of the positions in the text, recursing as needed, use the resulting information to sort the suffixes starting at the remaining 1/3 of the positions, and then merge the sorted information in linear time to produce the full suffix array.</p>
<p>For <em>i</em> = 1, 2, …, <em>n</em>, if <em>i</em> mod 3 equals 1 or 2, then <em>i</em> is a <span class="blue"><strong><em>sample position</em></strong></span>, and the suffixes starting at such positions are <span class="blue"><strong><em>sample suffixes</em></strong></span>. Positions 3, 6, 9, … are <span class="blue"><strong><em>nonsample positions</em></strong></span>, and the suffixes starting at <span class="blue"><strong><em>nonsample</em></strong></span> positions are <span class="blue"><strong><em>nonsample suffixes</em></strong></span>.</p>
<p>The algorithm sorts the sample suffixes, sorts the nonsample suffixes (aided by the result of sorting the sample suffixes), and merges the sorted sample and nonsample suffixes. Using the example text <em>T</em> = <span class="courierfont">bippityboppityboo</span>, here is the algorithm in detail, listing substeps of each of the above steps:</p>
<p class="nl-1list-1">1. The sample suffixes comprise about 2/3 of the suffixes. Sort them by the following substeps, which work with a heavily modified version of <em>T</em> and may require recursion. In part (a) of this problem on page 999, you will show that the orders of the suffixes of <em>T</em> and the suffixes of the modified version of <em>T</em> are the same.</p>
<p class="nl-2list">A. Construct two texts <em>P</em><sub>1</sub> and <em>P</em><sub>2</sub> made up of “metacharacters” that are actually substrings of three consecutive characters from <em>T</em>. We delimit each such metacharacter with parentheses. Construct</p>
<p class="eqnl1"><em>P</em><sub>1</sub> = (<em>T</em>[1:3])(<em>T</em>[4:6])(<em>T</em>[7:9]) <span class="font1">⋯</span> (<em>T</em>[<em>n</em>′:<em>n</em>′ + 2]),</p>
<p class="nl-2list-para">where <em>n</em>′ is the largest integer congruent to 1, modulo 3, that is less than or equal to <em>n</em> and <em>T</em> is extended beyond position <em>n</em> with the special character Ø, with encoding 0. With the example text <em>T</em> = <span class="courierfont">bippityboppityboo</span>, we get that</p>
<p class="eqnl1"><em>P</em><sub>1</sub> = (<span class="courierfont">bip</span>) (<span class="courierfont">pit</span>) (<span class="courierfont">ybo</span>) (<span class="courierfont">ppi</span>) (<span class="courierfont">tyb</span>) (<span class="courierfont">ooØ</span>).</p>
<p class="nl-2list-para">Similarly, construct</p>
<p class="eqnl1"><em>P</em><sub>2</sub> = (<em>T</em>[2:4])(<em>T</em>[5:7])(<em>T</em>[8:10]) <span class="font1">⋯</span> (<em>T</em>[<em>n</em>″:<em>n</em>″ + 2]),</p>
<p class="nl-2list-para">where <em>n</em>″ is the largest integer congruent to 2, modulo 3, that is less than or equal to <em>n</em>. For our example, we have</p>
<p class="eqnl1"><em>P</em><sub>2</sub> = (<span class="courierfont">ipp</span>) (<span class="courierfont">ity</span>) (<span class="courierfont">bop</span>) (<span class="courierfont">pit</span>) (<span class="courierfont">ybo</span>) (<span class="courierfont">oØØ</span>).</p>
<a id="p998"/>
<div class="divimage">
<p class="fig-img1" id="Fig_32-15"><img alt="art" class="width100" src="images/Art_P1323.jpg"/></p>
<p class="caption"><strong>Figure 32.15</strong> Computed values when sorting the sample suffixes of the linear-time suffix-array algorithm for the text <em>T</em> = <span class="courierfont">bippityboppityboo</span>.</p>
</div>
<p class="nl-2list-para">If <em>n</em> is a multiple of 3, append the metacharacter (ØØØ) to the end of <em>P</em><sub>1</sub>. In this way, <em>P</em><sub>1</sub> is guaranteed to end with a metacharacter containing Ø. (This property helps in part (a) of this problem.) The text <em>P</em><sub>2</sub> may or may not end with a metacharacter containing Ø.</p>
<p class="nl-2list">B. Concatenate <em>P</em><sub>1</sub> and <em>P</em><sub>2</sub> to form a new text <em>P</em>. <a href="chapter032.xhtml#Fig_32-15">Figure 32.15</a> shows <em>P</em> for our example, along with the corresponding positions of <em>T</em>.</p>
<p class="nl-2list">C. Sort and rank the unique metacharacters of <em>P</em>, with ranks starting from 1. In the example, <em>P</em> has 10 unique metacharacters: in sorted order, they are (<span class="courierfont">bip</span>), (<span class="courierfont">bop</span>), (<span class="courierfont">ipp</span>), (<span class="courierfont">ity</span>), (<span class="courierfont">oØØ</span>), (<span class="courierfont">ooØ</span>), (<span class="courierfont">pit</span>), (<span class="courierfont">ppi</span>), (<span class="courierfont">tyb</span>), (<span class="courierfont">ybo</span>). The metacharacters (<span class="courierfont">pit</span>) and (<span class="courierfont">ybo</span>) each appear twice.</p>
<p class="nl-2list">D. As <a href="chapter032.xhtml#Fig_32-15">Figure 32.15</a> shows, construct a new “text” <em>P</em>′ by renaming each metacharacter in <em>P</em> by its rank. If <em>P</em> contains <em>k</em> unique metacharacters, then each “character” in <em>P</em>′ is an integer from 1 to <em>k</em>. The suffix arrays for <em>P</em> and <em>P</em>′ are identical.</p>
<p class="nl-2list">E. Compute the suffix array <em>SA</em><sub><em>P</em>′</sub> of <em>P</em>′. If the characters of <em>P</em>′ (i.e., the ranks of metacharacters in <em>P</em>) are unique, then you can compute its suffix array directly, since the ordering of the individual characters gives the suffix array. Otherwise, recurse to compute the suffix array of <em>P</em>′, treating the ranks in <em>P</em>′ as the input characters in the recursive call. <a href="chapter032.xhtml#Fig_32-15">Figure 32.15</a> shows the suffix array <em>SA</em><sub><em>P</em>′</sub> for our example. Since the number of metacharacters in <em>P</em>, and hence the length of <em>P</em>′, is approximately 2<em>n</em>/3, this recursive subproblem is smaller than the current problem.</p>
<p class="nl-2list">F. From <em>SA</em><sub><em>P</em>′</sub> and the positions in <em>T</em> corresponding to the sample positions, compute the list of positions of the sorted sample suffixes of the original text <em>T</em>. <a href="chapter032.xhtml#Fig_32-15">Figure 32.15</a> shows the list of positions in <em>T</em> of the sorted sample suffixes in our example.</p>
<p class="nl-1list-1">2. The nonsample suffixes comprise about 1/3 of the suffixes. Using the sorted sample suffixes, sort the nonsample suffixes by the following substeps.</p>
<a id="p999"/>
<div class="divimage">
<p class="fig-img1" id="Fig_32-16"><img alt="art" src="images/Art_P1324.jpg"/></p>
<p class="caption"><strong>Figure 32.16</strong> The ranks <em>r</em><sub>1</sub> through <em>r</em><sub><em>n</em>+3</sub> for the text <em>T</em> = <span class="courierfont">bippityboppityboo</span> with <em>n</em> = 17.</p>
</div>
<p class="nl-2list">G. Extending the text <em>T</em> by the two special characters ØØ, so that <em>T</em> now has <em>n</em> + 2 characters, consider each suffix <em>T</em>[<em>i</em>:] for <em>i</em> = 1, 2, …, <em>n</em> + 2. Assign a rank <em>r</em><sub><em>i</em></sub> to each suffix <em>T</em>[<em>i</em>:]. For the two special characters ØØ, set <em>r</em><sub><em>n</em>+1</sub> = <em>r</em><sub><em>n</em>+2</sub> = 0. For the sample positions of <em>T</em>, base the rank on the list of sorted sample positions of <em>T</em>. The rank is currently undefined for the nonsample positions of <em>T</em>. For these positions, set <em>r</em><sub><em>i</em></sub> = <span class="font1">☐</span>. <a href="chapter032.xhtml#Fig_32-16">Figure 32.16</a> shows the ranks for <em>T</em> = <span class="courierfont">bippityboppityboo</span> with <em>n</em> = 17.</p>
<p class="nl-2list">H. Sort the nonsample suffixes by comparing tuples (<em>T</em>[<em>i</em>], <em>r</em><sub><em>i</em>+1</sub>). In our example, we get <em>T</em>[15:] &lt; <em>T</em>[12:] &lt; <em>T</em>[9:] &lt; <em>T</em>[3:] &lt; <em>T</em>[6:] because (<span class="courierfont">b</span>, 6) &lt; (<span class="courierfont">i</span>, 10) &lt; (<span class="courierfont">o</span>, 9) &lt; (<span class="courierfont">p</span>, 8) &lt; (<span class="courierfont">t</span>, 12).</p>
<p class="nl-1list-1">3. Merge the sorted sets of suffixes. From the sorted set of suffixes, determine the suffix array of <em>T</em>.</p>
<p class="noindent1-top">This completes the description of a linear-time algorithm for computing suffix arrays. The following parts of this problem ask you to show that certain steps of this algorithm are correct and to analyze the algorithm’s running time.</p>
<p class="nl"><strong><em>a.</em></strong> Define a <span class="blue"><strong><em>nonempty suffix</em></strong></span> at position <em>i</em> of the text <em>P</em> created in substep B as all metacharacters from position <em>i</em> of <em>P</em> up to and including the first metacharacter of <em>P</em> in which Ø appears or the end of <em>P</em>. In the example shown in <a href="chapter032.xhtml#Fig_32-15">Figure 32.15</a>, the nonempty suffixes of <em>P</em> starting at positions 1, 4, and 11 of <em>P</em> are (<span class="courierfont">bip</span>) (<span class="courierfont">pit</span>) (<span class="courierfont">ybo</span>) (<span class="courierfont">ppi</span>) (<span class="courierfont">tyb</span>) (<span class="courierfont">ooØ</span>), (<span class="courierfont">ppi</span>) (<span class="courierfont">tyb</span>) (<span class="courierfont">ooØ</span>), and (<span class="courierfont">ybo</span>) (<span class="courierfont">oØØ</span>), respectively. Prove that the order of suffixes of <em>P</em> is the same as the order of its nonempty suffixes. Conclude that the order of suffixes of <em>P</em> gives the order of the sample suffixes of <em>T</em>. (<em>Hint:</em> If <em>P</em> contains duplicate metacharacters, consider separately the cases in which two suffixes both start in <em>P</em><sub>1</sub>, both start in <em>P</em><sub>2</sub>, and one starts in <em>P</em><sub>1</sub> and the other starts in <em>P</em><sub>2</sub>. Use the property that Ø appears in the last metacharacter of <em>P</em><sub>1</sub>.)</p>
<p class="nl"><strong><em>b.</em></strong> Show how to perform substep C in Θ(<em>n</em>) time, bearing in mind that in a recursive call, the characters in <em>T</em> are actually ranks in <em>P</em>′ in the caller.</p>
<p class="nl"><strong><em>c.</em></strong> Argue that the tuples in substep H are unique. Then show how to perform this substep in Θ(<em>n</em>) time.<a id="p1000"/></p>
<p class="nl"><strong><em>d.</em></strong> Consider two suffixes <em>T</em>[<em>i</em>:] and <em>T</em>[<em>j</em>:], where <em>T</em>[<em>i</em>:] is a sample suffix and <em>T</em>[<em>j</em>:] is a nonsample suffix. Show how to determine in Θ(1) time whether <em>T</em>[<em>i</em>:] is lexicographically smaller than <em>T</em>[<em>j</em>:]. (<em>Hint:</em> Consider separately the cases in which <em>i</em> mod 3 = 1 and <em>i</em> mod 3 = 2. Compare tuples whose elements are characters in <em>T</em> and ranks as shown in <a href="chapter032.xhtml#Fig_32-16">Figure 32.16</a>. The number of elements per tuple may depend on whether <em>i</em> mod 3 equals 1 or 2.) Conclude that step 3 can be performed in Θ(<em>n</em>) time.</p>
<p class="nl"><strong><em>e.</em></strong> Justify the recurrence <em>T</em>(<em>n</em>) ≤ <em>T</em> (2<em>n</em>/3 + 2) + Θ(<em>n</em>) for the running time of the full algorithm, and show that its solution is <em>O</em>(<em>n</em>). Conclude that the algorithm runs in Θ(<em>n</em>) time.</p>
</section>
<section title="32-3 Burrows-Wheeler transform">
<p class="level2"><strong><em>32-3     Burrows-Wheeler transform</em></strong></p>
<p class="noindent">The <span class="blue"><strong><em>Burrows-Wheeler transform</em></strong></span>, or <span class="blue"><strong><em>BWT</em></strong></span>, for a text <em>T</em> is defined as follows. First, append a new character that compares as lexicographically less than every character of <em>T</em>, and denote this character by <span class="courierfont">$</span> and the resulting string by <em>T</em>′. Letting <em>n</em> be the length of <em>T</em>′, create <em>n</em> rows of characters, where each row is one of the <em>n</em> cyclic rotations of <em>T</em>′. Next, sort the rows lexicographically. The BWT is then the string of <em>n</em> characters in the rightmost column, read top to bottom.</p>
<p>For example, let <em>T</em> = <span class="courierfont">rutabaga</span>, so that <em>T</em>′ = <span class="courierfont">rutabaga$</span>. The cyclic rotations are</p>
<p class="noindent1-topa"><span class="courierfont">rutabaga$</span></p>
<p class="noindent"><span class="courierfont">utabaga$r</span></p>
<p class="noindent"><span class="courierfont">tabaga$ru</span></p>
<p class="noindent"><span class="courierfont">abaga$rut</span></p>
<p class="noindent"><span class="courierfont">baga$ruta</span></p>
<p class="noindent"><span class="courierfont">aga$rutab</span></p>
<p class="noindent"><span class="courierfont">ga$rutaba</span></p>
<p class="noindent"><span class="courierfont">a$rutabag</span></p>
<p class="noindent"><span class="courierfont">$rutabaga</span></p>
<p class="noindent1-topa">Sorting the rows and numbering the sorted rows gives</p>
<table class="table3">
<tr>
<td class="td1">1</td>
<td class="td1"><span class="courierfont">$rutabaga</span></td>
</tr>
<tr>
<td class="td1">2</td>
<td class="td1"><span class="courierfont">a$rutabag</span></td>
</tr>
<tr>
<td class="td1">3</td>
<td class="td1"><span class="courierfont">abaga$rut</span></td>
</tr>
<tr>
<td class="td1">4</td>
<td class="td1"><span class="courierfont">aga$rutab</span></td>
</tr>
<tr>
<td class="td1">5</td>
<td class="td1"><span class="courierfont">baga$ruta</span></td>
</tr>
<tr>
<td class="td1">6</td>
<td class="td1"><span class="courierfont">ga$rutaba</span></td>
</tr>
<tr>
<td class="td1">7</td>
<td class="td1"><span class="courierfont">rutabaga$</span></td>
</tr>
<tr>
<td class="td1">8</td>
<td class="td1"><span class="courierfont">tabaga$ru</span></td>
</tr>
<tr>
<td class="td1">9</td>
<td class="td1"><span class="courierfont">utabaga$r</span></td>
</tr>
</table>
<a id="p1001"/>
<p class="noindent">The BWT is the rightmost column, <span class="courierfont">agtbaa$ur</span>. (The row numbering will be helpful in understanding how to compute the inverse BWT.)</p>
<p>The BWT has applications in bioinformatics, and it can also be a step in text compression. That is because it tends to place identical characters together, as in the BWT of <span class="courierfont">rutabaga</span>, which places two of the instances of <span class="courierfont">a</span> together. When identical characters are placed together, or even nearby, additional means of compressing become available. Following the BWT, combinations of move-to-front encoding, run-length encoding, and Huffman coding (see <a href="chapter015.xhtml#Sec_15.3">Section 15.3</a>) can provide significant text compression. Compression ratios with the BWT tend improve as the text length increases.</p>
<p class="nl"><strong><em>a.</em></strong> Given the suffix array for <em>T</em>′, show how to compute the BWT in Θ(<em>n</em>) time.</p>
<p class="space-break">In order to decompress, the BWT must be invertible. Assuming that the alphabet size is constant, the inverse BWT can be computed in Θ(<em>n</em>) time from the BWT. Let’s look at the BWT of <span class="courierfont">rutabaga</span>, denoting it by <em>BWT</em>[1:<em>n</em>]. Each character in the BWT has a unique lexicographic rank from 1 to <em>n</em>. Denote the rank of <em>BWT</em>[<em>i</em>] by <em>rank</em>[<em>i</em>]. If a character appears multiple times in the BWT, each instance of the character has a rank 1 greater than the previous instance of the character. Here are <em>BWT</em> and <em>rank</em> for <span class="courierfont">rutabaga</span>:</p>
<p class="eql"><img alt="art" src="images/Art_P1324a.jpg"/></p>
<p class="noindent">For example, <em>rank</em>[1] = 2 because <em>BWT</em>[1] = <span class="courierfont">a</span> and the only character that precedes the first a lexicographically is <span class="courierfont">$</span> (which we defined to precede all other characters, so that <span class="courierfont">$</span> has rank 1). Next, we have <em>rank</em>[2] = 6 because <em>BWT</em>[2] = <span class="courierfont">g</span> and five characters in the BWT precede <span class="courierfont">g</span> lexicographically: <span class="courierfont">$</span>, the three instances of <span class="courierfont">a</span>, and <span class="courierfont">b</span>. Jumping ahead to <em>rank</em>[5] = 3, that is because <em>BWT</em>[5] = <span class="courierfont">a</span>, and because this <span class="courierfont">a</span> is the second instance of <span class="courierfont">a</span> in the BWT, its <em>rank</em> value is 1 greater than the <em>rank</em> value for the previous instance of <span class="courierfont">a</span>, in position 1.</p>
<p>There is enough information in <em>BWT</em> and <em>rank</em> to reconstruct <em>T</em>′ from back to front. Suppose that you know the rank <em>r</em> of a character <em>c</em> in <em>T</em>′. Then <em>c</em> is the first character in row <em>r</em> of the sorted cyclic rotations. The last character in row <em>r</em> must be the character that precedes <em>c</em> in <em>T</em>′. But you know which character is the last character in row <em>r</em>, because it is <em>BWT</em>[<em>r</em>]. To reconstruct <em>T</em>′ from back to front, start with <span class="courierfont">$</span>, which you can find in <em>BWT</em>. Then work backward using <em>BWT</em> and <em>rank</em> to reconstruct <em>T</em>′.</p>
<p>Let’s see how this strategy works for <span class="courierfont">rutabaga</span>. The last character of <em>T</em>′, <span class="courierfont">$</span>, appears in position 7 of <em>BWT</em>. Since <em>rank</em>[7] = 1, row 1 of the sorted cyclic rotations of <em>T</em>′ begins with <span class="courierfont">$</span>. The character that precedes <span class="courierfont">$</span> in <em>T</em>′ is the last character in row 1, which is <em>BWT</em>[1]: <span class="courierfont">a</span>. Now we know that the last two characters of <em>T</em>′ <a id="p1002"/>are <span class="courierfont">a$</span>. Looking up <em>rank</em>[1], it equals 2, so that row 2 of the sorted cyclic rotations of <em>T</em>′ begins with <span class="courierfont">a</span>. The last character in row 2 precedes a in <em>T</em>′, and that character is <em>BWT</em>[2] = <span class="courierfont">g</span>. Now we know that the last three characters of <em>T</em>′ are <span class="courierfont">ga$</span>. Continuing on, we have <em>rank</em>[2] = 6, so that row 6 of the sorted cyclic rotations begins with <span class="courierfont">g</span>. The character preceding <span class="courierfont">g</span> in <em>T</em>′ is <em>BWT</em>[6] = <span class="courierfont">a</span>, and so the last four characters of <em>T</em>′ are <span class="courierfont">aga$</span>. Because <em>rank</em>[6] = 4, <span class="courierfont">a</span> begins row 4 of the sorted cyclic rotations of <em>T</em>′. The character preceding <span class="courierfont">a</span> in <em>T</em>′ is the last character in row 4, <em>BWT</em>[4] = <span class="courierfont">b</span>, and the last five characters of <em>T</em>′ are <span class="courierfont">baga$</span>. And so on, until all <em>n</em> characters of <em>T</em>′ have been identified, from back to front.</p>
<p class="nl"><strong><em>b.</em></strong> Given the array <em>BWT</em>[1:<em>n</em>], write pseudcode to compute the array <em>rank</em>[1:<em>n</em>] in Θ(<em>n</em>) time, assuming that the alphabet size is constant.</p>
<p class="nl"><strong><em>c.</em></strong> Given the arrays <em>BWT</em>[1:<em>n</em>] and <em>rank</em>[1:<em>n</em>], write pseudocode to compute <em>T</em>′ in Θ(<em>n</em>) time.</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-193"><strong>Chapter notes</strong></p>
<p class="noindent">The relation of string matching to the theory of finite automata is discussed by Aho, Hopcroft, and Ullman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_5">5</a>]. The Knuth-Morris-Pratt algorithm [<a epub:type="noteref" href="bibliography001.xhtml#endnote_267">267</a>] was invented independently by Knuth and Pratt and by Morris, but they published their work jointly. Matiyasevich [<a epub:type="noteref" href="bibliography001.xhtml#endnote_317">317</a>] earlier discovered a similar algorithm, which applied only to an alphabet with two characters and was specified for a Turing machine with a two-dimensional tape. Reingold, Urban, and Gries [<a epub:type="noteref" href="bibliography001.xhtml#endnote_377">377</a>] give an alternative treatment of the Knuth-Morris-Pratt algorithm. The Rabin-Karp algorithm was proposed by Karp and Rabin [<a epub:type="noteref" href="bibliography001.xhtml#endnote_250">250</a>]. Galil and Seiferas [<a epub:type="noteref" href="bibliography001.xhtml#endnote_173">173</a>] give an interesting deterministic linear-time string-matching algorithm that uses only <em>O</em>(1) space beyond that required to store the pattern and text.</p>
<p>The suffix-array algorithm in <a href="chapter032.xhtml#Sec_32.5">Section 32.5</a> is by Manber and Myers [<a epub:type="noteref" href="bibliography001.xhtml#endnote_312">312</a>], who first proposed the notion of suffix arrays. The linear-time algorithm to compute the longest common prefix array presented here is by Kasai et al. [<a epub:type="noteref" href="bibliography001.xhtml#endnote_252">252</a>]. Problem 32-2 is based on the DC3 algorithm by Kärkkäinen, Sanders, and Burkhardt [<a epub:type="noteref" href="bibliography001.xhtml#endnote_245">245</a>]. For a survey of suffix-array algorithms, see the article by Puglisi, Smyth, and Turpin [<a epub:type="noteref" href="bibliography001.xhtml#endnote_370">370</a>]. To learn more about the Burrows-Wheeler transform from Problem 32-3, see the articles by Burrows and Wheeler [<a epub:type="noteref" href="bibliography001.xhtml#endnote_78">78</a>] and Manzini [<a epub:type="noteref" href="bibliography001.xhtml#endnote_314">314</a>].</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> For suffix arrays, the preprocessing time of <em>O</em>(<em>n</em> 1g <em>n</em>) comes from the algorithm presented in <a href="chapter032.xhtml#Sec_32.5">Section 32.5</a>. It can be reduced to Θ(<em>n</em>) by using the algorithm in Problem 32-2. The factor <em>k</em> in the matching time denotes the number of occurrences of the pattern in the text.</p>
<p class="footnote1" id="footnote_2"><a href="#footnote_ref_2"><sup>2</sup></a> We write Θ(<em>n</em> – <em>m</em> + 1) instead of Θ(<em>n</em> – <em>m</em>) because <em>s</em> takes on <em>n</em> − <em>m</em> + 1 different values. The “+1” is significant in an asymptotic sense because when <em>m</em> = <em>n</em>, computing the lone <em>t</em><sub><em>s</em></sub> value takes Θ(1) time, not Θ(0) time.</p>
<p class="footnote1" id="footnote_3"><a href="#footnote_ref_3"><sup>3</sup></a> Informally, lexicographic order is “alphabetical order” in the underlying character set. A more precise definition of lexicographic order appears in Problem 12-2 on page 327.</p>
<p class="footnote1" id="footnote_4"><a href="#footnote_ref_4"><sup>4</sup></a> Why keep saying “length at most”? Because for a given value of <em>l</em>, a substring of length <em>l</em> starting at position <em>i</em> is <em>T</em>[<em>i</em>:<em>i</em> + <em>l</em> – 1]. If <em>i</em> + <em>l</em> − 1 &gt; <em>n</em>, then the substring cuts off at the end of the text.</p>
</section>
</section>
</div>
</body>
</html>