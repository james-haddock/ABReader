<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p227"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="9 Medians and Order Statistics">
<p class="chapter-title"><a href="toc.xhtml#chap-9"><strong><span class="blue1">9          Medians and Order Statistics</span></strong></a></p>
<p class="noindent">The <em>i</em>th <strong><em><span class="blue1">order statistic</span></em></strong> of a set of <em>n</em> elements is the <em>i</em>th smallest element. For example, the <strong><em><span class="blue1">minimum</span></em></strong> of a set of elements is the first order statistic (<em>i</em> = 1), and the <strong><em><span class="blue1">maximum</span></em></strong> is the <em>n</em>th order statistic (<em>i</em> = <em>n</em>). A <strong><em><span class="blue1">median</span></em></strong>, informally, is the “halfway point” of the set. When <em>n</em> is odd, the median is unique, occurring at <em>i</em> = (<em>n</em> + 1)/2. When <em>n</em> is even, there are two medians, the <strong><em><span class="blue1">lower median</span></em></strong> occurring at <em>i</em> = <em>n</em>/2 and the <strong><em><span class="blue1">upper median</span></em></strong> occurring at <em>i</em> = <em>n</em>/2 + 1. Thus, regardless of the parity of <em>n</em>, medians occur at <em>i</em> = <span class="font1">⌊</span>(<em>n</em> + 1)/2<span class="font1">⌋</span> and <em>i</em> = <span class="font1">⌈</span>(<em>n</em> + 1)/2<span class="font1">⌉</span>. For simplicity in this text, however, we consistently use the phrase “the median” to refer to the lower median.</p>
<p>This chapter addresses the problem of selecting the <em>i</em>th order statistic from a set of <em>n</em> distinct numbers. We assume for convenience that the set contains distinct numbers, although virtually everything that we do extends to the situation in which a set contains repeated values. We formally specify the <strong><em><span class="blue1">selection problem</span></em></strong> as follows:</p>
<p class="para-hang1"><strong>Input:</strong> A set <em>A</em> of <em>n</em> distinct numbers<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup> and an integer <em>i</em>, with 1 ≤ <em>i</em> ≤ <em>n</em>.</p>
<p class="para-hang1"><strong>Output:</strong> The element <em>x</em> ∈ <em>A</em> that is larger than exactly <em>i</em> – 1 other elements of <em>A</em>.</p>
<p class="noindent1-top">We can solve the selection problem in <em>O</em>(<em>n</em> lg <em>n</em>) time simply by sorting the numbers using heapsort or merge sort and then outputting the <em>i</em>th element in the sorted array. This chapter presents asymptotically faster algorithms.</p>
<p><a href="chapter009.xhtml#Sec_9.1">Section 9.1</a> examines the problem of selecting the minimum and maximum of a set of elements. More interesting is the general selection problem, which we investigate in the subsequent two sections. <a href="chapter009.xhtml#Sec_9.2">Section 9.2</a> analyzes a practical randomized algorithm that achieves an <em>O</em>(<em>n</em>) expected running time, assuming distinct <a id="p228"/>elements. <a href="chapter009.xhtml#Sec_9.3">Section 9.3</a> contains an algorithm of more theoretical interest that achieves the <em>O</em>(<em>n</em>) running time in the worst case.</p>
<p class="line1"/>
<section title="9.1 Minimum and maximum">
<a id="Sec_9.1"/>
<p class="level1" id="h1-51"><a href="toc.xhtml#Rh1-51"><strong>9.1      Minimum and maximum</strong></a></p>
<p class="noindent">How many comparisons are necessary to determine the minimum of a set of <em>n</em> elements? To obtain an upper bound of <em>n</em> – 1 comparisons, just examine each element of the set in turn and keep track of the smallest element seen so far. The M<small>INIMUM</small> procedure assumes that the set resides in array <em>A</em>[1 : <em>n</em>].</p>
<div class="pull-quote1">
<p class="box-heading">M<small>INIMUM</small>(<em>A</em>, <em>n</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>min</em> = <em>A</em>[1]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>i</em> = 2 <strong>to</strong> <em>n</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>min</em> &gt; <em>A</em>[<em>i</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p3"><em>min</em> = <em>A</em>[<em>i</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>min</em></p></td>
</tr>
</table>
</div>
<p class="noindent">It’s no more difficult to find the maximum with <em>n</em> – 1 comparisons.</p>
<p>Is this algorithm for minimum the best we can do? Yes, because it turns out that there’s a lower bound of <em>n</em> – 1 comparisons for the problem of determining the minimum. Think of any algorithm that determines the minimum as a tournament among the elements. Each comparison is a match in the tournament in which the smaller of the two elements wins. Since every element except the winner must lose at least one match, we can conclude that <em>n</em> – 1 comparisons are necessary to determine the minimum. Hence the algorithm M<small>INIMUM</small> is optimal with respect to the number of comparisons performed.</p>
<p class="level4"><strong>Simultaneous minimum and maximum</strong></p>
<p class="noindent">Some applications need to find both the minimum and the maximum of a set of <em>n</em> elements. For example, a graphics program may need to scale a set of (<em>x</em>, <em>y</em>) data to fit onto a rectangular display screen or other graphical output device. To do so, the program must first determine the minimum and maximum value of each coordinate.</p>
<p>Of course, we can determine both the minimum and the maximum of <em>n</em> elements using Θ(<em>n</em>) comparisons. We simply find the minimum and maximum independently, using <em>n</em> – 1 comparisons for each, for a total of 2<em>n</em> – 2 = Θ(<em>n</em>) comparisons.</p>
<a id="p229"/>
<p>Although 2<em>n</em> – 2 comparisons is asymptotically optimal, it is possible to improve the leading constant. We can find both the minimum and the maximum using at most 3 <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> comparisons. The trick is to maintain both the minimum and maximum elements seen thus far. Rather than processing each element of the input by comparing it against the current minimum and maximum, at a cost of 2 comparisons per element, process elements in pairs. Compare pairs of elements from the input first <em>with each other</em>, and then compare the smaller with the current minimum and the larger to the current maximum, at a cost of 3 comparisons for every 2 elements.</p>
<p>How you set up initial values for the current minimum and maximum depends on whether <em>n</em> is odd or even. If <em>n</em> is odd, set both the minimum and maximum to the value of the first element, and then process the rest of the elements in pairs. If <em>n</em> is even, perform 1 comparison on the first 2 elements to determine the initial values of the minimum and maximum, and then process the rest of the elements in pairs as in the case for odd <em>n</em>.</p>
<p>Let’s count the total number of comparisons. If <em>n</em> is odd, then 3 <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> comparisons occur. If <em>n</em> is even, 1 initial comparison occurs, followed by another 3(<em>n</em> – 2)/2 comparisons, for a total of 3<em>n</em>/2 – 2. Thus, in either case, the total number of comparisons is at most 3 <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span>.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>9.1-1</em></strong></p>
<p class="noindent">Show that the second smallest of <em>n</em> elements can be found with <em>n</em> + <span class="font1">⌈</span>lg <em>n</em><span class="font1">⌉</span> – 2 comparisons in the worst case. (<em>Hint:</em> Also find the smallest element.)</p>
<p class="level3"><strong><em>9.1-2</em></strong></p>
<p class="noindent">Given <em>n</em> &gt; 2 distinct numbers, you want to find a number that is neither the minimum nor the maximum. What is the smallest number of comparisons that you need to perform?</p>
<p class="level3"><strong><em>9.1-3</em></strong></p>
<p class="noindent">A racetrack can run races with five horses at a time to determine their relative speeds. For 25 horses, it takes six races to determine the fastest horse, assuming transitivity (see page 1159). What’s the minimum number of races it takes to determine the fastest three horses out of 25?</p>
<p class="level3"><span class="font1">★</span> <strong><em>9.1-4</em></strong></p>
<p class="noindent">Prove the lower bound of <span class="font1">⌈</span>3<em>n</em>/2<span class="font1">⌉</span> – 2 comparisons in the worst case to find both the maximum and minimum of <em>n</em> numbers. (<em>Hint:</em> Consider how many numbers are potentially either the maximum or minimum, and investigate how a comparison affects these counts.)</p>
<a id="p230"/>
</section>
<p class="line1"/>
<section title="9.2 Selection in expected linear time">
<a id="Sec_9.2"/>
<p class="level1" id="h1-52"><a href="toc.xhtml#Rh1-52"><strong>9.2      Selection in expected linear time</strong></a></p>
<p class="noindent">The general selection problem—finding the <em>i</em>th order statistic for any value of <em>i</em>—appears more difficult than the simple problem of finding a minimum. Yet, surprisingly, the asymptotic running time for both problems is the same: Θ(<em>n</em>). This section presents a divide-and-conquer algorithm for the selection problem. The algorithm R<small>ANDOMIZED</small>-S<small>ELECT</small> is modeled after the quicksort algorithm of <a href="chapter007.xhtml">Chapter 7</a>. Like quicksort it partitions the input array recursively. But unlike quicksort, which recursively processes both sides of the partition, R<small>ANDOMIZED</small>-S<small>ELECT</small> works on only one side of the partition. This difference shows up in the analysis: whereas quicksort has an expected running time of Θ(<em>n</em> lg <em>n</em>), the expected running time of R<small>ANDOMIZED</small>-S<small>ELECT</small> is Θ(<em>n</em>), assuming that the elements are distinct.</p>
<p>R<small>ANDOMIZED</small>-S<small>ELECT</small> uses the procedure R<small>ANDOMIZED</small>-P<small>ARTITION</small> introduced in <a href="chapter007.xhtml#Sec_7.3">Section 7.3</a>. Like R<small>ANDOMIZED</small>-Q<small>UICKSORT</small>, it is a randomized algorithm, since its behavior is determined in part by the output of a random-number generator. The R<small>ANDOMIZED</small>-S<small>ELECT</small> procedure returns the <em>i</em>th smallest element of the array <em>A</em>[<em>p</em> : <em>r</em>], where 1 ≤ <em>i</em> ≤ <em>r</em> – <em>p</em> + 1.</p>
<div class="pull-quote1">
<p class="box-heading">R<small>ANDOMIZED</small>-S<small>ELECT</small>(<em>A</em>, <em>p</em>, <em>r</em>, <em>i</em>)</p>
<table class="table1a1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>if</strong> <em>p</em> == <em>r</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> <em>A</em>[<em>p</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> 1 ≤ <em>i</em> ≤ <em>r</em> – <em>p</em> + 1 when <em>p</em> == <em>r</em> means that <em>i</em> = 1</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><em>q</em> = R<small>ANDOMIZED</small>-P<small>ARTITION</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><em>k</em> = <em>q</em> – <em>p</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>if</strong> <em>i</em> == <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> <em>A</em>[<em>q</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> the pivot value is the answer</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>elseif</strong> <em>i</em> &lt; <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">8</span></p></td>
<td class="td1" colspan="2"><p class="p2"><strong>return</strong> R<small>ANDOMIZED</small>-S<small>ELECT</small>(<em>A</em>, <em>p</em>, <em>q</em> – 1, <em>i</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">9</span></p></td>
<td class="td1" colspan="2">
<p class="noindent"><strong>else return</strong> R<small>ANDOMIZED</small>-S<small>ELECT</small>(<em>A</em>, <em>q</em> + 1, <em>r</em>, <em>i</em> – <em>k</em>)</p></td>
</tr>
</table>
</div>
<p class="noindent"><a href="chapter009.xhtml#Fig_9-1">Figure 9.1</a> illustrates how the R<small>ANDOMIZED</small>-S<small>ELECT</small> procedure works. Line 1 checks for the base case of the recursion, in which the subarray <em>A</em>[<em>p</em> : <em>r</em>] consists of just one element. In this case, <em>i</em> must equal 1, and line 2 simply returns <em>A</em>[<em>p</em>] as the <em>i</em>th smallest element. Otherwise, the call to R<small>ANDOMIZED</small>-P<small>ARTITION</small> in line 3 partitions the array <em>A</em>[<em>p</em> : <em>r</em>] into two (possibly empty) subarrays <em>A</em>[<em>p</em> : <em>q</em> – 1] and <em>A</em>[<em>q</em> + 1 : <em>r</em>] such that each element of <em>A</em>[<em>p</em> : <em>q</em> – 1] is less than or equal to <em>A</em>[<em>q</em>], which in turn is less than each element of <em>A</em>[<em>q</em> + 1 : <em>r</em>]. (Although our analysis assumes that the elements are distinct, the procedure still yields the correct result even if equal elements are present.) As in quicksort, we’ll refer to <em>A</em>[<em>q</em>] as the <strong><em><span class="blue1">pivot</span></em></strong> element. Line 4 computes the number <em>k</em> of elements in the subarray <em>A</em>[<em>p</em> : <em>q</em>], that is, <a id="p231"/>the number of elements in the low side of the partition, plus 1 for the pivot element. Line 5 then checks whether <em>A</em>[<em>q</em>] is the <em>i</em>th smallest element. If it is, then line 6 returns <em>A</em>[<em>q</em>]. Otherwise, the algorithm determines in which of the two subarrays <em>A</em>[<em>p</em>: <em>q</em> – 1] and <em>A</em>[<em>q</em> + 1 : <em>r</em>] the <em>i</em>th smallest element lies. If <em>i</em> &lt; <em>k</em>, then the desired element lies on the low side of the partition, and line 8 recursively selects it from the subarray. If <em>i</em> &gt; <em>k</em>, however, then the desired element lies on the high side of the partition. Since we already know <em>k</em> values that are smaller than the <em>i</em>th smallest element of <em>A</em>[<em>p</em> : <em>r</em>]—namely, the elements of <em>A</em>[<em>p</em> : <em>q</em>]—the desired element is the (<em>i</em> – <em>k</em>)th smallest element of <em>A</em>[<em>q</em> + 1 : <em>r</em>], which line 9 finds recursively. The code appears to allow recursive calls to subarrays with 0 elements, but Exercise 9.2-1 asks you to show that this situation cannot happen.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_9-1"><img alt="art" class="width100" src="images/Art_P340.jpg"/></p>
<p class="caption"><strong>Figure 9.1</strong> The action of R<small>ANDOMIZED</small>-S<small>ELECT</small> as successive partitionings narrow the subarray <em>A</em>[<em>p</em>: <em>r</em>], showing the values of the parameters <em>p</em>, <em>r</em>, and <em>i</em> at each recursive call. The subarray <em>A</em>[<em>p</em> : <em>r</em>] in each recursive step is shown in tan, with the dark tan element selected as the pivot for the next partitioning. Blue elements are outside <em>A</em>[<em>p</em> : <em>r</em>]. The answer is the tan element in the bottom array, where <em>p</em> = <em>r</em> = 5 and <em>i</em> = 1. The array designations <em>A</em><sup>(0)</sup>, <em>A</em><sup>(1)</sup>, … , <em>A</em><sup>(5)</sup>, the partitioning numbers, and whether the partitioning is helpful are explained on the following page.</p>
</div>
<p>The worst-case running time for R<small>ANDOMIZED</small>-S<small>ELECT</small> is Θ(<em>n</em><sup>2</sup>), even to find the minimum, because it could be extremely unlucky and always partition around the largest remaining element before identifying the <em>i</em>th smallest when only one element remains. In this worst case, each recursive step removes only the pivot from consideration. Because partitioning <em>n</em> elements takes Θ(<em>n</em>) time, the recurrence for the worst-case running time is the same as for Q<small>UICKSORT</small>: <a id="p232"/><em>T</em> (<em>n</em>) = <em>T</em> (<em>n</em> – 1) + Θ(<em>n</em>), with the solution <em>T</em> (<em>n</em>) = Θ(<em>n</em><sup>2</sup>). We’ll see that the algorithm has a linear expected running time, however, and because it is randomized, no particular input elicits the worst-case behavior.</p>
<p>To see the intuition behind the linear expected running time, suppose that each time the algorithm randomly selects a pivot element, the pivot lies somewhere within the second and third quartiles—the “middle half”—of the remaining elements in sorted order. If the <em>i</em>th smallest element is less than the pivot, then all the elements greater than the pivot are ignored in all future recursive calls. These ignored elements include at least the uppermost quartile, and possibly more. Likewise, if the <em>i</em>th smallest element is greater than the pivot, then all the elements less than the pivot—at least the first quartile—are ignored in all future recursive calls. Either way, therefore, at least 1/4 of the remaining elements are ignored in all future recursive calls, leaving at most 3/4 of the remaining elements <strong><em><span class="blue1">in play</span></em></strong>: residing in the subarray <em>A</em>[<em>p</em> : <em>r</em>]. Since R<small>ANDOMIZED</small>-P<small>ARTITION</small> takes Θ(<em>n</em>) time on a subarray of <em>n</em> elements, the recurrence for the worst-case running time is <em>T</em> (<em>n</em>) = <em>T</em> (3<em>n</em>/4) + Θ(<em>n</em>). By case 3 of the master method (Theorem 4.1 on page 102), this recurrence has solution <em>T</em> (<em>n</em>) = Θ(<em>n</em>).</p>
<p>Of course, the pivot does not necessarily fall into the middle half every time. Since the pivot is selected at random, the probability that it falls into the middle half is about 1/2 each time. We can view the process of selecting the pivot as a Bernoulli trial (see <a href="appendix003.xhtml#Sec_C.4">Section C.4</a>) with success equating to the pivot residing in the middle half. Thus the expected number of trials needed for success is given by a geometric distribution: just two trials on average (equation (C.36) on page 1197). In other words, we expect that half of the partitionings reduce the number of elements still in play by at least 3/4 and that half of the partitionings do not help as much. Consequently, the expected number of partitionings at most doubles from the case when the pivot always falls into the middle half. The cost of each extra partitioning is less than the one that preceded it, so that the expected running time is still Θ(<em>n</em>).</p>
<p>To make the above argument rigorous, we start by defining the random variable <em>A</em><sup>(<em>j</em>)</sup> as the set of elements of <em>A</em> that are still in play after <em>j</em> partitionings (that is, within the subarray <em>A</em>[<em>p</em> : <em>r</em>] after <em>j</em> calls of R<small>ANDOMIZED</small>-S<small>ELECT</small>), so that <em>A</em><sup>(0)</sup> consists of all the elements in <em>A</em>. Since each partitioning removes at least one element—the pivot—from being in play, the sequence |<em>A</em><sup>(0)</sup>|, |<em>A</em><sup>(1)</sup>|, |<em>A</em><sup>(2)</sup>|, … strictly decreases. Set <em>A</em><sup>(<em>j</em>–1)</sup> is in play before the <em>j</em> th partitioning, and set <em>A</em><sup>(<em>j</em>)</sup> remains in play afterward. For convenience, assume that the initial set <em>A</em><sup>(0)</sup> is the result of a 0th “dummy” partitioning.</p>
<p>Let’s call the <em>j</em> th partitioning <strong><em><span class="blue1">helpful</span></em></strong> if |<em>A</em><sup>(<em>j</em>)</sup>| ≤ (3/4)|<em>A</em><sup>(<em>j</em>–1)</sup>|. <a href="chapter009.xhtml#Fig_9-1">Figure 9.1</a> shows the sets <em>A</em><sup>(<em>j</em>)</sup> and whether partitionings are helpful for an example array. A helpful partitioning corresponds to a successful Bernoulli trial. The following lemma shows that a partitioning is at least as likely to be helpful as not.</p>
<a id="p233"/>
<p class="lemma"><strong><em>Lemma 9.1</em></strong></p>
<p class="noindent">A partitioning is helpful with probability at least 1/2.</p>
<p class="proof"><strong><em>Proof</em></strong>   Whether a partitioning is helpful depends on the randomly chosen pivot. We discussed the “middle half” in the informal argument above. Let’s more precisely define the middle half of an <em>n</em>-element subarray as all but the smallest <span class="font1">⌈</span><em>n</em>/4<span class="font1">⌉</span> – 1 and greatest <span class="font1">⌈</span><em>n</em>/4<span class="font1">⌉</span> – 1 elements (that is, all but the first <span class="font1">⌈</span><em>n</em>/4<span class="font1">⌉</span> – 1 and last <span class="font1">⌈</span><em>n</em>/4<span class="font1">⌉</span> – 1 elements if the subarray were sorted). We’ll prove that if the pivot falls into the middle half, then the pivot leads to a helpful partitioning, and we’ll also prove that the probability of the pivot falling into the middle half is at least 1/2.</p>
<p>Regardless of where the pivot falls, either all the elements greater than it or all the elements less than it, along with the pivot itself, will no longer be in play after partitioning. If the pivot falls into the middle half, therefore, at least <span class="font1">⌈</span><em>n</em>/4<span class="font1">⌉</span> – 1 elements less than the pivot or <span class="font1">⌈</span><em>n</em>/4<span class="font1">⌉</span> – 1 elements greater than the pivot, plus the pivot, will no longer be in play after partitioning. That is, at least <span class="font1">⌈</span><em>n</em>/4<span class="font1">⌉</span> elements will no longer be in play. The number of elements remaining in play will be at most <em>n</em> – <span class="font1">⌈</span><em>n</em>/4<span class="font1">⌉</span>, which equals <span class="font1">⌊</span>3<em>n</em>/4<span class="font1">⌋</span> by Exercise 3.3-2 on page 70. Since <span class="font1">⌊</span>3<em>n</em>/4<span class="font1">⌋</span> ≤ 3<em>n</em>/4, the partitioning is helpful.</p>
<p>To determine a lower bound on the probability that a randomly chosen pivot falls into the middle half, we determine an upper bound on the probability that it does not. That probability is</p>
<p class="eql"><img alt="art" src="images/Art_P341.jpg"/></p>
<p class="noindent">Thus, the pivot has a probability of at least 1/2 of falling into the middle half, and so the probability is at least 1/2 that a partitioning is helpful.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">We can now bound the expected running time of R<small>ANDOMIZED</small>-S<small>ELECT</small>.</p>
<p class="theo"><strong><em>Theorem 9.2</em></strong></p>
<p class="noindent">The procedure R<small>ANDOMIZED</small>-S<small>ELECT</small> on an input array of <em>n</em> distinct elements has an expected running time of Θ(<em>n</em>).</p>
<p class="proof"><strong><em>Proof</em></strong>   Since not every partitioning is necessarily helpful, let’s give each partitioning an index starting at 0 and denote by <span class="font1">〈</span><em>h</em><sub>0</sub>, <em>h</em><sub>1</sub>, <em>h</em><sub>2</sub>, … , <em>h<sub>m</sub></em><span class="font1">〉</span> the sequence of partitionings that are helpful, so that the <em>h<sub>k</sub></em>th partitioning is helpful for <em>k</em> = 0, 1, 2, … , <em>m</em>. Although the number <em>m</em> of helpful partitionings is a random variable, <a id="p234"/>we can bound it, since after at most <span class="font1">⌈</span>log<sub>4/3</sub> <em>n</em><span class="font1">⌉</span> helpful partitionings, only one element remains in play. Consider the dummy 0th partitioning as helpful, so that <em>h</em><sub>0</sub> = 0. Denote <img alt="art" src="images/Art_P342.jpg"/> by <em>n<sub>k</sub></em>, where <em>n</em><sub>0</sub> = |<em>A</em><sup>(0)</sup>| is the original problem size. Since the <em>h<sub>k</sub></em>th partitioning is helpful and the sizes of the sets <em>A</em><sup>(<em>j</em>)</sup> strictly decrease, we have <img alt="art" src="images/Art_P343.jpg"/> for <em>k</em> = 1, 2, … , <em>m</em>. By iterating <em>n<sub>k</sub></em> ≤ (3/4) <em>n</em><sub><em>k</em>–1</sub>, we have that <em>n<sub>k</sub></em> ≤ (3/4)<em><sup>k</sup>n</em><sub>0</sub> for <em>k</em> = 0, 1, 2, … , <em>m</em>.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_9-2"><img alt="art" class="width100" src="images/Art_P344.jpg"/></p>
<p class="caption"><strong>Figure 9.2</strong> The sets within each generation in the proof of Theorem 9.2. Vertical lines represent the sets, with the height of each line indicating the size of the set, which equals the number of elements in play. Each generation starts with a set <img alt="art" src="images/ahk.jpg"/>, which is the result of a helpful partitioning. These sets are drawn in black and are at most 3/4 the size of the sets to their immediate left. Sets drawn in orange are not the first within a generation. A generation may contain just one set. The sets in generation <em>k</em> are <img alt="art" src="images/ahk.jpg"/>, <img alt="art" src="images/Art_P345.jpg"/>. The sets <img alt="art" src="images/ahk.jpg"/> are defined so that <img alt="art" src="images/Art_P346.jpg"/>. If the partitioning gets all the way to generation <em>h<sub>m</sub></em>, set <img alt="art" src="images/Art_P347.jpg"/> has at most one element in play.</p>
</div>
<p>As <a href="chapter009.xhtml#Fig_9-2">Figure 9.2</a> depicts, we break up the sequence of sets <em>A</em><sup>(<em>j</em>)</sup> into <em>m</em> <strong><em><span class="blue1">generations</span></em></strong> consisting of consecutively partitioned sets, starting with the result <img alt="art" src="images/ahk.jpg"/> of a helpful partitioning and ending with the last set <img alt="art" src="images/Art_P348.jpg"/> before the next helpful partitioning, so that the sets in generation <em>k</em> are <img alt="art" src="images/ahk.jpg"/>, <img alt="art" src="images/Art_P349.jpg"/>. Then for each set of elements <em>A</em><sup>(<em>j</em>)</sup> in the <em>k</em>th generation, we have that <img alt="art" src="images/Art_P350.jpg"/>.</p>
<p>Next, we define the random variable</p>
<p class="eql"><em>X<sub>k</sub></em> = <em>h</em><sub><em>k</em> + 1</sub> – <em>h<sub>k</sub></em></p>
<p class="noindent">for <em>k</em> = 0, 1, 2, … , <em>m</em> – 1. That is, <em>X<sub>k</sub></em> is the number of sets in the <em>k</em>th generation, so that the sets in the <em>k</em>th generation are <img alt="art" src="images/ahk.jpg"/>, <img alt="art" src="images/Art_P351.jpg"/>.</p>
<p>By Lemma 9.1, the probability that a partitioning is helpful is at least 1/2. The probability is actually even higher, since a partitioning is helpful even if the pivot <a id="p235"/>does not fall into the middle half but the <em>i</em>th smallest element happens to lie in the smaller side of the partitioning. We’ll just use the lower bound of 1/2, however, and then equation (C.36) gives that E [<em>X<sub>k</sub></em>] ≤ 2 for <em>k</em> = 0, 1, 2, … , <em>m</em> – 1.</p>
<p>Let’s derive an upper bound on how many comparisons are made altogether during partitioning, since the running time is dominated by the comparisons. Since we are calculating an upper bound, assume that the recursion goes all the way until only one element remains in play. The <em>j</em> th partitioning takes the set <em>A</em><sup>(<em>j</em>–1)</sup> of elements in play, and it compares the randomly chosen pivot with all the other |<em>A</em><sup>(<em>j</em>–1)</sup>| – 1 elements, so that the <em>j</em>th partitioning makes fewer than |<em>A</em><sup>(<em>j</em>–1)</sup>| comparisons. The sets in the <em>k</em>th generation have sizes <img alt="art" src="images/Art_P352.jpg"/>. Thus, the total number of comparisons during partitioning is less than</p>
<p class="eql"><img alt="art" src="images/Art_P354.jpg"/></p>
<p class="noindent">Since E [<em>X<sub>k</sub></em>] ≤ 2, we have that the expected total number of comparisons during partitioning is less than</p>
<p class="eql"><img alt="art" class="width100" src="images/Art_P355.jpg"/></p>
<p class="noindent">Since <em>n</em><sub>0</sub> is the size of the original array <em>A</em>, we conclude that the expected number of comparisons, and thus the expected running time, for R<small>ANDOMIZED</small>-S<small>ELECT</small> is <em>O</em>(<em>n</em>). All <em>n</em> elements are examined in the first call of R<small>ANDOMIZED</small>-P<small>ARTITION</small>, <a id="p236"/>giving a lower bound of Ω(<em>n</em>). Hence the expected running time is Θ(<em>n</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>9.2-1</em></strong></p>
<p class="noindent">Show that R<small>ANDOMIZED</small>-S<small>ELECT</small> never makes a recursive call to a 0-length array.</p>
<p class="level3"><strong><em>9.2-2</em></strong></p>
<p class="noindent">Write an iterative version of R<small>ANDOMIZED</small>-S<small>ELECT</small>.</p>
<p class="level3"><strong><em>9.2-3</em></strong></p>
<p class="noindent">Suppose that R<small>ANDOMIZED</small>-S<small>ELECT</small> is used to select the minimum element of the array <em>A</em> = <span class="font1">〈</span>2, 3, 0, 5, 7, 9, 1, 8, 6, 4<span class="font1">〉</span>. Describe a sequence of partitions that results in a worst-case performance of R<small>ANDOMIZED</small>-S<small>ELECT</small>.</p>
<p class="level3"><strong><em>9.2-4</em></strong></p>
<p class="noindent">Argue that the expected running time of R<small>ANDOMIZED</small>-S<small>ELECT</small> does not depend on the order of the elements in its input array <em>A</em>[<em>p</em> : <em>r</em>]. That is, the expected running time is the same for any permutation of the input array <em>A</em>[<em>p</em> : <em>r</em>]. (<em>Hint:</em> Argue by induction on the length <em>n</em> of the input array.)</p>
</section>
<p class="line1"/>
<section title="9.3 Selection in worst-case linear time">
<a id="Sec_9.3"/>
<p class="level1" id="h1-53"><a href="toc.xhtml#Rh1-53"><strong>9.3      Selection in worst-case linear time</strong></a></p>
<p class="noindent">We’ll now examine a remarkable and theoretically interesting selection algorithm whose running time is Θ(<em>n</em>) in the worst case. Although the R<small>ANDOMIZED</small>-S<small>ELECT</small> algorithm from <a href="chapter009.xhtml#Sec_9.2">Section 9.2</a> achieves linear expected time, we saw that its running time in the worst case was quadratic. The selection algorithm presented in this section achieves linear time in the worst case, but it is not nearly as practical as R<small>ANDOMIZED</small>-S<small>ELECT</small>. It is mostly of theoretical interest.</p>
<p>Like the expected linear-time R<small>ANDOMIZED</small>-S<small>ELECT</small>, the worst-case linear-time algorithm S<small>ELECT</small> finds the desired element by recursively partitioning the input array. Unlike R<small>ANDOMIZED</small>-S<small>ELECT</small>, however, S<small>ELECT</small> <em>guarantees</em> a good split by choosing a provably good pivot when partitioning the array. The cleverness in the algorithm is that it finds the pivot recursively. Thus, there are two invocations of S<small>ELECT</small>: one to find a good pivot, and a second to recursively find the desired order statistic.</p>
<p>The partitioning algorithm used by S<small>ELECT</small> is like the deterministic partitioning algorithm P<small>ARTITION</small> from quicksort (see <a href="chapter007.xhtml#Sec_7.1">Section 7.1</a>), but modified to take the element to partition around as an additional input parameter. Like P<small>ARTITION</small>, the <a id="p237"/>P<small>ARTITION</small>-A<small>ROUND</small> algorithm returns the index of the pivot. Since it’s so similar to P<small>ARTITION</small>, the pseudocode for P<small>ARTITION</small>-A<small>ROUND</small> is omitted.</p>
<p>The S<small>ELECT</small> procedure takes as input a subarray <em>A</em>[<em>p</em> : <em>r</em>] of <em>n</em> = <em>r</em> – <em>p</em> + 1 elements and an integer <em>i</em> in the range 1 ≤ <em>i</em> ≤ <em>n</em>. It returns the <em>i</em>th smallest element of <em>A</em>. The pseudocode is actually more understandable than it might appear at first.</p>
<div class="pull-quote1">
<p class="box-heading">S<small>ELECT</small>(<em>A</em>, <em>p</em>, <em>r</em>, <em>i</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> (<em>r</em> – <em>p</em> + 1) mod 5 ≠ 0</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="p2"><strong>for</strong> <em>j</em> = <em>p</em> + 1 <strong>to</strong> <em>r</em></p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> put the minimum into <em>A</em>[<em>p</em>]</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="p3"><strong>if</strong> <em>A</em>[<em>p</em>] &gt; <em>A</em>[<em>j</em>]</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="p4">exchange <em>A</em>[<em>p</em>] with <em>A</em>[<em>j</em>]</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1" colspan="2"><p class="p2"><span class="red"><strong>//</strong> If we want the minimum of <em>A</em>[<em>p</em> : <em>r</em>], we’re done.</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>i</em> == 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="p3"><strong>return</strong> <em>A</em>[<em>p</em>]</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1" colspan="2"><p class="p2"><span class="red"><strong>//</strong> Otherwise, we want the (<em>i</em> – 1)st element of <em>A</em>[<em>p</em> + 1 : <em>r</em>].</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="p2"><em>p</em> = <em>p</em> + 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><p class="p2"><em>i</em> = <em>i</em> – 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">11</span></p></td>
<td class="td1"><p class="noindent"><em>g</em> = (<em>r</em> – <em>p</em> + 1)/5</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> number of 5-element groups</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">12</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>j</em> = <em>p</em> <strong>to</strong> <em>p</em> + <em>g</em> – 1</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> sort each group</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">13</span></p></td>
<td class="td1" colspan="2"><p class="p2">sort <span class="font1">〈</span><em>A</em>[<em>j</em>], <em>A</em>[<em>j</em> + <em>g</em>], <em>A</em>[<em>j</em> + 2<em>g</em>], <em>A</em>[<em>j</em> + 3<em>g</em>], <em>A</em>[<em>j</em> + 4<em>g</em>]<span class="font1">〉</span> in place</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">14</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><span class="red"><strong>//</strong> All group medians now lie in the middle fifth of <em>A</em>[<em>p</em> : <em>r</em>].</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">15</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><span class="red"><strong>//</strong> Find the pivot <em>x</em> recursively as the median of the group medians.</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">16</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><em>x</em> = S<small>ELECT</small>(<em>A</em>, <em>p</em> + 2<em>g</em>, <em>p</em> + 3<em>g</em> – 1, <span class="font1">⌈</span><em>g</em>/2<span class="font1">⌉</span>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">17</span></p></td>
<td class="td1"><p class="noindent"><em>q</em> = P<small>ARTITION</small>-A<small>ROUND</small>(<em>A</em>, <em>p</em>, <em>r</em>, <em>x</em>)</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> partition around the pivot</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">18</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><span class="red"><strong>//</strong> The rest is just like lines 3–9 of R<small>ANDOMIZED</small>-S<small>ELECT</small>.</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">19</span></p></td>
<td class="td1"><p class="noindent"><em>k</em> = <em>q</em> – <em>p</em> + 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">20</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>i</em> == <em>k</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">21</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> <em>A</em>[<em>q</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> the pivot value is the answer</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">22</span></p></td>
<td class="td1"><p class="noindent"><strong>elseif</strong> <em>i</em> &lt; <em>k</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">23</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> S<small>ELECT</small>(<em>A</em>, <em>p</em>, <em>q</em> – 1, <em>i</em>)</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">24</span></p></td>
<td class="td1"><p class="noindent"><strong>else return</strong> S<small>ELECT</small>(<em>A</em>, <em>q</em> + 1, <em>r</em>, <em>i</em> – <em>k</em>)</p></td>
<td class="td1"/>
</tr>
</table>
</div>
<p>The pseudocode starts by executing the <strong>while</strong> loop in lines 1–10 to reduce the number <em>r</em> – <em>p</em> + 1 of elements in the subarray until it is divisible by 5. The <strong>while</strong> loop executes 0 to 4 times, each time rearranging the elements of <em>A</em>[<em>p</em> : <em>r</em>] so that <em>A</em>[<em>p</em>] contains the minimum element. If <em>i</em> = 1, which means that we actually want the minimum element, then the procedure simply returns it in line 7. Otherwise, S<small>ELECT</small> eliminates the minimum from the subarray <em>A</em>[<em>p</em> : <em>r</em>] and iterates to find the (<em>i</em> – 1)st element in <em>A</em>[<em>p</em> + 1 : <em>r</em>]. Lines 9–10 do so by incrementing <em>p</em> and decrementing <em>i</em>. If the <strong>while</strong> loop completes all of its iterations without returning a <a id="p238"/>result, the procedure executes the core of the algorithm in lines 11–24, assured that the number <em>r</em> – <em>p</em> + 1 of elements in <em>A</em>[<em>p</em> : <em>r</em>] is evenly divisible by 5.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_9-3"><img alt="art" src="images/Art_P356.jpg"/></p>
<p class="caption"><strong>Figure 9.3</strong> The relationships between elements (shown as circles) immediately after line 17 of the selection algorithm S<small>ELECT</small>. There are <em>g</em> = (<em>r</em> – <em>p</em> + 1)/5 groups of 5 elements, each of which occupies a column. For example, the leftmost column contains elements <em>A</em>[<em>p</em>], <em>A</em>[<em>p</em> + <em>g</em>], <em>A</em>[<em>p</em> + 2<em>g</em>], <em>A</em>[<em>p</em> + 3<em>g</em>], <em>A</em>[<em>p</em> + 4<em>g</em>], and the next column contains <em>A</em>[<em>p</em> + 1], <em>A</em>[<em>p</em> + <em>g</em> + 1], <em>A</em>[<em>p</em> + 2<em>g</em> + 1], <em>A</em>[<em>p</em> + 3<em>g</em> + 1], <em>A</em>[<em>p</em> + 4<em>g</em> + 1]. The medians of the groups are red, and the pivot <em>x</em> is labeled. Arrows go from smaller elements to larger. The elements on the blue background are all known to be less than or equal to <em>x</em> and cannot fall into the high side of the partition around <em>x</em>. The elements on the yellow background are known to be greater than or equal to <em>x</em> and cannot fall into the low side of the partition around <em>x</em>. The pivot <em>x</em> belongs to both the blue and yellow regions and is shown on a green background. The elements on the white background could lie on either side of the partition.</p>
</div>
<p>The next part of the algorithm implements the following idea, illustrated in <a href="chapter009.xhtml#Fig_9-3">Figure 9.3</a>. Divide the elements in <em>A</em>[<em>p</em> : <em>r</em>] into <em>g</em> = (<em>r</em> – <em>p</em> + 1)/5 groups of 5 elements each. The first 5-element group is</p>
<p class="eql"><span class="font1">〈</span><em>A</em>[<em>p</em>], <em>A</em>[<em>p</em> + <em>g</em>], <em>A</em>[<em>p</em> + 2<em>g</em>], <em>A</em>[<em>p</em> + 3<em>g</em>], <em>A</em>[<em>p</em> + 4<em>g</em>]<span class="font1">〉</span>,</p>
<p class="noindent">the second is</p>
<p class="eql"><span class="font1">〈</span><em>A</em>[<em>p</em> + 1], <em>A</em>[<em>p</em> + <em>g</em> + 1], <em>A</em>[<em>p</em> + 2<em>g</em> + 1], <em>A</em>[<em>p</em> + 3<em>g</em> + 1], <em>A</em>[<em>p</em> + 4<em>g</em> + 1]<span class="font1">〉</span>,</p>
<p class="noindent">and so forth until the last, which is</p>
<p class="eql"><span class="font1">〈</span><em>A</em>[<em>p</em> + <em>g</em> – 1], <em>A</em>[<em>p</em> + 2<em>g</em> – 1], <em>A</em>[<em>p</em> + 3<em>g</em> – 1], <em>A</em>[<em>p</em> + 4<em>g</em> – 1], <em>A</em>[<em>r</em>]<span class="font1">〉</span>.</p>
<p class="noindent1-top">(Note that <em>r</em> = <em>p</em> + 5<em>g</em> – 1.) Line 13 puts each group in order using, for example, insertion sort (<a href="chapter002.xhtml#Sec_2.1">Section 2.1</a>), so that for <em>j</em> = <em>p</em>, <em>p</em> + 1, … , <em>p</em> + <em>g</em> – 1, we have</p>
<a id="p239"/>
<p class="eql">A[<em>j</em>] ≤ <em>A</em>[<em>j</em> + <em>g</em>] ≤ <em>A</em>[<em>j</em> + 2<em>g</em>] ≤ <em>A</em>[<em>j</em> + 3<em>g</em>] ≤ <em>A</em>[<em>j</em> + 4<em>g</em>].</p>
<p class="noindent">Each vertical column in <a href="chapter009.xhtml#Fig_9-3">Figure 9.3</a> depicts a sorted group of 5 elements. The median of each 5-element group is <em>A</em>[<em>j</em> + 2<em>g</em>], and thus all the 5-element medians, shown in red, lie in the range <em>A</em>[<em>p</em> + 2<em>g</em> : <em>p</em> + 3<em>g</em> – 1].</p>
<p>Next, line 16 determines the pivot <em>x</em> by recursively calling S<small>ELECT</small> to find the median (specifically, the <span class="font1">⌈</span><em>g</em>/2<span class="font1">⌉</span>th smallest) of the <em>g</em> group medians. Line 17 uses the modified P<small>ARTITION</small>-A<small>ROUND</small> algorithm to partition the elements of <em>A</em>[<em>p</em> : <em>r</em>] around <em>x</em>, returning the index <em>q</em> of <em>x</em>, so that <em>A</em>[<em>q</em>] = <em>x</em>, elements in <em>A</em>[<em>p</em> : <em>q</em>] are all at most <em>x</em>, and elements in <em>A</em>[<em>q</em> : <em>r</em>] are greater than or equal to <em>x</em>.</p>
<p>The remainder of the code mirrors that of R<small>ANDOMIZED</small>-S<small>ELECT</small>. If the pivot <em>x</em> is the <em>i</em>th largest, the procedure returns it. Otherwise, the procedure recursively calls itself on either <em>A</em>[<em>p</em> : <em>q</em> – 1] or <em>A</em>[<em>q</em> + 1 : <em>r</em>], depending on the value of <em>i</em>.</p>
<p>Let’s analyze the running time of S<small>ELECT</small> and see how the judicious choice of the pivot <em>x</em> plays into a guarantee on its worst-case running time.</p>
<p class="theo"><strong><em>Theorem 9.3</em></strong></p>
<p class="noindent">The running time of S<small>ELECT</small> on an input of <em>n</em> elements is Θ(<em>n</em>).</p>
<p class="proof"><strong><em>Proof</em></strong>   Define <em>T</em> (<em>n</em>) as the worst-case time to run S<small>ELECT</small> on any input subarray <em>A</em>[<em>p</em> : <em>r</em>] of size at most <em>n</em>, that is, for which <em>r</em> – <em>p</em> + 1 ≤ <em>n</em>. By this definition, <em>T</em> (<em>n</em>) is monotonically increasing.</p>
<p>We first determine an upper bound on the time spent outside the recursive calls in lines 16, 23, and 24. The <strong>while</strong> loop in lines 1–10 executes 0 to 4 times, which is <em>O</em>(1) times. Since the dominant time within the loop is the computation of the minimum in lines 2–4, which takes Θ(<em>n</em>) time, lines 1–10 execute in <em>O</em>(1) · Θ(<em>n</em>) = <em>O</em>(<em>n</em>) time. The sorting of the 5-element groups in lines 12–13 takes Θ(<em>n</em>) time because each 5-element group takes Θ(1) time to sort (even using an asymptotically inefficient sorting algorithm such as insertion sort), and there are <em>g</em> elements to sort, where <em>n</em>/5 – 1 &lt; <em>g</em> ≤ <em>n</em>/5. Finally, the time to partition in line 17 is Θ(<em>n</em>), as Exercise 7.1-3 on page 187 asks you to show. Because the remaining bookkeeping only costs Θ(1) time, the total amount of time spent outside of the recursive calls is <em>O</em>(<em>n</em>) + Θ(<em>n</em>) + Θ(<em>n</em>) + Θ(1) = Θ(<em>n</em>).</p>
<p>Now let’s determine the running time for the recursive calls. The recursive call to find the pivot in line 16 takes <em>T</em> (<em>g</em>) ≤ <em>T</em> (<em>n</em>/5) time, since <em>g</em> ≤ <em>n</em>/5 and <em>T</em> (<em>n</em>) monotonically increases. Of the two recursive calls in lines 23 and 24, at most one is executed. But we’ll see that no matter which of these two recursive calls to S<small>ELECT</small> actually executes, the number of elements in the recursive call turns out to be at most 7<em>n</em>/10, and hence the worst-case cost for lines 23 and 24 is at most <em>T</em> (7<em>n</em>/10). Let’s now show that the machinations with group medians and the choice of the pivot <em>x</em> as the median of the group medians guarantees this property.</p>
<a id="p240"/>
<p><a href="chapter009.xhtml#Fig_9-3">Figure 9.3</a> helps to visualize what’s going on. There are <em>g</em> ≤ <em>n</em>/5 groups of 5 elements, with each group shown as a column sorted from bottom to top. The arrows show the ordering of elements within the columns. The columns are ordered from left to right with groups to the left of <em>x</em>’s group having a group median less than <em>x</em> and those to the right of <em>x</em>’s group having a group median greater than <em>x</em>. Although the relative order within each group matters, the relative order among groups to the left of <em>x</em>’s column doesn’t really matter, and neither does the relative order among groups to the right of <em>x</em>’s column. The important thing is that the groups to the left have group medians less than <em>x</em> (shown by the horizontal arrows entering <em>x</em>), and that the groups to the right have group medians greater than <em>x</em> (shown by the horizontal arrows leaving <em>x</em>). Thus, the yellow region contains elements that we know are greater than or equal to <em>x</em>, and the blue region contains elements that we know are less than or equal to <em>x</em>.</p>
<p>These two regions each contain at least 3<em>g</em>/2 elements. The number of group medians in the yellow region is <span class="font1">⌊</span><em>g</em>/2<span class="font1">⌋</span> + 1, and for each group median, two additional elements are greater than it, making a total of 3(<span class="font1">⌊</span><em>g</em>/2<span class="font1">⌋</span> + 1) ≥ 3<em>g</em>/2 elements. Similarly, the number of group medians in the blue region is <span class="font1">⌈</span><em>g</em>/2<span class="font1">⌉</span>, and for each group median, two additional elements are less than it, making a total of 3 <span class="font1">⌈</span><em>g</em>/2 <span class="font1">⌉</span> ≥ 3<em>g</em>/2.</p>
<p>The elements in the yellow region cannot fall into the low side of the partition around <em>x</em>, and those in the blue region cannot fall into the high side. The elements in neither region—those lying on a white background—could fall into either side of the partition. But since the low side of the partition excludes the elements in the yellow region, and there are a total of 5<em>g</em> elements, we know that the low side of the partition can contain at most 5<em>g</em> – 3<em>g</em>/2 = 7<em>g</em>/2 ≤ 7<em>n</em>/10 elements. Likewise, the high side of the partition excludes the elements in the blue region, and a similar calculation shows that it also contains at most 7<em>n</em>/10 elements.</p>
<p>All of which leads to the following recurrence for the worst-case running time of S<small>ELECT</small>:</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P357.jpg"/></p>
<p class="noindent">We can show that <em>T</em> (<em>n</em>) = <em>O</em>(<em>n</em>) by substitution.<sup><a epub:type="footnote" href="#footnote_2" id="footnote_ref_2">2</a></sup> More specifically, we’ll prove that <em>T</em> (<em>n</em>) ≤ <em>cn</em> for some suitably large constant <em>c</em> &gt; 0 and all <em>n</em> &gt; 0. Substituting this inductive hypothesis into the right-hand side of recurrence (9.1) and assuming that <em>n</em> ≥ 5 yields</p>
<a id="p241"/>
<table class="table2b">
<tr>
<td class="td2"><em>T</em> (<em>n</em>)</td>
<td class="td2">≤</td>
<td class="td2"><em>c</em>(<em>n</em>/5) + <em>c</em>(7<em>n</em>/10) + Θ(<em>n</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2">9<em>cn</em>/10 + Θ(<em>n</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>cn</em> – <em>cn</em>/10 + Θ(<em>n</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2"><em>cn</em></td>
</tr>
</table>
<p class="noindent">if <em>c</em> is chosen large enough that <em>c</em>/10 dominates the upper-bound constant hidden by the Θ(<em>n</em>). In addition to this constraint, we can pick <em>c</em> large enough that <em>T</em> (<em>n</em>) ≤ <em>cn</em> for all <em>n</em> ≤ 4, which is the base case of the recursion within S<small>ELECT</small>. The running time of S<small>ELECT</small> is therefore <em>O</em>(<em>n</em>) in the worst case, and because line 13 alone takes Θ(<em>n</em>) time, the total time is Θ(<em>n</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">As in a comparison sort (see <a href="chapter008.xhtml#Sec_8.1">Section 8.1</a>), S<small>ELECT</small> and R<small>ANDOMIZED</small>-S<small>ELECT</small> determine information about the relative order of elements only by comparing elements. Recall from <a href="chapter008.xhtml">Chapter 8</a> that sorting requires Ω(<em>n</em> lg <em>n</em>) time in the comparison model, even on average (see Problem 8-1). The linear-time sorting algorithms in <a href="chapter008.xhtml">Chapter 8</a> make assumptions about the type of the input. In contrast, the linear-time selection algorithms in this chapter do not require any assumptions about the input’s type, only that the elements are distinct and can be pairwise compared according to a linear order. The algorithms in this chapter are not subject to the Ω(<em>n</em> lg <em>n</em>) lower bound, because they manage to solve the selection problem without sorting all the elements. Thus, solving the selection problem by sorting and indexing, as presented in the introduction to this chapter, is asymptotically inefficient in the comparison model.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>9.3-1</em></strong></p>
<p class="noindent">In the algorithm S<small>ELECT</small>, the input elements are divided into groups of 5. Show that the algorithm works in linear time if the input elements are divided into groups of 7 instead of 5.</p>
<p class="level3"><strong><em>9.3-2</em></strong></p>
<p class="noindent">Suppose that the preprocessing in lines 1–10 of S<small>ELECT</small> is replaced by a base case for <em>n</em> ≥ <em>n</em><sub>0</sub>, where <em>n</em><sub>0</sub> is a suitable constant; that <em>g</em> is chosen as <span class="font1">⌊</span><em>r</em> – <em>p</em> + 1)/5<span class="font1">⌋</span>; and that the elements in <em>A</em>[5<em>g</em> : <em>n</em>] belong to no group. Show that although the recurrence for the running time becomes messier, it still solves to Θ(<em>n</em>).</p>
<p class="level3"><strong><em>9.3-3</em></strong></p>
<p class="noindent">Show how to use S<small>ELECT</small> as a subroutine to make quicksort run in <em>O</em>(<em>n</em> lg <em>n</em>) time in the worst case, assuming that all elements are distinct.</p>
<a id="p242"/>
<div class="divimage">
<p class="fig-imga" id="Fig_9-4"><img alt="art" src="images/Art_P358.jpg"/></p>
<p class="caption"><strong>Figure 9.4</strong> Professor Olay needs to determine the position of the east-west oil pipeline that minimizes the total length of the north-south spurs.</p>
</div>
<p class="level3"><span class="font1">★</span> <strong><em>9.3-4</em></strong></p>
<p class="noindent">Suppose that an algorithm uses only comparisons to find the <em>i</em>th smallest element in a set of <em>n</em> elements. Show that it can also find the <em>i</em> – 1 smaller elements and the <em>n</em> – <em>i</em> larger elements without performing any additional comparisons.</p>
<p class="level3"><strong><em>9.3-5</em></strong></p>
<p class="noindent">Show how to determine the median of a 5-element set using only 6 comparisons.</p>
<p class="level3"><strong><em>9.3-6</em></strong></p>
<p class="noindent">You have a “black-box” worst-case linear-time median subroutine. Give a simple, linear-time algorithm that solves the selection problem for an arbitrary order statistic.</p>
<p class="level3"><strong><em>9.3-7</em></strong></p>
<p class="noindent">Professor Olay is consulting for an oil company, which is planning a large pipeline running east to west through an oil field of <em>n</em> wells. The company wants to connect a spur pipeline from each well directly to the main pipeline along a shortest route (either north or south), as shown in <a href="chapter009.xhtml#Fig_9-4">Figure 9.4.</a> Given the <em>x</em>- and <em>y</em>-coordinates of the wells, how should the professor pick an optimal location of the main pipeline to minimize the total length of the spurs? Show how to determine an optimal location in linear time.</p>
<p class="level3"><strong><em>9.3-8</em></strong></p>
<p class="noindent">The <em>k</em>th <strong><em><span class="blue1">quantiles</span></em></strong> of an <em>n</em>-element set are the <em>k</em> – 1 order statistics that divide the sorted set into <em>k</em> equal-sized sets (to within 1). Give an <em>O</em>(<em>n</em> lg <em>k</em>)-time algorithm to list the <em>k</em>th quantiles of a set.</p>
<a id="p243"/>
<p class="level3"><strong><em>9.3-9</em></strong></p>
<p class="noindent">Describe an <em>O</em>(<em>n</em>)-time algorithm that, given a set <em>S</em> of <em>n</em> distinct numbers and a positive integer <em>k</em> ≤ <em>n</em>, determines the <em>k</em> numbers in <em>S</em> that are closest to the median of <em>S</em>.</p>
<p class="level3"><strong><em>9.3-10</em></strong></p>
<p class="noindent">Let <em>X</em>[1 : <em>n</em>] and <em>Y</em> [1 : <em>n</em>] be two arrays, each containing <em>n</em> numbers already in sorted order. Give an <em>O</em>(lg <em>n</em>)-time algorithm to find the median of all 2<em>n</em> elements in arrays <em>X</em> and <em>Y</em>. Assume that all 2<em>n</em> numbers are distinct.</p>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-54"><strong>Problems</strong></p>
<section title="9-1 Largest i numbers in sorted order">
<p class="level2"><strong><em>9-1     Largest i numbers in sorted order</em></strong></p>
<p class="noindent">You are given a set of <em>n</em> numbers, and you wish to find the <em>i</em> largest in sorted order using a comparison-based algorithm. Describe the algorithm that implements each of the following methods with the best asymptotic worst-case running time, and analyze the running times of the algorithms in terms of <em>n</em> and <em>i</em>.</p>
<p class="nl"><strong><em>a.</em></strong> Sort the numbers, and list the <em>i</em> largest.</p>
<p class="nl"><strong><em>b.</em></strong> Build a max-priority queue from the numbers, and call E<small>XTRACT</small>-M<small>AX</small> <em>i</em> times.</p>
<p class="nl"><strong><em>c.</em></strong> Use an order-statistic algorithm to find the <em>i</em>th largest number, partition around that number, and sort the <em>i</em> largest numbers.</p>
</section>
<section title="9-2 Variant of randomized selection">
<p class="level2"><strong><em>9-2     Variant of randomized selection</em></strong></p>
<p class="noindent">Professor Mendel has proposed simplifying R<small>ANDOMIZED</small>-S<small>ELECT</small> by eliminating the check for whether <em>i</em> and <em>k</em> are equal. The simplified procedure is S<small>IMPLER</small>-R<small>ANDOMIZED</small>-S<small>ELECT</small>.</p>
<div class="pull-quote1">
<p class="box-heading">S<small>IMPLER</small>-R<small>ANDOMIZED</small>-S<small>ELECT</small>(<em>A</em>, <em>p</em>, <em>r</em>, <em>i</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>if</strong> <em>p</em> == <em>r</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> <em>A</em>[<em>p</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> 1 ≤ <em>i</em> ≤ <em>r</em> – <em>p</em> + 1 means that <em>i</em> = 1</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><em>q</em> = R<small>ANDOMIZED</small>-P<small>ARTITION</small>(<em>A</em>, <em>p</em>, <em>r</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><em>k</em> = <em>q</em> – <em>p</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>if</strong> <em>i</em> ≤ <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1" colspan="2"><p class="p2"><strong>return</strong> S<small>IMPLER</small>-R<small>ANDOMIZED</small>-S<small>ELECT</small>(<em>A</em>, <em>p</em>, <em>q</em>, <em>i</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>else return</strong> S<small>IMPLER</small>-R<small>ANDOMIZED</small>-S<small>ELECT</small>(<em>A</em>, <em>q</em> + 1, <em>r</em>, <em>i</em> – <em>k</em>)</p></td>
</tr>
</table>
</div>
<a id="p244"/>
<p class="nl"><strong><em>a.</em></strong> Argue that in the worst case, S<small>IMPLER</small>-R<small>ANDOMIZED</small>-S<small>ELECT</small> never terminates.</p>
<p class="nl"><strong><em>b.</em></strong> Prove that the expected running time of S<small>IMPLER</small>-R<small>ANDOMIZED</small>-S<small>ELECT</small> is still <em>O</em>(<em>n</em>).</p>
</section>
<section title="9-3 Weighted median">
<p class="level2"><strong><em>9-3     Weighted median</em></strong></p>
<p class="noindent">Consider <em>n</em> elements <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, … , <em>x<sub>n</sub></em> with positive weights <em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, … , <em>w<sub>n</sub></em> such that <img alt="art" src="images/Art_P359.jpg"/>. The <strong><em><span class="blue1">weighted (lower) median</span></em></strong> is an element <em>x<sub>k</sub></em> satisfying</p>
<p class="eql"><img alt="art" src="images/Art_P360.jpg"/></p>
<p class="noindent">and</p>
<p class="eql"><img alt="art" src="images/Art_P361.jpg"/></p>
<p class="noindent">For example, consider the following elements <em>x<sub>i</sub></em> and weights <em>w<sub>i</sub></em>:</p>
<table class="table1b">
<tr>
<td class="th2"><p class="noindent"><em>i</em></p></td>
<td class="th1"><p class="center">1</p></td>
<td class="th1"><p class="center">2</p></td>
<td class="th1"><p class="center">3</p></td>
<td class="th1"><p class="center">4</p></td>
<td class="th1"><p class="center">5</p></td>
<td class="th1"><p class="center">6</p></td>
<td class="th1"><p class="center">7</p></td>
</tr>
<tr>
<td class="td1r"><p class="noindent"><em>x<sub>i</sub></em></p></td>
<td class="td1"><p class="center">3</p></td>
<td class="td1"><p class="center">8</p></td>
<td class="td1"><p class="center">2</p></td>
<td class="td1"><p class="center">5</p></td>
<td class="td1"><p class="center">4</p></td>
<td class="td1"><p class="center">1</p></td>
<td class="td1"><p class="center">6</p></td>
</tr>
<tr>
<td class="td1r"><p class="noindent"><em>w<sub>i</sub></em></p></td>
<td class="td1"><p class="center">0.12</p></td>
<td class="td1"><p class="center">0.35</p></td>
<td class="td1"><p class="center">0.025</p></td>
<td class="td1"><p class="center">0.08</p></td>
<td class="td1"><p class="center">0.15</p></td>
<td class="td1"><p class="center">0.075</p></td>
<td class="td1"><p class="center">0.2</p></td>
</tr>
</table>
<p class="noindent">For these elements, the median is <em>x</em><sub>5</sub> = 4, but the weighted median is <em>x</em><sub>7</sub> = 6. To see why the weighted median is <em>x</em><sub>7</sub>, observe that the elements less than <em>x</em><sub>7</sub> are <em>x</em><sub>1</sub>, <em>x</em><sub>3</sub>, <em>x</em><sub>4</sub>, <em>x</em><sub>5</sub>, and <em>x</em><sub>6</sub>, and the sum <em>w</em><sub>1</sub> + <em>w</em><sub>3</sub> + <em>w</em><sub>4</sub> + <em>w</em><sub>5</sub> + <em>w</em><sub>6</sub> = 0.45, which is less than 1/2. Furthermore, only element <em>x</em><sub>2</sub> is greater than <em>x</em><sub>7</sub>, and <em>w</em><sub>2</sub> = 0.35, which is no greater than 1/2.</p>
<p class="nl"><strong><em>a.</em></strong> Argue that the median of <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, … , <em>x<sub>n</sub></em> is the weighted median of the <em>x<sub>i</sub></em> with weights <em>w<sub>i</sub></em> = 1/<em>n</em> for <em>i</em> = 1, 2, … , <em>n</em>.</p>
<p class="nl"><strong><em>b.</em></strong> Show how to compute the weighted median of <em>n</em> elements in <em>O</em>(<em>n</em> lg <em>n</em>) worst-case time using sorting.</p>
<p class="nl"><strong><em>c.</em></strong> Show how to compute the weighted median in Θ(<em>n</em>) worst-case time using a linear-time median algorithm such as S<small>ELECT</small> from <a href="chapter009.xhtml#Sec_9.3">Section 9.3</a>.</p>
<p class="noindent1-top">The <strong><em><span class="blue1">post-office location problem</span></em></strong> is defined as follows. The input is <em>n</em> points <em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, … , <em>p<sub>n</sub></em> with associated weights <em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, … , <em>w<sub>n</sub></em>. A solution is a point <em>p</em> (not necessarily one of the input points) that minimizes the sum <img alt="art" src="images/Art_P362.jpg"/>, where <em>d</em>(<em>a</em>, <em>b</em>) is the distance between points <em>a</em> and <em>b</em>.</p>
<a id="p245"/>
<p class="nl"><strong><em>d.</em></strong> Argue that the weighted median is a best solution for the one-dimensional post-office location problem, in which points are simply real numbers and the distance between points <em>a</em> and <em>b</em> is <em>d</em>(<em>a</em>, <em>b</em>) = |<em>a</em> – <em>b</em>|.</p>
<p class="nl"><strong><em>e.</em></strong> Find the best solution for the two-dimensional post-office location problem, in which the points are (<em>x</em>, <em>y</em>) coordinate pairs and the distance between points <em>a</em> = (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>) and <em>b</em> = (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>) is the <strong><em><span class="blue1">Manhattan distance</span></em></strong> given by <em>d</em>(<em>a</em>, <em>b</em>) = |<em>x</em><sub>1</sub> – <em>x</em><sub>2</sub>| + |<em>y</em><sub>1</sub> – <em>y</em><sub>2</sub>|.</p>
</section>
<section title="9-4 Small order statistics">
<p class="level2"><strong><em>9-4     Small order statistics</em></strong></p>
<p class="noindent">Let’s denote by <em>S</em>(<em>n</em>) the worst-case number of comparisons used by S<small>ELECT</small> to select the <em>i</em>th order statistic from <em>n</em> numbers. Although <em>S</em>(<em>n</em>) = Θ(<em>n</em>), the constant hidden by the Θ-notation is rather large. When <em>i</em> is small relative to <em>n</em>, there is an algorithm that uses S<small>ELECT</small> as a subroutine but makes fewer comparisons in the worst case.</p>
<p class="nl"><strong><em>a.</em></strong> Describe an algorithm that uses <em>U<sub>i</sub></em>(<em>n</em>) comparisons to find the <em>i</em>th smallest of <em>n</em> elements, where</p>
<p class="nl-parat"><img alt="art" src="images/Art_P363.jpg"/></p>
<p class="nl-para">(<em>Hint:</em> Begin with <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> disjoint pairwise comparisons, and recurse on the set containing the smaller element from each pair.)</p>
<p class="nl"><strong><em>b.</em></strong> Show that, if <em>i</em> &lt; <em>n</em>/2, then <em>U<sub>i</sub></em>(<em>n</em>) = <em>n</em> + <em>O</em>(<em>S</em>(2<em>i</em>) lg(<em>n</em>/<em>i</em>)).</p>
<p class="nl"><strong><em>c.</em></strong> Show that if <em>i</em> is a constant less than <em>n</em>/2, then <em>U<sub>i</sub></em>(<em>n</em>) = <em>n</em> + <em>O</em>(lg <em>n</em>).</p>
<p class="nl"><strong><em>d.</em></strong> Show that if <em>i</em> = <em>n</em>/<em>k</em> for <em>k</em> ≥ 2, then <em>U<sub>i</sub></em>(<em>n</em>) = <em>n</em> + <em>O</em>(<em>S</em>(2<em>n</em>/<em>k</em>) lg <em>k</em>).</p>
</section>
<section title="9-5 Alternative analysis of randomized selection">
<p class="level2"><strong><em>9-5     Alternative analysis of randomized selection</em></strong></p>
<p class="noindent">In this problem, you will use indicator random variables to analyze the procedure R<small>ANDOMIZED</small>-S<small>ELECT</small> in a manner akin to our analysis of R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> in <a href="chapter007.xhtml#Sec_7.4.2">Section 7.4.2</a>.</p>
<p>As in the quicksort analysis, we assume that all elements are distinct, and we rename the elements of the input array <em>A</em> as <em>z</em><sub>1</sub>, <em>z</em><sub>2</sub>, … , <em>z<sub>n</sub></em>, where <em>z<sub>i</sub></em> is the <em>i</em>th smallest element. Thus the call R<small>ANDOMIZED</small>-S<small>ELECT</small>(<em>A</em>, 1, <em>n</em>, <em>i</em>) returns <em>z<sub>i</sub></em>.</p>
<p>For 1 ≤ <em>j</em> &lt; <em>k</em> ≤ <em>n</em>, let</p>
<table class="table2b">
<tr>
<td class="td2"><em>X<sub>ijk</sub></em></td>
<td class="td2">=</td>
<td class="td2">I {<em>z<sub>j</sub></em> is compared with <em>z<sub>k</sub></em> sometime during the execution of the algorithm to find <em>z<sub>i</sub></em>}.</td>
</tr>
</table>
<a id="p246"/>
<p class="nl"><strong><em>a.</em></strong> Give an exact expression for E [<em>X<sub>ijk</sub></em>]. (<em>Hint:</em> Your expression may have different values, depending on the values of <em>i</em>, <em>j</em>, and <em>k</em>.)</p>
<p class="nl"><strong><em>b.</em></strong> Let <em>X<sub>i</sub></em> denote the total number of comparisons between elements of array <em>A</em> when finding <em>z<sub>i</sub></em>. Show that</p>
<p class="nl-parat"><img alt="art" src="images/Art_P364.jpg"/></p>
<p class="nl"><strong><em>c.</em></strong> Show that E [<em>X<sub>i</sub></em>] ≤ 4<em>n</em>.</p>
<p class="nl"><strong><em>d.</em></strong> Conclude that, assuming all elements of array <em>A</em> are distinct, R<small>ANDOMIZED</small>-S<small>ELECT</small> runs in <em>O</em>(<em>n</em>) expected time.</p>
</section>
<section title="9-6 Select with groups of 3">
<p class="level2"><strong><em>9-6     Select with groups of 3</em></strong></p>
<p class="noindent">Exercise 9.3-1 asks you to show that the S<small>ELECT</small> algorithm still runs in linear time if the elements are divided into groups of 7. This problem asks about dividing into groups of 3.</p>
<p class="nl"><strong><em>a.</em></strong> Show that S<small>ELECT</small> runs in linear time if you divide the elements into groups whose size is any odd constant greater than 3.</p>
<p class="nl"><strong><em>b.</em></strong> Show that S<small>ELECT</small> runs in <em>O</em>(<em>n</em> lg <em>n</em>) time if you divide the elements into groups of size 3.</p>
<p class="space-break">Because the bound in part (b) is just an upper bound, we do not know whether the groups-of-3 strategy actually runs in <em>O</em>(<em>n</em>) time. But by repeating the groups-of-3 idea on the middle group of medians, we can pick a pivot that guarantees <em>O</em>(<em>n</em>) time. The S<small>ELECT</small>3 algorithm on the next page determines the <em>i</em>th smallest of an input array of <em>n</em> &gt; 1 distinct elements.</p>
<p class="nl"><strong><em>c.</em></strong> Describe in English how the S<small>ELECT</small>3 algorithm works. Include in your description one or more suitable diagrams.</p>
<p class="nl"><strong><em>d.</em></strong> Show that S<small>ELECT</small>3 runs in <em>O</em>(<em>n</em>) time in the worst case.</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-55"><strong>Chapter notes</strong></p>
<p class="noindent">The worst-case linear-time median-finding algorithm was devised by Blum, Floyd, Pratt, Rivest, and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_62">62</a>]. The fast randomized version is due to Hoare [<a epub:type="noteref" href="bibliography001.xhtml#endnote_218">218</a>]. Floyd and Rivest [<a epub:type="noteref" href="bibliography001.xhtml#endnote_147">147</a>] have developed an improved randomized version that partitions around an element recursively selected from a small sample of the elements.</p>
<a id="p247"/>
<div class="pull-quote1">
<p class="box-heading">S<small>ELECT</small>3(<em>A</em>, <em>p</em>, <em>r</em>, <em>i</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>while</strong> (<em>r</em> – <em>p</em> + 1) mod 9 ≠ 0</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="p2"><strong>for</strong> <em>j</em> = <em>p</em> + 1 <strong>to</strong> <em>r</em></p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> put the minimum into <em>A</em>[<em>p</em>]</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1" colspan="2"><p class="p3"><strong>if</strong> <em>A</em>[<em>p</em>] &gt; <em>A</em>[<em>j</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1" colspan="2"><p class="p4">exchange <em>A</em>[<em>p</em>] with <em>A</em>[<em>j</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1" colspan="2"><p class="p2"><span class="red"><strong>//</strong> If we want the minimum of <em>A</em>[<em>p</em> : <em>r</em>], we’re done.</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1" colspan="2"><p class="p2"><strong>if</strong> <em>i</em> == 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1" colspan="2"><p class="p3"><strong>return</strong> <em>A</em>[<em>p</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1" colspan="2"><p class="p2"><span class="red"><strong>//</strong> Otherwise, we want the (<em>i</em> – 1)st element of <em>A</em>[<em>p</em> + 1 : <em>r</em>].</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1" colspan="2"><p class="p2"><em>p</em> = <em>p</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1" colspan="2"><p class="p2"><em>i</em> = <em>i</em> – 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">11</span></p></td>
<td class="td1"><p class="noindent"><em>g</em> = (<em>r</em> – <em>p</em> + 1)/3</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> number of 3-element groups</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">12</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>j</em> = <em>p</em> <strong>to</strong> <em>p</em> + <em>g</em> – 1</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> run through the groups</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">13</span></p></td>
<td class="td1" colspan="2"><p class="p2">sort <span class="font1">〈</span><em>A</em>[<em>j</em>], <em>A</em>[<em>j</em> + <em>g</em>], <em>A</em>[<em>j</em> + 2<em>g</em>]<span class="font1">〉</span> in place</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">14</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><span class="red"><strong>//</strong> All group medians now lie in the middle third of <em>A</em>[<em>p</em> : <em>r</em>].</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">15</span></p></td>
<td class="td1"><p class="noindent"><em>g′</em> = <em>g</em>/3</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> number of 3-element subgroups</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">16</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>j</em> = <em>p</em> + <em>g</em> <strong>to</strong> <em>p</em> + <em>g</em> + <em>g′</em> – 1</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> sort the subgroups</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">17</span></p></td>
<td class="td1" colspan="2"><p class="p2">sort <span class="font1">〈</span><em>A</em>[<em>j</em>], <em>A</em>[<em>j</em> + <em>g′</em>], <em>A</em>[<em>j</em> + 2<em>g′</em>]<span class="font1">〉</span> in place</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">18</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><span class="red"><strong>//</strong> All subgroup medians now lie in the middle ninth of <em>A</em>[<em>p</em> : <em>r</em>].</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">19</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><span class="red"><strong>//</strong> Find the pivot <em>x</em> recursively as the median of the subgroup medians.</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">20</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><em>x</em> = S<small>ELECT</small>3(<em>A</em>, <em>p</em> + 4<em>g′</em>, <em>p</em> + 5<em>g′</em> – 1, <span class="font1">⌈</span><em>g′</em>/2<span class="font1">⌉</span>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">21</span></p></td>
<td class="td1"><p class="noindent"><em>q</em> = P<small>ARTITION</small>-A<small>ROUND</small>(<em>A</em>, <em>p</em>, <em>r</em>, <em>x</em>)</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> partition around the pivot</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">22</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><span class="red"><strong>//</strong> The rest is just like lines 19–24 of S<small>ELECT</small>.</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">23</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><em>k</em> = <em>q</em> – <em>p</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">24</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>if</strong> <em>i</em> == <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">25</span></p></td>
<td class="td1"><p class="p2"><strong>return</strong> <em>A</em>[<em>q</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red"><strong>//</strong> the pivot value is the answer</span></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">26</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>elseif</strong> <em>i</em> &lt; <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">27</span></p></td>
<td class="td1" colspan="2"><p class="p2"><strong>return</strong> S<small>ELECT</small>3(<em>A</em>, <em>p</em>, <em>q</em> – 1, <em>i</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">28</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>else return</strong> S<small>ELECT</small>3(<em>A</em>, <em>q</em> + 1, <em>r</em>, <em>i</em> – <em>k</em>)</p></td>
</tr>
</table>
</div>
<p>It is still unknown exactly how many comparisons are needed to determine the median. Bent and John [<a epub:type="noteref" href="bibliography001.xhtml#endnote_48">48</a>] gave a lower bound of 2<em>n</em> comparisons for median finding, and Schönhage, Paterson, and Pippenger [<a epub:type="noteref" href="bibliography001.xhtml#endnote_397">397</a>] gave an upper bound of 3<em>n</em>. Dor and Zwick have improved on both of these bounds. Their upper bound [<a epub:type="noteref" href="bibliography001.xhtml#endnote_123">123</a>] is slightly less than 2.95<em>n</em>, and their lower bound [<a epub:type="noteref" href="bibliography001.xhtml#endnote_124">124</a>] is (2 + <em><span class="font1">ϵ</span></em>)<em>n</em>, for a small positive constant <em><span class="font1">ϵ</span></em>, thereby improving slightly on related work by Dor et al. [<a epub:type="noteref" href="bibliography001.xhtml#endnote_122">122</a>]. Paterson [<a epub:type="noteref" href="bibliography001.xhtml#endnote_354">354</a>] describes some of these results along with other related work.</p>
<p>Problem 9-6 was inspired by a paper by Chen and Dumitrescu [<a epub:type="noteref" href="bibliography001.xhtml#endnote_84">84</a>].</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> As in the footnote on page 182, you can enforce the assumption that the numbers are distinct by converting each input value <em>A</em>[<em>i</em>] to an ordered pair (<em>A</em>[<em>i</em>], <em>i</em>) with (<em>A</em>[<em>i</em>], <em>i</em>) &lt; (<em>A</em>[<em>j</em>], <em>j</em>) if either <em>A</em>[<em>i</em>] &lt; <em>A</em>[<em>j</em>] or <em>A</em>[<em>i</em>] = <em>A</em>[<em>j</em>] and <em>i</em> &lt; <em>j</em>.</p>
<p class="footnote1" id="footnote_2"><a href="#footnote_ref_2"><sup>2</sup></a> We could also use the Akra-Bazzi method from <a href="chapter004.xhtml#Sec_4.7">Section 4.7</a>, which involves calculus, to solve this recurrence. Indeed, a similar recurrence (4.24) on page 117 was used to illustrate that method.</p>
</section>
</section>
</div>
</body>
</html>