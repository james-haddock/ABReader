<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p604"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="22 Single-Source Shortest Paths">
<p class="chapter-title"><a href="toc.xhtml#chap-22"><strong><span class="blue1">22        Single-Source Shortest Paths</span></strong></a></p>
<p class="noindent">Suppose that you need to drive from Oceanside, New York, to Oceanside, California, by the shortest possible route. Your GPS contains information about the entire road network of the United States, including the road distance between each pair of adjacent intersections. How can your GPS determine this shortest route?</p>
<p class="noindent">One possible way is to enumerate all the routes from Oceanside, New York, to Oceanside, California, add up the distances on each route, and select the shortest. But even disallowing routes that contain cycles, your GPS would need to examine an enormous number of possibilities, most of which are simply not worth considering. For example, a route that passes through Miami, Florida, is a poor choice, because Miami is several hundred miles out of the way.</p>
<p>This chapter and <a href="chapter023.xhtml">Chapter 23</a> show how to solve such problems efficiently. The input to a <span class="blue"><strong><em>shortest-paths problem</em></strong></span> is a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>), with a weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span> mapping edges to real-valued weights. The <span class="blue"><strong><em>weight</em></strong></span> <em>w</em>(<em>p</em>) of path <em>p</em> = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span> is the sum of the weights of its constituent edges:</p>
<p class="eql"><img alt="art" src="images/Art_P626.jpg"/></p>
<p class="noindent">We define the <span class="blue"><strong><em>shortest-path weight</em></strong></span> δ(<em>u</em>, <em>v</em>) from <em>u</em> to <em>v</em> by</p>
<p class="eql"><img alt="art" src="images/Art_P627.jpg"/></p>
<p class="noindent">A <span class="blue"><strong><em>shortest path</em></strong></span> from vertex <em>u</em> to vertex <em>v</em> is then defined as any path <em>p</em> with weight <em>w</em>(<em>p</em>) = δ(<em>u</em>, <em>v</em>).</p>
<p>In the example of going from Oceanside, New York, to Oceanside, California, your GPS models the road network as a graph: vertices represent intersections, edges represent road segments between intersections, and edge weights represent road distances. The goal is to find a shortest path from a given intersection in <a id="p605"/>Oceanside, New York (say, Brower Avenue and Skillman Avenue) to a given intersection in Oceanside, California (say, Topeka Street and South Horne Street).</p>
<p>Edge weights can represent metrics other than distances, such as time, cost, penalties, loss, or any other quantity that accumulates linearly along a path and that you want to minimize.</p>
<p>The breadth-first-search algorithm from <a href="chapter020.xhtml#Sec_20.2">Section 20.2</a> is a shortest-paths algorithm that works on unweighted graphs, that is, graphs in which each edge has unit weight. Because many of the concepts from breadth-first search arise in the study of shortest paths in weighted graphs, you might want to review <a href="chapter020.xhtml#Sec_20.2">Section 20.2</a> before proceeding.</p>
<p class="level4"><strong>Variants</strong></p>
<p class="noindent">This chapter focuses on the <span class="blue"><strong><em>single-source shortest-paths problem</em></strong></span>: given a graph <em>G</em> = (<em>V</em>, <em>E</em>), find a shortest path from a given <span class="blue"><strong><em>source vertex</em></strong></span> <em>s</em> ∈ <em>V</em> to every vertex <em>v</em> ∈ <em>V</em>. The algorithm for the single-source problem can solve many other problems, including the following variants.</p>
<p class="para-hang-top"><strong>Single-destination shortest-paths problem:</strong> Find a shortest path to a given <span class="blue"><strong><em>destination vertex</em></strong></span> <em>t</em> from each vertex <em>v</em>. By reversing the direction of each edge in the graph, you can reduce this problem to a single-source problem.</p>
<p class="para-hang-d"><strong>Single-pair shortest-path problem:</strong> Find a shortest path from <em>u</em> to <em>v</em> for given vertices <em>u</em> and <em>v</em>. If you solve the single-source problem with source vertex <em>u</em>, you solve this problem also. Moreover, all known algorithms for this problem have the same worst-case asymptotic running time as the best single-source algorithms.</p>
<p class="para-hang-d"><strong>All-pairs shortest-paths problem:</strong> Find a shortest path from <em>u</em> to <em>v</em> for every pair of vertices <em>u</em> and <em>v</em>. Although you can solve this problem by running a single-source algorithm once from each vertex, you often can solve it faster. Additionally, its structure is interesting in its own right. <a href="chapter023.xhtml">Chapter 23</a> addresses the all-pairs problem in detail.</p>
<p class="level4"><strong>Optimal substructure of a shortest path</strong></p>
<p class="noindent">Shortest-paths algorithms typically rely on the property that a shortest path between two vertices contains other shortest paths within it. (The Edmonds-Karp maximum-flow algorithm in <a href="chapter024.xhtml">Chapter 24</a> also relies on this property.) Recall that optimal substructure is one of the key indicators that dynamic programming (<a href="chapter014.xhtml">Chapter 14</a>) and the greedy method (<a href="chapter015.xhtml">Chapter 15</a>) might apply. Dijkstra’s algorithm, which we shall see in <a href="chapter022.xhtml#Sec_22.3">Section 22.3</a>, is a greedy algorithm, and the Floyd-Warshall algorithm, which finds a shortest path between every pair of vertices (see <a id="p606"/><a href="chapter023.xhtml#Sec_23.2">Section 23.2</a>), is a dynamic-programming algorithm. The following lemma states the optimal-substructure property of shortest paths more precisely.</p>
<p class="lem"><strong><em>Lemma 22.1 (Subpaths of shortest paths are shortest paths)</em></strong></p>
<p class="noindent">Given a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span> let <em>p</em> = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span> be a shortest path from vertex <em>v</em><sub>0</sub> to vertex <em>v<sub>k</sub></em> and, for any <em>i</em> and <em>j</em> such that 0 ≤ <em>i</em> ≤ <em>j</em> ≤ <em>k</em>, let <em>p<sub>ij</sub></em> = <span class="font1">〈</span><em>v<sub>i</sub></em>, <em>v</em><sub><em>i</em>+1</sub>, … , <em>v<sub>j</sub></em><span class="font1">〉</span> be the subpath of <em>p</em> from vertex <em>v<sub>i</sub></em> to vertex <em>v<sub>j</sub></em>. Then, <em>p<sub>ij</sub></em> is a shortest path from <em>v<sub>i</sub></em> to <em>v<sub>j</sub></em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   Decompose path <em>p</em> into <img alt="art" src="images/Art_P628.jpg"/>, so that <em>w</em>(<em>p</em>) = <em>w</em>(<em>p</em><sub>0<em>i</em></sub>) + <em>w</em>(<em>p<sub>ij</sub></em>) + <em>w</em>(<em>p<sub>jk</sub></em>). Now, assume that there is a path <img alt="art" src="images/Art_P629.jpg"/> from <em>v<sub>i</sub></em> to <em>v<sub>j</sub></em> with weight <img alt="art" src="images/Art_P630.jpg"/>. Then, <img alt="art" src="images/Art_P631.jpg"/> is a path from <em>v</em><sub>0</sub> to <em>v<sub>k</sub></em> whose weight <img alt="art" src="images/Art_P632.jpg"/> is less than <em>w</em>(<em>p</em>), which contradicts the assumption that <em>p</em> is a shortest path from <em>v</em><sub>0</sub> to <em>v<sub>k</sub></em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Negative-weight edges</strong></p>
<p class="noindent">Some instances of the single-source shortest-paths problem may include edges whose weights are negative. If the graph <em>G</em> = (<em>V</em>, <em>E</em>) contains no negative-weight cycles reachable from the source <em>s</em>, then for all <em>v</em> ∈ <em>V</em>, the shortest-path weight δ(<em>s</em>, <em>v</em>) remains well defined, even if it has a negative value. If the graph contains a negative-weight cycle reachable from <em>s</em>, however, shortest-path weights are not well defined. No path from <em>s</em> to a vertex on the cycle can be a shortest path—you can always find a path with lower weight by following the proposed “shortest” path and then traversing the negative-weight cycle. If there is a negative-weight cycle on some path from <em>s</em> to <em>v</em>, we define δ(<em>s</em>, <em>v</em>) = −∞.</p>
<p><a href="chapter022.xhtml#Fig_22-1">Figure 22.1</a> illustrates the effect of negative weights and negative-weight cycles on shortest-path weights. Because there is only one path from <em>s</em> to <em>a</em> (the path <span class="font1">〈</span><em>s</em>, <em>a</em><span class="font1">〉</span>), we have δ(<em>s</em>, <em>a</em>) = <em>w</em>(<em>s</em>, <em>a</em>) = 3. Similarly, there is only one path from <em>s</em> to <em>b</em>, and so δ(<em>s</em>, <em>b</em>) = <em>w</em>(<em>s</em>, <em>a</em>) + <em>w</em>(<em>a</em>, <em>b</em>) = 3 + (−4) = −1. There are infinitely many paths from <em>s</em> to <em>c</em>: <span class="font1">〈</span><em>s</em>, <em>c</em><span class="font1">〉</span>, <span class="font1">〈</span><em>s</em>, <em>c</em>, <em>d</em>, <em>c</em><span class="font1">〉</span>, <span class="font1">〈</span><em>s</em>, <em>c</em>, <em>d</em>, <em>c</em>, <em>d</em>, <em>c</em><span class="font1">〉</span>, and so on. Because the cycle <span class="font1">〈</span><em>c</em>, <em>d</em>, <em>c</em><span class="font1">〉</span> has weight 6 + (−3) = 3 &gt; 0, the shortest path from <em>s</em> to <em>c</em> is <span class="font1">〈</span><em>s</em>, <em>c</em><span class="font1">〉</span>, with weight δ(<em>s</em>, <em>c</em>) = <em>w</em>(<em>s</em>, <em>c</em>) = 5, and the shortest path from <em>s</em> to <em>d</em> is <span class="font1">〈</span><em>s</em>, <em>c</em>, <em>d</em><span class="font1">〉</span>, with weight δ(<em>s</em>, <em>d</em>) = <em>w</em>(<em>s</em>, <em>c</em>) + <em>w</em>(<em>c</em>, <em>d</em>) = 11. Analogously, there are infinitely many paths from <em>s</em> to <em>e</em>: <span class="font1">〈</span><em>s</em>, <em>e</em><span class="font1">〉</span>, <span class="font1">〈</span><em>s</em>, <em>e</em>, <em>f</em>, <em>e</em><span class="font1">〉</span>, <span class="font1">〈</span><em>s</em>, <em>e</em>, <em>f</em>, <em>e</em>, <em>f</em>, <em>e</em><span class="font1">〉</span>, and so on. Because the cycle <span class="font1">〈</span><em>e</em>, <em>f</em>, <em>e</em><span class="font1">〉</span> has weight 3 + (−6) = −3 &lt; 0, however, there is no shortest path from <em>s</em> to <em>e</em>. By traversing the negative-weight cycle <span class="font1">〈</span><em>e</em>, <em>f</em>, <em>e</em><span class="font1">〉</span> arbitrarily many times, you can find paths from <em>s</em> to <em>e</em> with arbitrarily large negative weights, and so δ(<em>s</em>, <em>e</em>) = −∞. Similarly, δ(<em>s</em>, <em>f</em>) = −∞. Because <em>g</em> is reachable from <em>f</em>, you can also find paths with arbitrarily large negative weights from <em>s</em> to <em>g</em>, <a id="p607"/>and so δ(<em>s</em>, <em>g</em>) = −∞. Vertices <em>h</em>, <em>i</em>, and <em>j</em> also form a negative-weight cycle. They are not reachable from <em>s</em>, however, and so δ(<em>s</em>, <em>h</em>) = δ(<em>s</em>, <em>i</em>) = δ(<em>s</em>, <em>j</em>) = ∞.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_22-1"><img alt="art" src="images/Art_P633.jpg"/></p>
<p class="caption"><strong>Figure 22.1</strong> Negative edge weights in a directed graph. The shortest-path weight from source <em>s</em> appears within each vertex. Because vertices <em>e</em> and <em>f</em> form a negative-weight cycle reachable from <em>s</em>, they have shortest-path weights of −∞. Because vertex <em>g</em> is reachable from a vertex whose shortest-path weight is −∞, it, too, has a shortest-path weight of −∞. Vertices such as <em>h</em>, <em>i</em>, and <em>j</em> are not reachable from <em>s</em>, and so their shortest-path weights are ∞, even though they lie on a negative-weight cycle.</p>
</div>
<p>Some shortest-paths algorithms, such as Dijkstra’s algorithm, assume that all edge weights in the input graph are nonnegative, as in a road network. Others, such as the Bellman-Ford algorithm, allow negative-weight edges in the input graph and produce a correct answer as long as no negative-weight cycles are reachable from the source. Typically, if there is such a negative-weight cycle, the algorithm can detect and report its existence.</p>
<p class="level4"><strong>Cycles</strong></p>
<p class="noindent">Can a shortest path contain a cycle? As we have just seen, it cannot contain a negative-weight cycle. Nor can it contain a positive-weight cycle, since removing the cycle from the path produces a path with the same source and destination vertices and a lower path weight. That is, if <em>p</em> = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span> is a path and <em>c</em> = <span class="font1">〈</span><em>v<sub>i</sub></em>, <em>v</em><sub><em>i</em>+1</sub>, … , <em>v<sub>j</sub></em><span class="font1">〉</span> is a positive-weight cycle on this path (so that <em>v<sub>i</sub></em> = <em>v<sub>j</sub></em> and <em>w</em>(<em>c</em>) &gt; 0), then the path <em>p</em>′ = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>i</sub></em>, <em>v</em><sub><em>j</em>+1</sub>, <em>v</em><sub><em>j</em>+2</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span> has weight <em>w</em>(<em>p</em>′) = <em>w</em>(<em>p</em>) − <em>w</em>(<em>c</em>) &lt; <em>w</em>(<em>p</em>), and so <em>p</em> cannot be a shortest path from <em>v</em><sub>0</sub> to <em>v<sub>k</sub></em>.</p>
<p>That leaves only 0-weight cycles. You can remove a 0-weight cycle from any path to produce another path whose weight is the same. Thus, if there is a shortest path from a source vertex <em>s</em> to a destination vertex <em>v</em> that contains a 0-weight cycle, then there is another shortest path from <em>s</em> to <em>v</em> without this cycle. As long as a shortest path has 0-weight cycles, you can repeatedly remove these cycles from the path until you have a shortest path that is cycle-free. Therefore, without loss of <a id="p608"/>generality, assume that shortest paths have no cycles, that is, they are simple paths. Since any acyclic path in a graph <em>G</em> = (<em>V</em>, <em>E</em>) contains at most |<em>V</em>| distinct vertices, it also contains at most |<em>V</em>| − 1 edges. Assume, therefore, that any shortest path contains at most |<em>V</em>| − 1 edges.</p>
<p class="level4"><strong>Representing shortest paths</strong></p>
<p class="noindent">It is usually not enough to compute only shortest-path weights. Most applications of shortest paths need to know the vertices on shortest paths as well. For example, if your GPS told you the distance to your destination but not how to get there, it would not be terribly useful. We represent shortest paths similarly to how we represented breadth-first trees in <a href="chapter020.xhtml#Sec_20.2">Section 20.2</a>. Given a graph <em>G</em> = (<em>V</em>, <em>E</em>), maintain for each vertex <em>v</em> ∈ <em>V</em> a <span class="blue"><strong><em>predecessor</em></strong></span> <em>v</em>.π that is either another vertex or <small>NIL</small>. The shortest-paths algorithms in this chapter set the π attributes so that the chain of predecessors originating at a vertex <em>v</em> runs backward along a shortest path from <em>s</em> to <em>v</em>. Thus, given a vertex <em>v</em> for which <em>v</em>.π ≠ <small>NIL</small>, the procedure P<small>RINT</small>-P<small>ATH</small>(<em>G</em>, <em>s</em>, <em>v</em>) from <a href="chapter020.xhtml#Sec_20.2">Section 20.2</a> prints a shortest path from <em>s</em> to <em>v</em>.</p>
<p>In the midst of executing a shortest-paths algorithm, however, the π values might not indicate shortest paths. The <span class="blue"><strong><em>predecessor subgraph</em></strong></span> <em>G</em><sub>π</sub> = (<em>V</em><sub>π</sub>, <em>E</em><sub>π</sub>) induced by the π values is defined the same for single-source shortest paths as for breadth-first search in equations (20.2) and (20.3) on page 561:</p>
<p class="eql"><em>V</em><sub>π</sub> = {<em>v</em> ∈ <em>V</em> : <em>v</em>.π ≠ <small>NIL</small>} ∪ {<em>s</em>},</p>
<p class="eql"><em>E</em><sub>π</sub> = {(<em>v</em>.π, <em>v</em>) ∈ <em>E</em> : <em>v</em> ∈ <em>V</em><sub>π</sub> − {<em>s</em>}}.</p>
<p>We’ll prove that the π values produced by the algorithms in this chapter have the property that at termination <em>G</em><sub>π</sub> is a “shortest-paths tree”—informally, a rooted tree containing a shortest path from the source <em>s</em> to every vertex that is reachable from s. <em>A</em> shortest-paths tree is like the breadth-first tree from <a href="chapter020.xhtml#Sec_20.2">Section 20.2</a>, but it contains shortest paths from the source defined in terms of edge weights instead of numbers of edges. To be precise, let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, and assume that <em>G</em> contains no negative-weight cycles reachable from the source vertex <em>s</em> ∈ <em>V</em>, so that shortest paths are well defined. <em>A</em><span class="blue"><strong><em>shortest-paths tree</em></strong></span> rooted at <em>s</em> is a directed subgraph <em>G</em>′ = (<em>V</em>′, <em>E</em>′), where <em>V</em>′ ⊆ <em>V</em> and <em>E</em>′ ⊆ <em>E</em>, such that</p>
<ol class="olnoindent" epub:type="list">
<li><em>V</em>′ is the set of vertices reachable from <em>s</em> in <em>G</em>,</li>
<li class="litop"><em>G</em>′ forms a rooted tree with root <em>s</em>, and</li>
<li class="litop">for all <em>v</em> ∈ <em>V</em>′, the unique simple path from <em>s</em> to <em>v</em> in <em>G</em>′ is a shortest path from <em>s</em> to <em>v</em> in <em>G</em>.</li></ol>
<a id="p609"/>
<div class="divimage">
<p class="fig-imga" id="Fig_22-2"><img alt="art" src="images/Art_P634.jpg"/></p>
<p class="caption"><strong>Figure 22.2 (a)</strong> <em>A</em> weighted, directed graph with shortest-path weights from source <em>s</em>. <strong>(b)</strong> The blue edges form a shortest-paths tree rooted at the source <em>s</em>. <strong>(c)</strong> Another shortest-paths tree with the same root.</p>
</div>
<p>Shortest paths are not necessarily unique, and neither are shortest-paths trees. For example, <a href="chapter022.xhtml#Fig_22-2">Figure 22.2</a> shows a weighted, directed graph and two shortest-paths trees with the same root.</p>
<p class="level4"><strong>Relaxation</strong></p>
<p class="noindent">The algorithms in this chapter use the technique of <span class="blue"><strong><em>relaxation</em></strong></span>. For each vertex <em>v</em> ∈ <em>V</em>, the single-source shortest paths algorithms maintain an attribute <em>v.d</em>, which is an upper bound on the weight of a shortest path from source <em>s</em> to <em>v</em>. We call <em>v.d</em> a <span class="blue"><strong><em>shortest-path estimate</em></strong></span>. To initialize the shortest-path estimates and predecessors, call the Θ(<em>V</em>)-time procedure I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>. After initialization, we have <em>v</em>.π = <small>NIL</small> for all <em>v</em> ∈ <em>V</em>, <em>s.d</em> = 0 and <em>v.d</em> = ∞ for <em>v</em> ∈ <em>V</em> − {<em>s</em>}.</p>
<div class="pull-quote1">
<p class="box-heading">I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>v</em> ∈ <em>G.V</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><em>v.d</em> = ∞</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2"><em>v</em>.π = <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent"><em>s.d</em> = 0</p></td>
</tr>
</table>
</div>
<p>The process of <span class="blue"><strong><em>relaxing</em></strong></span> an edge (<em>u</em>, <em>v</em>) consists of testing whether going through vertex <em>u</em> improves the shortest path to vertex <em>v</em> found so far and, if so, updating <em>v.d</em> and <em>v</em>.π. A relaxation step might decrease the value of the shortest-path estimate <em>v.d</em> and update <em>v</em>’s predecessor attribute <em>v</em>.π. The R<small>ELAX</small> procedure on the following page performs a relaxation step on edge (<em>u</em>, <em>v</em>) in <em>O</em>(1) time. <a href="chapter022.xhtml#Fig_22-3">Figure 22.3</a> shows two examples of relaxing an edge, one in which a shortest-path estimate decreases and one in which no estimate changes.</p>
<a id="p610"/>
<div class="divimage">
<p class="fig-imga" id="Fig_22-3"><img alt="art" src="images/Art_P635.jpg"/></p>
<p class="caption"><strong>Figure 22.3</strong> Relaxing an edge (<em>u</em>, <em>v</em>) with weight <em>w</em>(<em>u</em>, <em>v</em>) = 2. The shortest-path estimate of each vertex appears within the vertex. <strong>(a)</strong> Because <em>v.d</em> &gt; <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>) prior to relaxation, the value of <em>v.d</em> decreases. <strong>(b)</strong> Since we have <em>v.d</em> ≤ <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>) before relaxing the edge, the relaxation step leaves <em>v.d</em> unchanged.</p>
</div>
<div class="pull-quote1">
<p class="box-heading">R<small>ELAX</small>(<em>u</em>, <em>v</em>, <em>w</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>v.d</em> &gt; <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><em>v.d</em> = <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2"><em>v</em>.π = <em>u</em></p></td>
</tr>
</table>
</div>
<p>Each algorithm in this chapter calls I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small> and then repeatedly relaxes edges.<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup> Moreover, relaxation is the only means by which shortest-path estimates and predecessors change. The algorithms in this chapter differ in how many times they relax each edge and the order in which they relax edges. Dijkstra’s algorithm and the shortest-paths algorithm for directed acyclic graphs relax each edge exactly once. The Bellman-Ford algorithm relaxes each edge |<em>V</em>| − 1 times.</p>
<p class="level4"><strong>Properties of shortest paths and relaxation</strong></p>
<p class="noindent">To prove the algorithms in this chapter correct, we’ll appeal to several properties of shortest paths and relaxation. We state these properties here, and <a href="chapter022.xhtml#Sec_22.5">Section 22.5</a> proves them formally. For your reference, each property stated here includes the appropriate lemma or corollary number from <a href="chapter022.xhtml#Sec_22.5">Section 22.5</a>. The latter five of these properties, which refer to shortest-path estimates or the predecessor subgraph, implicitly <a id="p611"/>assume that the graph is initialized with a call to I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>) and that the only way that shortest-path estimates and the predecessor subgraph change are by some sequence of relaxation steps.</p>
<p class="para-hang-d"><strong>Triangle inequality</strong> (Lemma 22.10)</p>
<p class="para-hang-dp">For any edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>, we have δ(<em>s</em>, <em>v</em>) ≤ δ(<em>s</em>, <em>u</em>) + <em>w</em>(<em>u</em>, <em>v</em>).</p>
<p class="para-hang-d"><strong>Upper-bound property</strong> (Lemma 22.11)</p>
<p class="para-hang-dp">We always have <em>v.d</em> ≥ δ(<em>s</em>, <em>v</em>) for all vertices <em>v</em> ∈ <em>V</em>, and once <em>v.d</em> achieves the value δ(<em>s</em>, <em>v</em>), it never changes.</p>
<p class="para-hang-d"><strong>No-path property</strong> (Corollary 22.12)</p>
<p class="para-hang-dp">If there is no path from <em>s</em> to <em>v</em>, then we always have <em>v.d</em> = δ(<em>s</em>, <em>v</em>) = ∞.</p>
<p class="para-hang-d"><strong>Convergence property</strong> (Lemma 22.14)</p>
<p class="para-hang-dp">If <em>s</em> <span class="font1">⇝</span> <em>u</em> → <em>v</em> is a shortest path in <em>G</em> for some <em>u</em>, <em>v</em> ∈ <em>V</em>, and if <em>u.d</em> = δ(<em>s</em>, <em>u</em>) at any time prior to relaxing edge (<em>u</em>, <em>v</em>), then <em>v.d</em> = δ(<em>s</em>, <em>v</em>) at all times afterward.</p>
<p class="para-hang-d"><strong>Path-relaxation property</strong> (Lemma 22.15)</p>
<p class="para-hang-dp">If <em>p</em> = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span> is a shortest path from <em>s</em> = <em>v</em><sub>0</sub> to <em>v<sub>k</sub></em>, and the edges of <em>p</em> are relaxed in the order (<em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>), (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>), … , (<em>v</em><sub><em>k</em>−1</sub>, <em>v<sub>k</sub></em>), then <em>v</em><sub><em>k</em></sub>.<em>d</em> = δ(<em>s</em>, <em>v<sub>k</sub></em>). This property holds regardless of any other relaxation steps that occur, even if they are intermixed with relaxations of the edges of <em>p</em>.</p>
<p class="para-hang-d"><strong>Predecessor-subgraph property</strong> (Lemma 22.17)</p>
<p class="para-hang-dp">Once <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>, the predecessor subgraph is a shortest-paths tree rooted at <em>s</em>.</p>
<p class="level4"><strong>Chapter outline</strong></p>
<p class="noindent"><a href="chapter022.xhtml#Sec_22.1">Section 22.1</a> presents the Bellman-Ford algorithm, which solves the single-source shortest-paths problem in the general case in which edges can have negative weight. The Bellman-Ford algorithm is remarkably simple, and it has the further benefit of detecting whether a negative-weight cycle is reachable from the source. <a href="chapter022.xhtml#Sec_22.2">Section 22.2</a> gives a linear-time algorithm for computing shortest paths from a single source in a directed acyclic graph. <a href="chapter022.xhtml#Sec_22.3">Section 22.3</a> covers Dijkstra’s algorithm, which has a lower running time than the Bellman-Ford algorithm but requires the edge weights to be nonnegative. <a href="chapter022.xhtml#Sec_22.4">Section 22.4</a> shows how to use the Bellman-Ford algorithm to solve a special case of linear programming. Finally, <a href="chapter022.xhtml#Sec_22.5">Section 22.5</a> proves the properties of shortest paths and relaxation stated above.</p>
<p>This chapter does arithmetic with infinities, and so we need some conventions for when ∞ or −∞ appears in an arithmetic expression. We assume that for any real number <em>a</em> ≠ −∞, we have <em>a</em> + ∞ = ∞ + <em>a</em> = ∞. Also, to make our proofs hold in the presence of negative-weight cycles, we assume that for any real number <em>a</em> ≠ ∞, we have <em>a</em> + (−∞) = (−∞) + <em>a</em> = −∞.</p>
<a id="p612"/>
<p>All algorithms in this chapter assume that the directed graph <em>G</em> is stored in the adjacency-list representation. Additionally, stored with each edge is its weight, so that as each algorithm traverses an adjacency list, it can find edge weights in <em>O</em>(1) time per edge.</p>
<p class="line1"/>
<section title="22.1 The Bellman-Ford algorithm">
<a id="Sec_22.1"/>
<p class="level1" id="h1-129"><a href="toc.xhtml#Rh1-129"><strong>22.1    The Bellman-Ford algorithm</strong></a></p>
<p class="noindent">The <span class="blue"><strong><em>Bellman-Ford algorithm</em></strong></span> solves the single-source shortest-paths problem in the general case in which edge weights may be negative. Given a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with source vertex <em>s</em> and weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, the Bellman-Ford algorithm returns a boolean value indicating whether there is a negative-weight cycle that is reachable from the source. If there is such a cycle, the algorithm indicates that no solution exists. If there is no such cycle, the algorithm produces the shortest paths and their weights.</p>
<p>The procedure B<small>ELLMAN</small>-F<small>ORD</small> relaxes edges, progressively decreasing an estimate <em>v.d</em> on the weight of a shortest path from the source <em>s</em> to each vertex <em>v</em> ∈ <em>V</em> until it achieves the actual shortest-path weight δ(<em>s</em>, <em>v</em>). The algorithm returns <small>TRUE</small> if and only if the graph contains no negative-weight cycles that are reachable from the source.</p>
<div class="pull-quote1">
<p class="box-heading">B<small>ELLMAN</small>-F<small>ORD</small>(<em>G</em>, <em>w</em>, <em>s</em>)</p>
<table class="table1c1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent">I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> |<em>G.V</em>| − 1</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2"><strong>for</strong> each edge (<em>u</em>, <em>v</em>) ∈ <em>G.E</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p3">R<small>ELAX</small>(<em>u</em>, <em>v</em>, <em>w</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each edge (<em>u</em>, <em>v</em>) = <em>G.E</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>v.d</em> &gt; <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1"><p class="p3"><strong>return</strong> <small>FALSE</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">8</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <small>TRUE</small></p></td>
</tr>
</table>
</div>
<p><a href="chapter022.xhtml#Fig_22-4">Figure 22.4</a> shows the execution of the Bellman-Ford algorithm on a graph with 5 vertices. After initializing the <em>d</em> and π values of all vertices in line 1, the algorithm makes |<em>V</em>| − 1 passes over the edges of the graph. Each pass is one iteration of the <strong>for</strong> loop of lines 2–4 and consists of relaxing each edge of the graph once. <a href="chapter022.xhtml#Fig_22-4">Figures 22.4(b)</a>–<a href="chapter022.xhtml#Fig_22-4">(e)</a> show the state of the algorithm after each of the four passes over the edges. After making |<em>V</em>| − 1 passes, lines 5–8 check for a negative-weight cycle and return the appropriate boolean value. (We’ll see a little later why this check works.)</p>
<a id="p613"/>
<div class="divimage">
<p class="fig-imga" id="Fig_22-4"><img alt="art" src="images/Art_P636.jpg"/></p>
<p class="caption"><strong>Figure 22.4</strong> The execution of the Bellman-Ford algorithm. The source is vertex <em>s</em>. The <em>d</em> values appear within the vertices, and blue edges indicate predecessor values: if edge (<em>u</em>, <em>v</em>) is blue, then <em>v</em>.π = <em>u</em>. In this particular example, each pass relaxes the edges in the order (<em>t</em>, <em>x</em>), (<em>t</em>, <em>y</em>), (<em>t</em>, <em>z</em>), (<em>x</em>, <em>t</em>), (<em>y</em>, <em>x</em>), (<em>y</em>, <em>z</em>), (<em>z</em>, <em>x</em>), (<em>z</em>, <em>s</em>), (<em>s</em>, <em>t</em>), (<em>s</em>, <em>y</em>). <strong>(a)</strong> The situation just before the first pass over the edges. <strong>(b)–(e)</strong> The situation after each successive pass over the edges. Vertices whose shortest-path estimates and predecessors have changed due to a pass are highlighted in orange. The <em>d</em> and π values in part (e) are the final values. The Bellman-Ford algorithm returns <small>TRUE</small> in this example.</p>
</div>
<p>The Bellman-Ford algorithm runs in <em>O</em>(<em>V</em><sup>2</sup> + <em>VE</em>) time when the graph is represented by adjacency lists, since the initialization in line 1 takes Θ(<em>V</em>) time, each of the |<em>V</em>| − 1 passes over the edges in lines 2–4 takes Θ(<em>V</em> + <em>E</em>) time (examining |<em>V</em>| adjacency lists to find the |<em>E</em>| edges), and the <strong>for</strong> loop of lines 5–7 takes <em>O</em>(<em>V</em> + <em>E</em>) time. Fewer than |<em>V</em>| − 1 passes over the edges sometimes suffice (see Exercise 22.1-3), which is why we say <em>O</em>(<em>V</em><sup>2</sup>+<em>VE</em>) time, rather than Θ(<em>V</em><sup>2</sup>+<em>VE</em>) time. In the frequent case where |<em>E</em>| = Ω(<em>V</em>), we can express this running time as <em>O</em>(<em>VE</em>). Exercise 22.1-5 asks you to make the Bellman-Ford algorithm run in <em>O</em>(<em>VE</em>) time even when |<em>E</em>| = <em>o</em>(<em>V</em>).</p>
<p>To prove the correctness of the Bellman-Ford algorithm, we start by showing that if there are no negative-weight cycles, the algorithm computes correct shortest-path weights for all vertices reachable from the source.</p>
<a id="p614"/>
<p class="lem"><strong><em>Lemma 22.2</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with source vertex <em>s</em> and weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, and assume that <em>G</em> contains no negative-weight cycles that are reachable from <em>s</em>. Then, after the |<em>V</em>| − 1 iterations of the <strong>for</strong> loop of lines 2–4 of B<small>ELLMAN</small>-F<small>ORD</small>, <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all vertices <em>v</em> that are reachable from <em>s</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   We prove the lemma by appealing to the path-relaxation property. Consider any vertex <em>v</em> that is reachable from <em>s</em>, and let <em>p</em> = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span>, where <em>v</em><sub>0</sub> = <em>s</em> and <em>v<sub>k</sub></em> = <em>v</em>, be any shortest path from <em>s</em> to <em>v</em>. Because shortest paths are simple, <em>p</em> has at most |<em>V</em>| − 1 edges, and so <em>k</em> ≤ |<em>V</em>| − 1. Each of the |<em>V</em>| − 1 iterations of the <strong>for</strong> loop of lines 2–4 relaxes all |<em>E</em>| edges. Among the edges relaxed in the <em>i</em>th iteration, for <em>i</em> = 1, 2, … , <em>k</em>, is (<em>v</em><sub><em>i</em>−1</sub>, <em>v<sub>i</sub></em>). By the path-relaxation property, therefore, <em>v.d</em> = <em>v<sub>k</sub>.d</em> = δ(<em>s</em>, <em>v<sub>k</sub></em>) = δ(<em>s</em>, <em>v</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 22.3</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with source vertex <em>s</em> and weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>. Then, for each vertex <em>v</em> ∈ <em>V</em>, there is a path from <em>s</em> to <em>v</em> if and only if B<small>ELLMAN</small>-F<small>ORD</small> terminates with <em>v.d</em> &lt; ∞ when it is run on <em>G</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   The proof is left as Exercise 22.1-2.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="theo"><strong><em>Theorem 22.4 (Correctness of the Bellman-Ford algorithm)</em></strong></p>
<p class="noindent">Let B<small>ELLMAN</small>-F<small>ORD</small> be run on a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with source vertex <em>s</em> and weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>. If <em>G</em> contains no negative-weight cycles that are reachable from <em>s</em>, then the algorithm returns <small>TRUE</small>, <em>v.d</em> = δ(<em>s</em>, v) for all vertices <em>v</em> ∈ <em>V</em>, and the predecessor subgraph <em>G</em><sub>π</sub> is a shortest-paths tree rooted at <em>s</em>. If <em>G</em> does contain a negative-weight cycle reachable from <em>s</em>, then the algorithm returns <small>FALSE</small>.</p>
<p class="prof"><strong><em>Proof</em></strong>   Suppose that graph <em>G</em> contains no negative-weight cycles that are reachable from the source s. We first prove the claim that at termination, <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all vertices <em>v</em> ∈ <em>V</em>. If vertex <em>v</em> is reachable from <em>s</em>, then Lemma 22.2 proves this claim. If <em>v</em> is not reachable from <em>s</em>, then the claim follows from the no-path property. Thus, the claim is proven. The predecessor-subgraph property, along with the claim, implies that <em>G</em><sub>π</sub> is a shortest-paths tree. Now we use the claim to show that B<small>ELLMAN</small>-F<small>ORD</small> returns <small>TRUE</small>. At termination, for all edges (<em>u</em>, <em>v</em>) ∈ <em>E</em> we have</p>
<table class="table2b">
<tr>
<td class="td2"><em>v.d</em></td>
<td class="td2">=</td>
<td class="td2">δ(<em>s</em>, <em>v</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2">δ(<em>s</em>, <em>u</em>) + <em>w</em>(<em>u</em>, <em>v</em>) (by the triangle inequality)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>),</td>
</tr>
</table>
<a id="p615"/>
<p class="noindent">and so none of the tests in line 6 causes B<small>ELLMAN</small>-F<small>ORD</small> to return <small>FALSE</small>. Therefore, it returns <small>TRUE</small>.</p>
<p>Now, suppose that graph <em>G</em> contains a negative-weight cycle reachable from the source <em>s</em>. Let this cycle be <em>c</em> = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span>, where <em>v</em><sub>0</sub> = <em>v<sub>k</sub></em>, in which case we have</p>
<p class="eqr"><img alt="art" src="images/Art_P637.jpg"/></p>
<p class="noindent">Assume for the purpose of contradiction that the Bellman-Ford algorithm returns <small>TRUE</small>. Thus, <em>v<sub>i</sub>.d</em> ≤ <em>v</em><sub><em>i</em>−1</sub>.<em>d</em> + <em>w</em>(<em>v</em><sub><em>i</em>−1</sub>, <em>v<sub>i</sub></em>) for <em>i</em> = 1, 2, … , <em>k</em>. Summing the inequalities around cycle <em>c</em> gives</p>
<p class="eql"><img alt="art" src="images/Art_P638.jpg"/></p>
<p class="noindent">Since <em>v</em><sub>0</sub> = <em>v<sub>k</sub></em>, each vertex in <em>c</em> appears exactly once in each of the summations <img alt="art" src="images/Art_P639.jpg"/> and <img alt="art" src="images/Art_P640.jpg"/>, and so</p>
<p class="eql"><img alt="art" src="images/Art_P641.jpg"/></p>
<p class="noindent">Moreover, by Corollary 22.3, <em>v<sub>i</sub>.d</em> is finite for <em>i</em> = 1, 2, … , <em>k</em>. Thus,</p>
<p class="eql"><img alt="art" src="images/Art_P642.jpg"/></p>
<p class="noindent">which contradicts inequality (22.1). We conclude that the Bellman-Ford algorithm returns <small>TRUE</small> if graph <em>G</em> contains no negative-weight cycles reachable from the source, and <small>FALSE</small> otherwise.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>22.1-1</em></strong></p>
<p class="noindent">Run the Bellman-Ford algorithm on the directed graph of <a href="chapter022.xhtml#Fig_22-4">Figure 22.4</a>, using vertex <em>z</em> as the source. In each pass, relax edges in the same order as in the figure, and show the <em>d</em> and π values after each pass. Now, change the weight of edge (<em>z</em>, <em>x</em>) to 4 and run the algorithm again, using <em>s</em> as the source.</p>
<p class="level3"><strong><em>22.1-2</em></strong></p>
<p class="noindent">Prove Corollary 22.3.</p>
<a id="p616"/>
<p class="level3"><strong><em>22.1-3</em></strong></p>
<p class="noindent">Given a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with no negative-weight cycles, let <em>m</em> be the maximum over all vertices <em>v</em> ∈ <em>V</em> of the minimum number of edges in a shortest path from the source <em>s</em> to <em>v</em>. (Here, the shortest path is by weight, not the number of edges.) Suggest a simple change to the Bellman-Ford algorithm that allows it to terminate in <em>m</em> + 1 passes, even if <em>m</em> is not known in advance.</p>
<p class="level3"><strong><em>22.1-4</em></strong></p>
<p class="noindent">Modify the Bellman-Ford algorithm so that it sets <em>v.d</em> to −∞ for all vertices <em>v</em> for which there is a negative-weight cycle on some path from the source to <em>v</em>.</p>
<p class="level3"><strong><em>22.1-5</em></strong></p>
<p class="noindent">Suppose that the graph given as input to the Bellman-Ford algorithm is represented with a list of |<em>E</em>| edges, where each edge indicates the vertices it leaves and enters, along with its weight. Argue that the Bellman-Ford algorithm runs in <em>O</em>(<em>VE</em>) time without the constraint that |<em>E</em>| = Ω(<em>V</em>). Modify the Bellman-Ford algorithm so that it runs in <em>O</em>(<em>VE</em>) time in all cases when the input graph is represented with adjacency lists.</p>
<p class="level3"><strong><em>22.1-6</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>. Give an <em>O</em>(<em>VE</em>)-time algorithm to find, for all vertices <em>v</em> ∈ <em>V</em>, the value δ*(<em>v</em>) = min {δ(<em>u</em>, <em>v</em>) : <em>u</em> ∈ <em>V</em>}.</p>
<p class="level3"><strong><em>22.1-7</em></strong></p>
<p class="noindent">Suppose that a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) contains a negative-weight cycle. Give an efficient algorithm to list the vertices of one such cycle. Prove that your algorithm is correct.</p>
</section>
<p class="line1"/>
<section title="22.2 Single-source shortest paths in directed acyclic graphs">
<a id="Sec_22.2"/>
<p class="level1" id="h1-130"><a href="toc.xhtml#Rh1-130"><strong>22.2    Single-source shortest paths in directed acyclic graphs</strong></a></p>
<p class="noindent">In this section, we introduce one further restriction on weighted, directed graphs: they are acyclic. That is, we are concerned with weighted dags. Shortest paths are always well defined in a dag, since even if there are negative-weight edges, no negative-weight cycles can exist. We’ll see that if the edges of a weighted dag <em>G</em> = (<em>V</em>, <em>E</em>) are relaxed according to a topological sort of its vertices, it takes only Θ(<em>V</em> + <em>E</em>) time to compute shortest paths from a single source.</p>
<p>The algorithm starts by topologically sorting the dag (see <a href="chapter020.xhtml#Sec_20.4">Section 20.4</a>) to impose a linear ordering on the vertices. If the dag contains a path from vertex <em>u</em> to vertex <em>v</em>, then <em>u</em> precedes <em>v</em> in the topological sort. The D<small>AG</small>-S<small>HORTEST</small>-P<small>ATHS</small> <a id="p617"/>procedure makes just one pass over the vertices in the topologically sorted order. As it processes each vertex, it relaxes each edge that leaves the vertex. <a href="chapter022.xhtml#Fig_22-5">Figure 22.5</a> shows the execution of this algorithm.</p>
<div class="pull-quote1">
<p class="box-heading">D<small>AG</small>-S<small>HORTEST</small>-P<small>ATHS</small>(<em>G</em>, <em>w</em>, <em>s</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent">topologically sort the vertices of <em>G</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent">I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>u</em> ∈ <em>G.V</em>, taken in topologically sorted order</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><strong>for</strong> each vertex <em>v</em> in <em>G.Adj</em>[<em>u</em>]</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p3">R<small>ELAX</small>(<em>u</em>, <em>v</em>, <em>w</em>)</p></td>
</tr>
</table>
</div>
<p>Let’s analyze the running time of this algorithm. As shown in <a href="chapter020.xhtml#Sec_20.4">Section 20.4</a>, the topological sort of line 1 takes Θ(<em>V</em> + <em>E</em>) time. The call of I<small>NITIALIZE</small>-S<small>INGLE-SOURCE</small> in line 2 takes Θ(<em>V</em>) time. The <strong>for</strong> loop of lines 3–5 makes one iteration per vertex. Altogether, the <strong>for</strong> loop of lines 4–5 relaxes each edge exactly once. (We have used an aggregate analysis here.) Because each iteration of the inner <strong>for</strong> loop takes Θ(1) time, the total running time is Θ(<em>V</em> + <em>E</em>), which is linear in the size of an adjacency-list representation of the graph.</p>
<p>The following theorem shows that the D<small>AG</small>-S<small>HORTEST</small>-P<small>ATHS</small> procedure correctly computes the shortest paths.</p>
<p class="theo"><strong><em>Theorem 22.5</em></strong></p>
<p class="noindent">If a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) has source vertex <em>s</em> and no cycles, then at the termination of the D<small>AG</small>-S<small>HORTEST</small>-P<small>ATHS</small> procedure, <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all vertices <em>v</em> ∈ <em>V</em>, and the predecessor subgraph <em>G</em><sub>π</sub> is a shortest-paths tree.</p>
<p class="prof"><strong><em>Proof</em></strong>   We first show that <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all vertices <em>v</em> ∈ <em>V</em> at termination. If <em>v</em> is not reachable from <em>s</em>, then <em>v.d</em> = δ(<em>s</em>, <em>v</em>) = 1 by the no-path property. Now, suppose that <em>v</em> is reachable from <em>s</em>, so that there is a shortest path <em>p</em> = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span>, where <em>v</em><sub>0</sub> = <em>s</em> and <em>v<sub>k</sub></em> = <em>v</em>. Because D<small>AG</small>-S<small>HORTEST</small>-P<small>ATHS</small> processes the vertices in topologically sorted order, it relaxes the edges on <em>p</em> in the order (<em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>), (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>), … , (<em>v</em><sub><em>k</em>−1</sub>, <em>v<sub>k</sub></em>). The path-relaxation property implies that <em>v<sub>i</sub>.d</em> = δ(<em>s</em>, <em>v<sub>i</sub></em>) at termination for <em>i</em> = 0, 1, … , <em>k</em>. Finally, by the predecessor-subgraph property, <em>G</em><sub>π</sub> is a shortest-paths tree.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">A useful application of this algorithm arises in determining critical paths in <span class="blue"><strong><em>PERT chart</em></strong></span><sup><a epub:type="footnote" href="#footnote_2" id="footnote_ref_2">2</a></sup> analysis. <em>A</em> job consists of several tasks. Each task takes a certain <a id="p618"/>amount of time, and some tasks must be completed before others can be started. For example, if the job is to build a house, then the foundation must be completed before starting to frame the exterior walls, which must be completed before starting on the roof. Some tasks require more than one other task to be completed before they can be started: before the drywall can be installed over the wall framing, both the electrical system and plumbing must be installed. A dag models the tasks and dependencies. Edges represent tasks, with the weight of an edge indicating the time required to perform the task. Vertices represent “milestones,” which are <a id="p619"/>achieved when all the tasks represented by the edges entering the vertex have been completed. If edge (<em>u</em>, <em>v</em>) enters vertex <em>v</em> and edge (<em>v</em>, <em>x</em>) leaves <em>v</em>, then task (<em>u</em>, <em>v</em>) must be completed before task (<em>v</em>, <em>x</em>) is started. A path through this dag represents a sequence of tasks that must be performed in a particular order. A <span class="blue"><strong><em>critical path</em></strong></span> is a <em>longest</em> path through the dag, corresponding to the longest time to perform any sequence of tasks. Thus, the weight of a critical path provides a lower bound on the total time to perform all the tasks, even if as many tasks as possible are performed simultaneously. You can find a critical path by either</p>
<ul class="ulnoindent" epub:type="list">
<li>negating the edge weights and running D<small>AG</small>-S<small>HORTEST</small>-P<small>ATHS</small>, or</li>
<li class="litop">running D<small>AG</small>-S<small>HORTEST</small>-P<small>ATHS</small>, but replacing “∞” by “−∞” in line 2 of I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small> and “&gt;” by “&lt;” in the R<small>ELAX</small> procedure.</li></ul>
<div class="divimage">
<p class="fig-imga" id="Fig_22-5"><img alt="art" src="images/Art_P643.jpg"/></p>
<p class="caption"><strong>Figure 22.5</strong> The execution of the algorithm for shortest paths in a directed acyclic graph. The vertices are topologically sorted from left to right. The source vertex is <em>s</em>. The <em>d</em> values appear within the vertices, and blue edges indicate the π values. <strong>(a)</strong> The situation before the first iteration of the <strong>for</strong> loop of lines 3–5. <strong>(b)–(g)</strong> The situation after each iteration of the <strong>for</strong> loop of lines 3–5. Blue vertices have had their outgoing edges relaxed. The vertex highlighted in orange was used as <em>u</em> in that iteration. Each edge highlighted in orange caused a <em>d</em> value to change when it was relaxed in that iteration. The values shown in part (g) are the final values.</p>
</div>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>22.2-1</em></strong></p>
<p class="noindent">Show the result of running D<small>AG</small>-S<small>HORTEST</small>-P<small>ATHS</small> on the directed acyclic graph of <a href="chapter022.xhtml#Fig_22-5">Figure 22.5</a>, using vertex <em>r</em> as the source.</p>
<p class="level3"><strong><em>22.2-2</em></strong></p>
<p class="noindent">Suppose that you change line 3 of D<small>AG</small>-S<small>HORTEST</small>-P<small>ATHS</small> to read</p>
<table class="table1a1">
<tr>
<td class="td1w"><p class="noindent1-top">3</p></td>
<td class="td1"><p class="noindent1-top"><strong>for</strong> the first |<em>V</em>| − 1 vertices, taken in topologically sorted order</p></td>
</tr>
</table>
<p class="noindent1-top">Show that the procedure remains correct.</p>
<p class="level3"><strong><em>22.2-3</em></strong></p>
<p class="noindent">An alternative way to represent a PERT chart looks more like the dag of <a href="chapter020.xhtml#Fig_20-7">Figure 20.7</a> on page 574. Vertices represent tasks and edges represent sequencing constraints, that is, edge (<em>u</em>, <em>v</em>) indicates that task <em>u</em> must be performed before task <em>v</em>. Vertices, not edges, have weights. Modify the D<small>AG</small>-S<small>HORTEST</small>-P<small>ATHS</small> procedure so that it finds a longest path in a directed acyclic graph with weighted vertices in linear time.</p>
<p class="level3"><span class="font1">★</span> <strong><em>22.2-4</em></strong></p>
<p class="noindent">Give an efficient algorithm to count the total number of paths in a directed acyclic graph. The count should include all paths between all pairs of vertices and all paths with 0 edges. Analyze your algorithm.</p>
<a id="p620"/>
</section>
<p class="line1"/>
<section title="22.3 Dijkstra’s algorithm">
<a id="Sec_22.3"/>
<p class="level1" id="h1-131"><a href="toc.xhtml#Rh1-131"><strong>22.3    Dijkstra’s algorithm</strong></a></p>
<p class="noindent">Dijkstra’s algorithm solves the single-source shortest-paths problem on a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>), but it requires nonnegative weights on all edges: <em>w</em>(<em>u</em>, <em>v</em>) ≥ 0 for each edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>. As we shall see, with a good implementation, the running time of Dijkstra’s algorithm is lower than that of the Bellman-Ford algorithm.</p>
<p>You can think of Dijkstra’s algorithm as generalizing breadth-first search to weighted graphs. A wave emanates from the source, and the first time that a wave arrives at a vertex, a new wave emanates from that vertex. Whereas breadth-first search operates as if each wave takes unit time to traverse an edge, in a weighted graph, the time for a wave to traverse an edge is given by the edge’s weight. Because a shortest path in a weighted graph might not have the fewest edges, a simple, first-in, first-out queue won’t suffice for choosing the next vertex from which to send out a wave.</p>
<p>Instead, Dijkstra’s algorithm maintains a set <em>S</em> of vertices whose final shortest-path weights from the source <em>s</em> have already been determined. The algorithm repeatedly selects the vertex <em>u</em> ∈ <em>V</em> – <em>S</em> with the minimum shortest-path estimate, adds <em>u</em> into <em>S</em>, and relaxes all edges leaving <em>u</em>. The procedure D<small>IJKSTRA</small> replaces the first-in, first-out queue of breadth-first search by a min-priority queue <em>Q</em> of vertices, keyed by their <em>d</em> values.</p>
<div class="pull-quote1">
<p class="box-heading">D<small>IJKSTRA</small>(<em>G</em>, <em>w</em>, <em>s</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent">I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="noindent"><em>S</em> = Ø</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="noindent"><em>Q</em> = Ø</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>u</em> ∈ <em>G.V</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="p2">I<small>NSERT</small>(<em>Q, u</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> <em>Q</em> ≠ Ø</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="p2"><em>u</em> = E<small>XTRACT</small>-M<small>IN</small>(<em>Q</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="p2">S = <em>S</em> ∪ {u}</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="p2"><strong>for</strong> each vertex <em>v</em> in <em>G.Adj</em>[<em>u</em>]</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="p3">R<small>ELAX</small>(<em>u</em>, <em>v</em>, <em>w</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><p class="p3"><strong>if</strong> the call of R<small>ELAX</small> decreased <em>v.d</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1"><p class="p4">D<small>ECREASE</small>-K<small>EY</small>(<em>Q</em>, <em>v</em>, <em>v.d</em>)</p></td>
</tr>
</table>
</div>
<p>Dijkstra’s algorithm relaxes edges as shown in <a href="chapter022.xhtml#Fig_22-6">Figure 22.6</a>. Line 1 initializes the <em>d</em> and π values in the usual way, and line 2 initializes the set <em>S</em> to the empty set. The algorithm maintains the invariant that <em>Q</em> = <em>V</em> − <em>S</em> at the start of each iteration <a id="p621"/>of the <strong>while</strong> loop of lines 6–12. Lines 3–5 initialize the min-priority queue <em>Q</em> to contain all the vertices in <em>V</em>. Since <em>S</em> = Ø at that time, the invariant is true upon first reaching line 6. Each time through the <strong>while</strong> loop of lines 6–12, line 7 extracts a vertex <em>u</em> from <em>Q</em> = <em>V</em> − <em>S</em> and line 8 adds it to set <em>S</em>, thereby maintaining the invariant. (The first time through this loop, <em>u</em> = <em>s</em>.) Vertex <em>u</em>, therefore, has the smallest shortest-path estimate of any vertex in <em>V</em> − <em>S</em>. Then, lines 9–12 relax each edge (<em>u</em>, <em>v</em>) leaving <em>u</em>, thus updating the estimate <em>v.d</em> and the predecessor <em>v</em>.π if the shortest path to <em>v</em> found so far improves by going through <em>u</em>. Whenever a relaxation step changes the <em>d</em> and π values, the call to D<small>ECREASE</small>-K<small>EY</small> in line 12 updates the min-priority queue. The algorithm never inserts vertices into <em>Q</em> after the <strong>for</strong> loop of lines 4–5, and each vertex is extracted from <em>Q</em> and added to <em>S</em> exactly once, so that the <strong>while</strong> loop of lines 6–12 iterates exactly |<em>V</em>| times.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_22-6"><img alt="art" src="images/Art_P644.jpg"/></p>
<p class="caption"><strong>Figure 22.6</strong> The execution of Dijkstra’s algorithm. The source <em>s</em> is the leftmost vertex. The shortest-path estimates appear within the vertices, and blue edges indicate predecessor values. Blue vertices belong to the set <em>S</em>, and tan vertices are in the min-priority queue <em>Q</em> = <em>V</em> − <em>S</em>. <strong>(a)</strong> The situation just before the first iteration of the <strong>while</strong> loop of lines 6–12. <strong>(b)–(f)</strong> The situation after each successive iteration of the <strong>while</strong> loop. In each part, the vertex highlighted in orange was chosen as vertex <em>u</em> in line 7, and each edge highlighted in orange caused a <em>d</em> value and a predecessor to change when the edge was relaxed. The <em>d</em> values and predecessors shown in part (f) are the final values.</p>
</div>
<p>Because Dijkstra’s algorithm always chooses the “lightest” or “closest” vertex in <em>V</em> − <em>S</em> to add to set <em>S</em>, you can think of it as using a greedy strategy. <a href="chapter015.xhtml">Chapter 15</a> explains greedy strategies in detail, but you need not have read that chapter to understand Dijkstra’s algorithm. Greedy strategies do not always yield optimal <a id="p622"/>results in general, but as the following theorem and its corollary show, Dijkstra’s algorithm does indeed compute shortest paths. The key is to show that <em>u.d</em> = δ(<em>s</em>, <em>u</em>) each time it adds a vertex <em>u</em> to set <em>S</em>.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_22-7"><img alt="art" src="images/Art_P645.jpg"/></p>
<p class="caption"><strong>Figure 22.7</strong> The proof of Theorem 22.6. Vertex <em>u</em> is selected to be added into set <em>S</em> in line 7 of D<small>IJKSTRA</small>. Vertex <em>y</em> is the first vertex on a shortest path from the source <em>s</em> to vertex <em>u</em> that is not in set <em>S</em>, and <em>x</em> ∈ <em>S</em> is <em>y</em>’s predecessor on that shortest path. The subpath from <em>y</em> to <em>u</em> may or may not re-enter set <em>S</em>.</p>
</div>
<p class="theo"><strong><em>Theorem 22.6 (Correctness of Dijkstra’s algorithm)</em></strong></p>
<p class="noindent">Dijkstra’s algorithm, run on a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with nonnegative weight function <em>w</em> and source vertex <em>s</em>, terminates with <em>u.d</em> = δ(<em>s</em>, <em>u</em>) for all vertices <em>u</em> ∈ <em>V</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   We will show that at the start of each iteration of the <strong>while</strong> loop of lines 6–12, we have <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>S</em>. The algorithm terminates when <em>S</em> = <em>V</em>, so that <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>.</p>
<p>The proof is by induction on the number of iterations of the <strong>while</strong> loop, which equals |<em>S</em>| at the start of each iteration. There are two bases: for |<em>S</em>| = 0, so that <em>S</em> = Ø and the claim is trivially true, and for |<em>S</em>| = 1, so that <em>S</em> = {<em>s</em>} and <em>s.d</em> = δ(<em>s</em>, <em>s</em>) = 0.</p>
<p>For the inductive step, the inductive hypothesis is that <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>S</em>. The algorithm extracts vertex <em>u</em> from <em>V</em> − <em>S</em>. Because the algorithm adds <em>u</em> into <em>S</em>, we need to show that <em>u.d</em> = δ(<em>s</em>, <em>u</em>) at that time. If there is no path from <em>s</em> to <em>u</em>, then we are done, by the no-path property. If there is a path from <em>s</em> to <em>u</em>, then, as <a href="chapter022.xhtml#Fig_22-7">Figure 22.7</a> shows, let <em>y</em> be the first vertex on a shortest path from <em>s</em> to <em>u</em> that is not in <em>S</em>, and let <em>x</em> ∈ <em>S</em> be the predecessor of <em>y</em> on that shortest path. (We could have <em>y</em> = <em>u</em> or <em>x</em> = <em>s</em>.) Because <em>y</em> appears no later than <em>u</em> on the shortest path and all edge weights are nonnegative, we have δ(<em>s</em>, <em>y</em>) ≤ δ(<em>s</em>, <em>u</em>). Because the call of E<small>XTRACT</small>-M<small>IN</small> in line 7 returned <em>u</em> as having the minimum <em>d</em> value in <em>V</em> − <em>S</em>, we also have <em>u.d</em> ≤ <em>y.d</em>, and the upper-bound property gives δ(<em>s</em>, <em>u</em>) ≤ <em>u.d</em>.</p>
<p>Since <em>x</em> ∈ <em>S</em>, the inductive hypothesis implies that <em>x.d</em> = δ(<em>s</em>, <em>x</em>). During the iteration of the <strong>while</strong> loop that added <em>x</em> into <em>S</em>, edge (<em>x</em>, <em>y</em>) was relaxed. By the convergence property, <em>y.d</em> received the value of δ(<em>s</em>, <em>y</em>) at that time. Thus, we have</p>
<a id="p623"/>
<p class="eql">δ(<em>s</em>, <em>y</em>) ≤ δ(<em>s</em>, <em>u</em>) ≤ <em>u.d</em> ≤ <em>y.d</em> and <em>y.d</em> = δ(<em>s</em>, <em>y</em>),</p>
<p class="noindent">so that</p>
<p class="eql">δ(<em>s</em>, <em>y</em>) = δ(<em>s</em>, <em>u</em>) = <em>u.d</em> = <em>y.d</em>.</p>
<p class="noindent">Hence, <em>u.d</em> = δ(<em>s</em>, <em>u</em>), and by the upper-bound property, this value never changes again.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 22.7</em></strong></p>
<p class="noindent">After Dijkstra’s algorithm is run on a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with nonnegative weight function <em>w</em> and source vertex <em>s</em>, the predecessor subgraph <em>G</em><sub>π</sub> is a shortest-paths tree rooted at <em>s</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   Immediate from Theorem 22.6 and the predecessor-subgraph property.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Analysis</strong></p>
<p class="noindent">How fast is Dijkstra’s algorithm? It maintains the min-priority queue <em>Q</em> by calling three priority-queue operations: I<small>NSERT</small> (in line 5), E<small>XTRACT</small>-M<small>IN</small> (in line 7), and D<small>ECREASE</small>-K<small>EY</small> (in line 12). The algorithm calls both I<small>NSERT</small> and E<small>XTRACT</small>-M<small>IN</small> once per vertex. Because each vertex <em>u</em> ∈ <em>V</em> is added to set <em>S</em> exactly once, each edge in the adjacency list <em>Adj</em>[<em>u</em>] is examined in the <strong>for</strong> loop of lines 9–12 exactly once during the course of the algorithm. Since the total number of edges in all the adjacency lists is |<em>E</em>|, this <strong>for</strong> loop iterates a total of |<em>E</em>| times, and thus the algorithm calls D<small>ECREASE</small>-K<small>EY</small> at most |<em>E</em>| times overall. (Observe once again that we are using aggregate analysis.)</p>
<p>Just as in Prim’s algorithm, the running time of Dijkstra’s algorithm depends on the specific implementation of the min-priority queue <em>Q</em>. A simple implementation takes advantage of the vertices being numbered 1 to |<em>V</em>|: simply store <em>v.d</em> in the <em>v</em>th entry of an array. Each I<small>NSERT</small> and D<small>ECREASE</small>-K<small>EY</small> operation takes <em>O</em>(1) time, and each E<small>XTRACT</small>-M<small>IN</small> operation takes <em>O</em>(<em>V</em>) time (since it has to search through the entire array), for a total time of <em>O</em>(<em>V</em><sup>2</sup> + <em>E</em>) = <em>O</em>(<em>V</em><sup>2</sup>).</p>
<p>If the graph is sufficiently sparse—in particular, <em>E</em> = <em>o</em>(<em>V</em><sup>2</sup>/lg <em>V</em>)—you can improve the running time by implementing the min-priority queue with a binary min-heap that includes a way to map between vertices and their corresponding heap elements. Each E<small>XTRACT</small>-M<small>IN</small> operation then takes <em>O</em>(lg <em>V</em>) time. As before, there are |<em>V</em>| such operations. The time to build the binary min-heap is <em>O</em>(<em>V</em>). (As noted in <a href="chapter021.xhtml#Sec_21.2">Section 21.2</a>, you don’t even need to call B<small>UILD</small>-M<small>IN</small>-H<small>EAP</small>.) Each D<small>ECREASE</small>-K<small>EY</small> operation takes <em>O</em>(lg <em>V</em>) time, and there are still at most |<em>E</em>| such operations. The total running time is therefore <em>O</em>((<em>V</em> + <em>E</em>) lg <em>V</em>), which is <em>O</em>(<em>E</em> lg <em>V</em>) in the typical case that |<em>E</em>| = Ω(<em>V</em>). This running time improves upon the straightforward <em>O</em>(<em>V</em><sup>2</sup>)-time implementation if <em>E</em> = <em>o</em>(<em>V</em><sup>2</sup>/lg <em>V</em>).</p>
<a id="p624"/>
<p>By implementing the min-priority queue with a Fibonacci heap (see page 478), you can improve the running time to <em>O</em>(<em>V</em> lg <em>V</em> + <em>E</em>). The amortized cost of each of the |<em>V</em>| E<small>XTRACT</small>-M<small>IN</small> operations is <em>O</em>(lg <em>V</em>), and each D<small>ECREASE</small>-K<small>EY</small> call, of which there are at most |<em>E</em>|, takes only <em>O</em>(1) amortized time. Historically, the development of Fibonacci heaps was motivated by the observation that Dijkstra’s algorithm typically makes many more D<small>ECREASE</small>-K<small>EY</small> calls than E<small>XTRACT</small>-M<small>IN</small> calls, so that any method of reducing the amortized time of each D<small>ECREASE</small>-K<small>EY</small> operation to <em>o</em>(lg <em>V</em>) without increasing the amortized time of E<small>XTRACT</small>-M<small>IN</small> would yield an asymptotically faster implementation than with binary heaps.</p>
<p>Dijkstra’s algorithm resembles both breadth-first search (see <a href="chapter020.xhtml#Sec_20.2">Section 20.2</a>) and Prim’s algorithm for computing minimum spanning trees (see <a href="chapter021.xhtml#Sec_21.2">Section 21.2</a>). It is like breadth-first search in that set <em>S</em> corresponds to the set of black vertices in a breadth-first search. Just as vertices in <em>S</em> have their final shortest-path weights, so do black vertices in a breadth-first search have their correct breadth-first distances. Dijkstra’s algorithm is like Prim’s algorithm in that both algorithms use a min-priority queue to find the “lightest” vertex outside a given set (the set <em>S</em> in Dijkstra’s algorithm and the tree being grown in Prim’s algorithm), add this vertex into the set, and adjust the weights of the remaining vertices outside the set accordingly.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>22.3-1</em></strong></p>
<p class="noindent">Run Dijkstra’s algorithm on the directed graph of <a href="chapter022.xhtml#Fig_22-2">Figure 22.2</a>, first using vertex <em>s</em> as the source and then using vertex <em>z</em> as the source. In the style of <a href="chapter022.xhtml#Fig_22-6">Figure 22.6</a>, show the <em>d</em> and π values and the vertices in set <em>S</em> after each iteration of the <strong>while</strong> loop.</p>
<p class="level3"><strong><em>22.3-2</em></strong></p>
<p class="noindent">Give a simple example of a directed graph with negative-weight edges for which Dijkstra’s algorithm produces an incorrect answer. Why doesn’t the proof of Theorem 22.6 go through when negative-weight edges are allowed?</p>
<p class="level3"><strong><em>22.3-3</em></strong></p>
<p class="noindent">Suppose that you change line 6 of Dijkstra’s algorithm to read</p>
<table class="table3a">
<tr>
<td class="td1w1"><p class="noindent1-top">6   </p></td>
<td class="td1"><p class="noindent1-top"><strong>while</strong> |<em>Q</em>| &gt; 1</p></td>
</tr>
</table>
<p class="noindent1-top">This change causes the <strong>while</strong> loop to execute |<em>V</em>| − 1 times instead of |<em>V</em>| times. Is this proposed algorithm correct?</p>
<a id="p625"/>
<p class="level3"><strong><em>22.3-4</em></strong></p>
<p class="noindent">Modify the D<small>IJKSTRA</small> procedure so that the priority queue <em>Q</em> is more like the queue in the BFS procedure in that it contains only vertices that have been reached from source <em>s</em> so far: <em>Q</em> ⊆ <em>V</em> − <em>S</em> and <em>v</em> ∈ <em>Q</em> implies <em>v.d</em> ≠ ∞.</p>
<p class="level3"><strong><em>22.3-5</em></strong></p>
<p class="noindent">Professor Gaedel has written a program that he claims implements Dijkstra’s algorithm. The program produces <em>v.d</em> and <em>v</em>.π for each vertex <em>v</em> ∈ <em>V</em>. Give an <em>O</em>(<em>V</em> + <em>E</em>)-time algorithm to check the output of the professor’s program. It should determine whether the <em>d</em> and π attributes match those of some shortest-paths tree. You may assume that all edge weights are nonnegative.</p>
<p class="level3"><strong><em>22.3-6</em></strong></p>
<p class="noindent">Professor Newman thinks that he has worked out a simpler proof of correctness for Dijkstra’s algorithm. He claims that Dijkstra’s algorithm relaxes the edges of every shortest path in the graph in the order in which they appear on the path, and therefore the path-relaxation property applies to every vertex reachable from the source. Show that the professor is mistaken by constructing a directed graph for which Dijkstra’s algorithm relaxes the edges of a shortest path out of order.</p>
<p class="level3"><strong><em>22.3-7</em></strong></p>
<p class="noindent">Consider a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) on which each edge (<em>u</em>, <em>v</em>) ∈ <em>E</em> has an associated value <em>r</em>(<em>u</em>, <em>v</em>), which is a real number in the range 0 ≤ <em>r</em>(<em>u</em>, <em>v</em>) ≤ 1 that represents the reliability of a communication channel from vertex <em>u</em> to vertex <em>v</em>. Interpret <em>r</em>(<em>u</em>, <em>v</em>) as the probability that the channel from <em>u</em> to <em>v</em> will not fail, and assume that these probabilities are independent. Give an efficient algorithm to find the most reliable path between two given vertices.</p>
<p class="level3"><strong><em>22.3-8</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with positive weight function <em>w</em> : <em>E</em> → {1, 2, … , <em>W</em>} for some positive integer <em>W</em>, and assume that no two vertices have the same shortest-path weights from source vertex <em>s</em>. Now define an unweighted, directed graph <em>G</em>′ = (<em>V</em> ∪ <em>V</em>′, <em>E</em>′) by replacing each edge (<em>u</em>, <em>v</em>) ∈ <em>E</em> with <em>w</em>(<em>u</em>, <em>v</em>) unit-weight edges in series. How many vertices does <em>G</em>′ have? Now suppose that you run a breadth-first search on <em>G</em>′. Show that the order in which the breadth-first search of <em>G</em>′ colors vertices in <em>V</em> black is the same as the order in which Dijkstra’s algorithm extracts the vertices of <em>V</em> from the priority queue when it runs on <em>G</em>.</p>
<p class="level3"><strong><em>22.3-9</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with nonnegative weight function <em>w</em> : <em>E</em> → {0, 1, … , <em>W</em>} for some nonnegative integer <em>W</em>. Modify Dijkstra’s algorithm <a id="p626"/>to compute the shortest paths from a given source vertex <em>s</em> in <em>O</em>(<em>W V</em> + <em>E</em>) time.</p>
<p class="level3"><strong><em>22.3-10</em></strong></p>
<p class="noindent">Modify your algorithm from Exercise 22.3-9 to run in <em>O</em>((<em>V</em> + <em>E</em>) lg <em>W</em>) time. (<em>Hint:</em> How many distinct shortest-path estimates can <em>V</em> − <em>S</em> contain at any point in time?)</p>
<p class="level3"><strong><em>22.3-11</em></strong></p>
<p class="noindent">Suppose that you are given a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) in which edges that leave the source vertex <em>s</em> may have negative weights, all other edge weights are nonnegative, and there are no negative-weight cycles. Argue that Dijkstra’s algorithm correctly finds shortest paths from <em>s</em> in this graph.</p>
<p class="level3"><strong><em>22.3-12</em></strong></p>
<p class="noindent">Suppose that you have a weighted directed graph <em>G</em> = (<em>V</em>, <em>E</em>) in which all edge weights are positive real values in the range [<em>C</em>, 2<em>C</em>] for some positive constant <em>C</em>. Modify Dijkstra’s algorithm so that it runs in <em>O</em>(<em>V</em> + <em>E</em>) time.</p>
</section>
<p class="line1"/>
<section title="22.4 Difference constraints and shortest paths">
<a id="Sec_22.4"/>
<p class="level1" id="h1-132"><a href="toc.xhtml#Rh1-132"><strong>22.4    Difference constraints and shortest paths</strong></a></p>
<p class="noindent"><a href="chapter029.xhtml">Chapter 29</a> studies the general linear-programming problem, showing how to optimize a linear function subject to a set of linear inequalities. This section investigates a special case of linear programming that reduces to finding shortest paths from a single source. The Bellman-Ford algorithm then solves the resulting single-source shortest-paths problem, thereby also solving the linear-programming problem.</p>
<p class="level4"><strong>Linear programming</strong></p>
<p class="noindent">In the general <span class="blue"><strong><em>linear-programming problem</em></strong></span>, the input is an <em>m</em> × <em>n</em> matrix <em>A</em>, an <em>m</em>-vector <em>b</em>, and an <em>n</em>-vector <em>c</em>. The goal is to find a vector <em>x</em> of <em>n</em> elements that maximizes the <span class="blue"><strong><em>objective function</em></strong></span> <img alt="art" src="images/Art_P646.jpg"/> subject to the <em>m</em> constraints given by <em>Ax</em> ≤ <em>b</em>.</p>
<p>The most popular method for solving linear programs is the <span class="blue"><strong><em>simplex algorithm</em></strong></span>, which <a href="chapter029.xhtml#Sec_29.1">Section 29.1</a> discusses. Although the simplex algorithm does not always run in time polynomial in the size of its input, there are other linear-programming algorithms that do run in polynomial time. We offer here two reasons to understand the setup of linear-programming problems. First, if you know that you can cast a given problem as a polynomial-sized linear-programming problem, then you immediately <a id="p627"/>have a polynomial-time algorithm to solve the problem. Second, faster algorithms exist for many special cases of linear programming. For example, the single-pair shortest-path problem (Exercise 22.4-4) and the maximum-flow problem (Exercise 24.1-5) are special cases of linear programming.</p>
<p>Sometimes the objective function does not matter: it’s enough just to find any <span class="blue"><strong><em>feasible solution</em></strong></span>, that is, any vector <em>x</em> that satisfies <em>Ax</em> ≤ <em>b</em>, or to determine that no feasible solution exists. This section focuses on one such <span class="blue"><strong><em>feasibility problem</em></strong></span>.</p>
<p class="level4"><strong>Systems of difference constraints</strong></p>
<p class="noindent">In a <span class="blue"><strong><em>system of difference constraints</em></strong></span>, each row of the linear-programming matrix <em>A</em> contains one 1 and one −1, and all other entries of <em>A</em> are 0. Thus, the constraints given by <em>Ax</em> ≤ <em>b</em> are a set of <em>m</em><span class="blue"><strong><em>difference constraints</em></strong></span> involving <em>n</em> unknowns, in which each constraint is a simple linear inequality of the form</p>
<p class="eql"><em>x<sub>j</sub></em> − <em>x<sub>i</sub></em> ≤ <em>b<sub>k</sub></em>,</p>
<p class="noindent">where 1 ≤ <em>i</em>, <em>j</em> ≤ <em>n</em>, <em>i</em> ≠ <em>j</em>, and 1 ≤ <em>k</em> ≤ <em>m</em>.</p>
<p>For example, consider the problem of finding a 5-vector <em>x</em> = (<em>x<sub>i</sub></em>) that satisfies</p>
<p class="eql"><img alt="art" src="images/Art_P647.jpg"/></p>
<p class="noindent">This problem is equivalent to finding values for the unknowns <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>, <em>x</em><sub>4</sub>, <em>x</em><sub>5</sub>, satisfying the following 8 difference constraints:</p>
<p class="eqr"><img alt="art" src="images/Art_P648.jpg"/></p>
<p class="noindent">One solution to this problem is <em>x</em> = (−5, −3, 0, −1, −4), which you can verify directly by checking each inequality. In fact, this problem has more than one solution. <a id="p628"/>Another is <em>x</em>′ = (0, 2, 5, 4, 1). These two solutions are related: each component of <em>x</em>′ is 5 larger than the corresponding component of <em>x</em>. This fact is not mere coincidence.</p>
<p class="lem"><strong><em>Lemma 22.8</em></strong></p>
<p class="noindent">Let <em>x</em> = (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, … , <em>x<sub>n</sub></em>) be a solution to a system A<em>x</em> ≤ <em>b</em> of difference constraints, and let <em>d</em> be any constant. Then <em>x</em> + <em>d</em> = (<em>x</em><sub>1</sub> + <em>d</em>, <em>x</em><sub>2</sub> + <em>d</em>, … , <em>x<sub>n</sub></em> + <em>d</em>) is a solution to <em>Ax</em> ≤ <em>b</em> as well.</p>
<p class="prof"><strong><em>Proof</em></strong>   For each <em>x<sub>i</sub></em> and <em>x<sub>j</sub></em>, we have (<em>x<sub>j</sub></em> + <em>d</em>) − (<em>x<sub>i</sub></em> + <em>d</em>) = <em>x<sub>j</sub></em> − <em>x<sub>i</sub></em>. Thus, if <em>x</em> satisfies <em>Ax</em> ≤ <em>b</em>, so does <em>x</em> + <em>d</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Systems of difference constraints occur in various applications. For example, the unknowns <em>x<sub>i</sub></em> might be times at which events are to occur. Each constraint states that at least a certain amount of time, or at most a certain amount of time, must elapse between two events. Perhaps the events are jobs to be performed during the assembly of a product. If the manufacturer applies an adhesive that takes 2 hours to set at time <em>x</em><sub>1</sub> and has to wait until it sets to install a part at time <em>x</em><sub>2</sub>, then there is a constraint that <em>x</em><sub>2</sub> ≥ <em>x</em><sub>1</sub> + 2 or, equivalently, that <em>x</em><sub>1</sub> − <em>x</em><sub>2</sub> ≤ −2. Alternatively, the manufacturer might require the part to be installed after the adhesive has been applied but no later than the time that the adhesive has set halfway. In this case, there is a pair of constraints <em>x</em><sub>2</sub> ≥ <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub> ≤ <em>x</em><sub>1</sub> + 1 or, equivalently, <em>x</em><sub>1</sub> − <em>x</em><sub>2</sub> ≤ 0 and <em>x</em><sub>2</sub> − <em>x</em><sub>1</sub> ≤ 1.</p>
<p>If all the constraints have nonnegative numbers on the right-hand side—that is, if <em>b<sub>i</sub></em> ≥ 0 for <em>i</em> = 1, 2, … , <em>m</em>—then finding a feasible solution is trivial: just set all the unknowns <em>x<sub>i</sub></em> equal to each other. Then all the differences are 0, and every constraint is satisfied. The problem of finding a feasible solution to a system of difference constraints is interesting only if at least one constraint has <em>b<sub>i</sub></em> &lt; 0.</p>
<p class="level4"><strong>Constraint graphs</strong></p>
<p class="noindent">We can interpret systems of difference constraints from a graph-theoretic point of view. For a system <em>Ax</em> ≤ <em>b</em> of difference constraints, let’s view the <em>m</em> × <em>n</em> linear-programming matrix <em>A</em> as the transpose of an incidence matrix (see Exercise 20.1-7) for a graph with <em>n</em> vertices and <em>m</em> edges. Each vertex <em>v<sub>i</sub></em> in the graph, for <em>i</em> = 1, 2, … , <em>n</em>, corresponds to one of the <em>n</em> unknown variables <em>x<sub>i</sub></em>. Each directed edge in the graph corresponds to one of the <em>m</em> inequalities involving two unknowns.</p>
<p>More formally, given a system <em>Ax</em> ≤ <em>b</em> of difference constraints, the corresponding <span class="blue"><strong><em>constraint graph</em></strong></span> is a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>), where</p>
<a id="p629"/>
<p class="eql"><em>V</em> = {<em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>n</sub></em>}</p>
<p class="noindent">and</p>
<table class="table2b">
<tr>
<td class="td2"><em>E</em> =</td>
<td class="td2">{(<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>) : <em>x<sub>j</sub></em> − <em>x<sub>i</sub></em> ≤ <em>b<sub>k</sub></em> is a constraint}</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">   ∪ {(<em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>), (<em>v</em><sub>0</sub>, <em>v</em><sub>2</sub>), (<em>v</em><sub>0</sub>, <em>v</em><sub>3</sub>), … , (<em>v</em><sub>0</sub>, <em>v<sub>n</sub></em>)}.</td>
</tr>
</table>
<p class="noindent">The constraint graph includes the additional vertex <em>v</em><sub>0</sub>, as we shall see shortly, to guarantee that the graph has some vertex that can reach all other vertices. Thus, the vertex set <em>V</em> consists of a vertex <em>v<sub>i</sub></em> for each unknown <em>x<sub>i</sub></em>, plus an additional vertex <em>v</em><sub>0</sub>. The edge set <em>E</em> contains an edge for each difference constraint, plus an edge (<em>v</em><sub>0</sub>, <em>v<sub>i</sub></em>) for each unknown <em>x<sub>i</sub></em>. If <em>x<sub>j</sub></em> − <em>x<sub>i</sub></em> ≤ <em>b<sub>k</sub></em> is a difference constraint, then the weight of edge (<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>) is <em>w</em>(<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>) = <em>b<sub>k</sub></em>. The weight of each edge leaving <em>v</em><sub>0</sub> is 0. <a href="chapter022.xhtml#Fig_22-8">Figure 22.8</a> shows the constraint graph for the system (22.2)–(22.9) of difference constraints.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_22-8"><img alt="art" src="images/Art_P649.jpg"/></p>
<p class="caption"><strong>Figure 22.8</strong> The constraint graph corresponding to the system (22.2)–(22.9) of difference constraints. The value of δ(<em>v</em><sub>0</sub>, <em>v<sub>i</sub></em>) appears in each vertex <em>v<sub>i</sub></em>. One feasible solution to the system is <em>x</em> = (−5, −3, 0, −1, −4).</p>
</div>
<p>The following theorem shows how to solve a system of difference constraints by finding shortest-path weights in the corresponding constraint graph.</p>
<p class="theo"><strong><em>Theorem 22.9</em></strong></p>
<p class="noindent">Given a system <em>Ax</em> ≤ <em>b</em> of difference constraints, let <em>G</em> = (<em>V</em>, <em>E</em>) be the corresponding constraint graph. If <em>G</em> contains no negative-weight cycles, then</p>
<p class="eqr"><img alt="art" src="images/Art_P650.jpg"/></p>
<p class="noindent">is a feasible solution for the system. If <em>G</em> contains a negative-weight cycle, then there is no feasible solution for the system.</p>
<a id="p630"/>
<p class="prof"><strong><em>Proof</em></strong>   We first show that if the constraint graph contains no negative-weight cycles, then equation (22.10) gives a feasible solution. Consider any edge (<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>) ∈ <em>E</em>. The triangle inequality implies that δ(<em>v</em><sub>0</sub>, <em>v<sub>j</sub></em>) ≤ δ(<em>v</em><sub>0</sub>, <em>v<sub>i</sub></em>) + <em>w</em>(<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>), which is equivalent to δ(<em>v</em><sub>0</sub>, <em>v<sub>j</sub></em>)−δ(<em>v</em><sub>0</sub>, <em>v<sub>i</sub></em>) ≤ <em>w</em>(<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>). Thus, letting <em>x<sub>i</sub></em> = δ(<em>v</em><sub>0</sub>, <em>v<sub>i</sub></em>) and <em>x<sub>j</sub></em> = δ(<em>v</em><sub>0</sub>, <em>v<sub>j</sub></em>) satisfies the difference constraint <em>x<sub>j</sub></em> − <em>x<sub>i</sub></em> ≤ <em>w</em>(<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>) that corresponds to edge (<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>).</p>
<p>Now we show that if the constraint graph contains a negative-weight cycle, then the system of difference constraints has no feasible solution. Without loss of generality, let the negative-weight cycle be <em>c</em> = <span class="font1">〈</span><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span>, where <em>v</em><sub>1</sub> = <em>v<sub>k</sub></em>. (The vertex <em>v</em><sub>0</sub> cannot be on cycle <em>c</em>, because it has no entering edges.) Cycle <em>c</em> corresponds to the following difference constraints:</p>
<table class="table2b">
<tr>
<td class="td2"><p class="right"><em>x</em><sub>2</sub> − <em>x</em><sub>1</sub></p></td>
<td class="td2"><p class="center">≤</p></td>
<td class="td2"><p class="noindent"><em>w</em>(<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>),</p></td>
</tr>
<tr>
<td class="td2"><p class="right"><em>x</em><sub>3</sub> − <em>x</em><sub>2</sub></p></td>
<td class="td2"><p class="center">≤</p></td>
<td class="td2"><p class="noindent"><em>w</em>(<em>v</em><sub>2</sub>, <em>v</em><sub>3</sub>),</p></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2"><span class="font1">⋮</span></td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"><p class="right"><em>x</em><sub><em>k</em>−1</sub> − <em>x</em><sub><em>k</em>−2</sub></p></td>
<td class="td2"><p class="center">≤</p></td>
<td class="td2"><p class="noindent"><em>w</em>(<em>v</em><sub><em>k</em>−2</sub>, <em>v</em><sub><em>k</em>−1</sub>),</p></td>
</tr>
<tr>
<td class="td2"><p class="right"><em>x</em><sub><em>k</em></sub> − <em>x</em><sub><em>k</em>−1</sub></p></td>
<td class="td2"><p class="center">≤</p></td>
<td class="td2"><p class="noindent"><em>w</em>(<em>v</em><sub><em>k</em>−1</sub>, <em>v<sub>k</sub></em>).</p></td>
</tr>
</table>
<p class="noindent">We’ll assume that <em>x</em> has a solution satisfying each of these <em>k</em> inequalities and then derive a contradiction. The solution must also satisfy the inequality that results from summing the <em>k</em> inequalities together. In summing the left-hand sides, each unknown <em>x<sub>i</sub></em> is added in once and subtracted out once (remember that <em>v</em><sub>1</sub> = <em>v<sub>k</sub></em> implies <em>x</em><sub>1</sub> = <em>x<sub>k</sub></em>), so that the left-hand side sums to 0. The right-hand side sums to the weight <em>w</em>(<em>c</em>) of the cycle, giving 0 ≤ <em>w</em>(<em>c</em>). But since <em>c</em> is a negative-weight cycle, <em>w</em>(<em>c</em>) &lt; 0, and we obtain the contradiction that 0 ≤ <em>w</em>(<em>c</em>) &lt; 0.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Solving systems of difference constraints</strong></p>
<p class="noindent">Theorem 22.9 suggests how to use the Bellman-Ford algorithm to solve a system of difference constraints. Because the constraint graph contains edges from the source vertex <em>v</em><sub>0</sub> to all other vertices, any negative-weight cycle in the constraint graph is reachable from <em>v</em><sub>0</sub>. If the Bellman-Ford algorithm returns <small>TRUE</small>, then the shortest-path weights give a feasible solution to the system. In <a href="chapter022.xhtml#Fig_22-8">Figure 22.8</a>, for example, the shortest-path weights provide the feasible solution <em>x</em> = (−5, −3, 0, −1, −4), and by Lemma 22.8, <em>x</em> = (<em>d</em> − 5, <em>d</em> − 3, <em>d</em>, <em>d</em> − 1, <em>d</em> − 4) is also a feasible solution for any constant <em>d</em>. If the Bellman-Ford algorithm returns <small>FALSE</small>, there is no feasible solution to the system of difference constraints.</p>
<p>A system of difference constraints with <em>m</em> constraints on <em>n</em> unknowns produces a graph with <em>n</em> + 1 vertices and <em>n</em> + <em>m</em> edges. Thus, the Bellman-Ford algorithm provides a way to solve the system in <em>O</em>((<em>n</em> + 1)(<em>n</em> + <em>m</em>)) = <em>O</em>(<em>n</em><sup>2</sup> + <em>nm</em>) time. <a id="p631"/>Exercise 22.4-5 asks you to modify the algorithm to run in <em>O</em>(<em>nm</em>) time, even if <em>m</em> is much less than <em>n</em>.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>22.4-1</em></strong></p>
<p class="noindent">Find a feasible solution or determine that no feasible solution exists for the following system of difference constraints:</p>
<table class="table2b">
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>1</sub> − <em>x</em><sub>2</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">1,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>1</sub> − <em>x</em><sub>4</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">−4,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>2</sub> − <em>x</em><sub>3</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">2,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>2</sub> − <em>x</em><sub>5</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">7,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>2</sub> − <em>x</em><sub>6</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">5,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>3</sub> − <em>x</em><sub>6</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">10,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>4</sub> − <em>x</em><sub>2</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">2,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>5</sub> − <em>x</em><sub>1</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">−1,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>5</sub> − <em>x</em><sub>4</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">3,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>6</sub> − <em>x</em><sub>3</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">−8.</p></td>
</tr>
</table>
<p class="level3"><strong><em>22.4-2</em></strong></p>
<p class="noindent">Find a feasible solution or determine that no feasible solution exists for the following system of difference constraints:</p>
<table class="table2b">
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>1</sub> − <em>x</em><sub>2</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">4,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>1</sub> − <em>x</em><sub>5</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">5,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>2</sub> − <em>x</em><sub>4</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">−6,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>3</sub> − <em>x</em><sub>2</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">1,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>4</sub> − <em>x</em><sub>1</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">3,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>4</sub> − <em>x</em><sub>3</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">5,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>4</sub> − <em>x</em><sub>5</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">10,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>5</sub> − <em>x</em><sub>3</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">−4,</p></td>
</tr>
<tr>
<td class="td2"><p class="noindent"><em>x</em><sub>5</sub> − <em>x</em><sub>4</sub></p></td>
<td class="td2"><p class="noindent">≤</p></td>
<td class="td2"><p class="right">−8.</p></td>
</tr>
</table>
<p class="level3"><strong><em>22.4-3</em></strong></p>
<p class="noindent">Can any shortest-path weight from the new vertex <em>v</em><sub>0</sub> in a constraint graph be positive? Explain.</p>
<p class="level3"><strong><em>22.4-4</em></strong></p>
<p class="noindent">Express the single-pair shortest-path problem as a linear program.</p>
<a id="p632"/>
<p class="level3"><strong><em>22.4-5</em></strong></p>
<p class="noindent">Show how to modify the Bellman-Ford algorithm slightly so that when using it to solve a system of difference constraints with <em>m</em> inequalities on <em>n</em> unknowns, the running time is <em>O</em>(<em>nm</em>).</p>
<p class="level3"><strong><em>22.4-6</em></strong></p>
<p class="noindent">Consider adding <span class="blue"><strong><em>equality constraints</em></strong></span> of the form <em>x<sub>i</sub></em> = <em>x<sub>j</sub></em> + <em>b<sub>k</sub></em> to a system of difference constraints. Show how to solve this variety of constraint system.</p>
<p class="level3"><strong><em>22.4-7</em></strong></p>
<p class="noindent">Show how to solve a system of difference constraints by a Bellman-Ford-like algorithm that runs on a constraint graph without the extra vertex <em>v</em><sub>0</sub>.</p>
<p class="level3"><span class="font1">★</span> <strong><em>22.4-8</em></strong></p>
<p class="noindent">Let <em>Ax</em> ≤ <em>b</em> be a system of <em>m</em> difference constraints in <em>n</em> unknowns. Show that the Bellman-Ford algorithm, when run on the corresponding constraint graph, maximizes <img alt="art" src="images/Art_P651.jpg"/> subject to <em>Ax</em> ≤ <em>b</em> and <em>x<sub>i</sub></em> ≤ 0 for all <em>x<sub>i</sub></em>.</p>
<p class="level3"><span class="font1">★</span> <strong><em>22.4-9</em></strong></p>
<p class="noindent">Show that the Bellman-Ford algorithm, when run on the constraint graph for a system <em>Ax</em> ≤ <em>b</em> of difference constraints, minimizes the quantity (max {<em>x<sub>i</sub></em>}−min {<em>x<sub>i</sub></em>}) subject to <em>Ax</em> ≤ <em>b</em>. Explain how this fact might come in handy if the algorithm is used to schedule construction jobs.</p>
<p class="level3"><strong><em>22.4-10</em></strong></p>
<p class="noindent">Suppose that every row in the matrix <em>A</em> of a linear program <em>Ax</em> ≤ <em>b</em> corresponds to a difference constraint, a single-variable constraint of the form <em>x<sub>i</sub></em> ≤ <em>b<sub>k</sub></em>, or a single-variable constraint of the form −<em>x<sub>i</sub></em> ≤ <em>b<sub>k</sub></em>. Show how to adapt the Bellman-Ford algorithm to solve this variety of constraint system.</p>
<p class="level3"><strong><em>22.4-11</em></strong></p>
<p class="noindent">Give an efficient algorithm to solve a system <em>Ax</em> ≤ <em>b</em> of difference constraints when all of the elements of <em>b</em> are real-valued and all of the unknowns <em>x<sub>i</sub></em> must be integers.</p>
<p class="level3"><span class="font1">★</span> <strong><em>22.4-12</em></strong></p>
<p class="noindent">Give an efficient algorithm to solve a system <em>Ax</em> ≤ <em>b</em> of difference constraints when all of the elements of <em>b</em> are real-valued and a specified subset of some, but not necessarily all, of the unknowns <em>x<sub>i</sub></em> must be integers.</p>
<a id="p633"/>
</section>
<p class="line1"/>
<section title="22.5 Proofs of shortest-paths properties">
<a id="Sec_22.5"/>
<p class="level1" id="h1-133"><a href="toc.xhtml#Rh1-133"><strong>22.5    Proofs of shortest-paths properties</strong></a></p>
<p class="noindent">Throughout this chapter, our correctness arguments have relied on the triangle inequality, upper-bound property, no-path property, convergence property, path-relaxation property, and predecessor-subgraph property. We stated these properties without proof on page 611. In this section, we prove them.</p>
<p class="level4"><strong>The triangle inequality</strong></p>
<p class="noindent">In studying breadth-first search (<a href="chapter020.xhtml#Sec_20.2">Section 20.2</a>), we proved as Lemma 20.1 a simple property of shortest distances in unweighted graphs. The triangle inequality generalizes the property to weighted graphs.</p>
<p class="lem"><strong><em>Lemma 22.10 (Triangle inequality)</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span> and source vertex <em>s</em>. Then, for all edges (<em>u</em>, <em>v</em>) ∈ <em>E</em>,</p>
<p class="eql">δ(<em>s</em>, <em>v</em>) ≤ δ(<em>s</em>, <em>u</em>) + <em>w</em>(<em>u</em>, <em>v</em>).</p>
<p class="prof"><strong><em>Proof</em></strong>   Suppose that <em>p</em> is a shortest path from source <em>s</em> to vertex <em>v</em>. Then <em>p</em> has no more weight than any other path from <em>s</em> to <em>v</em>. Specifically, path <em>p</em> has no more weight than the particular path that takes a shortest path from source <em>s</em> to vertex <em>u</em> and then takes edge (<em>u</em>, <em>v</em>).</p>
<p>Exercise 22.5-3 asks you to handle the case in which there is no shortest path from <em>s</em> to <em>v</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Effects of relaxation on shortest-path estimates</strong></p>
<p class="noindent">The next group of lemmas describes how shortest-path estimates are affected by executing a sequence of relaxation steps on the edges of a weighted, directed graph that has been initialized by I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>.</p>
<p class="lem"><strong><em>Lemma 22.11 (Upper-bound property)</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>. Let <em>s</em> ∈ <em>V</em> be the source vertex, and let the graph be initialized by I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>). Then, <em>v.d</em> ≥ δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>, and this invariant is maintained over any sequence of relaxation steps on the edges of <em>G</em>. Moreover, once <em>v.d</em> achieves its lower bound δ(<em>s</em>, <em>v</em>), it never changes.</p>
<p class="prof"><strong><em>Proof</em></strong>   We prove the invariant <em>v.d</em> ≥ δ(<em>s</em>, <em>v</em>) for all vertices <em>v</em> ∈ <em>V</em> by induction over the number of relaxation steps.</p>
<a id="p634"/>
<p>For the base case, <em>v.d</em> ≥ δ(<em>s</em>, <em>v</em>) holds after initialization, since if <em>v.d</em> = ∞, then <em>v.d</em> ≥ δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em> − {<em>s</em>}, and since <em>s.d</em> = 0 ≥ δ(<em>s</em>, <em>s</em>). (Note that δ(<em>s</em>, <em>s</em>) = −∞ if <em>s</em> is on a negative-weight cycle and that δ(<em>s</em>, <em>s</em>) = 0 otherwise.)</p>
<p>For the inductive step, consider the relaxation of an edge (<em>u</em>, <em>v</em>). By the inductive hypothesis, <em>x.d</em> ≥ δ(<em>s</em>, <em>x</em>) for all <em>x</em> ∈ <em>V</em> prior to the relaxation. The only <em>d</em> value that may change is <em>v.d</em>. If it changes, we have</p>
<table class="table2b">
<tr>
<td class="td2"><em>v.d</em></td>
<td class="td2">=</td>
<td class="td2"><em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>)</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2">δ(<em>s</em>, <em>u</em>) + <em>w</em>(<em>u</em>, <em>v</em>)</td>
<td class="td2">(by the inductive hypothesis)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2">δ(<em>s</em>, <em>v</em>)</td>
<td class="td2">(by the triangle inequality),</td>
</tr>
</table>
<p class="noindent">and so the invariant is maintained.</p>
<p>The value of <em>v.d</em> never changes once <em>v.d</em> = δ(<em>s</em>, <em>v</em>) because, having achieved its lower bound, <em>v.d</em> cannot decrease since we have just shown that <em>v.d</em> ≥ δ(<em>s</em>, <em>v</em>), and it cannot increase because relaxation steps do not increase <em>d</em> values.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 22.12 (No-path property)</em></strong></p>
<p class="noindent">Suppose that in a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, no path connects a source vertex <em>s</em> ∈ <em>V</em> to a given vertex <em>v</em> ∈ <em>V</em>. Then, after the graph is initialized by I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>), we have <em>v.d</em> = δ(<em>s</em>, <em>v</em>) = ∞, and this equation is maintained as an invariant over any sequence of relaxation steps on the edges of <em>G</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   By the upper-bound property, we always have ∞ = δ(<em>s</em>, <em>v</em>) ≤ <em>v.d</em>, and thus <em>v.d</em> = ∞ = δ(<em>s</em>, <em>v</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="lem"><strong><em>Lemma 22.13</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, and let (<em>u</em>, <em>v</em>) ∈ <em>E</em>. Then, immediately after edge (<em>u</em>, <em>v</em>) is relaxed by a call of R<small>ELAX</small>(<em>u</em>, <em>v</em>, <em>w</em>), we have <em>v.d</em> ≤ <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>).</p>
<p class="prof"><strong><em>Proof</em></strong>   If, just prior to relaxing edge (<em>u</em>, <em>v</em>), we have <em>v.d</em> &gt; <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>), then <em>v.d</em> = <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>) afterward. If, instead, <em>v.d</em> ≤ <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>) just before the relaxation, then neither <em>u.d</em> nor <em>v.d</em> changes, and so <em>v.d</em> ≤ <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>) afterward.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="lem"><strong><em>Lemma 22.14 (Convergence property)</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, let <em>s</em> ∈ <em>V</em> be a source vertex, and let <em>s</em> <span class="font1">⇝</span> <em>u</em> → <em>v</em> be a shortest path in <em>G</em> for some vertices <em>u, v</em> ∈ <em>V</em>. Suppose that <em>G</em> is initialized by I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>) and then a sequence of relaxation steps that includes the call <a id="p635"/>R<small>ELAX</small>(<em>u</em>, <em>v</em>, <em>w</em>) is executed on the edges of <em>G</em>. If <em>u.d</em> = δ(<em>s</em>, <em>u</em>) at any time prior to the call, then <em>v.d</em> = δ(<em>s</em>, <em>v</em>) at all times after the call.</p>
<p class="prof"><strong><em>Proof</em></strong>   By the upper-bound property, if <em>u.d</em> = δ(<em>s</em>, <em>u</em>) at some point prior to relaxing edge (<em>u</em>, <em>v</em>), then this equation holds thereafter. In particular, after edge (<em>u</em>, <em>v</em>) is relaxed, we have</p>
<table class="table2b">
<tr>
<td class="td2"><em>v.d</em></td>
<td class="td2">≤</td>
<td class="td2"><em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>)</td>
<td class="td2">(by Lemma 22.13)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">δ(<em>s</em>, <em>u</em>) + <em>w</em>(<em>u</em>, <em>v</em>)</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">δ(<em>s</em>, <em>u</em>)</td>
<td class="td2">(by Lemma 22.1 on page 606).</td>
</tr>
</table>
<p class="noindent">The upper-bound property gives <em>v.d</em> ≥ δ(<em>s</em>, <em>v</em>), from which we conclude that <em>v.d</em> = δ(<em>s</em>, <em>v</em>), and this equation is maintained thereafter.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="lem"><strong><em>Lemma 22.15 (Path-relaxation property)</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, and let <em>s</em> ∈ <em>V</em> be a source vertex. Consider any shortest path <em>p</em> = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span> from <em>s</em> = <em>v</em><sub>0</sub> to <em>v<sub>k</sub></em>. If <em>G</em> is initialized by I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>) and then a sequence of relaxation steps occurs that includes, in order, relaxing the edges (<em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>), (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>), … , (<em>v</em><sub><em>k</em>−1</sub>, <em>v<sub>k</sub></em>), then <em>v<sub>k</sub>.d</em> = δ(<em>s</em>, <em>v<sub>k</sub></em>) after these relaxations and at all times afterward. This property holds no matter what other edge relaxations occur, including relaxations that are intermixed with relaxations of the edges of <em>p</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   We show by induction that after the <em>i</em>th edge of path <em>p</em> is relaxed, we have <em>v<sub>i</sub>.d</em> = δ(<em>s</em>, <em>v<sub>i</sub></em>). For the base case, <em>i</em> = 0, and before any edges of <em>p</em> have been relaxed, we have from the initialization that <em>v</em><sub>0</sub>.<em>d</em> = <em>s.d</em> = 0 = δ(<em>s</em>, <em>s</em>). By the upper-bound property, the value of <em>s.d</em> never changes after initialization.</p>
<p>For the inductive step, assume that <em>v</em><sub><em>i</em>−1</sub>.<em>d</em> = δ(<em>s</em>, <em>v</em><sub><em>i</em>−1</sub>). What happens when edge (<em>v</em><sub><em>i</em>−1</sub>, <em>v<sub>i</sub></em>) is relaxed? By the convergence property, after this relaxation, we have <em>v<sub>i</sub>.d</em> = δ(<em>s</em>, <em>v<sub>i</sub></em>), and this equation is maintained at all times thereafter.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Relaxation and shortest-paths trees</strong></p>
<p class="noindent">We now show that once a sequence of relaxations has caused the shortest-path estimates to converge to shortest-path weights, the predecessor subgraph <em>G</em><sub>π</sub> induced by the resulting π values is a shortest-paths tree for <em>G</em>. We start with the following lemma, which shows that the predecessor subgraph always forms a rooted tree whose root is the source.</p>
<p class="lem"><strong><em>Lemma 22.16</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span> let <em>s</em> ∈ <em>V</em> be a source vertex, and assume that <em>G</em> contains no negative-weight <a id="p636"/>cycles that are reachable from <em>s</em>. Then, after the graph is initialized by I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>), the predecessor subgraph <em>G</em><sub>π</sub> forms a rooted tree with root <em>s</em>, and any sequence of relaxation steps on edges of <em>G</em> maintains this property as an invariant.</p>
<p class="prof"><strong><em>Proof</em></strong>   Initially, the only vertex in <em>G</em><sub>π</sub> is the source vertex, and the lemma is trivially true. Consider a predecessor subgraph <em>G</em><sub>π</sub> that arises after a sequence of relaxation steps. We first prove that <em>G</em><sub>π</sub> is acyclic. Suppose for the sake of contradiction that some relaxation step creates a cycle in the graph <em>G</em><sub>π</sub>. Let the cycle be <em>c</em> = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span>, where <em>v<sub>k</sub></em> = <em>v</em><sub>0</sub>. Then, <em>v<sub>i</sub></em>.π = <em>v</em><sub><em>i</em>−1</sub> for <em>i</em> = 1, 2, … , <em>k</em> and, without loss of generality, assume that relaxing edge (<em>v</em><sub><em>k</em>−1</sub>, <em>v<sub>k</sub></em>) created the cycle in <em>G</em><sub>π</sub>.</p>
<p>We claim that all vertices on cycle <em>c</em> are reachable from the source vertex <em>s</em>. Why? Each vertex on <em>c</em> has a non-<small>NIL</small> predecessor, and so each vertex on <em>c</em> was assigned a finite shortest-path estimate when it was assigned its non-<em>NIL</em> π value. By the upper-bound property, each vertex on cycle <em>c</em> has a finite shortest-path weight, which means that it is reachable from <em>s</em>.</p>
<p>We’ll examine the shortest-path estimates on cycle <em>c</em> immediately before the call R<small>ELAX</small>(<em>v</em><sub><em>k</em>−1</sub>, <em>v<sub>k</sub></em>, <em>w</em>) and show that <em>c</em> is a negative-weight cycle, thereby contradicting the assumption that <em>G</em> contains no negative-weight cycles that are reachable from the source. Just before the call, we have <em>v<sub>i</sub></em>.π = <em>v</em><sub><em>i</em>−1</sub> for <em>i</em> = 1, 2, … , <em>k</em> − 1. Thus, for <em>i</em> = 1, 2, … , <em>k</em> − 1, the last update to <em>v<sub>i</sub>.d</em> was by the assignment <em>v<sub>i</sub>.d</em> = <em>v</em><sub><em>i</em>−1</sub>.<em>d</em>+<em>w</em>(<em>v</em><sub><em>i</em>−1</sub>, <em>v<sub>i</sub></em>). If <em>v</em><sub><em>i</em>−1</sub>.<em>d</em> changed since then, it decreased. Therefore, just before the call R<small>ELAX</small>(<em>v</em><sub><em>k</em>−1</sub>, <em>v<sub>k</sub></em>, <em>w</em>), we have</p>
<p class="eqr"><img alt="art" src="images/Art_P652.jpg"/></p>
<p class="noindent">Because <em>v<sub>k</sub></em>.π is changed by the call R<small>ELAX</small>(<em>v</em><sub><em>k</em>−1</sub>, <em>v<sub>k</sub></em>, <em>w</em>), immediately beforehand we also have the strict inequality</p>
<p class="eql"><em>v<sub>k</sub>.d</em> &gt; <em>v</em><sub><em>k</em>−1</sub>.<em>d</em> + <em>wv</em><sub><em>k</em>−1</sub>, <em>v<sub>k</sub></em>):</p>
<p>Summing this strict inequality with the <em>k</em> − 1 inequalities (22.11), we obtain the sum of the shortest-path estimates around cycle <em>c</em>:</p>
<p class="eql"><img alt="art" src="images/Art_P653.jpg"/></p>
<p class="noindent">But</p>
<p class="eql"><img alt="art" src="images/Art_P654.jpg"/></p>
<a id="p637"/>
<div class="divimage">
<p class="fig-imga" id="Fig_22-9"><img alt="art" src="images/Art_P655.jpg"/></p>
<p class="caption"><strong>Figure 22.9</strong> Showing that a simple path in <em>G</em><sub>π</sub> from source vertex <em>s</em> to vertex <em>v</em> is unique. If <em>G</em><sub>π</sub> contains two paths <em>p</em><sub>1</sub> (<em>s</em> <span class="font1">⇝</span> <em>u</em> <span class="font1">⇝</span> <em>x</em> → <em>z</em> <span class="font1">⇝</span> <em>v</em>) and <em>p</em><sub>2</sub> (<em>s</em> <span class="font1">⇝</span> <em>u</em> <span class="font1">⇝</span> <em>y</em> → <em>z</em> <span class="font1">⇝</span> <em>v</em>), where <em>x</em> ≠ <em>y</em>, then <em>z</em>.π = <em>x</em> and <em>z</em>.π = <em>y</em>, a contradiction.</p>
</div>
<p class="noindent">since each vertex in the cycle <em>c</em> appears exactly once in each summation. This equation implies</p>
<p class="eql"><img alt="art" src="images/Art_P656.jpg"/></p>
<p class="noindent">Thus, the sum of weights around the cycle c is negative, which provides the desired contradiction.</p>
<p>We have now proven that <em>G</em><sub>π</sub> is a directed, acyclic graph. To show that it forms a rooted tree with root <em>s</em>, it suffices (see Exercise B.5-2 on page 1175) to prove that for each vertex <em>v</em> ∈ <em>V</em><sub>π</sub>, there is a unique simple path from <em>s</em> to <em>v</em> in <em>G</em><sub>π</sub>.</p>
<p>The vertices in <em>V</em><sub>π</sub> are those with non-<small>NIL</small> values, plus <em>s</em>. Exercise 22.5-6 asks you to prove that a path from <em>s</em> exists to each vertex in <em>V</em><sub>π</sub>.</p>
<p>To complete the proof of the lemma, we now show that for any vertex <em>v</em> ∈ <em>V</em><sub>π</sub>, the graph <em>G</em><sub>π</sub> contains at most one simple path from <em>s</em> to <em>v</em>. Suppose otherwise. That is, suppose that, as <a href="chapter022.xhtml#Fig_22-9">Figure 22.9</a> illustrates, <em>G</em><sub>π</sub> contains two simple paths from <em>s</em> to some vertex <em>v</em>: <em>p</em><sub>1</sub>, which we decompose into <em>s</em> <span class="font1">⇝</span> <em>u</em> <span class="font1">⇝</span> <em>x</em> → <em>z</em> <span class="font1">⇝</span> <em>v</em>, and <em>p</em><sub>2</sub>, which we decompose into <em>s</em> <span class="font1">⇝</span> <em>u</em> <span class="font1">⇝</span> <em>y</em> → <em>z</em> <span class="font1">⇝</span> <em>v</em>, where <em>x</em> ≠ <em>y</em> (though <em>u</em> could be <em>s</em> and <em>z</em> could be <em>v</em>). But then, <em>z</em>.π = <em>x</em> and <em>z</em>.π = <em>y</em>, which implies the contradiction that <em>x</em> = <em>y</em>. We conclude that <em>G</em><sub>π</sub> contains a unique simple path from <em>s</em> to <em>v</em>, and thus <em>G</em><sub>π</sub> forms a rooted tree with root <em>s</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">We can now show that if all vertices have been assigned their true shortest-path weights after a sequence of relaxation steps, then the predecessor subgraph <em>G</em><sub>π</sub> is a shortest-paths tree.</p>
<p class="lem"><strong><em>Lemma 22.17 (Predecessor-subgraph property)</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, let <em>s</em> ∈ <em>V</em> be a source vertex, and assume that <em>G</em> contains no negative-weight cycles that are reachable from <em>s</em>. Then, after a call to I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>) followed by any sequence of relaxation steps on edges of <em>G</em> that produces <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>, the predecessor subgraph <em>G</em><sub>π</sub> is a shortest-paths tree rooted at <em>s</em>.</p>
<a id="p638"/>
<p class="prof"><strong><em>Proof</em></strong>   We must prove that the three properties of shortest-paths trees given on page 608 hold for <em>G</em><sub>π</sub>. To show the first property, we must show that <em>V</em><sub>π</sub> is the set of vertices reachable from <em>s</em>. By definition, a shortest-path weight δ(<em>s</em>, <em>v</em>) is finite if and only if <em>v</em> is reachable from <em>s</em>, and thus the vertices that are reachable from <em>s</em> are exactly those with finite <em>d</em> values. But a vertex <em>v</em> ∈ <em>V</em> − {<em>s</em>} has been assigned a finite value for <em>v.d</em> if and only if <em>v</em>.π ≠ <small>NIL</small>, since both assignments occur in R<small>ELAX</small>. Thus, the vertices in <em>V</em><sub>π</sub> are exactly those reachable from <em>s</em>.</p>
<p>The second property, that <em>G</em><sub>π</sub> forms a rooted tree with root <em>s</em>, follows directly from Lemma 22.16.</p>
<p>It remains, therefore, to prove the last property of shortest-paths trees: for each vertex <em>v</em> ∈ <em>V</em><sub>π</sub>, the unique simple path <img alt="art" src="images/Art_P657.jpg"/> in <em>G</em><sub>π</sub> is a shortest path from <em>s</em> to <em>v</em> in <em>G</em>. Let <em>p</em> = <span class="font1">〈</span><em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em><span class="font1">〉</span>, where <em>v</em><sub>0</sub> = <em>s</em> and <em>v<sub>k</sub></em> = <em>v</em>. Consider an edge (<em>v</em><sub><em>i</em>−1</sub>, <em>v<sub>i</sub></em>) in path <em>p</em>. Because this edge belongs to <em>G</em><sub>π</sub>, the last relaxation that changed <em>v<sub>i</sub>.d</em> must have been of this edge. After that relaxation, we had <em>v<sub>i</sub>.d</em> = <em>v</em><sub><em>i</em>−1</sub>.<em>d</em> + (<em>v</em><sub><em>i</em>−1</sub>, <em>v<sub>i</sub></em>). Subsequently, an edge entering <em>v</em><sub><em>i</em>−1</sub> could have been relaxed, causing <em>v</em><sub><em>i</em>−1</sub>.<em>d</em> to decrease further, but without changing <em>v<sub>i</sub>.d</em>. Therefore, we have <em>v<sub>i</sub>.d</em> ≥ <em>v</em><sub><em>i</em>−1</sub>.<em>d</em> + <em>w</em>(<em>v</em><sub><em>i</em>−1</sub>, <em>v<sub>i</sub></em>). Thus, for <em>i</em> = 1, 2, … , <em>k</em>, we have both <em>v<sub>i</sub>.d</em> = δ(<em>s</em>, <em>v<sub>i</sub></em>) and <em>v<sub>i</sub>.d</em> ≥ <em>v</em><sub><em>i</em>−1</sub>.<em>d</em> + <em>w</em>(<em>v</em><sub><em>i</em>−1</sub>, <em>v<sub>i</sub></em>), which together imply <em>w</em>(<em>v</em><sub><em>i</em>−1</sub>, <em>v<sub>i</sub></em>) ≤ δ(<em>s</em>, <em>v<sub>i</sub></em>) − δ(<em>s</em>, <em>v</em><sub><em>i</em>−1</sub>). Summing the weights along path <em>p</em> yields</p>
<p class="eql"><img alt="art" src="images/Art_P658.jpg"/></p>
<p class="noindent">Thus, we have <em>w</em>(<em>p</em>) ≤ δ(<em>s</em>, <em>v<sub>k</sub></em>). Since δ(<em>s</em>, <em>v<sub>k</sub></em>) is a lower bound on the weight of any path from <em>s</em> to <em>v<sub>k</sub></em>, we conclude that <em>w</em>(<em>p</em>) = δ(<em>s</em>, <em>v<sub>k</sub></em>), and <em>p</em> is a shortest path from <em>s</em> to <em>v</em> = <em>v<sub>k</sub></em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>22.5-1</em></strong></p>
<p class="noindent">Give two shortest-paths trees for the directed graph of <a href="chapter022.xhtml#Fig_22-2">Figure 22.2</a> on page 609 other than the two shown.</p>
<p class="level3"><strong><em>22.5-2</em></strong></p>
<p class="noindent">Give an example of a weighted, directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span> and source vertex <em>s</em> such that <em>G</em> satisfies the following property: For <a id="p639"/>every edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>, there is a shortest-paths tree rooted at <em>s</em> that contains (<em>u</em>, <em>v</em>) and another shortest-paths tree rooted at <em>s</em> that does not contain (<em>u</em>, <em>v</em>).</p>
<p class="level3"><strong><em>22.5-3</em></strong></p>
<p class="noindent">Modify the proof of Lemma 22.10 to handle cases in which shortest-path weights are ∞ or −∞.</p>
<p class="level3"><strong><em>22.5-4</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with source vertex <em>s</em>, and let <em>G</em> be initialized by I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>). Prove that if a sequence of relaxation steps sets <em>s</em>.π to a non-<small>NIL</small> value, then <em>G</em> contains a negative-weight cycle.</p>
<p class="level3"><strong><em>22.5-5</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with no negative-weight edges. Let <em>s</em> ∈ <em>V</em> be the source vertex, and suppose that <em>v</em>.π is allowed to be the predecessor of <em>v</em> on <em>any</em> shortest path to <em>v</em> from source <em>s</em> if <em>v</em> ∈ <em>V</em> − {<em>s</em>} is reachable from <em>s</em>, and <small>NIL</small> otherwise. Give an example of such a graph <em>G</em> and an assignment of π values that produces a cycle in <em>G</em><sub>π</sub>. (By Lemma 22.16, such an assignment cannot be produced by a sequence of relaxation steps.)</p>
<p class="level3"><strong><em>22.5-6</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span> and no negative-weight cycles. Let <em>s</em> ∈ <em>V</em> be the source vertex, and let <em>G</em> be initialized by I<small>NITIALIZE</small>-S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>). Use induction to prove that for every vertex <em>v</em> ∈ <em>V</em><sub>π</sub>, there exists a path from <em>s</em> to <em>v</em> in <em>G</em><sub>π</sub> and that this property is maintained as an invariant over any sequence of relaxations.</p>
<p class="level3"><strong><em>22.5-7</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted, directed graph that contains no negative-weight cycles. Let <em>s</em> ∈ <em>V</em> be the source vertex, and let <em>G</em> be initialized by I<small>NITIALIZE</small>S<small>INGLE</small>-S<small>OURCE</small>(<em>G</em>, <em>s</em>). Prove that there exists a sequence of |<em>V</em>| − 1 relaxation steps that produces <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>.</p>
<p class="level3"><strong><em>22.5-8</em></strong></p>
<p class="noindent">Let <em>G</em> be an arbitrary weighted, directed graph with a negative-weight cycle reachable from the source vertex s. Show how to construct an infinite sequence of relaxations of the edges of <em>G</em> such that every relaxation causes a shortest-path estimate to change.</p>
<a id="p640"/>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-134"><strong>Problems</strong></p>
<section title="22-1 Yen’s improvement to Bellman-Ford">
<p class="level2"><strong><em>22-1     Yen’s improvement to Bellman-Ford</em></strong></p>
<p class="noindent">The Bellman-Ford algorithm does not specify the order in which to relax edges in each pass. Consider the following method for deciding upon the order. Before the first pass, assign an arbitrary linear order <em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, … , <em>v</em><sub>|<em>V</em>|</sub> to the vertices of the input graph <em>G</em> = (<em>V</em>, <em>E</em>). Then partition the edge set <em>E</em> into <em>E<sub>f</sub></em> ∪ <em>E<sub>b</sub></em>, where <em>E<sub>f</sub></em> = {(<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>) ∈ <em>E</em> : <em>i</em> &lt; <em>j</em>} and <em>E<sub>b</sub></em> = {(<em>v<sub>i</sub></em>, <em>v<sub>j</sub></em>) ∈ <em>E</em> : <em>i</em> &gt; <em>j</em>}. (Assume that <em>G</em> contains no self-loops, so that every edge belongs to either <em>E<sub>f</sub></em> or <em>E<sub>b</sub></em>.) Define <em>G<sub>f</sub></em> = (<em>V</em>, <em>E<sub>f</sub></em>) and <em>G<sub>b</sub></em> = (<em>V</em>, <em>E<sub>b</sub></em>).</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Prove that <em>G<sub>f</sub></em> is acyclic with topological sort <span class="font1">〈</span><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, … , <em>v</em><sub>|<em>V</em>|</sub><span class="font1">〉</span> and that <em>G<sub>b</sub></em> is acyclic with topological sort <span class="font1">〈</span><em>v</em><sub>|<em>V</em>|</sub>, <em>v</em><sub>|<em>V</em>|−1</sub>, … , <em>v</em><sub>1</sub><span class="font1">〉</span>.</p>
<p class="noindent1-top">Suppose that each pass of the Bellman-Ford algorithm relaxes edges in the following way. First, visit each vertex in the order <em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, … , <em>v</em><sub>|<em>V</em>|</sub>, relaxing edges of <em>E<sub>f</sub></em> that leave the vertex. Then visit each vertex in the order <em>v</em><sub>|<em>V</em>|</sub>, <em>v</em><sub>|<em>V</em>|−1</sub>, …, <em>v</em><sub>1</sub>, relaxing edges of <em>E<sub>b</sub></em> that leave the vertex.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Prove that with this scheme, if <em>G</em> contains no negative-weight cycles that are reachable from the source vertex <em>s</em>, then after only <span class="font1">⌈</span>|<em>V</em>| / 2<span class="font1">⌉</span> passes over the edges, <em>v.d</em> = δ(<em>s</em>, <em>v</em>) for all vertices <em>v</em> ∈ <em>V</em>.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Does this scheme improve the asymptotic running time of the Bellman-Ford algorithm?</p>
</section>
<section title="22-2 Nesting boxes">
<p class="level2"><strong><em>22-2     Nesting boxes</em></strong></p>
<p class="noindent">A <em>d</em>-dimensional box with dimensions (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, … , <em>x<sub>d</sub></em>) <span class="blue"><strong><em>nests</em></strong></span> within another box with dimensions (<em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>, … , <em>y<sub>d</sub></em>) if there exists a permutation π on {1, 2, … , <em>d</em>} such that <em>x</em><sub>π(1)</sub> &lt; <em>y</em><sub>1</sub>, <em>x</em><sub>π(2)</sub> &lt; <em>y</em><sub>2</sub>, … , <em>x</em><sub>π(<em>d</em>)</sub> &lt; <em>y<sub>d</sub></em>.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Argue that the nesting relation is transitive.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Describe an efficient method to determine whether one <em>d</em>-dimensional box nests inside another.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> You are given a set of <em>n d</em>-dimensional boxes {<em>B</em><sub>1</sub>, <em>B</em><sub>2</sub>, … , <em>B<sub>n</sub></em>}. Give an efficient algorithm to find the longest sequence <img alt="art" src="images/Art_P660.jpg"/> of boxes such that <img alt="art" src="images/Art_P661.jpg"/> nests within <img alt="art" src="images/Art_P662.jpg"/> for <em>j</em> = 1, 2, … , <em>k</em> − 1. Express the running time of your algorithm in terms of <em>n</em> and <em>d</em>.</p>
<a id="p641"/>
</section>
<section title="22-3 Arbitrage">
<p class="level2"><strong><em>22-3     Arbitrage</em></strong></p>
<p class="noindent"><span class="blue"><strong><em>Arbitrage</em></strong></span> is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that one U.S. dollar buys 64 Indian rupees, one Indian rupee buys 1:8 Japanese yen, and one Japanese yen buys 0:009 U.S. dollars. Then, by converting currencies, a trader can start with 1 U.S. dollar and buy 64 × 1.8 × 0.009 = 1.0368 U.S. dollars, thus turning a profit of 3.68%.</p>
<p>Suppose that you are given <em>n</em> currencies <em>c</em><sub>1</sub>, <em>c</em><sub>2</sub>, … , <em>c<sub>n</sub></em> and an <em>n</em> × <em>n</em> table <em>R</em> of exchange rates, such that 1 unit of currency <em>c<sub>i</sub></em> buys <em>R</em>[<em>i</em>, <em>j</em>] units of currency <em>c<sub>j</sub></em>.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Give an efficient algorithm to determine whether there exists a sequence of currencies <img alt="art" src="images/Art_P663.jpg"/> such that</p>
<p class="nl-para1-d"><em>R</em>[<em>i</em><sub>1</sub>, <em>i</em><sub>2</sub>] · <em>R</em>[<em>i</em><sub>2</sub>, <em>i</em><sub>3</sub>] … <em>R</em>[<em>i</em><sub><em>k</em>−1</sub>, <em>i<sub>k</sub></em>] · <em>R</em>[<em>i<sub>k</sub></em>, <em>i</em><sub>1</sub>] &gt; 1.</p>
<p class="nl-para1-d">Analyze the running time of your algorithm.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Give an efficient algorithm to print out such a sequence if one exists. Analyze the running time of your algorithm.</p>
</section>
<section title="22-4 Gabow’s scaling algorithm for single-source shortest paths">
<p class="level2"><strong><em>22-4     Gabow’s scaling algorithm for single-source shortest paths</em></strong></p>
<p class="noindent">A <span class="blue"><strong><em>scaling</em></strong></span> algorithm solves a problem by initially considering only the highest-order bit of each relevant input value, such as an edge weight, assuming that these values are nonnegative integers. The algorithm then refines the initial solution by looking at the two highest-order bits. It progressively looks at more and more high-order bits, refining the solution each time, until it has examined all bits and computed the correct solution.</p>
<p>This problem examines an algorithm for computing the shortest paths from a single source by scaling edge weights. The input is a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with nonnegative integer edge weights <em>w</em>. Let <em>W</em> = max {<em>w</em>(<em>u</em>, <em>v</em>) : (<em>u</em>, <em>v</em>) = <em>E</em>} be the maximum weight of any edge. In this problem, you will develop an algorithm that runs in <em>O</em>(<em>E</em> lg <em>W</em>) time. Assume that all vertices are reachable from the source.</p>
<p>The scaling algorithm uncovers the bits in the binary representation of the edge weights one at a time, from the most significant bit to the least significant bit. Specifically, let <em>k</em> = <span class="font1">⌈</span>lg(<em>W</em> + 1)<span class="font1">⌉</span> be the number of bits in the binary representation of <em>W</em>, and for <em>i</em> = 1, 2, … , <em>k</em>, let <em>w<sub>i</sub></em>(<em>u</em>,<em>v</em>) = <span class="font1">⌊</span><em>w</em>(<em>u</em>,<em>v</em>)/2<sup><em>k</em>–<em>i</em></sup><span class="font1">⌋</span>. That is, <em>w<sub>i</sub></em> (<em>u</em>, <em>v</em>) is the “scaled-down” version of <em>w</em>(<em>u</em>, <em>v</em>) given by the <em>i</em> most significant bits of <em>w</em>(<em>u</em>, <em>v</em>). (Thus, <em>w<sub>k</sub></em>(<em>u</em>, <em>v</em>) = <em>w</em>(<em>u</em>, <em>v</em>) for all (<em>u</em>, <em>v</em>) ∈ <em>E</em>.) For example, if <em>k</em> = 5 and <em>w</em>(<em>u</em>, <em>v</em>) = 25, which has the binary representation <span class="font1">〈</span>11001<span class="font1">〉</span>, then <em>w</em><sub>3</sub>(<em>u</em>, <em>v</em>) = <span class="font1">〈</span>110<span class="font1">〉</span> = 6. Also with <em>k</em> = 5, if <em>w</em>(<em>u</em>, <em>v</em>) = <span class="font1">〈</span>00100<span class="font1">〉</span> = 4, then <em>w</em><sub>4</sub>(<em>u</em>, <em>v</em>) = <span class="font1">〈</span>0010<span class="font1">〉</span> = 2. Define δ<sub><em>i</em></sub>(<em>u</em>, <em>v</em>) as the shortest-path weight from vertex <em>u</em> <a id="p642"/>to vertex <em>v</em> using weight function <em>w<sub>i</sub></em>, so that δ<sub><em>k</em></sub>(<em>u</em>, <em>v</em>) = δ(<em>u</em>, <em>v</em>) for all <em>u</em>, <em>v</em> ∈ <em>V</em>. For a given source vertex <em>s</em>, the scaling algorithm first computes the shortest-path weights δ<sub>1</sub>(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>, then computes δ<sub>2</sub>(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>, and so on, until it computes δ<sub><em>k</em></sub>(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em>. Assume throughout that |<em>E</em>| ≥ |<em>V</em>| − 1. You will show how to compute δ<sub><em>i</em></sub> from δ<sub><em>i</em>−1</sub> in <em>O</em>(<em>E</em>) time, so that the entire algorithm takes <em>O</em>(<em>kE</em>) = <em>O</em>(<em>E</em> lg <em>W</em>) time.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Suppose that for all vertices <em>v</em> ∈ <em>V</em>, we have δ(<em>s</em>, <em>v</em>) ≤ |<em>E</em>|. Show how to compute δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em> in <em>O</em>(<em>E</em>) time.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Show how to compute δ<sub>1</sub>(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em> in <em>O</em>(<em>E</em>) time.</p>
<p class="noindent1-top">Now focus on computing δ<sub>i</sub> from δ<sub><em>i</em>−1</sub>.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Prove that for <em>i</em> = 2, 3, … , <em>k</em>, either <em>w<sub>i</sub></em>(<em>u</em>, <em>v</em>) = 2<em>w</em><sub><em>i</em>−1</sub>(<em>u</em>, <em>v</em>) or <em>w<sub>i</sub></em>(<em>u</em>, <em>v</em>) = 2<em>w</em><sub><em>i</em>−1</sub>(<em>u</em>, <em>v</em>) + 1. Then prove that</p>
<p class="nl-para1-d">2δ<sub><em>i</em>−1</sub>(<em>s</em>, <em>v</em>) ≤ δ<sub><em>i</em></sub>(<em>s</em>, <em>v</em>) ≤ 2δ<sub><em>i</em>−1</sub>(<em>s</em>, <em>v</em>) + |<em>V</em>| − 1</p>
<p class="nl-para1-d">for all <em>v</em> ∈ <em>V</em>.</p>
<p class="nl-1list-d"><strong><em>d.</em></strong> Define, for <em>i</em> = 2, 3, … , <em>k</em> and all (<em>u</em>, <em>v</em>) ∈ <em>E</em>,</p>
<p class="nl-para1-d"><em><span class="font1">ŵ</span></em><sub><em>i</em></sub>(<em>u</em>, <em>v</em>) = <em>w<sub>i</sub></em>(<em>u</em>, <em>v</em>) + 2δ<sub><em>i</em>−1</sub>(<em>s</em>, <em>u</em>) − 2δ<sub><em>i</em>−1</sub>(<em>s</em>, <em>v</em>).</p>
<p class="nl-para1-d">Prove that for <em>i</em> = 2, 3, … , <em>k</em> and all <em>u</em>, <em>v</em> ∈ <em>V</em>, the “reweighted” value <em><span class="font1">ŵ</span><sub>i</sub></em>(<em>u</em>, <em>v</em>) of edge (<em>u</em>, <em>v</em>) is a nonnegative integer.</p>
<p class="nl-1list-d"><strong><em>e.</em></strong> Now define <img alt="art" src="images/Art_P666.jpg"/> as the shortest-path weight from <em>s</em> to <em>v</em> using the weight function <em><span class="font1">ŵ</span><sub>i</sub></em>. Prove that for <em>i</em> = 2, 3, … , <em>k</em> and all <em>v</em> ∈ <em>V</em>,</p>
<p class="nl-para1-d"><img alt="art" src="images/Art_P667.jpg"/></p>
<p class="nl-para1-d">and that <img alt="art" src="images/Art_P668.jpg"/>.</p>
<p class="nl-1list-d"><strong><em>f.</em></strong> Show how to compute δ<sub><em>i</em></sub>(<em>s</em>, <em>v</em>) from δ<sub><em>i</em>−1</sub>(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em> in <em>O</em>(<em>E</em>) time. Conclude that you can compute δ(<em>s</em>, <em>v</em>) for all <em>v</em> ∈ <em>V</em> in <em>O</em>(<em>E</em> lg <em>W</em>) time.</p>
</section>
<section title="22-5 Karp’s minimum mean-weight cycle algorithm">
<p class="level2"><strong><em>22-5     Karp’s minimum mean-weight cycle algorithm</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a directed graph with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, and let <em>n</em> = |<em>V</em>|. We define the <span class="blue"><strong><em>mean weight</em></strong></span> of a cycle <em>c</em> = <span class="font1">〈</span><em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>, … , <em>e<sub>k</sub></em><span class="font1">〉</span> of edges in <em>E</em> to be</p>
<a id="p643"/>
<p class="eql"><img alt="art" src="images/Art_P669.jpg"/></p>
<p class="noindent">Let μ* = min {μ(<em>c</em>) : <em>c</em> is a directed cycle in <em>G</em>}. We call a cycle <em>c</em> for which μ(<em>c</em>) = μ* a <span class="blue"><strong><em>minimum mean-weight cycle</em></strong></span>. This problem investigates an efficient algorithm for computing μ*.</p>
<p>Assume without loss of generality that every vertex <em>v</em> ∈ <em>V</em> is reachable from a source vertex <em>s</em> ∈ <em>V</em>. Let δ(<em>s</em>, <em>v</em>) be the weight of a shortest path from <em>s</em> to <em>v</em>, and let δ<sub><em>k</em></sub>(<em>s</em>, <em>v</em>) be the weight of a shortest path from <em>s</em> to <em>v</em> consisting of <em>exactly k</em> edges. If there is no path from <em>s</em> to <em>v</em> with exactly <em>k</em> edges, then δ<sub><em>k</em></sub>(<em>s</em>, <em>v</em>) = ∞.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Show that if μ* = 0, then <em>G</em> contains no negative-weight cycles and δ(<em>s</em>, <em>v</em>) = min {δ<sub><em>k</em></sub>(<em>s</em>, <em>v</em>) : 0 ≤ <em>k</em> ≤ <em>n</em> − 1} for all vertices <em>v</em> ∈ <em>V</em>.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Show that if μ* = 0, then</p>
<p class="nl-para1-d"><img alt="art" src="images/Art_P670.jpg"/></p>
<p class="nl-para1-d">for all vertices <em>v</em> ∈ <em>V</em>. (<em>Hint:</em> Use both properties from part (a).)</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Let <em>c</em> be a 0-weight cycle, and let <em>u</em> and <em>v</em> be any two vertices on <em>c</em>. Suppose that μ* = 0 and that the weight of the simple path from <em>u</em> to <em>v</em> along the cycle is <em>x</em>. Prove that δ(<em>s</em>, <em>v</em>) = δ(<em>s</em>, <em>u</em>) + <em>x</em>. (<em>Hint:</em> The weight of the simple path from <em>v</em> to <em>u</em> along the cycle is −<em>x</em>.)</p>
<p class="nl-1list-d"><strong><em>d.</em></strong> Show that if μ* = 0, then on each minimum mean-weight cycle there exists a vertex <em>v</em> such that</p>
<p class="nl-para1-d"><img alt="art" src="images/Art_P671.jpg"/></p>
<p class="nl-para1-d">(<em>Hint:</em> Show how to extend a shortest path to any vertex on a minimum mean-weight cycle along the cycle to make a shortest path to the next vertex on the cycle.)</p>
<p class="nl-1list-d"><strong><em>e.</em></strong> Show that if μ* = 0, then the minimum value of</p>
<p class="nl-para1-d"><img alt="art" src="images/Art_P672.jpg"/></p>
<p class="nl-para1-d">taken over all vertices <em>v</em> ∈ <em>V</em>, equals 0.</p>
<a id="p644"/>
<p class="nl-1list-d"><strong><em>f.</em></strong> Show that if you add a constant <em>t</em> to the weight of each edge of <em>G</em>, then μ* increases by <em>t</em>. Use this fact to show that μ* equals the minimum value of</p>
<p class="nl-para1-d"><img alt="art" src="images/Art_P673.jpg"/></p>
<p class="nl-para1-d">taken over all vertices <em>v</em> ∈ <em>V</em>.</p>
<p class="nl-1list-d"><strong><em>g.</em></strong> Give an <em>O</em>(<em>VE</em>)-time algorithm to compute μ*.</p>
</section>
<section title="22-6 Bitonic shortest paths">
<p class="level2"><strong><em>22-6     Bitonic shortest paths</em></strong></p>
<p class="noindent">A sequence is <span class="blue"><strong><em>bitonic</em></strong></span> if it monotonically increases and then monotonically decreases, or if by a circular shift it monotonically increases and then monotonically decreases. For example the sequences <span class="font1">〈</span>1, 4, 6, 8, 3, −2<span class="font1">〉</span>, <span class="font1">〈</span>9, 2, −4, −10, −5<span class="font1">〉</span>, and <span class="font1">〈</span>1, 2, 3, 4<span class="font1">〉</span> are bitonic, but <span class="font1">〈</span>1, 3, 12, 4, 2, 10<span class="font1">〉</span> is not bitonic. (See Problem 14-3 on page 407 for the bitonic euclidean traveling-salesperson problem.)</p>
<p>Suppose that you are given a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) with weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, where all edge weights are unique, and you wish to find single-source shortest paths from a source vertex <em>s</em>. You are given one additional piece of information: for each vertex <em>v</em> ∈ <em>V</em>, the weights of the edges along any shortest path from <em>s</em> to <em>v</em> form a bitonic sequence.</p>
<p>Give the most efficient algorithm you can to solve this problem, and analyze its running time.</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-135"><strong>Chapter notes</strong></p>
<p class="noindent">The shortest-path problem has a long history that is nicely desribed in an article by Schrijver [<a epub:type="noteref" href="bibliography001.xhtml#endnote_400">400</a>]. He credits the general idea of repeatedly executing edge relaxations to Ford [<a epub:type="noteref" href="bibliography001.xhtml#endnote_148">148</a>]. Dijkstra’s algorithm [<a epub:type="noteref" href="bibliography001.xhtml#endnote_116">116</a>] appeared in 1959, but it contained no mention of a priority queue. The Bellman-Ford algorithm is based on separate algorithms by Bellman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_45">45</a>] and Ford [<a epub:type="noteref" href="bibliography001.xhtml#endnote_149">149</a>]. The same algorithm is also attributed to Moore [<a epub:type="noteref" href="bibliography001.xhtml#endnote_334">334</a>]. Bellman describes the relation of shortest paths to difference constraints. Lawler [<a epub:type="noteref" href="bibliography001.xhtml#endnote_276">276</a>] describes the linear-time algorithm for shortest paths in a dag, which he considers part of the folklore.</p>
<p>When edge weights are relatively small nonnegative integers, more efficient algorithms result from using min-priority queues that require integer keys and rely on the sequence of values returned by the E<small>XTRACT</small>-M<small>IN</small> calls in Dijkstra’s algorithm monotonically increasing over time. Ahuja, Mehlhorn, Orlin, and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_8">8</a>] give an algorithm that runs in <img alt="art" src="images/Art_P674.jpg"/> time on graphs with nonnegative edge weights, where <em>W</em> is the largest weight of any edge in the <a id="p645"/>graph. The best bounds are by Thorup [<a epub:type="noteref" href="bibliography001.xhtml#endnote_436">436</a>], who gives an algorithm that runs in <em>O</em>(<em>E</em> lg lg <em>V</em>) time, and by Raman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_375">375</a>], who gives an algorithm that runs in <em>O</em>(<em>E</em> + <em>V</em> min {(lg <em>V</em>)<sup>1/3+ε</sup>, (lg <em>W</em>)<sup>1/4+ε</sup>}) time. These two algorithms use an amount of space that depends on the word size of the underlying machine. Although the amount of space used can be unbounded in the size of the input, it can be reduced to be linear in the size of the input using randomized hashing.</p>
<p>For undirected graphs with integer weights, Thorup [<a epub:type="noteref" href="bibliography001.xhtml#endnote_435">435</a>] gives an algorithm that runs in <em>O</em>(<em>V</em> + <em>E</em>) time for single-source shortest paths. In contrast to the algorithms mentioned in the previous paragraph, the sequence of values returned by E<small>XTRACT</small>-M<small>IN</small> calls does not monotonically increase over time, and so this algorithm is not an implementation of Dijkstra’s algorithm. Pettie and Ramachandran [<a epub:type="noteref" href="bibliography001.xhtml#endnote_357">357</a>] remove the restriction of integer weights on undirected graphs. Their algorithm entails a preprocessing phase, followed by queries for specific source vertices. Preprocessing takes <em>O</em>(<em>MST</em>(<em>V</em>, <em>E</em>) + min {<em>V</em> lg <em>V</em>, <em>V</em> lg lg r}) time, where <em>MST</em>(<em>V</em>, <em>E</em>) is the time to compute a minimum spanning tree and <em>r</em> is the ratio of the maximum edge weight to the minimum edge weight. After preprocessing, each query takes <img alt="art" src="images/Art_P675.jpg"/> time, where <img alt="art" src="images/Art_P676.jpg"/> is the inverse of Ackermann’s function. (See the chapter notes for <a href="chapter019.xhtml">Chapter 19</a> for a brief discussion of Ackermann’s function and its inverse.)</p>
<p>For graphs with negative edge weights, an algorithm due to Gabow and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_167">167</a>] runs in <img alt="art" src="images/Art_P677.jpg"/> time, and one by Goldberg [<a epub:type="noteref" href="bibliography001.xhtml#endnote_186">186</a>] runs in <img alt="art" src="images/Art_P678.jpg"/> time, where <em>W</em> = max {|<em>w</em>(<em>u</em>, <em>v</em>)| : (<em>u</em>, <em>v</em>) ∈ <em>E</em>}. There has also been some progress based on methods that use continuous optimization and electrical flows. Cohen et al. [<a epub:type="noteref" href="bibliography001.xhtml#endnote_98">98</a>] give such an algorithm, which is randomized and runs in <em>Õ</em>(<em>E</em><sup>10/7</sup> lg <em>W</em>) expected time (see Problem 3-6 on page 73 for the defintion of <em>Õ</em>-notation). There is also a pseudopolyomial-time algorithm based on fast matrix multiplication. Sankowski [<a epub:type="noteref" href="bibliography001.xhtml#endnote_394">394</a>] and Yuster and Zwick [<a epub:type="noteref" href="bibliography001.xhtml#endnote_465">465</a>] designed an algorithm for shortest paths that runs in <em>Õ</em>(<em>W V</em><sup>ω</sup>) time, where two <em>n</em> × <em>n</em> matrices can be multiplied in <em>O</em>(<em>n</em><sup>ω</sup>) time, giving a faster algorithm than the previously mentioned algorithms for small values of <em>W</em> on dense graphs.</p>
<p>Cherkassky, Goldberg, and Radzik [<a epub:type="noteref" href="bibliography001.xhtml#endnote_89">89</a>] conducted extensive experiments comparing various shortest-path algorithms. Shortest-path algorithms are widely used in real-time navigation and route-planning applications. Typically based on Dijkstra’s algorithm, these algorithms use many clever ideas to be able to compute shortest paths on networks with many millions of vertices and edges in fractions of a second. Bast et al. [<a epub:type="noteref" href="bibliography001.xhtml#endnote_36">36</a>] survey many of these developments.</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> It may seem strange that the term “relaxation” is used for an operation that tightens an upper bound. The use of the term is historical. The outcome of a relaxation step can be viewed as a relaxation of the constraint <em>v.d</em> ≤ <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>), which, by the triangle inequality (Lemma 22.10 on page 633), must be satisfied if <em>u.d</em> = δ(<em>s</em>, <em>u</em>) and <em>v.d</em> = δ(<em>s</em>, <em>v</em>). That is, if <em>v.d</em> ≤ <em>u.d</em> + <em>w</em>(<em>u</em>, <em>v</em>), there is no “pressure” to satisfy this constraint, so the constraint is “relaxed.”</p>
<p class="footnote1" id="footnote_2"><a href="#footnote_ref_2"><sup>2</sup></a> “PERT” is an acronym for “program evaluation and review technique.”</p>
</section>
</section>
</div>
</body>
</html>