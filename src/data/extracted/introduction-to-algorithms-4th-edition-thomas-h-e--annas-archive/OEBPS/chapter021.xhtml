<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p585"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="21 Minimum Spanning Trees">
<p class="chapter-title"><a href="toc.xhtml#chap-21"><strong><span class="blue1">21        Minimum Spanning Trees</span></strong></a></p>
<p class="noindent">Electronic circuit designs often need to make the pins of several components electrically equivalent by wiring them together. To interconnect a set of <em>n</em> pins, the designer can use an arrangement of <em>n</em> − 1 wires, each connecting two pins. Of all such arrangements, the one that uses the least amount of wire is usually the most desirable.</p>
<p>To model this wiring problem, use a connected, undirected graph <em>G</em> = (<em>V</em>, <em>E</em>), where <em>V</em> is the set of pins, <em>E</em> is the set of possible interconnections between pairs of pins, and for each edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>, a weight <em>w</em>(<em>u</em>, <em>v</em>) specifies the cost (amount of wire needed) to connect <em>u</em> and <em>v</em>. The goal is to find an acyclic subset <em>T</em> ⊆ <em>E</em> that connects all of the vertices and whose total weight</p>
<p class="eql"><img alt="art" src="images/Art_P618.jpg"/></p>
<p class="noindent">is minimized. Since <em>T</em> is acyclic and connects all of the vertices, it must form a tree, which we call a <span class="blue"><strong><em>spanning tree</em></strong></span> since it “spans” the graph <em>G</em>. We call the problem of determining the tree <em>T</em> the <span class="blue"><strong><em>minimum-spanning-tree problem</em></strong></span>.<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup> <a href="chapter021.xhtml#Fig_21-1">Figure 21.1</a> shows an example of a connected graph and a minimum spanning tree.</p>
<p>This chapter studies two ways to solve the minimum-spanning-tree problem. Kruskal’s algorithm and Prim’s algorithm both run in <em>O</em>(<em>E</em> lg <em>V</em>) time. Prim’s algorithm achieves this bound by using a binary heap as a priority queue. By using Fibonacci heaps instead (see page 478), Prim’s algorithm runs in <em>O</em>(<em>E</em> + <em>V</em> lg <em>V</em>) time. This bound is better than <em>O</em>(<em>E</em> lg <em>V</em>) whenever |<em>E</em>| grows asymptotically faster than |<em>V</em>|.</p>
<a id="p586"/>
<div class="divimage">
<p class="fig-imga" id="Fig_21-1"><img alt="art" src="images/Art_P619.jpg"/></p>
<p class="caption"><strong>Figure 21.1</strong> A minimum spanning tree for a connected graph. The weights on edges are shown, and the blue edges form a minimum spanning tree. The total weight of the tree shown is 37. This minimum spanning tree is not unique: removing the edge (<em>b</em>, <em>c</em>) and replacing it with the edge (<em>a</em>, <em>h</em>) yields another spanning tree with weight 37.</p>
</div>
<p>The two algorithms are greedy algorithms, as described in <a href="chapter015.xhtml">Chapter 15</a>. Each step of a greedy algorithm must make one of several possible choices. The greedy strategy advocates making the choice that is the best at the moment. Such a strategy does not generally guarantee that it always finds globally optimal solutions to problems. For the minimum-spanning-tree problem, however, we can prove that certain greedy strategies do yield a spanning tree with minimum weight. Although you can read this chapter independently of <a href="chapter015.xhtml">Chapter 15</a>, the greedy methods presented here are a classic application of the theoretical notions introduced there.</p>
<p><a href="chapter021.xhtml#Sec_21.1">Section 21.1</a> introduces a “generic” minimum-spanning-tree method that grows a spanning tree by adding one edge at a time. <a href="chapter021.xhtml#Sec_21.2">Section 21.2</a> gives two algorithms that implement the generic method. The first algorithm, due to Kruskal, is similar to the connected-components algorithm from <a href="chapter019.xhtml#Sec_19.1">Section 19.1</a>. The second, due to Prim, resembles Dijkstra’s shortest-paths algorithm (<a href="chapter022.xhtml#Sec_22.3">Section 22.3</a>).</p>
<p>Because a tree is a type of graph, in order to be precise we must define a tree in terms of not just its edges, but its vertices as well. Because this chapter focuses on trees in terms of their edges, we’ll implicitly understand that the vertices of a tree <em>T</em> are those that some edge of <em>T</em> is incident on.</p>
<p class="line1"/>
<section title="21.1 Growing a minimum spanning tree">
<a id="Sec_21.1"/>
<p class="level1" id="h1-125"><a href="toc.xhtml#Rh1-125"><strong>21.1    Growing a minimum spanning tree</strong></a></p>
<p class="noindent">The input to the minumum-spanning-tree problem is a connected, undirected graph <em>G</em> = (<em>V</em>, <em>E</em>) with a weight function <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>. The goal is to find a minimum spanning tree for <em>G</em>. The two algorithms considered in this chapter use a greedy approach to the problem, although they differ in how they apply this approach.</p>
<p>This greedy strategy is captured by the procedure G<small>ENERIC</small>-MST on the facing page, which grows the minimum spanning tree one edge at a time. The generic method manages a set A of edges, maintaining the following loop invariant:</p>
<div class="pull-quote">
<p class="pq-noindent">Prior to each iteration, <em>A</em> is a subset of some minimum spanning tree.</p>
</div>
<a id="p587"/>
<div class="pull-quote1">
<p class="box-heading">G<small>ENERIC</small>-MST(<em>G</em>, <em>w</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>A</em> = Ø</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> A does not form a spanning tree</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2">find an edge (<em>u</em>, <em>v</em>) that is safe for <em>A</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><em>A</em> = <em>A</em> ∪ {(<em>u</em>, <em>v</em>)}</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>A</em></p></td>
</tr>
</table>
</div>
<p>Each step determines an edge (<em>u</em>, <em>v</em>) that the procedure can add to <em>A</em> without violating this invariant, in the sense that <em>A</em> ∪ {(<em>u</em>, <em>v</em>)} is also a subset of a minimum spanning tree. We call such an edge a <span class="blue"><strong><em>safe edge</em></strong></span> for <em>A</em>, since it can be added safely to <em>A</em> while maintaining the invariant.</p>
<p>This generic algorithm uses the loop invariant as follows:</p>
<p class="para-hang-d"><strong>Initialization:</strong> After line 1, the set <em>A</em> trivially satisfies the loop invariant.</p>
<p class="para-hang-d"><strong>Maintenance:</strong> The loop in lines 2–4 maintains the invariant by adding only safe edges.</p>
<p class="para-hang-d"><strong>Termination:</strong> All edges added to <em>A</em> belong to a minimum spanning tree, and the loop must terminate by the time it has considered all edges. Therefore, the set <em>A</em> returned in line 5 must be a minimum spanning tree.</p>
<p class="space-break">The tricky part is, of course, finding a safe edge in line 3. One must exist, since when line 3 is executed, the invariant dictates that there is a spanning tree <em>T</em> such that <em>A</em> ⊆ <em>T</em>. Within the <strong>while</strong> loop body, <em>A</em> must be a proper subset of <em>T</em>, and therefore there must be an edge (<em>u</em>, <em>v</em>) ∈ <em>T</em> such that (<em>u</em>, <em>v</em>) ∉ <em>A</em> and (<em>u</em>, <em>v</em>) is safe for <em>A</em>.</p>
<p>The remainder of this section provides a rule (Theorem 21.1) for recognizing safe edges. The next section describes two algorithms that use this rule to find safe edges efficiently.</p>
<p>We first need some definitions. <em>A</em><span class="blue"><strong><em>cut</em></strong></span> (S, <em>V</em> – S) of an undirected graph <em>G</em> = (<em>V</em>, <em>E</em>) is a partition of <em>V</em>. <a href="chapter021.xhtml#Fig_21-2">Figure 21.2</a> illustrates this notion. We say that an edge (<em>u</em>, <em>v</em>) ∈ <em>E</em><span class="blue"><strong><em>crosses</em></strong></span> the cut (<em>S</em>, <em>V</em> – <em>S</em>) if one of its endpoints belongs to <em>S</em> and the other belongs to <em>V</em> – <em>S</em>. A cut <span class="blue"><strong><em>respects</em></strong></span> a set <em>A</em> of edges if no edge in <em>A</em> crosses the cut. An edge is a <span class="blue"><strong><em>light edge</em></strong></span> crossing a cut if its weight is the minimum of any edge crossing the cut. There can be more than one light edge crossing a cut in the case of ties. More generally, we say that an edge is a <span class="blue"><strong><em>light edge</em></strong></span> satisfying a given property if its weight is the minimum of any edge satisfying the property.</p>
<p>The following theorem gives the rule for recognizing safe edges.</p>
<p class="theo"><strong><em>Theorem 21.1</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a connected, undirected graph with a real-valued weight function <em>w</em> defined on <em>E</em>. Let <em>A</em> be a subset of <em>E</em> that is included in some minimum <a id="p588"/>spanning tree for <em>G</em>, let (<em>S</em>, <em>V</em> – <em>S</em>) be any cut of <em>G</em> that respects <em>A</em>, and let (<em>u</em>, <em>v</em>) be a light edge crossing (<em>S</em>, <em>V</em> – <em>S</em>). Then, edge (<em>u</em>, <em>v</em>) is safe for <em>A</em>.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_21-2"><img alt="art" src="images/Art_P620.jpg"/></p>
<p class="caption"><strong>Figure 21.2</strong> <em>A</em> cut (<em>S</em>, <em>V</em> – <em>S</em>) of the graph from <a href="chapter021.xhtml#Fig_21-1">Figure 21.1</a>. Orange vertices belong to the set <em>S</em>, and tan vertices belong to <em>V</em> – <em>S</em>. The edges crossing the cut are those connecting tan vertices with orange vertices. The edge (<em>d</em>, <em>c</em>) is the unique light edge crossing the cut. Blue edges form a subset <em>A</em> of the edges. The cut (<em>S</em>, <em>V</em> – <em>S</em>) respects <em>A</em>, since no edge of <em>A</em> crosses the cut.</p>
</div>
<p class="prof"><strong><em>Proof</em></strong>   Let <em>T</em> be a minimum spanning tree that includes <em>A</em>, and assume that <em>T</em> does not contain the light edge (<em>u</em>, <em>v</em>), since if it does, we are done. We’ll construct another minimum spanning tree <em>T</em>′ that includes <em>A</em> ∪ {(<em>u</em>, <em>v</em>)} by using a cut-and-paste technique, thereby showing that (<em>u</em>, <em>v</em>) is a safe edge for <em>A</em>.</p>
<p>The edge (<em>u</em>, <em>v</em>) forms a cycle with the edges on the simple path p from <em>u</em> to <em>v</em> in <em>T</em>, as <a href="chapter021.xhtml#Fig_21-3">Figure 21.3</a> illustrates. Since <em>u</em> and <em>v</em> are on opposite sides of the cut (<em>S</em>, <em>V</em> – <em>S</em>), at least one edge in <em>T</em> lies on the simple path <em>p</em> and also crosses the cut. Let (<em>x</em>, <em>y</em>) be any such edge. The edge (<em>x</em>, <em>y</em>) is not in <em>A</em>, because the cut respects <em>A</em>. Since (<em>x</em>, <em>y</em>) is on the unique simple path from <em>u</em> to <em>v</em> in <em>T</em>, removing (<em>x</em>, <em>y</em>) breaks <em>T</em> into two components. Adding (<em>u</em>, <em>v</em>) reconnects them to form a new spanning tree <em>T</em>′ = (<em>T</em> – {(<em>x</em>, <em>y</em>)}) ∪ {(<em>u</em>, <em>v</em>)}.</p>
<p>We next show that <em>T</em>′ is a minimum spanning tree. Since (<em>u</em>, <em>v</em>) is a light edge crossing (<em>S</em>, <em>V</em> – <em>S</em>) and (<em>x</em>, <em>y</em>) also crosses this cut, <em>w</em>(<em>u</em>, <em>v</em>) ≤ <em>w</em>(<em>x</em>, <em>y</em>). Therefore,</p>
<table class="table2b">
<tr>
<td class="td2"><em>w</em>(<em>T</em>′)</td>
<td class="td2">=</td>
<td class="td2"><em>w</em>(<em>T</em>) − <em>w</em>(<em>x</em>, <em>y</em>) + <em>w</em>(<em>u</em>, <em>v</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2"><em>w</em>(<em>T</em>).</td>
</tr>
</table>
<p class="noindent">But <em>T</em> is a minimum spanning tree, so that <em>w</em>(<em>T</em>) ≤ <em>w</em>(<em>T</em>′), and thus, <em>T</em>′ must be a minimum spanning tree as well.</p>
<p>It remains to show that (<em>u</em>, <em>v</em>) is actually a safe edge for <em>A</em>. We have <em>A</em> ⊆ <em>T</em>′, since <em>A</em> ⊆ <em>T</em> and (<em>x</em>, <em>y</em>) ∉ <em>A</em>, and thus, <em>A</em> ∪ {(<em>u</em>, <em>v</em>)} ⊆ <em>T</em>′. Consequently, since <em>T</em>′ is a minimum spanning tree, (<em>u</em>, <em>v</em>) is safe for <em>A</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Theorem 21.1 provides insight into how the G<small>ENERIC</small>-MST method works on a connected graph <em>G</em> = (<em>V</em>, <em>E</em>). As the method proceeds, the set <em>A</em> is always acyclic, since it is a subset of a minimum spanning tree and a tree may not contain a cycle. At any point in the execution, the graph <em>G<sub>A</sub></em> = (<em>V</em>, <em>A</em>) is a forest, and each of the connected components of <em>G<sub>A</sub></em> is a tree. (Some of the trees may contain just one vertex, as is the case, for example, when the method begins: <em>A</em> is empty and the forest contains |<em>V</em>| trees, one for each vertex.) Moreover, any safe edge (<em>u</em>, <em>v</em>) for <em>A</em> connects distinct components of <em>G<sub>A</sub></em>, since <em>A</em> ∪ {(<em>u</em>, <em>v</em>)} must be acyclic.</p>
<a id="p589"/>
<div class="divimage">
<p class="fig-imga" id="Fig_21-3"><img alt="art" src="images/Art_P621.jpg"/></p>
<p class="caption"><strong>Figure 21.3</strong> The proof of Theorem 21.1. Orange vertices belong to <em>S</em>, and tan vertices belong to <em>V</em> – <em>S</em>. Only edges in the minimum spanning tree <em>T</em> are shown, along with edge (<em>u</em>, <em>v</em>), which does not lie in <em>T</em>. The edges in <em>A</em> are blue, and (<em>u</em>, <em>v</em>) is a light edge crossing the cut (<em>S</em>, <em>V</em> – <em>S</em>). The edge (<em>x</em>, <em>y</em>) is an edge on the unique simple path <em>p</em> from <em>u</em> to <em>v</em> in <em>T</em>. To form a minimum spanning tree <em>T</em>′ that contains (<em>u</em>, <em>v</em>), remove the edge (<em>x</em>, <em>y</em>) from <em>T</em> and add the edge (<em>u</em>, <em>v</em>).</p>
</div>
<p>The <strong>while</strong> loop in lines 2–4 of G<small>ENERIC</small>-MST executes |<em>V</em>| – 1 times because it finds one of the |<em>V</em>| – 1 edges of a minimum spanning tree in each iteration. Initially, when <em>A</em> = Ø, there are |<em>V</em>| trees in <em>G<sub>A</sub></em>, and each iteration reduces that number by 1. When the forest contains only a single tree, the method terminates.</p>
<p>The two algorithms in <a href="chapter021.xhtml#Sec_21.2">Section 21.2</a> use the following corollary to Theorem 21.1.</p>
<p class="cor"><strong><em>Corollary 21.2</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be a connected, undirected graph with a real-valued weight function <em>w</em> defined on <em>E</em>. Let <em>A</em> be a subset of <em>E</em> that is included in some minimum spanning tree for <em>G</em>, and let <em>C</em> = (<em>V<sub>C</sub></em>, <em>E<sub>C</sub></em>) be a connected component (tree) in the forest <em>G<sub>A</sub></em> = (<em>V</em>, <em>A</em>). If (<em>u</em>, <em>v</em>) is a light edge connecting <em>C</em> to some other component in <em>G<sub>A</sub></em>, then (<em>u</em>, <em>v</em>) is safe for <em>A</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   The cut (<em>V<sub>C</sub></em>, <em>V</em> – <em>V<sub>C</sub></em>) respects <em>A</em>, and (<em>u</em>, <em>v</em>) is a light edge for this cut. Therefore, (<em>u</em>, <em>v</em>) is safe for <em>A</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<a id="p590"/>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>21.1-1</em></strong></p>
<p class="noindent">Let (<em>u</em>, <em>v</em>) be a minimum-weight edge in a connected graph <em>G</em>. Show that (<em>u</em>, <em>v</em>) belongs to some minimum spanning tree of <em>G</em>.</p>
<p class="level3"><strong><em>21.1-2</em></strong></p>
<p class="noindent">Professor Sabatier conjectures the following converse of Theorem 21.1. Let <em>G</em> = (<em>V</em>, <em>E</em>) be a connected, undirected graph with a real-valued weight function <em>w</em> defined on <em>E</em>. Let <em>A</em> be a subset of <em>E</em> that is included in some minimum spanning tree for <em>G</em>, let (<em>S</em>, <em>V</em> – <em>S</em>) be any cut of <em>G</em> that respects <em>A</em>, and let (<em>u</em>, <em>v</em>) be a safe edge for <em>A</em> crossing (<em>S</em>, <em>V</em> – <em>S</em>). Then, (<em>u</em>, <em>v</em>) is a light edge for the cut. Show that the professor’s conjecture is incorrect by giving a counterexample.</p>
<p class="level3"><strong><em>21.1-3</em></strong></p>
<p class="noindent">Show that if an edge (<em>u</em>, <em>v</em>) is contained in some minimum spanning tree, then it is a light edge crossing some cut of the graph.</p>
<p class="level3"><strong><em>21.1-4</em></strong></p>
<p class="noindent">Give a simple example of a connected graph such that the set of edges {(<em>u</em>, <em>v</em>) : there exists a cut (<em>S</em>, <em>V</em> – <em>S</em>) such that (<em>u</em>, <em>v</em>) is a light edge crossing (<em>S</em>, <em>V</em> – <em>S</em>)} does not form a minimum spanning tree.</p>
<p class="level3"><strong><em>21.1-5</em></strong></p>
<p class="noindent">Let <em>e</em> be a maximum-weight edge on some cycle of connected graph <em>G</em> = (<em>V</em>, <em>E</em>). Prove that there is a minimum spanning tree of <em>G</em>′ = (<em>V</em>, <em>E</em> – {<em>e</em>}) that is also a minimum spanning tree of <em>G</em>. That is, there is a minimum spanning tree of <em>G</em> that does not include <em>e</em>.</p>
<p class="level3"><strong><em>21.1-6</em></strong></p>
<p class="noindent">Show that a graph has a unique minimum spanning tree if, for every cut of the graph, there is a unique light edge crossing the cut. Show that the converse is not true by giving a counterexample.</p>
<p class="level3"><strong><em>21.1-7</em></strong></p>
<p class="noindent">Argue that if all edge weights of a graph are positive, then any subset of edges that connects all vertices and has minimum total weight must be a tree. Give an example to show that the same conclusion does not follow if we allow some weights to be nonpositive.</p>
<a id="p591"/>
<p class="level3"><strong><em>21.1-8</em></strong></p>
<p class="noindent">Let <em>T</em> be a minimum spanning tree of a graph <em>G</em>, and let <em>L</em> be the sorted list of the edge weights of <em>T</em>. Show that for any other minimum spanning tree <em>T</em>′ of <em>G</em>, the list <em>L</em> is also the sorted list of edge weights of <em>T</em>′.</p>
<p class="level3"><strong><em>21.1-9</em></strong></p>
<p class="noindent">Let <em>T</em> be a minimum spanning tree of a graph <em>G</em> = (<em>V</em>, <em>E</em>), and let <em>V</em>′ be a subset of <em>V</em>. Let <em>T</em>′ be the subgraph of <em>T</em> induced by <em>V</em>′, and let <em>G</em>′ be the subgraph of <em>G</em> induced by <em>V</em>′. Show that if <em>T</em>′ is connected, then <em>T</em>′ is a minimum spanning tree of G′.</p>
<p class="level3"><strong><em>21.1-10</em></strong></p>
<p class="noindent">Given a graph <em>G</em> and a minimum spanning tree <em>T</em>, suppose that the weight of one of the edges in <em>T</em> decreases. Show that <em>T</em> is still a minimum spanning tree for <em>G</em>. More formally, let <em>T</em> be a minimum spanning tree for <em>G</em> with edge weights given by weight function <em>w</em>. Choose one edge (<em>x</em>, <em>y</em>) ∈ <em>T</em> and a positive number <em>k</em>, and define the weight function <em>w</em>′ by</p>
<p class="eql"><img alt="art" src="images/Art_P622.jpg"/></p>
<p class="noindent">Show that <em>T</em> is a minimum spanning tree for <em>G</em> with edge weights given by <em>w</em>′.</p>
<p class="level3"><span class="font1">★</span> <strong><em>21.1-11</em></strong></p>
<p class="noindent">Given a graph <em>G</em> and a minimum spanning tree <em>T</em>, suppose that the weight of one of the edges <em>not</em> in <em>T</em> decreases. Give an algorithm for finding the minimum spanning tree in the modified graph.</p>
</section>
<p class="line1"/>
<section title="21.2 The algorithms of Kruskal and Prim">
<a id="Sec_21.2"/>
<p class="level1" id="h1-126"><a href="toc.xhtml#Rh1-126"><strong>21.2    The algorithms of Kruskal and Prim</strong></a></p>
<p class="noindent">The two minimum-spanning-tree algorithms described in this section elaborate on the generic method. They each use a specific rule to determine a safe edge in line 3 of G<small>ENERIC</small>-MST. In Kruskal’s algorithm, the set <em>A</em> is a forest whose vertices are all those of the given graph. The safe edge added to <em>A</em> is always a lowest-weight edge in the graph that connects two distinct components. In Prim’s algorithm, the set <em>A</em> forms a single tree. The safe edge added to <em>A</em> is always a lowest-weight edge connecting the tree to a vertex not in the tree. Both algorithms assume that the input graph is connected and represented by adjacency lists.</p>
<a id="p592"/>
<div class="divimage">
<p class="fig-imga" id="Fig_21-4"><img alt="art" src="images/Art_P623.jpg"/></p>
<p class="caption"><strong>Figure 21.4</strong> The execution of Kruskal’s algorithm on the graph from <a href="chapter021.xhtml#Fig_21-1">Figure 21.1</a>. Blue edges belong to the forest <em>A</em> being grown. The algorithm considers each edge in sorted order by weight. A red arrow points to the edge under consideration at each step of the algorithm. If the edge joins two distinct trees in the forest, it is added to the forest, thereby merging the two trees.</p>
</div>
<p class="level4"><strong>Kruskal’s algorithm</strong></p>
<p class="noindent">Kruskal’s algorithm finds a safe edge to add to the growing forest by finding, of all the edges that connect any two trees in the forest, an edge (<em>u</em>, <em>v</em>) with the lowest weight. Let <em>C</em><sub>1</sub> and <em>C</em><sub>2</sub> denote the two trees that are connected by (<em>u</em>, <em>v</em>). Since (<em>u</em>, <em>v</em>) must be a light edge connecting <em>C</em><sub>1</sub> to some other tree, Corollary 21.2 implies <a id="p593"/>that (<em>u</em>, <em>v</em>) is a safe edge for <em>C</em><sub>1</sub>. Kruskal’s algorithm qualifies as a greedy algorithm because at each step it adds to the forest an edge with the lowest possible weight.</p>
<div class="divimage">
<p class="fig-img"><img alt="art" src="images/Art_P624.jpg"/></p>
<p class="caption"><strong>Figure 21.4, continued</strong> Further steps in the execution of Kruskal’s algorithm.</p>
</div>
<p>Like the algorithm to compute connected components from <a href="chapter019.xhtml#Sec_19.1">Section 19.1</a>, the procedure MST-K<small>RUSKAL</small> on the following page uses a disjoint-set data structure to maintain several disjoint sets of elements. Each set contains the vertices in one tree of the current forest. The operation F<small>IND</small>-S<small>ET</small>(<em>u</em>) returns a representative element from the set that contains <em>u</em>. Thus, to determine whether two vertices <em>u</em> and <em>v</em> belong to the same tree, just test whether F<small>IND</small>-S<small>ET</small>(<em>u</em>) equals F<small>IND</small>-S<small>ET</small>(<em>v</em>). To combine trees, Kruskal’s algorithm calls the U<small>NION</small> procedure.</p>
<p><a href="chapter021.xhtml#Fig_21-4">Figure 21.4</a> shows how Kruskal’s algorithm works. Lines 1–3 initialize the set <em>A</em> to the empty set and create |<em>V</em>| trees, one containing each vertex. The <strong>for</strong> loop in lines 6–9 examines edges in order of weight, from lowest to highest. The loop checks, for each edge (<em>u</em>, <em>v</em>), whether the endpoints <em>u</em> and <em>v</em> belong to the same tree. If they do, then the edge (<em>u</em>, <em>v</em>) cannot be added to the forest without creating a cycle, and the edge is ignored. Otherwise, the two vertices belong to different <a id="p594"/>trees. In this case, line 8 adds the edge (<em>u</em>, <em>v</em>) to <em>A</em>, and line 9 merges the vertices in the two trees.</p>
<div class="pull-quote1">
<p class="box-heading">MST-K<small>RUSKAL</small>(<em>G</em>, <em>w</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><em>A</em> = Ø</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>v</em> ∈ <em>G.V</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="p2">M<small>AKE</small>-S<small>ET</small>(<em>v</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="noindent">create a single list of the edges in <em>G.E</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="noindent">sort the list of edges into monotonically increasing order by weight <em>w</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each edge (<em>u</em>, <em>v</em>) taken from the sorted list in order</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> F<small>IND</small>-S<small>ET</small>(<em>u</em>) ≠ F<small>IND</small>-S<small>ET</small>(<em>v</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="p3"><em>A</em> = <em>A</em> ∪ {(<em>u</em>, <em>v</em>)}</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="p3">U<small>NION</small>(<em>u</em>, <em>v</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>A</em></p></td>
</tr>
</table>
</div>
<p>The running time of Kruskal’s algorithm for a graph <em>G</em> = (<em>V</em>, <em>E</em>) depends on the specific implementation of the disjoint-set data structure. Let’s assume that it uses the disjoint-set-forest implementation of <a href="chapter019.xhtml#Sec_19.3">Section 19.3</a> with the union-by-rank and path-compression heuristics, since that is the asymptotically fastest implementation known. Initializing the set <em>A</em> in line 1 takes <em>O</em>(1) time, creating a single list of edges in line 4 takes <em>O</em>(<em>V</em> + <em>E</em>) time (which is <em>O</em>(E) because <em>G</em> is connected), and the time to sort the edges in line 5 is <em>O</em>(<em>E</em> lg <em>E</em>). (We’ll account for the cost of the |<em>V</em>| M<small>AKE</small>-S<small>ET</small> operations in the <strong>for</strong> loop of lines 2–3 in a moment.) The <strong>for</strong> loop of lines 6–9 performs <em>O</em>(<em>E</em>) F<small>IND</small>-S<small>ET</small> and U<small>NION</small> operations on the disjoint-set forest. Along with the |<em>V</em>| M<small>AKE</small>-S<small>ET</small> operations, these disjoint-set operations take a total of <em>O</em>((<em>V</em> + <em>E</em>) α(<em>V</em>)) time, where α is the very slowly growing function defined in <a href="chapter019.xhtml#Sec_19.4">Section 19.4</a>. Because we assume that <em>G</em> is connected, we have |<em>E</em>| ≥ |<em>V</em>| – 1, and so the disjoint-set operations take <em>O</em>(<em>E</em> α(<em>V</em>)) time. Moreover, since α(|<em>V</em>|) = <em>O</em>(lg <em>V</em>) = <em>O</em>(lg <em>E</em>), the total running time of Kruskal’s algorithm is <em>O</em>(<em>E</em> lg <em>E</em>). Observing that |<em>E</em>| &lt; |<em>V</em>|<sup>2</sup>, we have lg |<em>E</em>| = <em>O</em>(lg <em>V</em>), and so we can restate the running time of Kruskal’s algorithm as <em>O</em>(<em>E</em> lg <em>V</em>).</p>
<p class="level4"><strong>Prim’s algorithm</strong></p>
<p class="noindent">Like Kruskal’s algorithm, Prim’s algorithm is a special case of the generic minimum-spanning-tree method from <a href="chapter021.xhtml#Sec_21.1">Section 21.1</a>. Prim’s algorithm operates much like Dijkstra’s algorithm for finding shortest paths in a graph, which we’ll see in <a href="chapter022.xhtml#Sec_22.3">Section 22.3</a>. Prim’s algorithm has the property that the edges in the set <em>A</em> always form a single tree. As <a href="chapter021.xhtml#Fig_21-5">Figure 21.5</a> shows, the tree starts from an arbitrary root vertex r and grows until it spans all the vertices in <em>V</em>. Each step adds to the tree A a light edge that connects <em>A</em> to an isolated vertex—one on which no edge of <em>A</em> is incident. By Corollary 21.2, this rule adds only edges that are safe for <em>A</em>. Therefore, when the algorithm terminates, the edges in <em>A</em> form a minimum spanning tree. This strategy qualifies as greedy since at each step it adds to the tree an edge that contributes the minimum amount possible to the tree’s weight.</p>
<a id="p595"/>
<div class="divimage">
<p class="fig-imga" id="Fig_21-5"><img alt="art" src="images/Art_P625.jpg"/></p>
<p class="caption"><strong>Figure 21.5</strong> The execution of Prim’s algorithm on the graph from <a href="chapter021.xhtml#Fig_21-1">Figure 21.1</a>. The root vertex is <em>a</em>. Blue vertices and edges belong to the tree being grown, and tan vertices have yet to be added to the tree. At each step of the algorithm, the vertices in the tree determine a cut of the graph, and a light edge crossing the cut is added to the tree. The edge and vertex added to the tree are highlighted in orange. In the second step (part (c)), for example, the algorithm has a choice of adding either edge (<em>b</em>, <em>c</em>) or edge (<em>a</em>, <em>h</em>) to the tree since both are light edges crossing the cut.</p>
</div>
<a id="p596"/>
<p>In the procedure MST-P<small>RIM</small> below, the connected graph <em>G</em> and the root <em>r</em> of the minimum spanning tree to be grown are inputs to the algorithm. In order to efficiently select a new edge to add into tree <em>A</em>, the algorithm maintains a min-priority queue <em>Q</em> of all vertices that are <em>not</em> in the tree, based on a <em>key</em> attribute. For each vertex <em>v</em>, the attribute <em>v.key</em> is the minimum weight of any edge connecting <em>v</em> to a vertex in the tree, where by convention, <em>v.key</em> = ∞ if there is no such edge. The attribute <em>v</em>.π names the parent of <em>v</em> in the tree. The algorithm implicitly maintains the set <em>A</em> from G<small>ENERIC</small>-MST as</p>
<p class="eql"><em>A</em> = {(<em>v</em>, <em>v</em>.π) : <em>v</em> ∈ <em>V</em> – {<em>r</em>} – <em>Q</em>},</p>
<p class="noindent">where we interpret the vertices in <em>Q</em> as forming a set. When the algorithm terminates, the min-priority queue <em>Q</em> is empty, and thus the minimum spanning tree <em>A</em> for <em>G</em> is</p>
<p class="eql"><em>A</em> = {(<em>v</em>, <em>v</em>.π) : <em>v</em> ∈ <em>V</em> – {<em>r</em>}}.</p>
<div class="pull-quote1">
<p class="box-heading">MST-P<small>RIM</small>(<em>G</em>, <em>w</em>, <em>r</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>for</strong> each vertex <em>u</em> ∈ <em>G</em>.<em>V</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1" colspan="2"><p class="p2"><em>u.key</em> = ∞</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1" colspan="2"><p class="p2"><em>u</em>.π = <small>NIL</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><em>r.key</em> = 0</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><em>Q</em> = Ø</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>for</strong> each vertex <em>u</em> ∈ <em>G.V</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1" colspan="2"><p class="p2">I<small>NSERT</small>(<em>Q</em>, <em>u</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1" colspan="2"><p class="noindent"><strong>while</strong> <em>Q</em> ≠ Ø</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="p2"><em>u</em> = E<small>XTRACT</small>-M<small>IN</small>(<em>Q</em>)</p></td>
<td class="td1"><p class="noindent"><span class="red">// add <em>u</em> to the tree</span></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><p class="p2"><strong>for</strong> each vertex <em>v</em> in <em>G.Adj</em>[<em>u</em>]</p></td>
<td class="td1"><p class="noindent"><span class="red">// update keys of <em>u</em>’s non-tree neighbors</span></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">11</span></p></td>
<td class="td1" colspan="2"><p class="p3"><strong>if</strong> <em>v</em> ∈ <em>Q</em> and <em>w</em>(<em>u</em>, <em>v</em>) &lt; <em>v.key</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">12</span></p></td>
<td class="td1" colspan="2"><p class="p4"><em>v</em>.π = <em>u</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">13</span></p></td>
<td class="td1" colspan="2"><p class="p4"><em>v.key</em> = <em>w</em>(<em>u</em>, <em>v</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">14</span></p></td>
<td class="td1" colspan="2"><p class="p4">D<small>ECREASE</small>-K<small>EY</small>(<em>Q</em>, <em>v</em>, <em>w</em>(<em>u</em>, <em>v</em>))</p></td>
</tr>
</table>
</div>
<p><a href="chapter021.xhtml#Fig_21-5">Figure 21.5</a> shows how Prim’s algorithm works. Lines 1–7 set the key of each vertex to ∞ (except for the root <em>r</em>, whose key is set to 0 to make it the first vertex processed), set the parent of each vertex to <small>NIL</small>, and insert each vertex into the min-priority queue <em>Q</em>. The algorithm maintains the following three-part loop invariant:</p>
<a id="p597"/>
<div class="pull-quote">
<p class="pq-noindent">Prior to each iteration of the <strong>while</strong> loop of lines 8–14,</p>
<ol class="olnoindent" epub:type="list">
<li><em>A</em> = {(<em>v</em>, <em>v</em>.π) : <em>v</em> ∈ <em>V</em> – {r} – <em>Q</em>}.</li>
<li class="litop">The vertices already placed into the minimum spanning tree are those in <em>V</em> − <em>Q</em>.</li>
<li class="litop">For all vertices <em>v</em> ∈ <em>Q</em>, if <em>v</em>.π ≠ <small>NIL</small>, then <em>v.key</em> &lt; ∞ and <em>v.key</em> is the weight of a light edge (<em>v</em>, <em>v</em>.π) connecting <em>v</em> to some vertex already placed into the minimum spanning tree.</li></ol>
</div>
<p class="noindent">Line 9 identifies a vertex <em>u</em> ∈ <em>Q</em> incident on a light edge that crosses the cut (<em>V</em> – <em>Q</em>, <em>Q</em>) (with the exception of the first iteration, in which <em>u</em> = <em>r</em> due to lines 4–7). Removing <em>u</em> from the set <em>Q</em> adds it to the set <em>V</em> – <em>Q</em> of vertices in the tree, thus adding the edge (<em>u</em>, <em>u</em>.π) to <em>A</em>. The <strong>for</strong> loop of lines 10–14 updates the <em>key</em> and attributes of every vertex <em>v</em> adjacent to <em>u</em> but not in the tree, thereby maintaining the third part of the loop invariant. Whenever line 13 updates <em>v.key</em>, line 14 calls D<small>ECREASE</small>-K<small>EY</small> to inform the min-priority queue that <em>v</em>’s key has changed.</p>
<p>The running time of Prim’s algorithm depends on the specific implementation of the min-priority queue <em>Q</em>. You can implement <em>Q</em> with a binary min-heap (see <a href="chapter006.xhtml">Chapter 6</a>), including a way to map between vertices and their corresponding heap elements. The B<small>UILD</small>-M<small>IN</small>-H<small>EAP</small> procedure can perform lines 5–7 in <em>O</em>(<em>V</em>) time. In fact, there is no need to call B<small>UILD</small>-M<small>IN</small>-H<small>EAP</small>. You can just put the key of <em>r</em> at the root of the min-heap, and because all other keys are ∞, they can go anywhere else in the min-heap. The body of the <strong>while</strong> loop executes |<em>V</em>| times, and since each E<small>XTRACT</small>-M<small>IN</small> operation takes <em>O</em>(lg <em>V</em>) time, the total time for all calls to E<small>XTRACT</small>-M<small>IN</small> is <em>O</em>(<em>V</em> lg <em>V</em>). The <strong>for</strong> loop in lines 10–14 executes <em>O</em>(<em>E</em>) times altogether, since the sum of the lengths of all adjacency lists is 2 |<em>E</em>|. Within the <strong>for</strong> loop, the test for membership in <em>Q</em> in line 11 can take constant time if you keep a bit for each vertex that indicates whether it belongs to <em>Q</em> and update the bit when the vertex is removed from <em>Q</em>. Each call to D<small>ECREASE</small>-K<small>EY</small> in line 14 takes <em>O</em>(lg <em>V</em>) time. Thus, the total time for Prim’s algorithm is <em>O</em>(<em>V</em> lg <em>V</em> + <em>E</em> lg <em>V</em>) = <em>O</em>(<em>E</em> lg <em>V</em>), which is asymptotically the same as for our implementation of Kruskal’s algorithm.</p>
<p>You can further improve the asymptotic running time of Prim’s algorithm by implementing the min-priority queue with a Fibonacci heap (see page 478). If a Fibonacci heap holds |<em>V</em>| elements, an E<small>XTRACT</small>-M<small>IN</small> operation takes <em>O</em>(lg <em>V</em>) amortized time and each I<small>NSERT</small> and D<small>ECREASE</small>-K<small>EY</small> operation takes only <em>O</em>(1) amortized time. Therefore, by using a Fibonacci heap to implement the min-priority queue <em>Q</em>, the running time of Prim’s algorithm improves to <em>O</em>(<em>E</em>+<em>V</em> lg <em>V</em>).</p>
<a id="p598"/>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>21.2-1</em></strong></p>
<p class="noindent">Kruskal’s algorithm can return different spanning trees for the same input graph <em>G</em>, depending on how it breaks ties when the edges are sorted. Show that for each minimum spanning tree <em>T</em> of <em>G</em>, there is a way to sort the edges of <em>G</em> in Kruskal’s algorithm so that the algorithm returns <em>T</em>.</p>
<p class="level3"><strong><em>21.2-2</em></strong></p>
<p class="noindent">Give a simple implementation of Prim’s algorithm that runs in <em>O</em>(<em>V</em><sup>2</sup>) time when the graph <em>G</em> = (<em>V</em>, <em>E</em>) is represented as an adjacency matrix.</p>
<p class="level3"><strong><em>21.2-3</em></strong></p>
<p class="noindent">For a sparse graph <em>G</em> = (<em>V</em>, <em>E</em>), where |<em>E</em>| = Θ(<em>V</em>), is the implementation of Prim’s algorithm with a Fibonacci heap asymptotically faster than the binary-heap implementation? What about for a dense graph, where |<em>E</em>| = Θ(<em>V</em><sup>2</sup>)? How must the sizes |<em>E</em>| and |<em>V</em>| be related for the Fibonacci-heap implementation to be asymptotically faster than the binary-heap implementation?</p>
<p class="level3"><strong><em>21.2-4</em></strong></p>
<p class="noindent">Suppose that all edge weights in a graph are integers in the range from 1 to |<em>V</em>|. How fast can you make Kruskal’s algorithm run? What if the edge weights are integers in the range from 1 to <em>W</em> for some constant <em>W</em>?</p>
<p class="level3"><strong><em>21.2-5</em></strong></p>
<p class="noindent">Suppose that all edge weights in a graph are integers in the range from 1 to |<em>V</em>|. How fast can you make Prim’s algorithm run? What if the edge weights are integers in the range from 1 to <em>W</em> for some constant <em>W</em>?</p>
<p class="level3"><strong><em>21.2-6</em></strong></p>
<p class="noindent">Professor Borden proposes a new divide-and-conquer algorithm for computing minimum spanning trees, which goes as follows. Given a graph <em>G</em> = (<em>V</em>, <em>E</em>), partition the set <em>V</em> of vertices into two sets <em>V</em><sub>1</sub> and <em>V</em><sub>2</sub> such that |<em>V</em><sub>1</sub>| and |<em>V</em><sub>2</sub>| differ by at most 1. Let <em>E</em><sub>1</sub> be the set of edges that are incident only on vertices in <em>V</em><sub>1</sub>, and let <em>E</em><sub>2</sub> be the set of edges that are incident only on vertices in <em>V</em><sub>2</sub>. Recursively solve a minimum-spanning-tree problem on each of the two subgraphs <em>G</em><sub>1</sub> = (<em>V</em><sub>1</sub>, <em>E</em><sub>1</sub>) and <em>G</em><sub>2</sub> = (<em>V</em><sub>2</sub>, <em>E</em><sub>2</sub>). Finally, select the minimum-weight edge in <em>E</em> that crosses the cut <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>), and use this edge to unite the resulting two minimum spanning trees into a single spanning tree.</p>
<p>Either argue that the algorithm correctly computes a minimum spanning tree of <em>G</em>, or provide an example for which the algorithm fails.</p>
<a id="p599"/>
<p class="level3"><span class="font1">★</span> <strong><em>21.2-7</em></strong></p>
<p class="noindent">Suppose that the edge weights in a graph are uniformly distributed over the half-open interval [0, 1). Which algorithm, Kruskal’s or Prim’s, can you make run faster?</p>
<p class="level3"><span class="font1">★</span> <strong><em>21.2-8</em></strong></p>
<p class="noindent">Suppose that a graph <em>G</em> has a minimum spanning tree already computed. How quickly can you update the minimum spanning tree upon adding a new vertex and incident edges to <em>G</em>?</p>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-127"><strong>Problems</strong></p>
<section title="21-1 Second-best minimum spanning tree">
<p class="level2"><strong><em>21-1     Second-best minimum spanning tree</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be an undirected, connected graph whose weight function is <em>w</em> : <em>E</em> → <span class="font1">ℝ</span>, and suppose that |<em>E</em>| ≥ |<em>V</em>| and all edge weights are distinct.</p>
<p>We define a second-best minimum spanning tree as follows. Let <span class="script">T</span> be the set of all spanning trees of <em>G</em>, and let <em>T</em> be a minimum spanning tree of <em>G</em>. Then a <span class="blue"><strong><em>second-best minimum spanning tree</em></strong></span> is a spanning tree <em>T</em>′ such that <em>w</em>(<em>T</em>′) = min {<em>w</em>(<em>T</em>″) : <em>T</em>″ ∈ <span class="script">T</span> − {<em>T</em>}}.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Show that the minimum spanning tree is unique, but that the second-best minimum spanning tree need not be unique.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Let <em>T</em> be the minimum spanning tree of <em>G</em>. Prove that <em>G</em> contains some edge (<em>u</em>, <em>v</em>) ∈ <em>T</em> and some edge (<em>x</em>, <em>y</em>) ∉ <em>T</em> such that (<em>T</em> – {(<em>u</em>, <em>v</em>)}) ∪ {(<em>x</em>, <em>y</em>)} is a second-best minimum spanning tree of <em>G</em>.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Now let <em>T</em> be any spanning tree of <em>G</em> and, for any two vertices <em>u</em>, <em>v</em> ∈ <em>V</em>, let <em>max</em>[<em>u</em>, <em>v</em>] denote an edge of maximum weight on the unique simple path between <em>u</em> and <em>v</em> in <em>T</em>. Describe an <em>O</em>(<em>V</em><sup>2</sup>)-time algorithm that, given <em>T</em>, computes <em>max</em>[<em>u</em>, <em>v</em>] for all <em>u, v</em> ∈ <em>V</em>.</p>
<p class="nl-1list-d"><strong><em>d.</em></strong> Give an efficient algorithm to compute the second-best minimum spanning tree of <em>G</em>.</p>
</section>
<section title="21-2 Minimum spanning tree in sparse graphs">
<p class="level2"><strong><em>21-2     Minimum spanning tree in sparse graphs</em></strong></p>
<p class="noindent">For a very sparse connected graph <em>G</em> = (<em>V</em>, <em>E</em>), it is possible to further improve upon the <em>O</em>(<em>E</em> + <em>V</em> lg <em>V</em>) running time of Prim’s algorithm with a Fibonacci heap by preprocessing <em>G</em> to decrease the number of vertices before running Prim’s algorithm. In particular, for each vertex <em>u</em>, choose the minimum-weight edge (<em>u</em>, <em>v</em>) <a id="p600"/>incident on <em>u</em>, and put (<em>u</em>, <em>v</em>) into the minimum spanning tree under construction. Then, contract all chosen edges (see <a href="appendix002.xhtml#Sec_B.4">Section B.4</a>). Rather than contracting these edges one at a time, first identify sets of vertices that are united into the same new vertex. Then create the graph that would have resulted from contracting these edges one at a time, but do so by “renaming” edges according to the sets into which their endpoints were placed. Several edges from the original graph might be renamed the same as each other. In such a case, only one edge results, and its weight is the minimum of the weights of the corresponding original edges.</p>
<p>Initially, set the minimum spanning tree <em>T</em> being constructed to be empty, and for each edge (<em>u</em>, <em>v</em>) ∈ <em>E</em>, initialize the two attributes (<em>u</em>, <em>v</em>).<em>orig</em> = (<em>u</em>, <em>v</em>) and (<em>u</em>, <em>v</em>).<em>c</em> = <em>w</em>(<em>u</em>, <em>v</em>). Use the <em>orig</em> attribute to reference the edge from the initial graph that is associated with an edge in the contracted graph. The <em>c</em> attribute holds the weight of an edge, and as edges are contracted, it is updated according to the above scheme for choosing edge weights. The procedure MST-R<small>EDUCE</small> on the facing page takes inputs <em>G</em> and <em>T</em>, and it returns a contracted graph <em>G</em>′ with updated attributes <em>orig</em>′ and <em>c</em>′. The procedure also accumulates edges of <em>G</em> into the minimum spanning tree <em>T</em>.</p>
<p class="nl-1list-d"><strong><em>a.</em></strong> Let <em>T</em> be the set of edges returned by MST-R<small>EDUCE</small>, and let <em>A</em> be the minimum spanning tree of the graph <em>G</em>′ formed by the call MST-P<small>RIM</small>(<em>G</em>′, <em>c</em>′, <em>r</em>), where <em>c</em>′ is the weight attribute on the edges of <em>G</em>′.<em>E</em> and <em>r</em> is any vertex in <em>G</em>′:<em>V</em>. Prove that <em>T</em> ∪ {(<em>x</em>, <em>y</em>).<em>orig</em>′ : (<em>x</em>, <em>y</em>) ∈ <em>A</em>} is a minimum spanning tree of <em>G</em>.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Argue that |<em>G</em>′.<em>V</em>| ≤ |<em>V</em>| /2.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Show how to implement MST-R<small>EDUCE</small> so that it runs in <em>O</em>(<em>E</em>) time. (<em>Hint:</em> Use simple data structures.)</p>
<p class="nl-1list-d"><strong><em>d.</em></strong> Suppose that you run <em>k</em> phases of MST-R<small>EDUCE</small>, using the output <em>G</em>′ produced by one phase as the input <em>G</em> to the next phase and accumulating edges in <em>T</em>. Argue that the overall running time of the <em>k</em> phases is <em>O</em>(<em>kE</em>).</p>
<p class="nl-1list-d"><strong><em>e.</em></strong> Suppose that after running <em>k</em> phases of MST-R<small>EDUCE</small>, as in part (<em>d</em>), you run Prim’s algorithm by calling MST-P<small>RIM</small>(<em>G</em>′, <em>c</em>′, <em>r</em>), where <em>G</em>′, with weight attribute <em>c</em>′, is returned by the last phase and <em>r</em> is any vertex in <em>G</em>′.<em>V</em>. Show how to pick <em>k</em> so that the overall running time is <em>O</em>(<em>E</em> lg lg <em>V</em>). Argue that your choice of <em>k</em> minimizes the overall asymptotic running time.</p>
<p class="nl-1list-d"><strong><em>f.</em></strong> For what values of |<em>E</em>| (in terms of |<em>V</em>|) does Prim’s algorithm with preprocessing asymptotically beat Prim’s algorithm without preprocessing?</p>
<a id="p601"/>
<div class="pull-quote1">
<p class="box-heading">MST-R<small>EDUCE</small>(<em>G</em>, <em>T</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>v</em> ∈ <em>G.V</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="p2"><em>v.mark</em> = <small>FALSE</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="p2">M<small>AKE</small>-S<small>ET</small>(<em>v</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>u</em> ∈ <em>G.V</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>u.mark</em> == <small>FALSE</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="p3">choose <em>v</em> ∈ <em>G.Adj</em>[<em>u</em>] such that (<em>u</em>, <em>v</em>).<em>c</em> is minimized</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="p3">U<small>NION</small>(<em>u</em>, <em>v</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="p3"><em>T</em> = <em>T</em> ∪ {(<em>u</em>, <em>v</em>).<em>orig</em>}</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="p3"><em>u.mark</em> = <small>TRUE</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><p class="p3"><em>v.mark</em> = <small>TRUE</small></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">11</span></p></td>
<td class="td1"><p class="noindent"><em>G</em>′.<em>V</em> = {F<small>IND</small>-S<small>ET</small>(<em>v</em>) : <em>v</em> ∈ <em>G.V</em>}</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">12</span></p></td>
<td class="td1"><p class="noindent"><em>G</em>′.<em>E</em> = Ø</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">13</span></p></td>
<td class="td1"><strong>for</strong> each edge (<em>x</em>, <em>y</em>) ∈ <em>G.E</em></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">14</span></p></td>
<td class="td1"><p class="p2"><em>u</em> = F<small>IND</small>-S<small>ET</small>(<em>x</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">15</span></p></td>
<td class="td1"><p class="p2"><em>v</em> = F<small>IND</small>-S<small>ET</small>(<em>y</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">16</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>u</em> ≠ <em>v</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">17</span></p></td>
<td class="td1"><p class="p3"><strong>if</strong> (<em>u</em>, <em>v</em>) ∉ <em>G</em>′.<em>E</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">18</span></p></td>
<td class="td1"><p class="p4"><em>G</em>′.<em>E</em> = <em>G</em>′.<em>E</em> ∪ {(u, v)}</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">19</span></p></td>
<td class="td1"><p class="p4">(<em>u, v</em>).<em>orig</em>′ = (<em>x</em>, <em>y</em>).<em>orig</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">20</span></p></td>
<td class="td1"><p class="p4">(<em>u</em>, <em>v</em>).<em>c</em>′ = (<em>x</em>, <em>y</em>).<em>c</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">21</span></p></td>
<td class="td1"><p class="p3"><strong>elseif</strong> (<em>x</em>, <em>y</em>).<em>c</em> &lt; (<em>u</em>, <em>v</em>).c′</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">22</span></p></td>
<td class="td1"><p class="p4">(<em>u</em>, <em>v</em>).<em>orig</em>′ = (<em>x</em>, <em>y</em>).<em>orig</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">23</span></p></td>
<td class="td1"><p class="p4">(<em>u</em>, <em>v</em>).<em>c</em>′ = (<em>x</em>, <em>y</em>).<em>c</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">24</span></p></td>
<td class="td1"><p class="noindent">construct adjacency lists <em>G</em>′.<em>Adj</em> for <em>G</em>′</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">25</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>G</em>′ and <em>T</em></p></td>
</tr>
</table>
</div>
</section>
<section title="21-3 Alternative minimum-spanning-tree algorithms">
<p class="level2"><strong><em>21-3     Alternative minimum-spanning-tree algorithms</em></strong></p>
<p class="noindent">Consider the three algorithms M<small>AYBE</small>-MST-A, M<small>AYBE</small>-MST-B, and M<small>AYBE</small>-MST-C on the next page. Each one takes a connected graph and a weight function as input and returns a set of edges <em>T</em>. For each algorithm, either prove that <em>T</em> is a minimum spanning tree or prove that <em>T</em> is not necessarily a minimum spanning tree. Also describe the most efficient implementation of each algorithm, regardless of whether it computes a minimum spanning tree.</p>
</section>
<section title="21-4 Bottleneck spanning tree">
<p class="level2"><strong><em>21-4     Bottleneck spanning tree</em></strong></p>
<p class="noindent">A <span class="blue"><strong><em>bottleneck spanning tree</em></strong></span> <em>T</em> of an undirected graph <em>G</em> is a spanning tree of <em>G</em> whose largest edge weight is minimum over all spanning trees of <em>G</em>. The value of the bottleneck spanning tree is the weight of the maximum-weight edge in <em>T</em>.</p>
<a id="p602"/>
<div class="pull-quote1">
<p class="box-heading">M<small>AYBE</small>-MST-A(<em>G</em>, <em>w</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent">sort the edges into monotonically decreasing order of edge weights <em>w</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><em>T</em> = <em>E</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each edge <em>e</em>, taken in monotonically decreasing order by weight</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>T</em> – {<em>e</em>} is a connected graph</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p3"><em>T</em> = <em>T</em> – {<em>e</em>}</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>T</em></p></td>
</tr>
<tr>
<td class="td1" colspan="2"><p class="box-headinga">M<small>AYBE</small>-MST-B(<em>G</em>, <em>w</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>T</em> = Ø</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each edge <em>e</em>, taken in arbitrary order</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>T</em> ∪ {<em>e</em>} has no cycles</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p3"><em>T</em> = <em>T</em> ∪ {<em>e</em>}</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> T</p></td>
</tr>
<tr>
<td class="td1" colspan="2"><p class="box-headinga">M<small>AYBE</small>-MST-C(<em>G</em>, <em>w</em>)</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>T</em> = Ø</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> each edge <em>e</em>, taken in arbitrary order</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2"><em>T</em> = <em>T</em> ∪ {<em>e</em>}</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>T</em> has a cycle <em>c</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p3">let <em>e</em>′ be a maximum-weight edge on <em>c</em></p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="p3"><em>T</em> = <em>T</em> – {<em>e</em>′}</p></td>
</tr>
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>T</em></p></td>
</tr>
</table>
</div>
<p class="nl-1list-d"><strong><em>a.</em></strong> Argue that a minimum spanning tree is a bottleneck spanning tree.</p>
<p class="noindent1-top">Part (a) shows that finding a bottleneck spanning tree is no harder than finding a minimum spanning tree. In the remaining parts, you will show how to find a bottleneck spanning tree in linear time.</p>
<p class="nl-1list-d"><strong><em>b.</em></strong> Give a linear-time algorithm that, given a graph <em>G</em> and an integer <em>b</em>, determines whether the value of the bottleneck spanning tree is at most <em>b</em>.</p>
<p class="nl-1list-d"><strong><em>c.</em></strong> Use your algorithm for part (b) as a subroutine in a linear-time algorithm for the bottleneck-spanning-tree problem. (<em>Hint:</em> You might want to use a subroutine that contracts sets of edges, as in the MST-R<small>EDUCE</small> procedure described in Problem 21-2.)</p>
<a id="p603"/>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-128"><strong>Chapter notes</strong></p>
<p class="noindent">Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_429">429</a>] surveys the minimum-spanning-tree problem and provides excellent advanced material. Graham and Hell [<a epub:type="noteref" href="bibliography001.xhtml#endnote_198">198</a>] compiled a history of the minimum-spanning-tree problem.</p>
<p>Tarjan attributes the first minimum-spanning-tree algorithm to a 1926 paper by O. Bor<span class="font1">ů</span>vka. Bor<span class="font1">ů</span>vka’s algorithm consists of running <em>O</em>(lg <em>V</em>) iterations of the procedure MST-R<small>EDUCE</small> described in Problem 21-2. Kruskal’s algorithm was reported by Kruskal [<a epub:type="noteref" href="bibliography001.xhtml#endnote_272">272</a>] in 1956. The algorithm commonly known as Prim’s algorithm was indeed invented by Prim [<a epub:type="noteref" href="bibliography001.xhtml#endnote_367">367</a>], but it was also invented earlier by V. Jarník in 1930.</p>
<p>When |<em>E</em>| = Ω(<em>V</em> lg <em>V</em>), Prim’s algorithm, implemented with a Fibonacci heap, runs in <em>O</em>(<em>E</em>) time. For sparser graphs, using a combination of the ideas from Prim’s algorithm, Kruskal’s algorithm, and Bor<span class="font1">ů</span>vka’s algorithm, together with advanced data structures, Fredman and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_156">156</a>] give an algorithm that runs in <em>O</em>(<em>E</em> lg* <em>V</em>) time. Gabow, Galil, Spencer, and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_165">165</a>] improved this algorithm to run in <em>O</em>(<em>E</em> lg lg* <em>V</em>) time. Chazelle [<a epub:type="noteref" href="bibliography001.xhtml#endnote_83">83</a>] gives an algorithm that runs in <em>O</em>(<em>E</em> <img alt="art" src="images/alphac.jpg"/>(<em>E</em>, <em>V</em>)) time, where <img alt="art" src="images/alphac.jpg"/>(<em>E</em>, <em>V</em>) is the functional inverse of Ackermann’s function. (See the chapter notes for <a href="chapter019.xhtml">Chapter 19</a> for a brief discussion of Ackermann’s function and its inverse.) Unlike previous minimum-spanning-tree algorithms, Chazelle’s algorithm does not follow the greedy method. Pettie and Ramachandran [<a epub:type="noteref" href="bibliography001.xhtml#endnote_356">356</a>] give an algorithm based on precomputed “MST decision trees” that also runs in <em>O</em>(<em>E</em> <img alt="art" src="images/alphac.jpg"/>(<em>E</em>, <em>V</em>)) time.</p>
<p>A related problem is <span class="blue"><strong><em>spanning-tree verification</em></strong></span>: given a graph <em>G</em> = (<em>V</em>, <em>E</em>) and a tree <em>T</em> ⊆ <em>E</em>, determine whether <em>T</em> is a minimum spanning tree of <em>G</em>. King [<a epub:type="noteref" href="bibliography001.xhtml#endnote_254">254</a>] gives a linear-time algorithm to verify a spanning tree, building on earlier work of Komlós [<a epub:type="noteref" href="bibliography001.xhtml#endnote_269">269</a>] and Dixon, Rauch, and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_120">120</a>].</p>
<p>The above algorithms are all deterministic and fall into the comparison-based model described in <a href="chapter008.xhtml">Chapter 8</a>. Karger, Klein, and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_243">243</a>] give a randomized minimum-spanning-tree algorithm that runs in <em>O</em>(<em>V</em> + <em>E</em>) expected time. This algorithm uses recursion in a manner similar to the linear-time selection algorithm in <a href="chapter009.xhtml#Sec_9.3">Section 9.3</a>: a recursive call on an auxiliary problem identifies a subset of the edges <em>E</em>′ that cannot be in any minimum spanning tree. Another recursive call on <em>E</em> – <em>E</em>′ then finds the minimum spanning tree. The algorithm also uses ideas from Bor<span class="font1">ů</span>vka’s algorithm and King’s algorithm for spanning-tree verification.</p>
<p>Fredman and Willard [<a epub:type="noteref" href="bibliography001.xhtml#endnote_158">158</a>] showed how to find a minimum spanning tree in <em>O</em>(<em>V</em> + <em>E</em>) time using a deterministic algorithm that is not comparison based. Their algorithm assumes that the data are <em>b</em>-bit integers and that the computer memory consists of addressable <em>b</em>-bit words.</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> The phrase “minimum spanning tree” is a shortened form of the phrase “minimum-weight spanning tree.” There is no point in minimizing the number of edges in <em>T</em>, since all spanning trees have exactly |<em>V</em>| − 1 edges by Theorem B.2 on page 1169.</p>
</section>
</section>
</div>
</body>
</html>