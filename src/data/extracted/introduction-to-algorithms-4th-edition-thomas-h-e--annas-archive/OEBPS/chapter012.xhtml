<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p312"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="12 Binary Search Trees">
<p class="chapter-title"><a href="toc.xhtml#chap-12"><strong><span class="blue1">12        Binary Search Trees</span></strong></a></p>
<p class="noindent">The search tree data structure supports each of the dynamic-set operations listed on page 250: S<small>EARCH</small>, M<small>INIMUM</small>, M<small>AXIMUM</small>, P<small>REDECESSOR</small>, S<small>UCCESSOR</small>, I<small>NSERT</small>, and D<small>ELETE</small>. Thus, you can use a search tree both as a dictionary and as a priority queue.</p>
<p>Basic operations on a binary search tree take time proportional to the height of the tree. For a complete binary tree with <em>n</em> nodes, such operations run in Θ(lg <em>n</em>) worst-case time. If the tree is a linear chain of <em>n</em> nodes, however, the same operations take Θ(<em>n</em>) worst-case time. In <a href="chapter013.xhtml">Chapter 13</a>, we’ll see a variation of binary search trees, red-black trees, whose operations guarantee a height of <em>O</em>(lg <em>n</em>). We won’t prove it here, but if you build a binary search tree on a random set of <em>n</em> keys, its expected height is <em>O</em>(lg <em>n</em>) even if you don’t try to limit its height.</p>
<p>After presenting the basic properties of binary search trees, the following sections show how to walk a binary search tree to print its values in sorted order, how to search for a value in a binary search tree, how to find the minimum or maximum element, how to find the predecessor or successor of an element, and how to insert into or delete from a binary search tree. The basic mathematical properties of trees appear in <a href="appendix002.xhtml">Appendix B</a>.</p>
<p class="line1"/>
<section title="12.1 What is a binary search tree?">
<a id="Sec_12.1"/>
<p class="level1" id="h1-69"><a href="toc.xhtml#Rh1-69"><strong>12.1    What is a binary search tree?</strong></a></p>
<p class="noindent">A binary search tree is organized, as the name suggests, in a binary tree, as shown in <a href="chapter012.xhtml#Fig_12-1">Figure 12.1</a>. You can represent such a tree with a linked data structure, as in <a href="chapter010.xhtml#Sec_10.3">Section 10.3</a>. In addition to a <em>key</em> and satellite data, each node object contains attributes <em>left</em>, <em>right</em>, and <em>p</em> that point to the nodes corresponding to its left child, its right child, and its parent, respectively. If a child or the parent is missing, the appropriate attribute contains the value <small>NIL</small>. The tree itself has an attribute <em>root</em> <a id="p313"/>that points to the root node, or <small>NIL</small> if the tree is empty. The root node <em>T.root</em> is the only node in a tree <em>T</em> whose parent is <small>NIL</small>.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_12-1"><img alt="art" src="images/Art_P416.jpg"/></p>
<p class="caption"><strong>Figure 12.1</strong> Binary search trees. For any node <em>x</em>, the keys in the left subtree of <em>x</em> are at most <em>x.key</em>, and the keys in the right subtree of <em>x</em> are at least <em>x.key</em>. Different binary search trees can represent the same set of values. The worst-case running time for most search-tree operations is proportional to the height of the tree. <strong>(a)</strong> A binary search tree on 6 nodes with height 2. The top figure shows how to view the tree conceptually, and the bottom figure shows the <em>left</em>, <em>right</em>, and <em>p</em> attributes in each node, in the style of <a href="chapter010.xhtml#Fig_10-6">Figure 10.6</a> on page 266. <strong>(b)</strong> A less efficient binary search tree, with height 4, that contains the same keys.</p>
</div>
<p>The keys in a binary search tree are always stored in such a way as to satisfy the <strong><em><span class="blue1">binary-search-tree property</span></em></strong>:</p>
<a id="p314"/>
<div class="pull-quote">
<p class="pq-noindent">Let <em>x</em> be a node in a binary search tree. If <em>y</em> is a node in the left subtree of <em>x</em>, then <em>y.key</em> ≤ <em>x.key</em>. If <em>y</em> is a node in the right subtree of <em>x</em>, then <em>y.key</em> ≥ <em>x.key</em>.</p>
</div>
<p>Thus, in <a href="chapter012.xhtml#Fig_12-1">Figure 12.1(a)</a>, the key of the root is 6, the keys 2, 5, and 5 in its left subtree are no larger than 6, and the keys 7 and 8 in its right subtree are no smaller than 6. The same property holds for every node in the tree. For example, looking at the root’s left child as the root of a subtree, this subtree root has the key 5, the key 2 in its left subtree is no larger than 5, and the key 5 in its right subtree is no smaller than 5.</p>
<p>Because of the binary-search-tree property, you can print out all the keys in a binary search tree in sorted order by a simple recursive algorithm, called an <strong><em><span class="blue1">inorder tree walk</span></em></strong>, given by the procedure I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small>. This algorithm is so named because it prints the key of the root of a subtree between printing the values in its left subtree and printing those in its right subtree. (Similarly, a <strong><em><span class="blue1">preorder tree walk</span></em></strong> prints the root before the values in either subtree, and a <strong><em><span class="blue1">postorder tree walk</span></em></strong> prints the root after the values in its subtrees.) To print all the elements in a binary search tree <em>T</em>, call I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small>(<em>T.root</em>). For example, the inorder tree walk prints the keys in each of the two binary search trees from <a href="chapter012.xhtml#Fig_12-1">Figure 12.1</a> in the order 2, 5, 5, 6, 7, 8. The correctness of the algorithm follows by induction directly from the binary-search-tree property.</p>
<div class="pull-quote1">
<p class="box-heading">I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small>(<em>x</em>)</p>
<table class="table1c1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>if</strong> <em>x</em> ≠ <small>NIL</small></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2">I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small>(<em>x.left</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p2">print <em>x.key</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2">I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small>(<em>x.right</em>)</p></td>
</tr>
</table>
</div>
<p>It takes Θ(<em>n</em>) time to walk an <em>n</em>-node binary search tree, since after the initial call, the procedure calls itself recursively exactly twice for each node in the tree—once for its left child and once for its right child. The following theorem gives a formal proof that it takes linear time to perform an inorder tree walk.</p>
<p class="theo"><strong><em>Theorem 12.1</em></strong></p>
<p class="noindent">If <em>x</em> is the root of an <em>n</em>-node subtree, then the call I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small>(<em>x</em>) takes Θ(<em>n</em>) time.</p>
<p class="proof"><strong><em>Proof</em></strong>   Let <em>T</em>(<em>n</em>) denote the time taken by I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small> when it is called on the root of an <em>n</em>-node subtree. Since I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small> visits all <em>n</em> nodes of the subtree, we have <em>T</em>(<em>n</em>) = Ω(<em>n</em>). It remains to show that <em>T</em>(<em>n</em>) = <em>O</em>(<em>n</em>).</p>
<a id="p315"/>
<p>Since I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small> takes a small, constant amount of time on an empty subtree (for the test <em>x</em> ≠ <small>NIL</small>), we have <em>T</em>(0) = <em>c</em> for some constant <em>c</em> &gt; 0.</p>
<p>For <em>n</em> &gt; 0, suppose that I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small> is called on a node <em>x</em> whose left subtree has <em>k</em> nodes and whose right subtree has <em>n</em> − <em>k</em> − 1 nodes. The time to perform I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small>(<em>x</em>) is bounded by <em>T</em>(<em>n</em>) ≤ <em>T</em>(<em>k</em>) + <em>T</em>(<em>n</em> − <em>k</em> − 1) + <em>d</em> for some constant <em>d</em> &gt; 0 that reflects an upper bound on the time to execute the body of I<small>NORDER</small>-T<small>REE</small>-W<small>ALK</small>(<em>x</em>), exclusive of the time spent in recursive calls.</p>
<p>We use the substitution method to show that <em>T</em>(<em>n</em>) = <em>O</em>(<em>n</em>) by proving that <em>T</em>(<em>n</em>) ≤ (<em>c</em> + <em>d</em>)<em>n</em> + <em>c</em>. For <em>n</em> = 0, we have (<em>c</em> + <em>d</em>) · 0 + <em>c</em> = <em>c</em> = <em>T</em>(0). For <em>n</em> &gt; 0, we have</p>
<table class="table2b">
<tr>
<td class="td2"><em>T</em>(<em>n</em>)</td>
<td class="td2">≤</td>
<td class="td2"><em>T</em>(<em>k</em>) + <em>T</em>(<em>n</em> − <em>k</em> − 1) + <em>d</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤</td>
<td class="td2">((<em>c</em> + <em>d</em>)<em>k</em> + <em>c</em>) + ((<em>c</em> + <em>d</em>)(<em>n</em> − <em>k</em> − 1) + <em>c</em>) + <em>d</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">(<em>c</em> + <em>d</em>)<em>n</em> + <em>c</em> − (<em>c</em> + <em>d</em>) + <em>c</em> + <em>d</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">(<em>c</em> + <em>d</em>)<em>n</em> + <em>c</em>,</td>
</tr>
</table>
<p class="noindent">which completes the proof.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>12.1-1</em></strong></p>
<p class="noindent">For the set {1, 4, 5, 10, 16, 17, 21} of keys, draw binary search trees of heights 2, 3, 4, 5, and 6.</p>
<p class="level3"><strong><em>12.1-2</em></strong></p>
<p class="noindent">What is the difference between the binary-search-tree property and the min-heap property on page 163? Can the min-heap property be used to print out the keys of an <em>n</em>-node tree in sorted order in <em>O</em>(<em>n</em>) time? Show how, or explain why not.</p>
<p class="level3"><strong><em>12.1-3</em></strong></p>
<p class="noindent">Give a nonrecursive algorithm that performs an inorder tree walk. (<em>Hint:</em> An easy solution uses a stack as an auxiliary data structure. A more complicated, but elegant, solution uses no stack but assumes that you can test two pointers for equality.)</p>
<p class="level3"><strong><em>12.1-4</em></strong></p>
<p class="noindent">Give recursive algorithms that perform preorder and postorder tree walks in Θ(<em>n</em>) time on a tree of <em>n</em> nodes.</p>
<p class="level3"><strong><em>12.1-5</em></strong></p>
<p class="noindent">Argue that since sorting <em>n</em> elements takes Ω(<em>n</em> lg <em>n</em>) time in the worst case in the comparison model, any comparison-based algorithm for constructing a binary search tree from an arbitrary list of <em>n</em> elements takes Ω(<em>n</em> lg <em>n</em>) time in the worst case.</p>
<a id="p316"/>
</section>
<p class="line1"/>
<section title="12.2 Querying a binary search tree">
<a id="Sec_12.2"/>
<p class="level1" id="h1-70"><a href="toc.xhtml#Rh1-70"><strong>12.2    Querying a binary search tree</strong></a></p>
<p class="noindent">Binary search trees can support the queries M<small>INIMUM</small>, M<small>AXIMUM</small>, S<small>UCCESSOR</small>, and P<small>REDECESSOR</small>, as well as S<small>EARCH</small>. This section examines these operations and shows how to support each one in <em>O</em>(<em>h</em>) time on any binary search tree of height <em>h</em>.</p>
<p class="level4"><strong>Searching</strong></p>
<p class="noindent">To search for a node with a given key in a binary search tree, call the T<small>REE</small>-S<small>EARCH</small> procedure. Given a pointer <em>x</em> to the root of a subtree and a key <em>k</em>, T<small>REE</small>-S<small>EARCH</small>(<em>x</em>, <em>k</em>) returns a pointer to a node with key <em>k</em> if one exists in the subtree; otherwise, it returns <small>NIL</small>. To search for key <em>k</em> in the entire binary search tree <em>T</em>, call T<small>REE</small>-S<small>EARCH</small>(<em>T.root</em>, <em>k</em>).</p>
<div class="pull-quote1">
<p class="box-heading">T<small>REE</small>-S<small>EARCH</small>(<em>x</em>, <em>k</em>)</p>
<table class="table1c1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>if</strong> <em>x</em> == <small>NIL</small> or <em>k</em> == <em>x.key</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><strong>return</strong> <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><strong>if</strong> <em>k</em> &lt; <em>x.key</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><strong>return</strong> T<small>REE</small>-S<small>EARCH</small>(<em>x.left</em>, <em>k</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><strong>else return</strong> T<small>REE</small>-S<small>EARCH</small>(<em>x.right</em>, <em>k</em>)</td>
</tr>
</table>
<p class="box-headinga">I<small>TERATIVE</small>-T<small>REE</small>-S<small>EARCH</small>(<em>x</em>, <em>k</em>)</p>
<table class="table1c1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>while</strong> <em>x</em> ≠ <small>NIL</small> and <em>k</em> ≠ <em>x.key</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>k</em> &lt; <em>x.key</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p3"><em>x</em> = <em>x.left</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><strong>else</strong> <em>x</em> = <em>x.right</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><strong>return</strong> <em>x</em></td>
</tr>
</table>
</div>
<p>The T<small>REE</small>-S<small>EARCH</small> procedure begins its search at the root and traces a simple path downward in the tree, as shown in <a href="chapter012.xhtml#Fig_12-2">Figure 12.2(a)</a>. For each node <em>x</em> it encounters, it compares the key <em>k</em> with <em>x.key</em>. If the two keys are equal, the search terminates. If <em>k</em> is smaller than <em>x.key</em>, the search continues in the left subtree of <em>x</em>, since the binary-search-tree property implies that <em>k</em> cannot reside in the right subtree. Symmetrically, if <em>k</em> is larger than <em>x.key</em>, the search continues in the right subtree. The nodes encountered during the recursion form a simple path downward from the root of the tree, and thus the running time of T<small>REE</small>-S<small>EARCH</small> is <em>O</em>(<em>h</em>), where <em>h</em> is the height of the tree.</p>
<a id="p317"/>
<div class="divimage">
<p class="fig-imga" id="Fig_12-2"><img alt="art" src="images/Art_P417.jpg"/></p>
<p class="caption"><strong>Figure 12.2</strong> Queries on a binary search tree. Nodes and paths followed in each query are colored blue. <strong>(a)</strong> A search for the key 13 in the tree follows the path 15 → 6 → 7 → 13 from the root. <strong>(b)</strong> The minimum key in the tree is 2, which is found by following <em>left</em> pointers from the root. The maximum key 20 is found by following <em>right</em> pointers from the root. <strong>(c)</strong> The successor of the node with key 15 is the node with key 17, since it is the minimum key in the right subtree of 15. <strong>(d)</strong> The node with key 13 has no right subtree, and thus its successor is its lowest ancestor whose left child is also an ancestor. In this case, the node with key 15 is its successor.</p>
</div>
<p>Since the T<small>REE</small>-S<small>EARCH</small> procedure recurses on either the left subtree or the right subtree, but not both, we can rewrite the algorithm to “unroll” the recursion into a <strong>while</strong> loop. On most computers, the I<small>TERATIVE</small>-T<small>REE</small>-S<small>EARCH</small> procedure on the facing page is more efficient.</p>
<p class="level4"><strong>Minimum and maximum</strong></p>
<p class="noindent">To find an element in a binary search tree whose key is a minimum, just follow <em>left</em> child pointers from the root until you encounter a <small>NIL</small>, as shown in <a href="chapter012.xhtml#Fig_12-2">Figure 12.2(b)</a>. <a id="p318"/>The T<small>REE</small>-M<small>INIMUM</small> procedure returns a pointer to the minimum element in the subtree rooted at a given node <em>x</em>, which we assume to be non-<small>NIL</small>.</p>
<div class="pull-quote1">
<p class="box-heading">T<small>REE</small>-M<small>INIMUM</small>(<em>x</em>)</p>
<table class="table1n">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>while</strong> <em>x.left</em> ≠ <small>NIL</small></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><em>x</em> = <em>x.left</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><strong>return</strong> <em>x</em></td>
</tr>
</table>
<p class="box-headinga">T<small>REE</small>-M<small>AXIMUM</small>(<em>x</em>)</p>
<table class="table1n">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>while</strong> <em>x.right</em> ≠ <small>NIL</small></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><em>x</em> = <em>x.right</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><strong>return</strong> <em>x</em></td>
</tr>
</table>
</div>
<p>The binary-search-tree property guarantees that T<small>REE</small>-M<small>INIMUM</small> is correct. If node <em>x</em> has no left subtree, then since every key in the right subtree of <em>x</em> is at least as large as <em>x.key</em>, the minimum key in the subtree rooted at <em>x</em> is <em>x.key</em>. If node <em>x</em> has a left subtree, then since no key in the right subtree is smaller than <em>x.key</em> and every key in the left subtree is not larger than <em>x.key</em>, the minimum key in the subtree rooted at <em>x</em> resides in the subtree rooted at <em>x.left</em>.</p>
<p>The pseudocode for T<small>REE</small>-M<small>AXIMUM</small> is symmetric. Both T<small>REE</small>-M<small>INIMUM</small> and T<small>REE</small>-M<small>AXIMUM</small> run in <em>O</em>(<em>h</em>) time on a tree of height <em>h</em> since, as in T<small>REE</small>-S<small>EARCH</small>, the sequence of nodes encountered forms a simple path downward from the root.</p>
<p class="level4"><strong>Successor and predecessor</strong></p>
<p class="noindent">Given a node in a binary search tree, how can you find its successor in the sorted order determined by an inorder tree walk? If all keys are distinct, the successor of a node <em>x</em> is the node with the smallest key greater than <em>x.key</em>. Regardless of whether the keys are distinct, we define the <strong><em><span class="blue1">successor</span></em></strong> of a node as the next node visited in an inorder tree walk. The structure of a binary search tree allows you to determine the successor of a node without comparing keys. The T<small>REE</small>-S<small>UCCESSOR</small> procedure on the facing page returns the successor of a node <em>x</em> in a binary search tree if it exists, or <small>NIL</small> if <em>x</em> is the last node that would be visited during an inorder walk.</p>
<p>The code for T<small>REE</small>-S<small>UCCESSOR</small> has two cases. If the right subtree of node <em>x</em> is nonempty, then the successor of <em>x</em> is just the leftmost node in <em>x</em>’s right subtree, which line 2 finds by calling T<small>REE</small>-M<small>INIMUM</small>(<em>x.right</em>). For example, the successor of the node with key 15 in <a href="chapter012.xhtml#Fig_12-2">Figure 12.2(c)</a> is the node with key 17.</p>
<p>On the other hand, as Exercise 12.2-6 asks you to show, if the right subtree of node <em>x</em> is empty and <em>x</em> has a successor <em>y</em>, then <em>y</em> is the lowest ancestor of <em>x</em> whose <a id="p319"/>left child is also an ancestor of <em>x</em>. In <a href="chapter012.xhtml#Fig_12-2">Figure 12.2(d)</a>, the successor of the node with key 13 is the node with key 15. To find <em>y</em>, go up the tree from <em>x</em> until you encounter either the root or a node that is the left child of its parent. Lines 4–8 of T<small>REE</small>-S<small>UCCESSOR</small> handle this case.</p>
<div class="pull-quote1">
<p class="box-heading">T<small>REE</small>-S<small>UCCESSOR</small>(<em>x</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>if</strong> <em>x.right</em> ≠ <small>NIL</small></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><strong>return</strong> T<small>REE</small>-M<small>INIMUM</small>(<em>x.right</em>)  <span class="red"><strong>//</strong> leftmost node in right subtree</span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><strong>else</strong> <span class="red"><strong>//</strong> find the lowest ancestor of <em>x</em> whose left child is an ancestor of <em>x</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><em>y</em> = <em>x.p</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p2"><strong>while</strong> <em>y</em> ≠ <small>NIL</small> and <em>x</em> == <em>y.right</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><p class="p3"><em>x</em> = <em>y</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">7</span></td>
<td class="td1"><p class="p3"><em>y</em> = <em>y.p</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">8</span></td>
<td class="td1"><p class="p2"><strong>return</strong> <em>y</em></p></td>
</tr>
</table>
</div>
<p>The running time of T<small>REE</small>-S<small>UCCESSOR</small> on a tree of height <em>h</em> is <em>O</em>(<em>h</em>), since it either follows a simple path up the tree or follows a simple path down the tree. The procedure T<small>REE</small>-P<small>REDECESSOR</small>, which is symmetric to T<small>REE</small>-S<small>UCCESSOR</small>, also runs in <em>O</em>(<em>h</em>) time.</p>
<p>In summary, we have proved the following theorem.</p>
<p class="theo"><strong><em>Theorem 12.2</em></strong></p>
<p class="noindent">The dynamic-set operations S<small>EARCH</small>, M<small>INIMUM</small>, M<small>AXIMUM</small>, S<small>UCCESSOR</small>, and P<small>REDECESSOR</small> can be implemented so that each one runs in <em>O</em>(<em>h</em>) time on a binary search tree of height <em>h</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>12.2-1</em></strong></p>
<p class="noindent">You are searching for the number 363 in a binary search tree containing numbers between 1 and 1000. Which of the following sequences <em>cannot</em> be the sequence of nodes examined?</p>
<p class="nl"><strong><em>a.</em></strong> 2, 252, 401, 398, 330, 344, 397, 363.</p>
<p class="nl"><strong><em>b.</em></strong> 924, 220, 911, 244, 898, 258, 362, 363.</p>
<p class="nl"><strong><em>c.</em></strong> 925, 202, 911, 240, 912, 245, 363.</p>
<p class="nl"><strong><em>d.</em></strong> 2, 399, 387, 219, 266, 382, 381, 278, 363.</p>
<p class="nl"><strong><em>e.</em></strong> 935, 278, 347, 621, 299, 392, 358, 363.</p>
<a id="p320"/>
<p class="level3"><strong><em>12.2-2</em></strong></p>
<p class="noindent">Write recursive versions of T<small>REE</small>-M<small>INIMUM</small> and T<small>REE</small>-M<small>AXIMUM</small>.</p>
<p class="level3"><strong><em>12.2-3</em></strong></p>
<p class="noindent">Write the T<small>REE</small>-P<small>REDECESSOR</small> procedure.</p>
<p class="level3"><strong><em>12.2-4</em></strong></p>
<p class="noindent">Professor Kilmer claims to have discovered a remarkable property of binary search trees. Suppose that the search for key <em>k</em> in a binary search tree ends up at a leaf. Consider three sets: <em>A</em>, the keys to the left of the search path; <em>B</em>, the keys on the search path; and <em>C</em>, the keys to the right of the search path. Professor Kilmer claims that any three keys <em>a</em> ∈ <em>A</em>, <em>b</em> ∈ <em>B</em>, and <em>c</em> ∈ <em>C</em> must satisfy <em>a</em> ≤ <em>b</em> ≤ <em>c</em>. Give a smallest possible counterexample to the professor’s claim.</p>
<p class="level3"><strong><em>12.2-5</em></strong></p>
<p class="noindent">Show that if a node in a binary search tree has two children, then its successor has no left child and its predecessor has no right child.</p>
<p class="level3"><strong><em>12.2-6</em></strong></p>
<p class="noindent">Consider a binary search tree <em>T</em> whose keys are distinct. Show that if the right subtree of a node <em>x</em> in <em>T</em> is empty and <em>x</em> has a successor <em>y</em>, then <em>y</em> is the lowest ancestor of <em>x</em> whose left child is also an ancestor of <em>x</em>. (Recall that every node is its own ancestor.)</p>
<p class="level3"><strong><em>12.2-7</em></strong></p>
<p class="noindent">An alternative method of performing an inorder tree walk of an <em>n</em>-node binary search tree finds the minimum element in the tree by calling T<small>REE</small>-M<small>INIMUM</small> and then making <em>n</em> − 1 calls to T<small>REE</small>-S<small>UCCESSOR</small>. Prove that this algorithm runs in Θ(<em>n</em>) time.</p>
<p class="level3"><strong><em>12.2-8</em></strong></p>
<p class="noindent">Prove that no matter what node you start at in a height-<em>h</em> binary search tree, <em>k</em> successive calls to T<small>REE</small>-S<small>UCCESSOR</small> take <em>O</em>(<em>k</em> + <em>h</em>) time.</p>
<p class="level3"><strong><em>12.2-9</em></strong></p>
<p class="noindent">Let <em>T</em> be a binary search tree whose keys are distinct, let <em>x</em> be a leaf node, and let <em>y</em> be its parent. Show that <em>y.key</em> is either the smallest key in <em>T</em> larger than <em>x.key</em> or the largest key in <em>T</em> smaller than <em>x.key</em>.</p>
<a id="p321"/>
</section>
<p class="line1"/>
<section title="12.3 Insertion and deletion">
<a id="Sec_12.3"/>
<p class="level1" id="h1-71"><a href="toc.xhtml#Rh1-71"><strong>12.3    Insertion and deletion</strong></a></p>
<p class="noindent">The operations of insertion and deletion cause the dynamic set represented by a binary search tree to change. The data structure must be modified to reflect this change, but in such a way that the binary-search-tree property continues to hold. We’ll see that modifying the tree to insert a new element is relatively straightforward, but deleting a node from a binary search tree is more complicated.</p>
<p class="level4"><strong>Insertion</strong></p>
<p class="noindent">The T<small>REE</small>-I<small>NSERT</small> procedure inserts a new node into a binary search tree. The procedure takes a binary search tree <em>T</em> and a node <em>z</em> for which <em>z.key</em> has already been filled in, <em>z.left</em> = <small>NIL</small>, and <em>z.right</em> = <small>NIL</small>. It modifies <em>T</em> and some of the attributes of <em>z</em> so as to insert <em>z</em> into an appropriate position in the tree.</p>
<div class="pull-quote1">
<p class="box-heading">T<small>REE</small>-I<small>NSERT</small>(<em>T</em>, <em>z</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><em>x</em> = <em>T.root</em></td>
<td class="td1"><span class="red"><strong>//</strong> node being compared with <em>z</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><em>y</em> = <small>NIL</small></td>
<td class="td1"><span class="red"><strong>//</strong> <em>y</em> will be parent of <em>z</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><strong>while</strong> <em>x</em> ≠ <small>NIL</small></td>
<td class="td1"><span class="red"><strong>//</strong> descend until reaching a leaf</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2"><em>y</em> = <em>x</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>z.key</em> &lt; <em>x.key</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p3"><em>x</em> = <em>x.left</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p2"><strong>else</strong> <em>x</em> = <em>x.right</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><em>z.p</em> = <em>y</em></td>
<td class="td1"><span class="red"><strong>//</strong> found the location—insert <em>z</em> with parent <em>y</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><strong>if</strong> <em>y</em> == <small>NIL</small></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="p2"><em>T.root</em> = <em>z</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> tree <em>T</em> was empty</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><strong>elseif</strong> <em>z.key</em> &lt; <em>y.key</em></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1"><p class="p2"><em>y.left</em> = <em>z</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1"><strong>else</strong> <em>y.right</em> = <em>z</em></td>
<td class="td1"/>
</tr>
</table>
</div>
<p><a href="chapter012.xhtml#Fig_12-3">Figure 12.3</a> shows how T<small>REE</small>-I<small>NSERT</small> works. Just like the procedures T<small>REE</small>-S<small>EARCH</small> and I<small>TERATIVE</small>-T<small>REE</small>-S<small>EARCH</small>, T<small>REE</small>-I<small>NSERT</small> begins at the root of the tree and the pointer <em>x</em> traces a simple path downward looking for a <small>NIL</small> to replace with the input node <em>z</em>. The procedure maintains the <strong><em><span class="blue1">trailing pointer</span></em></strong> <em>y</em> as the parent of <em>x</em>. After initialization, the <strong>while</strong> loop in lines 3–7 causes these two pointers to move down the tree, going left or right depending on the comparison of <em>z.key</em> with <em>x.key</em>, until <em>x</em> becomes <small>NIL</small>. This <small>NIL</small> occupies the position where node <em>z</em> will go. More precisely, this <small>NIL</small> is a <em>left</em> or <em>right</em> attribute of the node that will become <em>z</em>’s parent, or it is <em>T.root</em> if tree <em>T</em> is currently empty. The procedure needs the <a id="p322"/>trailing pointer <em>y</em>, because by the time it finds the <small>NIL</small> where <em>z</em> belongs, the search has proceeded one step beyond the node that needs to be changed. Lines 8–13 set the pointers that cause <em>z</em> to be inserted.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_12-3"><img alt="art" src="images/Art_P418.jpg"/></p>
<p class="caption"><strong>Figure 12.3</strong> Inserting a node with key 13 into a binary search tree. The simple path from the root down to the position where the node is inserted is shown in blue. The new node and the link to its parent are highlighted in orange.</p>
</div>
<p>Like the other primitive operations on search trees, the procedure T<small>REE</small>-I<small>NSERT</small> runs in <em>O</em>(<em>h</em>) time on a tree of height <em>h</em>.</p>
<p class="level4"><strong>Deletion</strong></p>
<p class="noindent">The overall strategy for deleting a node <em>z</em> from a binary search tree <em>T</em> has three basic cases and, as we’ll see, one of the cases is a bit tricky.</p>
<ul class="ulnoindent" epub:type="list">
<li>If <em>z</em> has no children, then simply remove it by modifying its parent to replace <em>z</em> with <small>NIL</small> as its child.</li>
<li class="litop">If <em>z</em> has just one child, then elevate that child to take <em>z</em>’s position in the tree by modifying <em>z</em>’s parent to replace <em>z</em> by <em>z</em>’s child.</li>
<li class="litop">If <em>z</em> has two children, find <em>z</em>’s successor <em>y</em>—which must belong to <em>z</em>’s right subtree—and move <em>y</em> to take <em>z</em>’s position in the tree. The rest of <em>z</em>’s original right subtree becomes <em>y</em>’s new right subtree, and <em>z</em>’s left subtree becomes <em>y</em>’s new left subtree. Because <em>y</em> is <em>z</em>’s successor, it cannot have a left child, and <em>y</em>’s original right child moves into <em>y</em>’s original position, with the rest of <em>y</em>’s original right subtree following automatically. This case is the tricky one because, as we’ll see, it matters whether <em>y</em> is <em>z</em>’s right child.</li></ul>
<p>The procedure for deleting a given node <em>z</em> from a binary search tree <em>T</em> takes as arguments pointers to <em>T</em> and <em>z</em>. It organizes its cases a bit differently from the three cases outlined previously by considering the four cases shown in <a href="chapter012.xhtml#Fig_12-4">Figure 12.4</a>.</p>
<a id="p323"/>
<div class="divimage">
<p class="fig-imga" id="Fig_12-4"><img alt="art" class="width100" src="images/Art_P419.jpg"/></p>
<p class="caption"><strong>Figure 12.4</strong> Deleting a node <em>z</em>, in blue, from a binary search tree. Node <em>z</em> may be the root, a left child of node <em>q</em>, or a right child of <em>q</em>. The node that will replace node <em>z</em> in its position in the tree is colored orange. <strong>(a)</strong> Node <em>z</em> has no left child. Replace <em>z</em> by its right child <em>r</em>, which may or may not be <small>NIL</small>. <strong>(b)</strong> Node <em>z</em> has a left child <em>l</em> but no right child. Replace <em>z</em> by <em>l</em>. <strong>(c)</strong> Node <em>z</em> has two children. Its left child is node <em>l</em>, its right child is its successor <em>y</em> (which has no left child), and <em>y</em>’s right child is node <em>x</em>. Replace <em>z</em> by <em>y</em>, updating <em>y</em>’s left child to become <em>l</em>, but leaving <em>x</em> as <em>y</em>’s right child. <strong>(d)</strong> Node <em>z</em> has two children (left child <em>l</em> and right child <em>r</em>), and its successor <em>y</em> ≠ <em>r</em> lies within the subtree rooted at <em>r</em>. First replace <em>y</em> by its own right child <em>x</em>, and set <em>y</em> to be <em>r</em>’s parent. Then set <em>y</em> to be <em>q</em>’s child and the parent of <em>l</em>.</p>
</div>
<ul class="ulnoindent" epub:type="list">
<li>If <em>z</em> has no left child, then as in part (a) of the figure, replace <em>z</em> by its right child, which may or may not be <small>NIL</small>. When <em>z</em>’s right child is <small>NIL</small>, this case deals with <a id="p324"/>the situation in which <em>z</em> has no children. When <em>z</em>’s right child is non-<small>NIL</small>, this case handles the situation in which <em>z</em> has just one child, which is its right child.</li>
<li class="litop">Otherwise, if <em>z</em> has just one child, then that child is a left child. As in part (b) of the figure, replace <em>z</em> by its left child.</li>
<li class="litop">Otherwise, <em>z</em> has both a left and a right child. Find <em>z</em>’s successor <em>y</em>, which lies in <em>z</em>’s right subtree and has no left child (see Exercise 12.2-5). Splice node <em>y</em> out of its current location and replace <em>z</em> by <em>y</em> in the tree. How to do so depends on whether <em>y</em> is <em>z</em>’s right child:
<ul class="ulnoindent1" epub:type="list">
<li class="litop">If <em>y</em> is <em>z</em>’s right child, then as in part (c) of the figure, replace <em>z</em> by <em>y</em>, leaving <em>y</em>’s right child alone.</li>
<li class="litop">Otherwise, <em>y</em> lies within <em>z</em>’s right subtree but is not <em>z</em>’s right child. In this case, as in part (d) of the figure, first replace <em>y</em> by its own right child, and then replace <em>z</em> by <em>y</em>.</li></ul>
</li></ul>
<p>As part of the process of deleting a node, subtrees need to move around within the binary search tree. The subroutine T<small>RANSPLANT</small> replaces one subtree as a child of its parent with another subtree. When T<small>RANSPLANT</small> replaces the subtree rooted at node <em>u</em> with the subtree rooted at node <em>v</em>, node <em>u</em>’s parent becomes node <em>v</em>’s parent, and <em>u</em>’s parent ends up having <em>v</em> as its appropriate child. T<small>RANSPLANT</small> allows <em>v</em> to be <small>NIL</small> instead of a pointer to a node.</p>
<div class="pull-quote1">
<p class="box-heading">T<small>RANSPLANT</small>(<em>T</em>, <em>u</em>, <em>v</em>)</p>
<table class="table1c1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>if</strong> <em>u.p</em> == <small>NIL</small></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><em>T.root</em> = <em>v</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><strong>elseif</strong> <em>u</em> == <em>u.p.left</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><em>u.p.left</em> = <em>v</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><strong>else</strong> <em>u.p.right</em> = <em>v</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><strong>if</strong> <em>v</em> ≠ <small>NIL</small></td>
</tr>
<tr>
<td class="td1"><span class="x-small">7</span></td>
<td class="td1"><p class="p2"><em>v.p</em> = <em>u.p</em></p></td>
</tr>
</table>
</div>
<p>Here is how T<small>RANSPLANT</small> works. Lines 1–2 handle the case in which <em>u</em> is the root of <em>T</em>. Otherwise, <em>u</em> is either a left child or a right child of its parent. Lines 3–4 take care of updating <em>u.p.left</em> if <em>u</em> is a left child, and line 5 updates <em>u.p.right</em> if <em>u</em> is a right child. Because <em>v</em> may be <small>NIL</small>, lines 6–7 update <em>v.p</em> only if <em>v</em> is non-<small>NIL</small>. The procedure T<small>RANSPLANT</small> does not attempt to update <em>v.left</em> and <em>v.right</em>. Doing so, or not doing so, is the responsibility of T<small>RANSPLANT</small>’s caller.</p>
<p>The procedure T<small>REE</small>-D<small>ELETE</small> on the facing page uses T<small>RANSPLANT</small> to delete node <em>z</em> from binary search tree <em>T</em>. It executes the four cases as follows. Lines 1–2 handle the case in which node <em>z</em> has no left child (<a href="chapter012.xhtml#Fig_12-4">Figure 12.4(a)</a>), and lines 3–4 <a id="p325"/>handle the case in which <em>z</em> has a left child but no right child (<a href="chapter012.xhtml#Fig_12-4">Figure 12.4(b)</a>). Lines 5–12 deal with the remaining two cases, in which <em>z</em> has two children. Line 5 finds node <em>y</em>, which is the successor of <em>z</em>. Because <em>z</em> has a nonempty right subtree, its successor must be the node in that subtree with the smallest key; hence the call to T<small>REE</small>-M<small>INIMUM</small>(<em>z.right</em>). As we noted before, <em>y</em> has no left child. The procedure needs to splice <em>y</em> out of its current location and replace <em>z</em> by <em>y</em> in the tree. If <em>y</em> is <em>z</em>’s right child (<a href="chapter012.xhtml#Fig_12-4">Figure 12.4(c)</a>), then lines 10–12 replace <em>z</em> as a child of its parent by <em>y</em> and replace <em>y</em>’s left child by <em>z</em>’s left child. Node <em>y</em> retains its right child (<em>x</em> in <a href="chapter012.xhtml#Fig_12-4">Figure 12.4(c)</a>), and so no change to <em>y.right</em> needs to occur. If <em>y</em> is not <em>z</em>’s right child (<a href="chapter012.xhtml#Fig_12-4">Figure 12.4(d)</a>), then two nodes have to move. Lines 7–9 replace <em>y</em> as a child of its parent by <em>y</em>’s right child (<em>x</em> in <a href="chapter012.xhtml#Fig_12-4">Figure 12.4(c)</a>) and make <em>z</em>’s right child (<em>r</em> in the figure) become <em>y</em>’s right child instead. Finally, lines 10–12 replace <em>z</em> as a child of its parent by <em>y</em> and replace <em>y</em>’s left child by <em>z</em>’s left child.</p>
<div class="pull-quote1">
<p class="box-heading">T<small>REE</small>-D<small>ELETE</small>(<em>T</em>, <em>z</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><strong>if</strong> <em>z.left</em> == <small>NIL</small></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><p class="p2">T<small>RANSPLANT</small>(<em>T</em>, <em>z</em>, <em>z.right</em>)</p></td>
<td class="td1"><span class="red"><strong>//</strong> replace <em>z</em> by its right child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><strong>elseif</strong> <em>z.right</em> == <small>NIL</small></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2">T<small>RANSPLANT</small>(<em>T</em>, <em>z</em>, <em>z.left</em>)</p></td>
<td class="td1"><span class="red"><strong>//</strong> replace <em>z</em> by its left child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><strong>else</strong> <em>y</em> = T<small>REE</small>-M<small>INIMUM</small>(<em>z.right</em>)</td>
<td class="td1"><span class="red"><strong>//</strong> <em>y</em> is <em>z</em>’s successor</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>y</em> ≠ <em>z.right</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> is <em>y</em> farther down the tree?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p3">T<small>RANSPLANT</small>(<em>T</em>, <em>y</em>, <em>y.right</em>)</p></td>
<td class="td1"><span class="red"><strong>//</strong> replace <em>y</em> by its right child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="p3"><em>y.right</em> = <em>z.right</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> <em>z</em>’s right child becomes</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="p3"><em>y.right.p</em> = <em>y</em></p></td>
<td class="td1"><span class="red"><strong>//</strong>      <em>y</em>’s right child</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="p2">T<small>RANSPLANT</small>(<em>T</em>, <em>z</em>, <em>y</em>)</p></td>
<td class="td1"><span class="red"><strong>//</strong> replace <em>z</em> by its successor <em>y</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><p class="p2"><em>y.left</em> = <em>z.left</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> and give <em>z</em>’s left child to y,</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1"><p class="p2"><em>y.left.p</em> = <em>y</em></p></td>
<td class="td1"><span class="red"><strong>//</strong>      which had no left child</span></td>
</tr>
</table>
</div>
<p>Each line of T<small>REE</small>-D<small>ELETE</small>, including the calls to T<small>RANSPLANT</small>, takes constant time, except for the call to T<small>REE</small>-M<small>INIMUM</small> in line 5. Thus, T<small>REE</small>-D<small>ELETE</small> runs in <em>O</em>(<em>h</em>) time on a tree of height <em>h</em>.</p>
<p>In summary, we have proved the following theorem.</p>
<p class="theo"><strong><em>Theorem 12.3</em></strong></p>
<p class="noindent">The dynamic-set operations I<small>NSERT</small> and D<small>ELETE</small> can be implemented so that each one runs in <em>O</em>(<em>h</em>) time on a binary search tree of height <em>h</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<a id="p326"/>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>12.3-1</em></strong></p>
<p class="noindent">Give a recursive version of the T<small>REE</small>-I<small>NSERT</small> procedure.</p>
<p class="level3"><strong><em>12.3-2</em></strong></p>
<p class="noindent">Suppose that you construct a binary search tree by repeatedly inserting distinct values into the tree. Argue that the number of nodes examined in searching for a value in the tree is 1 plus the number of nodes examined when the value was first inserted into the tree.</p>
<p class="level3"><strong><em>12.3-3</em></strong></p>
<p class="noindent">You can sort a given set of <em>n</em> numbers by first building a binary search tree containing these numbers (using T<small>REE</small>-I<small>NSERT</small> repeatedly to insert the numbers one by one) and then printing the numbers by an inorder tree walk. What are the worst-case and best-case running times for this sorting algorithm?</p>
<p class="level3"><strong><em>12.3-4</em></strong></p>
<p class="noindent">When T<small>REE</small>-D<small>ELETE</small> calls T<small>RANSPLANT</small>, under what circumstances can the parameter <em>v</em> of T<small>RANSPLANT</small> be <small>NIL</small>?</p>
<p class="level3"><strong><em>12.3-5</em></strong></p>
<p class="noindent">Is the operation of deletion “commutative” in the sense that deleting <em>x</em> and then <em>y</em> from a binary search tree leaves the same tree as deleting <em>y</em> and then <em>x</em>? Argue why it is or give a counterexample.</p>
<p class="level3"><strong><em>12.3-6</em></strong></p>
<p class="noindent">Suppose that instead of each node <em>x</em> keeping the attribute <em>x.p</em>, pointing to <em>x</em>’s parent, it keeps <em>x.succ</em>, pointing to <em>x</em>’s successor. Give pseudocode for T<small>REE</small>-S<small>EARCH</small>, T<small>REE</small>-I<small>NSERT</small>, and T<small>REE</small>-D<small>ELETE</small> on a binary search tree <em>T</em> using this representation. These procedures should operate in <em>O</em>(<em>h</em>) time, where <em>h</em> is the height of the tree <em>T</em>. You may assume that all keys in the binary search tree are distinct. (<em>Hint:</em> You might wish to implement a subroutine that returns the parent of a node.)</p>
<p class="level3"><strong><em>12.3-7</em></strong></p>
<p class="noindent">When node <em>z</em> in T<small>REE</small>-D<small>ELETE</small> has two children, you can choose node <em>y</em> to be its predecessor rather than its successor. What other changes to T<small>REE</small>-D<small>ELETE</small> are necessary if you do so? Some have argued that a fair strategy, giving equal priority to predecessor and successor, yields better empirical performance. How might T<small>REE</small>-D<small>ELETE</small> be minimally changed to implement such a fair strategy?</p>
<a id="p327"/>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-72"><strong>Problems</strong></p>
<section title="12-1 Binary search trees with equal keys">
<p class="level2"><strong><em>12-1     Binary search trees with equal keys</em></strong></p>
<p class="noindent">Equal keys pose a problem for the implementation of binary search trees.</p>
<p class="nl"><strong><em>a.</em></strong> What is the asymptotic performance of T<small>REE</small>-I<small>NSERT</small> when used to insert <em>n</em> items with identical keys into an initially empty binary search tree?</p>
<p class="noindent1-top">Consider changing T<small>REE</small>-I<small>NSERT</small> to test whether <em>z.key</em> = <em>x.key</em> before line 5 and to test whether <em>z.key</em> = <em>y.key</em> before line 11. If equality holds, implement one of the following strategies. For each strategy, find the asymptotic performance of inserting <em>n</em> items with identical keys into an initially empty binary search tree. (The strategies are described for line 5, which compares the keys of <em>z</em> and <em>x</em>. Substitute <em>y</em> for <em>x</em> to arrive at the strategies for line 11.)</p>
<p class="nl"><strong><em>b.</em></strong> Keep a boolean flag <em>x.b</em> at node <em>x</em>, and set <em>x</em> to either <em>x.left</em> or <em>x.right</em> based on the value of <em>x.b</em>, which alternates between <small>FALSE</small> and <small>TRUE</small> each time T<small>REE</small>-I<small>NSERT</small> visits <em>x</em> while inserting a node with the same key as <em>x</em>.</p>
<p class="nl"><strong><em>c.</em></strong> Keep a list of nodes with equal keys at <em>x</em>, and insert <em>z</em> into the list.</p>
<p class="nl"><strong><em>d.</em></strong> Randomly set <em>x</em> to either <em>x.left</em> or <em>x.right</em>. (Give the worst-case performance and informally derive the expected running time.)</p>
</section>
<section title="12-2 Radix trees">
<p class="level2"><strong><em>12-2     Radix trees</em></strong></p>
<p class="noindent">Given two strings <em>a</em> = <em>a</em><sub>0</sub><em>a</em><sub>1</sub> … <em>a<sub>p</sub></em> and <em>b</em> = <em>b</em><sub>0</sub><em>b</em><sub>1</sub> … <em>b<sub>q</sub></em>, where each <em>a<sub>i</sub></em> and each <em>b<sub>j</sub></em> belongs to some ordered set of characters, we say that string <em>a</em> is <strong><em><span class="blue1">lexicographically less than</span></em></strong> string <em>b</em> if either</p>
<ol class="olnoindent" epub:type="list">
<li>there exists an integer <em>j</em>, where 0 ≤ <em>j</em> ≤ min {<em>p</em>, <em>q</em>}, such that <em>a<sub>i</sub></em> = <em>b<sub>i</sub></em> for all <em>i</em> = 0, 1, …, <em>j</em> − 1 and <em>a<sub>j</sub></em> &lt; <em>b<sub>j</sub></em>, or</li>
<li class="litop"><em>p</em> &lt; <em>q</em> and <em>a<sub>i</sub></em> = <em>b<sub>i</sub></em> for all <em>i</em> = 0, 1, …, <em>p</em>.</li></ol>
<p class="noindent">For example, if <em>a</em> and <em>b</em> are bit strings, then 10100 &lt; 10110 by rule 1 (letting <em>j</em> = 3) and 10100 &lt; 101000 by rule 2. This ordering is similar to that used in English-language dictionaries.</p>
<p>The <strong><em><span class="blue1">radix tree</span></em></strong> data structure shown in <a href="chapter012.xhtml#Fig_12-5">Figure 12.5</a> (also known as a <strong><em><span class="blue1">trie</span></em></strong>) stores the bit strings 1011, 10, 011, 100, and 0. When searching for a key <em>a</em> = <em>a</em><sub>0</sub><em>a</em><sub>1</sub> … <em>a<sub>p</sub></em>, go left at a node of depth <em>i</em> if <em>a<sub>i</sub></em> = 0 and right if <em>a<sub>i</sub></em> = 1. Let <em>S</em> be a set of distinct bit strings whose lengths sum to <em>n</em>. Show how to use a radix tree to sort <em>S</em> lexicographically in Θ(<em>n</em>) time. For the example in <a href="chapter012.xhtml#Fig_12-5">Figure 12.5</a>, the output of the sort should be the sequence 0, 011, 10, 100, 1011.</p>
<a id="p328"/>
<div class="divimage">
<p class="fig-imga" id="Fig_12-5"><img alt="art" src="images/Art_P420.jpg"/></p>
<p class="caption"><strong>Figure 12.5</strong> A radix tree storing the bit strings 1011, 10, 011, 100, and 0. To determine each node’s key, traverse the simple path from the root to that node. There is no need, therefore, to store the keys in the nodes. The keys appear here for illustrative purposes only. Keys corresponding to blue nodes are not in the tree. Such nodes are present only to establish a path to other nodes.</p>
</div>
</section>
<section title="12-3 Average node depth in a randomly built binary search tree">
<p class="level2"><strong><em>12-3     Average node depth in a randomly built binary search tree</em></strong></p>
<p class="noindent">A <strong><em><span class="blue1">randomly built binary search tree</span></em></strong> on <em>n</em> keys is a binary search tree created by starting with an empty tree and inserting the keys in random order, where each of the <em>n</em>! permutations of the keys is equally likely. In this problem, you will prove that the average depth of a node in a randomly built binary search tree with <em>n</em> nodes is <em>O</em>(lg <em>n</em>). The technique reveals a surprising similarity between the building of a binary search tree and the execution of R<small>ANDOMIZED</small>-Q<small>UICKSORT</small> from <a href="chapter007.xhtml#Sec_7.3">Section 7.3</a>.</p>
<p>Denote the depth of any node <em>x</em> in tree <em>T</em> by <em>d</em>(<em>x</em>, <em>T</em>). Then the <strong><em><span class="blue1">total path length</span></em></strong> <em>P</em>(<em>T</em>) of a tree <em>T</em> is the sum, over all nodes <em>x</em> in <em>T</em>, of <em>d</em>(<em>x</em>, <em>T</em>).</p>
<p class="nl"><strong><em>a.</em></strong> Argue that the average depth of a node in <em>T</em> is</p>
<p class="eqnl"><img alt="art" src="images/Art_P421.jpg"/></p>
<p class="noindent">Thus, you need to show that the expected value of <em>P</em>(<em>T</em>) is <em>O</em>(<em>n</em> lg <em>n</em>).</p>
<p class="nl"><strong><em>b.</em></strong> Let <em>T<sub>L</sub></em> and <em>T<sub>R</sub></em> denote the left and right subtrees of tree <em>T</em>, respectively. Argue that if <em>T</em> has <em>n</em> nodes, then</p>
<p class="eqnl"><em>P</em>(<em>T</em>) = <em>P</em>(<em>T<sub>L</sub></em>) + <em>P</em>(<em>T<sub>R</sub></em>) + <em>n</em> − 1.</p>
<p class="nl"><strong><em>c.</em></strong> Let <em>P</em>(<em>n</em>) denote the average total path length of a randomly built binary search tree with <em>n</em> nodes. Show that</p>
<a id="p329"/>
<p class="eqnl"><img alt="art" src="images/Art_P422.jpg"/></p>
<p class="nl"><strong><em>d.</em></strong> Show how to rewrite <em>P</em>(<em>n</em>) as</p>
<p class="eqnl"><img alt="art" src="images/Art_P423.jpg"/></p>
<p class="nl"><strong><em>e.</em></strong> Recalling the alternative analysis of the randomized version of quicksort given in Problem 7-3, conclude that <em>P</em>(<em>n</em>) = <em>O</em>(<em>n</em> lg <em>n</em>).</p>
<p class="noindent1-top">Each recursive invocation of randomized quicksort chooses a random pivot element to partition the set of elements being sorted. Each node of a binary search tree partitions the set of elements that fall into the subtree rooted at that node.</p>
<p class="nl"><strong><em>f.</em></strong> Describe an implementation of quicksort in which the comparisons to sort a set of elements are exactly the same as the comparisons to insert the elements into a binary search tree. (The order in which comparisons are made may differ, but the same comparisons must occur.)</p>
</section>
<section title="12-4 Number of different binary trees">
<p class="level2"><strong><em>12-4     Number of different binary trees</em></strong></p>
<p class="noindent">Let <em>b<sub>n</sub></em> denote the number of different binary trees with <em>n</em> nodes. In this problem, you will find a formula for <em>b<sub>n</sub></em>, as well as an asymptotic estimate.</p>
<p class="nl"><strong><em>a.</em></strong> Show that <em>b</em><sub>0</sub> = 1 and that, for <em>n</em> ≥ 1,</p>
<p class="eqnl"><img alt="art" src="images/Art_P424.jpg"/></p>
<p class="nl"><strong><em>b.</em></strong> Referring to Problem 4-5 on page 121 for the definition of a generating function, let <em>B</em>(<em>x</em>) be the generating function</p>
<p class="eqnl"><img alt="art" src="images/Art_P425.jpg"/></p>
<p class="nl-para">Show that <em>B</em>(<em>x</em>) = <em>xB</em>(<em>x</em>)<sup>2</sup> + 1, and hence one way to express <em>B</em>(<em>x</em>) in closed form is</p>
<p class="eqnl"><img alt="art" src="images/Art_P426.jpg"/></p>
<p class="noindent">The <strong><em><span class="blue1">Taylor expansion</span></em></strong> of <em>f</em>(<em>x</em>) around the point <em>x</em> = <em>a</em> is given by</p>
<a id="p330"/>
<p class="eql"><img alt="art" src="images/Art_P427.jpg"/></p>
<p class="noindent">where <em>f</em><sup>(<em>k</em>)</sup>(<em>x</em>) is the <em>k</em>th derivative of <em>f</em> evaluated at <em>x</em>.</p>
<p class="nl"><strong><em>c.</em></strong> Show that</p>
<p class="eqnl"><img alt="art" src="images/Art_P428.jpg"/></p>
<p class="nl-para">(the <em>n</em>th <strong><em><span class="blue1">Catalan number</span></em></strong>) by using the Taylor expansion of <img alt="art" src="images/Art_P429.jpg"/> around <em>x</em> = 0. (If you wish, instead of using the Taylor expansion, you may use the generalization of the binomial theorem, equation (C.4) on page 1181, to noninteger exponents <em>n</em>, where for any real number <em>n</em> and for any integer <em>k</em>, you can interpret <img alt="art" src="images/Art_P430.jpg"/> to be <em>n</em>(<em>n</em> − 1) … (<em>n</em> − <em>k</em> + 1)/<em>k</em>! if <em>k</em> ≥ 0, and 0 otherwise.)</p>
<p class="nl"><strong><em>d.</em></strong> Show that</p>
<p class="eqnl"><img alt="art" src="images/Art_P431.jpg"/></p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-73"><strong>Chapter notes</strong></p>
<p class="noindent">Knuth [<a epub:type="noteref" href="bibliography001.xhtml#endnote_261">261</a>] contains a good discussion of simple binary search trees as well as many variations. Binary search trees seem to have been independently discovered by a number of people in the late 1950s. Radix trees are often called “tries,” which comes from the middle letters in the word <em>retrieval</em>. Knuth [<a epub:type="noteref" href="bibliography001.xhtml#endnote_261">261</a>] also discusses them.</p>
<p>Many texts, including the first two editions of this book, describe a somewhat simpler method of deleting a node from a binary search tree when both of its children are present. Instead of replacing node <em>z</em> by its successor <em>y</em>, delete node <em>y</em> but copy its key and satellite data into node <em>z</em>. The downside of this approach is that the node actually deleted might not be the node passed to the delete procedure. If other components of a program maintain pointers to nodes in the tree, they could mistakenly end up with “stale” pointers to nodes that have been deleted. Although the deletion method presented in this edition of this book is a bit more complicated, it guarantees that a call to delete node <em>z</em> deletes node <em>z</em> and only node <em>z</em>.</p>
<p><a href="chapter014.xhtml#Sec_14.5">Section 14.5</a> will show how to construct an optimal binary search tree when you know the search frequencies before constructing the tree. That is, given the frequencies of searching for each key and the frequencies of searching for values that fall between keys in the tree, a set of searches in the constructed binary search tree examines the minimum number of nodes.</p>
</section>
</section>
</div>
</body>
</html>