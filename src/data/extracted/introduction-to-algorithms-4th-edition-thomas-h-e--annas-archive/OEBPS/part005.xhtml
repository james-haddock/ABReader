<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p476"/>
<p class="line-p"/>
<section epub:type="bodymatter part" title="Part V Advanced Data Structures">
<p class="part-title"><a href="toc.xhtml#part-5"><strong><em><span class="blue1">Part V    Advanced Data Structures</span></em></strong></a></p>
<a id="p477"/>
<p class="cp"/>
<p class="noindent1-top1"> </p>
<p class="noindent1-top1"> </p>
<section title="Introduction">
<p class="level1a" id="h1-100"><a href="toc.xhtml#Rh1-100"><strong>Introduction</strong></a></p>
<p class="noindent">This part returns to studying data structures that support operations on dynamic sets, but at a more advanced level than <a href="part003.xhtml">Part III</a>. One of the chapters, for example, makes extensive use of the amortized analysis techniques from <a href="chapter016.xhtml">Chapter 16</a>.</p>
<p><a href="chapter017.xhtml">Chapter 17</a> shows how to augment red-black trees—adding additional information in each node—to support dynamic-set operations in addition to those covered in <a href="chapter012.xhtml">Chapters 12</a> and <a href="chapter013.xhtml">13</a>. The first example augments red-black trees to dynamically maintain order statistics for a set of keys. Another example augments them in a different way to maintain intervals of real numbers. <a href="chapter017.xhtml">Chapter 17</a> includes a theorem giving sufficient conditions for when a red-black tree can be augmented while maintaining the <em>O</em>(lg <em>n</em>) running times for insertion and deletion.</p>
<p><a href="chapter018.xhtml">Chapter 18</a> presents B-trees, which are balanced search trees specifically designed to be stored on disks. Since disks operate much more slowly than random-access memory, B-tree performance depends not only on how much computing time the dynamic-set operations consume but also on how many disk accesses they perform. For each B-tree operation, the number of disk accesses increases with the height of the B-tree, but B-tree operations keep the height low.</p>
<p><a href="chapter019.xhtml">Chapter 19</a> examines data structures for disjoint sets. Starting with a universe of <em>n</em> elements, each initially in its own singleton set, the operation U<small>NION</small> unites two sets. At all times, the <em>n</em> elements are partitioned into disjoint sets, even as calls to the U<small>NION</small> operation change the members of a set dynamically. The query F<small>IND</small>-S<small>ET</small> identifies the unique set that contains a given element at the moment. Representing each set as a simple rooted tree yields surprisingly fast operations: a sequence of <em>m</em> operations runs in <em>O</em>(<em>mα</em>(<em>n</em>)) time, where <em>α</em>(<em>n</em>) is an incredibly slowly growing function—<em>α</em>(<em>n</em>) is at most 4 in any conceivable application. The amortized analysis that proves this time bound is as complex as the data structure is simple.</p>
<a id="p478"/>
<p>The topics covered in this part are by no means the only examples of “advanced” data structures. Other advanced data structures include the following:</p>
<ul class="ulnoindent" epub:type="list">
<li><span class="blue"><strong><em>Fibonacci heaps</em></strong></span> [<a epub:type="noteref" href="bibliography001.xhtml#endnote_156">156</a>] implement mergeable heaps (see Problem 10-2 on page 268) with the operations I<small>NSERT</small>, M<small>INIMUM</small>, and U<small>NION</small> taking only <em>O</em>(1) actual and amortized time, and the operations E<small>XTRACT</small>-M<small>IN</small> and D<small>ELETE</small> taking <em>O</em>(lg <em>n</em>) amortized time. The most significant advantage of these data structures, however, is that D<small>ECREASE</small>-K<small>EY</small> takes only <em>O</em>(1) amortized time. <span class="blue"><strong><em>Strict Fibonacci heaps</em></strong></span> [<a epub:type="noteref" href="bibliography001.xhtml#endnote_73">73</a>], developed later, made all of these time bounds actual. Because the D<small>ECREASE</small>-K<small>EY</small> operation takes constant amortized time, (strict) Fibonacci heaps constitute key components of some of the asymptotically fastest algorithms to date for graph problems.</li>
<li class="litop"><span class="blue"><strong><em>Dynamic trees</em></strong></span> [<a epub:type="noteref" href="bibliography001.xhtml#endnote_415">415</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_429">429</a>] maintain a forest of disjoint rooted trees. Each edge in each tree has a real-valued cost. Dynamic trees support queries to find parents, roots, edge costs, and the minimum edge cost on a simple path from a node up to a root. Trees may be manipulated by cutting edges, updating all edge costs on a simple path from a node up to a root, linking a root into another tree, and making a node the root of the tree it appears in. One implementation of dynamic trees gives an <em>O</em>(lg <em>n</em>) amortized time bound for each operation, while a more complicated implementation yields <em>O</em>(lg <em>n</em>) worst-case time bounds. Dynamic trees are used in some of the asymptotically fastest network-flow algorithms.</li>
<li class="litop"><span class="blue"><strong><em>Splay trees</em></strong></span> [<a epub:type="noteref" href="bibliography001.xhtml#endnote_418">418</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_429">429</a>] are a form of binary search tree on which the standard search-tree operations run in <em>O</em>(lg <em>n</em>) amortized time. One application of splay trees simplifies dynamic trees.</li>
<li class="litop"><span class="blue"><strong><em>Persistent</em></strong></span> data structures allow queries, and sometimes updates as well, on past versions of a data structure. For example, linked data structures can be made persistent with only a small time and space cost [<a epub:type="noteref" href="bibliography001.xhtml#endnote_126">126</a>]. Problem 13-1 gives a simple example of a persistent dynamic set.</li>
<li class="litop">Several data structures allow a faster implementation of dictionary operations (I<small>NSERT</small>, D<small>ELETE</small>, and S<small>EARCH</small>) for a restricted universe of keys. By taking advantage of these restrictions, they are able to achieve better worst-case asymptotic running times than comparison-based data structures. If the keys are unique integers drawn from the set {0, 1, 2, … , <em>u</em> − 1}, where <em>u</em> is an exact power of 2, then a recursive data structure known as a <span class="blue"><strong><em>van Emde Boas tree</em></strong></span> [<a epub:type="noteref" href="bibliography001.xhtml#endnote_440">440</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_441">441</a>] supports each of the operations S<small>EARCH</small>, I<small>NSERT</small>, D<small>ELETE</small>, M<small>INIMUM</small>, M<small>AXIMUM</small>, S<small>UCCESSOR</small>, and P<small>REDECESSOR</small> in <em>O</em>(lg lg <em>u</em>) time. <span class="blue"><strong><em>Fusion trees</em></strong></span> [<a epub:type="noteref" href="bibliography001.xhtml#endnote_157">157</a>] were the first data structure to allow faster dictionary operations when the universe is restricted to integers, implementing these operations in <em>O</em>(lg <em>n</em>/lg lg <em>n</em>) time. Several subsequent data structures, including <span class="blue"><strong><em>exponential search trees</em></strong></span> [<a epub:type="noteref" href="bibliography001.xhtml#endnote_17">17</a>], have also given improved bounds on some or all of <a id="p479"/>the dictionary operations and are mentioned in the chapter notes throughout this book.</li>
<li class="litop"><span class="blue"><strong><em>Dynamic graph data structures</em></strong></span> support various queries while allowing the structure of a graph to change through operations that insert or delete vertices or edges. Examples of the queries that they support include vertex connectivity [<a epub:type="noteref" href="bibliography001.xhtml#endnote_214">214</a>], edge connectivity, minimum spanning trees [<a epub:type="noteref" href="bibliography001.xhtml#endnote_213">213</a>], biconnectivity, and transitive closure [<a epub:type="noteref" href="bibliography001.xhtml#endnote_212">212</a>].</li></ul>
<p class="noindent">Chapter notes throughout this book mention additional data structures.</p>
</section>
</section>
</div>
</body>
</html>