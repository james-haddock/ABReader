<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p360"/>
<p class="line-p"/>
<section epub:type="bodymatter part" title="Part IV Advanced Design and Analysis Techniques">
<p class="part-title"><a href="toc.xhtml#part-4"><strong><em><span class="blue1">Part IV    Advanced Design and Analysis Techniques</span></em></strong></a></p>
<a id="p361"/>
<p class="cp"/>
<p class="noindent1-top1"> </p>
<p class="noindent1-top1"> </p>
<section title="Introduction">
<p class="level1a" id="h1-80"><a href="toc.xhtml#Rh1-80"><strong>Introduction</strong></a></p>
<p class="noindent">This part covers three important techniques used in designing and analyzing efficient algorithms: dynamic programming (<a href="chapter014.xhtml">Chapter 14</a>), greedy algorithms (<a href="chapter015.xhtml">Chapter 15</a>), and amortized analysis (<a href="chapter016.xhtml">Chapter 16</a>). Earlier parts have presented other widely applicable techniques, such as divide-and-conquer, randomization, and how to solve recurrences. The techniques in this part are somewhat more sophisticated, but you will be able to use them solve many computational problems. The themes introduced in this part will recur later in this book.</p>
<p>Dynamic programming typically applies to optimization problems in which you make a set of choices in order to arrive at an optimal solution, each choice generates subproblems of the same form as the original problem, and the same subproblems arise repeatedly. The key strategy is to store the solution to each such subproblem rather than recompute it. <a href="chapter014.xhtml">Chapter 14</a> shows how this simple idea can sometimes transform exponential-time algorithms into polynomial-time algorithms.</p>
<p>Like dynamic-programming algorithms, greedy algorithms typically apply to optimization problems in which you make a set of choices in order to arrive at an optimal solution. The idea of a greedy algorithm is to make each choice in a locally optimal manner, resulting in a faster algorithm than you get with dynamic programming. <a href="chapter015.xhtml">Chapter 15</a> will help you determine when the greedy approach works.</p>
<p>The technique of amortized analysis applies to certain algorithms that perform a sequence of similar operations. Instead of bounding the cost of the sequence of operations by bounding the actual cost of each operation separately, an amortized analysis provides a worst-case bound on the actual cost of the entire sequence. One advantage of this approach is that although some operations might be expensive, many others might be cheap. You can use amortized analysis when designing algorithms, since the design of an algorithm and the analysis of its running time are often closely intertwined. <a href="chapter016.xhtml">Chapter 16</a> introduces three ways to perform an amortized analysis of an algorithm.</p>
</section>
</section>
</div>
</body>
</html>