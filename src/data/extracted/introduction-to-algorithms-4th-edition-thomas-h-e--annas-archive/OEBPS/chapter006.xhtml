<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p161"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="6 Heapsort">
<p class="chapter-title"><a href="toc.xhtml#chap-6"><strong><span class="blue1">6          Heapsort</span></strong></a></p>
<p class="noindent">This chapter introduces another sorting algorithm: heapsort. Like merge sort, but unlike insertion sort, heapsort’s running time is <em>O</em>(<em>n</em> lg <em>n</em>). Like insertion sort, but unlike merge sort, heapsort sorts in place: only a constant number of array elements are stored outside the input array at any time. Thus, heapsort combines the better attributes of the two sorting algorithms we have already discussed.</p>
<p>Heapsort also introduces another algorithm design technique: using a data structure, in this case one we call a “heap,” to manage information. Not only is the heap data structure useful for heapsort, but it also makes an efficient priority queue. The heap data structure will reappear in algorithms in later chapters.</p>
<p>The term “heap” was originally coined in the context of heapsort, but it has since come to refer to “garbage-collected storage,” such as the programming languages Java and Python provide. Please don’t be confused. The heap data structure is <em>not</em> garbage-collected storage. This book is consistent in using the term “heap” to refer to the data structure, not the storage class.</p>
<p class="line1"/>
<section title="6.1 Heaps">
<a id="Sec_6.1"/>
<p class="level1" id="h1-32"><a href="toc.xhtml#Rh1-32"><strong>6.1      Heaps</strong></a></p>
<p class="noindent">The <strong><em><span class="blue1">(binary) heap</span></em></strong> data structure is an array object that we can view as a nearly complete binary tree (see <a href="appendix002.xhtml#Sec_B.5.3">Section B.5.3</a>), as shown in <a href="chapter006.xhtml#Fig_6-1">Figure 6.1</a>. Each node of the tree corresponds to an element of the array. The tree is completely filled on all levels except possibly the lowest, which is filled from the left up to a point. An array <em>A</em>[1 : <em>n</em>] that represents a heap is an object with an attribute <em>A.heap-size</em>, which represents how many elements in the heap are stored within array <em>A</em>. That is, although <em>A</em>[1 : <em>n</em>] may contain numbers, only the elements in <em>A</em>[1 : <em>A.heap-size</em>], where 0 ≤ <em>A.heap-size</em> ≤ <em>n</em>, are valid elements of the heap. If <em>A.heap-size</em> = 0, then the heap is empty. The root of the tree is <em>A</em>[1], and given the index <em>i</em> of a node, <a id="p162"/>there’s a simple way to compute the indices of its parent, left child, and right child with the one-line procedures P<small>ARENT</small>, L<small>EFT</small>, and R<small>IGHT</small>.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_6-1"><img alt="art" src="images/Art_P298.jpg"/></p>
<p class="caption"><strong>Figure 6.1</strong> A max-heap viewed as <strong>(a)</strong> a binary tree and <strong>(b)</strong> an array. The number within the circle at each node in the tree is the value stored at that node. The number above a node is the corresponding index in the array. Above and below the array are lines showing parent-child relationships, with parents always to the left of their children. The tree has height 3, and the node at index 4 (with value 8) has height 1.</p>
</div>
<div class="pull-quote1">
<p class="box-heading">P<small>ARENT</small>(<em>i</em>)</p>
<table class="table1n">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <span class="font1">⌊</span><em>i</em>/2<span class="font1">⌋</span></p></td>
</tr>
</table>
<p class="box-headinga">L<small>EFT</small>(<em>i</em>)</p>
<table class="table1n">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> 2<em>i</em></p></td>
</tr>
</table>
<p class="box-headinga">R<small>IGHT</small>(<em>i</em>)</p>
<table class="table1n">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> 2<em>i</em> + 1</p></td>
</tr>
</table>
</div>
<p>On most computers, the L<small>EFT</small> procedure can compute 2<em>i</em> in one instruction by simply shifting the binary representation of <em>i</em> left by one bit position. Similarly, the R<small>IGHT</small> procedure can quickly compute 2<em>i</em> + 1 by shifting the binary representation of <em>i</em> left by one bit position and then adding 1. The P<small>ARENT</small> procedure can compute <span class="font1">⌊</span><em>i</em>/2<span class="font1">⌋</span> by shifting <em>i</em> right one bit position. Good implementations of heapsort often implement these procedures as macros or inline procedures.</p>
<p>There are two kinds of binary heaps: max-heaps and min-heaps. In both kinds, the values in the nodes satisfy a <strong><em><span class="blue1">heap property</span></em></strong>, the specifics of which depend on the kind of heap. In a <strong><em><span class="blue1">max-heap</span></em></strong>, the <strong><em><span class="blue1">max-heap property</span></em></strong> is that for every node <em>i</em> other than the root,</p>
<p class="eql"><em>A</em>[P<small>ARENT</small>(<em>i</em>)] ≥ <em>A</em>[<em>i</em>],</p>
<a id="p163"/>
<p class="noindent">that is, the value of a node is at most the value of its parent. Thus, the largest element in a max-heap is stored at the root, and the subtree rooted at a node contains values no larger than that contained at the node itself. A <strong><em><span class="blue1">min-heap</span></em></strong> is organized in the opposite way: the <strong><em><span class="blue1">min-heap property</span></em></strong> is that for every node <em>i</em> other than the root,</p>
<p class="eql"><em>A</em>[P<small>ARENT</small>(<em>i</em>)] ≤ <em>A</em>[<em>i</em>].</p>
<p class="noindent">The smallest element in a min-heap is at the root.</p>
<p>The heapsort algorithm uses max-heaps. Min-heaps commonly implement priority queues, which we discuss in <a href="chapter006.xhtml#Sec_6.5">Section 6.5</a>. We’ll be precise in specifying whether we need a max-heap or a min-heap for any particular application, and when properties apply to either max-heaps or min-heaps, we just use the term “heap.”</p>
<p>Viewing a heap as a tree, we define the <strong><em><span class="blue1">height</span></em></strong> of a node in a heap to be the number of edges on the longest simple downward path from the node to a leaf, and we define the height of the heap to be the height of its root. Since a heap of <em>n</em> elements is based on a complete binary tree, its height is Θ(lg <em>n</em>) (see Exercise 6.1-2). As we’ll see, the basic operations on heaps run in time at most proportional to the height of the tree and thus take <em>O</em>(lg <em>n</em>) time. The remainder of this chapter presents some basic procedures and shows how they are used in a sorting algorithm and a priority-queue data structure.</p>
<ul class="ulnoindent" epub:type="list">
<li>The M<small>AX</small>-H<small>EAPIFY</small> procedure, which runs in <em>O</em>(lg <em>n</em>) time, is the key to maintaining the max-heap property.</li>
<li class="litop">The B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> procedure, which runs in linear time, produces a max-heap from an unordered input array.</li>
<li class="litop">The H<small>EAPSORT</small> procedure, which runs in <em>O</em>(<em>n</em> lg <em>n</em>) time, sorts an array in place.</li>
<li class="litop">The procedures M<small>AX</small>-H<small>EAP</small>-I<small>NSERT</small>, M<small>AX</small>-H<small>EAP</small>-E<small>XTRACT</small>-M<small>AX</small>, M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small>, and M<small>AX</small>-H<small>EAP</small>-M<small>AXIMUM</small> allow the heap data structure to implement a priority queue. They run in <em>O</em>(lg <em>n</em>) time plus the time for mapping between objects being inserted into the priority queue and indices in the heap.</li></ul>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>6.1-1</em></strong></p>
<p class="noindent">What are the minimum and maximum numbers of elements in a heap of height <em>h</em>?</p>
<p class="level3"><strong><em>6.1-2</em></strong></p>
<p class="noindent">Show that an <em>n</em>-element heap has height <span class="font1">⌊</span>lg <em>n</em><span class="font1">⌋</span>.</p>
<a id="p164"/>
<p class="level3"><strong><em>6.1-3</em></strong></p>
<p class="noindent">Show that in any subtree of a max-heap, the root of the subtree contains the largest value occurring anywhere in that subtree.</p>
<p class="level3"><strong><em>6.1-4</em></strong></p>
<p class="noindent">Where in a max-heap might the smallest element reside, assuming that all elements are distinct?</p>
<p class="level3"><strong><em>6.1-5</em></strong></p>
<p class="noindent">At which levels in a max-heap might the <em>k</em>th largest element reside, for 2 ≤ <em>k</em> ≤ <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span>, assuming that all elements are distinct?</p>
<p class="level3"><strong><em>6.1-6</em></strong></p>
<p class="noindent">Is an array that is in sorted order a min-heap?</p>
<p class="level3"><strong><em>6.1-7</em></strong></p>
<p class="noindent">Is the array with values <span class="font1">〈</span>33, 19, 20, 15, 13, 10, 2, 13, 16, 12<span class="font1">〉</span> a max-heap?</p>
<p class="level3"><strong><em>6.1-8</em></strong></p>
<p class="noindent">Show that, with the array representation for storing an <em>n</em>-element heap, the leaves are the nodes indexed by <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> + 1, <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> + 2, … , <em>n</em>.</p>
</section>
<p class="line1"/>
<section title="6.2 Maintaining the heap property">
<a id="Sec_6.2"/>
<p class="level1" id="h1-33"><a href="toc.xhtml#Rh1-33"><strong>6.2      Maintaining the heap property</strong></a></p>
<p class="noindent">The procedure M<small>AX</small>-H<small>EAPIFY</small> on the facing page maintains the max-heap property. Its inputs are an array <em>A</em> with the <em>heap-size</em> attribute and an index <em>i</em> into the array. When it is called, M<small>AX</small>-H<small>EAPIFY</small> assumes that the binary trees rooted at L<small>EFT</small>(<em>i</em>) and R<small>IGHT</small>(<em>i</em>) are max-heaps, but that <em>A</em>[<em>i</em>] might be smaller than its children, thus violating the max-heap property. M<small>AX</small>-H<small>EAPIFY</small> lets the value at <em>A</em>[<em>i</em>] “float down” in the max-heap so that the subtree rooted at index <em>i</em> obeys the max-heap property.</p>
<p><a href="chapter006.xhtml#Fig_6-2">Figure 6.2</a> illustrates the action of M<small>AX</small>-H<small>EAPIFY</small>. Each step determines the largest of the elements <em>A</em>[<em>i</em>], <em>A</em>[L<small>EFT</small>(<em>i</em>)], and <em>A</em>[R<small>IGHT</small>(<em>i</em>)] and stores the index of the largest element in <em>largest</em>. If <em>A</em>[<em>i</em>] is largest, then the subtree rooted at node <em>i</em> is already a max-heap and nothing else needs to be done. Otherwise, one of the two children contains the largest element. Positions <em>i</em> and <em>largest</em> swap their contents, which causes node <em>i</em> and its children to satisfy the max-heap property. The node indexed by <em>largest</em>, however, just had its value decreased, and thus the subtree rooted at <em>largest</em> might violate the max-heap property. Consequently, M<small>AX</small>-H<small>EAPIFY</small> calls itself recursively on that subtree.</p>
<a id="p165"/>
<div class="divimage">
<p class="fig-imga" id="Fig_6-2"><img alt="art" class="width100" src="images/Art_P299.jpg"/></p>
<p class="caption"><strong>Figure 6.2</strong> The action of M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, 2), where <em>A.heap-size</em> = 10. The node that potentially violates the max-heap property is shown in blue. <strong>(a)</strong> The initial configuration, with <em>A</em>[2] at node <em>i</em> = 2 violating the max-heap property since it is not larger than both children. The max-heap property is restored for node 2 in <strong>(b)</strong> by exchanging <em>A</em>[2] with <em>A</em>[4], which destroys the max-heap property for node 4. The recursive call M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, 4) now has <em>i</em> = 4. After <em>A</em>[4] and <em>A</em>[9] are swapped, as shown in <strong>(c)</strong>, node 4 is fixed up, and the recursive call M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, 9) yields no further change to the data structure.</p>
</div>
<div class="pull-quote1">
<p class="box-heading">M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, <em>i</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">  1</span></p></td>
<td class="td1"><p class="noindent"><em>l</em> = L<small>EFT</small>(<em>i</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  2</span></p></td>
<td class="td1"><p class="noindent"><em>r</em> = R<small>IGHT</small>(<em>i</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  3</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>l</em> ≤ <em>A.heap-size</em> and <em>A</em>[<em>l</em>] &gt; <em>A</em>[<em>i</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  4</span></p></td>
<td class="td1"><p class="p2"><em>largest</em> = <em>l</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  5</span></p></td>
<td class="td1"><p class="noindent"><strong>else</strong> <em>largest</em> = <em>i</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  6</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>r</em> ≤ <em>A.heap-size</em> and <em>A</em>[<em>r</em>] &gt; <em>A</em>[<em>largest</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  7</span></p></td>
<td class="td1"><p class="p2"><em>largest</em> = <em>r</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  8</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>largest</em> ≠ <em>i</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">  9</span></p></td>
<td class="td1"><p class="p2">exchange <em>A</em>[<em>i</em>] with <em>A</em>[<em>largest</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">10</span></p></td>
<td class="td1"><p class="p2">M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, <em>largest</em>)</p></td>
</tr>
</table>
</div>
<a id="p166"/>
<p>To analyze M<small>AX</small>-H<small>EAPIFY</small>, let <em>T</em> (<em>n</em>) be the worst-case running time that the procedure takes on a subtree of size at most <em>n</em>. For a tree rooted at a given node <em>i</em>, the running time is the Θ(1) time to fix up the relationships among the elements <em>A</em>[<em>i</em>], <em>A</em>[L<small>EFT</small>(<em>i</em>)], and <em>A</em>[R<small>IGHT</small>(<em>i</em>)], plus the time to run M<small>AX</small>-H<small>EAPIFY</small> on a subtree rooted at one of the children of node <em>i</em> (assuming that the recursive call occurs). The children’s subtrees each have size at most 2<em>n</em>/3 (see Exercise 6.2-2), and therefore we can describe the running time of M<small>AX</small>-H<small>EAPIFY</small> by the recurrence</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P300.jpg"/></p>
<p class="noindent">The solution to this recurrence, by case 2 of the master theorem (Theorem 4.1 on page 102), is <em>T</em> (<em>n</em>) = <em>O</em>(lg <em>n</em>). Alternatively, we can characterize the running time of M<small>AX</small>-H<small>EAPIFY</small> on a node of height <em>h</em> as <em>O</em>(<em>h</em>).</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>6.2-1</em></strong></p>
<p class="noindent">Using <a href="chapter006.xhtml#Fig_6-2">Figure 6.2</a> as a model, illustrate the operation of M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, 3) on the array <em>A</em> = <span class="font1">〈</span>27, 17, 3, 16, 13, 10, 1, 5, 7, 12, 4, 8, 9, 0<span class="font1">〉</span>.</p>
<p class="level3"><strong><em>6.2-2</em></strong></p>
<p class="noindent">Show that each child of the root of an <em>n</em>-node heap is the root of a subtree containing at most 2<em>n</em>/3 nodes. What is the smallest constant <em>α</em> such that each subtree has at most <em>α n</em> nodes? How does that affect the recurrence (6.1) and its solution?</p>
<p class="level3"><strong><em>6.2-3</em></strong></p>
<p class="noindent">Starting with the procedure M<small>AX</small>-H<small>EAPIFY</small>, write pseudocode for the procedure M<small>IN</small>-H<small>EAPIFY</small>(<em>A</em>, <em>i</em>), which performs the corresponding manipulation on a min-heap. How does the running time of M<small>IN</small>-H<small>EAPIFY</small> compare with that of M<small>AX</small>-H<small>EAPIFY</small>?</p>
<p class="level3"><strong><em>6.2-4</em></strong></p>
<p class="noindent">What is the effect of calling M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, <em>i</em>) when the element <em>A</em>[<em>i</em>] is larger than its children?</p>
<p class="level3"><strong><em>6.2-5</em></strong></p>
<p class="noindent">What is the effect of calling M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, <em>i</em>) for <em>i</em> &gt; <em>A.heap-size</em>/2?</p>
<p class="level3"><strong><em>6.2-6</em></strong></p>
<p class="noindent">The code for M<small>AX</small>-H<small>EAPIFY</small> is quite efficient in terms of constant factors, except possibly for the recursive call in line 10, for which some compilers might produce inefficient code. Write an efficient M<small>AX</small>-H<small>EAPIFY</small> that uses an iterative control construct (a loop) instead of recursion.</p>
<a id="p167"/>
<p class="level3"><strong><em>6.2-7</em></strong></p>
<p class="noindent">Show that the worst-case running time of M<small>AX</small>-H<small>EAPIFY</small> on a heap of size <em>n</em> is Ω(lg <em>n</em>). (<em>Hint:</em> For a heap with <em>n</em> nodes, give node values that cause M<small>AX</small>-H<small>EAPIFY</small> to be called recursively at every node on a simple path from the root down to a leaf.)</p>
</section>
<p class="line1"/>
<section title="6.3 Building a heap">
<a id="Sec_6.3"/>
<p class="level1" id="h1-34"><a href="toc.xhtml#Rh1-34"><strong>6.3      Building a heap</strong></a></p>
<p class="noindent">The procedure B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> converts an array <em>A</em>[1 : <em>n</em>] into a max-heap by calling M<small>AX</small>-H<small>EAPIFY</small> in a bottom-up manner. Exercise 6.1-8 says that the elements in the subarray <em>A</em>[<span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> + 1 : <em>n</em>] are all leaves of the tree, and so each is a 1-element heap to begin with. B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> goes through the remaining nodes of the tree and runs M<small>AX</small>-H<small>EAPIFY</small> on each one. <a href="chapter006.xhtml#Fig_6-3">Figure 6.3</a> shows an example of the action of B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small>.</p>
<div class="pull-quote1">
<p class="box-heading">B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small>(<em>A</em>, <em>n</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>A.heap-size</em> = <em>n</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>i</em> = <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> <strong>downto</strong> 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2">M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, <em>i</em>)</p></td>
</tr>
</table>
</div>
<p>To show why B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> works correctly, we use the following loop invariant:</p>
<div class="pull-quote">
<p class="pq-noindent">At the start of each iteration of the <strong>for</strong> loop of lines 2–3, each node <em>i</em> + 1, <em>i</em> + 2, … , <em>n</em> is the root of a max-heap.</p>
</div>
<p class="noindent">We need to show that this invariant is true prior to the first loop iteration, that each iteration of the loop maintains the invariant, that the loop terminates, and that the invariant provides a useful property to show correctness when the loop terminates.</p>
<p class="para-hang1"><strong>Initialization:</strong> Prior to the first iteration of the loop, <em>i</em> = <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span>. Each node <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> + 1, <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> + 2, … , <em>n</em> is a leaf and is thus the root of a trivial max-heap.</p>
<p class="para-hang1"><strong>Maintenance:</strong> To see that each iteration maintains the loop invariant, observe that the children of node <em>i</em> are numbered higher than <em>i</em>. By the loop invariant, therefore, they are both roots of max-heaps. This is precisely the condition required for the call M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, <em>i</em>) to make node <em>i</em> a max-heap root. Moreover, the M<small>AX</small>-H<small>EAPIFY</small> call preserves the property that nodes <em>i</em> + 1, <em>i</em> + 2, … , <em>n</em> are all roots of max-heaps. Decrementing <em>i</em> in the <strong>for</strong> loop update reestablishes the loop invariant for the next iteration.</p>
<a id="p168"/>
<div class="divimage">
<p class="fig-imga" id="Fig_6-3"><img alt="art" class="width100" src="images/Art_P301.jpg"/></p>
<p class="caption"><strong>Figure 6.3</strong> The operation of B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small>, showing the data structure before the call to M<small>AX</small>-H<small>EAPIFY</small> in line 3 of B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small>. The node indexed by <em>i</em> in each iteration is shown in blue. <strong>(a)</strong> A 10-element input array <em>A</em> and the binary tree it represents. The loop index <em>i</em> refers to node 5 before the call M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, <em>i</em>). <strong>(b)</strong> The data structure that results. The loop index <em>i</em> for the next iteration refers to node 4. <strong>(c)–(e)</strong> Subsequent iterations of the <strong>for</strong> loop in B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small>. Observe that whenever M<small>AX</small>-H<small>EAPIFY</small> is called on a node, the two subtrees of that node are both max-heaps. <strong>(f)</strong> The max-heap after B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> finishes.</p>
</div>
<a id="p169"/>
<p class="para-hang1"><strong>Termination:</strong> The loop makes exactly <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> iterations, and so it terminates. At termination, <em>i</em> = 0. By the loop invariant, each node 1, 2, … , <em>n</em> is the root of a max-heap. In particular, node 1 is.</p>
<p class="space-break">We can compute a simple upper bound on the running time of B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> as follows. Each call to M<small>AX</small>-H<small>EAPIFY</small> costs <em>O</em>(lg <em>n</em>) time, and B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> makes <em>O</em>(<em>n</em>) such calls. Thus, the running time is <em>O</em>(<em>n</em> lg <em>n</em>). This upper bound, though correct, is not as tight as it can be.</p>
<p>We can derive a tighter asymptotic bound by observing that the time for M<small>AX</small>-H<small>EAPIFY</small> to run at a node varies with the height of the node in the tree, and that the heights of most nodes are small. Our tighter analysis relies on the properties that an <em>n</em>-element heap has height <span class="font1">⌊</span>lg <em>n</em><span class="font1">⌋</span> (see Exercise 6.1-2) and at most <span class="font1">⌈</span><em>n</em>/2<sup><em>h</em> + 1</sup><span class="font1">⌉</span> nodes of any height <em>h</em> (see Exercise 6.3-4).</p>
<p>The time required by M<small>AX</small>-H<small>EAPIFY</small> when called on a node of height <em>h</em> is <em>O</em>(<em>h</em>). Letting <em>c</em> be the constant implicit in the asymptotic notation, we can express the total cost of B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> as being bounded from above by <img alt="art" src="images/Art_P302.jpg"/>. As Exercise 6.3-2 shows, we have <span class="font1">⌈</span><em>n</em>/2<sup><em>h</em> + 1</sup><span class="font1">⌉</span> ≥ 1/2 for 0 ≤ <em>h</em> ≤ <span class="font1">⌊</span>lg <em>n</em><span class="font1">⌋</span>. Since <span class="font1">⌈</span><em>x</em><span class="font1">⌉</span> ≤ 2<em>x</em> for any <em>x</em> ≥ 1/2, we have <span class="font1">⌈</span><em>n</em>/2<sup><em>h</em> + 1</sup><span class="font1">⌉</span> ≤ <em>n</em>/2<em><sup>h</sup></em>. We thus obtain</p>
<p class="eql"><img alt="art" class="width100" src="images/Art_P303.jpg"/></p>
<p class="noindent">Hence, we can build a max-heap from an unordered array in linear time.</p>
<p>To build a min-heap, use the procedure B<small>UILD</small>-M<small>IN</small>-H<small>EAP</small>, which is the same as B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> but with the call to M<small>AX</small>-H<small>EAPIFY</small> in line 3 replaced by a call to M<small>IN</small>-H<small>EAPIFY</small> (see Exercise 6.2-3). B<small>UILD</small>-M<small>IN</small>-H<small>EAP</small> produces a min-heap from an unordered linear array in linear time.</p>
<a id="p170"/>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>6.3-1</em></strong></p>
<p class="noindent">Using <a href="chapter006.xhtml#Fig_6-3">Figure 6.3</a> as a model, illustrate the operation of B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> on the array <em>A</em> = <span class="font1">〈</span>5, 3, 17, 10, 84, 19, 6, 22, 9<span class="font1">〉</span>.</p>
<p class="level3"><strong><em>6.3-2</em></strong></p>
<p class="noindent">Show that <span class="font1">⌈</span><em>n</em>/2<sup><em>h</em> + 1</sup><span class="font1">⌉</span> ≥ 1/2 for 0 ≤ <em>h</em> ≤ <span class="font1">⌊</span>lg <em>n</em><span class="font1">⌋</span>.</p>
<p class="level3"><strong><em>6.3-3</em></strong></p>
<p class="noindent">Why does the loop index <em>i</em> in line 2 of B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> decrease from <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span> to 1 rather than increase from 1 to <span class="font1">⌊</span><em>n</em>/2<span class="font1">⌋</span>?</p>
<p class="level3"><strong><em>6.3-4</em></strong></p>
<p class="noindent">Show that there are at most <span class="font1">⌈</span><em>n</em>/2<sup><em>h</em> + 1</sup><span class="font1">⌉</span> nodes of height <em>h</em> in any <em>n</em>-element heap.</p>
</section>
<p class="line1"/>
<section title="6.4 The heapsort algorithm">
<a id="Sec_6.4"/>
<p class="level1" id="h1-35"><a href="toc.xhtml#Rh1-35"><strong>6.4      The heapsort algorithm</strong></a></p>
<p class="noindent">The heapsort algorithm, given by the procedure H<small>EAPSORT</small>, starts by calling the B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> procedure to build a max-heap on the input array <em>A</em>[1 : <em>n</em>]. Since the maximum element of the array is stored at the root <em>A</em>[1], H<small>EAPSORT</small> can place it into its correct final position by exchanging it with <em>A</em>[<em>n</em>]. If the procedure then discards node <em>n</em> from the heap—and it can do so by simply decrementing <em>A.heap-size</em>—the children of the root remain max-heaps, but the new root element might violate the max-heap property. To restore the max-heap property, the procedure just calls M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, 1), which leaves a max-heap in <em>A</em>[1 : <em>n</em> – 1]. The H<small>EAPSORT</small> procedure then repeats this process for the max-heap of size <em>n</em> – 1 down to a heap of size 2. (See Exercise 6.4-2 for a precise loop invariant.)</p>
<div class="pull-quote1">
<p class="box-heading">H<small>EAPSORT</small>(<em>A</em>, <em>n</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent">B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small>(<em>A</em>, <em>n</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>i</em> = <em>n</em> <strong>downto</strong> 2</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2">exchange <em>A</em>[1] with <em>A</em>[<em>i</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="p2"><em>A.heap-size</em> = <em>A.heap-size</em> – 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="p2">M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, 1)</p></td>
</tr>
</table>
</div>
<p><a href="chapter006.xhtml#Fig_6-4">Figure 6.4</a> shows an example of the operation of H<small>EAPSORT</small> after line 1 has built the initial max-heap. The figure shows the max-heap before the first iteration of the <strong>for</strong> loop of lines 2–5 and after each iteration.</p>
<a id="p171"/>
<div class="divimage">
<p class="fig-imga" id="Fig_6-4"><img alt="art" class="width100" src="images/Art_P304.jpg"/></p>
<p class="caption"><strong>Figure 6.4</strong> The operation of H<small>EAPSORT</small>. <strong>(a)</strong> The max-heap data structure just after B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> has built it in line 1. <strong>(b)–(j)</strong> The max-heap just after each call of M<small>AX</small>-H<small>EAPIFY</small> in line 5, showing the value of <em>i</em> at that time. Only blue nodes remain in the heap. Tan nodes contain the largest values in the array, in sorted order. <strong>(k)</strong> The resulting sorted array <em>A</em>.</p>
</div>
<a id="p172"/>
<p>The H<small>EAPSORT</small> procedure takes <em>O</em>(<em>n</em> lg <em>n</em>) time, since the call to B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> takes <em>O</em>(<em>n</em>) time and each of the <em>n</em> – 1 calls to M<small>AX</small>-H<small>EAPIFY</small> takes <em>O</em>(lg <em>n</em>) time.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>6.4-1</em></strong></p>
<p class="noindent">Using <a href="chapter006.xhtml#Fig_6-4">Figure 6.4</a> as a model, illustrate the operation of H<small>EAPSORT</small> on the array <em>A</em> = <span class="font1">〈</span>5, 13, 2, 25, 7, 17, 20, 8, 4<span class="font1">〉</span>.</p>
<p class="level3"><strong><em>6.4-2</em></strong></p>
<p class="noindent">Argue the correctness of H<small>EAPSORT</small> using the following loop invariant:</p>
<div class="pull-quote">
<p class="pq-noindent">At the start of each iteration of the <strong>for</strong> loop of lines 2–5, the subarray <em>A</em>[1 : <em>i</em>] is a max-heap containing the <em>i</em> smallest elements of <em>A</em>[1 : <em>n</em>], and the subarray <em>A</em>[<em>i</em> + 1 : <em>n</em>] contains the <em>n</em> – <em>i</em> largest elements of <em>A</em>[1 : <em>n</em>], sorted.</p>
</div>
<p class="level3"><strong><em>6.4-3</em></strong></p>
<p class="noindent">What is the running time of H<small>EAPSORT</small> on an array <em>A</em> of length <em>n</em> that is already sorted in increasing order? How about if the array is already sorted in decreasing order?</p>
<p class="level3"><strong><em>6.4-4</em></strong></p>
<p class="noindent">Show that the worst-case running time of H<small>EAPSORT</small> is Ω(<em>n</em> lg <em>n</em>).</p>
<p class="level3"><span class="font1">★</span> <strong><em>6.4-5</em></strong></p>
<p class="noindent">Show that when all the elements of <em>A</em> are distinct, the best-case running time of H<small>EAPSORT</small> is Ω(<em>n</em> lg <em>n</em>).</p>
</section>
<p class="line1"/>
<section title="6.5 Priority queues">
<a id="Sec_6.5"/>
<p class="level1" id="h1-36"><a href="toc.xhtml#Rh1-36"><strong>6.5      Priority queues</strong></a></p>
<p class="noindent">In <a href="chapter008.xhtml">Chapter 8</a>, we will see that any comparison-based sorting algorithm requires Ω(<em>n</em> lg <em>n</em>) comparisons and hence Ω(<em>n</em> lg <em>n</em>) time. Therefore, heapsort is asymptotically optimal among comparison-based sorting algorithms. Yet, a good implementation of quicksort, presented in <a href="chapter007.xhtml">Chapter 7</a>, usually beats it in practice. Nevertheless, the heap data structure itself has many uses. In this section, we present one of the most popular applications of a heap: as an efficient priority queue. As with heaps, priority queues come in two forms: max-priority queues and min-priority queues. We’ll focus here on how to implement max-priority queues, which are in turn based on max-heaps. Exercise 6.5-3 asks you to write the procedures for min-priority queues.</p>
<a id="p173"/>
<p>A <strong><em><span class="blue1">priority queue</span></em></strong> is a data structure for maintaining a set <em>S</em> of elements, each with an associated value called a <strong><em><span class="blue1">key</span></em></strong>. A <strong><em><span class="blue1">max-priority queue</span></em></strong> supports the following operations:</p>
<p class="para-hang1">I<small>NSERT</small>(<em>S</em>, <em>x</em>, <em>k</em>) inserts the element <em>x</em> with key <em>k</em> into the set <em>S</em>, which is equivalent to the operation <em>S</em> = <em>S</em> <span class="font1">⋃</span> {<em>x</em>}.</p>
<p class="para-hang1">M<small>AXIMUM</small>(<em>S</em>) returns the element of <em>S</em> with the largest key.</p>
<p class="para-hang1">E<small>XTRACT</small>-M<small>AX</small>(<em>S</em>) removes and returns the element of <em>S</em> with the largest key.</p>
<p class="para-hang1">I<small>NCREASE</small>-K<small>EY</small>(<em>S</em>, <em>x</em>, <em>k</em>) increases the value of element <em>x</em>’s key to the new value <em>k</em>, which is assumed to be at least as large as <em>x</em>’s current key value.</p>
<p class="space-break">Among their other applications, you can use max-priority queues to schedule jobs on a computer shared among multiple users. The max-priority queue keeps track of the jobs to be performed and their relative priorities. When a job is finished or interrupted, the scheduler selects the highest-priority job from among those pending by calling E<small>XTRACT</small>-M<small>AX</small>. The scheduler can add a new job to the queue at any time by calling I<small>NSERT</small>.</p>
<p>Alternatively, a <strong><em><span class="blue1">min-priority queue</span></em></strong> supports the operations I<small>NSERT</small>, M<small>INIMUM</small>, E<small>XTRACT</small>-M<small>IN</small>, and D<small>ECREASE</small>-K<small>EY</small>. A min-priority queue can be used in an event-driven simulator. The items in the queue are events to be simulated, each with an associated time of occurrence that serves as its key. The events must be simulated in order of their time of occurrence, because the simulation of an event can cause other events to be simulated in the future. The simulation program calls E<small>XTRACT</small>-M<small>IN</small> at each step to choose the next event to simulate. As new events are produced, the simulator inserts them into the min-priority queue by calling I<small>NSERT</small>. We’ll see other uses for min-priority queues, highlighting the D<small>ECREASE</small>-K<small>EY</small> operation, in <a href="chapter021.xhtml">Chapters 21</a> and <a href="chapter022.xhtml">22</a>.</p>
<p>When you use a heap to implement a priority queue within a given application, elements of the priority queue correspond to objects in the application. Each object contains a key. If the priority queue is implemented by a heap, you need to determine which application object corresponds to a given heap element, and vice versa. Because the heap elements are stored in an array, you need a way to map application objects to and from array indices.</p>
<p>One way to map between application objects and heap elements uses <strong><em><span class="blue1">handles</span></em></strong>, which are additional information stored in the objects and heap elements that give enough information to perform the mapping. Handles are often implemented to be opaque to the surrounding code, thereby maintaining an abstraction barrier between the application and the priority queue. For example, the handle within an application object might contain the corresponding index into the heap array. But since only the code for the priority queue accesses this index, the index is entirely hidden from the application code. Because heap elements change locations within <a id="p174"/>the array during heap operations, an actual implementation of the priority queue, upon relocating a heap element, must also update the array indices in the corresponding handles. Conversely, each element in the heap might contain a pointer to the corresponding application object, but the heap element knows this pointer as only an opaque handle and the application maps this handle to an application object. Typically, the worst-case overhead for maintaining handles is <em>O</em>(1) per access.</p>
<p>As an alternative to incorporating handles in application objects, you can store within the priority queue a mapping from application objects to array indices in the heap. The advantage of doing so is that the mapping is contained entirely within the priority queue, so that the application objects need no further embellishment. The disadvantage lies in the additional cost of establishing and maintaining the mapping. One option for the mapping is a hash table (see <a href="chapter011.xhtml">Chapter 11</a>).<sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup> The added expected time for a hash table to map an object to an array index is just <em>O</em>(1), though the worst-case time can be as bad as Θ(<em>n</em>).</p>
<p>Let’s see how to implement the operations of a max-priority queue using a max-heap. In the previous sections, we treated the array elements as the keys to be sorted, implicitly assuming that any satellite data moved with the corresponding keys. When a heap implements a priority queue, we instead treat each array element as a pointer to an object in the priority queue, so that the object is analogous to the satellite data when sorting. We further assume that each such object has an attribute <em>key</em>, which determines where in the heap the object belongs. For a heap implemented by an array <em>A</em>, we refer to <em>A</em>[<em>i</em>].<em>key</em>.</p>
<p>The procedure M<small>AX</small>-H<small>EAP</small>-M<small>AXIMUM</small> on the facing page implements the M<small>AXIMUM</small> operation in Θ(1) time, and M<small>AX</small>-H<small>EAP</small>-E<small>XTRACT</small>-M<small>AX</small> implements the operation E<small>XTRACT</small>-M<small>AX</small>. M<small>AX</small>-H<small>EAP</small>-E<small>XTRACT</small>-M<small>AX</small> is similar to the <strong>for</strong> loop body (lines 3–5) of the H<small>EAPSORT</small> procedure. We implicitly assume that M<small>AX</small>-H<small>EAPIFY</small> compares priority-queue objects based on their <em>key</em> attributes. We also assume that when M<small>AX</small>-H<small>EAPIFY</small> exchanges elements in the array, it is exchanging pointers and also that it updates the mapping between objects and array indices. The running time of M<small>AX</small>-H<small>EAP</small>-E<small>XTRACT</small>-M<small>AX</small> is <em>O</em>(lg <em>n</em>), since it performs only a constant amount of work on top of the <em>O</em>(lg <em>n</em>) time for M<small>AX</small>-H<small>EAPIFY</small>, plus whatever overhead is incurred within M<small>AX</small>-H<small>EAPIFY</small> for mapping priority-queue objects to array indices.</p>
<p>The procedure M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small> on page 176 implements the I<small>NCREASE</small>-K<small>EY</small> operation. It first verifies that the new key <em>k</em> will not cause the key in the object <em>x</em> to decrease, and if there is no problem, it gives <em>x</em> the new key value. The procedure then finds the index <em>i</em> in the array corresponding to object <em>x</em>, <a id="p175"/>so that <em>A</em>[<em>i</em>] is <em>x</em>. Because increasing the key of <em>A</em>[<em>i</em>] might violate the max-heap property, the procedure then, in a manner reminiscent of the insertion loop (lines 5–7) of I<small>NSERTION</small>-S<small>ORT</small> on page 19, traverses a simple path from this node toward the root to find a proper place for the newly increased key. As M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small> traverses this path, it repeatedly compares an element’s key to that of its parent, exchanging pointers and continuing if the element’s key is larger, and terminating if the element’s key is smaller, since the max-heap property now holds. (See Exercise 6.5-7 for a precise loop invariant.) Like M<small>AX</small>-H<small>EAPIFY</small> when used in a priority queue, M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small> updates the information that maps objects to array indices when array elements are exchanged. <a href="chapter006.xhtml#Fig_6-5">Figure 6.5</a> shows an example of a M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small> operation. In addition to the overhead for mapping priority queue objects to array indices, the running time of M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small> on an <em>n</em>-element heap is <em>O</em>(lg <em>n</em>), since the path traced from the node updated in line 3 to the root has length <em>O</em>(lg <em>n</em>).</p>
<div class="pull-quote1">
<p class="box-heading">M<small>AX</small>-H<small>EAP</small>-M<small>AXIMUM</small>(<em>A</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>A.heap-size</em> &lt; 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><strong>error</strong> “heap underflow”</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>A</em>[1]</p></td>
</tr>
</table>
<p class="box-headinga">M<small>AX</small>-H<small>EAP</small>-E<small>XTRACT</small>-M<small>AX</small>(<em>A</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>max</em> = M<small>AX</small>-H<small>EAP</small>-M<small>AXIMUM</small>(<em>A</em>)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><em>A</em>[1] = <em>A</em>[<em>A.heap-size</em>]</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><em>A.heap-size</em> = <em>A.heap-size</em> – 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent">M<small>AX</small>-H<small>EAPIFY</small>(<em>A</em>, 1)</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>max</em></p></td>
</tr>
</table>
</div>
<p>The procedure M<small>AX</small>-H<small>EAP</small>-I<small>NSERT</small> on the next page implements the I<small>NSERT</small> operation. It takes as inputs the array <em>A</em> implementing the max-heap, the new object <em>x</em> to be inserted into the max-heap, and the size <em>n</em> of array <em>A</em>. The procedure first verifies that the array has room for the new element. It then expands the max-heap by adding to the tree a new leaf whose key is –∞. Then it calls M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small> to set the key of this new element to its correct value and maintain the max-heap property. The running time of M<small>AX</small>-H<small>EAP</small>-I<small>NSERT</small> on an <em>n</em>-element heap is <em>O</em>(lg <em>n</em>) plus the overhead for mapping priority queue objects to indices.</p>
<p>In summary, a heap can support any priority-queue operation on a set of size <em>n</em> in <em>O</em>(lg <em>n</em>) time, plus the overhead for mapping priority queue objects to array indices.</p>
<a id="p176"/>
<div class="pull-quote1">
<p class="box-heading">M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small>(<em>A</em>, <em>x</em>, <em>k</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>k</em> &lt; <em>x.key</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><strong>error</strong> “new key is smaller than current key”</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><em>x.key</em> = <em>k</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent">find the index <em>i</em> in array <em>A</em> where object <em>x</em> occurs</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><strong>while</strong> <em>i</em> &gt; 1 and <em>A</em>[P<small>ARENT</small>(<em>i</em>)].<em>key</em> &lt; <em>A</em>[<em>i</em>].<em>key</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="p2">exchange <em>A</em>[<em>i</em>] with <em>A</em>[P<small>ARENT</small>(<em>i</em>)], updating the information that maps priority queue objects to array indices</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1"><p class="p2"><em>i</em> = P<small>ARENT</small>(<em>i</em>)</p></td>
</tr>
</table>
<p class="box-headinga">M<small>AX</small>-H<small>EAP</small>-I<small>NSERT</small>(<em>A</em>, <em>x</em>, <em>n</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>A.heap-size</em> == <em>n</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="p2"><strong>error</strong> “heap overflow”</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="noindent"><em>A.heap-size</em> = <em>A.heap-size</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">4</span></p></td>
<td class="td1"><p class="noindent"><em>k</em> = <em>x.key</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">5</span></p></td>
<td class="td1"><p class="noindent"><em>x.key</em> = –∞</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">6</span></p></td>
<td class="td1"><p class="noindent"><em>A</em>[<em>A.heap-size</em>] = <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">7</span></p></td>
<td class="td1"><p class="noindent">map <em>x</em> to index <em>heap-size</em> in the array</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">8</span></p></td>
<td class="td1"><p class="noindent">M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small>(<em>A</em>, <em>x</em>, <em>k</em>)</p></td>
</tr>
</table>
</div>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>6.5-1</em></strong></p>
<p class="noindent">Suppose that the objects in a max-priority queue are just keys. Illustrate the operation of M<small>AX</small>-H<small>EAP</small>-E<small>XTRACT</small>-M<small>AX</small> on the heap <em>A</em> = <span class="font1">〈</span>15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1<span class="font1">〉</span>.</p>
<p class="level3"><strong><em>6.5-2</em></strong></p>
<p class="noindent">Suppose that the objects in a max-priority queue are just keys. Illustrate the operation of M<small>AX</small>-H<small>EAP</small>-I<small>NSERT</small>(<em>A</em>, 10) on the heap <em>A</em> = <span class="font1">〈</span>15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1<span class="font1">〉</span>.</p>
<p class="level3"><strong><em>6.5-3</em></strong></p>
<p class="noindent">Write pseudocode to implement a min-priority queue with a min-heap by writing the procedures M<small>IN</small>-H<small>EAP</small>-M<small>INIMUM</small>, M<small>IN</small>-H<small>EAP</small>-E<small>XTRACT</small>-M<small>IN</small>, M<small>IN</small>-H<small>EAP</small>-D<small>ECREASE</small>-K<small>EY</small>, and M<small>IN</small>-H<small>EAP</small>-I<small>NSERT</small>.</p>
<p class="level3"><strong><em>6.5-4</em></strong></p>
<p class="noindent">Write pseudocode for the procedure M<small>AX</small>-H<small>EAP</small>-D<small>ECREASE</small>-K<small>EY</small>(<em>A</em>, <em>x</em>, <em>k</em>) in a max-heap. What is the running time of your procedure?</p>
<a id="p177"/>
<div class="divimage">
<p class="fig-imga" id="Fig_6-5"><img alt="art" class="width100" src="images/Art_P305.jpg"/></p>
<p class="caption"><strong>Figure 6.5</strong> The operation of M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small>. Only the key of each element in the priority queue is shown. The node indexed by <em>i</em> in each iteration is shown in blue. <strong>(a)</strong> The max-heap of <a href="chapter006.xhtml#Fig_6-4">Figure 6.4(a)</a> with <em>i</em> indexing the node whose key is about to be increased. <strong>(b)</strong> This node has its key increased to 15. <strong>(c)</strong> After one iteration of the <strong>while</strong> loop of lines 5–7, the node and its parent have exchanged keys, and the index <em>i</em> moves up to the parent. <strong>(d)</strong> The max-heap after one more iteration of the <strong>while</strong> loop. At this point, <em>A</em>[P<small>ARENT</small>(<em>i</em>)] ≥ <em>A</em>[<em>i</em>]. The max-heap property now holds and the procedure terminates.</p>
</div>
<p class="level3"><strong><em>6.5-5</em></strong></p>
<p class="noindent">Why does M<small>AX</small>-H<small>EAP</small>-I<small>NSERT</small> bother setting the key of the inserted object to –∞ in line 5 given that line 8 will set the object’s key to the desired value?</p>
<p class="level3"><strong><em>6.5-6</em></strong></p>
<p class="noindent">Professor Uriah suggests replacing the <strong>while</strong> loop of lines 5–7 in M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small> by a call to M<small>AX</small>-H<small>EAPIFY</small>. Explain the flaw in the professor’s idea.</p>
<p class="level3"><strong><em>6.5-7</em></strong></p>
<p class="noindent">Argue the correctness of M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small> using the following loop invariant:</p>
<a id="p178"/>
<p class="space-break">At the start of each iteration of the <strong>while</strong> loop of lines 5–7:</p>
<p class="nl-1listt">a. If both nodes P<small>ARENT</small>(<em>i</em>) and L<small>EFT</small>(<em>i</em>) exist, then <em>A</em>[P<small>ARENT</small>(<em>i</em>)].<em>key</em> ≥ <em>A</em>[L<small>EFT</small>(<em>i</em>)].<em>key</em>.</p>
<p class="nl-1list">b. If both nodes P<small>ARENT</small>(<em>i</em>) and R<small>IGHT</small>(<em>i</em>) exist, then <em>A</em>[P<small>ARENT</small>(<em>i</em>)].<em>key</em> ≥ <em>A</em>[R<small>IGHT</small>(<em>i</em>)].<em>key</em>.</p>
<p class="nl-1list">c. The subarray <em>A</em>[1 : <em>A.heap-size</em>] satisfies the max-heap property, except that there may be one violation, which is that <em>A</em>[<em>i</em>].<em>key</em> may be greater than <em>A</em>[P<small>ARENT</small>(<em>i</em>)].<em>key</em>.</p>
<p class="ntop1">You may assume that the subarray <em>A</em>[1 : <em>A.heap-size</em>] satisfies the max-heap property at the time M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small> is called.</p>
<p class="level3"><strong><em>6.5-8</em></strong></p>
<p class="noindent">Each exchange operation on line 6 of M<small>AX</small>-H<small>EAP</small>-I<small>NCREASE</small>-K<small>EY</small> typically requires three assignments, not counting the updating of the mapping from objects to array indices. Show how to use the idea of the inner loop of I<small>NSERTION</small>-S<small>ORT</small> to reduce the three assignments to just one assignment.</p>
<p class="level3"><strong><em>6.5-9</em></strong></p>
<p class="noindent">Show how to implement a first-in, first-out queue with a priority queue. Show how to implement a stack with a priority queue. (Queues and stacks are defined in <a href="chapter010.xhtml#Sec_10.1.3">Section 10.1.3</a>.)</p>
<p class="level3"><strong><em>6.5-10</em></strong></p>
<p class="noindent">The operation M<small>AX</small>-H<small>EAP</small>-D<small>ELETE</small>(<em>A</em>, <em>x</em>) deletes the object <em>x</em> from max-heap <em>A</em>. Give an implementation of M<small>AX</small>-H<small>EAP</small>-D<small>ELETE</small> for an <em>n</em>-element max-heap that runs in <em>O</em>(lg <em>n</em>) time plus the overhead for mapping priority queue objects to array indices.</p>
<p class="level3"><strong><em>6.5-11</em></strong></p>
<p class="noindent">Give an <em>O</em>(<em>n</em> lg <em>k</em>)-time algorithm to merge <em>k</em> sorted lists into one sorted list, where <em>n</em> is the total number of elements in all the input lists. (<em>Hint:</em> Use a min-heap for <em>k</em>-way merging.)</p>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-37"><strong>Problems</strong></p>
<section title="6-1 Building a heap using insertion">
<p class="level2"><strong><em>6-1     Building a heap using insertion</em></strong></p>
<p class="noindent">One way to build a heap is by repeatedly calling M<small>AX</small>-H<small>EAP</small>-I<small>NSERT</small> to insert the elements into the heap. Consider the procedure B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small>′ on the facing page. It assumes that the objects being inserted are just the heap elements.</p>
<a id="p179"/>
<div class="pull-quote1">
<p class="box-heading">B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small>′ (<em>A</em>, <em>n</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><p class="noindent"><span class="x-small">1</span></p></td>
<td class="td1"><p class="noindent"><em>A.heap-size</em> = 1</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">2</span></p></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>i</em> = 2 <strong>to</strong> <em>n</em></p></td>
</tr>
<tr>
<td class="td1"><p class="noindent"><span class="x-small">3</span></p></td>
<td class="td1"><p class="p2">M<small>AX</small>-H<small>EAP</small>-I<small>NSERT</small>(<em>A</em>, <em>A</em>[<em>i</em>], <em>n</em>)</p></td>
</tr>
</table>
</div>
<p class="nl-top"><strong><em>a.</em></strong> Do the procedures B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> and B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small>′ always create the same heap when run on the same input array? Prove that they do, or provide a counterexample.</p>
<p class="nl"><strong><em>b.</em></strong> Show that in the worst case, B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small>′ requires Θ(<em>n</em> lg <em>n</em>) time to build an <em>n</em>-element heap.</p>
</section>
<section title="6-2 Analysis of d-ary heaps">
<p class="level2"><strong><em>6-2     Analysis of d-ary heaps</em></strong></p>
<p class="noindent">A <strong><em><span class="blue1">d-ary heap</span></em></strong> is like a binary heap, but (with one possible exception) nonleaf nodes have <em>d</em> children instead of two children. In all parts of this problem, assume that the time to maintain the mapping between objects and heap elements is <em>O</em>(1) per operation.</p>
<p class="nl"><strong><em>a.</em></strong> Describe how to represent a <em>d</em>-ary heap in an array.</p>
<p class="nl"><strong><em>b.</em></strong> Using Θ-notation, express the height of a <em>d</em>-ary heap of <em>n</em> elements in terms of <em>n</em> and <em>d</em>.</p>
<p class="nl"><strong><em>c.</em></strong> Give an efficient implementation of E<small>XTRACT</small>-M<small>AX</small> in a <em>d</em>-ary max-heap. Analyze its running time in terms of <em>d</em> and <em>n</em>.</p>
<p class="nl"><strong><em>d.</em></strong> Give an efficient implementation of I<small>NCREASE</small>-K<small>EY</small> in a <em>d</em>-ary max-heap. Analyze its running time in terms of <em>d</em> and <em>n</em>.</p>
<p class="nl"><strong><em>e.</em></strong> Give an efficient implementation of I<small>NSERT</small> in a <em>d</em>-ary max-heap. Analyze its running time in terms of <em>d</em> and <em>n</em>.</p>
<p class="level2"><strong><em>6-3 Young tableaus</em></strong></p>
<p class="noindent">An <em>m</em> × <em>n</em> <strong><em><span class="blue1">Young tableau</span></em></strong> is an <em>m</em> × <em>n</em> matrix such that the entries of each row are in sorted order from left to right and the entries of each column are in sorted order from top to bottom. Some of the entries of a Young tableau may be ∞, which we treat as nonexistent elements. Thus, a Young tableau can be used to hold <em>r</em> ≤ <em>mn</em> finite numbers.</p>
<p class="nl-top"><strong><em>a.</em></strong> Draw a 4 × 4 Young tableau containing the elements {9, 16, 3, 2, 4, 8, 5, 14, 12}.<a id="p180"/></p>
<p class="nl"><strong><em>b.</em></strong> Argue that an <em>m</em> × <em>n</em> Young tableau <em>Y</em> is empty if <em>Y</em> [1, 1] = ∞. Argue that <em>Y</em> is full (contains <em>mn</em> elements) if <em>Y</em> [<em>m</em>, <em>n</em>] &lt; ∞.</p>
<p class="nl"><strong><em>c.</em></strong> Give an algorithm to implement E<small>XTRACT</small>-M<small>IN</small> on a nonempty <em>m</em> × <em>n</em> Young tableau that runs in <em>O</em>(<em>m</em> + <em>n</em>) time. Your algorithm should use a recursive subroutine that solves an <em>m</em> × <em>n</em> problem by recursively solving either an (<em>m</em> – 1) × <em>n</em> or an <em>m</em> × (<em>n</em> – 1) subproblem. (<em>Hint:</em> Think about M<small>AX</small>-H<small>EAPIFY</small>.) Explain why your implementation of E<small>XTRACT</small>-M<small>IN</small> runs in <em>O</em>(<em>m</em> + <em>n</em>) time.</p>
<p class="nl"><strong><em>d.</em></strong> Show how to insert a new element into a nonfull <em>m</em> × <em>n</em> Young tableau in <em>O</em>(<em>m</em> + <em>n</em>) time.</p>
<p class="nl"><strong><em>e.</em></strong> Using no other sorting method as a subroutine, show how to use an <em>n</em> × <em>n</em> Young tableau to sort <em>n</em><sup>2</sup> numbers in <em>O</em>(<em>n</em><sup>3</sup>) time.</p>
<p class="nl"><strong><em>f.</em></strong> Give an <em>O</em>(<em>m</em> + <em>n</em>)-time algorithm to determine whether a given number is stored in a given <em>m</em> × <em>n</em> Young tableau.</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-38"><strong>Chapter notes</strong></p>
<p class="noindent">The heapsort algorithm was invented by Williams [<a epub:type="noteref" href="bibliography001.xhtml#endnote_456">456</a>], who also described how to implement a priority queue with a heap. The B<small>UILD</small>-M<small>AX</small>-H<small>EAP</small> procedure was suggested by Floyd [<a epub:type="noteref" href="bibliography001.xhtml#endnote_145">145</a>]. Schaffer and Sedgewick [<a epub:type="noteref" href="bibliography001.xhtml#endnote_395">395</a>] showed that in the best case, the number of times elements move in the heap during heapsort is approximately (<em>n</em>/2) lg <em>n</em> and that the average number of moves is approximately <em>n</em> lg <em>n</em>.</p>
<p>We use min-heaps to implement min-priority queues in <a href="chapter015.xhtml">Chapters 15</a>, <a href="chapter021.xhtml">21</a>, and <a href="chapter022.xhtml">22</a>. Other, more complicated, data structures give better time bounds for certain min-priority queue operations. Fredman and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_156">156</a>] developed Fibonacci heaps, which support I<small>NSERT</small> and D<small>ECREASE</small>-K<small>EY</small> in <em>O</em>(1) amortized time (see <a href="chapter016.xhtml">Chapter 16</a>). That is, the average worst-case running time for these operations is <em>O</em>(1). Brodal, Lagogiannis, and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_73">73</a>] subsequently devised strict Fibonacci heaps, which make these time bounds the actual running times. If the keys are unique and drawn from the set {0, 1, … , <em>n</em> – 1} of nonnegative integers, van Emde Boas trees [<a epub:type="noteref" href="bibliography001.xhtml#endnote_440">440</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_441">441</a>] support the operations I<small>NSERT</small>, D<small>ELETE</small>, S<small>EARCH</small>, M<small>INIMUM</small>, M<small>AXIMUM</small>, P<small>REDECESSOR</small>, and S<small>UCCESSOR</small> in <em>O</em>(lg lg <em>n</em>) time.</p>
<p>If the data are <em>b</em>-bit integers, and the computer memory consists of addressable <em>b</em>-bit words, Fredman and Willard [<a epub:type="noteref" href="bibliography001.xhtml#endnote_157">157</a>] showed how to implement M<small>INIMUM</small> in <em>O</em>(1) time and I<small>NSERT</small> and E<small>XTRACT</small>-M<small>IN</small> in <img alt="art" src="images/Art_P306.jpg"/> time. Thorup [<a epub:type="noteref" href="bibliography001.xhtml#endnote_436">436</a>] has <a id="p181"/>improved the <img alt="art" src="images/Art_P307.jpg"/> bound to <em>O</em>(lg lg <em>n</em>) time by using randomized hashing, requiring only linear space.</p>
<p>An important special case of priority queues occurs when the sequence of E<small>XTRACT</small>-M<small>IN</small> operations is <strong><em><span class="blue1">monotone</span></em></strong>, that is, the values returned by successive E<small>XTRACT</small>-M<small>IN</small> operations are monotonically increasing over time. This case arises in several important applications, such as Dijkstra’s single-source shortest-paths algorithm, which we discuss in <a href="chapter022.xhtml">Chapter 22</a>, and in discrete-event simulation. For Dijkstra’s algorithm it is particularly important that the D<small>ECREASE</small>-K<small>EY</small> operation be implemented efficiently. For the monotone case, if the data are integers in the range 1, 2, … , <em>C</em>, Ahuja, Mehlhorn, Orlin, and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_8">8</a>] describe how to implement E<small>XTRACT</small>-M<small>IN</small> and I<small>NSERT</small> in <em>O</em>(lg <em>C</em>) amortized time (<a href="chapter016.xhtml">Chapter 16</a> presents amortized analysis) and D<small>ECREASE</small>-K<small>EY</small> in <em>O</em>(1) time, using a data structure called a radix heap. The <em>O</em>(lg <em>C</em>) bound can be improved to <img alt="art" src="images/Art_P308.jpg"/> using Fibonacci heaps in conjunction with radix heaps. Cherkassky, Goldberg, and Silverstein [<a epub:type="noteref" href="bibliography001.xhtml#endnote_90">90</a>] further improved the bound to <em>O</em>(lg<sup>1/3+<em><span class="font1">ϵ</span></em></sup> <em>C</em>) expected time by combining the multilevel bucketing structure of Denardo and Fox [<a epub:type="noteref" href="bibliography001.xhtml#endnote_112">112</a>] with the heap of Thorup mentioned earlier. Raman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_375">375</a>] further improved these results to obtain a bound of <em>O</em>(min {lg<sup>1/4+<em><span class="font1">ϵ</span></em></sup> <em>C</em>, lg<sup>1/3+<em><span class="font1">ϵ</span></em></sup> <em>n</em>}), for any fixed <em><span class="font1">ϵ</span></em> &gt; 0.</p>
<p>Many other variants of heaps have been proposed. Brodal [<a epub:type="noteref" href="bibliography001.xhtml#endnote_72">72</a>] surveys some of these developments.</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> In Python, dictionaries are implemented with hash tables.</p>
</section>
</section>
</div>
</body>
</html>