<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p704"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="25 Matchings in Bipartite Graphs">
<p class="chapter-title"><a href="toc.xhtml#chap-25"><strong><span class="blue1">25        Matchings in Bipartite Graphs</span></strong></a></p>
<p class="noindent">Many real-world problems can be modeled as finding matchings in an undirected graph. For an undirected graph <em>G</em> = (<em>V</em>, <em>E</em>), a <strong><em><span class="blue">matching</span></em></strong> is a subset of edges <em>M</em> ⊆ <em>E</em> such that every vertex in <em>V</em> has at most one incident edge in <em>M</em>.</p>
<p>For example, consider the following scenario. You have one or more positions to fill and several candidates to interview. According to your schedule, you are able to interview candidates at certain time slots. You ask the candidates to indicate the subsets of time slots at which they are available. How can you schedule the interviews so that each time slot has at most one candidate scheduled, while maximizing the number of candidates that you can interview? You can model this scenario as a matching problem on a bipartite graph in which each vertex represents either a candidate or a time slot, with an edge between a candidate and a time slot if the candidate is available then. If an edge is included in the matching, that means you are scheduling a particular candidate for a particular time slot. Your goal is to find a <strong><em><span class="blue">maximum matching</span></em></strong>: a matching of maximum cardinality. One of the authors of this book was faced with exactly this situation when hiring teaching assistants for a large class. He used the Hopcroft-Karp algorithm in <a href="chapter025.xhtml#Sec_25.1">Section 25.1</a> to schedule the interviews.</p>
<p>Another application of matching is the U.S. National Resident Matching Program, in which medical students are matched to hospitals where they will be stationed as medical residents. Each student ranks the hospitals by preference, and each hospital ranks the students. The goal is to assign students to hospitals so that there is never a student and a hospital that both have regrets because the student was not assigned to the hospital, yet each ranked the other higher than who or where they were assigned. This scenario is perhaps the best-known real-world example of the “stable-marriage problem,” which <a href="chapter025.xhtml#Sec_25.2">Section 25.2</a> examines.</p>
<p>Yet another instance where matching comes into play occurs when workers must be assigned to tasks in order to maximize the overall effectiveness of the assignment. For each worker and each task, the worker has some quantified effectiveness <a id="p705"/>for that task. Assuming that there are equal numbers of workers and tasks, the goal is to find a matching with the maximum total effectiveness. Such a situation is an example of an assignment problem, which <a href="chapter025.xhtml#Sec_25.3">Section 25.3</a> shows how to solve.</p>
<p>The algorithms in this chapter find matchings in <strong><em><span class="blue">bipartite</span></em></strong> graphs. As in <a href="chapter024.xhtml#Sec_24.3">Section 24.3</a>, the input is an undirected graph <em>G</em> = (<em>V</em>, <em>E</em>), where <em>V</em> = <em>L</em> ∪ <em>R</em>, the vertex sets <em>L</em> and <em>R</em> are disjoint, and every edge in <em>E</em> is incident on one vertex in <em>L</em> and one vertex in <em>R</em>. A matching, therefore, matches vertices in <em>L</em> with vertices in <em>R</em>. In some applications, the sets <em>L</em> and <em>R</em> have equal cardinality, and in other applications they need not be the same size.</p>
<p>An undirected graph need not be bipartite for the concept of matching to apply. Matching in general undirected graphs has applications in areas such as scheduling and computational chemistry. It models problems in which you want to pair up entities, represented by vertices. Two vertices are adjacent if they represent compatible entities, and you need to find a large set of compatible pairs. Maximum-matching and maximum-weight matching problems on general graphs can be solved by polynomial-time algorithms whose running times are similar to those for bipartite matching, but the algorithms are significantly more complicated. Exercise 25.2-5 discusses the general version of the stable-marriage problem, known as the “stable-roommates problem.” Although matching applies to general undirected graphs, this chapter deals only with bipartite graphs.</p>
<p class="line1"/>
<section title="25.1 Maximum bipartite matching (revisited)">
<a id="Sec_25.1"/>
<p class="level1" id="h1-146"><a href="toc.xhtml#Rh1-146"><strong>25.1    Maximum bipartite matching (revisited)</strong></a></p>
<p class="noindent"><a href="chapter024.xhtml#Sec_24.3">Section 24.3</a> demonstrated one way to find a maximum matching in a bipartite graph, by finding a maximum flow. This section provides a more efficient method, the Hopcroft-Karp algorithm, which runs in <img alt="art" src="images/Art_P790.jpg"/> time. <a href="chapter025.xhtml#Fig_25-1">Figure 25.1(a)</a> shows a matching in an undirected bipartite graph. A vertex that has an incident edge in matching <em>M</em> is <strong><em><span class="blue">matched</span></em></strong> under <em>M</em>, and otherwise, it is <strong><em><span class="blue">unmatched</span></em></strong>. A <strong><em><span class="blue">maximal matching</span></em></strong> is a matching <em>M</em> to which no other edges can be added, that is, for every edge <em>e</em> ∈ <em>E</em> − <em>M</em>, the edge set <em>M</em> ∪ {<em>e</em>} fails to be a matching. A maximum matching is always maximal, but the reverse does not always hold.</p>
<p>Many algorithms to find maximum matchings, the Hopcroft-Karp algorithm included, work by incrementally increasing the size of a matching. Given a matching <em>M</em> in an undirected graph <em>G</em> = (<em>V</em>, <em>E</em>), an <strong><em><span class="blue">M-alternating path</span></em></strong> is a simple path whose edges alternate between being in <em>M</em> and being in <em>E</em> − <em>M</em>. <a href="chapter025.xhtml#Fig_25-1">Figure 25.1(b)</a> depicts an <strong><em><span class="blue">M-augmenting path</span></em></strong> (sometimes called an augmenting path with respect to <em>M</em>): an <em>M</em>-alternating path whose first and last edges belong to <em>E</em> − <em>M</em>. Since an <em>M</em>-augmenting path contains one more edge in <em>E</em> − <em>M</em> than in <em>M</em>, it must consist of an odd number of edges.</p>
<a id="p706"/>
<div class="divimage">
<p class="fig-imga" id="Fig_25-1"><img alt="art" class="width100" src="images/Art_P791.jpg"/></p>
<p class="caption"><strong>Figure 25.1</strong> A bipartite graph, where <em>V</em> = <em>L</em> ∪ <em>R</em>, <em>L</em> = {<em>l</em><sub>1</sub>, <em>l</em><sub>2</sub>, … , <em>l</em><sub>7</sub>}, and <em>R</em> = {<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, … , <em>r</em><sub>8</sub>}. <strong>(a)</strong> A matching <em>M</em> with cardinality 4, highlighted in blue. Matched vertices are blue, and unmatched vertices are tan. <strong>(b)</strong> The five edges highlighted in orange form an <em>M</em>-augmenting path <em>P</em> going between vertices <em>l</em><sub>6</sub> and <em>r</em><sub>8</sub>. <strong>(c)</strong> The set of edges <em>M</em>′ = <em>M</em> ⊕ <em>P</em> highlighted in blue is a matching containing one more edge than <em>M</em> and adding <em>l</em><sub>6</sub> and <em>r</em><sub>8</sub> to the matched vertices. This matching is not a maximum matching (see Exercise 25.1-1).</p>
</div>
<p><a href="chapter025.xhtml#Fig_25-1">Figure 25.1(c)</a> demonstrates the following lemma, which shows that by removing from matching <em>M</em> the edges in an <em>M</em>-augmenting path that belong to <em>M</em> and adding to <em>M</em> the edges in the <em>M</em>-augmenting path that are not in <em>M</em>, the result is a new matching with one more edge than <em>M</em>. Since a matching is a set of edges, the lemma relies on the notion of the <strong><em><span class="blue">symmetric difference</span></em></strong> of two sets: <em>X</em> ⊕ <em>Y</em> = (<em>X</em> − <em>Y</em>) ∪ (<em>Y</em> − <em>X</em>), that is, the elements that belong to <em>X</em> or <em>Y</em>, but not both. Alternatively, you can think of <em>X</em> ⊕ <em>Y</em> as (<em>X</em> ∪ <em>Y</em>)−(<em>X</em> ∩ <em>Y</em>). The operator ⊕ is commutative and associative. Furthermore, <em>X</em> ⊕ <em>X</em> = Ø and <em>X</em> ⊕ Ø = Ø ⊕ <em>X</em> = <em>X</em> for any set <em>X</em>, so that the empty set is the identity for ⊕.</p>
<p class="lem"><strong><em>Lemma 25.1</em></strong></p>
<p class="noindent">Let <em>M</em> be a matching in any undirected graph <em>G</em> = (<em>V</em>, <em>E</em>), and let <em>P</em> be an <em>M</em>-augmenting path. Then the set of edges <em>M</em>′ = <em>M</em> ⊕ <em>P</em> is also a matching in <em>G</em> with |<em>M</em>′| = |<em>M</em>| + 1.</p>
<a id="p707"/>
<p class="prof"><strong><em>Proof</em></strong>   Let <em>P</em> contain <em>q</em> edges, so that <span class="font1">⌈</span>q/2<span class="font1">⌉</span> edges belong to <em>E</em> − <em>M</em> and <span class="font1">⌊</span>q/2<span class="font1">⌋</span> edges belong to <em>M</em>, and let these <em>q</em> edges be (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>), (<em>v</em><sub>2</sub>, <em>v</em><sub>3</sub>), … , (<em>v</em><sub><em>q</em></sub>, <em>v</em><sub><em>q</em>+1</sub>). Because <em>P</em> is an <em>M</em>-augmenting path, vertices <em>v</em><sub>1</sub> and <em>v</em><sub><em>q</em>+1</sub> are unmatched under <em>M</em> and all other vertices in <em>P</em> are matched. Edges (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>), (<em>v</em><sub>3</sub>, <em>v</em><sub>4</sub>), … , (<em>v</em><sub><em>q</em></sub>, <em>v</em><sub><em>q</em>+1</sub>) belong to <em>E</em> − <em>M</em>, and edges (<em>v</em><sub>2</sub>, <em>v</em><sub>3</sub>), (<em>v</em><sub>4</sub>, <em>v</em><sub>5</sub>), … , (<em>v</em><sub><em>q</em>−1</sub>, <em>v</em><sub><em>q</em></sub>) belong to <em>M</em>. The symmetric difference <em>M</em>′ = <em>M</em> ⊕ <em>P</em> reverses these roles, so that edges (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>), (<em>v</em><sub>3</sub>, <em>v</em><sub>4</sub>), … , (<em>v</em><sub><em>q</em></sub>, <em>v</em><sub><em>q</em>+1</sub>) belong to <em>M</em>′ and (<em>v</em><sub>2</sub>, <em>v</em><sub>3</sub>), (<em>v</em><sub>4</sub>, <em>v</em><sub>5</sub>), … , (<em>v</em><sub><em>q</em>−1</sub>, <em>v</em><sub><em>q</em></sub>) belong to <em>E</em> − <em>M</em>′. Each vertex <em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, … , <em>v</em><sub><em>q</em></sub>, <em>v</em><sub><em>q</em>+1</sub> is matched under <em>M</em>′, which gains one additional edge relative to <em>M</em>, and no other vertices or edges in <em>G</em> are affected by the change from <em>M</em> to <em>M</em>′. Hence, <em>M</em>′ is a matching in <em>G</em>, and |<em>M</em>′| = |<em>M</em>| + 1.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Since taking the symmetric difference of a matching <em>M</em> with an <em>M</em>-augmenting path increases the size of the matching by 1, the following corollary shows that taking the symmetric difference of <em>M</em> with <em>k</em> vertex-disjoint <em>M</em>-augmenting paths increases the size of the matching by <em>k</em>.</p>
<p class="cor"><strong><em>Corollary 25.2</em></strong></p>
<p class="noindent">Let <em>M</em> be a matching in any undirected graph <em>G</em> = (<em>V</em>, <em>E</em>) and <em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>, … , <em>P</em><sub><em>k</em></sub> be vertex-disjoint <em>M</em>-augmenting paths. Then the set of edges <em>M</em>′ = <em>M</em> ⊕ (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ … ∪ <em>P</em><sub><em>k</em></sub>) is a matching in <em>G</em> with |<em>M</em>′| = |<em>M</em>| + <em>k</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   Since the <em>M</em>-augmenting paths <em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>, … , <em>P</em><sub><em>k</em></sub> are vertex-disjoint, we have that <em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪<span class="font1">⋯</span>∪ <em>P</em><sub><em>k</em></sub> = <em>P</em><sub>1</sub>⊕ <em>P</em><sub>2</sub> ⊕<span class="font1">⋯</span>⊕ <em>P</em><sub><em>k</em></sub>. Because the operator ⊕ is associative, we have</p>
<table class="table2b">
<tr>
<td class="td2"><em>M</em> ⊕ (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>k</em></sub>)</td>
<td class="td2">=</td>
<td class="td2"><em>M</em> ⊕ (<em>P</em><sub>1</sub> ⊕ <em>P</em><sub>2</sub> ⊕ <span class="font1">⋯</span> ⊕ <em>P</em><sub><em>k</em></sub>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">(<span class="font1">⋯</span> ((<em>M</em> ⊕ <em>P</em><sub>1</sub>) ⊕ <em>P</em><sub>2</sub>) ⊕ <span class="font1">⋯</span> ⊕ <em>P</em><sub><em>k</em>−1</sub>) ⊕ <em>P</em><sub><em>k</em></sub>.</td>
</tr>
</table>
<p class="noindent">A simple induction on <em>i</em> using Lemma 25.1 shows that <em>M</em> ⊕ (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>i</em>−1</sub>) is a matching in <em>G</em> containing |<em>M</em>| + <em>i</em> − 1 edges and that path <em>P</em><sub><em>i</em></sub> is an augmenting path with respect to <em>M</em> ⊕ (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>i</em>−1</sub>). Each of these augmenting paths increases the size of the matching by 1, and so |<em>M</em>′| = |<em>M</em>| + <em>k</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">As the Hopcroft-Karp algorithm goes from matching to matching, it will be useful to consider the symmetric difference between two matchings.</p>
<p class="lem"><strong><em>Lemma 25.3</em></strong></p>
<p class="noindent">Let <em>M</em> and <em>M</em>* be matchings in graph <em>G</em> = (<em>V</em>, <em>E</em>), and consider the graph <em>G</em>′ = (<em>V</em>, <em>E</em>′), where <em>E</em>′ = <em>M</em> ⊕ <em>M</em>*. Then, <em>G</em>′ is a disjoint union of simple paths, simple cycles, and/or isolated vertices. The edges in each such simple path or simple cycle <a id="p708"/>alternate between <em>M</em> and <em>M</em>*. If |<em>M</em>*| &gt; |<em>M</em>|, then <em>G</em>′ contains at least |<em>M</em>*|−|<em>M</em>| vertex-disjoint <em>M</em>-augmenting paths.</p>
<p class="prof"><strong><em>Proof</em></strong>   Each vertex in <em>G</em>′ has degree 0, 1, or 2, since at most two edges of <em>E</em>′ can be incident on a vertex: at most one edge from <em>M</em> and at most one edge from <em>M</em>*. Therefore, each connected component of <em>G</em>′ is either a singleton vertex, an even-length simple cycle with edges alternately in <em>M</em> and <em>M</em>*, or a simple path with edges alternately in <em>M</em> and <em>M</em>*. Since</p>
<table class="table2b">
<tr>
<td class="td2"><em>E</em>′</td>
<td class="td2">=</td>
<td class="td2"><em>M</em> ⊕ <em>M</em>*</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">(<em>M</em> ∪ <em>M</em>*) − (<em>M</em> ∩ <em>M</em>*)</td>
</tr>
</table>
<p class="noindent">and |<em>M</em>*| &gt; |<em>M</em>|, the edge set <em>E</em>′ must contain |<em>M</em>*| − |<em>M</em>| more edges from <em>M</em>* than from <em>M</em>. Because each cycle in <em>G</em>′ has an even number of edges drawn alternately from <em>M</em> and <em>M</em>*, each cycle has an equal number of edges from <em>M</em> and <em>M</em>*. Therefore, the simple paths in <em>G</em>′ account for there being |<em>M</em>*| − |<em>M</em>| more edges from <em>M</em>* than <em>M</em>. Each path containing a different number of edges from <em>M</em> and <em>M</em>* either starts and ends with edges from <em>M</em>, containing one more edge from <em>M</em> than from <em>M</em>*, or starts and ends with edges from <em>M</em>*, containing one more edge from <em>M</em>* than from <em>M</em>. Because <em>E</em>′ contains |<em>M</em>*| − |<em>M</em>| more edges from <em>M</em>* than from <em>M</em>, there are at least |<em>M</em>*| − |<em>M</em>| paths of the latter type, and each one is an <em>M</em>-augmenting path. Because each vertex has at most two incident edges from <em>E</em>′, these paths must be vertex-disjoint.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">If an algorithm finds a maximum matching by incrementally increasing the size of the matching, how does it determine when to stop? The following corollary gives the answer: when there are no augmenting paths.</p>
<p class="cor"><strong><em>Corollary 25.4</em></strong></p>
<p class="noindent">Matching <em>M</em> in graph <em>G</em> = (<em>V</em>, <em>E</em>) is a maximum matching if and only if <em>G</em> contains no <em>M</em>-augmenting path.</p>
<p class="prof"><strong><em>Proof</em></strong>   We prove the contrapositive of both directions of the lemma statement. The contrapositive of the forward direction is straightforward. If there is an <em>M</em>-augmenting path <em>P</em> in <em>G</em>, then by Lemma 25.1, the matching <em>M</em> ⊕ <em>P</em> contains one more edge than <em>M</em>, meaning that <em>M</em> could not be a maximum matching.</p>
<p>To show the contrapositive of the backward direction—if <em>M</em> is not a maximum matching, then <em>G</em> contains an <em>M</em>-augmenting path—let <em>M</em>* be a maximum matching in Lemma 25.3, so that |<em>M</em>*| &gt; |<em>M</em>|. Then <em>G</em> contains at least |<em>M</em>*| − |<em>M</em>| &gt; 0 vertex-disjoint <em>M</em>-augmenting paths.</p>
<p class="right"><span class="font1">▪</span></p>
<a id="p709"/>
<p>We already have learned enough to create a maximum-matching algorithm that runs in <em>O</em>(<em>VE</em>) time. Start with the matching <em>M</em> empty. Then repeatedly run a variant of either breadth-first search or depth-first search from an unmatched vertex that takes alternating paths until you find another unmatched vertex. Use the resulting <em>M</em>-augmenting path to increase the size of <em>M</em> by 1.</p>
<p class="level4"><strong>The Hopcroft-Karp algorithm</strong></p>
<p class="noindent">The Hopcroft-Karp algorithm improves the running time to <img alt="art" src="images/Art_P792.jpg"/>. The procedure H<small>OPCROFT</small>-K<small>ARP</small> is given an undirected bipartite graph, and it uses Corollary 25.2 to repeatedly increase the size of the matching <em>M</em> it finds. Corollary 25.4 proves that the algorithm is correct, since it terminates once there are no <em>M</em>-augmenting paths. It remains to show that the algorithm does run in <img alt="art" src="images/Art_P793.jpg"/> time. We’ll see that the <strong>repeat</strong> loop of lines 2–5 iterates <img alt="art" src="images/Art_P794.jpg"/> times and how to implement line 3 so that it runs in <em>O</em>(<em>E</em>) time in each iteration.</p>
<div class="pull-quote1">
<p class="box-heading">H<small>OPCROFT</small>-K<small>ARP</small> (<em>G</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><em>M</em> = Ø</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="noindent"><strong>repeat</strong></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p2">let <span class="script">P</span> = {<em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>, … , <em>P</em><sub><em>k</em></sub>} be a maximal set of vertex-disjoint shortest <em>M</em>-augmenting paths</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><em>M</em> = <em>M</em> ⊕ (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>k</em></sub>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="noindent"><strong>until</strong> <span class="script">P</span> == Ø</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>M</em></p></td>
</tr>
</table>
</div>
<p>Let’s first see how to find a maximal set of vertex-disjoint shortest <em>M</em>-augmenting paths in <em>O</em>(<em>E</em>) time. There are three phases. The first phase forms a directed version <em>G</em><sub><em>M</em></sub> of the undirected bipartite graph <em>G</em>. The second phase creates a directed acyclic graph <em>H</em> from <em>G</em><sub><em>M</em></sub> via a variant of breadth-first search. The third phase finds a maximal set of vertex-disjoint shortest <em>M</em>-augmenting paths by running a variant of depth-first search on the transpose <em>H</em><sup>T</sup> of <em>H</em>. (Recall that the transpose of a directed graph reverses the direction of each edge. Since <em>H</em> is acyclic, so is <em>H</em><sup>T</sup>.)</p>
<p>Given a matching <em>M</em>, you can think of an <em>M</em>-augmenting path <em>P</em> as starting at an unmatched vertex in <em>L</em>, traversing an odd number of edges, and ending at an unmatched vertex in <em>R</em>. The edges in <em>P</em> traversed from <em>L</em> to <em>R</em> must belong to <em>E</em> − <em>M</em>, and the edges in <em>P</em> traversed from <em>R</em> to <em>L</em> must belong to <em>M</em>. The first phase, therefore, creates the directed graph <em>G</em><sub><em>M</em></sub> by directing the edges accordingly: <em>G</em><sub><em>M</em></sub> = (<em>V</em>, <em>E</em><sub><em>M</em></sub>), where</p>
<a id="p710"/>
<div class="divimage">
<p class="fig-imga" id="Fig_25-2"><img alt="art" class="width100" src="images/Art_P795.jpg"/></p>
<p class="caption"><strong>Figure 25.2 (a)</strong> The directed graph <em>G</em><sub><em>M</em></sub> created in the first phase for the undirected bipartite graph <em>G</em> and matching <em>M</em> in <a href="chapter025.xhtml#Fig_25-1">Figure 25.1(a)</a>. Breadth-first distances from any unmatched vertex in <em>L</em> appear next to each vertex. <strong>(b)</strong> The dag <em>H</em> created from <em>G</em><sub><em>M</em></sub> in the second phase. Because the smallest distance to an unmatched vertex in <em>R</em> is 3, vertices <em>l</em><sub>7</sub> and <em>r</em><sub>8</sub>, with distances greater than 3, are not in <em>H</em>.</p>
</div>
<table class="table2b">
<tr>
<td class="td2"><em>E</em><sub><em>M</em></sub></td>
<td class="td2">=</td>
<td class="td2">{(<em>l</em>, <em>r</em>) : <em>l</em> ∈ <em>L</em>, <em>r</em> ∈ <em>R</em>, and (<em>l</em>, <em>r</em>) ∈ <em>E</em> − <em>M</em> }</td>
<td class="td2">(edges from <em>L</em> to <em>R</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2"/>
<td class="td2">∪ {(<em>r</em>, <em>l</em>) : <em>r</em> ∈ <em>R</em>, <em>l</em> ∈ <em>L</em>, and (<em>l</em>, <em>r</em>) ∈ <em>M</em> }</td>
<td class="td2">(edges from <em>R</em> to <em>L</em>).</td>
</tr>
</table>
<p class="noindent"><a href="chapter025.xhtml#Fig_25-2">Figure 25.2(a)</a> shows the graph <em>G</em><sub><em>M</em></sub> for the graph <em>G</em> and matching <em>M</em> in <a href="chapter025.xhtml#Fig_25-1">Figure 25.1(a)</a>.</p>
<p>The dag <em>H</em> = (<em>V</em><sub><em>H</em></sub>, <em>E</em><sub><em>H</em></sub>) created by the second phase has layers of vertices. <a href="chapter025.xhtml#Fig_25-2">Figure 25.2(b)</a> shows the dag <em>H</em> corresponding to the directed graph <em>G</em><sub><em>M</em></sub> in part (a) of the figure. Each layer contains only vertices from <em>L</em> or only vertices from <em>R</em>, alternating from layer to layer. The layer that a vertex resides in is given by that vertex’s minimum breadth-first distance in <em>G</em><sub><em>M</em></sub> from any unmatched vertex in <em>L</em>. Vertices in <em>L</em> appear in even-numbered layers, and vertices in <em>R</em> appear in odd-numbered layers. Let <em>q</em> denote the smallest distance in <em>G</em><sub><em>M</em></sub> of any unmatched vertex in <em>R</em>. Then, the last layer in <em>H</em> contains the vertices in <em>R</em> with distance <em>q</em>. Vertices whose distance exceeds <em>q</em> do not appear in <em>V</em><sub><em>H</em></sub>. (The graph <em>H</em> in <a href="chapter025.xhtml#Fig_25-2">Figure 25.2(b)</a> omits vertices <em>l</em><sub>7</sub> and <em>r</em><sub>8</sub> because their distances from any unmatched vertex in <em>L</em> exceed <em>q</em> = 3.) The edges in <em>E</em><sub><em>H</em></sub> form a subset of <em>E</em><sub><em>M</em></sub>:</p>
<a id="p711"/>
<p class="eql"><em>E</em><sub><em>H</em></sub> = {(<em>l</em>, <em>r</em>) ∈ <em>E</em><sub><em>M</em></sub> : <em>r</em>.<em>d</em> ≤ <em>q</em> and <em>r</em>.<em>d</em> = <em>l</em>.<em>d</em> + 1} ∪ {(<em>r</em>, <em>l</em>) ∈ <em>E</em><sub><em>M</em></sub> : <em>l</em>.<em>d</em> ≤ <em>q</em>},</p>
<p class="noindent">where the attribute <em>d</em> of a vertex gives the vertex’s breadth-first distance in <em>G</em><sub><em>M</em></sub> from any unmatched vertex in <em>L</em>. Edges that do not go between two consecutive layers are omitted from <em>E</em><sub><em>H</em></sub>.</p>
<p>To determine the breadth-first distances of vertices, run breadth-first search on the graph <em>G</em><sub><em>M</em></sub>, but starting from all the unmatched vertices in <em>L</em>. (In the BFS procedure on page 556, replace the root vertex <em>s</em> by the set of unmatched vertices in <em>L</em>.) The predecessor attributes <em>π</em> computed by the BFS procedure are not needed here, since <em>H</em> is a dag and not necessarily a tree.</p>
<p>Every path in <em>H</em> from a vertex in layer 0 to an unmatched vertex in layer <em>q</em> corresponds to a shortest <em>M</em>-augmenting path in the original bipartite graph <em>G</em>. Just use the undirected versions of the directed edges in <em>H</em>. Moreover, every shortest <em>M</em>-augmenting path in <em>G</em> is present in <em>H</em>.</p>
<p>The third phase identifies a maximal set of vertex-disjoint shortest <em>M</em>-augmenting paths. As <a href="chapter025.xhtml#Fig_25-3">Figure 25.3</a> shows, it starts by creating the transpose <em>H</em><sup>T</sup> of <em>H</em>. Then, for each unmatched vertex <em>r</em> in layer <em>q</em>, it performs a depth-first search starting from <em>r</em> until it either reaches a vertex in layer 0 or has exhausted all possible paths without reaching a vertex in layer 0. Instead of maintaining discovery and finish times, the depth-first search just needs to keep track of the predecessor attributes <em>π</em> in the depth-first tree of each search. Upon reaching a vertex in layer 0, tracing back along the predecessors identifies an <em>M</em>-augmenting path. Each vertex is searched from only when it is first discovered in any search. If the search from a vertex <em>r</em> in layer <em>q</em> cannot find a path of undiscovered vertices to an undiscovered vertex in layer 0, then no <em>M</em>-augmenting path including <em>r</em> goes into the maximal set.</p>
<p><a href="chapter025.xhtml#Fig_25-3">Figure 25.3</a> shows the result of the third phase. The first depth-first search starts from vertex <em>r</em><sub>1</sub>. It identifies the <em>M</em>-augmenting path <span class="font1">〈</span>(<em>r</em><sub>1</sub>, <em>l</em><sub>3</sub>), (<em>l</em><sub>3</sub>, <em>r</em><sub>3</sub>), (<em>r</em><sub>3</sub>, <em>l</em><sub>1</sub>)<span class="font1">〉</span>, which is highlighted in orange, and discovers vertices <em>r</em><sub>1</sub>, <em>l</em><sub>3</sub>, <em>r</em><sub>3</sub>, and <em>l</em><sub>1</sub>. The next depth-first search starts from vertex <em>r</em><sub>4</sub>. This search first examines the edge (<em>r</em><sub>4</sub>, <em>l</em><sub>3</sub>), but because <em>l</em><sub>3</sub> was already discovered, it backtracks and examines edge (<em>r</em><sub>4</sub>, <em>l</em><sub>5</sub>). From there, it continues and identifies the <em>M</em>-augmenting path <span class="font1">〈</span>(<em>r</em><sub>4</sub>, <em>l</em><sub>5</sub>), (<em>l</em><sub>5</sub>, <em>r</em><sub>7</sub>), (<em>r</em><sub>7</sub>, <em>l</em><sub>6</sub>)<span class="font1">〉</span>, which is highlighted in yellow, and discovers vertices <em>r</em><sub>4</sub>, <em>l</em><sub>5</sub>, <em>r</em><sub>7</sub>, and <em>l</em><sub>6</sub>. The depth-first search from vertex <em>r</em><sub>6</sub> gets stuck at vertices <em>l</em><sub>3</sub> and <em>l</em><sub>5</sub>, which have already been discovered, and so this search fails to find a path of undiscovered vertices to a vertex in layer 0. There is no depth-first search from vertex <em>r</em><sub>5</sub> because it is matched, and depth-first searches start from unmatched vertices. Therefore, the maximal set of vertex-disjoint shortest <em>M</em>-augmenting paths found contains just the two <em>M</em>-augmenting paths (<span class="font1">〈</span><em>r</em><sub>1</sub>, <em>l</em><sub>3</sub>), (<em>l</em><sub>3</sub>, <em>r</em><sub>3</sub>), (<em>r</em><sub>3</sub>, <em>l</em><sub>1</sub>)<span class="font1">〉</span> and <span class="font1">〈</span>(<em>r</em><sub>4</sub>, <em>l</em><sub>5</sub>), (<em>l</em><sub>5</sub>, <em>r</em><sub>7</sub>), (<em>r</em><sub>7</sub>, <em>l</em><sub>6</sub>)<span class="font1">〉</span>.</p>
<p>You might have noticed that in this example, this maximal set of two vertex-disjoint shortest <em>M</em>-augmenting paths is not a maximum set. The graph contains three vertex-disjoint shortest <em>M</em>-augmenting paths: <span class="font1">〈</span>(<em>r</em><sub>1</sub>, <em>l</em><sub>2</sub>), (<em>l</em><sub>2</sub>, <em>r</em><sub>2</sub>), (<em>r</em><sub>2</sub>, <em>l</em><sub>1</sub>)<span class="font1">〉</span>, <span class="font1">〈</span>(<em>r</em><sub>4</sub>, <em>l</em><sub>3</sub>), (<em>l</em><sub>3</sub>, <em>r</em><sub>3</sub>), (<em>r</em><sub>3</sub>, <em>l</em><sub>4</sub>)<span class="font1">〉</span>, and <span class="font1">〈</span>(<em>r</em><sub>6</sub>, <em>l</em><sub>5</sub>), (<em>l</em><sub>5</sub>, <em>r</em><sub>7</sub>), (<em>r</em><sub>7</sub>, <em>l</em><sub>6</sub>)<span class="font1">〉</span>. No matter: the algorithm <a id="p712"/>requires the set of vertex-disjoint shortest <em>M</em>-augmenting paths found in line 3 of H<small>OPCROFT</small>-K<small>ARP</small> to be only maximal, not necessarily maximum.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_25-3"><img alt="art" src="images/Art_P796.jpg"/></p>
<p class="caption"><strong>Figure 25.3</strong> The transpose <em>H</em><sup>T</sup> of the dag <em>H</em> created in the third phase. The first depth-first search, starting from vertex <em>r</em><sub>1</sub>, identifies the <em>M</em>-augmenting path <span class="font1">〈</span>(<em>r</em><sub>1</sub>, <em>l</em><sub>3</sub>), (<em>l</em><sub>3</sub>, <em>r</em><sub>3</sub>), (<em>r</em><sub>3</sub>, <em>l</em><sub>1</sub>)<span class="font1">〉</span> highlighted in orange, and it discovers vertices <em>r</em><sub>1</sub>, <em>l</em><sub>3</sub>, <em>r</em><sub>3</sub>, <em>l</em><sub>1</sub>. The second depth-first search, starting from vertex <em>r</em><sub>4</sub>, identifies the <em>M</em>-augmenting path <span class="font1">〈</span>(<em>r</em><sub>4</sub>, <em>l</em><sub>5</sub>), (<em>l</em><sub>5</sub>, <em>r</em><sub>7</sub>), (<em>r</em><sub>7</sub>, <em>l</em><sub>6</sub>)<span class="font1">〉</span> highlighted in yellow, discovering vertices <em>r</em><sub>4</sub>, <em>l</em><sub>5</sub>, <em>r</em><sub>7</sub>, <em>l</em><sub>6</sub>.</p>
</div>
<p>It remains to show that all three phases of line 3 take <em>O</em>(<em>E</em>) time. We assume that in the original bipartite graph <em>G</em>, each vertex has at least one incident edge so that |<em>V</em>| = <em>O</em>(<em>E</em>), which in turn implies that |<em>V</em>| + |<em>E</em>| = <em>O</em>(<em>E</em>). The first phase creates the directed graph <em>G</em><sub><em>M</em></sub> by simply directing each edge of <em>G</em>, so that |<em>V</em><sub><em>M</em></sub>| = |<em>V</em>| and |<em>E</em><sub><em>M</em></sub> = |<em>E</em>|. The second phase performs a breadth-first search on <em>G</em><sub><em>M</em></sub>, taking <em>O</em>(<em>V</em><sub><em>M</em></sub> + <em>E</em><sub><em>M</em></sub>) = <em>O</em>(<em>E</em><sub><em>M</em></sub>) = <em>O</em>(<em>E</em>) time. In fact, it can stop once the first distance in the queue within the breadth-first search exceeds the shortest distance <em>q</em> to an unmatched vertex in <em>R</em>. The dag <em>H</em> has |<em>V</em><sub><em>H</em></sub>| ≤ |<em>V</em><sub><em>M</em></sub>| and |<em>E</em><sub><em>H</em></sub>| ≤ |<em>E</em><sub><em>M</em></sub>|, so that it takes <em>O</em>(<em>V</em><sub><em>H</em></sub> + <em>E</em><sub><em>H</em></sub>) = <em>O</em>(<em>E</em>) time to construct. Finally, the third phase performs depth-first searches from the unmatched vertices in layer <em>q</em>. Once a vertex is discovered, it is not searched from again, and so the analysis of depth-first search from <a href="chapter020.xhtml#Sec_20.3">Section 20.3</a> applies here: <em>O</em>(<em>V</em><sub><em>H</em></sub> + <em>E</em><sub><em>H</em></sub>) = <em>O</em>(<em>E</em>). Hence, all three phases take just <em>O</em>(<em>E</em>) time.</p>
<p>Once the maximal set of vertex-disjoint shortest <em>M</em>-augmenting paths have been found in line 3, updating the matching in line 4 takes <em>O</em>(<em>E</em>) time, as it is just a matter of going through the edges of the <em>M</em>-augmenting paths and adding edges to and removing edges from the matching <em>M</em>. Thus, each iteration of the <strong>repeat</strong> loop of lines 2–5 can run in <em>O</em>(<em>E</em>) time.</p>
<a id="p713"/>
<p>It remains to show that the <strong>repeat</strong> loop iterates <img alt="art" src="images/Art_P797.jpg"/> times. We start with the following lemma, which shows that after each iteration of the <strong>repeat</strong> loop, the length of an augmenting path increases.</p>
<p class="lem"><strong><em>Lemma 25.5</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>) be an undirected bipartite graph with matching <em>M</em>, and let <em>q</em> be the length of a shortest <em>M</em>-augmenting path. Let <span class="script">P</span> = {<em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>, … , <em>P</em><sub><em>k</em></sub>} be a maximal set of vertex-disjoint <em>M</em>-augmenting paths of length <em>q</em>. Let <em>M</em>′ = <em>M</em> ⊕ (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>k</em></sub>), and suppose that <em>P</em> is a shortest <em>M</em>′-augmenting path. Then <em>P</em> has more than <em>q</em> edges.</p>
<p class="prof"><strong><em>Proof</em></strong>   We consider separately the cases in which <em>P</em> is vertex-disjoint from the augmenting paths in <span class="script">P</span> and in which it is not vertex-disjoint.</p>
<p>First, assume that <em>P</em> is vertex-disjoint from the augmenting paths in <span class="script">P</span>. Then, <em>P</em> contains edges that are in <em>M</em> but are not in any of <em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>, … , <em>P</em><sub><em>k</em></sub>, so that <em>P</em> is also an <em>M</em>-augmenting path. Since <em>P</em> is disjoint from <em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>, … , <em>P</em><sub><em>k</em></sub> but is also an <em>M</em>-augmenting path, and since <span class="script">P</span> is a maximal set of shortest <em>M</em>-augmenting paths, <em>P</em> must be longer than any of the augmenting paths in <span class="script">P</span>, each of which has length <em>q</em>. Therefore, <em>P</em> has more than <em>q</em> edges.</p>
<p>Now, assume that <em>P</em> visits at least one vertex from the <em>M</em>-augmenting paths in <span class="script">P</span>. By Corollary 25.2, <em>M</em> ′ is a matching in <em>G</em> with |<em>M</em>′| = |<em>M</em>| + <em>k</em>. Since <em>P</em> is an <em>M</em>′-augmenting path, by Lemma 25.1, <em>M</em>′ ⊕ <em>P</em> is a matching with |<em>M</em>′ ⊕ <em>P</em>| = |<em>M</em>′| + 1 = |<em>M</em>| + <em>k</em> + 1. Now let <em>A</em> = <em>M</em> ⊕ <em>M</em>′ ⊕ <em>P</em>. We claim that <em>A</em> = (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>k</em></sub>) ⊕ <em>P</em>:</p>
<table class="table2b">
<tr>
<td class="td2"><em>A</em></td>
<td class="td2">=</td>
<td class="td2"><em>M</em> ⊕ <em>M</em>′ ⊕ <em>P</em></td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>M</em> ⊕ (M ⊕ (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>k</em></sub>)) ⊕ <em>P</em></td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">(<em>M</em> ⊕ <em>M</em>) ⊕ (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>k</em></sub>) ⊕ <em>P</em></td>
<td class="td2">(associativity of ⊕)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">Ø ⊕ (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>k</em></sub>) ⊕ <em>P</em></td>
<td class="td2">(<em>X</em> ⊕ <em>X</em> = Ø for all <em>X</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">(<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>k</em></sub>) ⊕ <em>P</em></td>
<td class="td2">(Ø ⊕ <em>X</em> = <em>X</em> for all <em>X</em>).</td>
</tr>
</table>
<p class="noindent">Lemma 25.3 with <em>M</em>* = <em>M</em>′ ⊕ <em>P</em> gives that <em>A</em> contains at least |<em>M</em>′ ⊕ <em>P</em>| − |<em>M</em>| = <em>k</em> + 1 vertex-disjoint <em>M</em>-augmenting paths. Since each such <em>M</em>-augmenting path has at least <em>q</em> edges, we have |<em>A</em>| ≥ (<em>k</em> + 1)<em>q</em> = <em>kq</em> + <em>q</em>.</p>
<p>Now we claim that <em>P</em> shares at least one edge with some <em>M</em>-augmenting path in <span class="script">P</span>. Under the matching <em>M</em>′, every vertex in each <em>M</em>-augmenting path in <span class="script">P</span> is matched. (Only the first and last vertex in each <em>M</em>-augmenting path <em>P</em><sub><em>i</em></sub> is unmatched under <em>M</em>, and under <em>M</em> ⊕ <em>P</em><sub><em>i</em></sub>, all vertices in <em>P</em><sub><em>i</em></sub> are matched. Because the <em>M</em>-augmenting paths in <span class="script">P</span> are vertex-disjoint, no other path in <span class="script">P</span> can affect whether the vertices in <em>P</em><sub><em>i</em></sub> are matched. That is, the vertices in <em>P</em><sub><em>i</em></sub> are matched under (<em>M</em> ⊕ <em>P</em><sub><em>i</em></sub>) ⊕ <em>P<sub>j</sub></em> if and only if they are matched under <em>M</em> ⊕ <em>P</em><sub><em>i</em></sub>, for any other <a id="p714"/>path <em>P</em><sub><em>j</em></sub> ∈ <span class="script">P</span>.) Suppose that <em>P</em> shares a vertex <em>v</em> with some path <em>P</em><sub><em>i</em></sub> ∈ <span class="script">P</span>. Vertex <em>v</em> cannot be an endpoint of <em>P</em>, because the endpoints of <em>P</em> are unmatched under <em>M</em>′. Therefore, <em>v</em> has an incident edge in <em>P</em> that belongs to <em>M</em>′. Since any vertex has at most one incident edge in a matching, this edge must also belong to <em>P</em><sub><em>i</em></sub>, thus proving the claim.</p>
<p>Because <em>A</em> = (<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>k</em></sub>) ⊕ <em>P</em> and <em>P</em> shares at least one edge with some <em>P</em><sub><em>i</em></sub> ∈ <span class="script">P</span>, we have that |<em>A</em>| &lt; |<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P</em><sub><em>k</em></sub>| + |<em>P</em>|. Thus, we have</p>
<table class="table2b">
<tr>
<td class="td2"><em>kq</em> + <em>q</em></td>
<td class="td2">≤</td>
<td class="td2">|<em>A</em>|</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">&lt;</td>
<td class="td2">|<em>P</em><sub>1</sub> ∪ <em>P</em><sub>2</sub> ∪ <span class="font1">⋯</span> ∪ <em>P<sub>k</sub></em>| + |<em>P</em>|</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>kq</em> + |<em>P</em>|,</td>
</tr>
</table>
<p class="noindent">so that <em>q</em> &lt; |<em>P</em>|. We conclude that <em>P</em> contains more than <em>q</em> edges.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The next lemma bounds the size of a maximum matching, based on the length of a shortest augmenting path.</p>
<p class="lem"><strong><em>Lemma 25.6</em></strong></p>
<p class="noindent">Let <em>M</em> be a matching in graph <em>G</em> = (<em>V</em>, <em>E</em>), and let a shortest <em>M</em>-augmenting path in <em>G</em> contain <em>q</em> edges. Then the size of a maximum matching in <em>G</em> is at most |<em>M</em>| + |<em>V</em>| / (<em>q</em> + 1).</p>
<p class="prof"><strong><em>Proof</em></strong>   Let <em>M</em>* be a maximum matching in <em>G</em>. By Lemma 25.3, <em>G</em> contains at least |<em>M</em>*| − |<em>M</em>| vertex-disjoint <em>M</em>-augmenting paths. Each of these paths contains at least <em>q</em> edges, and hence at least <em>q</em> + 1 vertices. Because these paths are vertex-disjoint, we have (|<em>M</em>*|−|<em>M</em>|)(<em>q</em>+1) ≤ |<em>V</em>|, so that |<em>M</em>*| ≤ |<em>M</em>| + |<em>V</em>|/(<em>q</em>+1).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The final lemma bounds the number of iterations of the <strong>repeat</strong> loop of lines 2–5.</p>
<p class="lem"><strong><em>Lemma 25.7</em></strong></p>
<p class="noindent">When the H<small>OPCROFT</small>-K<small>ARP</small> procedure runs on an undirected bipartite graph <em>G</em> = (<em>V</em>, <em>E</em>), the <strong>repeat</strong> loop of lines 2–5 iterates <img alt="art" src="images/Art_P798.jpg"/> times.</p>
<p class="prof"><strong><em>Proof</em></strong>   By Lemma 25.5, the length <em>q</em> of the shortest <em>M</em>-augmenting paths found in line 3 increases from iteration to iteration. After <img alt="art" src="images/Art_P799.jpg"/> iterations, therefore, we must have <img alt="art" src="images/Art_P800.jpg"/>. Consider the situation after the first time line 4 executes with <em>M</em>-augmenting paths whose length is at least <img alt="art" src="images/Art_P801.jpg"/>. Since the size of a matching increases by at least one edge per iteration, Lemma 25.6 implies that the number of additional iterations before achieving a maximum matching is at most</p>
<p class="eql"><img alt="art" src="images/Art_P802.jpg"/></p>
<a id="p715"/>
<p class="noindent">Hence, the total number of loop iterations is less than <img alt="art" src="images/Art_P803.jpg"/>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Thus, we have the following bound on the running time of the H<small>OPCROFT</small>-K<small>ARP</small> procedure.</p>
<p class="theo"><strong><em>Theorem 25.8</em></strong></p>
<p class="noindent">The procedure H<small>OPCROFT</small>-K<small>ARP</small> runs in <img alt="art" src="images/Art_P804.jpg"/> time on an undirected bipartite graph <em>G</em> = (<em>V</em>, <em>E</em>).</p>
<p class="prof"><strong><em>Proof</em></strong>   By Lemma 25.7 the <strong>repeat</strong> loop iterates <img alt="art" src="images/Art_P805.jpg"/> times, and we have seen how to implement each iteration in <em>O</em>(<em>E</em>) time.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>25.1-1</em></strong></p>
<p class="noindent">Use the Hopcroft-Karp algorithm to find a maximum matching for the graph in <a href="chapter025.xhtml#Fig_25-1">Figure 25.1</a>.</p>
<p class="level3"><strong><em>25.1-2</em></strong></p>
<p class="noindent">How are <em>M</em>-augmenting paths and augmenting paths in flow networks similar? How do they differ?</p>
<p class="level3"><strong><em>25.1-3</em></strong></p>
<p class="noindent">What is the advantage of searching in the transpose <em>H</em><sup>T</sup> from unmatched vertices in layer <em>q</em> (the first layer that contains an unmatched vertex in <em>R</em>) to layer 0 versus searching in the dag <em>H</em> from layer 0 to layer <em>q</em>?</p>
<p class="level3"><strong><em>25.1-4</em></strong></p>
<p class="noindent">Show how to bound the number of iterations of the the <strong>repeat</strong> loop of lines 2–5 of H<small>OPCROFT</small>-K<small>ARP</small> by <img alt="art" src="images/Art_P806.jpg"/>.</p>
<p class="level3"><span class="font1">★</span> <strong><em>25.1-5</em></strong></p>
<p class="noindent">A <strong><em><span class="blue">perfect matching</span></em></strong> is a matching under which every vertex is matched. Let <em>G</em> = (<em>V</em>, <em>E</em>) be an undirected bipartite graph with vertex partition <em>V</em> = <em>L</em> ∪ <em>R</em>, where |<em>L</em>| = |<em>R</em>|. For any <em>X</em> ⊆ <em>V</em>, define the <strong><em><span class="blue">neighborhood</span></em></strong> of <em>X</em> as</p>
<p class="eql"><em>N</em>(<em>X</em>) = {<em>y</em> ∈ <em>V</em> : (<em>x</em>, <em>y</em>) ∈ <em>E</em> for some <em>x</em> ∈ <em>X</em>},</p>
<p class="noindent">that is, the set of vertices adjacent to some member of <em>X</em>. Prove <strong><em><span class="blue">Hall’s theorem</span></em></strong>: there exists a perfect matching in <em>G</em> if and only if |<em>A</em>| ≤ |<em>N</em>(<em>A</em>)| for every subset <em>A</em> ⊆ <em>L</em>.</p>
<a id="p716"/>
<p class="level3"><strong><em>25.1-6</em></strong></p>
<p class="noindent">In a <strong><em><span class="blue">d-regular</span></em></strong> graph, every vertex has degree <em>d</em>. If <em>G</em> = (<em>V</em>, <em>E</em>) is bipartite with vertex partition <em>V</em> = <em>L</em> ∪ <em>R</em> and also <em>d</em>-regular, then |<em>L</em>| = |<em>R</em>|. Use Hall’s theorem (see Exercise 25.1-5) to prove that every <em>d</em>-regular bipartite graph contains a perfect matching. Then use that result to prove that every <em>d</em>-regular bipartite graph contains <em>d</em> disjoint perfect matchings.</p>
</section>
<p class="line1"/>
<section title="25.2 The stable-marriage problem">
<a id="Sec_25.2"/>
<p class="level1" id="h1-147"><a href="toc.xhtml#Rh1-147"><strong>25.2    The stable-marriage problem</strong></a></p>
<p class="noindent">In <a href="chapter025.xhtml#Sec_25.1">Section 25.1</a>, the goal was to find a maximum matching in an undirected bipartite graph. If you know that the graph <em>G</em> = (<em>V</em>, <em>E</em>) with vertex partition <em>V</em> = <em>L</em> ∪ <em>R</em> is a <strong><em><span class="blue">complete bipartite graph</span></em></strong><sup><a epub:type="footnote" href="#footnote_1" id="footnote_ref_1">1</a></sup>—containing an edge from every vertex in <em>L</em> to every vertex in <em>R</em>—then you can find a maximum matching by a simple greedy algorithm.</p>
<p>When a graph can have several matchings, you might want to decide which matchings are most desirable. In <a href="chapter025.xhtml#Sec_25.3">Section 25.3</a>, we’ll add weights to the edges and find a matching of maximum weight. In this section, we will instead add some information to each vertex in a complete bipartite graph: a ranking of the vertices in the other side. That is, each vertex in <em>L</em> has an ordered list of all the vertices in <em>R</em>, and vice-versa. To keep things simple, let’s assume that <em>L</em> and <em>R</em> each contain <em>n</em> vertices. The goal here is to match each vertex in <em>L</em> with a vertex in <em>R</em> in a “stable” way.</p>
<p>This problem derives its name, the <strong><em><span class="blue">stable-marriage problem</span></em></strong>, from the notion of heterosexual marriage, viewing <em>L</em> as a set of women and <em>R</em> as a set of men.<sup><a epub:type="footnote" href="#footnote_2" id="footnote_ref_2">2</a></sup> Each woman ranks all the men in terms of desirability, and each man does the same with all the women. The goal is to pair up women and men (a matching) so that if a woman and a man are not matched to each other, then at least one of them prefers their assigned partner.</p>
<p>If a woman and a man are not matched to each other but each prefers the other over their assigned partner, they form a <strong><em><span class="blue">blocking pair</span></em></strong>. A blocking pair has incentive to opt out of the assigned pairing and get together on their own. If that were to occur, then this pair would block the matching from being “stable.” A <strong><em><span class="blue">stable matching</span></em></strong>, <a id="p717"/>therefore, is a matching that has no blocking pair. If there is a blocking pair, then the matching is <strong><em><span class="blue">unstable</span></em></strong>.</p>
<p>Let’s look at an example with four women—Wanda, Emma, Lacey, and Karen—and four men—Oscar, Davis, Brent, and Hank—having the following preferences:</p>
<table class="table2b1">
<tr>
<td class="td1">Wanda:</td>
<td class="td1">Brent, Hank, Oscar, Davis</td>
</tr>
<tr>
<td class="td1">Emma:</td>
<td class="td1">Davis, Hank, Oscar, Brent</td>
</tr>
<tr>
<td class="td1">Lacey:</td>
<td class="td1">Brent, Davis, Hank, Oscar</td>
</tr>
<tr>
<td class="td1">Karen:</td>
<td class="td1">Brent, Hank, Davis, Oscar</td>
</tr>
<tr>
<td class="td1"><p class="ntop1">Oscar:</p></td>
<td class="td1"><p class="ntop1">Wanda, Karen, Lacey, Emma</p></td>
</tr>
<tr>
<td class="td1">Davis:</td>
<td class="td1">Wanda, Lacey, Karen, Emma</td>
</tr>
<tr>
<td class="td1">Brent:</td>
<td class="td1">Lacey, Karen, Wanda, Emma</td>
</tr>
<tr>
<td class="td1">Hank:</td>
<td class="td1">Lacey, Wanda, Emma, Karen</td>
</tr>
</table>
<p class="noindent">A stable matching comprises the following pairs:</p>
<table class="table2b1">
<tr>
<td class="td1"><p class="noindent">Lacey and Brent</p>
<p class="noindent">Wanda and Hank</p>
<p class="noindent">Karen and Davis</p>
<p class="noindent">Emma and Oscar</p></td>
</tr>
</table>
<p class="noindent">You can verify that this matching has no blocking pair. For example, even though Karen prefers Brent and Hank to her partner Davis, Brent prefers his partner Lacey to Karen, and Hank prefers his partner Wanda to Karen, so that neither Karen and Brent nor Karen and Hank form a blocking pair. In fact, this stable matching is unique. Suppose instead that the last two pairs were</p>
<table class="table2b1">
<tr>
<td class="td1"><p class="noindent">Emma and Davis</p>
<p class="noindent">Karen and Oscar</p></td>
</tr>
</table>
<p class="noindent">Then Karen and Davis would be a blocking pair, because they were not paired together, Karen prefers Davis to Oscar, and Davis prefers Karen to Emma. Therefore, this matching is not stable.</p>
<p>Stable matchings need not be unique. For example, suppose that there are three women—Monica, Phoebe, and Rachel—and three men—Chandler, Joey, and Ross—with these preferences:</p>
<table class="table2b1">
<tr>
<td class="td1">Monica:</td>
<td class="td1">Chandler, Joey, Ross</td>
</tr>
<tr>
<td class="td1">Phoebe:</td>
<td class="td1">Joey, Ross, Chandler</td>
</tr>
<tr>
<td class="td1">Rachel:</td>
<td class="td1">Ross, Chandler, Joey</td>
</tr>
<tr>
<td class="td1"><p class="ntop1">Chandler: </p></td>
<td class="td1"><p class="ntop1">Phoebe, Rachel, Monica</p></td>
</tr>
<tr>
<td class="td1">Joey:</td>
<td class="td1">Rachel, Monica, Phoebe</td>
</tr>
<tr>
<td class="td1">Ross:</td>
<td class="td1">Monica, Phoebe, Rachel</td>
</tr>
</table>
<a id="p718"/>
<p class="noindent">In this case, there are three stable matchings:</p>
<table class="table2b1">
<tr>
<td class="td1a">Matching 1<hr/></td>
<td class="td1a">Matching 2<hr/></td>
<td class="td1a">Matching 3<hr/></td>
</tr>
<tr>
<td class="td1a">Monica and Chandler</td>
<td class="td1a">Phoebe and Chandler</td>
<td class="td1a">Rachel and Chandler</td>
</tr>
<tr>
<td class="td1a">Phoebe and Joey</td>
<td class="td1a">Rachel and Joey</td>
<td class="td1a">Monica and Joey</td>
</tr>
<tr>
<td class="td1a">Rachel and Ross</td>
<td class="td1a">Monica and Ross</td>
<td class="td1a">Phoebe and Ross</td>
</tr>
</table>
<p class="noindent">In matching 1, all women get their first choice and all men get their last choice. Matching 2 is the opposite, with all men getting their first choice and all women getting their last choice. When all the women or all the men get their first choice, there plainly cannot be a blocking pair. In matching 3, everyone gets their second choice. You can verify that there are no blocking pairs.</p>
<p>You might wonder whether it is always possible to come up with a stable matching no matter what rankings each participant provides. The answer is yes. (Exercise 25.2-3 asks you to show that even in the scenario of the National Resident Matching Program, where each hospital takes on multiple students, it is always possible to devise a stable assignment.) A simple algorithm known as the Gale-Shapley algorithm always finds a stable matching. The algorithm has two variants, which mirror each other: “woman-oriented” and “man-oriented.” Let’s examine the woman-oriented version. Each participant is either “free” or “engaged.” Everyone starts out free. Engagements occur when a free woman proposes to a man. When a man is first proposed to, he goes from free to engaged, and he always stays engaged, though not necessarily to the same woman. If an engaged man receives a proposal from a woman whom he prefers to the woman he’s currently engaged to, that engagement is broken, the woman to whom he had been engaged becomes free, and the man and the woman whom he prefers become engaged. Each woman proposes to the men in her preference list, in order, until the last time she becomes engaged. When a woman is engaged, she temporarily stops proposing, but if she becomes free again, she continues down her list. Once everyone is engaged, the algorithm terminates. The procedure G<small>ALE</small>-S<small>HAPLEY</small> on the next page makes this process more concrete. The procedure allows for some choice: any free woman may be selected in line 2. We’ll see that the procedure produces a stable matching regardless of the order in which line 2 chooses free women. For the man-oriented version, just reverse the roles of men and women in the procedure.</p>
<p>Let’s see how the G<small>ALE</small>-S<small>HAPLEY</small> procedure executes on the example with Wanda, Emma, Lacey, Karen, Oscar, Davis, Brent, and Hank. After everyone is initialized to free, here is one possible version of what can occur in successive iterations of the <strong>while</strong> loop of lines 2–9:</p>
<ol class="olnoindent" epub:type="list">
<li>Wanda proposes to Brent. Brent is free, so that Wanda and Brent become engaged and no longer free.<a id="p719"/></li>
<li class="litop">Emma proposes to Davis. Davis is free, so that Emma and Davis become engaged and no longer free.</li>
<li class="litop">Lacey proposes to Brent. Brent is engaged to Wanda, but he prefers Lacey. Brent breaks the engagement to Wanda, who becomes free. Lacey and Brent become engaged, with Lacey no longer free.</li>
<li class="litop">Karen proposes to Brent. Brent is engaged to Lacey, whom he prefers to Karen. Brent rejects Karen, who remains free.</li>
<li class="litop">Karen proposes to Hank. Hank is free, so that Karen and Hank become engaged and no longer free.</li>
<li class="litop">Wanda proposes to Hank. Hank is engaged to Karen, but he prefers Wanda. Hank breaks the engagement with Karen, who becomes free. Wanda and Hank become engaged, with Wanda no longer free.</li>
<li class="litop">Karen proposes to Davis. Davis is engaged to Emma, but he prefers Karen. Davis breaks the engagement to Emma, who becomes free. Karen and Davis become engaged, with Karen no longer free.</li>
<li class="litop">Emma proposes to Hank. Hank is engaged to Wanda, whom he prefers to Emma. Hank rejects Emma, who remains free.</li>
<li class="litop">Emma proposes to Oscar. Oscar is free, so that Emma and Oscar become engaged and no longer free.</li></ol>
<div class="pull-quote1">
<p class="box-heading">G<small>ALE</small>-S<small>HAPLEY</small> (<em>men</em>, <em>women</em>, <em>rankings</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><p class="noindent">assign each woman and man as free</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><p class="noindent"><strong>while</strong> some woman <em>w</em> is free</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><p class="p2">let <em>m</em> be the first man on <em>w</em>’s ranked list to whom she has not proposed</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>m</em> is free</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="p3"><em>w</em> and <em>m</em> become engaged to each other (and not free)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p2"><strong>elseif</strong> <em>m</em> ranks <em>w</em> higher than the woman <em>w</em>′ he is currently engaged to</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p3"><em>m</em> breaks the engagement to <em>w</em>′, who becomes free</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="p3"><em>w</em> and <em>m</em> become engaged to each other (and not free)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="p2"><strong>else</strong> <em>m</em> rejects <em>w</em>, with <em>w</em> remaining free</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="noindent"><strong>return</strong> the stable matching consisting of the engaged pairs</p></td>
</tr>
</table>
</div>
<p class="noindent">At this point, everyone is engaged and nobody is free, so the <strong>while</strong> loop terminates. The procedure returns the stable matching we saw earlier.</p>
<p>The following theorem shows that not only does G<small>ALE</small>-S<small>HAPLEY</small> terminate, but that it always returns a stable matching, thereby proving that a stable matching always exists.</p>
<a id="p720"/>
<p class="theo"><strong><em>Theorem 25.9</em></strong></p>
<p class="noindent">The procedure G<small>ALE</small>-S<small>HAPLEY</small> always terminates and returns a stable matching.</p>
<p class="prof"><strong><em>Proof</em></strong>   Let’s first show that the <strong>while</strong> loop of lines 2–9 always terminates, so that the procedure terminates. The proof is by contradiction. If the loop fails to terminate, it is because some woman remains free. In order for a woman to remain free, she must have proposed to all the men and been rejected by each one. In order for a man to reject a woman, he must be already engaged. Therefore, all the men are engaged. Once engaged, a man stays engaged (though not necessarily to the same woman). There are an equal number <em>n</em> of women and men, however, which means that every woman is engaged, leading to the contradiction that no women are free. We must also show that the <strong>while</strong> loop makes a bounded number of iterations. Since each of the <em>n</em> women goes through her ranking of the <em>n</em> men in order, possibly not reaching the end of her list, the total number of iterations is at most <em>n</em><sup>2</sup>. Therefore, the <strong>while</strong> loop always terminates, and the procedure returns a matching.</p>
<p>We need to show that there are no blocking pairs. We first observe that once a man <em>m</em> is engaged to a woman <em>w</em>, all subsequent actions for <em>m</em> occur in lines 6–8. Therefore, once a man is engaged, he stays engaged, and any time he breaks an engagement to a woman <em>w</em>, it’s for a woman whom he prefers to <em>w</em>. Suppose that a woman <em>w</em> is matched with a man <em>m</em>, but she prefers man <em>m</em>′. We’ll show that <em>w</em> and <em>m</em>′ is not a blocking pair, because <em>m</em>′ does not prefer <em>w</em> to his partner. Because <em>w</em> ranks <em>m</em>′ higher than <em>m</em>, she must have proposed to <em>m</em>′ before proposing to <em>m</em>, and <em>m</em>′ either rejected her proposal or accepted it and later broke the engagement. If <em>m</em>′ rejected the proposal from <em>w</em>, it is because he was already engaged to some woman he prefers to <em>w</em>. If <em>m</em>′ accepted and later broke the engagement, he was at some point engaged to <em>w</em> but later accepted a proposal from a woman he prefers to <em>w</em>. In either case, he ultimately ends up with a partner whom he prefers to <em>w</em>. We conclude that even though <em>w</em> might prefer <em>m</em>′ to her partner <em>m</em>, it is not also the case that <em>m</em>′ prefers <em>w</em> to his partner. Therefore, the procedure returns a matching containing no blocking pairs.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Exercise 25.2-1 asks you to provide the proof of the following corollary.</p>
<p class="cor"><strong><em>Corollary 25.10</em></strong></p>
<p class="noindent">Given preference rankings for <em>n</em> women and <em>n</em> men, the Gale-Shapley algorithm can be implemented to run in <em>O</em>(<em>n</em><sup>2</sup>) time.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Because line 2 can choose any free woman, you might wonder whether different choices can produce different stable matchings. The answer is no: as the following <a id="p721"/>theorem shows, every execution of the G<small>ALE</small>-S<small>HAPLEY</small> produces exactly the same result. Moreover, the stable matching returned is optimal for the women.</p>
<p class="theo"><strong><em>Theorem 25.11</em></strong></p>
<p class="noindent">Regardless of how women are chosen in line 2 of G<small>ALE</small>-S<small>HAPLEY</small>, the procedure always returns the same stable matching, and in this stable matching, each woman has the best partner possible in any stable matching.</p>
<p class="prof"><strong><em>Proof</em></strong>   The proof that each woman has the best partner possible in any stable matching is by contradiction. Suppose that the G<small>ALE</small>-S<small>HAPLEY</small> procedure returns a stable matching <em>M</em>, but that there is a different stable matching <em>M</em>′ in which some woman <em>w</em> prefers her partner <em>m</em>′ to the partner <em>m</em> she has in <em>M</em>. Because <em>w</em> ranks <em>m</em>′ higher than <em>m</em>, she must have proposed to <em>m</em>′ before proposing to <em>m</em>. Then there is a woman <em>w</em>′ whom <em>m</em>′ prefers to <em>w</em>, and <em>m</em>′ was already engaged to <em>w</em>′ when <em>w</em> proposed or <em>m</em>′ accepted the proposal from <em>w</em> and later broke the engagement in favor of <em>w</em>′. Either way, there is a moment when <em>m</em>′ decided against <em>w</em> in favor of <em>w</em>′. Now suppose, without loss of generality, that this moment was the first time that any man rejected a partner who belongs to some stable matching.</p>
<p>We claim that <em>w</em>′ cannot have a partner <em>m</em>″ in a stable matching whom she prefers to <em>m</em>′. If there were such a man <em>m</em>″, then in order for <em>w</em>′ to propose to <em>m</em>′, she would have proposed to <em>m</em>″ and been rejected at some point before proposing to <em>m</em>′. If <em>m</em>′ accepted the proposal from <em>w</em> and later broke it to accept <em>w</em>′, then since this was the first rejection in a stable matching, we get the contradiction that <em>m</em>″ could not have rejected <em>w</em>′ beforehand. If <em>m</em>″ was already engaged to <em>w</em>′ when <em>w</em> proposed, then again, <em>m</em>″ could not have rejected <em>w</em>′ beforehand, thus proving the claim.</p>
<p>Since <em>w</em>′ does not prefer anyone to <em>m</em>′ in a stable matching and <em>w</em>′ is not matched with <em>m</em>′ in <em>M</em>′ (because <em>m</em>′ is matched with <em>w</em> in <em>M</em>′), <em>w</em>′ prefers <em>m</em>′ to her partner in <em>M</em>′. Since <em>w</em>′ prefers <em>m</em>′ over her partner in <em>M</em>′ and <em>m</em>′ prefers <em>w</em>′ over his partner <em>w</em> in <em>M</em>′, the pair <em>w</em>′ and <em>m</em>′ is a blocking pair in <em>M</em>′. Because <em>M</em>′ has a blocking pair, it cannot be a stable matching, thereby contradicting the assumption that there exists some stable matching in which each woman has the best partner possible other than the matching <em>M</em> returned by G<small>ALE</small>-S<small>HAPLEY</small>.</p>
<p>We put no condition on the execution of the procedure, which means that all possible orders in which line 2 selects women result in the same stable matching being returned.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 25.12</em></strong></p>
<p class="noindent">There can be stable matchings that the G<small>ALE</small>-S<small>HAPLEY</small> procedure does not return.</p>
<p class="prof"><strong><em>Proof</em></strong>   Theorem 25.11 says that for a given set of rankings, G<small>ALE</small>-S<small>HAPLEY</small> returns just one matching, no matter how it chooses women in line 2. The earlier example <a id="p722"/>of three women and three men with three different stable matchings shows that there can be multiple stable matchings for a given set of rankings. A call of G<small>ALE</small>-S<small>HAPLEY</small> is capable of returning only one of these stable matchings.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Although the G<small>ALE</small>-S<small>HAPLEY</small> procedure gives the best possible outcome for the women, the following corollary shows that it also produces the worst possible outcome for the men.</p>
<p class="cor"><strong><em>Corollary 25.13</em></strong></p>
<p class="noindent">In the stable matching returned by the procedure G<small>ALE</small>-S<small>HAPLEY</small>, each man has the worst partner possible in any stable matching.</p>
<p class="prof"><strong><em>Proof</em></strong>   Let <em>M</em> be the matching returned by a call to G<small>ALE</small>-S<small>HAPLEY</small>. Suppose that there is another stable matching <em>M</em>′ and a man <em>m</em> who prefers his partner <em>w</em> in <em>M</em> to his partner <em>w</em>′ in <em>M</em>′. Let the partner of <em>w</em> in <em>M</em>′ be <em>m</em>′. By Theorem 25.11, <em>m</em> is the best partner that <em>w</em> can have in any stable matching, which means that <em>w</em> prefers <em>m</em> to <em>m</em>′. Since <em>m</em> prefers <em>w</em> to <em>w</em>′, the pair <em>w</em> and <em>m</em> is a blocking pair in <em>M</em>′, contradicting the assumption that <em>M</em>′ is a stable matching.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>25.2-1</em></strong></p>
<p class="noindent">Describe how to implement the Gale-Shapley algorithm so that it runs in <em>O</em>(<em>n</em><sup>2</sup>) time.</p>
<p class="level3"><strong><em>25.2-2</em></strong></p>
<p class="noindent">Is it possible to have an unstable matching with just two women and two men? If so, provide and justify an example. If not, argue why not.</p>
<p class="level3"><strong><em>25.2-3</em></strong></p>
<p class="noindent">The National Resident Matching Program differs from the scenario for the stable-marriage problem set out in this section in two ways. First, a hospital may be matched with more than one student, so that hospital <em>h</em> takes <em>r</em><sub><em>h</em></sub> ≥ 1 students. Second, the number of students might not equal the number of hospitals. Describe how to modify the Gale-Shapley algorithm to fit the requirements of the National Resident Matching Program.</p>
<p class="level3"><strong><em>25.2-4</em></strong></p>
<p class="noindent">Prove the following property, which is known as <strong><em><span class="blue">weak Pareto optimality</span></em></strong>:</p>
<div class="pull-quote">
<p class="pq-noindent">Let <em>M</em> be the stable matching produced by the G<small>ALE</small>-S<small>HAPLEY</small> procedure, with women proposing to men. Then, for a given instance of the stable-marriage problem there is no matching—stable or unstable—such that every <a id="p723"/>woman has a partner whom she prefers to her partner in the stable matching <em>M</em>.</p>
</div>
<p class="level3"><strong><em>25.2-5</em></strong></p>
<p class="noindent">The <strong><em><span class="blue">stable-roommates problem</span></em></strong> is similar to the stable-marriage problem, except that the graph is a complete graph, not bipartite, with an even number of vertices. Each vertex represents a person, and each person ranks all the other people. The definitions of blocking pairs and stable matching extend in the natural way: a blocking pair comprises two people who both prefer each other to their current partner, and a matching is stable if there are no blocking pairs. For example, consider four people—Wendy, Xenia, Yolanda, and Zelda—with the following preference lists:</p>
<table class="table2b1">
<tr>
<td class="td1">Wendy:</td>
<td class="td1">Xenia, Yolanda, Zelda</td>
</tr>
<tr>
<td class="td1">Xenia:</td>
<td class="td1">Wendy, Zelda, Yolanda</td>
</tr>
<tr>
<td class="td1">Yolanda: </td>
<td class="td1">Wendy, Zelda, Xenia</td>
</tr>
<tr>
<td class="td1">Zelda:</td>
<td class="td1">Xenia, Yolanda, Wendy</td>
</tr>
</table>
<p class="noindent">You can verify that the following matching is stable:</p>
<table class="table2a1">
<tr>
<td class="td1"><p class="noindent">Wendy and Xenia</p></td>
</tr>
<tr>
<td class="td1"><p class="noindent">Yolanda and Zelda</p></td>
</tr>
</table>
<p class="noindent">Unlike the stable-marriage problem, the stable-roommates problem can have inputs for which no stable matching exists. Find such an input and explain why no stable matching exists.</p>
</section>
<p class="line1"/>
<section title="25.3 The Hungarian algorithm for the assignment problem">
<a id="Sec_25.3"/>
<p class="level1" id="h1-148"><a href="toc.xhtml#Rh1-148"><strong>25.3    The Hungarian algorithm for the assignment problem</strong></a></p>
<p class="noindent">Let us once again add some information to a complete bipartite graph <em>G</em> = (<em>V</em>, <em>E</em>), where <em>V</em> = <em>L</em> ∪ <em>R</em>. This time, instead of having the vertices of each side rank the vertices on the other side, we assign a weight to each edge. Again, let’s assume that the vertex sets <em>L</em> and <em>R</em> each contain <em>n</em> vertices, so that the graph contains <em>n</em><sup>2</sup> edges. For <em>l</em> ∈ <em>L</em> and <em>r</em> ∈ <em>R</em>, denote the weight of edge (<em>l</em>, <em>r</em>) by <em>w</em>(<em>l</em>, <em>r</em>), which represents the utility gained by matching vertex <em>l</em> with vertex <em>r</em>.</p>
<p>The goal is to find a perfect matching <em>M</em>* (see Exercises 25.1-5 and 25.1-6) whose edges have the maximum total weight over all perfect matchings. That is, letting <em>w</em>(<em>M</em>) = ∑<sub>(<em>l</em>,<em>r</em>)∈<em>M</em></sub> <em>w</em>(<em>l</em>, <em>r</em>) denote the total weight of the edges in matching <em>M</em>, we want to find a perfect matching <em>M</em>* such that</p>
<p class="eql"><em>w</em>(<em>M</em>*) = max {<em>w</em>(<em>M</em>) : <em>M</em> is a perfect matching}.</p>
<a id="p724"/>
<p class="noindent">We call finding such a maximum-weight perfect matching the <strong><em><span class="blue">assignment problem</span></em></strong>. A solution to the assignment problem is a perfect matching that maximizes the total utility. Like the stable-marriage problem, the assignment problem finds a matching that is “good,” but with a different definition of good: maximizing total value rather than achieving stability.</p>
<p>Although you could enumerate all n! perfect matchings to solve the assignment problem, an algorithm known as the <strong><em><span class="blue">Hungarian algorithm</span></em></strong> solves it much faster. This section will prove an <em>O</em>(<em>n</em><sup>4</sup>) time bound, and Problem 25-2 asks you to refine the algorithm to reduce the running time to <em>O</em>(<em>n</em><sup>3</sup>). Instead of working with the complete bipartite graph <em>G</em>, the Hungarian algorithm works with a subgraph of <em>G</em> called the “equality subgraph.” The equality subgraph, which is defined below, changes over time and has the beneficial property that any perfect matching in the equality subgraph is also an optimal solution to the assignment problem.</p>
<p>The equality subgraph depends on assigning an attribute <em>h</em> to each vertex. We call <em>h</em> the <strong><em><span class="blue">label</span></em></strong> of a vertex, and we say that <em>h</em> is a <strong><em><span class="blue">feasible vertex labeling</span></em></strong> of <em>G</em> if</p>
<p class="eql"><em>l</em>.<em>h</em> + <em>r</em>.<em>h</em> ≥ <em>w</em>(<em>l</em>, <em>r</em>) for all <em>l</em> ∈ <em>L</em> and <em>r</em> ∈ <em>R</em>.</p>
<p class="noindent">A feasible vertex labeling always exists, such as the <strong><em><span class="blue">default vertex labeling</span></em></strong> given by</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P807.jpg"/></p>
<p class="noindent">Given a feasible vertex labeling <em>h</em>, the <strong><em><span class="blue">equality subgraph</span></em></strong> <em>G</em><sub><em>h</em></sub> = (<em>V</em>, <em>E</em><sub><em>h</em></sub>) of <em>G</em> consists of the same vertices as <em>G</em> and the subset of edges</p>
<p class="eql"><em>E</em><sub><em>h</em></sub> = {(<em>l</em>, <em>r</em>) ∈ <em>E</em> : <em>l</em>.<em>h</em> + <em>r</em>.<em>h</em> = <em>w</em>(<em>l</em>, <em>r</em>)}.</p>
<p>The following theorem ties together a perfect matching in an equality subgraph and an optimal solution to the assignment problem.</p>
<p class="theo"><strong><em>Theorem 25.14</em></strong></p>
<p class="noindent">Let <em>G</em> = (<em>V</em>, <em>E</em>), where <em>V</em> = <em>L</em> ∪ <em>R</em>, be a complete bipartite graph where each edge (<em>l</em>, <em>r</em>) ∈ <em>E</em> has weight <em>w</em>(<em>l</em>, <em>r</em>). Let <em>h</em> be a feasible vertex labeling of <em>G</em> and <em>G</em><sub><em>h</em></sub> be the equality subgraph of <em>G</em>. If <em>G</em><sub><em>h</em></sub> contains a perfect matching <em>M</em>*, then <em>M</em>* is an optimal solution to the assignment problem on <em>G</em>.</p>
<p class="prof"><strong><em>Proof</em></strong>   If <em>G</em><sub><em>h</em></sub> contains a perfect matching <em>M</em>*, then because <em>G</em><sub><em>h</em></sub> and <em>G</em> have the same sets of vertices, <em>M</em>* is also a perfect matching in <em>G</em>. Because each edge of <em>M</em>* belongs to <em>G</em><sub><em>h</em></sub> and each vertex has exactly one incident edge from any perfect matching, we have</p>
<a id="p725"/>
<p class="eql"><img alt="art" src="images/Art_P808.jpg"/></p>
<p class="noindent">Letting <em>M</em> be any perfect matching in <em>G</em>, we have</p>
<p class="eql"><img alt="art" src="images/Art_P809.jpg"/></p>
<p class="noindent">Thus, we have</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P810.jpg"/></p>
<p class="noindent">so that <em>M</em>* is a maximum-weight perfect matching in <em>G</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The goal now becomes finding a perfect matching in an equality subgraph. Which equality subgraph? It does not matter! We have free rein to not only choose an equality subgraph, but to change which equality subgraph we choose as we go along. We just need to find <em>some</em> perfect matching in <em>some</em> equality subgraph.</p>
<p>To understand the equality subgraph better, consider again the proof of Theorem 25.14 and, in the second half, let <em>M</em> be any matching. The proof is still valid, in particular, inequality (25.3): the weight of any matching is always at most the sum of the vertex labels. If we choose any set of vertex labels that define an equality subgraph, then a maximum-cardinality matching in this equality subgraph has total value at most the sum of the vertex labels. If the set of vertex labels is the “right” one, then it will have total value equal to <em>w</em>(<em>M</em>*), and a maximum-cardinality matching in the equality subgraph is also a maximum-weight perfect matching. The Hungarian algorithm repeatedly modifies the matching and the vertex labels in order to achieve this goal.</p>
<p>The Hungarian algorithm starts with any feasible vertex labeling <em>h</em> and any matching <em>M</em> in the equality subgraph <em>G</em><sub><em>h</em></sub>. It repeatedly finds an <em>M</em>-augmenting path <em>P</em> in <em>G</em><sub><em>h</em></sub> and, using Lemma 25.1, updates the matching to be <em>M</em> ⊕ <em>P</em>, thereby incrementing the size of the matching. As long as there is some equality subgraph that contains an <em>M</em>-augmenting path, the size of the matching can increase, until a perfect matching is achieved.</p>
<a id="p726"/>
<p>Four questions arise:</p>
<ol class="olnoindent" epub:type="list">
<li>What initial feasible vertex labeling should the algorithm start with? Answer: the default vertex labeling given by equations (25.1) and (25.2).</li>
<li class="litop">What initial matching in <em>G</em><sub><em>h</em></sub> should the algorithm start with? Short answer: any matching, even an empty matching, but a greedy maximal matching works well.</li>
<li class="litop">If an <em>M</em>-augmenting path exists in <em>G</em><sub><em>h</em></sub>, how to find it? Short answer: use a variant of breadth-first search similar to the second phase of the procedure used in the Hopcroft-Karp algorithm to find a maximal set of shortest <em>M</em>-augmenting paths.</li>
<li class="litop">What if the search for an <em>M</em>-augmenting path fails? Short answer: update the feasible vertex labeling to bring in at least one new edge.</li></ol>
<p>We’ll elaborate on the short answers using the example that starts in <a href="chapter025.xhtml#Fig_25-4">Figure 25.4</a>. Here, <em>L</em> = {<em>l</em><sub>1</sub>, <em>l</em><sub>2</sub>, … , <em>l</em><sub>7</sub>} and <em>R</em> = {<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, … , <em>r</em><sub>7</sub>}. The edge weights appear in the matrix shown in part (a), where the weight <em>w</em>(<em>l</em><sub><em>i</em></sub>, <em>r</em><sub><em>j</em></sub>) appears in row <em>i</em> and column <em>j</em>. The feasible vertex labels, given by the default vertex labeling, appear to the left of and above the matrix. Matrix entries in red indicate edges (<em>l</em><sub><em>i</em></sub>, <em>r</em><sub><em>j</em></sub>) for which <em>l</em><sub><em>i</em></sub>.<em>h</em> + <em>r</em><sub><em>j</em></sub>.<em>h</em> = <em>w</em>(<em>l</em><sub><em>i</em></sub>, r<sub><em>j</em></sub>), that is, edges in the equality subgraph <em>G</em><sub><em>h</em></sub> appearing in part (b) of the figure.</p>
<p class="level4"><strong>Greedy maximal bipartite matching</strong></p>
<p class="noindent">There are several ways to implement a greedy method to find a maximal bipartite matching. The procedure G<small>REEDY</small>-B<small>IPARTITE</small>-M<small>ATCHING</small> shows one. Edges in <a href="chapter025.xhtml#Fig_25-4">Figure 25.4(b)</a> highlighted in blue indicate the initial greedy maximal matching in <em>G</em><sub><em>h</em></sub>. Exercise 25.3-2 asks you to show that the G<small>REEDY</small>-B<small>IPARTITE</small>-M<small>ATCHING</small> procedure returns a matching that is at least half the size of a maximum matching.</p>
<div class="pull-quote1">
<p class="box-heading">G<small>REEDY</small>-B<small>IPARTITE</small>-M<small>ATCHING</small> (<em>G</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><em>M</em> = Ø</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>l</em> ∈ <em>L</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>l</em> has an unmatched neighbor in <em>R</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p3">choose any such unmatched neighbor <em>r</em> ∈ <em>R</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p3"><em>M</em> = <em>M</em> ∪ {(<em>l</em>, <em>r</em>)}</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>M</em></p></td>
</tr>
</table>
</div>
<a id="p727"/>
<div class="divimage">
<p class="fig-imga" id="Fig_25-4"><img alt="art" class="width100" src="images/Art_P811.jpg"/></p>
<p class="caption"><strong>Figure 25.4</strong> The start of the Hungarian algorithm. <strong>(a)</strong> The matrix of edge weights for a bipartite graph with <em>L</em> = {<em>l</em><sub>1</sub>, <em>l</em><sub>2</sub>, … , <em>l</em><sub>7</sub>}. The value in row <em>i</em> and column <em>j</em> indicates <em>w</em>(<em>l</em><sub><em>i</em></sub>, <em>r</em><sub><em>j</em></sub>). Feasible vertex labels appear above and next to the matrix. Red entries correspond to edges in the equality subgraph. <strong>(b)</strong> The equality subgraph <em>G</em><sub><em>h</em></sub>. Edges highlighted in blue belong to the initial greedy maximal matching <em>M</em>. Blue vertices are matched, and tan vertices are unmatched. <strong>(c)</strong> The directed equality subgraph <em>G</em><sub><em>M,h</em></sub> created from <em>G</em><sub><em>h</em></sub> by directing edges in <em>M</em> from <em>R</em> to <em>L</em> and all other edges from <em>L</em> to <em>R</em>.</p>
</div>
<p class="level4"><strong>Finding an <em>M</em>-augmenting path in <em>G<sub>h</sub></em></strong></p>
<p class="noindent">To find an <em>M</em>-augmenting path in the equality subgraph <em>G</em><sub><em>h</em></sub> with a matching <em>M</em>, the Hungarian algorithm first creates the <strong><em><span class="blue">directed equality subgraph</span></em></strong> <em>G</em><sub><em>M,h</em></sub> from <em>G</em><sub><em>h</em></sub>, just as the Hopcroft-Karp algorithm creates <em>G</em><sub><em>M</em></sub> from <em>G</em>. As in the Hopcroft-Karp algorithm, you can think of an <em>M</em>-augmenting path as starting from an unmatched vertex in <em>L</em>, ending at an unmatched vertex in <em>R</em>, taking unmatched edges from <em>L</em> to <em>R</em>, and taking matched edges from <em>R</em> to <em>L</em>. Thus, <em>G</em><sub><em>M,h</em></sub> = (<em>V</em>, <em>E</em><sub><em>M,h</em></sub>), where</p>
<table class="table2b">
<tr>
<td class="td1"><em>E</em><sub><em>M,h</em></sub></td>
<td class="td1">=</td>
<td class="td1">{(<em>l</em>, <em>r</em>) : <em>l</em> ∈ <em>L</em>, <em>r</em> ∈ <em>R</em>, and (<em>l</em>, <em>r</em>) ∈ <em>E</em><sub><em>h</em></sub> − <em>M</em> }</td>
<td class="td1">(edges from <em>L</em> to <em>R</em>)</td>
</tr>
<tr>
<td class="td1"/>
<td class="td1"/>
<td class="td1">∪ {(<em>r</em>, <em>l</em>) : <em>r</em> ∈ <em>R</em>, <em>l</em> ∈ <em>L</em>, and (<em>l</em>, <em>r</em>) ∈ <em>M</em> }</td>
<td class="td1">(edges from <em>R</em> to <em>L</em>).</td>
</tr>
</table>
<p class="noindent">Because an <em>M</em>-augmenting path in the directed equality subgraph <em>G</em><sub><em>M.h</em></sub> is also an <em>M</em>-augmenting path in the equality subgraph <em>G</em><sub><em>h</em></sub>, it suffices to find <em>M</em>-augmenting paths in <em>G</em><sub><em>M.h</em></sub>. <a href="chapter025.xhtml#Fig_25-4">Figure 25.4(c)</a> shows the directed equality subgraph <em>G</em><sub><em>M,h</em></sub> corresponding to the equality subgraph <em>G</em><sub><em>h</em></sub> and matching <em>M</em> from part (b) of the figure.</p>
<a id="p728"/>
<p>With the directed equality subgraph <em>G</em><sub><em>M,h</em></sub> in hand, the Hungarian algorithm searches for an <em>M</em>-augmenting path from any unmatched vertex in <em>L</em> to any unmatched vertex in <em>R</em>. Any exhaustive graph-search method suffices. Here, we’ll use breadth-first search, starting from all the unmatched vertices in <em>L</em> (just as the Hopcroft-Karp algorithm does when creating the dag <em>H</em>), but stopping upon first discovering some unmatched vertex in <em>R</em>. <a href="chapter025.xhtml#Fig_25-5">Figure 25.5</a> shows the idea. To start from all the unmatched vertices in <em>L</em>, initialize the first-in, first-out queue with all the unmatched vertices in <em>L</em>, rather than just one source vertex. Unlike the dag <em>H</em> in the Hopcroft-Karp algorithm, here each vertex needs just one predecessor, so that the breadth-first search creates a <strong><em><span class="blue">breadth-first forest</span></em></strong> <em>F</em> = (<em>V</em><sub><em>F</em></sub>, <em>E</em><sub><em>F</em></sub>). Each unmatched vertex in <em>L</em> is a root in <em>F</em>.</p>
<p>In <a href="chapter025.xhtml#Fig_25-5">Figure 25.5(g)</a>, the breadth-first search has found the <em>M</em>-augmenting path <span class="font1">〈</span>(<em>l</em><sub>4</sub>, <em>r</em><sub>2</sub>), (<em>r</em><sub>2</sub>, <em>l</em><sub>1</sub>), (<em>l</em><sub>1</sub>, <em>r</em><sub>3</sub>), (<em>r</em><sub>3</sub>, <em>l</em><sub>6</sub>), (<em>l</em><sub>6</sub>, <em>r</em><sub>5</sub>)<span class="font1">〉</span>. <a href="chapter025.xhtml#Fig_25-6">Figure 25.6(a)</a> shows the new matching created by taking the symmetric difference of the matching <em>M</em> in <a href="chapter025.xhtml#Fig_25-5">Figure 25.5(a)</a> with this <em>M</em>-augmenting path.</p>
<p class="level4"><strong>When the search for an <em>M</em>-augmenting path fails</strong></p>
<p class="noindent">Having updated the matching <em>M</em> from an <em>M</em>-augmenting path, the Hungarian algorithm updates the directed equality subgraph <em>G</em><sub><em>M,h</em></sub> according to the new matching and then starts a new breadth-first search from all the unmatched vertices in <em>L</em>. <a href="chapter025.xhtml#Fig_25-6">Figure 25.6</a> shows the start of this process, picking up from <a href="chapter025.xhtml#Fig_25-5">Figure 25.5</a>.</p>
<p>In <a href="chapter025.xhtml#Fig_25-6">Figure 25.6(d)</a>, the queue contains vertices <em>l</em><sub>4</sub> and <em>l</em><sub>3</sub>. Neither of these vertices has an edge that leaves it, however, so that once these vertices are removed from the queue, the queue becomes empty. The search terminates at this point, before discovering an unmatched vertex in <em>R</em> to yield an <em>M</em>-augmenting path. Whenever this situation occurs, the most recently discovered vertices must belong to <em>L</em>. Why? Whenever an unmatched vertex in <em>R</em> is discovered, the search has found an <em>M</em>-augmenting path, and when a matched vertex in <em>R</em> is discovered, it has an unvisited neighbor in <em>L</em>, which the search can then discover.</p>
<p>Recall that we have the freedom to work with any equality subgraph. We can change the directed equality subgraph “on the fly,” as long we do not counteract the work already done. The Hungarian algorithm updates the feasible vertex labeling <em>h</em> to fulfill the following criteria:</p>
<ol class="olnoindent" epub:type="list">
<li>No edge in the breadth-first forest <em>F</em> leaves the directed equality subgraph.</li>
<li class="litop">No edge in the matching <em>M</em> leaves the directed equality subgraph.</li>
<li class="litop">At least one edge (<em>l</em>, <em>r</em>), where <em>l</em> ∈ <em>L</em> ∩ <em>V</em><sub><em>F</em></sub> and <em>r</em> ∈ <em>R</em> − <em>V</em><sub><em>F</em></sub> goes into <em>E</em><sub><em>h</em></sub>, and hence into <em>E</em><sub><em>M,h</em></sub>. Therefore, at least one vertex in <em>R</em> will be newly discovered.</li></ol>
<p class="noindent">Thus, at least one new edge enters the directed equality subgraph, and any edge that leaves the directed equality subgraph belongs to neither the matching <em>M</em> nor <a id="p729"/>the breadth-first forest <em>F</em>. Newly discovered vertices in <em>R</em> are enqueued, but their distances are not necessarily 1 greater than the distances of the most recently discovered vertices in <em>L</em>.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_25-5"><img alt="art" class="width100" src="images/Art_P812.jpg"/></p>
<p class="caption"><strong>Figure 25.5</strong> Finding an <em>M</em>-augmenting path in <em>G</em><sub><em>M,h</em></sub> by breadth-first search. <strong>(a)</strong> The directed equality subgraph <em>G</em><sub><em>M,h</em></sub> from <a href="chapter025.xhtml#Fig_25-4">Figure 25.4(c)</a>. <strong>(b)–(g)</strong> Successive versions of the breadth-first forest <em>F</em>, shown as the vertices at each distance from the roots—the unmatched vertices in <em>L</em>—are discovered. In parts (b)–(f), the layer of vertices closest to the bottom of the figure are those in the first-in, first-out queue. For example, in part (b), the queue contains the roots <span class="font1">〈</span><em>l</em><sub>4</sub>, <em>l</em><sub>5</sub>, <em>l</em><sub>7</sub><span class="font1">〉</span>, and in part (e), the queue contains <span class="font1">〈</span><em>r</em><sub>3</sub>, <em>r</em><sub>4</sub><span class="font1">〉</span>, at distance 3 from the roots. In part (g), the unmatched vertex <em>r</em><sub>5</sub> is discovered, so the breadth-first search terminates. The path <span class="font1">〈</span>(<em>l</em><sub>4</sub>, <em>r</em><sub>2</sub>), (<em>r</em><sub>2</sub>, <em>l</em><sub>1</sub>), (<em>l</em><sub>1</sub>, <em>r</em><sub>3</sub>), (<em>r</em><sub>3</sub>, <em>l</em><sub>6</sub>), (<em>l</em><sub>6</sub>, <em>r</em><sub>5</sub>)<span class="font1">〉</span>, highlighted in orange in parts (a) and (g), is an <em>M</em>-augmenting path. Taking its symmetric difference with the matching <em>M</em> yields a new matching with one more edge than <em>M</em>.</p>
</div>
<p class="bolck"/>
<a id="p730"/>
<div class="divimage">
<p class="fig-imga" id="Fig_25-6"><img alt="art" src="images/Art_P813.jpg"/></p>
<p class="caption"><strong>Figure 25.6 (a)</strong> The new matching <em>M</em> and the new directed equality subgraph <em>G</em><sub><em>M.h</em></sub> after updating the matching in <a href="chapter025.xhtml#Fig_25-5">Figure 25.5(a)</a> with the <em>M</em>-augmenting path in <a href="chapter025.xhtml#Fig_25-5">Figure 25.5(g)</a>. <strong>(b)–(d)</strong> Successive versions of the breadth-first forest <em>F</em> in a new breadth-first search with roots <em>l</em><sub>5</sub> and <em>l</em><sub>7</sub>. After the vertices <em>l</em><sub>4</sub> and <em>l</em><sub>3</sub> in part (d) have been removed from the queue, the queue becomes empty before the search can discover an unmatched vertex in <em>R</em>.</p>
</div>
<p>To update the feasible vertex labeling, the Hungarian algorithm first computes the value</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P814.jpg"/></p>
<p class="noindent">where <em>F</em><sub><em>L</em></sub> = <em>L</em> ∩ <em>V</em><sub><em>F</em></sub> and <em>F</em><sub><em>R</em></sub> = <em>R</em> ∩ <em>V</em><sub><em>F</em></sub> denote the vertices in the breadth-first forest <em>F</em> that belong to <em>L</em> and <em>R</em>, respectively. That is, <em>δ</em> is the smallest difference by which an edge incident on a vertex in <em>F</em><sub><em>L</em></sub> missed being in the current equality subgraph <em>G</em><sub><em>h</em></sub>. The Hungarian algorithm then creates a new feasible vertex labeling, say <em>h</em>′, by subtracting <em>δ</em> from <em>l</em>.<em>h</em> for all vertices <em>l</em> ∈ <em>F</em><sub><em>L</em></sub> and adding <em>δ</em> to <em>r</em>.<em>h</em> for all vertices <em>r</em> ∈ <em>F</em><sub><em>R</em></sub>:</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P815.jpg"/></p>
<a id="p731"/>
<p class="noindent">The following lemma shows that these changes achieve the three criteria above.</p>
<p class="lem"><strong><em>Lemma 25.15</em></strong></p>
<p class="noindent">Let <em>h</em> be a feasible vertex labeling for the complete bipartite graph <em>G</em> with equality subgraph <em>G</em><sub><em>h</em></sub>, and let <em>M</em> be a matching for <em>G</em><sub><em>h</em></sub> and <em>F</em> be a breadth-first forest being constructed for the directed equality subgraph <em>G</em><sub><em>M,h</em></sub>. Then, the labeling <em>h</em>′ in equation (25.5) is a feasible vertex labeling for <em>G</em> with the following properties:</p>
<ol class="olnoindent" epub:type="list">
<li>If (<em>u</em>, <em>v</em>) is an edge in the breadth-first forest <em>F</em> for <em>G</em><sub><em>M,h</em></sub>, then (<em>u</em>, <em>v</em>) ∈ <em>E</em><sub><em>M,h′</em></sub>.</li>
<li class="litop">If (<em>l</em>, <em>r</em>) belongs to the matching <em>M</em> for <em>G</em><sub><em>h</em></sub>, then (<em>r</em>, <em>l</em>) ∈ <em>E</em><sub><em>M,h′</em></sub>.</li>
<li class="litop">There exist vertices <em>l</em> ∈ <em>F</em><sub><em>L</em></sub> and <em>r</em> ∈ <em>R</em> − <em>F</em><sub><em>R</em></sub> such that (<em>l</em>, <em>r</em>) ∉ <em>E</em><sub><em>M,h</em></sub> but (<em>l</em>, <em>r</em>) ∈ <em>E</em><sub><em>M,h′</em></sub>.</li></ol>
<p class="prof"><strong><em>Proof</em></strong>   We first show that <em>h</em>′ is a feasible vertex labeling for <em>G</em>. Because <em>h</em> is a feasible vertex labeling, we have <em>l</em>.<em>h</em> + <em>r</em>.<em>h</em> ≥ <em>w</em>(<em>l</em>, <em>r</em>) for all <em>l</em> ∈ <em>L</em> and <em>r</em> ∈ <em>R</em>. In order for <em>h</em>′ to not be a feasible vertex labeling, we would need <em>l</em>.<em>h</em>′ + <em>r</em>.<em>h</em>′ &lt; <em>l</em>.<em>h</em> + <em>r</em>.<em>h</em> for some <em>l</em> ∈ <em>L</em> and <em>r</em> ∈ <em>R</em>. The only way this could occur would be for some <em>l</em> ∈ <em>F</em><sub><em>L</em></sub> and <em>r</em> ∈ <em>R</em> − <em>F</em><sub><em>R</em></sub>. In this instance, the amount of the decrease equals <em>δ</em>, so that <em>l</em>.<em>h</em>′ + <em>r</em>.<em>h</em>′ = <em>l</em>.<em>h</em> − <em>δ</em> + <em>r</em>.<em>h</em>. By equation (25.4), we have that <em>l</em>.<em>h</em>−<em>δ</em>+<em>r</em>.<em>h</em> ≥ <em>w</em>(<em>l</em>, <em>r</em>) for any <em>l</em> ∈ <em>F</em><sub><em>L</em></sub> and <em>r</em> ∈ <em>R</em>−<em>F</em><sub><em>R</em></sub>, so that <em>l</em>.<em>h</em>′+<em>r</em>.<em>h</em>′ ≥ <em>w</em>(<em>l</em>, <em>r</em>). For all other edges, we have <em>l</em>.<em>h</em>′ + <em>r</em>.<em>h</em>′ ≥ <em>l</em>.<em>h</em>+<em>r</em>.<em>h</em> ≥ <em>w</em>(<em>l</em>, <em>r</em>). Thus, <em>h</em>′ is a feasible vertex labeling.</p>
<p>Now we show that each of the three desired properties holds:</p>
<ol class="olnoindent" epub:type="list">
<li>If <em>l</em> ∈ <em>F</em><sub><em>L</em></sub> and <em>r</em> ∈ <em>F</em><sub><em>R</em></sub>, then we have <em>l</em>.<em>h</em>′+<em>r</em>.<em>h</em>′ = <em>l</em>.<em>h</em>+<em>r</em>.<em>h</em> because <em>δ</em> is added to the label of <em>l</em> and subtracted from the label of <em>r</em>. Therefore, if an edge belongs to <em>F</em> for the directed graph <em>G</em><sub><em>M,h</em></sub>, it also belongs to <em>G</em><sub><em>M,h</em></sub>′.</li>
<li class="litop">We claim that at the time the Hungarian algorithm computes the new feasible vertex labeling <em>h</em>′, for every edge (<em>l</em>, <em>r</em>) ∈ <em>M</em>, we have <em>l</em> ∈ <em>F</em><sub><em>L</em></sub> if and only if <em>r</em> ∈ <em>F</em><sub><em>R</em></sub>. To see why, consider a matched vertex <em>r</em> and let (<em>l</em>, <em>r</em>) ∈ <em>M</em>. First suppose that <em>r</em> ∈ <em>F</em><sub><em>R</em></sub>, so that the search discovered <em>r</em> and enqueued it. When <em>r</em> was removed from the queue, <em>l</em> was discovered, so <em>l</em> ∈ <em>F</em><sub><em>L</em></sub>. Now suppose that <em>r</em> ∉ <em>F</em><sub><em>R</em></sub>, so <em>r</em> is undiscovered. We will show that <em>l</em> ∉ <em>F</em><sub><em>L</em></sub>. The only edge in <em>G</em><sub><em>M,h</em></sub> that enters <em>l</em> is (<em>r</em>, <em>l</em>), and since <em>r</em> is undiscovered, the search has not taken this edge; if <em>l</em> ∈ <em>F</em><sub><em>L</em></sub>, it is not because of the edge (<em>r</em>, <em>l</em>). The only other way that a vertex in <em>L</em> can be in <em>F</em><sub><em>L</em></sub> is if it is a root of the search, but only unmatched vertices in <em>L</em> are roots and <em>l</em> is matched. Thus, <em>l</em> ∉ <em>F</em><sub><em>L</em></sub>, and the claim is proved.
<p class="noindent1-top">We already saw that <em>l</em> ∈ <em>F</em><sub><em>L</em></sub> and <em>r</em> ∈ <em>F</em><sub><em>R</em></sub> implies <em>l</em>.<em>h</em>′ + <em>r</em>.<em>h</em>′ = <em>l</em>.<em>h</em> + <em>r</em>.<em>h</em>. For the opposite case, when <em>l</em> ∈ <em>L</em> − <em>F</em><sub><em>L</em></sub> and <em>R</em> ∈ <em>R</em> − <em>F</em><sub><em>R</em></sub>, we have that <em>l</em>.<em>h</em>′ = <em>l</em>.<em>h</em> and <em>r</em>.<em>h</em>′ = <em>r</em>.<em>h</em>, so that again <em>l</em>.<em>h</em>′ + <em>r</em>.<em>h</em>′ = <em>l</em>.<em>h</em> + <em>r</em>.<em>h</em>. Thus, if edge (<em>l</em>, <em>r</em>) is in the matching <em>M</em> for the equality graph <em>G</em><sub><em>h</em></sub>, then (<em>r</em>, <em>l</em>) ∈ <em>E</em><sub><em>M,h</em>′</sub>.<a id="p732"/></p>
</li>
<li class="litop">Let (<em>l</em>, <em>r</em>) be an edge not in <em>E</em><sub><em>h</em></sub> such that <em>l</em> ∈ <em>F</em><sub><em>L</em></sub>, <em>r</em> ∈ <em>R</em> − <em>F</em><sub><em>R</em></sub>, and <em>δ</em> = <em>l</em>.<em>h</em> + <em>r</em>.<em>h</em> − <em>w</em>(<em>l</em>, <em>r</em>). By the definition of <em>δ</em>, there is at least one such edge. Then, we have
<table class="table2b">
<tr>
<td class="td1"><em>l</em>.<em>h</em>′ + <em>r</em>.<em>h</em>′</td>
<td class="td1">=</td>
<td class="td1"><em>l</em>.<em>h</em> − <em>δ</em> + <em>r</em>.<em>h</em></td>
</tr>
<tr>
<td class="td1"/>
<td class="td1">=</td>
<td class="td1"><em>l</em>.<em>h</em> − (<em>l</em>.<em>h</em> + <em>r</em>.<em>h</em> − <em>w</em>(<em>l</em>, <em>r</em>)) + <em>r</em>.<em>h</em></td>
</tr>
<tr>
<td class="td1"/>
<td class="td1">=</td>
<td class="td1"><em>w</em>(<em>l</em>, <em>r</em>),</td>
</tr>
</table>
<p class="lip">and thus (<em>l</em>, <em>r</em>) ∈ <em>E</em><sub><em>h</em>′</sub>. Since (<em>l</em>, <em>r</em>) is not in <em>E</em><sub><em>h</em></sub>, it is not in the matching <em>M</em>, so that in <em>E</em><sub><em>M,h</em>′</sub> it must be directed from <em>L</em> to <em>R</em>. Thus, (<em>l</em>, <em>r</em>) ∈ <em>E</em><sub><em>M,h</em>′</sub>.</p>
<p class="right"><span class="font1">▪</span></p></li>
</ol>
<p>It is possible for an edge to belong to <em>E</em><sub><em>M,h</em></sub> but not to <em>E</em><sub><em>M,h</em>′</sub>. By Lemma 25.15, any such edge belongs neither to the matching <em>M</em> nor to the breadth-first forest <em>F</em> at the time that the new feasible vertex labeling <em>h</em>′ is computed. (See Exercise 25.3-3.)</p>
<p>Going back to <a href="chapter025.xhtml#Fig_25-6">Figure 25.6(d)</a>, the queue became empty before an <em>M</em>-augmenting path was found. <a href="chapter025.xhtml#Fig_25-7">Figure 25.7</a> shows the next steps taken by the algorithm. The value of <em>δ</em> = 1 is achieved by the edge (<em>l</em><sub>5</sub>, <em>r</em><sub>3</sub>) because in <a href="chapter025.xhtml#Fig_25-4">Figure 25.4(a)</a>, <em>l</em><sub>5</sub>.<em>h</em> + <em>r</em><sub>3</sub>.<em>h</em> − <em>w</em>(<em>l</em><sub>5</sub>, <em>r</em><sub>3</sub>) = 6 + 0 − 5 = 1. In <a href="chapter025.xhtml#Fig_25-7">Figure 25.7(a)</a>, the values of <em>l</em><sub>3</sub>.<em>h</em>, <em>l</em><sub>4</sub>.<em>h</em>, <em>l</em><sub>5</sub>.<em>h</em>, and <em>l</em><sub>7</sub>.<em>h</em> have decreased by 1 and the values of <em>r</em><sub>2</sub>.<em>h</em> and <em>r</em><sub>7</sub>.<em>h</em> have increased by 1 because these vertices are in <em>F</em>. As a result, the edges (<em>l</em><sub>1</sub>, <em>r</em><sub>2</sub>) and (<em>l</em><sub>6</sub>, <em>r</em><sub>7</sub>) leave <em>G</em><sub><em>M,h</em></sub> and the edge (<em>l</em><sub>5</sub>, <em>r</em><sub>3</sub>) enters. <a href="chapter025.xhtml#Fig_25-7">Figure 25.7(b)</a> shows the new directed equality subgraph <em>G</em><sub><em>M,h</em></sub>. With edge (<em>l</em><sub>5</sub>, <em>r</em><sub>3</sub>) now in <em>G</em><sub><em>M,h</em></sub>, <a href="chapter025.xhtml#Fig_25-7">Figure 25.7(c)</a> shows that this edge is added to the breadth-first forest <em>F</em>, and <em>r</em><sub>3</sub> is added to the queue. Parts (c)–(f) show the breadth-first forest continuing to be built until in part (f), the queue once again becomes empty after vertex <em>l</em><sub>2</sub>, which has no edges leaving, is removed. Again, the algorithm must update the feasible vertex labeling and the directed equality subgraph. Now the value of <em>δ</em> = 1 is achieved by three edges: (<em>l</em><sub>1</sub>, <em>r</em><sub>6</sub>), (<em>l</em><sub>5</sub>, <em>r</em><sub>6</sub>), and (<em>l</em><sub>7</sub>, <em>r</em><sub>6</sub>).</p>
<p>As <a href="chapter025.xhtml#Fig_25-8">Figure 25.8</a> shows in parts (a) and (b), these edges enter <em>G</em><sub><em>M,h</em></sub>, and edge (<em>l</em><sub>6</sub>, <em>r</em><sub>3</sub>) leaves. Part (c) shows that edge (<em>l</em><sub>1</sub>, <em>r</em><sub>6</sub>) is added to the breadth-first forest. (Either of edges (<em>l</em><sub>5</sub>, <em>r</em><sub>6</sub>) or (<em>l</em><sub>7</sub>, <em>r</em><sub>6</sub>) could have been added instead.) Because <em>r</em><sub>6</sub> is unmatched, the search has found the <em>M</em>-augmenting path <span class="font1">〈</span>(<em>l</em><sub>5</sub>, <em>r</em><sub>3</sub>), (<em>r</em><sub>3</sub>, <em>l</em><sub>1</sub>), (<em>l</em><sub>1</sub>, <em>r</em><sub>6</sub>)<span class="font1">〉</span>, highlighted in orange.</p>
<p><a href="chapter025.xhtml#Fig_25-9">Figure 25.9(a)</a> shows <em>G</em><sub><em>M,h</em></sub> after the matching <em>M</em> has been updated by taking its symmetric difference with the <em>M</em>-augmenting path. The Hungarian algorithm starts its last breadth-first search, with vertex <em>l</em><sub>7</sub> as the only root. The search proceeds as shown in parts (b)–(h) of the figure, until the queue becomes empty after removing <em>l</em><sub>4</sub>. This time, we find that <em>δ</em> = 2, achieved by the five edges (<em>l</em><sub>2</sub>, <em>r</em><sub>5</sub>), (<em>l</em><sub>3</sub>, <em>r</em><sub>1</sub>), (<em>l</em><sub>4</sub>, <em>r</em><sub>5</sub>), (<em>l</em><sub>5</sub>, <em>r</em><sub>1</sub>), and (<em>l</em><sub>5</sub>, <em>r</em><sub>5</sub>), each of which enters <em>G</em><sub><em>M,h</em></sub>. <a href="chapter025.xhtml#Fig_25-10">Figure 25.10(a)</a> shows the results of decreasing the feasible vertex label of each vertex in <em>F</em><sub><em>L</em></sub> by 2 and increasing the feasible vertex label of each vertex in <em>F</em><sub>R</sub> <a id="p733"/>by 2, and <a href="chapter025.xhtml#Fig_25-10">Figure 25.10(b)</a> shows the resulting directed equality subgraph <em>G</em><sub><em>M,h</em></sub>. Part (c) shows that edge (<em>l</em><sub>3</sub>, <em>r</em><sub>1</sub>) is added to the breadth-first forest. Since <em>r</em><sub>1</sub> is an unmatched vertex, the search terminates, having found the <em>M</em>-augmenting path <span class="font1">〈</span>(<em>l</em><sub>7</sub>, <em>r</em><sub>7</sub>), (<em>r</em><sub>7</sub>, <em>l</em><sub>3</sub>), (<em>l</em><sub>3</sub>, <em>r</em><sub>1</sub>)<span class="font1">〉</span>, highlighted in orange. If <em>r</em><sub>1</sub> had been matched, vertex <em>r</em><sub>5</sub> would also have been added to the breadth-first forest, with any of <em>l</em><sub>2</sub>, <em>l</em><sub>4</sub>, or <em>l</em><sub>5</sub> as its parent.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_25-7"><img alt="art" class="width100" src="images/Art_P816.jpg"/></p>
<p class="caption"><strong>Figure 25.7</strong> Updating the feasible vertex labeling and the directed equality subgraph <em>G</em><sub><em>M,h</em></sub> when the queue becomes empty before finding an <em>M</em>-augmenting path. <strong>(a)</strong> With <em>δ</em> = 1, the values of <em>l</em><sub>3</sub>.<em>h</em>, <em>l</em><sub>4</sub>.<em>h</em>, <em>l</em><sub>5</sub>.<em>h</em>, and <em>l</em><sub>7</sub>.<em>h</em> decreased by 1 and <em>r</em><sub>2</sub>.<em>h</em> and <em>r</em><sub>7</sub>.<em>h</em> increased by 1. Edges (<em>l</em><sub>1</sub>, <em>r</em><sub>2</sub>) and (<em>l</em><sub>6</sub>, <em>r</em><sub>7</sub>) leave <em>G</em><sub><em>M,h</em></sub>, and edge (<em>l</em><sub>5</sub>, <em>r</em><sub>3</sub>) enters. These changes are highlighted in yellow. <strong>(b)</strong> The resulting directed equality subgraph <em>G</em><sub><em>M,h</em></sub>. <strong>(c)–(f)</strong> With edge (<em>l</em><sub>5</sub>, <em>r</em><sub>3</sub>) added to the breadth-first forest and <em>r</em><sub>3</sub> added to the queue, the breadth-first search continues until the queue once again becomes empty in part (f).</p>
</div>
<p>After updating the matching <em>M</em>, the algorithm arrives at the perfect matching shown for the equality subgraph <em>G</em><sub><em>h</em></sub> in <a href="chapter025.xhtml#Fig_25-11">Figure 25.11</a>. By Theorem 25.14, the edges in <em>M</em> form an optimal solution to the original assignment problem given in the matrix. Here, the weights of edges (<em>l</em><sub>1</sub>, <em>r</em><sub>6</sub>), (<em>l</em><sub>2</sub>, <em>r</em><sub>4</sub>), (<em>l</em><sub>3</sub>, <em>r</em><sub>1</sub>), (<em>l</em><sub>4</sub>, <em>r</em><sub>2</sub>), (<em>l</em><sub>5</sub>, <em>r</em><sub>3</sub>), (<em>l</em><sub>6</sub>, <em>r</em><sub>5</sub>), and (<em>l</em><sub>7</sub>, <em>r</em><sub>7</sub>) sum to 65, which is the maximum weight of any matching.</p>
<p>The weight of the maximum-weight matching equals the sum of all the feasible vertex labels. These problems—maximizing the weight of a matching and minimizing <a id="p734"/>the sum of the feasible vertex labels—are “duals” of each other, in a similar vein to how the value of a maximum flow equals the capacity of a minimum cut. <a href="chapter029.xhtml#Sec_29.3">Section 29.3</a> explores duality in more depth.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_25-8"><img alt="art" class="width100" src="images/Art_P817.jpg"/></p>
<p class="caption"><strong>Figure 25.8</strong> Another update to the feasible vertex labeling and directed equality subgraph <em>G</em><sub><em>M,h</em></sub> because the queue became empty before finding an <em>M</em>-augmenting path. <strong>(a)</strong> With <em>δ</em> = 1, the values of <em>l</em><sub>1</sub>.<em>h</em>, <em>l</em><sub>2</sub>.<em>h</em>, <em>l</em><sub>3</sub>.<em>h</em>, <em>l</em><sub>4</sub>.<em>h</em>, <em>l</em><sub>5</sub>.<em>h</em>, and <em>l</em><sub>7</sub>.<em>h</em> decrease by 1, and <em>r</em><sub>2</sub>.<em>h</em>, <em>r</em><sub>3</sub>.<em>h</em>, <em>r</em><sub>4</sub>.<em>h</em>, and <em>r</em><sub>7</sub>.<em>h</em> increase by 1. Edge (<em>l</em><sub>6</sub>, <em>r</em><sub>3</sub>) leaves <em>G</em><sub><em>M,h</em></sub>, and edges (<em>l</em><sub>1</sub>, <em>r</em><sub>6</sub>), (<em>l</em><sub>5</sub>, <em>r</em><sub>6</sub>) and (<em>l</em><sub>7</sub>, <em>r</em><sub>6</sub>) enter. <strong>(b)</strong> The resulting directed equality subgraph <em>G</em><sub><em>M,h</em></sub>. <strong>(c)</strong> With edge (<em>l</em><sub>1</sub>, <em>r</em><sub>6</sub>) added to the breadth-first forest and <em>r</em><sub>6</sub> unmatched, the search terminates, having found the <em>M</em>-augmenting path <span class="font1">〈</span>(<em>l</em><sub>5</sub>, <em>r</em><sub>3</sub>), (<em>r</em><sub>3</sub>, <em>l</em><sub>1</sub>), (<em>l</em><sub>1</sub>, <em>r</em><sub>6</sub>)<span class="font1">〉</span>, highlighted in orange in parts (b) and (c).</p>
</div>
<p class="level4"><strong>The Hungarian algorithm</strong></p>
<p class="noindent">The procedure H<small>UNGARIAN</small> on page 737 and its subroutine F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> on page 738 follow the steps we have just seen. The third property in Lemma 25.15 ensures that in line 23 of F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> the queue <em>Q</em> is nonempty. The pseudocode uses the attribute <em>π</em> to indicate predecessor vertices in the breadth-first forest. Instead of coloring vertices, as in the BFS procedure on page 556, the search puts the discovered vertices into the sets <em>F</em><sub><em>L</em></sub> and <em>F</em><sub><em>R</em></sub>. Because the Hungarian algorithm does not need breadth-first distances, the pseudocode omits the <em>d</em> attribute computed by the BFS procedure.</p>
<a id="p735"/>
<div class="divimage">
<p class="fig-imga" id="Fig_25-9"><img alt="art" class="width100" src="images/Art_P818.jpg"/></p>
<p class="caption"><strong>Figure 25.9 (a)</strong> The new matching <em>M</em> and the new directed equality subgraph <em>G</em><sub><em>M,h</em></sub> after updating the matching in <a href="chapter025.xhtml#Fig_25-8">Figure 25.8</a> with the <em>M</em>-augmenting path in <a href="chapter025.xhtml#Fig_25-8">Figure 25.8</a> parts (b) and (c). <strong>(b)–(h)</strong> Successive versions of the breadth-first forest <em>F</em> in a new breadth-first search with root <em>l</em><sub>7</sub>. After the vertex <em>l</em><sub>4</sub> in part (h) has been removed from the queue, the queue becomes empty before the search discovers an unmatched vertex in <em>R</em>.</p>
</div>
<p>Now, let’s see why the Hungarian algorithm runs in <em>O</em>(<em>n</em><sup>4</sup>) time, where |<em>V</em>| = <em>n</em>/2 and |<em>E</em>| = <em>n</em><sup>2</sup> in the original graph <em>G</em>. (Below we outline how to reduce the running time to <em>O</em>(<em>n</em><sup>3</sup>).) You can go through the pseudocode of H<small>UNGARIAN</small> to verify that lines 1–6 and 11 take <em>O</em>(<em>n</em><sup>2</sup>) time. The <strong>while</strong> loop of lines 7–10 iterates at most <em>n</em> times, since each iteration increases the size of the matching <em>M</em> by 1. Each test in line 7 can take constant time by just checking whether |<em>M</em>| &lt; <em>n</em>, each update of <em>M</em> in line 9 takes <em>O</em>(<em>n</em>) time, and the updates in line 10 take <em>O</em>(<em>n</em><sup>2</sup>) time.</p>
<p>To achieve the <em>O</em>(<em>n</em><sup>4</sup>) time bound, it remains to show that each call of F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> runs in <em>O</em>(<em>n</em><sup>3</sup>) time. Let’s call each execution of lines 10–22 <a id="p736"/>a <strong><em><span class="blue">growth step</span></em></strong>. Ignoring the growth steps, you can verify that F<small>IND</small>-A<small>UGMENTING-PATH</small> is a breadth-first search. With the sets <em>F</em><sub><em>L</em></sub> and <em>F</em><sub><em>R</em></sub> represented appropriately, the breadth-first search takes <em>O</em>(<em>V</em> + <em>E</em>) = <em>O</em>(<em>n</em><sup>2</sup>) time. Within a call of F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small>, at most <em>n</em> growth steps can occur, since each growth step is guaranteed to discover at least one vertex in <em>R</em>. Since there are at most <em>n</em><sup>2</sup> edges in <em>G</em><sub><em>M,h</em></sub>, the <strong>for</strong> loop of lines 16–22 iterates at most <em>n</em><sup>2</sup> times per call of F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small>. The bottleneck is lines 10 and 15, which take <em>O</em>(<em>n</em><sup>2</sup>) time, so that F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> takes <em>O</em>(<em>n</em><sup>3</sup>) time.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_25-10"><img alt="art" src="images/Art_P819.jpg"/></p>
<p class="caption"><strong>Figure 25.10</strong> Updating the feasible vertex labeling and directed equality subgraph <em>G</em><sub><em>M,h</em></sub>. <strong>(a)</strong> Here, <em>δ</em> = 2, so the values of <em>l</em><sub>1</sub>.<em>h</em>, <em>l</em><sub>2</sub>.<em>h</em>, <em>l</em><sub>3</sub>.<em>h</em>, <em>l</em><sub>4</sub>.<em>h</em>, <em>l</em><sub>5</sub>.<em>h</em>, and <em>l</em><sub>7</sub>.<em>h</em> decreased by 2, and the values of <em>r</em><sub>2</sub>.<em>h</em>, <em>r</em><sub>3</sub>.<em>h</em>, <em>r</em><sub>4</sub>.<em>h</em>, <em>r</em><sub>6</sub>.<em>h</em>, and <em>r</em><sub>7</sub>.<em>h</em> increased by 2. Edges (<em>l</em><sub>2</sub>, <em>r</em><sub>5</sub>), (<em>l</em><sub>3</sub>, <em>r</em><sub>1</sub>), (<em>l</em><sub>4</sub>, <em>r</em><sub>5</sub>), (<em>l</em><sub>5</sub>, <em>r</em><sub>1</sub>), and (<em>l</em><sub>5</sub>, <em>r</em><sub>5</sub>) enter <em>G</em><sub><em>M,h</em></sub>. <strong>(b)</strong> The resulting directed graph <em>G</em><sub><em>M,h</em></sub>. <strong>(c)</strong> With edge (<em>l</em><sub>3</sub>, <em>r</em><sub>1</sub>) added to the breadth-first forest and <em>r</em><sub>1</sub> unmatched, the search terminates, having found the <em>M</em>-augmenting path <span class="font1">〈</span>(<em>l</em><sub>7</sub>, <em>r</em><sub>7</sub>), (<em>r</em><sub>7</sub>, <em>l</em><sub>3</sub>), (<em>l</em><sub>3</sub>, <em>r</em><sub>1</sub>)<span class="font1">〉</span>, highlighted in orange in parts (b) and (c).</p>
</div>
<p>Exercise 25.3-5 asks you to show that reconstructing the directed equality subgraph <em>G</em><sub><em>M,h</em></sub> in line 15 is actually unnecessary, so that its cost can be eliminated. Reducing the cost of computing <em>δ</em> in line 10 to <em>O</em>(<em>n</em>) takes a little more effort and is the subject of Problem 25-2. With these changes, each call of F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> takes <em>O</em>(<em>n</em><sup>2</sup>) time, so that the Hungarian algorithm runs in <em>O</em>(<em>n</em><sup>3</sup>) time.</p>
<a id="p737"/>
<div class="divimage">
<p class="fig-imga" id="Fig_25-11"><img alt="art" src="images/Art_P820.jpg"/></p>
<p class="caption"><strong>Figure 25.11</strong> The final matching, shown for the equality subgraph <em>G</em><sub><em>h</em></sub> with blue edges and blue entries in the matrix. The weights of the edges in the matching sum to 65, which is the maximum for any matching in the original complete bipartite graph <em>G</em>, as well as the sum of all the final feasible vertex labels.</p>
</div>
<div class="pull-quote1">
<p class="box-heading">H<small>UNGARIAN</small> (<em>G</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1" colspan="2"><p class="noindent"><strong>for</strong> each vertex <em>l</em> ∈ <em>L</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><p class="p2"><em>l</em>.<em>h</em> = max {<em>w</em>(<em>l</em>, <em>r</em>) : <em>r</em> ∈ <em>R</em>}</p></td>
<td class="td1"><span class="red"><strong>//</strong> from equation (25.1)</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1" colspan="2"><p class="noindent"><strong>for</strong> each vertex <em>r</em> ∈ <em>R</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2"><em>r</em>.<em>h</em> = 0</p></td>
<td class="td1"><span class="red"><strong>//</strong> from equation (25.2)</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1" colspan="2"><p class="noindent">let <em>M</em> be any matching in <em>G</em><sub><em>h</em></sub> (such as the matching returned by</p></td>
</tr>
<tr>
<td class="td1"/>
<td class="td1" colspan="2"><p class="p2">G<small>REEDY</small>-B<small>IPARTITE</small>-M<small>ATCHING</small>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1" colspan="2"><p class="noindent">from <em>G</em>, <em>M</em>, and <em>h</em>, form the equality subgraph <em>G</em><sub><em>h</em></sub></p></td>
</tr>
<tr>
<td class="td1"/>
<td class="td1" colspan="2"><p class="p2">and the directed equality subgraph <em>G</em><sub><em>M,h</em></sub></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1" colspan="2"><p class="noindent"><strong>while</strong> <em>M</em> is not a perfect matching in <em>G</em><sub><em>h</em></sub></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1" colspan="2"><p class="p2"><em>P</em> = F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> (<em>G</em><sub><em>M,h</em></sub>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1" colspan="2"><p class="p2"><em>M</em> = <em>M</em> ⊕ <em>P</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1" colspan="2"><p class="p2">update the equality subgraph <em>G</em><sub><em>h</em></sub></p></td>
</tr>
<tr>
<td class="td1"/>
<td class="td1" colspan="2"><p class="p3">and the directed equality subgraph <em>G</em><sub><em>M,h</em></sub></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1" colspan="2"><p class="noindent"><strong>return</strong> <em>M</em></p></td>
</tr>
</table>
</div>
<a id="p738"/>
<div class="pull-quote1">
<p class="box-heading">F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> (<em>G</em><sub><em>M,h</em></sub>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1" colspan="4"><p class="tdph"><em>Q</em> = Ø</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1" colspan="4"><p class="tdph"><em>F</em><sub><em>L</em></sub> = Ø</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1" colspan="4"><p class="tdph"><em>F</em><sub><em>R</em></sub> = Ø</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1" colspan="4"><p class="tdph"><strong>for</strong> each unmatched vertex <em>l</em> ∈ <em>L</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1" colspan="4"><p class="p2"><em>l</em>.<em>π</em> = NIL</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1" colspan="4"><p class="p2">E<small>NQUEUE</small> (<em>Q</em>, <em>l</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="p2"><em>F</em><sub><em>L</em></sub> = <em>F</em><sub><em>L</em></sub> ∪ {<em>l</em>}</p></td>
<td class="td1" colspan="3"><span class="red"><strong>//</strong> forest <em>F</em> starts with unmatched vertices in <em>L</em></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1" colspan="4"><p class="tdph"><strong>repeat</strong></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>Q</em> is empty</p></td>
<td class="td1" colspan="3"><span class="red"><strong>//</strong> ran out of vertices to search from?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1" colspan="4"><p class="p3"><em>δ</em> = min {<em>l</em>.<em>h</em> + <em>r</em>.<em>h</em> − <em>w</em>(<em>l</em>, <em>r</em>) : <em>l</em> ∈ <em>F</em><sub><em>L</em></sub> and <em>r</em> ∈ <em>R</em> − <em>F</em><sub><em>R</em></sub>}</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1" colspan="4"><p class="p3"><strong>for</strong> each vertex <em>l</em> ∈ <em>F</em><sub><em>L</em></sub></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">12</span></td>
<td class="td1" colspan="2"><p class="p4"><em>l</em>.<em>h</em> = <em>l</em>.<em>h</em> − <em>δ</em></p></td>
<td class="td1" colspan="2"><p class="p2"><span class="red"><strong>//</strong> relabel according to equation (25.5)</span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">13</span></td>
<td class="td1" colspan="4"><p class="p3"><strong>for</strong> each vertex <em>r</em> ∈ <em>F</em><sub><em>R</em></sub></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">14</span></td>
<td class="td1" colspan="2"><p class="p4"><em>r</em>.<em>h</em> = <em>r</em>.<em>h</em> + <em>δ</em></p></td>
<td class="td1" colspan="2"><p class="p2"><span class="red"><strong>//</strong> relabel according to equation (25.5)</span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">15</span></td>
<td class="td1" colspan="4"><p class="p3">from <em>G</em>, <em>M</em>, and <em>h</em>, form a new directed equality graph <em>G</em><sub><em>M,h</em></sub></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">16</span></td>
<td class="td1" colspan="3"><p class="p3"><strong>for</strong> each new edge (<em>l</em>, <em>r</em>) in <em>G</em><sub><em>M,h</em></sub></p></td>
<td class="td1"><p class="p6"><span class="red"><strong>//</strong> continue search with new edges</span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">17</span></td>
<td class="td1" colspan="4"><p class="p4"><strong>if</strong> <em>r</em> ∉ <em>F</em><sub><em>R</em></sub></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">18</span></td>
<td class="td1" colspan="3"><p class="p5"><em>r</em>.<em>π</em> = <em>l</em></p></td>
<td class="td1"><p class="p6"><span class="red"><strong>//</strong> discover <em>r</em>, add it to F</span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">19</span></td>
<td class="td1" colspan="4"><p class="p5"><strong>if</strong> <em>r</em> is unmatched</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">20</span></td>
<td class="td1" colspan="4"><p class="p6">an <em>M</em>-augmenting path has been found</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">20</span></td>
<td class="td1" colspan="4"><p class="p7">(exit the <strong>repeat</strong> loop)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">21</span></td>
<td class="td1" colspan="3"><p class="p5"><strong>else</strong> E<small>NQUEUE</small> (<em>Q</em>, <em>r</em>)</p></td>
<td class="td1"><p class="p6"><span class="red"><strong>//</strong> can search from <em>r</em> later</span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">22</span></td>
<td class="td1" colspan="4"><p class="p6"><em>F<sub>R</sub></em> = <em>F</em><sub><em>R</em></sub> ∪ {<em>r</em>}</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">23</span></td>
<td class="td1" colspan="3"><p class="p2"><em>u</em> = D<small>EQUEUE</small> (<em>Q</em>)</p></td>
<td class="td1"><p class="p6"><span class="red"><strong>//</strong> search from <em>u</em></span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">24</span></td>
<td class="td1" colspan="4"><p class="p2"><strong>for</strong> each neighbor <em>v</em> of <em>u</em> in <em>G</em><sub><em>M,h</em></sub></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">25</span></td>
<td class="td1" colspan="4"><p class="p3"><strong>if</strong> <em>v</em> ∈ <em>L</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">26</span></td>
<td class="td1" colspan="4"><p class="p4"><em>v.π</em> = <em>u</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">27</span></td>
<td class="td1" colspan="3"><p class="p4"><em>F</em><sub><em>L</em></sub> = <em>F</em><sub><em>L</em></sub> ∪ {<em>v</em>}</p></td>
<td class="td1"><p class="p6"><span class="red"><strong>//</strong> discover <em>v</em>, add it to <em>F</em></span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">28</span></td>
<td class="td1" colspan="3"><p class="p4">E<small>NQUEUE</small> (<em>Q</em>, <em>v</em>)</p></td>
<td class="td1"><p class="p6"><span class="red"><strong>//</strong> can search from <em>v</em> later</span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">29</span></td>
<td class="td1" colspan="3"><p class="p3"><strong>elseif</strong> <em>v</em> ∉ <em>F</em><sub><em>R</em></sub></p></td>
<td class="td1"><p class="p6"><span class="red"><strong>//</strong> <em>v</em> ∈ <em>R</em>, do same as lines 18–22</span></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">30</span></td>
<td class="td1" colspan="4"><p class="p4"><em>v.π</em> = <em>u</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">31</span></td>
<td class="td1" colspan="4"><p class="p4"><strong>if</strong> <em>v</em> is unmatched</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">32</span></td>
<td class="td1" colspan="4"><p class="p6">an <em>M</em>-augmenting path has been found</p></td>
</tr>
<tr>
<td class="td1"/>
<td class="td1" colspan="4"><p class="p7">(exit the <strong>repeat</strong> loop)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">33</span></td>
<td class="td1" colspan="4"><p class="p4"><strong>else</strong> E<small>NQUEUE</small> (<em>Q</em>, <em>v</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">34</span></td>
<td class="td1" colspan="4"><p class="p5"><em>F<sub>R</sub></em> = <em>F</em><sub><em>R</em></sub> ∪ {<em>v</em>}</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">35</span></td>
<td class="td1" colspan="4"><p class="tdph"><strong>until</strong> an <em>M</em>-augmenting path has been found</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">36</span></td>
<td class="td1" colspan="4"><p class="tdph">using the predecessor attributes <em>π</em>, construct an <em>M</em>-augmenting path <em>P</em> by tracing back from the unmatched vertex in <em>R</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">37</span></td>
<td class="td1" colspan="4"><p class="tdph"><strong>return</strong> <em>P</em></p></td>
</tr>
</table>
</div>
<a id="p739"/>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>25.3-1</em></strong></p>
<p class="noindent">The F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> procedure checks in two places (lines 19 and 31) whether a vertex it discovers in <em>R</em> is unmatched. Show how to rewrite the pseudocode so that it checks for an unmatched vertex in <em>R</em> in only one place. What is the downside of doing so?</p>
<p class="level3"><strong><em>25.3-2</em></strong></p>
<p class="noindent">Show that for any bipartite graph, the G<small>REEDY</small>-B<small>IPARTITE</small>-M<small>ATCHING</small> procedure on page 726 returns a matching at least half the size of a maximum matching.</p>
<p class="level3"><strong><em>25.3-3</em></strong></p>
<p class="noindent">Show that if an edge (<em>l</em>, <em>r</em>) belongs to the directed equality subgraph <em>G</em><sub><em>M,h</em></sub> but is not a member of <em>G</em><sub><em>M,h</em>′</sub>, where <em>h</em>′ is given by equation (25.5), then <em>l</em> ∈ <em>L</em> − <em>F</em><sub><em>L</em></sub> and <em>r</em> ∈ <em>F</em><sub><em>R</em></sub> at the time that <em>h</em>′ is computed.</p>
<p class="level3"><strong><em>25.3-4</em></strong></p>
<p class="noindent">At line 29 in the F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> procedure, it has already been established that <em>v</em> ∈ <em>R</em>. This line checks to see whether <em>v</em> is already discovered by testing whether <em>v</em> ∈ <em>F</em><sub><em>R</em></sub>. Why doesn’t the procedure need to check whether <em>v</em> is already discovered for the case when <em>v</em> ∈ <em>L</em>, in lines 26–28?</p>
<p class="level3"><strong><em>25.3-5</em></strong></p>
<p class="noindent">Professor Hrabosky asserts that the directed equality subgraph <em>G</em><sub><em>M,h</em></sub> must be constructed and maintained by the Hungarian algorithm, so that line 6 of H<small>UNGARIAN</small> and line 15 of F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> are required. Argue that the professor is incorrect by showing how to determine whether an edge belongs to <em>E</em><sub><em>M,h</em></sub> without explicitly constructing <em>G</em><sub><em>M,h</em></sub>.</p>
<p class="level3"><strong><em>25.3-6</em></strong></p>
<p class="noindent">How can you modify the Hungarian algorithm to find a matching of vertices in <em>L</em> to vertices in <em>R</em> that minimizes, rather than maximizes, the sum of the edge weights in the matching?</p>
<p class="level3"><strong><em>25.3-7</em></strong></p>
<p class="noindent">How can an assignment problem with |<em>L</em>| ≠ |<em>R</em>| be modified so that the Hungarian algorithm solves it?</p>
<a id="p740"/>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-149"><strong>Problems</strong></p>
<section title="25-1 Perfect matchings in a regular bipartite graph">
<p class="level2"><strong><em>25-1     Perfect matchings in a regular bipartite graph</em></strong></p>
<p class="nl"><strong><em>a.</em></strong> Problem 20-3 asked about Euler tours in directed graphs. Prove that a connected, <em>undirected</em> graph <em>G</em> = (<em>V</em>, <em>E</em>) has an Euler tour—a cycle traversing each edge exactly once, though it may visit a vertex multiple times—if and only if the degree of every vertex in <em>V</em> is even.</p>
<p class="nl"><strong><em>b.</em></strong> Assuming that <em>G</em> is connected, undirected, and every vertex in <em>V</em> has even degree, give an <em>O</em>(<em>E</em>)-time algorithm to find an Euler tour of <em>G</em>, as in Problem 20-3(b).</p>
<p class="nl"><strong><em>c.</em></strong> Exercise 25.1-6 states that if <em>G</em> = (<em>V</em>, <em>E</em>) is a <em>d</em>-regular bipartite graph, then it contains <em>d</em> disjoint perfect matchings. Suppose that <em>d</em> is an exact power of 2. Give an algorithm to find all <em>d</em> disjoint perfect matchings in a <em>d</em>-regular bipartite graph in Θ(<em>E</em> lg <em>d</em>) time.</p>
</section>
<section title="25-2 Reducing the running time of the Hungarian algorithm to O(n3)">
<p class="level2"><strong><em>25-2     Reducing the running time of the Hungarian algorithm to O</em>(<em>n</em><sup>3</sup>)</strong></p>
<p class="noindent">In this problem, you will show how to reduce the running time of the Hungarian algorithm from <em>O</em>(<em>n</em><sup>4</sup>) to <em>O</em>(<em>n</em><sup>3</sup>) by showing how to reduce the running time of the F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> procedure from <em>O</em>(<em>n</em><sup>3</sup>) to <em>O</em>(<em>n</em><sup>2</sup>). Exercise 25.3-5 demonstrates that line 6 of H<small>UNGARIAN</small> and line 15 of F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> are unnecessary. Now you will show how to reduce the running time of each execution of line 10 in F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small> to <em>O</em>(<em>n</em>).</p>
<p>For each vertex <em>r</em> ∈ <em>R</em> − <em>F</em><sub><em>R</em></sub>, define a new attribute <em>r.σ</em> where</p>
<p class="eql"><em>r.σ</em> = min {<em>l</em>.<em>h</em> + <em>r</em>.<em>h</em> − <em>w</em>(<em>l</em>, <em>r</em>) : <em>l</em> ∈ <em>F</em><sub><em>L</em></sub>}.</p>
<p class="noindent">That is, <em>r.σ</em> indicates how close <em>r</em> is to being adjacent to some vertex <em>l</em> ∈ <em>F</em><sub><em>L</em></sub> in the directed equality subgraph <em>G</em><sub><em>m,h</em></sub>. Initially, before placing any vertices into <em>F</em><sub><em>L</em></sub>, set <em>r.σ</em> to ∞ for all <em>r</em> ∈ <em>R</em>.</p>
<p class="nl"><strong><em>a.</em></strong> Show how to compute <em>δ</em> in line 10 in <em>O</em>(<em>n</em>) time, based on the <em>σ</em> attribute.</p>
<p class="nl"><strong><em>b.</em></strong> Show how to update all the <em>σ</em> attributes in <em>O</em>(<em>n</em>) time after <em>δ</em> has been computed.</p>
<p class="nl"><strong><em>c.</em></strong> Show that updating all the <em>σ</em> attributes when <em>F</em><sub><em>L</em></sub> changes takes <em>O</em>(<em>n</em><sup>2</sup>) time per call of F<small>IND</small>-A<small>UGMENTING</small>-P<small>ATH</small>.</p>
<p class="nl"><strong><em>d.</em></strong> Conclude that the H<small>UNGARIAN</small> procedure can be implemented to run in <em>O</em>(<em>n</em><sup>3</sup>) time.</p>
<a id="p741"/>
</section>
<section title="25-3 Other matching problems">
<p class="level2"><strong><em>25-3     Other matching problems</em></strong></p>
<p class="noindent">The Hungarian algorithm finds a maximum-weight perfect matching in a complete bipartite graph. It is possible to use the Hungarian algorithm to solve problems in other graphs by modifying the input graph, running the Hungarian algorithm, and then possibly modifying the output. Show how to solve the following matching problems in this manner.</p>
<p class="nl"><strong><em>a.</em></strong> Give an algorithm to find a maximum-weight matching in a weighted bipartite graph that is not necessarily complete and with all edge weights positive.</p>
<p class="nl"><strong><em>b.</em></strong> Redo part (a), but with edge weights allowed to also be 0 or negative.</p>
<p class="nl"><strong><em>c.</em></strong> A <strong><em><span class="blue">cycle cover</span></em></strong> in a directed graph, not necessarily bipartite, is a set of edge-disjoint directed cycles such that each vertex lies on at most one cycle. Given nonnegative edge weights <em>w</em>(<em>u</em>, <em>v</em>), let <em>C</em> be the set of edges in a cycle cover, and define <em>w</em>(<em>C</em>) = ∑<sub>(<em>u,v</em>)∈<em>C</em></sub> <em>w</em>(<em>u, v</em>) to be the weight of the cycle cover. Give an algorithm to find a maximum-weight cycle cover.</p>
</section>
<section title="25-4 Fractional matchings">
<p class="level2"><strong><em>25-4     Fractional matchings</em></strong></p>
<p class="noindent">It is possible to define a <strong><em><span class="blue">fractional matching</span></em></strong>. Given a graph <em>G</em> = (<em>V</em>, <em>E</em>), we define a fractional matching <em>x</em> as a function <em>x</em> : <em>E</em> → [0, 1] (real numbers between 0 and 1, inclusive) such that for every vertex <em>u</em> ∈ <em>V</em>, we have ∑<sub>(<em>u,v</em>)∈<em>E</em></sub> <em>x</em>(<em>u, v</em>) ≤ 1. The value of a fractional matching is ∑<sub>(<em>u, v</em>)∈<em>E</em></sub> <em>x</em>(<em>u, v</em>). The definition of a fractional matching is identical to that of a matching, except that a matching has the additional constraint that <em>x</em>(<em>u</em>, <em>v</em>) ∈ {0, 1} for all edges (<em>u</em>, <em>v</em>) ∈ <em>E</em>. Given a graph, we let <em>M</em>* denote a maximum matching and <em>x</em>* denote a fractional matching with maximum value.</p>
<p class="nl"><strong><em>a.</em></strong> Argue that, for any bipartite graph, we must have ∑<sub>(<em>u, v</em>)∈<em>E</em></sub> <em>x</em>*(<em>u, v</em>) ≥ |<em>M*|.</em></p>
<p class="nl"><strong><em>b.</em></strong> Prove that, for any bipartite graph, we must have ∑<sub>(<em>u, v</em>)∈<em>E</em></sub> <em>x</em>*(<em>e</em>) ≤ |<em>M*|.</em> (<em>Hint:</em> Give an algorithm that converts a fractional matching with an integer value to a matching.) Conclude that the maximum value of a fractional matching in a bipartite graph is the same as the size of the maximum cardinality matching.</p>
<p class="nl"><strong><em>c.</em></strong> We can define a fractional matching in a weighted graph in the same manner: the value of the matching is now ∑<sub>(<em>u, v</em>)∈<em>E</em></sub> <em>w</em>(<em>u, v</em>) <em>x</em>(<em>u, v</em>). Extend the results of the previous parts to show that in a weighted bipartite graph, the maximum value of a weighted fractional matching is equal to the value of a maximum weighted matching.</p>
<a id="p742"/>
<p class="nl"><strong><em>d.</em></strong> In a general graph, the analogous results do not necessarily hold. Give an example of a small graph that is not bipartite for which the fractional matching with maximum value is not a maximum matching.</p>
</section>
<section title="25-5 Computing vertex labels">
<p class="level2"><strong><em>25-5     Computing vertex labels</em></strong></p>
<p class="noindent">You are given a complete bipartite graph <em>G</em> = (<em>V</em>, <em>E</em>) with edge weights <em>w</em>(<em>l</em>, <em>r</em>) for all (<em>l</em>, <em>r</em>) ∈ <em>E</em>. You are also given a maximum-weight perfect matching <em>M</em>* for <em>G</em>. You wish to compute a feasible vertex labeling <em>h</em> such that <em>M</em>* is a perfect matching in the equality subgraph <em>G</em><sub><em>h</em></sub>. That is, you want to compute a labeling <em>h</em> of vertices such that</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P821.jpg"/></p>
<p class="noindent">(Requirement (25.6) holds for all edges, and the stronger requirement (25.7) holds for all edges in <em>M</em>*.) Give an algorithm to compute the feasible vertex labeling <em>h</em>, and prove that it is correct. (<em>Hint:</em> Use the similarity between conditions (25.6) and (25.7) and some of the properties of shortest paths proved in <a href="chapter022.xhtml">Chapter 22</a>, in particular the triangle inequality (Lemma 22.10) and the convergence property (Lemma 22.14.))</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-150"><strong>Chapter notes</strong></p>
<p class="noindent">Matching algorithms have a long history and have been central to many breakthroughs in algorithm design and analysis. The book by Lovász and Plummer [<a epub:type="noteref" href="bibliography001.xhtml#endnote_306">306</a>] is an excellent reference on matching problems, and the chapter on matching in the book by Ahuja, Magnanti and Orlin [<a epub:type="noteref" href="bibliography001.xhtml#endnote_10">10</a>] also has extensive references.</p>
<p>The Hopcroft-Karp algorithm is by Hopcroft and Karp [<a epub:type="noteref" href="bibliography001.xhtml#endnote_224">224</a>]. Madry [<a epub:type="noteref" href="bibliography001.xhtml#endnote_308">308</a>] gave an <em>Õ</em>(<em>E</em><sup>10/7</sup>)-time algorithm, which is asymptotically faster than Hopcroft-Karp for sparse graphs.</p>
<p>Corollary 25.4 is due to Berge [<a epub:type="noteref" href="bibliography001.xhtml#endnote_53">53</a>], and it also holds in graphs that are not bipartite. Matching in general graphs requires more complicated algorithms. The first polynomial-time algorithm, running in <em>O</em>(<em>V</em> <sup>4</sup>) time, is due to Edmonds [<a epub:type="noteref" href="bibliography001.xhtml#endnote_130">130</a>] (in a paper that also introduced the notion of a polynomial-time algorithm). Like the bipartite case, this algorithm also uses augmenting paths, although the algorithm for finding augmenting paths in general graphs is more involved than the one for bipartite graphs. Subsequently, several <img alt="art" src="images/Art_P822.jpg"/>-time algorithms appeared, including ones by Gabow and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_168">168</a>] as part of an algorithm for weighted matching and a simpler one by Gabow [<a epub:type="noteref" href="bibliography001.xhtml#endnote_164">164</a>].</p>
<a id="p743"/>
<p>The Hungarian algorithm is described in the book by Bondy and Murty [<a epub:type="noteref" href="bibliography001.xhtml#endnote_67">67</a>] and is based on work by Kuhn [<a epub:type="noteref" href="bibliography001.xhtml#endnote_273">273</a>] and Munkres [<a epub:type="noteref" href="bibliography001.xhtml#endnote_337">337</a>]. Kuhn adopted the name “Hungarian algorithm” because the algorithm derived from work by the Hungarian mathematicians D. K<span class="font1">ő</span>nig and J. Egervéry. The algorithm is an early example of a primal-dual algorithm. A faster algorithm that runs in <img alt="art" src="images/Art_P823.jpg"/> time, where the edge weights are integers from 0 to <em>W</em>, was given by Gabow and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_167">167</a>], and an algorithm with the same time bound for maximum-weight matching in general graphs was given by Duan, Pettie, and Su [<a epub:type="noteref" href="bibliography001.xhtml#endnote_127">127</a>].</p>
<p>The stable-marriage problem was first defined and analyzed by Gale and Shapley [<a epub:type="noteref" href="bibliography001.xhtml#endnote_169">169</a>]. The stable-marriage problem has numerous variants. The books by Gusfield and Irving [<a epub:type="noteref" href="bibliography001.xhtml#endnote_203">203</a>], Knuth [<a epub:type="noteref" href="bibliography001.xhtml#endnote_266">266</a>], and Manlove [<a epub:type="noteref" href="bibliography001.xhtml#endnote_313">313</a>] serve as excellent sources for cataloging and solving them.</p>
<p class="footnote" id="footnote_1"><a href="#footnote_ref_1"><sup>1</sup></a> The definition of a complete bipartite graph differs from the definition of complete graph given on page 1167 because in a bipartite graph, there are no edges between vertices in <em>L</em> and no edges between vertices in <em>R</em>.</p>
<p class="footnote1" id="footnote_2"><a href="#footnote_ref_2"><sup>2</sup></a> Although marriage norms are changing, it’s traditional to view the stable-marriage problem through the lens of heterosexual marriage.</p>
</section>
</section>
</div>
</body>
</html>