<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p546"/>
<p class="line-p"/>
<section epub:type="bodymatter part" title="Part VI Graph Algorithms">
<p class="part-title"><a href="toc.xhtml#part-6"><strong><em><span class="blue1">Part VI    Graph Algorithms</span></em></strong></a></p>
<a id="p547"/>
<p class="cp"/>
<p class="noindent1-top1"> </p>
<p class="noindent1-top1"> </p>
<section title="Introduction">
<p class="level1a" id="h1-117"><a href="toc.xhtml#Rh1-117"><strong>Introduction</strong></a></p>
<p class="noindent">Graph problems pervade computer science, and algorithms for working with them are fundamental to the field. Hundreds of interesting computational problems are couched in terms of graphs. This part touches on a few of the more significant ones.</p>
<p><a href="chapter020.xhtml">Chapter 20</a> shows how to represent a graph in a computer and then discusses algorithms based on searching a graph using either breadth-first search or depth-first search. The chapter gives two applications of depth-first search: topologically sorting a directed acyclic graph and decomposing a directed graph into its strongly connected components.</p>
<p><a href="chapter021.xhtml">Chapter 21</a> describes how to compute a minimum-weight spanning tree of a graph: the least-weight way of connecting all of the vertices together when each edge has an associated weight. The algorithms for computing minimum spanning trees serve as good examples of greedy algorithms (see <a href="chapter015.xhtml">Chapter 15</a>).</p>
<p><a href="chapter022.xhtml">Chapters 22</a> and <a href="chapter023.xhtml">23</a> consider how to compute shortest paths between vertices when each edge has an associated length or “weight.” <a href="chapter022.xhtml">Chapter 22</a> shows how to find shortest paths from a given source vertex to all other vertices, and <a href="chapter023.xhtml">Chapter 23</a> examines methods to compute shortest paths between every pair of vertices.</p>
<p><a href="chapter024.xhtml">Chapter 24</a> shows how to compute a maximum flow of material in a flow network, which is a directed graph having a specified source vertex of material, a specified sink vertex, and specified capacities for the amount of material that can traverse each directed edge. This general problem arises in many forms, and a good algorithm for computing maximum flows can help solve a variety of related problems efficiently.</p>
<p>Finally, <a href="chapter025.xhtml">Chapter 25</a> explores matchings in bipartite graphs: methods for pairing up vertices that are partitioned into two sets by selecting edges that go between the sets. Bipartite-matching problems model several situations that arise in the real world. The chapter examines how to find a matching of maximum cardinality; the <a id="p548"/>“stable-marriage problem,” which has the highly practical application of matching medical residents to hospitals; and assignment problems, which maximize the total weight of a bipartite matching.</p>
<p>When we characterize the running time of a graph algorithm on a given graph <em>G</em> = (<em>V</em>, <em>E</em>), we usually measure the size of the input in terms of the number of vertices |<em>V</em>| and the number of edges |<em>E</em>| of the graph. That is, we denote the size of the input with two parameters, not just one. We adopt a common notational convention for these parameters. Inside asymptotic notation (such as <em>O</em>-notation or <em>Θ</em>-notation), and <em>only</em> inside such notation, the symbol <em>V</em> denotes |<em>V</em> | and the symbol <em>E</em> denotes |<em>E</em>|. For example, we might say, “the algorithm runs in <em>O</em>(<em>VE</em>) time,” meaning that the algorithm runs in <em>O</em>(|<em>V</em>| |<em>E</em>|) time. This convention makes the running-time formulas easier to read, without risk of ambiguity.</p>
<p>Another convention we adopt appears in pseudocode. We denote the vertex set of a graph <em>G</em> by <em>G</em>.<em>V</em> and its edge set by <em>G</em>.<em>E</em>. That is, the pseudocode views vertex and edge sets as attributes of a graph.</p>
</section>
</section>
</div>
</body>
</html>