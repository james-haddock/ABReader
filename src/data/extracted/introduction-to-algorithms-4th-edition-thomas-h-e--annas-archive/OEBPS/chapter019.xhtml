<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p520"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="19 Data Structures for Disjoint Sets">
<p class="chapter-title"><a href="toc.xhtml#chap-19"><strong><span class="blue1">19        Data Structures for Disjoint Sets</span></strong></a></p>
<p class="noindent">Some applications involve grouping <em>n</em> distinct elements into a collection of disjoint sets—sets with no elements in common. These applications often need to perform two operations in particular: finding the unique set that contains a given element and uniting two sets. This chapter explores methods for maintaining a data structure that supports these operations.</p>
<p><a href="chapter019.xhtml#Sec_19.1">Section 19.1</a> describes the operations supported by a disjoint-set data structure and presents a simple application. <a href="chapter019.xhtml#Sec_19.2">Section 19.2</a> looks at a simple linked-list implementation for disjoint sets. <a href="chapter019.xhtml#Sec_19.3">Section 19.3</a> presents a more efficient representation using rooted trees. The running time using the tree representation is theoretically superlinear, but for all practical purposes it is linear. <a href="chapter019.xhtml#Sec_19.4">Section 19.4</a> defines and discusses a very quickly growing function and its very slowly growing inverse, which appears in the running time of operations on the tree-based implementation, and then, by a complex amortized analysis, proves an upper bound on the running time that is just barely superlinear.</p>
<p class="line1"/>
<section title="19.1 Disjoint-set operations">
<a id="Sec_19.1"/>
<p class="level1" id="h1-111"><a href="toc.xhtml#Rh1-111"><strong>19.1    Disjoint-set operations</strong></a></p>
<p class="noindent">A <span class="blue"><strong><em>disjoint-set data structure</em></strong></span> maintains a collection <span class="script">S</span> = {<em>S</em><sub>1</sub>, <em>S</em><sub>2</sub>, … , <em>S<sub>k</sub></em>} of disjoint dynamic sets. To identify each set, choose a <span class="blue"><strong><em>representative</em></strong></span>, which is some member of the set. In some applications, it doesn’t matter which member is used as the representative; it matters only that if you ask for the representative of a dynamic set twice without modifying the set between the requests, you get the same answer both times. Other applications may require a prespecified rule for choosing the representative, such as choosing the smallest member in the set (for a set whose elements can be ordered).</p>
<a id="p521"/>
<p>As in the other dynamic-set implementations we have studied, each element of a set is represented by an object. Letting <em>x</em> denote an object, we’ll see how to support the following operations:</p>
<p class="para-hang1">M<small>AKE</small>-S<small>ET</small>(<em>x</em>), where <em>x</em> does not already belong to some other set, creates a new set whose only member (and thus representative) is <em>x</em>.</p>
<p class="para-hang1">U<small>NION</small>(<em>x</em>, <em>y</em>) unites two disjoint, dynamic sets that contain <em>x</em> and <em>y</em>, say <em>S<sub>x</sub></em> and <em>S<sub>y</sub></em>, into a new set that is the union of these two sets. The representative of the resulting set is any member of <em>S<sub>x</sub></em> ∪ <em>S<sub>y</sub></em>, although many implementations of U<small>NION</small> specifically choose the representative of either <em>S<sub>x</sub></em> or <em>S<sub>y</sub></em> as the new representative. Since the sets in the collection must at all times be disjoint, the U<small>NION</small> operation destroys sets <em>S<sub>x</sub></em> and <em>S<sub>y</sub></em>, removing them from the collection <span class="script">S</span>. In practice, implementations often absorb the elements of one of the sets into the other set.</p>
<p class="para-hang1">F<small>IND</small>-S<small>ET</small>(<em>x</em>) returns a pointer to the representative of the unique set containing <em>x</em>.</p>
<p class="space-break">Throughout this chapter, we’ll analyze the running times of disjoint-set data structures in terms of two parameters: <em>n</em>, the number of M<small>AKE</small>-S<small>ET</small> operations, and <em>m</em>, the total number of M<small>AKE</small>-S<small>ET</small>, U<small>NION</small>, and F<small>IND</small>-S<small>ET</small> operations. Because the total number of operations <em>m</em> includes the <em>n</em> M<small>AKE</small>-S<small>ET</small> operations, <em>m</em> ≥ <em>n</em>. The first <em>n</em> operations are always M<small>AKE</small>-S<small>ET</small> operations, so that after the first <em>n</em> operations, the collection consists of <em>n</em> singleton sets. Since the sets are disjoint at all times, each U<small>NION</small> operation reduces the number of sets by 1. After <em>n</em> − 1 U<small>NION</small> operations, therefore, only one set remains, and so at most <em>n</em> − 1 U<small>NION</small> operations can occur.</p>
<p class="level4"><strong>An application of disjoint-set data structures</strong></p>
<p class="noindent">One of the many applications of disjoint-set data structures arises in determining the connected components of an undirected graph (see <a href="appendix002.xhtml#Sec_B.4">Section B.4</a>). <a href="chapter019.xhtml#Fig_19-1">Figure 19.1(a)</a>, for example, shows a graph with four connected components.</p>
<p>The procedure C<small>ONNECTED</small>-C<small>OMPONENTS</small> on the following page uses the disjoint-set operations to compute the connected components of a graph. Once the C<small>ONNECTED</small>-C<small>OMPONENTS</small> procedure has preprocessed the graph, the procedure S<small>AME</small>-C<small>OMPONENT</small> answers queries about whether two vertices belong to the same connected component. In pseudocode, we denote the set of vertices of a graph <em>G</em> by <em>G</em>.<em>V</em> and the set of edges by <em>G</em>.<em>E</em>.</p>
<p>The procedure C<small>ONNECTED</small>-C<small>OMPONENTS</small> initially places each vertex <em>v</em> in its own set. Then, for each edge (<em>u</em>, <em>v</em>), it unites the sets containing <em>u</em> and <em>v</em>. By Exercise 19.1-2, after all the edges are processed, two vertices belong to the same connected component if and only if the objects corresponding to the vertices belong <a id="p522"/>to the same set. Thus C<small>ONNECTED</small>-C<small>OMPONENTS</small> computes sets in such a way that the procedure S<small>AME</small>-C<small>OMPONENT</small> can determine whether two vertices are in the same connected component. <a href="chapter019.xhtml#Fig_19-1">Figure 19.1(b)</a> illustrates how C<small>ONNECTED</small>-C<small>OMPONENTS</small> computes the disjoint sets.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_19-1"><img alt="art" class="width100" src="images/Art_P557.jpg"/></p>
<p class="caption"><strong>Figure 19.1 (a)</strong> A graph with four connected components: {<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>}, {<em>e</em>, <em>f</em>, <em>g</em>}, {<em>h</em>, <em>i</em>}, and {<em>j</em> }. <strong>(b)</strong> The collection of disjoint sets after processing each edge.</p>
</div>
<div class="pull-quote1">
<p class="box-heading">C<small>ONNECTED</small>-C<small>OMPONENTS</small>(<em>G</em>)</p>
<table class="table1c">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> each vertex <em>v</em> ∈ <em>G</em>.<em>V</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2">M<small>AKE</small>-S<small>ET</small>(<em>v</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> each edge (<em>u</em>, <em>v</em>) ∈ <em>G</em>.<em>E</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><strong>if</strong> F<small>IND</small>-S<small>ET</small>(<em>u</em>) ≠ F<small>IND</small>-S<small>ET</small>(<em>v</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p3">U<small>NION</small>(<em>u</em>, <em>v</em>)</p></td>
</tr>
<tr>
<td class="td1" colspan="2"><p class="box-headinga">S<small>AME</small>-C<small>OMPONENT</small>(<em>u</em>, <em>v</em>)</p></td>
</tr>
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><strong>if</strong> F<small>IND</small>-S<small>ET</small>(<em>u</em>) == F<small>IND</small>-S<small>ET</small>(<em>v</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><strong>return</strong> T<small>RUE</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="noindent"><strong>else return</strong><small>FALSE</small></p></td>
</tr>
</table>
</div>
<p>In an actual implementation of this connected-components algorithm, the representations of the graph and the disjoint-set data structure would need to reference each other. That is, an object representing a vertex would contain a pointer to the corresponding disjoint-set object, and vice versa. Since these programming details depend on the implementation language, we do not address them further here.</p>
<p>When the edges of the graph are static—not changing over time—depth-first search can compute the connected components faster (see Exercise 20.3-12 on <a id="p523"/>page 572). Sometimes, however, the edges are added dynamically, with the connected components updated as each edge is added. In this case, the implementation given here can be more efficient than running a new depth-first search for each new edge.</p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>19.1-1</em></strong></p>
<p class="noindent">The C<small>ONNECTED</small>-C<small>OMPONENTS</small> procedure is run on the undirected graph <em>G</em> = (<em>V</em>, <em>E</em>), where <em>V</em> = {<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em>, <em>f</em>, <em>g</em>, <em>h</em>, <em>i</em>, <em>j</em>, <em>k</em>}, and the edges of <em>E</em> are processed in the order (<em>d</em>, <em>i</em>), (<em>f</em>, <em>k</em>), (<em>g</em>, <em>i</em>), (<em>b</em>, <em>g</em>), (<em>a</em>, <em>h</em>), (<em>i</em>, <em>j</em>), (<em>d</em>, <em>k</em>), (<em>b</em>, <em>j</em>), (<em>d</em>, <em>f</em>), (<em>g</em>, <em>j</em>), (<em>a</em>, <em>e</em>). List the vertices in each connected component after each iteration of lines 3–5.</p>
<p class="level3"><strong><em>19.1-2</em></strong></p>
<p class="noindent">Show that after all edges are processed by C<small>ONNECTED</small>-C<small>OMPONENTS</small>, two vertices belong to the same connected component if and only if they belong to the same set.</p>
<p class="level3"><strong><em>19.1-3</em></strong></p>
<p class="noindent">During the execution of C<small>ONNECTED</small>-C<small>OMPONENTS</small> on an undirected graph <em>G</em> = (<em>V</em>, <em>E</em>) with <em>k</em> connected components, how many times is F<small>IND</small>-S<small>ET</small> called? How many times is U<small>NION</small> called? Express your answers in terms of |<em>V</em> |, |<em>E</em>|, and <em>k</em>.</p>
</section>
<p class="line1"/>
<section title="19.2 Linked-list representation of disjoint sets">
<a id="Sec_19.2"/>
<p class="level1" id="h1-112"><a href="toc.xhtml#Rh1-112"><strong>19.2    Linked-list representation of disjoint sets</strong></a></p>
<p class="noindent"><a href="chapter019.xhtml#Fig_19-2">Figure 19.2(a)</a> shows a simple way to implement a disjoint-set data structure: each set is represented by its own linked list. The object for each set has attributes <em>head</em>, pointing to the first object in the list, and <em>tail</em>, pointing to the last object. Each object in the list contains a set member, a pointer to the next object in the list, and a pointer back to the set object. Within each linked list, the objects may appear in any order. The representative is the set member in the first object in the list.</p>
<p>With this linked-list representation, both M<small>AKE</small>-S<small>ET</small> and F<small>IND</small>-S<small>ET</small> require only <em>O</em>(1) time. To carry out M<small>AKE</small>-S<small>ET</small>(<em>x</em>), create a new linked list whose only object is <em>x</em>. For F<small>IND</small>-S<small>ET</small>(<em>x</em>), just follow the pointer from <em>x</em> back to its set object and then return the member in the object that <em>head</em> points to. For example, in <a href="chapter019.xhtml#Fig_19-2">Figure 19.2(a)</a>, the call F<small>IND</small>-S<small>ET</small>(<em>g</em>) returns <em>f</em>.</p>
<a id="p524"/>
<div class="divimage">
<p class="fig-imga" id="Fig_19-2"><img alt="art" class="width100" src="images/Art_P558.jpg"/></p>
<p class="caption"><strong>Figure 19.2 (a)</strong> Linked-list representations of two sets. Set <em>S</em><sub>1</sub> contains members <em>d</em>, <em>f</em>, and <em>g</em>, with representative <em>f</em>, and set <em>S</em><sub>2</sub> contains members <em>b</em>, <em>c</em>, <em>e</em>, and <em>h</em>, with representative <em>c</em>. Each object in the list contains a set member, a pointer to the next object in the list, and a pointer back to the set object. Each set object has pointers <em>head</em> and <em>tail</em> to the first and last objects, respectively. <strong>(b)</strong> The result of U<small>NION</small>(<em>g</em>, <em>e</em>), which appends the linked list containing <em>e</em> to the linked list containing <em>g</em>. The representative of the resulting set is <em>f</em>. The set object for <em>e</em>’s list, <em>S</em><sub>2</sub>, is destroyed.</p>
</div>
<p class="level4"><strong>A simple implementation of union</strong></p>
<p class="noindent">The simplest implementation of the U<small>NION</small> operation using the linked-list set representation takes significantly more time than M<small>AKE</small>-S<small>ET</small> or F<small>IND</small>-S<small>ET</small>. As <a href="chapter019.xhtml#Fig_19-2">Figure 19.2(b)</a> shows, the operation U<small>NION</small>(<em>x</em>, <em>y</em>) appends <em>y</em>’s list onto the end of <em>x</em>’s list. The representative of <em>x</em>’s list becomes the representative of the resulting set. To quickly find where to append <em>y</em>’s list, use the <em>tail</em> pointer for <em>x</em>’s list. Because all members of <em>y</em>’s list join <em>x</em>’s list, the U<small>NION</small> operation destroys the set object for <em>y</em>’s list. The U<small>NION</small> operation is where this implementation pays the price for F<small>IND</small>-S<small>ET</small> taking constant time: U<small>NION</small> must also update the pointer to the set object for each object originally on <em>y</em>’s list, which takes time linear in the length of <em>y</em>’s list. In <a href="chapter019.xhtml#Fig_19-2">Figure 19.2</a>, for example, the operation U<small>NION</small>(<em>g</em>, <em>e</em>) causes pointers to be updated in the objects for <em>b</em>, <em>c</em>, <em>e</em>, and <em>h</em>.</p>
<p>In fact, we can construct a sequence of <em>m</em> operations on <em>n</em> objects that requires Θ(<em>n</em><sup>2</sup>) time. Starting with objects <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, … , <em>x<sub>n</sub></em>, execute the sequence of <em>n</em> M<small>AKE</small>-S<small>ET</small> operations followed by <em>n</em> − 1 U<small>NION</small> operations shown in <a href="chapter019.xhtml#Fig_19-3">Figure 19.3</a>, so that <em>m</em> = 2<em>n</em>−1. The <em>n</em> M<small>AKE</small>-S<small>ET</small> operations take Θ(<em>n</em>) time. Because the <em>i</em>th U<small>NION</small> operation updates <em>i</em> objects, the total number of objects updated by all <em>n</em>−1 U<small>NION</small> operations forms an arithmetic series:</p>
<a id="p525"/>
<div class="divimage">
<p class="fig-imga" id="Fig_19-3"><img alt="art" src="images/Art_P559.jpg"/></p>
<p class="caption"><strong>Figure 19.3</strong> A sequence of 2<em>n</em> − 1 operations on <em>n</em> objects that takes Θ(<em>n</em><sup>2</sup>) time, or Θ(<em>n</em>) time per operation on average, using the linked-list set representation and the simple implementation of U<small>NION</small>.</p>
</div>
<p class="eql"><img alt="art" src="images/Art_P560.jpg"/></p>
<p class="noindent">The total number of operations is 2<em>n</em>−1, and so each operation on average requires Θ(<em>n</em>) time. That is, the amortized time of an operation is Θ(<em>n</em>).</p>
<p class="level4"><strong>A weighted-union heuristic</strong></p>
<p class="noindent">In the worst case, the above implementation of U<small>NION</small> requires an average of Θ(<em>n</em>) time per call, because it might be appending a longer list onto a shorter list, and the procedure must update the pointer to the set object for each member of the longer list. Suppose instead that each list also includes the length of the list (which can be maintained straightforwardly with constant overhead) and that the U<small>NION</small> procedure always appends the shorter list onto the longer, breaking ties arbitrarily. With this simple <span class="blue"><strong><em>weighted-union heuristic</em></strong></span>, a single U<small>NION</small> operation can still take Ω(<em>n</em>) time if both sets have Ω(<em>n</em>) members. As the following theorem shows, however, a sequence of <em>m</em> M<small>AKE</small>-S<small>ET</small>, U<small>NION</small>, and F<small>IND</small>-S<small>ET</small> operations, <em>n</em> of which are M<small>AKE</small>-S<small>ET</small> operations, takes <em>O</em>(<em>m</em> + <em>n</em> lg <em>n</em>) time.</p>
<p class="theorem"><strong><em>Theorem 19.1</em></strong></p>
<p class="noindent">Using the linked-list representation of disjoint sets and the weighted-union heuristic, a sequence of <em>m</em> M<small>AKE</small>-S<small>ET</small>, U<small>NION</small>, and F<small>IND</small>-S<small>ET</small> operations, <em>n</em> of which are M<small>AKE</small>-S<small>ET</small> operations, takes <em>O</em>(<em>m</em> + <em>n</em> lg <em>n</em>) time.</p>
<p class="proof"><strong><em>Proof</em></strong>   Because each U<small>NION</small> operation unites two disjoint sets, at most <em>n</em> − 1 U<small>NION</small> operations occur over all. We now bound the total time taken by these <a id="p526"/>U<small>NION</small> operations. We start by determining, for each object, an upper bound on the number of times the object’s pointer back to its set object is updated. Consider a particular object <em>x</em>. Each time <em>x</em>’s pointer is updated, <em>x</em> must have started in the smaller set. The first time <em>x</em>’s pointer is updated, therefore, the resulting set must have at least 2 members. Similarly, the next time <em>x</em>’s pointer is updated, the resulting set must have had at least 4 members. Continuing on, for any <em>k</em> ≤ <em>n</em>, after <em>x</em>’s pointer has been updated <span class="font1">⌈</span>lg <em>k</em><span class="font1">⌉</span> times, the resulting set must have at least <em>k</em> members. Since the largest set has at most <em>n</em> members, each object’s pointer is updated at most <span class="font1">⌈</span>lg <em>n</em><span class="font1">⌉</span> times over all the U<small>NION</small> operations. Thus the total time spent updating object pointers over all U<small>NION</small> operations is <em>O</em>(<em>n</em> lg <em>n</em>). We must also account for updating the <em>tail</em> pointers and the list lengths, which take only Θ(1) time per U<small>NION</small> operation. The total time spent in all U<small>NION</small> operations is thus <em>O</em>(<em>n</em> lg <em>n</em>).</p>
<p>The time for the entire sequence of <em>m</em> operations follows. Each M<small>AKE</small>-S<small>ET</small> and F<small>IND</small>-S<small>ET</small> operation takes <em>O</em>(1) time, and there are <em>O</em>(<em>m</em>) of them. The total time for the entire sequence is thus <em>O</em>(<em>m</em> + <em>n</em> lg <em>n</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>19.2-1</em></strong></p>
<p class="noindent">Write pseudocode for M<small>AKE</small>-S<small>ET</small>, F<small>IND</small>-S<small>ET</small>, and U<small>NION</small> using the linked-list representation and the weighted-union heuristic. Make sure to specify the attributes that you assume for set objects and list objects.</p>
<p class="level3"><strong><em>19.2-2</em></strong></p>
<p class="noindent">Show the data structure that results and the answers returned by the F<small>IND</small>-S<small>ET</small> operations in the following program. Use the linked-list representation with the weighted-union heuristic. Assume that if the sets containing <em>x<sub>i</sub></em> and <em>x<sub>j</sub></em> have the same size, then the operation U<small>NION</small>(<em>x<sub>i</sub></em>, <em>x<sub>j</sub></em>) appends <em>x<sub>j</sub></em>’s list onto <em>x<sub>i</sub></em>’s list.</p>
<table class="table2">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> 16</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><p class="p2">M<small>AKE</small>-S<small>ET</small>(<em>x<sub>i</sub></em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> 15 <strong>by</strong> 2</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2">U<small>NION</small>(<em>x<sub>i</sub></em>, <em>x</em><sub><em>i</em>+1</sub>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> 13 <strong>by</strong> 4</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p2">U<small>NION</small>(<em>x<sub>i</sub></em>, <em>x</em><sub><em>i</em>+2</sub>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="noindent">U<small>NION</small>(<em>x</em><sub>1</sub>, <em>x</em><sub>5</sub>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="noindent">U<small>NION</small>(<em>x</em><sub>11</sub>, <em>x</em><sub>13</sub>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="noindent">U<small>NION</small>(<em>x</em><sub>1</sub>, <em>x</em><sub>10</sub>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="noindent">F<small>IND</small>-S<small>ET</small>(<em>x</em><sub>2</sub>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">11</span></td>
<td class="td1"><p class="noindent">F<small>IND</small>-S<small>ET</small>(<em>x</em><sub>9</sub>)</p></td>
</tr>
</table>
<a id="p527"/>
<p class="level3"><strong><em>19.2-3</em></strong></p>
<p class="noindent">Adapt the aggregate proof of Theorem 19.1 to obtain amortized time bounds of <em>O</em>(1) for M<small>AKE</small>-S<small>ET</small> and F<small>IND</small>-S<small>ET</small> and <em>O</em>(lg <em>n</em>) for U<small>NION</small> using the linked-list representation and the weighted-union heuristic.</p>
<p class="level3"><strong><em>19.2-4</em></strong></p>
<p class="noindent">Give a tight asymptotic bound on the running time of the sequence of operations in <a href="chapter019.xhtml#Fig_19-3">Figure 19.3</a> assuming the linked-list representation and the weighted-union heuristic.</p>
<p class="level3"><strong><em>19.2-5</em></strong></p>
<p class="noindent">Professor Gompers suspects that it might be possible to keep just one pointer in each set object, rather than two (<em>head</em> and <em>tail</em>), while keeping the number of pointers in each list element at two. Show that the professor’s suspicion is well founded by describing how to represent each set by a linked list such that each operation has the same running time as the operations described in this section. Describe also how the operations work. Your scheme should allow for the weighted-union heuristic, with the same effect as described in this section. (<em>Hint</em>: Use the tail of a linked list as its set’s representative.)</p>
<p class="level3"><strong><em>19.2-6</em></strong></p>
<p class="noindent">Suggest a simple change to the U<small>NION</small> procedure for the linked-list representation that removes the need to keep the <em>tail</em> pointer to the last object in each list. Regardless of whether the weighted-union heuristic is used, your change should not change the asymptotic running time of the U<small>NION</small> procedure. (<em>Hint</em>: Rather than appending one list to another, splice them together.)</p>
</section>
<p class="line1"/>
<section title="19.3 Disjoint-set forests">
<a id="Sec_19.3"/>
<p class="level1" id="h1-113"><a href="toc.xhtml#Rh1-113"><strong>19.3    Disjoint-set forests</strong></a></p>
<p class="noindent">A faster implementation of disjoint sets represents sets by rooted trees, with each node containing one member and each tree representing one set. In a <span class="blue"><strong><em>disjoint-set forest</em></strong></span>, illustrated in <a href="chapter019.xhtml#Fig_19-4">Figure 19.4(a)</a>, each member points only to its parent. The root of each tree contains the representative and is its own parent. As we’ll see, although the straightforward algorithms that use this representation are no faster than ones that use the linked-list representation, two heuristics—“union by rank” and “path compression”—yield an asymptotically optimal disjoint-set data structure.</p>
<p>The three disjoint-set operations have simple implementations. A M<small>AKE</small>-S<small>ET</small> operation simply creates a tree with just one node. A F<small>IND</small>-S<small>ET</small> operation follows parent pointers until it reaches the root of the tree. The nodes visited on this simple <a id="p528"/>path toward the root constitute the <span class="blue"><strong><em>find path</em></strong></span>. A U<small>NION</small> operation, shown in <a href="chapter019.xhtml#Fig_19-4">Figure 19.4(b)</a>, simply causes the root of one tree to point to the root of the other.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_19-4"><img alt="art" src="images/Art_P561.jpg"/></p>
<p class="caption"><strong>Figure 19.4</strong> A disjoint-set forest. <strong>(a)</strong> Trees representing the two sets of <a href="chapter019.xhtml#Fig_19-2">Figure 19.2</a>. The tree on the left represents the set {<em>b</em>, <em>c</em>, <em>e</em>, <em>h</em>}, with <em>c</em> as the representative, and the tree on the right represents the set {<em>d</em>, <em>f</em>, <em>g</em>}, with <em>f</em> as the representative. <strong>(b)</strong> The result of U<small>NION</small> (<em>e</em>, <em>g</em>).</p>
</div>
<p class="level4"><strong>Heuristics to improve the running time</strong></p>
<p class="noindent">So far, disjoint-set forests have not improved on the linked-list implementation. A sequence of <em>n</em> − 1 U<small>NION</small> operations could create a tree that is just a linear chain of <em>n</em> nodes. By using two heuristics, however, we can achieve a running time that is almost linear in the total number <em>m</em> of operations.</p>
<p>The first heuristic, <span class="blue"><strong><em>union by rank</em></strong></span>, is similar to the weighted-union heuristic we used with the linked-list representation. The common-sense approach is to make the root of the tree with fewer nodes point to the root of the tree with more nodes. Rather than explicitly keeping track of the size of the subtree rooted at each node, however, we’ll adopt an approach that eases the analysis. For each node, maintain a <span class="blue"><strong><em>rank</em></strong></span>, which is an upper bound on the height of the node. Union by rank makes the root with smaller rank point to the root with larger rank during a U<small>NION</small> operation.</p>
<p>The second heuristic, <span class="blue"><strong><em>path compression</em></strong></span>, is also quite simple and highly effective. As shown in <a href="chapter019.xhtml#Fig_19-5">Figure 19.5</a>, F<small>IND</small>-S<small>ET</small> operations use it to make each node on the find path point directly to the root. Path compression does not change any ranks.</p>
<p class="level4"><strong>Pseudocode for disjoint-set forests</strong></p>
<p class="noindent">The union-by-rank heuristic requires its implementation to keep track of ranks. With each node <em>x</em>, maintain the integer value <em>x</em>.<em>rank</em>, which is an upper bound on the height of <em>x</em> (the number of edges in the longest simple path from a descendant leaf to <em>x</em>). When M<small>AKE</small>-S<small>ET</small> creates a singleton set, the single node in the <a id="p529"/>corresponding tree has an initial rank of 0. Each F<small>IND</small>-S<small>ET</small> operation leaves all ranks unchanged. The U<small>NION</small> operation has two cases, depending on whether the roots of the trees have equal rank. If the roots have unequal ranks, make the root with higher rank the parent of the root with lower rank, but don’t change the ranks themselves. If the roots have equal ranks, arbitrarily choose one of the roots as the parent and increment its rank.</p>
<div class="divimage">
<p class="fig-imga" id="Fig_19-5"><img alt="art" class="width100" src="images/Art_P562.jpg"/></p>
<p class="caption"><strong>Figure 19.5</strong> Path compression during the operation F<small>IND</small>-S<small>ET</small>. Arrows and self-loops at roots are omitted. <strong>(a)</strong> A tree representing a set prior to executing F<small>IND</small>-S<small>ET</small>(<em>a</em>). Triangles represent subtrees whose roots are the nodes shown. Each node has a pointer to its parent. <strong>(b)</strong> The same set after executing F<small>IND</small>-S<small>ET</small>(<em>a</em>). Each node on the find path now points directly to the root.</p>
</div>
<p>Let’s put this method into pseudocode, appearing on the next page. The parent of node <em>x</em> is denoted by <em>x</em>.<em>p</em>. The L<small>INK</small> procedure, a subroutine called by U<small>NION</small>, takes pointers to two roots as inputs. The F<small>IND</small>-S<small>ET</small> procedure with path compression, implemented recursively, turns out to be quite simple.</p>
<p>The F<small>IND</small>-S<small>ET</small> procedure is a <span class="blue"><strong><em>two-pass method</em></strong></span>: as it recurses, it makes one pass up the find path to find the root, and as the recursion unwinds, it makes a second pass back down the find path to update each node to point directly to the root. Each call of F<small>IND</small>-S<small>ET</small>(<em>x</em>) returns <em>x</em>.<em>p</em> in line 3. If <em>x</em> is the root, then F<small>IND</small>-S<small>ET</small> skips line 2 and just returns <em>x</em>.<em>p</em>, which is <em>x</em>. In this case the recursion bottoms out. Otherwise, line 2 executes, and the recursive call with parameter <em>x</em>.<em>p</em> returns <a id="p530"/>a pointer to the root. Line 2 updates node <em>x</em> to point directly to the root, and line 3 returns this pointer.</p>
<div class="pull-quote1">
<p class="box-heading">M<small>AKE</small>-S<small>ET</small>(<em>x</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><em>x</em>.<em>p</em> = <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="noindent"><em>x</em>.<em>rank</em> = 0</p></td>
</tr>
</table>
<p class="box-headinga">U<small>NION</small>(<em>x</em>, <em>y</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent">L<small>INK</small>(F<small>IND</small>-S<small>ET</small>(<em>x</em>), F<small>IND</small>-S<small>ET</small>(<em>y</em>))</p></td>
</tr>
</table>
<p class="box-headinga">L<small>INK</small>(<em>x</em>, <em>y</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>x</em>.<em>rank &gt; y</em>.<em>rank</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><em>y</em>.<em>p</em> = <em>x</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="noindent"><strong>else</strong> <em>x</em>.<em>p</em> = <em>y</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>x</em>.<em>rank</em> == <em>y</em>.<em>rank</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p3"><em>y</em>.<em>rank</em> = <em>y</em>.<em>rank</em> + 1</p></td>
</tr>
</table>
<p class="box-headinga">F<small>IND</small>-S<small>ET</small>(<em>x</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>x</em> ≠ <em>x</em>.<em>p</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> not the root?</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><em>x</em>.<em>p</em> = F<small>IND</small>-S<small>ET</small>(<em>x</em>.<em>p</em>)</p></td>
<td class="td1"><span class="red"><strong>//</strong> the root becomes the parent</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>x</em>.<em>p</em></p></td>
<td class="td1"><span class="red"><strong>//</strong> return the root</span></td>
</tr>
</table>
</div>
<p class="level4"><strong>Effect of the heuristics on the running time</strong></p>
<p class="noindent">Separately, either union by rank or path compression improves the running time of the operations on disjoint-set forests, and combining the two heuristics yields an even greater improvement. Alone, union by rank yields a running time of <em>O</em>(<em>m</em> lg <em>n</em>) for a sequence of <em>m</em> operations, <em>n</em> of which are M<small>AKE</small>-S<small>ET</small> (see Exercise 19.4-4), and this bound is tight (see Exercise 19.3-3). Although we won’t prove it here, for a sequence of <em>n</em> M<small>AKE</small>-S<small>ET</small> operations (and hence at most <em>n</em> − 1 U<small>NION</small> operations) and <em>f</em> F<small>IND</small>-S<small>ET</small> operations, the worst-case running time using only the path-compression heuristic is Θ(<em>n</em> + <em>f</em> · (1 + log<sub>2+<em>f</em>/<em>n</em></sub><em>n</em>)).</p>
<p>Combining union by rank and path compression gives a worst-case running time of <em>O</em>(<em>m α</em>(<em>n</em>)), where <em>α</em>(<em>n</em>) is a <em>very</em> slowly growing function, defined in <a href="chapter019.xhtml#Sec_19.4">Section 19.4</a>. In any conceivable application of a disjoint-set data structure, <em>α</em>(<em>n</em>) ≤ 4, and thus, its running time is as good as linear in <em>m</em> for all practical purposes. Mathematically speaking, however, it is superlinear. <a href="chapter019.xhtml#Sec_19.4">Section 19.4</a> proves this <em>O</em>(<em>mα</em>(<em>n</em>)) upper bound.</p>
<a id="p531"/>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>19.3-1</em></strong></p>
<p class="noindent">Redo Exercise 19.2-2 using a disjoint-set forest with union by rank and path compression. Show the resulting forest with each node including its <em>x<sub>i</sub></em> and rank.</p>
<p class="level3"><strong><em>19.3-2</em></strong></p>
<p class="noindent">Write a nonrecursive version of F<small>IND</small>-S<small>ET</small> with path compression.</p>
<p class="level3"><strong><em>19.3-3</em></strong></p>
<p class="noindent">Give a sequence of <em>m</em> M<small>AKE</small>-S<small>ET</small>, U<small>NION</small>, and F<small>IND</small>-S<small>ET</small> operations, <em>n</em> of which are M<small>AKE</small>-S<small>ET</small> operations, that takes Ω(<em>m</em> lg <em>n</em>) time when using only union by rank and not path compression.</p>
<p class="level3"><strong><em>19.3-4</em></strong></p>
<p class="noindent">Consider the operation P<small>RINT</small>-S<small>ET</small>(<em>x</em>), which is given a node <em>x</em> and prints all the members of <em>x</em>’s set, in any order. Show how to add just a single attribute to each node in a disjoint-set forest so that P<small>RINT</small>-S<small>ET</small>(<em>x</em>) takes time linear in the number of members of <em>x</em>’s set and the asymptotic running times of the other operations are unchanged. Assume that you can print each member of the set in <em>O</em>(1) time.</p>
<p class="level3"><span class="font1">★</span> <strong><em>19.3-5</em></strong></p>
<p class="noindent">Show that any sequence of <em>m</em> M<small>AKE</small>-S<small>ET</small>, F<small>IND</small>-S<small>ET</small>, and L<small>INK</small> operations, where all the L<small>INK</small> operations appear before any of the F<small>IND</small>-S<small>ET</small> operations, takes only <em>O</em>(<em>m</em>) time when using both path compression and union by rank. You may assume that the arguments to L<small>INK</small> are roots within the disjoint-set forest. What happens in the same situation when using only path compression and not union by rank?</p>
</section>
<p class="line1"/>
<section title="⋆ 19.4 Analysis of union by rank with path compression">
<a id="Sec_19.4"/>
<p class="level1-1" id="h1-114"><a href="toc.xhtml#Rh1-114"><span class="font1">★</span> <strong>19.4 Analysis of union by rank with path compression</strong></a></p>
<p class="noindent">As noted in <a href="chapter019.xhtml#Sec_19.3">Section 19.3</a>, the combined union-by-rank and path-compression heuristic runs in <em>O</em>(<em>m α</em>(<em>n</em>)) time for <em>m</em> disjoint-set operations on <em>n</em> elements. In this section, we’ll explore the function <em>α</em> to see just how slowly it grows. Then we’ll analyze the running time using the potential method of amortized analysis.</p>
<p class="level4"><strong>A very quickly growing function and its very slowly growing inverse</strong></p>
<p class="noindent">For integers <em>j</em>, <em>k</em> ≥ 0, we define the function <em>A<sub>k</sub></em>(<em>j</em>) as</p>
<a id="p532"/>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P563.jpg"/></p>
<p class="noindent">where the expression <img alt="art" src="images/Art_P564.jpg"/> uses the functional-iteration notation defined in equation (3.30) on page 68. Specifically, equation (3.30) gives <img alt="art" src="images/Art_P565.jpg"/> and <img alt="art" src="images/Art_P566.jpg"/> for <em>i</em> ≥ 1. We call the parameter <em>k</em> the <span class="blue"><strong><em>level</em></strong></span> of the function <em>A</em>.</p>
<p>The function <em>A<sub>k</sub></em>(<em>j</em>) strictly increases with both <em>j</em> and <em>k</em>. To see just how quickly this function grows, we first obtain closed-form expressions for <em>A</em><sub>1</sub>(<em>j</em>) and <em>A</em><sub>2</sub>(<em>j</em>).</p>
<p class="lemma"><strong><em>Lemma 19.2</em></strong></p>
<p class="noindent">For any integer <em>j</em> ≥ 1, we have <em>A</em><sub>1</sub>(<em>j</em>) = 2<em>j</em> + 1.</p>
<p class="proof"><strong><em>Proof</em></strong>   We first use induction on <em>i</em> to show that <img alt="art" src="images/Art_P567.jpg"/>. For the base case, <img alt="art" src="images/Art_P568.jpg"/>. For the inductive step, assume that <img alt="art" src="images/Art_P569.jpg"/>. Then <img alt="art" src="images/Art_P570.jpg"/>. Finally, we note that <img alt="art" src="images/Art_P571.jpg"/>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="lemma"><strong><em>Lemma 19.3</em></strong></p>
<p class="noindent">For any integer <em>j</em> ≥ 1, we have <em>A</em><sub>2</sub> (<em>j</em>) = 2<sup><em>j</em>+1</sup>(<em>j</em> + 1) − 1.</p>
<p class="proof"><strong><em>Proof</em></strong>   We first use induction on <em>i</em> to show that <img alt="art" src="images/Art_P572.jpg"/>. For the base case, we have <img alt="art" src="images/Art_P573.jpg"/>. For the inductive step, assume that <img alt="art" src="images/Art_P574.jpg"/>. Then <img alt="art" src="images/Art_P575.jpg"/>. Finally, we note that <img alt="art" src="images/Art_P576.jpg"/>.</p>
<p class="space-break">Now we can see how quickly <em>A<sub>k</sub></em>(<em>j</em>) grows by simply examining <em>A<sub>k</sub></em>(1) for levels <em>k</em> = 0, 1, 2, 3, 4. From the definition of <em>A</em><sub>0</sub>(<em>j</em>) and the above lemmas, we have <em>A</em><sub>0</sub>(1) = 1 + 1 = 2, <em>A</em><sub>1</sub>(1) = 2<em> ·</em> 1 + 1 = 3, and <em>A</em><sub>2</sub>(1) = 2<sup>1+1</sup> · (1 + 1) − 1 = 7. We also have</p>
<table class="table2b">
<tr>
<td class="td2"><em>A</em><sub>3</sub>(1)</td>
<td class="td2">=</td>
<td class="td2"><img alt="art" src="images/Art_P577.jpg"/></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>A</em><sub>2</sub>(<em>A</em><sub>2</sub>(1))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>A</em><sub>2</sub>(7)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">2<sup>8</sup> · 8 − 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">2<sup>11</sup> − 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">2047</td>
</tr>
</table>
<a id="p533"/>
<p class="noindent">and</p>
<table class="table2b">
<tr>
<td class="td2"><em>A</em><sub>4</sub>(1)</td>
<td class="td2">=</td>
<td class="td2"><img alt="art" src="images/Art_P578.jpg"/></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>A</em><sub>3</sub>(<em>A</em><sub>3</sub>(1))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>A</em><sub>3</sub>(2047)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><img alt="art" src="images/Art_P579.jpg"/></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2"><span class="font1">≫</span></td>
<td class="td2"><em>A</em><sub>2</sub>(2047)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">2<sup>2048</sup> · 2048 − 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">2<sup>2059</sup> − 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">&gt;</td>
<td class="td2">2<sup>2056</sup></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">(2<sup>4</sup>)<sup>514</sup></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">16<sup>514</sup></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2"><span class="font1">≫</span></td>
<td class="td2">10<sup>80</sup>,</td>
</tr>
</table>
<p class="noindent">which is the estimated number of atoms in the observable universe. (The symbol “<span class="font1">≫</span>” denotes the “much-greater-than” relation.)</p>
<p>We define the inverse of the function <em>A<sub>k</sub></em>(<em>n</em>), for integer <em>n</em> ≥ 0, by</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P580.jpg"/></p>
<p class="noindent">In words, <em>α</em>(<em>n</em>) is the lowest level <em>k</em> for which <em>A<sub>k</sub></em>(1) is at least <em>n</em>. From the above values of <em>A<sub>k</sub></em>(1), we see that</p>
<p class="eql"><img alt="art" src="images/Art_P581.jpg"/></p>
<p class="noindent">It is only for values of <em>n</em> so large that the term “astronomical” understates them (greater than <em>A</em><sub>4</sub>(1), a huge number) that <em>α</em>(<em>n</em>) &gt; 4, and so <em>α</em>(<em>n</em>) ≤ 4 for all practical purposes.</p>
<p class="level4"><strong>Properties of ranks</strong></p>
<p class="noindent">In the remainder of this section, we prove an <em>O</em>(<em>mα</em>(<em>n</em>)) bound on the running time of the disjoint-set operations with union by rank and path compression. In order to prove this bound, we first prove some simple properties of ranks.</p>
<p class="lemma"><strong><em>Lemma 19.4</em></strong></p>
<p class="noindent">For all nodes <em>x</em>, we have <em>x</em>.<em>rank</em> ≤ <em>x</em>.<em>p</em>.<em>rank</em>, with strict inequality if <em>x</em> ≠ <em>x</em>.<em>p</em> (<em>x</em> is not a root). The value of <em>x</em>.<em>rank</em> is initially 0, increases through time until <em>x</em> ≠ <em>x</em>.<em>p</em>, <a id="p534"/>and from then on, <em>x</em>.<em>rank</em> does not change. The value of <em>x</em>.<em>p</em>.<em>rank</em> monotonically increases over time.</p>
<p class="proof"><strong><em>Proof</em></strong>   The proof is a straightforward induction on the number of operations, using the implementations of M<small>AKE</small>-S<small>ET</small>, U<small>NION</small>, and F<small>IND</small>-S<small>ET</small> that appear on page 530, and is left as Exercise 19.4-1.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 19.5</em></strong></p>
<p class="noindent">On the simple path from any node going up toward a root, node ranks strictly increase.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="lemma"><strong><em>Lemma 19.6</em></strong></p>
<p class="noindent">Every node has rank at most <em>n</em> − 1.</p>
<p class="proof"><strong><em>Proof</em></strong>   Each node’s rank starts at 0, and it increases only upon L<small>INK</small> operations. Because there are at most <em>n</em> − 1 U<small>NION</small> operations, there are also at most <em>n</em> − 1 L<small>INK</small> operations. Because each L<small>INK</small> operation either leaves all ranks alone or increases some node’s rank by 1, all ranks are at most <em>n</em> − 1.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Lemma 19.6 provides a weak bound on ranks. In fact, every node has rank at most <span class="font1">⌊</span>lg <em>n</em><span class="font1">⌋</span> (see Exercise 19.4-2). The looser bound of Lemma 19.6 suffices for our purposes, however.</p>
<p class="level4"><strong>Proving the time bound</strong></p>
<p class="noindent">In order to prove the <em>O</em>(<em>mα</em>(<em>n</em>)) time bound, we’ll use the potential method of amortized analysis from <a href="chapter016.xhtml#Sec_16.3">Section 16.3</a>. In performing the amortized analysis, it will be convenient to assume that we invoke the L<small>INK</small> operation rather than the U<small>NION</small> operation. That is, since the parameters of the L<small>INK</small> procedure are pointers to two roots, we act as though we perform the appropriate F<small>IND</small>-S<small>ET</small> operations separately. The following lemma shows that even if we count the extra F<small>IND</small>-S<small>ET</small> operations induced by U<small>NION</small> calls, the asymptotic running time remains unchanged.</p>
<p class="lemma"><strong><em>Lemma 19.7</em></strong></p>
<p class="noindent">Suppose that we convert a sequence <em>S</em>′ of <em>m</em>′ M<small>AKE</small>-S<small>ET</small>, U<small>NION</small>, and F<small>IND</small>-S<small>ET</small> operations into a sequence <em>S</em> of <em>m</em> M<small>AKE</small>-S<small>ET</small>, L<small>INK</small>, and F<small>IND</small>-S<small>ET</small> operations by turning each U<small>NION</small> into two F<small>IND</small>-S<small>ET</small> operations followed by one L<small>INK</small>. Then, if sequence <em>S</em> runs in <em>O</em>(<em>mα</em>(<em>n</em>)) time, sequence <em>S</em>′ runs in <em>O</em>(<em>m</em>′ <em>α</em>(<em>n</em>)) time.</p>
<p class="proof"><strong><em>Proof</em></strong>   Since each U<small>NION</small> operation in sequence <em>S</em>′ is converted into three operations in <em>S</em>, we have <em>m</em>′ ≤ <em>m</em> ≤ 3<em>m</em>′, so that <em>m</em> = Θ(<em>m</em>′), Thus, an <em>O</em>(<em>m α</em>(<em>n</em>)) <a id="p535"/>time bound for the converted sequence <em>S</em> implies an <em>O</em>(<em>m</em>′ <em>α</em>(<em>n</em>)) time bound for the original sequence <em>S</em>′.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">From now on, we assume that the initial sequence of <em>m</em>′ M<small>AKE</small>-S<small>ET</small>, U<small>NION</small>, and F<small>IND</small>-S<small>ET</small> operations has been converted to a sequence of <em>m</em> M<small>AKE</small>-S<small>ET</small>, L<small>INK</small>, and F<small>IND</small>-S<small>ET</small> operations. We now prove an <em>O</em>(<em>m α</em>(<em>n</em>)) time bound for the converted sequence and appeal to Lemma 19.7 to prove the <em>O</em>(<em>m</em>′ <em>α</em>(<em>n</em>)) running time of the original sequence of <em>m</em>′ operations.</p>
<p class="level4"><strong>Potential function</strong></p>
<p class="noindent">The potential function we use assigns a potential <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>x</em>) to each node <em>x</em> in the disjoint-set forest after <em>q</em> operations. For the potential Φ<em><sub>q</sub></em> of the entire forest after <em>q</em> operations, sum the individual node potentials: <img alt="art" src="images/Art_P582.jpg"/>. Because the forest is empty before the first operation, the sum is taken over an empty set, and so Φ<sub>0</sub> = 0. No potential Φ<em><sub>q</sub></em> is ever negative.</p>
<p>The value of <em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>) depends on whether <em>x</em> is a tree root after the <em>q</em>th operation. If it is, or if <em>x</em>.<em>rank</em> = 0, then <em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>) = <em>α</em>(<em>n</em>) · <em>x</em>.<em>rank</em>.</p>
<p>Now suppose that after the <em>q</em>th operation, <em>x</em> is not a root and that <em>x</em>.<em>rank</em> ≥ 1. We need to define two auxiliary functions on <em>x</em> before we can define <em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>). First we define</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P583.jpg"/></p>
<p class="noindent">That is, level(<em>x</em>) is the greatest level <em>k</em> for which <em>A<sub>k</sub></em>, applied to <em>x</em>’s rank, is no greater than <em>x</em>’s parent’s rank.</p>
<p>We claim that</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P584.jpg"/></p>
<p class="noindent">which we see as follows. We have</p>
<table class="table2b">
<tr>
<td class="td2"><em>x</em>.<em>p</em>.<em>rank</em></td>
<td class="td2">≥</td>
<td class="td2"><em>x</em>.<em>rank</em> + 1</td>
<td class="td2">(by Lemma 19.4 because <em>x</em> is not a root)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>A</em><sub>0</sub>(<em>x</em>.<em>rank</em>)</td>
<td class="td2">(by the definition (19.1) of <em>A</em><sub>0</sub>(<em>j</em>)),</td>
</tr>
</table>
<p class="noindent">which implies that level(<em>x</em>) ≥ 0, and</p>
<table class="table2b">
<tr>
<td class="td2"><em>A</em><sub><em>α</em>(<em>n</em>)</sub>(<em>x</em>.<em>rank</em>)</td>
<td class="td2">≥</td>
<td class="td2"><em>A</em><sub><em>α</em>(<em>n</em>)</sub>(1)</td>
<td class="td2">(because <em>A<sub>k</sub></em>(<em>j</em>) is strictly increasing)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2"><em>n</em></td>
<td class="td2">(by the definition (19.2) of <em>α</em>(<em>n</em>))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">&gt;</td>
<td class="td2"><em>x</em>.<em>p</em>.<em>rank</em></td>
<td class="td2">(by Lemma 19.6),</td>
</tr>
</table>
<p class="noindent">which implies that level(<em>x</em>) &lt; <em>α</em>(<em>n</em>).</p>
<p>For a given nonroot node <em>x</em>, the value of level(<em>x</em>) monotonically increases over time. Why? Because <em>x</em> is not a root, its rank does not change. The rank of <em>x</em>.<em>p</em> <a id="p536"/>monotonically increases over time, since if <em>x</em>.<em>p</em> is not a root then its rank does not change, and if <em>x</em>.<em>p</em> is a root then its rank can never decrease. Thus, the difference between <em>x</em>.<em>rank</em> and <em>x</em>.<em>p</em>.<em>rank</em> monotonically increases over time. Therefore, the value of <em>k</em> needed for <em>A<sub>k</sub></em>(<em>x</em>.<em>rank</em>) to overtake <em>x</em>.<em>p</em>.<em>rank</em> monotonically increases over time as well.</p>
<p>The second auxiliary function applies when <em>x</em>.<em>rank</em> ≥ 1: iter(<em>x</em>) = max</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P585.jpg"/></p>
<p class="noindent">That is, iter(<em>x</em>) is the largest number of times we can iteratively apply <em>A</em><sub>level(<em>x</em>)</sub>, applied initially to <em>x</em>’s rank, before exceeding <em>x</em>’s parent’s rank.</p>
<p>We claim that when <em>x</em>.<em>rank</em> ≥ 1, we have</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P586.jpg"/></p>
<p class="noindent">which we see as follows. We have</p>
<table class="table2b">
<tr>
<td class="td2"><em>x</em>.<em>p</em>.<em>rank</em></td>
<td class="td2">≥</td>
<td class="td2"><em>A</em><sub>level(<em>x</em>)</sub>(<em>x</em>.<em>rank</em>)</td>
<td class="td2">(by the definition (19.3) of level(<em>x</em>))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><img alt="art" src="images/Art_P587.jpg"/></td>
<td class="td2">(by the definition (3.30) of functional iteration),</td>
</tr>
</table>
<p class="noindent">which implies that iter(<em>x</em>) ≥ 1. We also have</p>
<table class="table2b">
<tr>
<td class="td2"><img alt="art" src="images/Art_P588.jpg"/></td>
<td class="td2">=</td>
<td class="td2"><em>A</em><sub>level(<em>x</em>)+1</sub>(<em>x</em>.<em>rank</em>)</td>
<td class="td2">(by the definition (19.1) of <em>A<sub>k</sub></em>(<em>j</em>))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">&gt;</td>
<td class="td2"><em>x</em>.<em>p</em>.<em>rank</em></td>
<td class="td2">(by the definition (19.3) of level(<em>x</em>)),</td>
</tr>
</table>
<p class="noindent">which implies that iter(<em>x</em>) ≤ <em>x</em>.<em>rank</em>. Note that because <em>x</em>.<em>p</em>.<em>rank</em> monotonically increases over time, in order for iter(<em>x</em>) to decrease, level(<em>x</em>) must increase. As long as level(<em>x</em>) remains unchanged, iter(<em>x</em>) must either increase or remain unchanged.</p>
<p>With these auxiliary functions in place, we are ready to define the potential of node <em>x</em> after <em>q</em> operations:</p>
<p class="eqr"><img alt="art" class="width100" src="images/Art_P589.jpg"/></p>
<p class="noindent">We next investigate some useful properties of node potentials.</p>
<p class="lemma"><strong><em>Lemma 19.8</em></strong></p>
<p class="noindent">For every node <em>x</em>, and for all operation counts <em>q</em>, we have</p>
<p class="eql">0 ≤ <em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>) ≤ <em>α</em>(<em>n</em>) · <em>x</em>.<em>rank</em>.</p>
<p class="proof"><strong><em>Proof</em></strong>   If <em>x</em> is a root or <em>x</em>.<em>rank</em> = 0, then <em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>) = <em>α</em>(<em>n</em>) · <em>x</em>.<em>rank</em> by definition. Now suppose that <em>x</em> is not a root and that <em>x</em>.<em>rank</em> ≥ 1. We can obtain a lower bound on <em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>) by maximizing level(<em>x</em>) and iter(<em>x</em>). The bounds (19.4) and (19.6) give <em>α</em>(<em>n</em>) − level(<em>x</em>) ≥ 1 and iter(<em>x</em>) ≤ <em>x</em>.<em>rank</em>. Thus, we have</p>
<a id="p537"/>
<table class="table2b">
<tr>
<td class="td2"><em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>)</td>
<td class="td2">=</td>
<td class="td2">(<em>α</em>(<em>n</em>) − level(<em>x</em>)) · <em>x</em>.<em>rank</em> − iter(<em>x</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2"><em>x</em>.<em>rank</em> − <em>x</em>.<em>rank</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">0.</td>
</tr>
</table>
<p class="noindent">Similarly, minimizing level(<em>x</em>) and iter(<em>x</em>) provides an upper bound on <em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>). By the bound (19.4), level(<em>x</em>) ≥ 0, and by the bound (19.6), iter(<em>x</em>) ≥ 1. Thus, we have</p>
<table class="table2b">
<tr>
<td class="td2"><em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>)</td>
<td class="td2">≤</td>
<td class="td2">(<em>α</em>(<em>n</em>) − 0) · <em>x</em>.<em>rank</em> − 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>α</em>(<em>n</em>) · <em>x</em>.<em>rank</em> − 1</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">&lt;</td>
<td class="td2"><em>α</em>(<em>n</em>) · <em>x</em>.<em>rank</em>.</td>
</tr>
</table>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 19.9</em></strong></p>
<p class="noindent">If node <em>x</em> is not a root and <em>x</em>.<em>rank &gt;</em> 0, then <em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>) &lt; <em>α</em>(<em>n</em>) · <em>x</em>.<em>rank</em>.</p>
<p class="level4"><strong>Potential changes and amortized costs of operations</strong></p>
<p class="noindent">We are now ready to examine how the disjoint-set operations affect node potentials. Once we understand how each operation can change the potential, we can determine the amortized costs.</p>
<p class="lemma"><strong><em>Lemma 19.10</em></strong></p>
<p class="noindent">Let <em>x</em> be a node that is not a root, and suppose that the <em>q</em>th operation is either a L<small>INK</small> or a F<small>IND</small>-S<small>ET</small>. Then after the <em>q</em>th operation, <em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>) ≤ <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>x</em>). Moreover, if <em>x</em>.<em>rank</em> ≥ 1 and either level(<em>x</em>) or iter(<em>x</em>) changes due to the <em>q</em>th operation, then <em><span class="symbolfont">ϕ</span><sub>q</sub></em>(<em>x</em>) ≤ <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>x</em>) − 1. That is, <em>x</em>’s potential cannot increase, and if it has positive rank and either level(<em>x</em>) or iter(<em>x</em>) changes, then <em>x</em>’s potential drops by at least 1.</p>
<p class="proof"><strong><em>Proof</em></strong>   Because <em>x</em> is not a root, the <em>q</em>th operation does not change <em>x</em>.<em>rank</em>, and because <em>n</em> does not change after the initial <em>n</em> M<small>AKE</small>-S<small>ET</small> operations, <em>α</em>(<em>n</em>) remains unchanged as well. Hence, these components of the formula for <em>x</em>’s potential remain the same after the <em>q</em>th operation. If <em>x</em>.<em>rank</em> = 0, then <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>x</em>) = <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>x</em>) = 0.</p>
<p>Now assume that <em>x</em>.<em>rank</em> ≥ 1. Recall that level(<em>x</em>) monotonically increases over time. If the <em>q</em>th operation leaves level(<em>x</em>) unchanged, then iter(<em>x</em>) either increases or remains unchanged. If both level(<em>x</em>) and iter(<em>x</em>) are unchanged, then <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>x</em>) = <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>x</em>). If level(<em>x</em>) is unchanged and iter(<em>x</em>) increases, then it increases by at least 1, and so <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>x</em>) ≤ <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>x</em>) − 1.</p>
<p>Finally, if the <em>q</em>th operation increases level(<em>x</em>), it increases by at least 1, so that the value of the term (<em>α</em>(<em>n</em>) − level(<em>x</em>)) · <em>x</em>.<em>rank</em> drops by at least <em>x</em>.<em>rank</em>. Because level(<em>x</em>) increased, the value of iter(<em>x</em>) might drop, but according to the bound (19.6), the drop is by at most <em>x</em>.<em>rank</em> − 1. Thus, the increase in potential <a id="p538"/>due to the change in iter(<em>x</em>) is less than the decrease in potential due to the change in level(<em>x</em>), yielding <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>x</em>) ≤ <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>x</em>) − 1.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Our final three lemmas show that the amortized cost of each M<small>AKE</small>-S<small>ET</small>, L<small>INK</small>, and F<small>IND</small>-S<small>ET</small> operation is <em>O</em>(<em>α</em>(<em>n</em>)). Recall from equation (16.2) on page 456 that the amortized cost of each operation is its actual cost plus the change in potential due to the operation.</p>
<p class="lemma"><strong><em>Lemma 19.11</em></strong></p>
<p class="noindent">The amortized cost of each M<small>AKE</small>-S<small>ET</small> operation is <em>O</em>(1).</p>
<p class="proof"><strong><em>Proof</em></strong>   Suppose that the <em>q</em>th operation is M<small>AKE</small>-S<small>ET</small>(<em>x</em>). This operation creates node <em>x</em> with rank 0, so that <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>x</em>) = 0. No other ranks or potentials change, and so Φ<em><sub>q</sub></em> = Φ<sub><em>q</em>−1</sub>. Noting that the actual cost of the M<small>AKE</small>-S<small>ET</small> operation is <em>O</em>(1) completes the proof.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="lemma"><strong><em>Lemma 19.12</em></strong></p>
<p class="noindent">The amortized cost of each L<small>INK</small> operation is <em>O</em>(<em>α</em>(<em>n</em>)).</p>
<p class="proof"><strong><em>Proof</em></strong>   Suppose that the <em>q</em>th operation is L<small>INK</small>(<em>x</em>, <em>y</em>). The actual cost of the L<small>INK</small> operation is <em>O</em>(1). Without loss of generality, suppose that the L<small>INK</small> makes <em>y</em> the parent of <em>x</em>.</p>
<p>To determine the change in potential due to the L<small>INK</small>, note that the only nodes whose potentials may change are <em>x</em>, <em>y</em>, and the children of <em>y</em> just prior to the operation. We’ll show that the only node whose potential can increase due to the L<small>INK</small> is <em>y</em>, and that its increase is at most <em>α</em>(<em>n</em>):</p>
<ul class="ulnoindent" epub:type="list">
<li>By Lemma 19.10, any node that is <em>y</em>’s child just before the L<small>INK</small> cannot have its potential increase due to the L<small>INK</small>.</li>
<li class="litop">From the definition (19.7) of <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>x</em>), note that, since <em>x</em> was a root just before the <em>q</em>th operation, <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>x</em>) = <em>α</em>(<em>n</em>) · <em>x</em>.<em>rank</em> at that time. If <em>x</em>.<em>rank</em> = 0, then <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>x</em>) = <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>x</em>) = 0. Otherwise,
<table class="table2b">
<tr>
<td class="td2"><em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>x</em>)</td>
<td class="td2">&lt;</td>
<td class="td2"><em>α</em>(<em>n</em>) · <em>x</em>.<em>rank</em></td>
<td class="td2">(by Corollary 19.9)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>x</em>),</td>
<td class="td2"/>
</tr>
</table>
<p class="noindent">and so <em>x</em>’s potential decreases.</p>
</li>
<li class="litop">Because <em>y</em> is a root prior to the L<small>INK</small>, <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>y</em>) = <em>α</em>(<em>n</em>) · <em>y</em>.<em>rank</em>. After the L<small>INK</small> operation, <em>y</em> remains a root, so that <em>y</em>’s potential still equals <em>α</em>(<em>n</em>) times its rank after the operation. The L<small>INK</small> operation either leaves <em>y</em>’s rank alone or increases <em>y</em>’s rank by 1. Therefore, either <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>y</em>) = <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>y</em>) or <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>y</em>) = <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>y</em>) + <em>α</em>(<em>n</em>).</li></ul>
<a id="p539"/>
<p>The increase in potential due to the L<small>INK</small> operation, therefore, is at most <em>α</em>(<em>n</em>). The amortized cost of the L<small>INK</small> operation is <em>O</em>(1) + <em>α</em>(<em>n</em>) = <em>O</em>(<em>α</em>(<em>n</em>)).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="lemma"><strong><em>Lemma 19.13</em></strong></p>
<p class="noindent">The amortized cost of each F<small>IND</small>-S<small>ET</small> operation is <em>O</em>(<em>α</em>(<em>n</em>)).</p>
<p class="proof"><strong><em>Proof</em></strong>   Suppose that the <em>q</em>th operation is a F<small>IND</small>-S<small>ET</small> and that the find path contains <em>s</em> nodes. The actual cost of the F<small>IND</small>-S<small>ET</small> operation is <em>O</em>(<em>s</em>). We will show that no node’s potential increases due to the F<small>IND</small>-S<small>ET</small> and that at least max {0, <em>s</em> − (<em>α</em>(<em>n</em>) + 2)} nodes on the find path have their potential decrease by at least 1.</p>
<p>We first show that no node’s potential increases. Lemma 19.10 takes care of all nodes other than the root. If <em>x</em> is the root, then its potential is <em>α</em>(<em>n</em>) · <em>x</em>.<em>rank</em>, which does not change due to the F<small>IND</small>-S<small>ET</small> operation.</p>
<p>Now we show that at least max {0, <em>s</em> − (<em>α</em>(<em>n</em>) + 2)} nodes have their potential decrease by at least 1. Let <em>x</em> be a node on the find path such that <em>x</em>.<em>rank &gt;</em> 0 and <em>x</em> is followed somewhere on the find path by another node <em>y</em> that is not a root, where level(<em>y</em>) = level(<em>x</em>) just before the F<small>IND</small>-S<small>ET</small> operation. (Node <em>y</em> need not <em>immediately</em> follow <em>x</em> on the find path.) All but at most <em>α</em>(<em>n</em>) + 2 nodes on the find path satisfy these constraints on <em>x</em>. Those that do not satisfy them are the first node on the find path (if it has rank 0), the last node on the path (i.e., the root), and the last node <em>w</em> on the path for which level(<em>w</em>) = <em>k</em>, for each <em>k</em> = 0, 1, 2, … , <em>α</em>(<em>n</em>)−1.</p>
<p>Consider such a node <em>x</em>. It has positive rank and is followed somewhere on the find path by nonroot node <em>y</em> such that level(<em>y</em>) = level(<em>x</em>) before the path compression occurs. We claim that the path compression decreases <em>x</em>’s potential by at least 1. To prove this claim, let <em>k</em> = level(<em>x</em>) = level(<em>y</em>) and <em>i</em> = iter(<em>x</em>) before the path compression occurs. Just prior to the path compression caused by the F<small>IND</small>-S<small>ET</small>, we have</p>
<table class="table2b">
<tr>
<td class="td2"><p class="right"><em>x</em>.<em>p</em>.<em>rank</em></p></td>
<td class="td2">≥</td>
<td class="td2"><img alt="art" src="images/Art_P590.jpg"/></td>
<td class="td2"><p class="para-hang">(by the definition (19.5) of iter(<em>x</em>)),</p></td>
</tr>
<tr>
<td class="td2"><p class="right"><em>y</em>.<em>p</em>.<em>rank</em></p></td>
<td class="td2">≥</td>
<td class="td2"><em>A<sub>k</sub></em>(<em>y</em>.<em>rank</em>)</td>
<td class="td2"><p class="para-hang">(by the definition (19.3) of level(<em>y</em>)),</p></td>
</tr>
<tr>
<td class="td2"><p class="right"><em>y</em>.<em>rank</em></p></td>
<td class="td2">≥</td>
<td class="td2"><em>x</em>.<em>p</em>.<em>rank</em></td>
<td class="td2"><p class="para-hang">(by Corollary 19.5 and because <em>y</em> follows <em>x</em> on the find path).</p></td>
</tr>
</table>
<p class="noindent">Putting these inequalities together gives</p>
<table class="table2b">
<tr>
<td class="td2"><em>y</em>.<em>p</em>.<em>rank</em></td>
<td class="td2">≥</td>
<td class="td2"><em>A<sub>k</sub></em>(<em>y</em>.<em>rank</em>)</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2"><em>A<sub>k</sub></em>(<em>x</em>.<em>p</em>.<em>rank</em>)</td>
<td class="td2">(because <em>A<sub>k</sub></em>(<em>j</em>) is strictly increasing)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2"><img alt="art" src="images/Art_P591.jpg"/></td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><img alt="art" src="images/Art_P592.jpg"/></td>
<td class="td2">(by the definition (3.30) of functional iteration).</td>
</tr>
</table>
<a id="p540"/>
<p>Because path compression makes <em>x</em> and <em>y</em> have the same parent, after path compression we have <em>x</em>.<em>p</em>.<em>rank</em> = <em>y</em>.<em>p</em>.<em>rank</em>. The parent of <em>y</em> might change due to the path compression, but if it does, the rank of <em>y</em>’s new parent compared with the rank of <em>y</em>’s parent before path compression is either the same or greater. Since <em>x</em>.<em>rank</em> does not change, <img alt="art" src="images/Art_P593.jpg"/> after path compression. By the definition (19.5) of the iter function, the value of iter(<em>x</em>) increases from <em>i</em> to at least <em>i</em> + 1. By Lemma 19.10, <em><span class="symbolfont">ϕ</span></em><sub><em>q</em></sub>(<em>x</em>) ≤ <em><span class="symbolfont">ϕ</span></em><sub><em>q</em>−1</sub>(<em>x</em>) − 1, so that <em>x</em>’s potential decreases by at least 1.</p>
<p>The amortized cost of the F<small>IND</small>-S<small>ET</small> operation is the actual cost plus the change in potential. The actual cost is <em>O</em>(<em>s</em>), and we have shown that the total potential decreases by at least max {0, <em>s</em> − (<em>α</em>(<em>n</em>) + 2)}. The amortized cost, therefore, is at most <em>O</em>(<em>s</em>) − (<em>s</em> − (<em>α</em>(<em>n</em>) + 2)) = <em>O</em>(<em>s</em>) − <em>s</em> + <em>O</em>(<em>α</em>(<em>n</em>)) = <em>O</em>(<em>α</em>(<em>n</em>)), since we can scale up the units of potential to dominate the constant hidden in <em>O</em>(<em>s</em>). (See Exercise 19.4-6.)</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Putting the preceding lemmas together yields the following theorem.</p>
<p class="theorem"><strong><em>Theorem 19.14</em></strong></p>
<p class="noindent">A sequence of <em>m</em> M<small>AKE</small>-S<small>ET</small>, U<small>NION</small>, and F<small>IND</small>-S<small>ET</small> operations, <em>n</em> of which are M<small>AKE</small>-S<small>ET</small> operations, can be performed on a disjoint-set forest with union by rank and path compression in <em>O</em>(<em>m α</em>(<em>n</em>)) time.</p>
<p class="proof"><strong><em>Proof</em></strong>   Immediate from Lemmas 19.7, 19.11, 19.12, and 19.13.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="exe"><strong>Exercises</strong></p>
<p class="level3"><strong><em>19.4-1</em></strong></p>
<p class="noindent">Prove Lemma 19.4.</p>
<p class="level3"><strong><em>19.4-2</em></strong></p>
<p class="noindent">Prove that every node has rank at most <span class="font1">⌊</span>lg <em>n</em><span class="font1">⌋</span>.</p>
<p class="level3"><strong><em>19.4-3</em></strong></p>
<p class="noindent">In light of Exercise 19.4-2, how many bits are necessary to store <em>x</em>.<em>rank</em> for each node <em>x</em>?</p>
<p class="level3"><strong><em>19.4-4</em></strong></p>
<p class="noindent">Using Exercise 19.4-2, give a simple proof that operations on a disjoint-set forest with union by rank but without path compression run in <em>O</em>(<em>m</em> lg <em>n</em>) time.</p>
<a id="p541"/>
<p class="level3"><strong><em>19.4-5</em></strong></p>
<p class="noindent">Professor Dante reasons that because node ranks increase strictly along a simple path to the root, node levels must monotonically increase along the path. In other words, if <em>x</em>.<em>rank &gt;</em> 0 and <em>x</em>.<em>p</em> is not a root, then level(<em>x</em>) ≤ level(<em>x</em>.<em>p</em>). Is the professor correct?</p>
<p class="level3"><strong><em>19.4-6</em></strong></p>
<p class="noindent">The proof of Lemma 19.13 ends with scaling the units of potential to dominate the constant hidden in the <em>O</em>(<em>s</em>) term. To be more precise in the proof, you need to change the definition (19.7) of the potential function to multiply each of the two cases by a constant, say <em>c</em>, that dominates the constant in the <em>O</em>(<em>s</em>) term. How must the rest of the analysis change to accommodate this updated potential function?</p>
<p class="level3"><span class="font1">★</span> <strong><em>19.4-7</em></strong></p>
<p class="noindent">Consider the function <em>α</em>′(<em>n</em>) = min {<em>k</em> : <em>A<sub>k</sub></em>(1) ≥ lg(<em>n</em> + 1)}. Show that <em>α</em>′(<em>n</em>) ≤ 3 for all practical values of <em>n</em> and, using Exercise 19.4-2, show how to modify the potential-function argument to prove that performing a sequence of <em>m</em> M<small>AKE</small>-S<small>ET</small>, U<small>NION</small>, and F<small>IND</small>-S<small>ET</small> operations, <em>n</em> of which are M<small>AKE</small>-S<small>ET</small> operations, on a disjoint-set forest with union by rank and path compression takes <em>O</em>(<em>mα</em>′(<em>n</em>)) time.</p>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-115"><strong>Problems</strong></p>
<section title="19-1 Offline minimum">
<p class="level2"><strong><em>19-1     Offline minimum</em></strong></p>
<p class="noindent">In the <span class="blue"><strong><em>offline minimum problem</em></strong></span>, you maintain a dynamic set <em>T</em> of elements from the domain {1, 2, … , <em>n</em>} under the operations I<small>NSERT</small> and E<small>XTRACT</small>-M<small>IN</small>. The input is a sequence <em>S</em> of <em>n</em> I<small>NSERT</small> and <em>m</em> E<small>XTRACT</small>-M<small>IN</small> calls, where each key in {1, 2, … , <em>n</em>} is inserted exactly once. Your goal is to determine which key is returned by each E<small>XTRACT</small>-M<small>IN</small> call. Specifically, you must fill in an array <em>extracted</em>[1: <em>m</em>], where for <em>i</em> = 1, 2, … , <em>m</em>, <em>extracted</em>[<em>i</em>] is the key returned by the <em>i</em>th E<small>XTRACT</small>-M<small>IN</small> call. The problem is “offline” in the sense that you are allowed to process the entire sequence <em>S</em> before determining any of the returned keys.</p>
<p class="nl"><strong><em>a.</em></strong> Consider the following instance of the offline minimum problem, in which each operation I<small>NSERT</small>(<em>i</em>) is represented by the value of <em>i</em> and each E<small>XTRACT</small>-M<small>IN</small> is represented by the letter E:</p>
<p class="eqnl">4, 8, E, 3, E, 9, 2, 6, E, E, E, 1, 7, E, 5.</p>
<p class="nl-para">Fill in the correct values in the <em>extracted</em> array.</p>
<a id="p542"/>
<p class="noindent1-top">To develop an algorithm for this problem, break the sequence <em>S</em> into homogeneous subsequences. That is, represent <em>S</em> by</p>
<p class="eql">I<sub>1</sub>, E, I<sub>2</sub>, E, I<sub>3</sub>, … , I<em><sub>m</sub></em>, E, I<sub><em>m</em>+1</sub>,</p>
<p class="noindent">where each E represents a single E<small>XTRACT</small>-M<small>IN</small> call and each I<em><sub>j</sub></em> represents a (possibly empty) sequence of I<small>NSERT</small> calls. For each subsequence I<em><sub>j</sub></em>, initially place the keys inserted by these operations into a set <em>K<sub>j</sub></em>, which is empty if I<em><sub>j</sub></em> is empty. Then execute the O<small>FFLINE</small>-M<small>INIMUM</small> procedure.</p>
<div class="pull-quote1">
<p class="box-heading">O<small>FFLINE</small>-M<small>INIMUM</small>(<em>m</em>, <em>n</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> <em>n</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2">determine <em>j</em> such that <em>i</em> ∈ <em>K<sub>j</sub></em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>j</em> ≠ <em>m</em> + 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p3"><em>extracted</em>[<em>j</em>] = <em>i</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p3">let <em>l</em> be the smallest value greater than <em>j</em> for which set <em>K<sub>l</sub></em> exists</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><p class="p3"><em>K<sub>l</sub></em> = <em>K<sub>j</sub></em> ∪ <em>K<sub>l</sub></em>, destroying <em>K<sub>j</sub></em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">7</span></td>
<td class="td1"><p class="noindent"><strong>return</strong> <em>extracted</em></p></td>
</tr>
</table>
</div>
<p class="nl"><strong><em>b.</em></strong> Argue that the array <em>extracted</em> returned by O<small>FFLINE</small>-M<small>INIMUM</small> is correct.</p>
<p class="nl"><strong><em>c.</em></strong> Describe how to implement O<small>FFLINE</small>-M<small>INIMUM</small> efficiently with a disjoint-set data structure. Give as tight a bound as you can on the worst-case running time of your implementation.</p>
</section>
<section title="19-2 Depth determination">
<p class="level2"><strong><em>19-2     Depth determination</em></strong></p>
<p class="noindent">In the <span class="blue"><strong><em>depth-determination problem</em></strong></span>, you maintain a forest <span class="font1">ℱ</span> = {<em>T<sub>i</sub></em>} of rooted trees under three operations:</p>
<p class="para-hang1">M<small>AKE</small>-T<small>REE</small>(<em>v</em>) creates a tree whose only node is <em>v</em>.</p>
<p class="para-hang1">F<small>IND</small>-D<small>EPTH</small>(<em>v</em>) returns the depth of node <em>v</em> within its tree.</p>
<p class="para-hang1">G<small>RAFT</small>(<em>r</em>, <em>v</em>) makes node <em>r</em>, which is assumed to be the root of a tree, become the child of node <em>v</em>, which is assumed to be in a different tree from <em>r</em> but may or may not itself be a root.</p>
<p class="nl"><strong><em>a.</em></strong> Suppose that you use a tree representation similar to a disjoint-set forest: <em>v</em>.<em>p</em> is the parent of node <em>v</em>, except that <em>v</em>.<em>p</em> = <em>v</em> if <em>v</em> is a root. Suppose further that you implement G<small>RAFT</small>(<em>r</em>, <em>v</em>) by setting <em>r</em>.<em>p</em> = <em>v</em> and F<small>IND</small>-D<small>EPTH</small>(<em>v</em>) by following the find path from <em>v</em> up to the root, returning a count of all nodes other than <em>v</em> encountered. Show that the worst-case running time of a sequence of <em>m</em> M<small>AKE</small>-T<small>REE</small>, F<small>IND</small>-D<small>EPTH</small>, and G<small>RAFT</small> operations is Θ(<em>m</em><sup>2</sup>).</p>
<a id="p543"/>
<p class="noindent1-top">By using the union-by-rank and path-compression heuristics, you can reduce the worst-case running time. Use the disjoint-set forest <span class="script">S</span> = {<em>S<sub>i</sub></em>}, where each set <em>S<sub>i</sub></em> (which is itself a tree) corresponds to a tree <em>T<sub>i</sub></em> in the forest <span class="font1">ℱ</span>. The tree structure within a set <em>S<sub>i</sub></em>, however, does not necessarily correspond to that of <em>T<sub>i</sub></em>. In fact, the implementation of <em>S<sub>i</sub></em> does not record the exact parent-child relationships but nevertheless allows you to determine any node’s depth in <em>T<sub>i</sub></em>.</p>
<p>The key idea is to maintain in each node <em>v</em> a “pseudodistance” <em>v</em>.<em>d</em>, which is defined so that the sum of the pseudodistances along the simple path from <em>v</em> to the root of its set <em>S<sub>i</sub></em> equals the depth of <em>v</em> in <em>T<sub>i</sub></em>. That is, if the simple path from <em>v</em> to its root in <em>S<sub>i</sub></em> is <em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, … , <em>v<sub>k</sub></em>, where <em>v</em><sub>0</sub> = <em>v</em> and <em>v<sub>k</sub></em> is <em>S<sub>i</sub></em>’s root, then the depth of <em>v</em> in <em>T<sub>i</sub></em> is <img alt="art" src="images/Art_P594.jpg"/>.</p>
<p class="nl"><strong><em>b.</em></strong> Give an implementation of M<small>AKE</small>-T<small>REE</small>.</p>
<p class="nl"><strong><em>c.</em></strong> Show how to modify F<small>IND</small>-S<small>ET</small> to implement F<small>IND</small>-D<small>EPTH</small>. Your implementation should perform path compression, and its running time should be linear in the length of the find path. Make sure that your implementation updates pseudodistances correctly.</p>
<p class="nl"><strong><em>d.</em></strong> Show how to implement G<small>RAFT</small>(<em>r</em>, <em>v</em>), which combines the sets containing <em>r</em> and <em>v</em>, by modifying the U<small>NION</small> and L<small>INK</small> procedures. Make sure that your implementation updates pseudodistances correctly. Note that the root of a set <em>S<sub>i</sub></em> is not necessarily the root of the corresponding tree <em>T<sub>i</sub></em>.</p>
<p class="nl"><strong><em>e.</em></strong> Give a tight bound on the worst-case running time of a sequence of <em>m</em> M<small>AKE</small>-T<small>REE</small>, F<small>IND</small>-D<small>EPTH</small>, and G<small>RAFT</small> operations, <em>n</em> of which are M<small>AKE</small>-T<small>REE</small> operations.</p>
</section>
<section title="19-3 Tarjan’s offline lowest-common-ancestors algorithm">
<p class="level2"><strong><em>19-3     Tarjan’s offline lowest-common-ancestors algorithm</em></strong></p>
<p class="noindent">The <span class="blue"><strong><em>lowest common ancestor</em></strong></span> of two nodes <em>u</em> and <em>v</em> in a rooted tree <em>T</em> is the node <em>w</em> that is an ancestor of both <em>u</em> and <em>v</em> and that has the greatest depth in <em>T</em>. In the <span class="blue"><strong><em>offline lowest-common-ancestors problem</em></strong></span>, you are given a rooted tree <em>T</em> and an arbitrary set <em>P</em> = {{<em>u</em>, <em>v</em>}} of unordered pairs of nodes in <em>T</em>, and you wish to determine the lowest common ancestor of each pair in <em>P</em>.</p>
<p>To solve the offline lowest-common-ancestors problem, the LCA procedure on the following page performs a tree walk of <em>T</em> with the initial call LCA(<em>T</em>.<em>root</em>). Assume that each node is colored <small>WHITE</small> prior to the walk.</p>
<p class="nl"><strong><em>a.</em></strong> Argue that line 10 executes exactly once for each pair {<em>u</em>, <em>v</em>} ∈ <em>P</em>.</p>
<p class="nl"><strong><em>b.</em></strong> Argue that at the time of the call LCA(<em>u</em>), the number of sets in the disjoint-set data structure equals the depth of <em>u</em> in <em>T</em>.</p>
<a id="p544"/>
<div class="pull-quote1">
<p class="box-heading">LCA(<em>u</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">  1</span></td>
<td class="td1"><p class="noindent">M<small>AKE</small>-S<small>ET</small>(<em>u</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  2</span></td>
<td class="td1"><p class="noindent">F<small>IND</small>-S<small>ET</small>(<em>u</em>).<em>ancestor</em> = <em>u</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  3</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> each child <em>v</em> of <em>u</em> in <em>T</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  4</span></td>
<td class="td1"><p class="p2">LCA(<em>v</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  5</span></td>
<td class="td1"><p class="p2">U<small>NION</small>(<em>u</em>, <em>v</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  6</span></td>
<td class="td1"><p class="p2">F<small>IND</small>-S<small>ET</small>(<em>u</em>).<em>ancestor</em> = <em>u</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  7</span></td>
<td class="td1"><p class="noindent"><em>u</em>.<em>color</em> = <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  8</span></td>
<td class="td1"><p class="noindent"><strong>for</strong> each node <em>v</em> such that {<em>u</em>, <em>v</em>} ∈ <em>P</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">  9</span></td>
<td class="td1"><p class="p2"><strong>if</strong> <em>v</em>.<em>color</em> == <small>BLACK</small></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">10</span></td>
<td class="td1"><p class="p3">print “The lowest common ancestor of”</p></td>
</tr>
<tr>
<td class="td1"/>
<td class="td1"><p class="p4"><em>u</em> “and” <em>v</em> “is” F<small>IND</small>-S<small>ET</small>(<em>v</em>).<em>ancestor</em></p></td>
</tr>
</table>
</div>
<p class="nl"><strong><em>c.</em></strong> Prove that LCA correctly prints the lowest common ancestor of <em>u</em> and <em>v</em> for each pair {<em>u</em>, <em>v</em>} ∈ <em>P</em>.</p>
<p class="nl"><strong><em>d.</em></strong> Analyze the running time of LCA, assuming that you use the implementation of the disjoint-set data structure in <a href="chapter019.xhtml#Sec_19.3">Section 19.3</a>.</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-116"><strong>Chapter notes</strong></p>
<p class="noindent">Many of the important results for disjoint-set data structures are due at least in part to R. E. Tarjan. Using aggregate analysis, Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_427">427</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_429">429</a>] gave the first tight upper bound in terms of the very slowly growing inverse <img alt="art" src="images/Art_P595.jpg"/> of Ackermann’s function. (The function <em>A<sub>k</sub></em>(<em>j</em>) given in <a href="chapter019.xhtml#Sec_19.4">Section 19.4</a> is similar to Ackermann’s function, and the function <em>α</em>(<em>n</em>) is similar to <img alt="art" src="images/Art_P595.jpg"/>. Both <em>α</em>(<em>n</em>) and <img alt="art" src="images/Art_P595.jpg"/> are at most 4 for all conceivable values of <em>m</em> and <em>n</em>.) An upper bound of <em>O</em>(<em>m</em> lg* <em>n</em>) was proven earlier by Hopcroft and Ullman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_5">5</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_227">227</a>]. The treatment in <a href="chapter019.xhtml#Sec_19.4">Section 19.4</a> is adapted from a later analysis by Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_431">431</a>], which is based on an analysis by Kozen [<a epub:type="noteref" href="bibliography001.xhtml#endnote_270">270</a>]. Harfst and Reingold [<a epub:type="noteref" href="bibliography001.xhtml#endnote_209">209</a>] give a potential-based version of Tarjan’s earlier bound.</p>
<p>Tarjan and van Leeuwen [<a epub:type="noteref" href="bibliography001.xhtml#endnote_432">432</a>] discuss variants on the path-compression heuristic, including “one-pass methods,” which sometimes offer better constant factors in their performance than do two-pass methods. As with Tarjan’s earlier analyses of the basic path-compression heuristic, the analyses by Tarjan and van Leeuwen are aggregate. Harfst and Reingold [<a epub:type="noteref" href="bibliography001.xhtml#endnote_209">209</a>] later showed how to make a small change to the potential function to adapt their path-compression analysis to these one-pass variants. Goel et al. [<a epub:type="noteref" href="bibliography001.xhtml#endnote_182">182</a>] prove that linking disjoint-set trees randomly yields the <a id="p545"/>same asymptotic running time as union by rank. Gabow and Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_166">166</a>] show that in certain applications, the disjoint-set operations can be made to run in <em>O</em>(<em>m</em>) time.</p>
<p>Tarjan [<a epub:type="noteref" href="bibliography001.xhtml#endnote_428">428</a>] showed that a lower bound of <img alt="art" src="images/Art_P598.jpg"/> time is required for operations on any disjoint-set data structure satisfying certain technical conditions. This lower bound was later generalized by Fredman and Saks [<a epub:type="noteref" href="bibliography001.xhtml#endnote_155">155</a>], who showed that in the worst case, <img alt="art" src="images/Art_P599.jpg"/> (lg <em>n</em>)-bit words of memory must be accessed.</p>
</section>
</section>
</div>
</body>
</html>