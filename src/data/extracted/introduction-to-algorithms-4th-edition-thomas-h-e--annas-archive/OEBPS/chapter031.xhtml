<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
<title>Introduction to Algorithms</title>
<link href="css/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4a9ccac5-f2db-4081-af1f-a5a376b433e1" name="Adept.expected.resource"/>
</head>
<body>
<div class="body"><a id="p903"/>
<p class="line-c"/>
<section epub:type="bodymatter chapter" title="31 Number-Theoretic Algorithms">
<p class="chapter-title"><a href="toc.xhtml#chap-31"><strong><span class="blue1">31        Number-Theoretic Algorithms</span></strong></a></p>
<p class="noindent">Number theory was once viewed as a beautiful but largely useless subject in pure mathematics. Today number-theoretic algorithms are used widely, due in large part to the invention of cryptographic schemes based on large prime numbers. These schemes are feasible because we can find large primes quickly, and they are secure because we do not know how to factor the product of large primes (or solve related problems, such as computing discrete logarithms) efficiently. This chapter presents some of the number theory and related algorithms that underlie such applications.</p>
<p>We start in <a href="chapter031.xhtml#Sec_31.1">Section 31.1</a> by introducing basic concepts of number theory, such as divisibility, modular equivalence, and unique prime factorization. <a href="chapter031.xhtml#Sec_31.2">Section 31.2</a> studies one of the world’s oldest algorithms: Euclid’s algorithm for computing the greatest common divisor of two integers, and <a href="chapter031.xhtml#Sec_31.3">Section 31.3</a> reviews concepts of modular arithmetic. <a href="chapter031.xhtml#Sec_31.4">Section 31.4</a> then explores the set of multiples of a given number <em>a</em>, modulo <em>n</em>, and shows how to find all solutions to the equation <em>ax</em> = <em>b</em> (mod <em>n</em>) by using Euclid’s algorithm. The Chinese remainder theorem is presented in <a href="chapter031.xhtml#Sec_31.5">Section 31.5</a>. <a href="chapter031.xhtml#Sec_31.6">Section 31.6</a> considers powers of a given number <em>a</em>, modulo <em>n</em>, and presents a repeated-squaring algorithm for efficiently computing <em>a<sup>b</sup></em> mod <em>n</em>, given <em>a</em>, <em>b</em>, and <em>n</em>. This operation is at the heart of efficient primality testing and of much modern cryptography, such as the RSA public-key cryptosystem described in <a href="chapter031.xhtml#Sec_31.7">Section 31.7</a>. We wrap up in <a href="chapter031.xhtml#Sec_31.8">Section 31.8</a>, which examines a randomized primality test. This test finds large primes efficiently, an essential step in creating keys for the RSA cryptosystem.</p>
<p class="level4"><strong>Size of inputs and cost of arithmetic computations</strong></p>
<p class="noindent">Because we’ll be working with large integers, we need to adjust how to think about the size of an input and about the cost of elementary arithmetic operations.</p>
<p>In this chapter, a “large input” typically means an input containing “large integers” rather than an input containing “many integers” (as for sorting). Thus, the size of an input depends on the <em>number of bits</em> required to represent that input, not just the number of integers in the input. An algorithm with integer inputs <a id="p904"/><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a<sub>k</sub></em> is a <span class="blue"><strong><em>polynomial-time algorithm</em></strong></span> if it runs in time polynomial in 1g <em>a</em><sub>1</sub>, 1g <em>a</em><sub>2</sub>, …, 1g <em>a</em><sub><em>k</em></sub>, that is, polynomial in the lengths of its binary-encoded inputs.</p>
<p>Most of this book considers the elementary arithmetic operations (multiplications, divisions, or computing remainders) as primitive operations that take one unit of time. Counting the number of such arithmetic operations that an algorithm performs provides a basis for making a reasonable estimate of the algorithm’s actual running time on a computer. Elementary operations can be time-consuming, however, when their inputs are large. It thus becomes appropriate to measure how many <span class="blue"><strong><em>bit operations</em></strong></span> a number-theoretic algorithm requires. In this model, multiplying two <em>β</em>-bit integers by the ordinary method uses Θ(<em>β</em><sup>2</sup>) bit operations. Similarly, dividing a <em>β</em>-bit integer by a shorter integer or taking the remainder of a <em>β</em>-bit integer when divided by a shorter integer requires Θ(<em>β</em><sup>2</sup>) time by simple algorithms. (See Exercise 31.1-12.) Faster methods are known. For example, a simple divide-and-conquer method for multiplying two <em>β</em>-bit integers has a running time of Θ(<em>β</em><sup>1g 3</sup>), and <em>O</em>(<em>β</em> 1g <em>β</em> 1g 1g <em>β</em>) time is possible. For practical purposes, however, the Θ(<em>β</em><sup>2</sup>) algorithm is often best, and we use this bound as a basis for our analyses. In this chapter, we’ll usually analyze algorithms in terms of both the number of arithmetic operations and the number of bit operations they require.</p>
<p class="line1"/>
<section title="31.1 Elementary number-theoretic notions">
<a id="Sec_31.1"/>
<p class="level1" id="h1-177"><a href="toc.xhtml#Rh1-177"><strong>31.1    Elementary number-theoretic notions</strong></a></p>
<p class="noindent">This section provides a brief review of notions from elementary number theory concerning the set <span class="font1">ℤ</span> = {…, –2, –1, 0, 1, 2, …} of integers and the set <span class="font1">ℕ</span> = {0, 1, 2, …} of natural numbers.</p>
<p class="level4"><strong>Divisibility and divisors</strong></p>
<p class="noindent">The notion of one integer being divisible by another is key to the theory of numbers. The notation <em>d</em> | <em>a</em> (read “<em>d</em> <span class="blue"><strong><em>divides</em></strong></span> <em>a</em>”) means that <em>a</em> = <em>kd</em> for some integer <em>k</em>. Every integer divides 0. If <em>a</em> &gt; 0 and <em>d</em> | <em>a</em>, then |<em>d</em>| ≤ |<em>a</em>|. If <em>d</em> | <em>a</em>, then we also say that <em>a</em> is a <span class="blue"><strong><em>multiple</em></strong></span> of <em>d</em>. If <em>d</em> does not divide <em>a</em>, we write <em>d</em> <span class="font1">∤</span> <em>a</em>.</p>
<p>If <em>d</em> | <em>a</em> and <em>d</em> ≥ 0, then <em>d</em> is a <span class="blue"><strong><em>divisor</em></strong></span> of <em>a</em>. Since <em>d</em> | <em>a</em> if and only if –<em>d</em> | <em>a</em>, without loss of generality, we define the divisors of <em>a</em> to be nonnegative, with the understanding that the negative of any divisor of <em>a</em> also divides <em>a</em>. A divisor of a nonzero integer <em>a</em> is at least 1 but not greater than |<em>a</em>|. For example, the divisors of 24 are 1, 2, 3, 4, 6, 8, 12, and 24.</p>
<p>Every positive integer <em>a</em> is divisible by the <span class="blue"><strong><em>trivial divisors</em></strong></span> 1 and <em>a</em>. The nontrivial divisors of <em>a</em> are the <span class="blue"><strong><em>factors</em></strong></span> of <em>a</em>. For example, the factors of 20 are 2, 4, 5, and 10.</p>
<a id="p905"/>
<p class="level4"><strong>Prime and composite numbers</strong></p>
<p class="noindent">An integer <em>a</em> &gt; 1 whose only divisors are the trivial divisors 1 and <em>a</em> is a <span class="blue"><strong><em>prime number</em></strong></span> or, more simply, a <span class="blue"><strong><em>prime</em></strong></span>. Primes have many special properties and play a critical role in number theory. The first 20 primes, in order, are</p>
<p class="eql">2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71.</p>
<p class="noindent">Exercise 31.1-2 asks you to prove that there are infinitely many primes. An integer <em>a</em> &gt; 1 that is not prime is a <span class="blue"><strong><em>composite number</em></strong></span> or, more simply, a <span class="blue"><strong><em>composite</em></strong></span>. For example, 39 is composite because 3 | 39. We call the integer 1 a <span class="blue"><strong><em>unit</em></strong></span>, and it is neither prime nor composite. Similarly, the integer 0 and all negative integers are neither prime nor composite.</p>
<p class="level4"><strong>The division theorem, remainders, and modular equivalence</strong></p>
<p class="noindent">Given an integer <em>n</em>, we can partition the integers into those that are multiples of <em>n</em> and those that are not multiples of <em>n</em>. Much number theory is based upon refining this partition by classifying the integers that are not multiples of <em>n</em> according to their remainders when divided by <em>n</em>. The following theorem provides the basis for this refinement. We omit the proof (but see, for example, Niven and Zuckerman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_345">345</a>]).</p>
<p class="theo"><strong><em>Theorem 31.1 (Division theorem)</em></strong></p>
<p class="noindent">For any integer <em>a</em> and any positive integer <em>n</em>, there exist unique integers <em>q</em> and <em>r</em> such that 0 ≤ <em>r</em> &lt; <em>n</em> and <em>a</em> = <em>qn</em> + <em>r</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The value <em>q</em> = <span class="font1">⌊</span><em>a</em>/<em>n</em><span class="font1">⌋</span> is the <span class="blue"><strong><em>quotient</em></strong></span> of the division. The value <em>r</em> = <em>a</em> mod <em>n</em> is the <span class="blue"><strong><em>remainder</em></strong></span> (or <span class="blue"><strong><em>residue</em></strong></span>) of the division, so that <em>n</em> | <em>a</em> if and only if <em>a</em> mod <em>n</em> = 0.</p>
<p>The integers partition into <em>n</em> equivalence classes according to their remainders modulo <em>n</em>. The <span class="blue"><strong><em>equivalence class modulo n</em></strong></span> containing an integer <em>a</em> is</p>
<p class="eql">[<em>a</em>]<sub><em>n</em></sub> = {<em>a</em> + <em>kn</em> : <em>k</em> ∈ <span class="font1">ℤ</span>}.</p>
<p class="noindent">For example, [3]<sub>7</sub> = {…, –11, –4, 3, 10, 17, …}, and [–4]<sub>7</sub> and [10]<sub>7</sub> also denote this set. With the notation defined on page 64, writing <em>a</em> ∈ [<em>b</em>]<sub><em>n</em></sub> is the same as writing <em>a</em> = <em>b</em> (mod <em>n</em>). The set of all such equivalence classes is</p>
<p class="eqr"><img alt="art" src="images/Art_P1131.jpg"/></p>
<p class="noindent">When you see the definition</p>
<p class="eqr"><img alt="art" src="images/Art_P1132.jpg"/></p>
<p class="noindent">you should read it as equivalent to equation (31.1) with the understanding that 0 represents [0]<sub><em>n</em></sub>, 1 represents [1]<sub><em>n</em></sub>, and so on. Each class is represented by its <a id="p906"/>smallest nonnegative element. You should keep the underlying equivalence classes in mind, however. For example, if we refer to –1 as a member of <span class="font1">ℤ</span><sub><em>n</em></sub>, we are really referring to [<em>n</em> – 1]<sub><em>n</em></sub>, since –1 = <em>n</em> – 1 (mod <em>n</em>).</p>
<p class="level4"><strong>Common divisors and greatest common divisors</strong></p>
<p class="noindent">If <em>d</em> is a divisor of <em>a</em> and <em>d</em> is also a divisor of <em>b</em>, then <em>d</em> is a <span class="blue"><strong><em>common divisor</em></strong></span> of <em>a</em> and <em>b</em>. For example, the divisors of 30 are 1, 2, 3, 5, 6, 10, 15, and 30, and so the common divisors of 24 and 30 are 1, 2, 3, and 6. Any pair of integers has a common divisor of 1.</p>
<p>An important property of common divisors is that</p>
<p class="eqr"><img alt="art" src="images/Art_P1133.jpg"/></p>
<p class="noindent">More generally, for any integers <em>x</em> and <em>y</em>,</p>
<p class="eqr"><img alt="art" src="images/Art_P1134.jpg"/></p>
<p class="noindent">Also, if <em>a</em> | <em>b</em>, then either |<em>a</em>| ≤ |<em>b</em>| or <em>b</em> = 0, which implies that</p>
<p class="eqr"><img alt="art" src="images/Art_P1135.jpg"/></p>
<p>The <span class="blue"><strong><em>greatest common divisor</em></strong></span> of two integers <em>a</em> and <em>b</em> which are not both 0, denoted by gcd(<em>a</em>, <em>b</em>), is the largest of the common divisors of <em>a</em> and <em>b</em>. For example, gcd(24, 30) = 6, gcd(5, 7) = 1, and gcd(0, 9) = 9. If <em>a</em> and <em>b</em> are both nonzero, then gcd(<em>a</em>, <em>b</em>) is an integer between 1 and min {|<em>a</em>|, |<em>b</em>|}. We define gcd(0, 0) to be 0, so that standard properties of the gcd function (such as equation (31.9) below) hold universally.</p>
<p>Exercise 31.1-9 asks you to prove the following elementary properties of the gcd function:</p>
<p class="eqr"><img alt="art" src="images/Art_P1136.jpg"/></p>
<p>The following theorem provides an alternative and useful way to characterize gcd(<em>a</em>, <em>b</em>).</p>
<p class="theo"><strong><em>Theorem 31.2</em></strong></p>
<p class="noindent">If <em>a</em> and <em>b</em> are any integers, not both zero, then gcd(<em>a</em>, <em>b</em>) is the smallest positive element of the set {<em>ax</em> + <em>by</em> : <em>x</em>, <em>y</em> ∈ <span class="font1">ℤ</span>} of linear combinations of <em>a</em> and <em>b</em>.</p>
<a id="p907"/>
<p class="proof"><strong><em>Proof</em></strong>   Let <em>s</em> be the smallest positive such linear combination of <em>a</em> and <em>b</em>, and let <em>s</em> = <em>ax</em> + <em>by</em> for some <em>x</em>, <em>y</em> ∈ <span class="font1">ℤ</span>. Let <em>q</em> = <span class="font1">⌊</span><em>a</em>/<em>s</em><span class="font1">⌋</span>. Equation (3.11) on page 64 then implies</p>
<table class="table2b">
<tr>
<td class="td2"><em>a</em> mod <em>s</em></td>
<td class="td2">=</td>
<td class="td2"><em>a</em> – <em>qs</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>a</em> – <em>q</em>(<em>ax</em> + <em>by</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>a</em> (1 – <em>qx</em>) + <em>b</em> (–<em>qy</em>),</td>
</tr>
</table>
<p class="noindent">so that <em>a</em> mod <em>s</em> is a linear combination of <em>a</em> and <em>b</em> as well. Because <em>s</em> is the smallest <em>positive</em> such linear combination and 0 ≤ <em>a</em> mod <em>s</em> &lt; <em>s</em> (inequality (3.12) on page 64), <em>a</em> mod <em>s</em> cannot be positive. Hence, <em>a</em> mod <em>s</em> = 0. Therefore, we have that <em>s</em> | <em>a</em> and, by analogous reasoning, <em>s</em> | <em>b</em>. Thus, <em>s</em> is a common divisor of <em>a</em> and <em>b</em>, so that gcd(<em>a</em>, <em>b</em>) ≥ <em>s</em>. By definition, gcd(<em>a</em>, <em>b</em>) divides both <em>a</em> and <em>b</em>, and <em>s</em> is defined as a linear combination of <em>a</em> and <em>b</em>. Equation (31.4) therefore implies that gcd(<em>a</em>, <em>b</em>) | <em>s</em>. But gcd(<em>a</em>, <em>b</em>) | <em>s</em> and <em>s</em> &gt; 0 imply that gcd(<em>a</em>, <em>b</em>) ≤ <em>s</em>. Combining gcd(<em>a</em>, <em>b</em>) ≥ <em>s</em> and gcd(<em>a</em>, <em>b</em>) ≤ <em>s</em> yields gcd(<em>a</em>, <em>b</em>) = <em>s</em>. We conclude that <em>s</em>, the smallest positive linear combination of <em>a</em> and <em>b</em>, is also their greatest common divisor.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Theorem 31.2 engenders three useful corollaries.</p>
<p class="cor"><strong><em>Corollary 31.3</em></strong></p>
<p class="noindent">For any integers <em>a</em> and <em>b</em>, if <em>d</em> | <em>a</em> and <em>d</em> | <em>b</em>, then <em>d</em> | gcd(<em>a</em>, <em>b</em>).</p>
<p class="proof"><strong><em>Proof</em></strong>   This corollary follows from equation (31.4) and Theorem 31.2, because gcd(<em>a</em>, <em>b</em>) is a linear combination of <em>a</em> and <em>b</em>,</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 31.4</em></strong></p>
<p class="noindent">For all integers <em>a</em> and <em>b</em> and any nonnegative integer <em>n</em>, we have</p>
<p class="eql">gcd(<em>an</em>, <em>bn</em>) = <em>n</em> gcd(<em>a</em>, <em>b</em>).</p>
<p class="proof"><strong><em>Proof</em></strong>   If <em>n</em> = 0, the corollary is trivial. If <em>n</em> &gt; 0, then gcd(<em>an</em>, <em>bn</em>) is the smallest positive element of the set {<em>anx</em> + <em>bny</em> : <em>x</em>, <em>y</em> ∈ <span class="font1">ℤ</span>}, which in turn is <em>n</em> times the smallest positive element of the set {<em>ax</em> + <em>by</em> : <em>x</em>, <em>y</em> ∈ <span class="font1">ℤ</span>}.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 31.5</em></strong></p>
<p class="noindent">For all positive integers <em>n</em>, <em>a</em>, and <em>b</em>, if <em>n</em> | <em>ab</em> and gcd(<em>a</em>, <em>n</em>) = 1, then <em>n</em> | <em>b</em>.</p>
<p class="proof"><strong><em>Proof</em></strong>   Exercise 31.1-5 asks you to provide the proof.</p>
<p class="right"><span class="font1">▪</span></p>
<a id="p908"/>
<p class="level4"><strong>Relatively prime integers</strong></p>
<p class="noindent">Two integers <em>a</em> and <em>b</em> are <span class="blue"><strong><em>relatively prime</em></strong></span> if their only common divisor is 1, that is, if gcd(<em>a</em>, <em>b</em>) = 1. For example, 8 and 15 are relatively prime, since the divisors of 8 are 1, 2, 4, and 8, and the divisors of 15 are 1, 3, 5, and 15. The following theorem states that if two integers are each relatively prime to an integer <em>p</em>, then their product is relatively prime to <em>p</em>.</p>
<p class="theo"><strong><em>Theorem 31.6</em></strong></p>
<p class="noindent">For any integers <em>a</em>, <em>b</em>, and <em>p</em>, we have gcd(<em>ab</em>, <em>p</em>) = 1 if and only if gcd(<em>a</em>, <em>p</em>) = 1 and gcd(<em>b</em>, <em>p</em>) = 1 both hold.</p>
<p class="proof"><strong><em>Proof</em></strong>   If gcd(<em>a</em>, <em>p</em>) = 1 and gcd(<em>b</em>, <em>p</em>) = 1, then it follows from Theorem 31.2 that there exist integers <em>x</em>, <em>y</em>, <em>x</em>′, and <em>y</em>′ such that</p>
<table class="table2b">
<tr>
<td class="td2"><em>ax</em> + <em>py</em></td>
<td class="td2">=</td>
<td class="td2">1,</td>
</tr>
<tr>
<td class="td2"><em>bx</em>′ + <em>py</em>′</td>
<td class="td2">=</td>
<td class="td2">1.</td>
</tr>
</table>
<p class="noindent">Multiplying these equations and rearranging gives</p>
<p class="eql"><em>ab</em>(<em>xx</em>′) + <em>p</em>(<em>ybx</em>′ + <em>y</em>′<em>ax</em> + <em>pyy</em>′) = 1.</p>
<p class="noindent">Since 1 is thus a positive linear combination of <em>ab</em> and <em>p</em>, it is the smallest positive linear combination. Applying Theorem 31.2 implies gcd(<em>ab</em>, <em>p</em>) = 1, completing the proof in this direction.</p>
<p>Conversely, if gcd(<em>ab</em>, <em>p</em>) = 1, then Theorem 31.2 implies that there exist integers <em>x</em> and <em>y</em> such that</p>
<p class="eql"><em>abx</em> + <em>py</em> = 1.</p>
<p class="noindent">Writing <em>abx</em> as <em>a</em>(<em>bx</em>) and applying Theorem 31.2 again proves that gcd(<em>a</em>, <em>p</em>) = 1. Proving that gcd(<em>b</em>, <em>p</em>) = 1 is similar.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Integers <em>n</em><sub>1</sub>, <em>n</em><sub>2</sub>, …, <em>n</em><sub><em>k</em></sub> are <span class="blue"><strong><em>pairwise relatively prime</em></strong></span> if gcd(<em>n</em><sub><em>i</em></sub>, <em>n</em><sub><em>j</em></sub>) = 1 for 1 ≤ <em>i</em> &lt; <em>j</em> ≤ <em>k</em>.</p>
<p class="level4"><strong>Unique prime factorization</strong></p>
<p class="noindent">An elementary but important fact about divisibility by primes is the following.</p>
<p class="theo"><strong><em>Theorem 31.7</em></strong></p>
<p class="noindent">For all primes <em>p</em> and all integers <em>a</em> and <em>b</em>, if <em>p</em> | <em>ab</em>, then <em>p</em> | <em>a</em> or <em>p</em> | <em>b</em> (or both).</p>
<p class="proof"><strong><em>Proof</em></strong>   Assume for the purpose of contradiction that <em>p</em> | <em>ab</em>, but that <em>p</em> <span class="font1">∤</span> <em>a</em> and <em>p</em> <span class="font1">∤</span> <em>b</em>. Because <em>p</em> &gt; 1 and <em>ab</em> = <em>kp</em> for some <em>k</em> ∈ <span class="font1">ℤ</span>, equation (31.10) gives <a id="p909"/>that gcd(<em>ab</em>, <em>p</em>) = <em>p</em>. We also have that gcd(<em>a</em>, <em>p</em>) = 1 and gcd(<em>b</em>, <em>p</em>) = 1, since the only divisors of <em>p</em> are 1 and <em>p</em>, and we assumed that <em>p</em> divides neither <em>a</em> nor <em>b</em>. Theorem 31.6 then implies that gcd(<em>ab</em>, <em>p</em>) = 1, contradicting gcd(<em>ab</em>, <em>p</em>) = <em>p</em>. This contradiction completes the proof.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">A consequence of Theorem 31.7 is that any composite integer can be uniquely factored into a product of primes. Exercise 31.1-11 asks you to provide a proof.</p>
<p class="theo"><strong><em>Theorem 31.8 (Unique prime factorization)</em></strong></p>
<p class="noindent">There is exactly one way to write any composite integer <em>a</em> as a product of the form</p>
<p class="eql"><img alt="art" src="images/Art_P1137.jpg"/></p>
<p class="noindent">where the <em>p</em><sub><em>i</em></sub> are prime, <em>p</em><sub>1</sub> &lt; <em>p</em><sub>2</sub> &lt; … &lt; <em>p</em><sub><em>r</em></sub>, and the <em>e</em><sub><em>i</em></sub> are positive integers.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">As an example, the unique prime factorization of the number 6000 is 2<sup>4</sup> · 3<sup>1</sup> · 5<sup>3</sup>.</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>31.1-1</em></strong></p>
<p class="noindent">Prove that if <em>a</em> &gt; <em>b</em> &gt; 0 and <em>c</em> = <em>a</em> + <em>b</em>, then <em>c</em> mod <em>a</em> = <em>b</em>.</p>
<p class="level3"><strong><em>31.1-2</em></strong></p>
<p class="noindent">Prove that there are infinitely many primes. (<em>Hint:</em> Show that none of the primes <em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, …, <em>p</em><sub><em>k</em></sub> divide (<em>p</em><sub>1</sub><em>p</em><sub>2</sub> <span class="font1">⋯</span> <em>p</em><sub><em>k</em></sub>) + 1.)</p>
<p class="level3"><strong><em>31.1-3</em></strong></p>
<p class="noindent">Prove that if <em>a</em> | <em>b</em> and <em>b</em> | <em>c</em>, then <em>a</em> | <em>c</em>.</p>
<p class="level3"><strong><em>31.1-4</em></strong></p>
<p class="noindent">Prove that if <em>p</em> is prime and 0 &lt; <em>k</em> &lt; <em>p</em>, then gcd(<em>k</em>, <em>p</em>) = 1.</p>
<p class="level3"><strong><em>31.1-5</em></strong></p>
<p class="noindent">Prove Corollary 31.5.</p>
<p class="level3"><strong><em>31.1-6</em></strong></p>
<p class="noindent">Prove that if <em>p</em> is prime and 0 &lt; <em>k</em> &lt; <em>p</em>, then <img alt="art" src="images/Art_P1138.jpg"/>. Conclude that for all integers <em>a</em> and <em>b</em> and all primes <em>p</em>,</p>
<p class="eql">(<em>a</em> + <em>b</em>)<sup><em>p</em></sup> = <em>a</em><sup><em>p</em></sup> + <em>b</em><sup><em>p</em></sup> (mod <em>p</em>).</p>
<p class="level3"><strong><em>31.1-7</em></strong></p>
<p class="noindent">Prove that if <em>a</em> and <em>b</em> are any positive integers such that <em>a</em> | <em>b</em>, then</p>
<a id="p910"/>
<p class="eql">(<em>x</em> mod <em>b</em>) mod <em>a</em> = <em>x</em> mod <em>a</em></p>
<p class="noindent">for any <em>x</em>. Prove, under the same assumptions, that</p>
<p class="eql"><em>x</em> = <em>y</em> (mod <em>b</em>) implies <em>x</em> = <em>y</em> (mod <em>a</em>)</p>
<p class="noindent">for any integers <em>x</em> and <em>y</em>.</p>
<p class="level3"><strong><em>31.1-8</em></strong></p>
<p class="noindent">For any integer <em>k</em> &gt; 0, an integer <em>n</em> is a <span class="blue"><strong><em>kth power</em></strong></span> if there exists an integer <em>a</em> such that <em>a</em><sup><em>k</em></sup> = <em>n</em>. Furthermore, <em>n</em> &gt; 1 is a <span class="blue"><strong><em>nontrivial power</em></strong></span> if it is a <em>k</em>th power for some integer <em>k</em> &gt; 1. Show how to determine whether a given <em>β</em>-bit integer <em>n</em> is a nontrivial power in time polynomial in <em>β</em>.</p>
<p class="level3"><strong><em>31.1-9</em></strong></p>
<p class="noindent">Prove equations (31.6)–(31.10).</p>
<p class="level3"><strong><em>31.1-10</em></strong></p>
<p class="noindent">Show that the gcd operator is associative. That is, prove that for all integers <em>a</em>, <em>b</em>, and <em>c</em>, we have</p>
<p class="eql">gcd(<em>a</em>, gcd(<em>b</em>, <em>c</em>)) = gcd(gcd(<em>a</em>, <em>b</em>), <em>c</em>).</p>
<p class="level3"><span class="font1">★</span> <strong><em>31.1-11</em></strong></p>
<p class="noindent">Prove Theorem 31.8.</p>
<p class="level3"><strong><em>31.1-12</em></strong></p>
<p class="noindent">Give efficient algorithms for the operations of dividing a <em>β</em>-bit integer by a shorter integer and of taking the remainder of a <em>β</em>-bit integer when divided by a shorter integer. Your algorithms should run in Θ(<em>β</em><sup>2</sup>) time.</p>
<p class="level3"><strong><em>31.1-13</em></strong></p>
<p class="noindent">Give an efficient algorithm to convert a given <em>β</em>-bit (binary) integer to a decimal representation. Argue that if multiplication or division of integers whose length is at most <em>β</em> takes <em>M</em>(<em>β</em>) time, where <em>M</em>(<em>β</em>) = Ω(<em>β</em>), then you can convert binary to decimal in <em>O</em>(<em>M</em>(<em>β</em>) 1g <em>β</em>) time. (<em>Hint:</em> Use a divide-and-conquer approach, obtaining the top and bottom halves of the result with separate recursions.)</p>
<p class="level3"><strong><em>31.1-14</em></strong></p>
<p class="noindent">Professor Marshall sets up <em>n</em> lightbulbs in a row. The lightbulbs all have switches, so that if he presses a bulb, it toggles on if it was off and off if it was on. The lightbulbs all start off. For <em>i</em> = 1, 2, 3, …, <em>n</em>, the professor presses bulb <em>i</em>, 2<em>i</em>, 3<em>i</em>, …. After the last press, which lightbulbs are on? Prove your answer.</p>
<a id="p911"/>
</section>
<p class="line1"/>
<section title="31.2 Greatest common divisor">
<a id="Sec_31.2"/>
<p class="level1" id="h1-178"><a href="toc.xhtml#Rh1-178"><strong>31.2    Greatest common divisor</strong></a></p>
<p class="noindent">In this section, we describe Euclid’s algorithm for efficiently computing the greatest common divisor of two integers. When we analyze the running time, we’ll see a surprising connection with the Fibonacci numbers, which yield a worst-case input for Euclid’s algorithm.</p>
<p>We restrict ourselves in this section to nonnegative integers. This restriction is justified by equation (31.8), which states that gcd(<em>a</em>, <em>b</em>) = gcd(|<em>a</em>|, |<em>b</em>|).</p>
<p>In principle, for positive integers <em>a</em> and <em>b</em>, their prime factorizations suffice to compute gcd(<em>a</em>, <em>b</em>). Indeed, if</p>
<p class="eqr"><img alt="art" src="images/Art_P1139.jpg"/></p>
<p class="noindent">with 0 exponents being used to make the set of primes <em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, …, <em>p</em><sub><em>r</em></sub> the same for both <em>a</em> and <em>b</em>, then, as Exercise 31.2-1 asks you to show,</p>
<p class="eqr"><img alt="art" src="images/Art_P1140.jpg"/></p>
<p class="noindent">The best algorithms to date for factoring do not run in polynomial time. Thus, this approach to computing greatest common divisors seems unlikely to yield an efficient algorithm.</p>
<p>Euclid’s algorithm for computing greatest common divisors relies on the following theorem.</p>
<p class="theo"><strong><em>Theorem 31.9 (GCD recursion theorem)</em></strong></p>
<p class="noindent">For any nonnegative integer <em>a</em> and any positive integer <em>b</em>,</p>
<p class="eql">gcd(<em>a</em>, <em>b</em>) = gcd(<em>b</em>, <em>a</em> mod <em>b</em>).</p>
<p class="proof"><strong><em>Proof</em></strong>   We will show that gcd(<em>a</em>, <em>b</em>) and gcd(<em>b</em>, <em>a</em> mod <em>b</em>) divide each other. Since they are both nonnegative, equation (31.5) then implies that they must be equal.</p>
<p>We first show that gcd(<em>a</em>, <em>b</em>) | gcd(<em>b</em>, <em>a</em> mod <em>b</em>). If we let <em>d</em> = gcd(<em>a</em>, <em>b</em>), then <em>d</em> | <em>a</em> and <em>d</em> | <em>b</em>. By equation (3.11) on page 64, <em>a</em> mod <em>b</em> = <em>a</em> – <em>qb</em>, where <em>q</em> = <span class="font1">⌊</span><em>a</em>/<em>b</em><span class="font1">⌋</span>. Since <em>a</em> mod <em>b</em> is thus a linear combination of <em>a</em> and <em>b</em>, equation (31.4) implies that <em>d</em> | (<em>a</em> mod <em>b</em>). Therefore, since <em>d</em> | <em>b</em> and <em>d</em> | (<em>a</em> mod <em>b</em>), Corollary 31.3 implies that <em>d</em> | gcd(<em>b</em>, <em>a</em> mod <em>b</em>), that is,</p>
<p class="eqr"><img alt="art" src="images/Art_P1141.jpg"/></p>
<p>Showing that gcd(<em>b</em>, <em>a</em> mod <em>b</em>) | gcd(<em>a</em>, <em>b</em>) is almost the same. If we now let <em>d</em> = gcd(<em>b</em>, <em>a</em> mod <em>b</em>), then <em>d</em> | <em>b</em> and <em>d</em> | (<em>a</em> mod <em>b</em>). Since <em>a</em> = <em>qb</em> + (<em>a</em> mod <em>b</em>), <a id="p912"/>where <em>q</em> = <span class="font1">⌊</span><em>a</em>/<em>b</em><span class="font1">⌋</span>, we have that <em>a</em> is a linear combination of <em>b</em> and (<em>a</em> mod <em>b</em>). By equation (31.4), we conclude that <em>d</em> | <em>a</em>. Since <em>d</em> | <em>b</em> and <em>d</em> | <em>a</em>, we have that <em>d</em> | gcd(<em>a</em>, <em>b</em>) by Corollary 31.3, so that</p>
<p class="eqr"><img alt="art" src="images/Art_P1142.jpg"/></p>
<p class="noindent">Using equation (31.5) to combine equations (31.14) and (31.15) completes the proof.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Euclid’s algorithm</strong></p>
<p class="noindent">Euclid’s <em>Elements</em> (circa 300 <small>B</small>.<small>C</small>.<small>E</small>.) describes the following gcd algorithm, although its origin might be even earlier. The recursive procedure E<small>UCLID</small> implements Euclid’s algorithm, based directly on Theorem 31.9. The inputs <em>a</em> and <em>b</em> are arbitrary nonnegative integers.</p>
<div class="pull-quote1">
<p class="box-heading">E<small>UCLID</small>(<em>a</em>, <em>b</em>)</p>
<table class="table1c1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>b</em> == 0</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><strong>return</strong> <em>a</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="noindent"><strong>else return</strong> E<small>UCLID</small>(<em>b</em>, <em>a</em> mod <em>b</em>)</p></td>
</tr>
</table>
</div>
<p class="noindent">For example, here is how the procedure computes gcd(30, 21):</p>
<table class="table2b">
<tr>
<td class="td2">E<small>UCLID</small>(30, 21)</td>
<td class="td2">=</td>
<td class="td2">E<small>UCLID</small>(21, 9)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">E<small>UCLID</small>(9, 3)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">E<small>UCLID</small>(3, 0)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">3.</td>
</tr>
</table>
<p class="noindent">This computation calls E<small>UCLID</small> recursively three times.</p>
<p>The correctness of E<small>UCLID</small> follows from Theorem 31.9 and the property that if the algorithm returns <em>a</em> in line 2, then <em>b</em> = 0, so that by equation (31.9), gcd(<em>a</em>, <em>b</em>) = gcd(<em>a</em>, 0) = <em>a</em>. The algorithm cannot recurse indefinitely, since the second argument strictly decreases in each recursive call and is always nonnegative. Therefore, EUCLID always terminates with the correct answer.</p>
<p class="level4"><strong>The running time of Euclid’s algorithm</strong></p>
<p class="noindent">Let’s analyze the worst-case running time of E<small>UCLID</small> as a function of the size of <em>a</em> and <em>b</em>. The overall running time of E<small>UCLID</small> is proportional to the number of recursive calls it makes. The analysis assumes that <em>a</em> &gt; <em>b</em> ≥ 0, that is, the first argument is greater than the second argument. Why? If <em>b</em> = <em>a</em> &gt; 0, then <em>a</em> mod <em>b</em> = 0 and the procedure terminates after one recursive call. If <em>b</em> &gt; <em>a</em> ≥ 0, <a id="p913"/>then the procedure makes just one more recursive call than when <em>a</em> &gt; <em>b</em>, because in this case E<small>UCLID</small>(<em>a</em>, <em>b</em>) immediately makes the recursive call E<small>UCLID</small>(<em>b</em>, <em>a</em>), and now the first argument is greater than the second.</p>
<p>Our analysis relies on the Fibonacci numbers <em>F</em><sub><em>k</em></sub>, defined by the recurrence equation (3.31) on page 69.</p>
<p class="lem"><strong><em>Lemma 31.10</em></strong></p>
<p class="noindent">If <em>a</em> &gt; <em>b</em> ≥ 1 and the call E<small>UCLID</small>(<em>a</em>, <em>b</em>) performs <em>k</em> ≥ 1 recursive calls, then <em>a</em> ≥ <em>F</em><sub><em>k</em>+2</sub> and <em>b</em> ≥ <em>F</em><sub><em>k</em>+1</sub>.</p>
<p class="proof"><strong><em>Proof</em></strong>   The proof proceeds by induction on <em>k</em>. For the base case of the induction, let <em>k</em> = 1. Then, <em>b</em> ≥ 1 = <em>F</em><sub>2</sub>, and since <em>a</em> &gt; <em>b</em>, we must have <em>a</em> ≥ 2 = <em>F</em><sub>3</sub>. Since <em>b</em> &gt; (<em>a</em> mod <em>b</em>), in each recursive call the first argument is strictly larger than the second. The assumption that <em>a</em> &gt; <em>b</em> therefore holds for each recursive call.</p>
<p>Assuming inductively that the lemma holds if the procedure makes <em>k</em> – 1 recursive calls, we shall prove that the lemma holds for <em>k</em> recursive calls. Since <em>k</em> &gt; 0, we have <em>b</em> &gt; 0, and E<small>UCLID</small>(<em>a</em>, <em>b</em>) calls E<small>UCLID</small>(<em>b</em>, <em>a</em> mod <em>b</em>) recursively, which in turn makes <em>k</em> – 1 recursive calls. The inductive hypothesis then implies that <em>b</em> ≥ <em>F</em><sub><em>k</em>+1</sub> (thus proving part of the lemma), and <em>a</em> mod <em>b</em> ≥ <em>F</em><sub><em>k</em></sub>. We have</p>
<table class="table2b">
<tr>
<td class="td2"><em>b</em> + (<em>a</em> mod <em>b</em>)</td>
<td class="td2">= <em>b</em> + (<em>a</em> – <em>b</em> <span class="font1">⌊</span><em>a</em>/<em>b</em><span class="font1">⌋</span>)</td>
<td class="td2">(by equation (3.11))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≤ <em>a</em>,</td>
<td class="td2"/>
</tr>
</table>
<p class="noindent">since <em>a</em> &gt; <em>b</em> &gt; 0 implies <span class="font1">⌊</span><em>a</em>/<em>b</em><span class="font1">⌋</span> ≥ 1. Thus,</p>
<table class="table2b">
<tr>
<td class="td2"><em>a</em></td>
<td class="td2">≥</td>
<td class="td2"><em>b</em> + (<em>a</em> mod <em>b</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≥</td>
<td class="td2"><em>F</em><sub><em>k</em>+1</sub> + <em>F</em><sub><em>k</em></sub></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>F</em><sub><em>k</em>+2</sub>.</td>
</tr>
</table>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The following theorem is an immediate corollary of this lemma.</p>
<p class="theo"><strong><em>Theorem 31.11 (Lamé’s theorem)</em></strong></p>
<p class="noindent">For any integer <em>k</em> ≥ 1, if <em>a</em> &gt; <em>b</em> ≥ 1 and <em>b</em> &lt; <em>F</em><sub><em>k</em>+1</sub>, then the call E<small>UCLID</small>(<em>a</em>, <em>b</em>) makes fewer than <em>k</em> recursive calls.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">To show that the upper bound of Theorem 31.11 is the best possible, we’ll show that the call E<small>UCLID</small>(<em>F</em><sub><em>k</em>+1</sub>, <em>F</em><sub><em>k</em></sub>) makes exactly <em>k</em> – 1 recursive calls when <em>k</em> ≥ 2. We use induction on <em>k</em>. For the base case, <em>k</em> = 2, and the call E<small>UCLID</small>(<em>F</em><sub>3</sub>, <em>F</em><sub>2</sub>) makes exactly one recursive call, to E<small>UCLID</small>(1, 0). (We have to start at <em>k</em> = 2, because when <em>k</em> = 1 we do not have <em>F</em><sub>2</sub> &gt; <em>F</em><sub>1</sub>.) For the inductive step, assume that E<small>UCLID</small>(<em>F</em><sub><em>k</em></sub>, <em>F</em><sub><em>k</em>−1</sub>) makes exactly <em>k</em> – 2 recursive calls. For <em>k</em> &gt; 2, we have <em>F</em><sub><em>k</em></sub> &gt; <em>F</em><sub><em>k</em>−1</sub> &gt; 0 and <em>F</em><sub><em>k</em>+1</sub> = <em>F</em><sub><em>k</em></sub> + <em>F</em><sub><em>k</em>−1</sub>, and so by Exercise 31.1-1, we <a id="p914"/>have <em>F</em><sub><em>k</em>+1</sub> mod <em>F</em><sub><em>k</em></sub> = <em>F</em><sub><em>k</em>−1</sub>. Because E<small>UCLID</small>(<em>a</em>, <em>b</em>) calls E<small>UCLID</small>(<em>b</em>, <em>a</em> mod <em>b</em>) when <em>b</em> &gt; 0, the call E<small>UCLID</small>(<em>F</em><sub><em>k</em>+1</sub>, <em>F</em><sub><em>k</em></sub>) recurses one time more than the call E<small>UCLID</small>(<em>F</em><sub><em>k</em></sub>, <em>F</em><sub><em>k</em>−1</sub>), or exactly <em>k</em> – 1 times, which meets the upper bound given by Theorem 31.11.</p>
<p>Since <em>F</em><sub><em>k</em></sub> is approximately <img alt="art" src="images/Art_P1143.jpg"/>, where <em><span class="symbolfont">ϕ</span></em> is the golden ratio <img alt="art" src="images/Art_P1144.jpg"/> defined by equation (3.32) on page 69, the number of recursive calls in E<small>UCLID</small> is <em>O</em>(1g <em>b</em>). (See Exercise 31.2-5 for a tighter bound.) Therefore, a call of E<small>UCLID</small> on two <em>β</em>-bit numbers performs <em>O</em>(<em>β</em>) arithmetic operations and <em>O</em>(<em>β</em><sup>3</sup>) bit operations (assuming that multiplication and division of <em>β</em>-bit numbers take <em>O</em>(<em>β</em><sup>2</sup>) bit operations). Problem 31-2 asks you to prove an <em>O</em>(<em>β</em><sup>2</sup>) bound on the number of bit operations.</p>
<p class="level4"><strong>The extended form of Euclid’s algorithm</strong></p>
<p class="noindent">By rewriting Euclid’s algorithm, we can gain additional useful information. Specifically, let’s extend the algorithm to compute the integer coefficients <em>x</em> and <em>y</em> such that</p>
<p class="eqr"><img alt="art" src="images/Art_P1145.jpg"/></p>
<p class="noindent">where either or both of <em>x</em> and <em>y</em> may be zero or negative. These coefficients will prove useful later for computing modular multiplicative inverses. The procedure E<small>XTENDED</small>-E<small>UCLID</small> takes as input a pair of nonnegative integers and returns a triple of the form (<em>d</em>, <em>x</em>, <em>y</em>) that satisfies equation (31.16). As an example, <a href="chapter031.xhtml#Fig_31-1">Figure 31.1</a> traces out the call E<small>XTENDED</small>-E<small>UCLID</small>(99, 78).</p>
<div class="pull-quote1">
<p class="box-heading">E<small>XTENDED</small>-E<small>UCLID</small>(<em>a</em>, <em>b</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><p class="noindent"><strong>if</strong> <em>b</em> == 0</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><strong>return</strong> (<em>a</em>, 1, 0)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="noindent"><strong>else</strong> (<em>d</em>′, <em>x</em>′, <em>y</em>′) = E<small>XTENDED</small>-E<small>UCLID</small>(<em>b</em>, <em>a</em> mod <em>b</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2">(<em>d</em>, <em>x</em>, <em>y</em>) = (<em>d</em>′, <em>y</em>′, <em>x</em>′ – <span class="font1">⌊</span><em>a</em>/<em>b</em><span class="font1">⌋</span> <em>y</em>′)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p2"><strong>return</strong> (<em>d</em>, <em>x</em>, <em>y</em>)</p></td>
</tr>
</table>
</div>
<p>The E<small>XTENDED</small>-E<small>UCLID</small> procedure is a variation of the E<small>UCLID</small> procedure. Line 1 is equivalent to the test “<em>b</em> == 0” in line 1 of E<small>UCLID</small>. If <em>b</em> = 0, then E<small>XTENDED</small>-E<small>UCLID</small> returns not only <em>d</em> = <em>a</em> in line 2, but also the coefficients <em>x</em> = 1 and <em>y</em> = 0, so that <em>a</em> = <em>ax</em> + <em>by</em>. If <em>b</em> ≠ 0, E<small>XTENDED</small>-E<small>UCLID</small> first computes (<em>d</em>′, <em>x</em>′, <em>y</em>′) such that <em>d</em>′ = gcd(<em>b</em>, <em>a</em> mod <em>b</em>) and</p>
<p class="eqr"><img alt="art" src="images/Art_P1146.jpg"/></p>
<p class="noindent">As in the E<small>UCLID</small> procedure, we have <em>d</em> = gcd(<em>a</em>, <em>b</em>) = <em>d</em>′ = gcd(<em>b</em>, <em>a</em> mod <em>b</em>). To obtain <em>x</em> and <em>y</em> such that <em>d</em> = <em>ax</em> + <em>by</em>, let’s rewrite equation (31.17), setting <a id="p915"/><em>d</em> = <em>d</em>′ and using equation (3.11):</p>
<div class="divimage">
<p class="fig-img1" id="Fig_31-1"><img alt="art" src="images/Art_P1147.jpg"/></p>
<p class="caption"><strong>Figure 31.1</strong> How E<small>XTENDED</small>-E<small>UCLID</small> computes gcd(99, 78). Each line shows one level of the recursion: the values of the inputs <em>a</em> and <em>b</em>, the computed value <span class="font1">⌊</span><em>a</em>/<em>b</em><span class="font1">⌋</span>, and the values <em>d</em>, <em>x</em>, and <em>y</em> returned. The triple (<em>d</em>, <em>x</em>, <em>y</em>) returned becomes the triple (<em>d</em>′, <em>x</em>′, <em>y</em>′) used at the next higher level of recursion. The call E<small>XTENDED</small>-E<small>UCLID</small>(99, 78) returns (3, –11, 14), so that gcd(99, 78) = 3 = 99 · (–11) + 78 · 14.</p>
</div>
<table class="table2b">
<tr>
<td class="td2"><em>d</em></td>
<td class="td2">=</td>
<td class="td2"><em>bx</em>′ + (<em>a</em> – <em>b</em> <span class="font1">⌊</span><em>a</em>/<em>b</em><span class="font1">⌋</span>)<em>y</em>′</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>ay</em>′ + <em>b</em>(<em>x</em>′ – <span class="font1">⌊</span><em>a</em>/<em>b</em><span class="font1">⌋</span> <em>y</em>′).</td>
</tr>
</table>
<p class="noindent">Thus, choosing <em>x</em> = <em>y</em>′ and <em>y</em> = <em>x</em>′ – <span class="font1">⌊</span><em>a</em>/<em>b</em><span class="font1">⌋</span> <em>y</em>′ satisfies the equation <em>d</em> = <em>ax</em> + <em>by</em>, thereby proving the correctness of E<small>XTENDED</small>-E<small>UCLID</small>.</p>
<p>Since the number of recursive calls made in E<small>UCLID</small> is equal to the number of recursive calls made in E<small>XTENDED</small>-E<small>UCLID</small>, the running times of E<small>UCLID</small> and E<small>XTENDED</small>-E<small>UCLID</small> are the same, to within a constant factor. That is, for <em>a</em> &gt; <em>b</em> &gt; 0, the number of recursive calls is <em>O</em>(1g <em>b</em>).</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>31.2-1</em></strong></p>
<p class="noindent">Prove that equations (31.11) and (31.12) imply equation (31.13).</p>
<p class="level3"><strong><em>31.2-2</em></strong></p>
<p class="noindent">Compute the values (<em>d</em>, <em>x</em>, <em>y</em>) that the call E<small>XTENDED</small>-E<small>UCLID</small>(899, 493) returns.</p>
<p class="level3"><strong><em>31.2-3</em></strong></p>
<p class="noindent">Prove that for all integers <em>a</em>, <em>k</em>, and <em>n</em>,</p>
<p class="eqr"><img alt="art" src="images/Art_P1148.jpg"/></p>
<p class="noindent">Use equation (31.18) to show that <em>a</em> = 1 (mod <em>n</em>) implies gcd(<em>a</em>, <em>n</em>) = 1.</p>
<p class="level3"><strong><em>31.2-4</em></strong></p>
<p class="noindent">Rewrite E<small>UCLID</small> in an iterative form that uses only a constant amount of memory (that is, stores only a constant number of integer values).</p>
<a id="p916"/>
<p class="level3"><strong><em>31.2-5</em></strong></p>
<p class="noindent">If <em>a</em> &gt; <em>b</em> ≥ 0, show that the call E<small>UCLID</small> (<em>a</em>, <em>b</em>) makes at most 1 + log<sub><em><span class="symbolfont">ϕ</span></em></sub> <em>b</em> recursive calls. Improve this bound to 1 + log<sub><em><span class="symbolfont">ϕ</span></em></sub>(<em>b</em>/gcd(<em>a</em>, <em>b)</em>).</p>
<p class="level3"><strong><em>31.2-6</em></strong></p>
<p class="noindent">What does E<small>XTENDED</small>-E<small>UCLID</small>(<em>F</em><sub><em>k</em>+1</sub>, <em>F</em><sub><em>k</em></sub>) return? Prove your answer correct.</p>
<p class="level3"><strong><em>31.2-7</em></strong></p>
<p class="noindent">Define the gcd function for more than two arguments by the recursive equation gcd(<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, …, <em>a</em><sub><em>n</em></sub>) = gcd(<em>a</em><sub>0</sub>, gcd(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>n</em></sub>)). Show that the gcd function returns the same answer independent of the order in which its arguments are specified. Also show how to find integers <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, …, <em>x</em><sub><em>n</em></sub> such that gcd(<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, …, <em>a</em><sub><em>n</em></sub>) = <em>a</em><sub>0</sub><em>x</em><sub>0</sub> + <em>a</em><sub>1</sub><em>x</em><sub>1</sub> + <span class="font1">⋯</span> + <em>a</em><sub><em>n</em></sub><em>x</em><sub><em>n</em></sub>. Show that the number of divisions performed by your algorithm is <em>O</em>(<em>n</em> + 1g(max {<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, …, <em>a</em><sub><em>n</em></sub>})).</p>
<p class="level3"><strong><em>31.2-8</em></strong></p>
<p class="noindent">The <span class="blue"><strong><em>least common multiple</em></strong></span> 1cm(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>n</em></sub>) of integers <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>n</em></sub> is the smallest nonnegative integer that is a multiple of each <em>a</em><sub><em>i</em></sub>. Show how to compute 1cm(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>n</em></sub>) efficiently using the (two-argument) gcd operation as a subroutine.</p>
<p class="level3"><strong><em>31.2-9</em></strong></p>
<p class="noindent">Prove that <em>n</em><sub>1</sub>, <em>n</em><sub>2</sub>, <em>n</em><sub>3</sub>, and <em>n</em><sub>4</sub> are pairwise relatively prime if and only if</p>
<p class="eql">gcd(<em>n</em><sub>1</sub><em>n</em><sub>2</sub>, <em>n</em><sub>3</sub><em>n</em><sub>4</sub>) = gcd(<em>n</em><sub>1</sub><em>n</em><sub>3</sub>, <em>n</em><sub>2</sub><em>n</em><sub>4</sub>) = 1.</p>
<p class="noindent">More generally, show that <em>n</em><sub>1</sub>, <em>n</em><sub>2</sub>, …, <em>n</em><sub><em>k</em></sub> are pairwise relatively prime if and only if a set of <span class="font1">⌈</span>1g <em>k</em><span class="font1">⌉</span> pairs of numbers derived from the <em>n</em><sub><em>i</em></sub> are relatively prime.</p>
</section>
<p class="line1"/>
<section title="31.3 Modular arithmetic">
<a id="Sec_31.3"/>
<p class="level1" id="h1-179"><a href="toc.xhtml#Rh1-179"><strong>31.3    Modular arithmetic</strong></a></p>
<p class="noindent">Informally, you can think of modular arithmetic as arithmetic as usual over the integers, except that when working modulo <em>n</em>, then every result <em>x</em> is replaced by the element of {0, 1, …, <em>n</em> – 1} that is equivalent to <em>x</em>, modulo <em>n</em> (so that <em>x</em> is replaced by <em>x</em> mod <em>n</em>). This informal model suffices if you stick to the operations of addition, subtraction, and multiplication. A more formal model for modular arithmetic, which follows, is best described within the framework of group theory.</p>
<a id="p917"/>
<p class="level4"><strong>Finite groups</strong></p>
<p class="noindent">A <span class="blue"><strong><em>group</em></strong></span> (<em>S</em>, ⊕) is a set <em>S</em> together with a binary operation ⊕ defined on <em>S</em> for which the following properties hold:</p>
<ol class="olnoindent" epub:type="list">
<li><strong>Closure:</strong> For all <em>a</em>, <em>b</em> ∈ <em>S</em>, we have <em>a</em> ⊕ <em>b</em> ∈ <em>S</em>.</li>
<li class="litop"><strong>Identity:</strong> There exists an element <em>e</em> ∈ <em>S</em>, called the <span class="blue"><strong><em>identity</em></strong></span> of the group, such that <em>e</em> ⊕ <em>a</em> = <em>a</em> ⊕ <em>e</em> = <em>a</em> for all <em>a</em> ∈ <em>S</em>.</li>
<li class="litop"><strong>Associativity:</strong> For all <em>a</em>, <em>b</em>, <em>c</em> ∈ <em>S</em>, we have (<em>a</em> ⊕ <em>b</em>) ⊕ <em>c</em> = <em>a</em> ⊕ (<em>b</em> ⊕ <em>c</em>).</li>
<li class="litop"><strong>Inverses:</strong> For each <em>a</em> ∈ <em>S</em>, there exists a unique element <em>b</em> ∈ <em>S</em>, called the <span class="blue"><strong><em>inverse</em></strong></span> of <em>a</em>, such that <em>a</em> ⊕ <em>b</em> = <em>b</em> ⊕ <em>a</em> = <em>e</em>.</li></ol>
<p class="noindent">As an example, consider the familiar group (<span class="font1">ℤ</span>, +) of the integers <span class="font1">ℤ</span> under the operation of addition: 0 is the identity, and the inverse of <em>a</em> is –<em>a</em>. An <span class="blue"><strong><em>abelian group</em></strong></span> (<em>S</em>, ⊕) satisfies the <span class="blue"><strong><em>commutative law</em></strong></span> <em>a</em> ⊕ <em>b</em> = <em>b</em> ⊕ <em>a</em> for all <em>a</em>, <em>b</em> ∈ <em>S</em>. The <span class="blue"><strong><em>size</em></strong></span> of group (<em>S</em>, ⊕) is |<em>S</em>|, and if |<em>S</em>| &lt; ∞, then (<em>S</em>, ⊕) is a <span class="blue"><strong><em>finite group</em></strong></span>.</p>
<p class="level4"><strong>The groups defined by modular addition and multiplication</strong></p>
<p class="noindent">We can form two finite abelian groups by using addition and multiplication modulo <em>n</em>, where <em>n</em> is a positive integer. These groups are based on the equivalence classes of the integers modulo <em>n</em>, defined in <a href="chapter031.xhtml#Sec_31.1">Section 31.1</a>.</p>
<p>To define a group on <span class="font1">ℤ</span><sub><em>n</em></sub>, we need suitable binary operations, which we obtain by redefining the ordinary operations of addition and multiplication. We can define addition and multiplication operations for <span class="font1">ℤ</span><sub><em>n</em></sub>, because the equivalence class of two integers uniquely determines the equivalence class of their sum or product. That is, if <em>a</em> = <em>a</em>′ (mod <em>n</em>) and <em>b</em> = <em>b</em>′ (mod <em>n</em>), then</p>
<table class="table2b">
<tr>
<td class="td2"><em>a</em> + <em>b</em></td>
<td class="td2">=</td>
<td class="td2"><em>a</em>′ + <em>b</em>′</td>
<td class="td2">(mod <em>n</em>),</td>
</tr>
<tr>
<td class="td2"><em>ab</em></td>
<td class="td2">=</td>
<td class="td2"><em>a</em>′<em>b</em>′</td>
<td class="td2">(mod <em>n</em>).</td>
</tr>
</table>
<p class="noindent">Thus, we define addition and multiplication modulo <em>n</em>, denoted +<sub><em>n</em></sub> and ·<sub><em>n</em></sub>, by</p>
<p class="eqr"><img alt="art" src="images/Art_P1149.jpg"/></p>
<p class="noindent">(We can define subtraction similarly on <span class="font1">ℤ</span><sub><em>n</em></sub> by [<em>a</em>]<sub><em>n</em></sub> –<sub><em>n</em></sub> [<em>b</em>]<sub><em>n</em></sub> = [<em>a</em> – <em>b</em>]<sub><em>n</em></sub>, but division is more complicated, as we’ll see.) These facts justify the common and convenient practice of using the smallest nonnegative element of each equivalence class as its representative when performing computations in <span class="font1">ℤ</span><sub><em>n</em></sub>. We add, subtract, and multiply as usual on the representatives, but we replace each result <em>x</em> by the representative of its class, that is, by <em>x</em> mod <em>n</em>.</p>
<a id="p918"/>
<div class="divimage">
<p class="fig-img1" id="Fig_31-2"><img alt="art" src="images/Art_P1150.jpg"/></p>
<p class="caption"><strong>Figure 31.2</strong> Two finite groups. Equivalence classes are denoted by their representative elements. <strong>(a)</strong> The group (<span class="font1">ℤ</span><sub>6</sub>, +<sub>6</sub>). <strong>(b)</strong> The group <img alt="art" src="images/Art_P1151.jpg"/>.</p>
</div>
<p>Using this definition of addition modulo <em>n</em>, we define the <span class="blue"><strong><em>additive group modulo n</em></strong></span> as (<span class="font1">ℤ</span><sub><em>n</em></sub>, +<sub><em>n</em></sub>). The size of the additive group modulo <em>n</em> is |<span class="font1">ℤ</span><sub><em>n</em></sub>| = <em>n</em>. <a href="chapter031.xhtml#Fig_31-2">Figure 31.2(a)</a> gives the operation table for the group (<span class="font1">ℤ</span><sub>6</sub>, +<sub>6</sub>).</p>
<p class="theo"><strong><em>Theorem 31.12</em></strong></p>
<p class="noindent">The system (<span class="font1">ℤ</span><sub><em>n</em></sub>, +<sub><em>n</em></sub>) is a finite abelian group.</p>
<p class="proof"><strong><em>Proof</em></strong>   Equation (31.19) shows that (<span class="font1">ℤ</span><sub><em>n</em></sub>, +<sub><em>n</em></sub>) is closed. Associativity and commutativity of +<sub><em>n</em></sub> follow from the associativity and commutativity of +:</p>
<table class="table2b">
<tr>
<td class="td2"><p class="right">([<em>a</em>]<sub><em>n</em></sub> +<sub><em>n</em></sub> [<em>b</em>]<sub><em>n</em></sub>) +<sub><em>n</em></sub> [<em>c</em>]<sub><em>n</em></sub></p></td>
<td class="td2">=</td>
<td class="td2">[<em>a</em> + <em>b</em>]<sub><em>n</em></sub> +<sub><em>n</em></sub> [<em>c</em>]<sub><em>n</em></sub></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">[(<em>a</em> + <em>b</em>) + <em>c</em>]<sub><em>n</em></sub></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">[<em>a</em> + (<em>b</em> + <em>c</em>)]<sub><em>n</em></sub></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">[<em>a</em>]<sub><em>n</em></sub> +<sub><em>n</em></sub> [<em>b</em> + <em>c</em>]<sub><em>n</em></sub></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">[<em>a</em>]<sub><em>n</em></sub> +<sub><em>n</em></sub> ([<em>b</em>]<sub><em>n</em></sub> +<sub><em>n</em></sub> [<em>c</em>]<sub><em>n</em></sub>),</td>
</tr>
<tr>
<td class="td2" colspan="3" rowspan="1"> </td>
</tr>
<tr>
<td class="td2"><p class="right">[<em>a</em>]<sub><em>n</em></sub> +<sub><em>n</em></sub> [<em>b</em>]<sub><em>n</em></sub></p></td>
<td class="td2">=</td>
<td class="td2">[<em>a</em> + <em>b</em>]<sub><em>n</em></sub></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">[<em>b</em> + <em>a</em>]<sub><em>n</em></sub></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">[<em>b</em>]<sub><em>n</em></sub> +<sub><em>n</em></sub> [<em>a</em>]<sub><em>n</em></sub>.</td>
</tr>
</table>
<p class="noindent">The identity element of (<span class="font1">ℤ</span><sub><em>n</em></sub>, +<sub><em>n</em></sub>) is 0 (that is, [0]<sub><em>n</em></sub>). The (additive) inverse of an element <em>a</em> (that is, of [<em>a</em>]<sub><em>n</em></sub>) is the element –<em>a</em> (that is, [–<em>a</em>]<sub><em>n</em></sub> or [<em>n</em> – <em>a</em>]<sub><em>n</em></sub>), since [<em>a</em>]<sub><em>n</em></sub> +<sub><em>n</em></sub> [–<em>a</em>]<sub><em>n</em></sub> = [<em>a</em> – <em>a</em>]<sub><em>n</em></sub> = [0]<sub><em>n</em></sub>.</p>
<p class="right"><span class="font1">▪</span></p>
<a id="p919"/>
<p>Using the definition of multiplication modulo <em>n</em>, we define the <span class="blue"><strong><em>multiplicative group modulo n</em></strong></span> as <img alt="art" src="images/Art_P1152.jpg"/>. The elements of this group are the set <img alt="art" src="images/Art_P1153.jpg"/> of elements in <span class="font1">ℤ</span><sub><em>n</em></sub> that are relatively prime to <em>n</em>, so that each one has a unique inverse, modulo <em>n</em>:</p>
<p class="eql"><img alt="art" src="images/Art_P1154.jpg"/></p>
<p class="noindent">To see that <img alt="art" src="images/Art_P1153.jpg"/> is well defined, note that for 0 ≤ <em>a</em> &lt; <em>n</em>, we have <em>a</em> = (<em>a</em> + <em>kn</em>) (mod <em>n</em>) for all integers <em>k</em>. By Exercise 31.2-3, therefore, gcd(<em>a</em>, <em>n</em>) = 1 implies gcd(<em>a</em> + <em>kn</em>, <em>n</em>) = 1 for all integers <em>k</em>. Since [<em>a</em>]<sub><em>n</em></sub> = {<em>a</em> + <em>kn</em> : <em>k</em> ∈ <span class="font1">ℤ</span>}, the set <img alt="art" src="images/Art_P1153.jpg"/> is well defined. An example of such a group is</p>
<p class="eql"><img alt="art" src="images/Art_P1157.jpg"/></p>
<p class="noindent">where the group operation is multiplication modulo 15. (We have denoted an element [<em>a</em>]<sub>15</sub> as <em>a</em>, and thus, for example, we denote [7]<sub>15</sub> as 7.) <a href="chapter031.xhtml#Fig_31-2">Figure 31.2(b)</a> shows the group <img alt="art" src="images/Art_P1158.jpg"/>. For example, 8 · 11 = 13 (mod 15), working in <img alt="art" src="images/Art_P1159.jpg"/>. The identity for this group is 1.</p>
<p class="theo"><strong><em>Theorem 31.13</em></strong></p>
<p class="noindent">The system <img alt="art" src="images/Art_P1160.jpg"/> is a finite abelian group.</p>
<p class="proof"><strong><em>Proof</em></strong>   Theorem 31.6 implies that <img alt="art" src="images/Art_P1152.jpg"/> is closed. Associativity and commutativity can be proved for ·<sub><em>n</em></sub> as they were for +<sub><em>n</em></sub> in the proof of Theorem 31.12. The identity element is [1]<sub><em>n</em></sub>. To show the existence of inverses, let <em>a</em> be an element of <img alt="art" src="images/Art_P1153.jpg"/> and let (<em>d</em>, <em>x</em>, <em>y</em>) be returned by E<small>XTENDED</small>-E<small>UCLID</small>(<em>a</em>, <em>n</em>). Then we have <em>d</em> = 1, since <img alt="art" src="images/Art_P1163.jpg"/>, and</p>
<p class="eqr"><img alt="art" src="images/Art_P1164.jpg"/></p>
<p class="noindent">or equivalently,</p>
<p class="eql"><em>ax</em> = 1 (mod <em>n</em>).</p>
<p class="noindent">Thus [<em>x</em>]<sub><em>n</em></sub> is a multiplicative inverse of [<em>a</em>]<sub><em>n</em></sub>, modulo <em>n</em>. Furthermore, we claim that <img alt="art" src="images/Art_P1165.jpg"/>. To see why, equation (31.20) demonstrates that the smallest positive linear combination of <em>x</em> and <em>n</em> must be 1. Therefore, Theorem 31.2 implies that gcd(<em>x</em>, <em>n</em>) = 1. We defer the proof that inverses are uniquely defined until Corollary 31.26 in <a href="chapter031.xhtml#Sec_31.4">Section 31.4</a>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">As an example of computing multiplicative inverses, suppose that <em>a</em> = 5 and <em>n</em> = 11. Then E<small>XTENDED</small>-E<small>UCLID</small>(<em>a</em>, <em>n</em>) returns (<em>d</em>, <em>x</em>, <em>y</em>) = (1, –2, 1), so that 1 = 5 · (–2) + 11 · 1. Thus, [–2]<sub>11</sub> (i.e., [9]<sub>11</sub>) is the multiplicative inverse of [5]<sub>11</sub>.</p>
<p>When working with the groups (<span class="font1">ℤ</span><sub><em>n</em></sub>, +<sub><em>n</em></sub>) and <img alt="art" src="images/Art_P1160.jpg"/> in the remainder of this chapter, we follow the convenient practice of denoting equivalence classes by their representative elements and denoting the operations +<sub><em>n</em></sub> and ·<sub><em>n</em></sub> by the usual <a id="p920"/>arithmetic notations + and · (or juxtaposition, so that <em>ab</em> = <em>a</em> · <em>b</em>) respectively. Furthermore, equivalences modulo <em>n</em> may also be interpreted as equations in <span class="font1">ℤ</span><sub><em>n</em></sub>. For example, the following two statements are equivalent:</p>
<p class="eql"><em>ax</em> = <em>b</em> (mod <em>n</em>)</p>
<p class="noindent">and</p>
<p class="eql">[<em>a</em>]<sub><em>n</em></sub> ·<sub><em>n</em></sub> [<em>x</em>]<sub><em>n</em></sub> = [<em>b</em>]<sub><em>n</em></sub>.</p>
<p>As a further convenience, we sometimes refer to a group (<em>S</em>, ⊕) merely as <em>S</em> when the operation ⊕ is understood from context. We may thus refer to the groups (<span class="font1">ℤ</span><sub><em>n</em></sub>, +<sub><em>n</em></sub>) and <img alt="art" src="images/Art_P1160.jpg"/> as just <span class="font1">ℤ</span><sub><em>n</em></sub> and <img alt="art" src="images/Art_P1153.jpg"/>, respectively.</p>
<p>We denote the (multiplicative) inverse of an element <em>a</em> by (<em>a</em><sup>−1</sup> mod <em>n</em>). Division in <img alt="art" src="images/Art_P1153.jpg"/> is defined by the equation <em>a</em>/<em>b</em> = <em>ab</em><sup>−1</sup> (mod <em>n</em>). For example, in <img alt="art" src="images/Art_P1159.jpg"/> we have that 7<sup>−1</sup> = 13 (mod 15), since 7 · 13 = 91 = 1 (mod 15), so that 2/7 = 2 · 13 = 11 (mod 15).</p>
<p>The size of <img alt="art" src="images/Art_P1153.jpg"/> is denoted <em><span class="symbolfont">ϕ</span></em>(<em>n</em>). This function, known as <span class="blue"><strong><em>Euler’s phi function</em></strong></span>, satisfies the equation</p>
<p class="eqr"><img alt="art" src="images/Art_P1172.jpg"/></p>
<p class="noindent">so that <em>p</em> runs over all the primes dividing <em>n</em> (including <em>n</em> itself, if <em>n</em> is prime). We won’t prove this formula here. Intuitively, begin with a list of the <em>n</em> remainders {0, 1, …, <em>n</em> – 1} and then, for each prime <em>p</em> that divides <em>n</em>, cross out every multiple of <em>p</em> in the list. For example, since the prime divisors of 45 are 3 and 5,</p>
<p class="eql"><img alt="art" src="images/Art_P1173.jpg"/></p>
<p class="noindent">If <em>p</em> is prime, then <img alt="art" src="images/Art_P1174.jpg"/>, and</p>
<p class="eqr"><img alt="art" src="images/Art_P1175.jpg"/></p>
<p class="noindent">If <em>n</em> is composite, then <em><span class="symbolfont">ϕ</span></em>(<em>n</em>) &lt; <em>n</em> – 1, although it can be shown that</p>
<p class="eqr"><img alt="art" src="images/Art_P1176.jpg"/></p>
<a id="p921"/>
<p class="noindent">for <em>n</em> ≥ 3, where <em>γ</em> = 0.5772156649 … is <span class="blue"><strong><em>Euler’s constant</em></strong></span>. A somewhat simpler (but looser) lower bound for <em>n</em> &gt; 5 is</p>
<p class="eqr"><img alt="art" src="images/Art_P1177.jpg"/></p>
<p class="noindent">The lower bound (31.23) is essentially the best possible, since</p>
<p class="eqr"><img alt="art" src="images/Art_P1178.jpg"/></p>
<p class="level4"><strong>Subgroups</strong></p>
<p class="noindent">If (<em>S</em>, ⊕) is a group, <em>S</em>′ ⊆ <em>S</em>, and (<em>S</em>′, ⊕) is also a group, then (<em>S</em>′, ⊕) is a <span class="blue"><strong><em>subgroup</em></strong></span> of (<em>S</em>, ⊕). For example, the even integers form a subgroup of the integers under the operation of addition. The following theorem, whose proof we leave as Exercise 31.3-3, provides a useful tool for recognizing subgroups.</p>
<p class="theo"><strong><em>Theorem 31.14 (A nonempty closed subset of a finite group is a subgroup)</em></strong></p>
<p class="noindent">If (<em>S</em>, ⊕) is a finite group and <em>S</em>′ is any nonempty subset of <em>S</em> such that <em>a</em> ⊕ <em>b</em> ∈ <em>S</em>′ for all <em>a</em>, <em>b</em> ∈ <em>S</em>′, then (<em>S</em>′, ⊕) is a subgroup of (<em>S</em>, ⊕).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">For example, the set {0, 2, 4, 6} forms a subgroup of <span class="font1">ℤ</span><sub>8</sub>, since it is nonempty and closed under the operation + (that is, it is closed under +<sub>8</sub>).</p>
<p>The following theorem, whose proof is omitted, provides an extremely useful constraint on the size of a subgroup.</p>
<p class="theo"><strong><em>Theorem 31.15 (Lagrange’s theorem)</em></strong></p>
<p class="noindent">If (<em>S</em>, ⊕) is a finite group and (<em>S</em>′, ⊕) is a subgroup of (<em>S</em>, ⊕), then |<em>S</em>′| is a divisor of |<em>S</em>|.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">A subgroup <em>S</em>′ of a group <em>S</em> is a <span class="blue"><strong><em>proper</em></strong></span> subgroup if <em>S</em>′ ≠ <em>S</em>. We’ll use the following corollary in the analysis in <a href="chapter031.xhtml#Sec_31.8">Section 31.8</a> of the Miller-Rabin primality test procedure.</p>
<p class="cor"><strong><em>Corollary 31.16</em></strong></p>
<p class="noindent">If <em>S</em>′ is a proper subgroup of a finite group <em>S</em>, then |<em>S</em>′| ≤ |<em>S</em>|/2.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Subgroups generated by an element</strong></p>
<p class="noindent">Theorem 31.14 affords us a straightforward way to produce a subgroup of a finite group (<em>S</em>, ⊕): choose an element <em>a</em> and take all elements that can be generated from <em>a</em> using the group operation. Specifically, define <em>a</em><sup>(<em>k</em>)</sup> for <em>k</em> ≥ 1 by</p>
<a id="p922"/>
<p class="eql"><img alt="art" src="images/Art_P1179.jpg"/></p>
<p class="noindent">For example, taking <em>a</em> = 2 in the group <span class="font1">ℤ</span><sub>6</sub> yields the sequence</p>
<p class="eql"><em>a</em><sup>(1)</sup>, <em>a</em><sup>(2)</sup>, <em>a</em><sup>(3)</sup>, … = 2, 4, 0, 2, 4, 0, 2, 4, 0, ….</p>
<p class="noindent">We have <em>a</em><sup>(<em>k</em>)</sup> = <em>ka</em> mod <em>n</em> in the group <span class="font1">ℤ</span><sub><em>n</em></sub>, and <em>a</em><sup>(<em>k</em>)</sup> = <em>a</em><sup><em>k</em></sup> mod <em>n</em> in the group <img alt="art" src="images/Art_P1153.jpg"/>. We define the <span class="blue"><strong><em>subgroup generated by a</em></strong></span>, denoted <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> or (<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>, ⊕), by</p>
<p class="eql"><span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> = {<em>a</em><sup>(<em>k</em>)</sup> : <em>k</em> ≥ 1}.</p>
<p class="noindent">We say that <em>a</em> <span class="blue"><strong><em>generates</em></strong></span> the subgroup <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> or that <em>a</em> is a <span class="blue"><strong><em>generator</em></strong></span> of <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>. Since <em>S</em> is finite, <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> is a finite subset of <em>S</em>, possibly including all of <em>S</em>. Since the associativity of ⊕ implies</p>
<p class="eql"><em>a</em><sup>(<em>i</em>)</sup> ⊕ <em>a</em><sup>(<em>j</em>)</sup> = <em>a</em><sup>(<em>i</em>+<em>j</em>)</sup>,</p>
<p class="noindent"><span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> is closed and therefore, by Theorem 31.14, <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> is a subgroup of <em>S</em>. For example, in <span class="font1">ℤ</span><sub>6</sub>, we have</p>
<table class="table2b">
<tr>
<td class="td2"><span class="font1"><span class="font1">〈</span></span>0<span class="font1"><span class="font1">〉</span></span></td>
<td class="td2">=</td>
<td class="td2">{0},</td>
</tr>
<tr>
<td class="td2"><span class="font1"><span class="font1">〈</span></span>1<span class="font1"><span class="font1">〉</span></span></td>
<td class="td2">=</td>
<td class="td2">{0, 1, 2, 3, 4, 5},</td>
</tr>
<tr>
<td class="td2"><span class="font1"><span class="font1">〈</span></span>2<span class="font1"><span class="font1">〉</span></span></td>
<td class="td2">=</td>
<td class="td2">{0, 2, 4}.</td>
</tr>
</table>
<p class="noindent">Similarly, in <img alt="art" src="images/Art_P1181.jpg"/>, we have</p>
<table class="table2b">
<tr>
<td class="td2"><span class="font1"><span class="font1">〈</span></span>1<span class="font1"><span class="font1">〉</span></span></td>
<td class="td2">=</td>
<td class="td2">{1},</td>
</tr>
<tr>
<td class="td2"><span class="font1"><span class="font1">〈</span></span>2<span class="font1"><span class="font1">〉</span></span></td>
<td class="td2">=</td>
<td class="td2">{1, 2, 4},</td>
</tr>
<tr>
<td class="td2"><span class="font1"><span class="font1">〈</span></span>3<span class="font1"><span class="font1">〉</span></span></td>
<td class="td2">=</td>
<td class="td2">{1, 2, 3, 4, 5, 6}.</td>
</tr>
</table>
<p class="space-break">The <span class="blue"><strong><em>order</em></strong></span> of <em>a</em> (in the group <em>S</em>), denoted ord(<em>a</em>), is defined as the smallest positive integer <em>t</em> such that <em>a</em><sup>(<em>t</em>)</sup> = <em>e</em>. (Recall that <em>e</em> ∈ <em>S</em> is the group identity.)</p>
<p class="theo"><strong><em>Theorem 31.17</em></strong></p>
<p class="noindent">For any finite group (<em>S</em>, ⊕) and any <em>a</em> ∈ <em>S</em>, the order of <em>a</em> is equal to the size of the subgroup it generates, or ord(<em>a</em>) = |<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>|.</p>
<p class="proof"><strong><em>Proof</em></strong>   Let <em>t</em> = ord(<em>a</em>). Since <em>a</em><sup>(<em>t</em>)</sup> = <em>e</em> and <em>a</em><sup>(<em>t</em>+<em>k</em>)</sup> = <em>a</em><sup>(<em>t</em>)</sup> ⊕ <em>a</em><sup>(<em>k</em>)</sup> = <em>a</em><sup>(<em>k</em>)</sup> for <em>k</em> ≥ 1, if <em>i</em> &gt; <em>t</em>, then <em>a</em><sup>(<em>i</em>)</sup> = <em>a</em><sup>(<em>j</em>)</sup> for some <em>j</em> &lt; <em>i</em>. Therefore, as we generate elements by <em>a</em>, we see no new elements after <em>a</em><sup>(<em>t</em>)</sup>. Thus, <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> = {<em>a</em><sup>(1)</sup>, <em>a</em><sup>(2)</sup>, …, <em>a</em><sup>(<em>t</em>)</sup>}, and so |<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>| ≤ <em>t</em>. To show that |<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>| ≥ <em>t</em>, we show that each element of the sequence <em>a</em><sup>(1)</sup>, <em>a</em><sup>(2)</sup>, …, <em>a</em><sup>(<em>t</em>)</sup> is distinct. Suppose for the purpose of contradiction that <em>a</em><sup>(<em>i</em>)</sup> = <em>a</em><sup>(<em>j</em>)</sup> for some <em>i</em> and <em>j</em> satisfying 1 ≤ <em>i</em> &lt; <em>j</em> ≤ <em>t</em>. Then, <em>a</em><sup>(<em>i</em>+<em>k</em>)</sup> = <em>a</em><sup>(<em>j</em>+<em>k</em>)</sup> for <a id="p923"/><em>k</em> ≥ 0. But this equation implies that <em>a</em><sup>(<em>i</em>+(<em>t</em>–<em>j</em>))</sup> = <em>a</em><sup>(<em>j</em>+(<em>t</em>–<em>j</em>))</sup> = <em>e</em>, a contradiction, since <em>i</em> + (<em>t</em> – <em>j</em>) &lt; <em>t</em> but <em>t</em> is the least positive value such that <em>a</em><sup>(<em>t</em>)</sup> = <em>e</em>. Therefore, each element of the sequence <em>a</em><sup>(1)</sup>, <em>a</em><sup>(2)</sup>, …, <em>a</em><sup>(<em>t</em>)</sup> is distinct, and |<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>| ≥ <em>t</em>. We conclude that ord(<em>a</em>) = |<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>|.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 31.18</em></strong></p>
<p class="noindent">The sequence <em>a</em><sup>(1)</sup>, <em>a</em><sup>(2)</sup>, … is periodic with period <em>t</em> = ord(<em>a</em>), that is, <em>a</em><sup>(<em>i</em>)</sup> = <em>a</em><sup>(<em>j</em>)</sup> if and only if <em>i</em> = <em>j</em> (mod <em>t</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Consistent with the above corollary, we define <em>a</em><sup>(0)</sup> as <em>e</em> and <em>a</em><sup>(<em>i</em>)</sup> as <em>a</em><sup>(<em>i</em> mod <em>t</em>)</sup>, where <em>t</em> = ord(<em>a</em>), for all integers <em>i</em>.</p>
<p class="cor"><strong><em>Corollary 31.19</em></strong></p>
<p class="noindent">If (<em>S</em>, ⊕) is a finite group with identity <em>e</em>, then for all <em>a</em> ∈ <em>S</em>,</p>
<p class="eql"><em>a</em><sup>(|<em>S</em>|)</sup> = <em>e</em>.</p>
<p class="proof"><strong><em>Proof</em></strong>   Lagrange’s theorem (Theorem 31.15) implies that ord(<em>a</em>) | |<em>S</em>|, and so |<em>S</em>| = 0 (mod <em>t</em>), where <em>t</em> = ord(<em>a</em>). Therefore, <em>a</em><sup>(|<em>S</em>|)</sup> = <em>a</em><sup>(0)</sup> = <em>e</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>31.3-1</em></strong></p>
<p class="noindent">Draw the group operation tables for the groups (<span class="font1">ℤ</span><sub>4</sub>, +<sub>4</sub>) and <img alt="art" src="images/Art_P1182.jpg"/>. Show that these groups are isomorphic by exhibiting a one-to-one correspondence <em>f</em> between <span class="font1">ℤ</span><sub>4</sub> and <img alt="art" src="images/Art_P1183.jpg"/> such that <em>a</em>+<em>b</em> = <em>c</em> (mod 4) if and only if <em>f</em>(<em>a</em>)·<em>f</em>(<em>b</em>) = <em>f</em>(<em>c</em>) (mod 5).</p>
<p class="level3"><strong><em>31.3-2</em></strong></p>
<p class="noindent">List all subgroups of <span class="font1">ℤ</span><sub>9</sub> and of <img alt="art" src="images/Art_P1184.jpg"/>.</p>
<p class="level3"><strong><em>31.3-3</em></strong></p>
<p class="noindent">Prove Theorem 31.14.</p>
<p class="level3"><strong><em>31.3-4</em></strong></p>
<p class="noindent">Show that if <em>p</em> is prime and <em>e</em> is a positive integer, then</p>
<p class="eql"><em><span class="symbolfont">ϕ</span></em>(<em>p</em><sup><em>e</em></sup>) = <em>p</em><sup><em>e</em>–1</sup>(<em>p</em> – 1).</p>
<p class="level3"><strong><em>31.3-5</em></strong></p>
<p class="noindent">Show that for any integer <em>n</em> &gt; 1 and for any <img alt="art" src="images/Art_P1185.jpg"/>, the function <img alt="art" src="images/Art_P1186.jpg"/> defined by <em>f</em><sub><em>a</em></sub>(<em>x</em>) = <em>ax</em> mod <em>n</em> is a permutation of <img alt="art" src="images/Art_P1153.jpg"/>.</p>
<a id="p924"/>
</section>
<p class="line1"/>
<section title="31.4 Solving modular linear equations">
<a id="Sec_31.4"/>
<p class="level1" id="h1-180"><a href="toc.xhtml#Rh1-180"><strong>31.4    Solving modular linear equations</strong></a></p>
<p class="noindent">We now consider the problem of finding solutions to the equation</p>
<p class="eqr"><img alt="art" src="images/Art_P1188.jpg"/></p>
<p class="noindent">where <em>a</em> &gt; 0 and <em>n</em> &gt; 0. This problem has several applications. For example, we’ll use it in <a href="chapter031.xhtml#Sec_31.7">Section 31.7</a> as part of the procedure to find keys in the RSA public-key cryptosystem. We assume that <em>a</em>, <em>b</em>, and <em>n</em> are given, and we wish to find all values of <em>x</em>, modulo <em>n</em>, that satisfy equation (31.26). The equation may have zero, one, or more than one such solution.</p>
<p>Let <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> denote the subgroup of <span class="font1">ℤ</span><sub><em>n</em></sub> generated by <em>a</em>. Since <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> = {<em>a</em><sup>(<em>x</em>)</sup> : <em>x</em> &gt; 0} = {<em>ax</em> mod <em>n</em> : <em>x</em> &gt; 0}, equation (31.26) has a solution if and only if [<em>b</em>] ∈ <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>. Lagrange’s theorem (Theorem 31.15) tells us that |<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>| must be a divisor of <em>n</em>. The following theorem gives us a precise characterization of <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>.</p>
<p class="theo"><strong><em>Theorem 31.20</em></strong></p>
<p class="noindent">For any positive integers <em>a</em> and <em>n</em>, if <em>d</em> = gcd(<em>a</em>, <em>n</em>), then we have</p>
<table class="table2b">
<tr>
<td class="td2"><span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span></td>
<td class="td2">=</td>
<td class="td2"><span class="font1"><span class="font1">〈</span></span><em>d</em><span class="font1"><span class="font1">〉</span></span></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">{0, <em>d</em>, 2<em>d</em>, …, ((<em>n</em>/<em>d</em>) – 1)<em>d</em>}</td>
</tr>
</table>
<p class="noindent">in <span class="font1">ℤ</span><sub><em>n</em></sub>, and thus</p>
<p class="eql">|<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>| = <em>n</em>/<em>d</em>.</p>
<p class="proof"><strong><em>Proof</em></strong>   We begin by showing that <em>d</em> ∈ <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>. Recall that E<small>XTENDED</small>-E<small>UCLID</small>(<em>a</em>, <em>n</em>) returns a triple (<em>d</em>, <em>x</em>, <em>y</em>) such that <em>ax</em> + <em>ny</em> = <em>d</em>. Thus, <em>ax</em> = <em>d</em> (mod <em>n</em>), so that <em>d</em> ∈ <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>. In other words, <em>d</em> is a multiple of <em>a</em> in <span class="font1">ℤ</span><sub><em>n</em></sub>.</p>
<p>Since <em>d</em> ∈ <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>, it follows that every multiple of <em>d</em> belongs to <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>, because any multiple of a multiple of <em>a</em> is itself a multiple of <em>a</em>. Thus, <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> contains every element in {0, <em>d</em>, 2<em>d</em>, …, ((<em>n</em>/<em>d</em>) – 1)<em>d</em>}. That is, <span class="font1"><span class="font1">〈</span></span><em>d</em><span class="font1"><span class="font1">〉</span></span> ⊆ <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>.</p>
<p>We now show that <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> ⊆ <span class="font1"><span class="font1">〈</span></span><em>d</em><span class="font1"><span class="font1">〉</span></span>. If <em>m</em> ∈ <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>, then <em>m</em> = <em>ax</em> mod <em>n</em> for some integer <em>x</em>, and so <em>m</em> = <em>ax</em> + <em>ny</em> for some integer <em>y</em>. Because <em>d</em> = gcd(<em>a</em>, <em>n</em>), we know that <em>d</em> | <em>a</em> and <em>d</em> | <em>n</em>, and so <em>d</em> | <em>m</em> by equation (31.4). Therefore, <em>m</em> ∈ <span class="font1"><span class="font1">〈</span></span><em>d</em><span class="font1"><span class="font1">〉</span></span>.</p>
<p>Combining these results, we have that <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> = <span class="font1"><span class="font1">〈</span></span><em>d</em><span class="font1"><span class="font1">〉</span></span>. To see that |<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>| = <em>n</em>/<em>d</em>, observe that there are exactly <em>n</em>/<em>d</em> multiples of <em>d</em> between 0 and <em>n</em> – 1, inclusive.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 31.21</em></strong></p>
<p class="noindent">The equation <em>ax</em> = <em>b</em> (mod <em>n</em>) is solvable for the unknown <em>x</em> if and only if <em>d</em> | <em>b</em>, where <em>d</em> = gcd(<em>a</em>, <em>n</em>).</p>
<a id="p925"/>
<p class="proof"><strong><em>Proof</em></strong>   The equation <em>ax</em> = <em>b</em> (mod <em>n</em>) is solvable if and only if [<em>b</em>] ∈ <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>, which is the same as saying</p>
<p class="eql">(<em>b</em> mod <em>n</em>) ∈ {0, <em>d</em>, 2<em>d</em>, …, ((<em>n</em>/<em>d</em>) – 1)<em>d</em>},</p>
<p class="noindent">by Theorem 31.20. If 0 ≤ <em>b</em> &lt; <em>n</em>, then <em>b</em> ∈ <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> if and only if <em>d</em> | <em>b</em>, since the members of <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> are precisely the multiples of <em>d</em>. If <em>b</em> &lt; 0 or <em>b</em> ≥ <em>n</em>, the corollary then follows from the observation that <em>d</em> | <em>b</em> if and only if <em>d</em> | (<em>b</em> mod <em>n</em>), since <em>b</em> and <em>b</em> mod <em>n</em> differ by a multiple of <em>n</em>, which is itself a multiple of <em>d</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 31.22</em></strong></p>
<p class="noindent">The equation <em>ax</em> = <em>b</em> (mod <em>n</em>) either has <em>d</em> distinct solutions modulo <em>n</em>, where <em>d</em> = gcd(<em>a</em>, <em>n</em>), or it has no solutions.</p>
<p class="proof"><strong><em>Proof</em></strong>   If <em>ax</em> = <em>b</em> (mod <em>n</em>) has a solution, then <em>b</em> ∈ <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>. By Theorem 31.17, ord(<em>a</em>) = |<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>|, and so Corollary 31.18 and Theorem 31.20 imply that the sequence <em>ai</em> mod <em>n</em>, for <em>i</em> = 0, 1, …, is periodic with period |<span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>| = <em>n</em>/<em>d</em>. If <em>b</em> ∈ <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span>, then <em>b</em> appears exactly <em>d</em> times in the sequence <em>ai</em> mod <em>n</em>, for <em>i</em> = 0, 1, …, <em>n</em> – 1, since the length-(<em>n</em>/<em>d</em>) block of values <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> repeats exactly <em>d</em> times as <em>i</em> increases from 0 to <em>n</em>–1. The indices <em>x</em> of the <em>d</em> positions for which <em>ax</em> mod <em>n</em> = <em>b</em> are the solutions of the equation <em>ax</em> = <em>b</em> (mod <em>n</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="theo"><strong><em>Theorem 31.23</em></strong></p>
<p class="noindent">Let <em>d</em> = gcd(<em>a</em>, <em>n</em>), and suppose that <em>d</em> = <em>ax</em>′ + <em>ny</em>′ for some integers <em>x</em>′ and <em>y</em>′ (for example, as computed by E<small>XTENDED</small>-E<small>UCLID</small>). If <em>d</em> | <em>b</em>, then the equation <em>ax</em> = <em>b</em> (mod <em>n</em>) has as one of its solutions the value <em>x</em><sub>0</sub>, where</p>
<p class="eql"><em>x</em><sub>0</sub> = <em>x</em>′(<em>b</em>/<em>d</em>) mod <em>n</em>.</p>
<p class="proof"><strong><em>Proof</em></strong>   We have</p>
<table class="table2b">
<tr>
<td class="td2"><em>ax</em><sub>0</sub></td>
<td class="td2">= <em>ax</em>′(<em>b</em>/<em>d</em>)</td>
<td class="td2">(mod <em>n</em>)</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">= <em>d</em>(<em>b</em>/<em>d</em>)</td>
<td class="td2">(mod <em>n</em>)</td>
<td class="td2">(because <em>ax</em>′ = <em>d</em> (mod <em>n</em>))</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">= <em>b</em></td>
<td class="td2">(mod <em>n</em>),</td>
<td class="td2"/>
</tr>
</table>
<p class="noindent">and thus <em>x</em><sub>0</sub> is a solution to <em>ax</em> = <em>b</em> (mod <em>n</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="theo"><strong><em>Theorem 31.24</em></strong></p>
<p class="noindent">Suppose that the equation <em>ax</em> = <em>b</em> (mod <em>n</em>) is solvable (that is, <em>d</em> | <em>b</em>, where <em>d</em> = gcd(<em>a</em>, <em>n</em>)) and that <em>x</em><sub>0</sub> is any solution to this equation. Then, this equation has exactly <em>d</em> distinct solutions, modulo <em>n</em>, given by <em>x</em><sub><em>i</em></sub> = <em>x</em><sub>0</sub> + <em>i</em>(<em>n</em>/<em>d</em>) for <em>i</em> = 0, 1, …, <em>d</em> – 1.</p>
<a id="p926"/>
<p class="proof"><strong><em>Proof</em></strong>   Because <em>n</em>/<em>d</em> &gt; 0 and 0 ≤ <em>i</em>(<em>n</em>/<em>d</em>) &lt; <em>n</em> for <em>i</em> = 0, 1, …, <em>d</em> – 1, the values <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, …, <em>x</em><sub><em>d</em>–1</sub> are all distinct, modulo <em>n</em>. Since <em>x</em><sub>0</sub> is a solution of <em>ax</em> = <em>b</em> (mod <em>n</em>), we have <em>ax</em><sub>0</sub> mod <em>n</em> = <em>b</em> (mod <em>n</em>). Thus, for <em>i</em> = 0, 1, …, <em>d</em> – 1, we have</p>
<table class="table2b">
<tr>
<td class="td2"><em>ax</em><sub><em>i</em></sub> mod <em>n</em></td>
<td class="td2">=</td>
<td class="td2"><em>a</em>(<em>x</em><sub>0</sub> + <em>in</em>/<em>d</em>) mod <em>n</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">(<em>ax</em><sub>0</sub> + <em>ain</em>/<em>d</em>) mod <em>n</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>ax</em><sub>0</sub> mod <em>n</em> (because <em>d</em> | <em>a</em> implies that <em>ain</em>/<em>d</em> is a multiple of <em>n</em>)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2"><em>b</em> (mod <em>n</em>),</td>
</tr>
</table>
<p class="noindent">and hence <em>ax</em><sub><em>i</em></sub> = <em>b</em> (mod <em>n</em>), making <em>x</em><sub><em>i</em></sub> a solution, too. By Corollary 31.22, the equation <em>ax</em> = <em>b</em> (mod <em>n</em>) has exactly <em>d</em> solutions, so that <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, …, <em>x</em><sub><em>d</em>–1</sub> must be all of them.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">We have now developed the mathematics needed to solve the equation <em>ax</em> = <em>b</em> (mod <em>n</em>). The procedure M<small>ODULAR</small>-L<small>INEAR</small>-E<small>QUATION</small>-S<small>OLVER</small> prints all solutions to this equation. The inputs <em>a</em> and <em>n</em> are arbitrary positive integers, and <em>b</em> is an arbitrary integer.</p>
<div class="pull-quote1">
<p class="box-heading">M<small>ODULAR</small>-L<small>INEAR</small>-E<small>QUATION</small>-S<small>OLVER</small>(<em>a</em>, <em>b</em>, <em>n</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1">(<em>d</em>, <em>x</em>′, <em>y</em>′) = E<small>XTENDED</small>-E<small>UCLID</small>(<em>a</em>, <em>n</em>)</td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><strong>if</strong> <em>d</em> | <em>b</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><p class="p2"><em>x</em><sub>0</sub> = <em>x</em>′(<em>b</em>/<em>d</em>) mod <em>n</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><strong>for</strong> <em>i</em> = 0 <strong>to</strong> <em>d</em> – 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p3">print (<em>x</em><sub>0</sub> + <em>i</em>(<em>n</em>/<em>d</em>)) mod <em>n</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><strong>else</strong> print “no solutions”</td>
</tr>
</table>
</div>
<p>As an example of the operation of M<small>ODULAR</small>-L<small>INEAR</small>-E<small>QUATION</small>-S<small>OLVER</small>, consider the equation 14<em>x</em> = 30 (mod 100) (and thus <em>a</em> = 14, <em>b</em> = 30, and <em>n</em> = 100). Calling E<small>XTENDED</small>-E<small>UCLID</small> in line 1 gives (<em>d</em>, <em>x</em>′, <em>y</em>′) = (2, –7, 1). Since 2 | 30, lines 3–5 execute. Line 3 computes <em>x</em><sub>0</sub> = (–7)(15) mod 100 = 95. The <strong>for</strong> loop of lines 4–5 prints the two solutions, 95 and 45.</p>
<p>The procedure M<small>ODULAR</small>-L<small>INEAR</small>-E<small>QUATION</small>-S<small>OLVER</small> works as follows. The call to E<small>XTENDED</small>-E<small>UCLID</small> in line 1 returns a triple (<em>d</em>, <em>x</em>′, <em>y</em>′) such that <em>d</em> = gcd(<em>a</em>, <em>n</em>) and <em>d</em> = <em>ax</em>′ + <em>ny</em>′. Therefore, <em>x</em>′ is a solution to the equation <em>ax</em>′ = <em>d</em> (mod <em>n</em>). If <em>d</em> does not divide <em>b</em>, then the equation <em>ax</em> = <em>b</em> (mod <em>n</em>) has no solution, by Corollary 31.21. Line 2 checks to see whether <em>d</em> | <em>b</em>, and if not, line 6 reports that there are no solutions. Otherwise, line 3 computes a solution <em>x</em><sub>0</sub> to <em>ax</em> = <em>b</em> (mod <em>n</em>), as Theorem 31.23 suggests. Given one solution, Theorem 31.24 states that adding multiples of (<em>n</em>/<em>d</em>), modulo <em>n</em>, yields the other <a id="p927"/><em>d</em> – 1 solutions. The <strong>for</strong> loop of lines 4–5 prints out all <em>d</em> solutions, beginning with <em>x</em><sub>0</sub> and spaced <em>n</em>/<em>d</em> apart, modulo <em>n</em>.</p>
<p>M<small>ODULAR</small>-L<small>INEAR</small>-E<small>QUATION</small>-S<small>OLVER</small> performs <em>O</em>(1g <em>n</em> + gcd(<em>a</em>, <em>n</em>)) arithmetic operations, since E<small>XTENDED</small>-E<small>UCLID</small> performs <em>O</em>(1g <em>n</em>) arithmetic operations, and each iteration of the <strong>for</strong> loop of lines 4–5 performs a constant number of arithmetic operations.</p>
<p>The following corollaries of Theorem 31.24 give specializations of particular interest.</p>
<p class="cor"><strong><em>Corollary 31.25</em></strong></p>
<p class="noindent">For any <em>n</em> &gt; 1, if gcd(<em>a</em>, <em>n</em>) = 1, then the equation <em>ax</em> = <em>b</em> (mod <em>n</em>) has a unique solution, modulo <em>n</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">If <em>b</em> = 1, a common case of considerable interest, the <em>x</em> that solves the equation is a <span class="blue"><strong><em>multiplicative inverse</em></strong></span> of <em>a</em>, modulo <em>n</em>.</p>
<p class="cor"><strong><em>Corollary 31.26</em></strong></p>
<p class="noindent">For any <em>n</em> &gt; 1, if gcd(<em>a</em>, <em>n</em>) = 1, then the equation <em>ax</em> = 1 (mod <em>n</em>) has a unique solution, modulo <em>n</em>. Otherwise, it has no solution.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Thanks to Corollary 31.26, the notation <em>a</em><sup>−1</sup> mod <em>n</em> refers to <em>the</em> multiplicative inverse of <em>a</em>, modulo <em>n</em>, when <em>a</em> and <em>n</em> are relatively prime. If gcd(<em>a</em>, <em>n</em>) = 1, then the unique solution to the equation <em>ax</em> = 1 (mod <em>n</em>) is the integer <em>x</em> returned by E<small>XTENDED</small>-E<small>UCLID</small>, since the equation</p>
<p class="eql">gcd(<em>a</em>, <em>n</em>) = 1 = <em>ax</em> + <em>ny</em></p>
<p class="noindent">implies <em>ax</em> = 1 (mod <em>n</em>). Thus, E<small>XTENDED</small>-E<small>UCLID</small> can compute <em>a</em><sup>−1</sup> mod <em>n</em> efficiently.</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>31.4-1</em></strong></p>
<p class="noindent">Find all solutions to the equation 35<em>x</em> = 10 (mod 50).</p>
<p class="level3"><strong><em>31.4-2</em></strong></p>
<p class="noindent">Prove that the equation <em>ax</em> = <em>ay</em> (mod <em>n</em>) implies <em>x</em> = <em>y</em> (mod <em>n</em>) whenever gcd(<em>a</em>, <em>n</em>) = 1. Show that the condition gcd(<em>a</em>, <em>n</em>) = 1 is necessary by supplying a counterexample with gcd(<em>a</em>, <em>n</em>) &gt; 1.</p>
<a id="p928"/>
<p class="level3"><strong><em>31.4-3</em></strong></p>
<p class="noindent">Consider the following change to line 3 of the procedure M<small>ODULAR</small>-L<small>INEAR</small>-E<small>QUATION</small>-S<small>OLVER</small>:</p>
<p> </p>
<table class="table1">
<tr>
<td class="td1w">3</td>
<td class="td1"><em>x</em><sub>0</sub> = <em>x</em>′(<em>b</em>/<em>d</em>) mod (<em>n</em>/<em>d</em>)</td>
</tr>
</table>
<p class="noindent1-top">With this change, will the procedure still work? Explain why or why not.</p>
<p class="level3"><span class="font1">★</span> <strong><em>31.4-4</em></strong></p>
<p class="noindent">Let <em>p</em> be prime and <em>f</em>(<em>x</em>) = (<em>f</em><sub>0</sub> + <em>f</em><sub>1</sub><em>x</em> + <span class="font1">⋯</span> + <em>f</em><sub><em>t</em></sub><em>x</em><sup><em>t</em></sup>) (mod <em>p</em>) be a polynomial of degree <em>t</em>, with coefficients <em>f</em><sub><em>i</em></sub> drawn from <span class="font1">ℤ</span><sub><em>p</em></sub>. We say that <em>a</em> ∈ <span class="font1">ℤ</span><sub><em>p</em></sub> is a <span class="blue"><strong><em>zero</em></strong></span> of <em>f</em> if <em>f</em>(<em>a</em>) = 0 (mod <em>p</em>). Prove that if <em>a</em> is a zero of <em>f</em>, then <em>f</em>(<em>x</em>) = (<em>x</em> – <em>a</em>)<em>g</em>(<em>x</em>) (mod <em>p</em>) for some polynomial <em>g</em>(<em>x</em>) of degree <em>t</em> – 1. Prove by induction on <em>t</em> that if <em>p</em> is prime, then a polynomial <em>f</em>(<em>x</em>) of degree <em>t</em> can have at most <em>t</em> distinct zeros modulo <em>p</em>.</p>
</section>
<p class="line1"/>
<section title="31.5 The Chinese remainder theorem">
<a id="Sec_31.5"/>
<p class="level1" id="h1-181"><a href="toc.xhtml#Rh1-181"><strong>31.5    The Chinese remainder theorem</strong></a></p>
<p class="noindent">Around 100 <small>C</small>.<small>E</small>., the Chinese mathematician Sun-Ts<span class="font1">ŭ</span> solved the problem of finding those integers <em>x</em> that leave remainders 2, 3, and 2 when divided by 3, 5, and 7 respectively. One such solution is <em>x</em> = 23, and all solutions are of the form 23+105<em>k</em> for arbitrary integers <em>k</em>. The “Chinese remainder theorem” provides a correspondence between a system of equations modulo a set of pairwise relatively prime moduli (for example, 3, 5, and 7) and an equation modulo their product (for example, 105).</p>
<p>The Chinese remainder theorem has two major applications. Let the integer <em>n</em> be factored as <em>n</em> = <em>n</em><sub>1</sub><em>n</em><sub>2</sub> <span class="font1">⋯</span> <em>n</em><sub><em>k</em></sub>, where the factors <em>n</em><sub><em>i</em></sub> are pairwise relatively prime. First, the Chinese remainder theorem is a descriptive “structure theorem” that describes the structure of <span class="font1">ℤ</span><sub><em>n</em></sub> as identical to that of the Cartesian product <img alt="art" src="images/Art_P1189.jpg"/> with componentwise addition and multiplication modulo <em>n</em><sub><em>i</em></sub> in the <em>i</em>th component. Second, this description helps in designing efficient algorithms, since working in each of the systems <img alt="art" src="images/Art_P1190.jpg"/> can be more efficient (in terms of bit operations) than working modulo <em>n</em>.</p>
<p class="theo"><strong><em>Theorem 31.27 (Chinese remainder theorem)</em></strong></p>
<p class="noindent">Let <em>n</em> = <em>n</em><sub>1</sub><em>n</em><sub>2</sub> <span class="font1">⋯</span> <em>n</em><sub><em>k</em></sub>, where the <em>n</em><sub><em>i</em></sub> are pairwise relatively prime. Consider the correspondence</p>
<p class="eqr"><img alt="art" src="images/Art_P1191.jpg"/></p>
<p class="noindent">where <img alt="art" src="images/Art_P1192.jpg"/>, and</p>
<a id="p929"/>
<p class="eql"><em>a</em><sub><em>i</em></sub> = <em>a</em> mod <em>n</em><sub><em>i</em></sub></p>
<p class="noindent">for <em>i</em> = 1, 2, …, <em>k</em>. Then, mapping (31.27) is a one-to-one mapping (bijection) between <span class="font1">ℤ</span><sub><em>n</em></sub> and the Cartesian product <img alt="art" src="images/Art_P1193.jpg"/>. Operations performed on the elements of <span class="font1">ℤ</span><sub><em>n</em></sub> can be equivalently performed on the corresponding <em>k</em>-tuples by performing the operations independently in each coordinate position in the appropriate system. That is, if</p>
<table class="table2b">
<tr>
<td class="td2"><em>a</em></td>
<td class="td2">↔</td>
<td class="td2">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>k</em></sub>),</td>
</tr>
<tr>
<td class="td2"><em>b</em></td>
<td class="td2">↔</td>
<td class="td2">(<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, …, <em>b</em><sub><em>k</em></sub>),</td>
</tr>
</table>
<p class="noindent">then</p>
<p class="eqr"><img alt="art" src="images/Art_P1194.jpg"/></p>
<p class="proof"><strong><em>Proof</em></strong>   Let’s see how to translate between the two representations. Going from <em>a</em> to (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>k</em></sub>) requires only <em>k</em> “mod” operations. The reverse—computing <em>a</em> from inputs (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>k</em></sub>)—is only slightly more complicated.</p>
<p>We begin by defining <em>m</em><sub><em>i</em></sub> = <em>n</em>/<em>n</em><sub><em>i</em></sub> for <em>i</em> = 1, 2, …, <em>k</em>. Thus, <em>m</em><sub><em>i</em></sub> is the product of all of the <em>n</em><sub><em>j</em></sub>’s other than <em>n</em><sub><em>i</em></sub>: <em>m</em><sub><em>i</em></sub> = <em>n</em><sub>1</sub><em>n</em><sub>2</sub> <span class="font1">⋯</span> <em>n</em><sub><em>i</em>−1</sub><em>n</em><sub><em>i</em>+1</sub> <span class="font1">⋯</span> <em>n</em><sub><em>k</em></sub>. We next define</p>
<p class="eqr"><img alt="art" src="images/Art_P1195.jpg"/></p>
<p class="noindent">for <em>i</em> = 1, 2, …, <em>k</em>. Equation (31.31) is well defined: since <em>m</em><sub><em>i</em></sub> and <em>n</em><sub><em>i</em></sub> are relatively prime (by Theorem 31.6), Corollary 31.26 guarantees that <img alt="art" src="images/Art_P1196.jpg"/> mod <em>n</em><sub><em>i</em></sub> exists. Here is how to compute <em>a</em> as a function of the <em>a</em><sub><em>i</em></sub> and <em>c</em><sub><em>i</em></sub>:</p>
<p class="eqr"><img alt="art" src="images/Art_P1197.jpg"/></p>
<p>We now show that equation (31.32) ensures that <em>a</em> = <em>a</em><sub><em>i</em></sub> (mod <em>n</em><sub><em>i</em></sub>) for <em>i</em> = 1, 2, …, <em>k</em>. If <em>j</em> ≠ <em>i</em>, then <em>m</em><sub><em>j</em></sub> = 0 (mod <em>n</em><sub><em>i</em></sub>), which implies that <em>c</em><sub><em>j</em></sub> = <em>m</em><sub><em>j</em></sub> = 0 (mod <em>n</em><sub><em>i</em></sub>). Note also that <em>c</em><sub><em>i</em></sub> = 1 (mod <em>n</em><sub><em>i</em></sub>), from equation (31.31). We thus have the appealing and useful correspondence</p>
<p class="eql"><em>c</em><sub><em>i</em></sub> ↔ (0, 0, …, 0, 1, 0, …, 0),</p>
<p class="noindent">a vector that has 0s everywhere except in the <em>i</em>th coordinate, where it has a 1. The <em>c</em><sub><em>i</em></sub> thus form a “basis” for the representation, in a certain sense. For each <em>i</em>, therefore, we have</p>
<p class="eql"><img alt="art" src="images/Art_P1198.jpg"/></p>
<a id="p930"/>
<p class="noindent">which is what we wished to show: our method of computing <em>a</em> from the <em>a</em><sub><em>i</em></sub>’s produces a result <em>a</em> that satisfies the constraints <em>a</em> = <em>a</em><sub><em>i</em></sub> (mod <em>n</em><sub><em>i</em></sub>) for <em>i</em> = 1, 2, …, <em>k</em>. The correspondence is one-to-one, since we can transform in both directions. Finally, equations (31.28)–(31.30) follow directly from Exercise 31.1-7, since <em>x</em> mod <em>n</em><sub><em>i</em></sub> = (<em>x</em> mod <em>n</em>) mod <em>n</em><sub><em>i</em></sub> for any <em>x</em> and <em>i</em> = 1, 2, …, <em>k</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">We’ll use the following corollaries later in this chapter.</p>
<p class="cor"><strong><em>Corollary 31.28</em></strong></p>
<p class="noindent">If <em>n</em><sub>1</sub>, <em>n</em><sub>2</sub>, …, <em>n</em><sub><em>k</em></sub> are pairwise relatively prime and <em>n</em> = <em>n</em><sub>1</sub><em>n</em><sub>2</sub> <span class="font1">⋯</span> <em>n</em><sub><em>k</em></sub>, then for any integers <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>k</em></sub>, the set of simultaneous equations</p>
<table class="table2b">
<tr>
<td class="td2"><em>x</em> = <em>a</em><sub><em>i</em></sub></td>
<td class="td2">(mod <em>n</em><sub><em>i</em></sub>),</td>
</tr>
</table>
<p class="noindent">for <em>i</em> = 1, 2, …, <em>k</em>, has a unique solution modulo <em>n</em> for the unknown <em>x</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="cor"><strong><em>Corollary 31.29</em></strong></p>
<p class="noindent">If <em>n</em><sub>1</sub>, <em>n</em><sub>2</sub>, …, <em>n</em><sub><em>k</em></sub> are pairwise relatively prime and <em>n</em> = <em>n</em><sub>1</sub><em>n</em><sub>2</sub> <span class="font1">⋯</span> <em>n</em><sub><em>k</em></sub>, then for all integers <em>x</em> and <em>a</em>,</p>
<p class="eql"><em>x</em> = <em>a</em> (mod <em>n</em><sub><em>i</em></sub>)</p>
<p class="noindent">for <em>i</em> = 1, 2, …, <em>k</em> if and only if</p>
<p class="eql"><em>x</em> = <em>a</em> (mod <em>n</em>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">As an example of the application of the Chinese remainder theorem, suppose that you are given the two equations</p>
<table class="table2b">
<tr>
<td class="td2"><em>a</em> = 2</td>
<td class="td2">(mod 5),</td>
</tr>
<tr>
<td class="td2"><em>a</em> = 3</td>
<td class="td2">(mod 13),</td>
</tr>
</table>
<p class="noindent">so that <em>a</em><sub>1</sub> = 2, <em>n</em><sub>1</sub> = <em>m</em><sub>2</sub> = 5, <em>a</em><sub>2</sub> = 3, and <em>n</em><sub>2</sub> = <em>m</em><sub>1</sub> = 13, and you wish to compute <em>a</em> mod 65, since <em>n</em> = <em>n</em><sub>1</sub><em>n</em><sub>2</sub> = 65. Because 13<sup>−1</sup> = 2 (mod 5) and 5<sup>−1</sup> = 8 (mod 13), you compute</p>
<table class="table2b">
<tr>
<td class="td2"><em>c</em><sub>1</sub></td>
<td class="td2">= 13 · (2 mod 5) = 26,</td>
</tr>
<tr>
<td class="td2"><em>c</em><sub>2</sub></td>
<td class="td2">= 5 · (8 mod 13) = 40,</td>
</tr>
</table>
<p class="noindent">and</p>
<table class="table2b">
<tr>
<td class="td2"><em>a</em></td>
<td class="td2">=</td>
<td class="td2">2 · 26 + 3 · 40</td>
<td class="td2">(mod 65)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">52 + 120</td>
<td class="td2">(mod 65)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">=</td>
<td class="td2">42</td>
<td class="td2">(mod 65).</td>
</tr>
</table>
<a id="p931"/>
<div class="divimage">
<p class="fig-img1" id="Fig_31-3"><img alt="art" src="images/Art_P1199.jpg"/></p>
<p class="caption"><strong>Figure 31.3</strong> An illustration of the Chinese remainder theorem for <em>n</em><sub>1</sub> = 5 and <em>n</em><sub>2</sub> = 13. For this example, <em>c</em><sub>1</sub> = 26 and <em>c</em><sub>2</sub> = 40. In row <em>i</em>, column <em>j</em> is shown the value of <em>a</em>, modulo 65, such that <em>a</em> mod 5 = <em>i</em> and <em>a</em> mod 13 = <em>j</em>. Note that row 0, column 0 contains a 0. Similarly, row 4, column 12 contains a 64 (equivalent to −1). Since <em>c</em><sub>1</sub> = 26, moving down a row increases <em>a</em> by 26. Similarly, <em>c</em><sub>2</sub> = 40 means that moving right by a column increases <em>a</em> by 40. Increasing <em>a</em> by 1 corresponds to moving diagonally downward and to the right, wrapping around from the bottom to the top and from the right to the left.</p>
</div>
<p class="noindent">See <a href="chapter031.xhtml#Fig_31-3">Figure 31.3</a> for an illustration of the Chinese remainder theorem, modulo 65.</p>
<p>Thus, you can work modulo <em>n</em> by working modulo <em>n</em> directly or by working in the transformed representation using separate modulo <em>n</em><sub><em>i</em></sub> computations, as convenient. The computations are entirely equivalent.</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>31.5-1</em></strong></p>
<p class="noindent">Find all solutions to the equations <em>x</em> = 4 (mod 5) and <em>x</em> = 5 (mod 11).</p>
<p class="level3"><strong><em>31.5-2</em></strong></p>
<p class="noindent">Find all integers <em>x</em> that leave remainders 1, 2, and 3 when divided by 9, 8, and 7, respectively.</p>
<p class="level3"><strong><em>31.5-3</em></strong></p>
<p class="noindent">Argue that, under the definitions of Theorem 31.27, if gcd(<em>a</em>, <em>n</em>) = 1, then</p>
<p class="eql"><img alt="art" src="images/Art_P1200.jpg"/></p>
<p class="level3"><strong><em>31.5-4</em></strong></p>
<p class="noindent">Under the definitions of Theorem 31.27, prove that for any polynomial <em>f</em>, the number of roots of the equation <em>f</em>(<em>x</em>) = 0 (mod <em>n</em>) equals the product of the number of roots of each of the equations <em>f</em>(<em>x</em>) = 0 (mod <em>n</em><sub>1</sub>), <em>f</em>(<em>x</em>) = 0 (mod <em>n</em><sub>2</sub>), …, <em>f</em>(<em>x</em>) = 0 (mod <em>n</em><sub><em>k</em></sub>).</p>
<a id="p932"/>
</section>
<p class="line1"/>
<section title="31.6 Powers of an element">
<a id="Sec_31.6"/>
<p class="level1" id="h1-182"><a href="toc.xhtml#Rh1-182"><strong>31.6    Powers of an element</strong></a></p>
<p class="noindent">Along with considering the multiples of a given element <em>a</em>, modulo <em>n</em>, we often consider the sequence of powers of <em>a</em>, modulo <em>n</em>, where <img alt="art" src="images/Art_P1201.jpg"/>:</p>
<p class="eql"><em>a</em><sup>0</sup>, <em>a</em><sup>1</sup>, <em>a</em><sup>2</sup>, <em>a</em><sup>3</sup>, …,</p>
<p class="noindent">modulo <em>n</em>. Indexing from 0, the 0th value in this sequence is <em>a</em><sup>0</sup> mod <em>n</em> = 1, and the <em>i</em>th value is <em>a</em><sup><em>i</em></sup> mod <em>n</em>. For example, the powers of 3 modulo 7 are</p>
<p class="eql"><img alt="art" src="images/Art_P1201a.jpg"/></p>
<p class="noindent">and the powers of 2 modulo 7 are</p>
<p class="eql"><img alt="art" src="images/Art_P1201b.jpg"/></p>
<p>In this section, let <span class="font1"><span class="font1">〈</span></span><em>a</em><span class="font1"><span class="font1">〉</span></span> denote the subgroup of <img alt="art" src="images/Art_Zastn.jpg"/> generated by <em>a</em> through repeated multiplication, and let ord<sub><em>n</em></sub>(<em>a</em>) (the “order of <em>a</em>, modulo <em>n</em>”) denote the order of <em>a</em> in <img alt="art" src="images/Art_Zastn.jpg"/>. For example, <span class="font1"><span class="font1">〈</span></span>2<span class="font1"><span class="font1">〉</span></span> = {1, 2, 4} in <img alt="art" src="images/Art_P1202.jpg"/>, and ord<sub>7</sub>(2) = 3. Using the definition of the Euler phi function <em><span class="symbolfont">ϕ</span></em>(<em>n</em>) as the size of <img alt="art" src="images/Art_Zastn.jpg"/> (see <a href="chapter031.xhtml#Sec_31.3">Section 31.3</a>), we now translate Corollary 31.19 into the notation of <img alt="art" src="images/Art_Zastn.jpg"/> to obtain Euler’s theorem and specialize it to <img alt="art" src="images/Art_Zastp.jpg"/>, where <em>p</em> is prime, to obtain Fermat’s theorem.</p>
<p class="theo"><strong><em>Theorem 31.30 (Euler’s theorem)</em></strong></p>
<p class="noindent">For any integer <em>n</em> &gt; 1,</p>
<p class="eql"><img alt="art" src="images/Art_P1203.jpg"/></p>
<p class="right"><span class="font1">▪</span></p>
<p class="theo"><strong><em>Theorem 31.31 (Fermat’s theorem)</em></strong></p>
<p class="noindent">If <em>p</em> is prime, then</p>
<p class="eql"><img alt="art" src="images/Art_P1204.jpg"/></p>
<p class="proof"><strong><em>Proof</em></strong>   By equation (31.22), <em><span class="symbolfont">ϕ</span></em>(<em>p</em>) = <em>p</em> – 1 if <em>p</em> is prime.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Fermat’s theorem applies to every element in <span class="font1">ℤ</span><sub><em>p</em></sub> except 0, since <img alt="art" src="images/Art_P1205.jpg"/>. For all <em>a</em> ∈ <span class="font1">ℤ</span><sub><em>p</em></sub>, however, we have <em>a</em><sup><em>p</em></sup> = <em>a</em> (mod <em>p</em>) if <em>p</em> is prime.</p>
<p>If <img alt="art" src="images/Art_P1206.jpg"/>, then every element in <img alt="art" src="images/Art_Zastn.jpg"/> is a power of <em>g</em>, modulo <em>n</em>, and <em>g</em> is a <span class="blue"><strong><em>primitive root</em></strong></span> or a <span class="blue"><strong><em>generator</em></strong></span> of <img alt="art" src="images/Art_Zastn.jpg"/>. For example, 3 is a primitive root, modulo 7, but 2 is not a primitive root, modulo 7. If <img alt="art" src="images/Art_Zastn.jpg"/> possesses a primitive root, the group <img alt="art" src="images/Art_Zastn.jpg"/> is <span class="blue"><strong><em>cyclic</em></strong></span>. We omit the proof of the following theorem, which is proven by Niven and Zuckerman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_345">345</a>].</p>
<a id="p933"/>
<p class="theo"><strong><em>Theorem 31.32</em></strong></p>
<p class="noindent">The values of <em>n</em> &gt; 1 for which <img alt="art" src="images/Art_Zastn.jpg"/> is cyclic are 2, 4, <em>p</em><sup><em>e</em></sup>, and 2<em>p</em><sup><em>e</em></sup>, for all primes <em>p</em> &gt; 2 and all positive integers <em>e</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">If <em>g</em> is a primitive root of <img alt="art" src="images/Art_Zastn.jpg"/> and <em>a</em> is any element of <img alt="art" src="images/Art_Zastn.jpg"/>, then there exists a <em>z</em> such that <em>g</em><sup><em>z</em></sup> = <em>a</em> (mod <em>n</em>). This <em>z</em> is a <span class="blue"><strong><em>discrete logarithm</em></strong></span> or an <span class="blue"><strong><em>index</em></strong></span> of <em>a</em>, modulo <em>n</em>, to the base <em>g</em>. We denote this value as ind<sub><em>n</em>,<em>g</em></sub>(<em>a</em>).</p>
<p class="theo"><strong><em>Theorem 31.33 (Discrete logarithm theorem)</em></strong></p>
<p class="noindent">If <em>g</em> is a primitive root of <img alt="art" src="images/Art_Zastn.jpg"/>, then the equation <em>g</em><sup><em>x</em></sup> = <em>g</em><sup><em>y</em></sup> (mod <em>n</em>) holds if and only if the equation <em>x</em> = <em>y</em> (mod <em><span class="symbolfont">ϕ</span></em>(<em>n</em>)) holds.</p>
<p class="proof"><strong><em>Proof</em></strong>   Suppose first that <em>x</em> = <em>y</em> (mod <em><span class="symbolfont">ϕ</span></em>(<em>n</em>)). Then, we have <em>x</em> = <em>y</em> + <em>k<span class="symbolfont">ϕ</span></em>(<em>n</em>) for some integer <em>k</em>, and thus</p>
<table class="table2b">
<tr>
<td class="td2"><em>g</em><sup><em>x</em></sup></td>
<td class="td2">= <em>g</em><sup><em>y</em>+<em>k<span class="symbolfont">ϕ</span></em>(<em>n</em>)</sup></td>
<td class="td2">(mod <em>n</em>)</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">= <em>g</em><sup><em>y</em></sup> · (<em>g</em><sup><em><span class="symbolfont">ϕ</span></em>(<em>n</em>)</sup>)<sup><em>k</em></sup></td>
<td class="td2">(mod <em>n</em>)</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">= <em>g</em><sup><em>y</em></sup> · 1<sup><em>k</em></sup></td>
<td class="td2">(mod <em>n</em>)</td>
<td class="td2">(by Euler’s theorem)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">= <em>g</em><sup><em>y</em></sup></td>
<td class="td2">(mod <em>n</em>).</td>
<td class="td2"/>
</tr>
</table>
<p class="noindent">Conversely, suppose that <em>g</em><sup><em>x</em></sup> = <em>g</em><sup><em>y</em></sup> (mod <em>n</em>). Because the sequence of powers of <em>g</em> generates every element of <span class="font1"><span class="font1">〈</span></span><em>g</em><span class="font1"><span class="font1">〉</span></span> and |<span class="font1"><span class="font1">〈</span></span><em>g</em><span class="font1"><span class="font1">〉</span></span>| = <em><span class="symbolfont">ϕ</span></em>(<em>n</em>), Corollary 31.18 implies that the sequence of powers of <em>g</em> is periodic with period <em><span class="symbolfont">ϕ</span></em>(<em>n</em>). Therefore, if <em>g</em><sup><em>x</em></sup> = <em>g</em><sup><em>y</em></sup> (mod <em>n</em>), we must have <em>x</em> = <em>y</em> (mod <em><span class="symbolfont">ϕ</span></em>(<em>n</em>)).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Let’s now turn our attention to the square roots of 1, modulo a prime power. The following properties will be useful to justify the primality-testing algorithm in <a href="chapter031.xhtml#Sec_31.8">Section 31.8</a>.</p>
<p class="theo"><strong><em>Theorem 31.34</em></strong></p>
<p class="noindent">If <em>p</em> is an odd prime and <em>e</em> ≥ 1, then the equation</p>
<p class="eqr"><img alt="art" src="images/Art_P1207.jpg"/></p>
<p class="noindent">has only two solutions, namely <em>x</em> = 1 and <em>x</em> = −1.</p>
<p class="proof"><strong><em>Proof</em></strong>   By Exercise 31.6-2, equation (31.33) is equivalent to</p>
<p class="eql"><em>p</em><sup><em>e</em></sup> | (<em>x</em> − 1)(<em>x</em> + 1).</p>
<p class="noindent">Since <em>p</em> &gt; 2, we can have <em>p</em> | (<em>x</em> − 1) or <em>p</em> | (<em>x</em> + 1), but not both. (Otherwise, by property (31.3), <em>p</em> would also divide their difference (<em>x</em> + 1) – (<em>x</em> − 1) = 2.) If <em>p</em> <span class="font1">∤</span> (<em>x</em> – 1), then gcd(<em>p</em><sup><em>e</em></sup>, <em>x</em> − 1) = 1, and by Corollary 31.5, we would have <em>p</em><sup><em>e</em></sup> | (<em>x</em> + 1). That is, <em>x</em> = −1 (mod <em>p</em><sup><em>e</em></sup>). Symmetrically, if <em>p</em> <span class="font1">∤</span> (<em>x</em> + 1), <a id="p934"/>then gcd(<em>p</em><sup><em>e</em></sup>, <em>x</em> + 1) = 1, and Corollary 31.5 implies that <em>p</em><sup><em>e</em></sup> | (<em>x</em> − 1), so that <em>x</em> = 1 (mod <em>p</em><sup><em>e</em></sup>). Therefore, either <em>x</em> = −1 (mod <em>p</em><sup><em>e</em></sup>) or <em>x</em> = 1 (mod <em>p</em><sup><em>e</em></sup>).</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">A number <em>x</em> is a <span class="blue"><strong><em>nontrivial square root of</em> 1, <em>modulo n</em></strong></span>, if it satisfies the equation <em>x</em><sup>2</sup> = 1 (mod <em>n</em>) but <em>x</em> is equivalent to neither of the two “trivial” square roots: 1 or −1, modulo <em>n</em>. For example, 6 is a nontrivial square root of 1, modulo 35. We’ll use the following corollary to Theorem 31.34 in <a href="chapter031.xhtml#Sec_31.8">Section 31.8</a> to prove the Miller-Rabin primality-testing procedure correct.</p>
<p class="cor"><strong><em>Corollary 31.35</em></strong></p>
<p class="noindent">If there exists a nontrivial square root of 1, modulo <em>n</em>, then <em>n</em> is composite.</p>
<p class="proof"><strong><em>Proof</em></strong>   By the contrapositive of Theorem 31.34, if there exists a nontrivial square root of 1, modulo <em>n</em>, then <em>n</em> cannot be an odd prime or a power of an odd prime. Nor can <em>n</em> be 2, because if <em>x</em><sup>2</sup> = 1 (mod 2), then <em>x</em> = 1 (mod 2), and therefore, all square roots of 1, modulo 2, are trivial. Thus, <em>n</em> cannot be prime. Finally, we must have <em>n</em> &gt; 1 for a nontrivial square root of 1 to exist. Therefore, <em>n</em> must be composite.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="level4"><strong>Raising to powers with repeated squaring</strong></p>
<p class="noindent">A frequently occurring operation in number-theoretic computations is raising one number to a power modulo another number, also known as <span class="blue"><strong><em>modular exponentiation</em></strong></span>. More precisely, we would like an efficient way to compute <em>a</em><sup><em>b</em></sup> mod <em>n</em>, where <em>a</em> and <em>b</em> are nonnegative integers and <em>n</em> is a positive integer. Modular exponentiation is an essential operation in many primality-testing routines and in the RSA public-key cryptosystem. The method of <span class="blue"><strong><em>repeated squaring</em></strong></span> solves this problem efficiently.</p>
<p>Repeated squaring is based on the following formula to compute <em>a</em><sup><em>b</em></sup> for nonnegative integers <em>a</em> and <em>b</em>:</p>
<p class="eqr"><img alt="art" src="images/Art_P1208.jpg"/></p>
<p>The last case, where <em>b</em> is odd, reduces to the one of the first two cases, since if <em>b</em> is odd, then <em>b</em> − 1 is even. The recursive procedure M<small>ODULAR</small>-E<small>XPONENTIATION</small> on the next page computes <em>a</em><sup><em>b</em></sup> mod <em>n</em> using equation (31.34), but performing all computations modulo <em>n</em>. The term “repeated squaring” comes from squaring the intermediate result <em>d</em> = <em>a</em><sup><em>b</em>/2</sup> in line 5. <a href="chapter031.xhtml#Fig_31-4">Figure 31.4</a> shows the values of the parameter <em>b</em>, the local variable <em>d</em>, and the value returned at each level of the recursion for the call M<small>ODULAR</small>-E<small>XPONENTIATION</small>(7,560,561), which returns the result 1.</p>
<a id="p935"/>
<div class="divimage">
<p class="fig-img1" id="Fig_31-4"><img alt="art" src="images/Art_P1209.jpg"/></p>
<p class="caption"><strong>Figure 31.4</strong> The values of the parameter <em>b</em>, the local variable <em>d</em>, and the value returned for recursive calls of M<small>ODULAR</small>-E<small>XPONENTIATION</small> with parameter values <em>a</em> = 7, <em>b</em> = 560, and <em>n</em> = 561. The value returned by each recursive call is assigned directly to <em>d</em>. The result of the call with <em>a</em> = 7, <em>b</em> = 560, and <em>n</em> = 561 is 1.</p>
</div>
<div class="pull-quote1">
<p class="box-heading">M<small>ODULAR</small>-E<small>XPONENTIATION</small>(<em>a</em>, <em>b</em>, <em>n</em>)</p>
<table class="table1a1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1"><strong>if</strong> <em>b</em> == 0</td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><strong>return</strong> 1</p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><strong>elseif</strong> <em>b</em> mod 2 == 0</td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p2"><em>d</em> = M<small>ODULAR</small>-E<small>XPONENTIATION</small>(<em>a</em>, <em>b</em>/2, <em>n</em>)</p></td>
<td class="td1"><span class="red"><strong>//</strong> <em>b</em> is even</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><p class="p2"><strong>return</strong> (<em>d</em> · <em>d</em>) mod <em>n</em></p></td>
<td class="td1"/>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><strong>else</strong> <em>d</em> = M<small>ODULAR</small>-E<small>XPONENTIATION</small>(<em>a</em>, <em>b</em> − 1, <em>n</em>)</td>
<td class="td1"><span class="red"><strong>//</strong> <em>b</em> is odd</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">7</span></td>
<td class="td1"><p class="p2"><strong>return</strong> (<em>a</em> · <em>d</em>) mod <em>n</em></p></td>
<td class="td1"/>
</tr>
</table>
</div>
<p>The total number of recursive calls depends on the number of bits of <em>b</em> and the values of these bits. Assume that <em>b</em> &gt; 0 and that the most significant bit of <em>b</em> is a 1. Each 0 generates one recursive call (in line 4), and each 1 generates two recursive calls (one in line 6 followed by one in line 4 because if <em>b</em> is odd, then <em>b</em> − 1 is even). If the inputs <em>a</em>, <em>b</em>, and <em>n</em> are <em>β</em>-bit numbers, then there are between <em>β</em> and 2<em>β</em> − 1 recursive calls altogether, the total number of arithmetic operations required is <em>O</em>(<em>β</em>), and the total number of bit operations required is <em>O</em>(<em>β</em><sup>3</sup>).</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>31.6-1</em></strong></p>
<p class="noindent">Draw a table showing the order of every element in <img alt="art" src="images/Art_P1210.jpg"/>. Pick the smallest primitive root <em>g</em> and compute a table giving ind<sub>11,<em>g</em></sub>(<em>x</em>) for all <img alt="art" src="images/Art_P1211.jpg"/>.</p>
<p class="level3"><strong><em>31.6-2</em></strong></p>
<p class="noindent">Show that <em>x</em><sup>2</sup> = 1 (mod <em>p</em><sup><em>e</em></sup>) is equivalent to <em>p</em><sup><em>e</em></sup> | (<em>x</em> − 1)(<em>x</em> + 1).</p>
<p class="level3"><strong><em>31.6-3</em></strong></p>
<p class="noindent">Rewrite the third case of M<small>ODULAR</small>-E<small>XPONENTIATION</small>, where <em>b</em> is odd, so that if <em>b</em> has <em>β</em> bits and the most significant bit is 1, then there are always exactly <em>β</em> recursive calls.</p>
<a id="p936"/>
<p class="level3"><strong><em>31.6-4</em></strong></p>
<p class="noindent">Give a nonrecursive (i.e., iterative) version of M<small>ODULAR</small>-E<small>XPONENTIATION</small>.</p>
<p class="level3"><strong><em>31.6-5</em></strong></p>
<p class="noindent">Assuming that you know <em><span class="symbolfont">ϕ</span></em>(<em>n</em>), explain how to compute <em>a</em><sup>−1</sup> mod <em>n</em> for any <img alt="art" src="images/Art_P1212.jpg"/> using the procedure M<small>ODULAR</small>-E<small>XPONENTIATION</small>.</p>
</section>
<p class="line1"/>
<section title="31.7 The RSA public-key cryptosystem">
<a id="Sec_31.7"/>
<p class="level1" id="h1-183"><a href="toc.xhtml#Rh1-183"><strong>31.7    The RSA public-key cryptosystem</strong></a></p>
<p class="noindent">With a public-key cryptosystem, you can <span class="blue"><strong><em>encrypt</em></strong></span> messages sent between two communicating parties so that an eavesdropper who overhears the encrypted messages will not be able to decode, or <span class="blue"><strong><em>decrypt</em></strong></span>, them. A public-key cryptosystem also enables a party to append an unforgeable “digital signature” to the end of an electronic message. Such a signature is the electronic version of a handwritten signature on a paper document. It can be easily checked by anyone, forged by no one, yet loses its validity if any bit of the message is altered. It therefore provides authentication of both the identity of the signer and the contents of the signed message. It is the perfect tool for electronically signed business contracts, electronic checks, electronic purchase orders, and other electronic communications that parties wish to authenticate.</p>
<p>The RSA public-key cryptosystem relies on the dramatic difference between the ease of finding large prime numbers and the difficulty of factoring the product of two large prime numbers. <a href="chapter031.xhtml#Sec_31.8">Section 31.8</a> describes an efficient procedure for finding large prime numbers.</p>
<p class="level4"><strong>Public-key cryptosystems</strong></p>
<p class="noindent">In a public-key cryptosystem, each participant has both a <span class="blue"><strong><em>public key</em></strong></span> and a <span class="blue"><strong><em>secret key</em></strong></span>. Each key is a piece of information. For example, in the RSA cryptosystem, each key consists of a pair of integers. The participants “Alice” and “Bob” are traditionally used in cryptography examples. We denote the public keys for Alice and Bob as <em>P</em><sub><em>A</em></sub> and <em>P</em><sub><em>B</em></sub>, respectively, and likewise the secret keys are <em>S</em><sub><em>A</em></sub> for Alice and <em>S</em><sub><em>B</em></sub> for Bob.</p>
<p>Each participant creates his or her own public and secret keys. Secret keys are kept secret, but public keys can be revealed to anyone or even published. In fact, it is often convenient to assume that everyone’s public key is available in a public directory, so that any participant can easily obtain the public key of any other participant.</p>
<a id="p937"/>
<div class="divimage">
<p class="fig-img1" id="Fig_31-5"><img alt="art" src="images/Art_P1213.jpg"/></p>
<p class="caption"><strong>Figure 31.5</strong> Encryption in a public key system. Bob encrypts the message <em>M</em> using Alice’s public key <em>P</em><sub><em>A</em></sub> and transmits the resulting ciphertext <em>C</em> = <em>P</em><sub><em>A</em></sub>(<em>M</em>) over a communication channel to Alice. An eavesdropper who captures the transmitted ciphertext gains no information about <em>M</em>. Alice receives <em>C</em> and decrypts it using her secret key to obtain the original message <em>M</em> = <em>S</em><sub><em>A</em></sub>(<em>C</em>).</p>
</div>
<p>The public and secret keys specify functions that can be applied to any message. Let <span class="script">D</span> denote the set of permissible messages. For example, <span class="script">D</span> might be the set of all finite-length bit sequences. The simplest, and original, formulation of public-key cryptography requires one-to-one functions from <span class="script">D</span> to itself, based on the public and secret keys. We denote the function based on Alice’s public key <em>P</em><sub><em>A</em></sub> by <em>P</em><sub><em>A</em></sub>() and the function based on her secret key <em>S</em><sub><em>A</em></sub> by <em>S</em><sub><em>A</em></sub>(). The functions <em>P</em><sub><em>A</em></sub>() and <em>S</em><sub><em>A</em></sub>() are thus permutations of <span class="script">D</span>. We assume that the functions <em>P</em><sub><em>A</em></sub>() and <em>S</em><sub><em>A</em></sub>() are efficiently computable given the corresponding keys <em>P</em><sub><em>A</em></sub> and <em>S</em><sub><em>A</em></sub>.</p>
<p>The public and secret keys for any participant are a “matched pair” in that they specify functions that are inverses of each other. That is,</p>
<p class="eqr"><img alt="art" src="images/Art_P1214.jpg"/></p>
<p class="noindent">for any message <em>M</em> ∈ <span class="script">D</span>. Transforming <em>M</em> with the two keys <em>P</em><sub><em>A</em></sub> and <em>S</em><sub><em>A</em></sub> successively, in either order, yields back the original message <em>M</em>.</p>
<p>A public-key cryptosystem requires that Alice, and only Alice, be able to compute the function <em>S</em><sub><em>A</em></sub>() in any practical amount of time. This assumption is crucial to keeping encrypted messages sent to Alice private and to knowing that Alice’s digital signatures are authentic. Alice must keep her key <em>S</em><sub><em>A</em></sub> secret. If she does not, whoever else has access to <em>S</em><sub><em>A</em></sub> can decrypt messages intended only for Alice and can also forge her digital signature. The assumption that only Alice can reasonably compute <em>S</em><sub><em>A</em></sub>() must hold even though everyone knows <em>P</em><sub><em>A</em></sub> and can compute <em>P</em><sub><em>A</em></sub>(), the inverse function to <em>S</em><sub><em>A</em></sub>(), efficiently. These requirements appear formidable, but we’ll see how to satisfy them.</p>
<p>In a public-key cryptosystem, encryption works as shown in <a href="chapter031.xhtml#Fig_31-5">Figure 31.5</a>. Suppose that Bob wishes to send Alice a message <em>M</em> encrypted so that it looks like <a id="p938"/></p>
<div class="divimage">
<p class="fig-img1" id="Fig_31-6"><img alt="art" src="images/Art_P1215.jpg"/></p>
<p class="caption"><strong>Figure 31.6</strong> Digital signatures in a public-key system. Alice signs the message <em>M</em>′ by appending her digital signature <em>σ</em> = <em>S</em><sub><em>A</em></sub>(<em>M</em>′) to it. She transmits the message/signature pair (<em>M</em>′, <em>σ</em>) to Bob, who verifies it by checking the equation <em>M</em>′ = <em>P</em><sub><em>A</em></sub>(<em>σ</em>). If the equation holds, he accepts (<em>M</em>′, <em>σ</em>) as a message that Alice has signed.</p>
</div>
<p class="noindent">unintelligible gibberish to an eavesdropper. The scenario for sending the message goes as follows.</p>
<ul class="ulnoindent" epub:type="list">
<li>Bob obtains Alice’s public key <em>P</em><sub><em>A</em></sub>, perhaps from a public directory or perhaps directly from Alice.</li>
<li class="litop">Bob computes the <span class="blue"><strong><em>ciphertext</em></strong></span> <em>C</em> = <em>P</em><sub><em>A</em></sub>(<em>M</em>) corresponding to the message <em>M</em> and sends <em>C</em> to Alice.</li>
<li class="litop">When Alice receives the ciphertext <em>C</em>, she applies her secret key <em>S</em><sub><em>A</em></sub> to retrieve the original message: <em>S</em><sub><em>A</em></sub>(<em>C</em>) = <em>S</em><sub><em>A</em></sub>(<em>P</em><sub><em>A</em></sub>(<em>M</em>)) = <em>M</em>.</li></ul>
<p class="noindent">Because <em>S</em><sub><em>A</em></sub>() and <em>P</em><sub><em>A</em></sub>() are inverse functions, Alice can compute <em>M</em> from <em>C</em>. Because only Alice is able to compute <em>S</em><sub><em>A</em></sub>(), only Alice can compute <em>M</em> from <em>C</em>. Because Bob encrypts <em>M</em> using <em>P</em><sub><em>A</em></sub>(), only Alice can understand the transmitted message.</p>
<p>Digital signatures can be implemented within this formulation of a public-key cryptosystem. (There are other ways to construct digital signatures, but we won’t go into them here.) Suppose now that Alice wishes to send Bob a digitally signed response <em>M</em>′. <a href="chapter031.xhtml#Fig_31-6">Figure 31.6</a> shows how the digital-signature scenario proceeds.</p>
<ul class="ulnoindent" epub:type="list">
<li>Alice computes her <span class="blue"><strong><em>digital signature</em></strong></span> <em>σ</em> for the message <em>M</em>′ using her secret key <em>S</em><sub><em>A</em></sub> and the equation <em>σ</em> = <em>S</em><sub><em>A</em></sub>(<em>M</em>′).</li>
<li class="litop">Alice sends the message/signature pair (<em>M</em>′, <em>σ</em>) to Bob.</li>
<li class="litop">When Bob receives (<em>M</em>′, <em>σ</em>), he can verify that it originated from Alice by using Alice’s public key to verify the equation <em>M</em>′ = <em>P</em><sub><em>A</em></sub>(<em>σ</em>). (Presumably, <em>M</em>′ contains Alice’s name, so that Bob knows whose public key to use.) If the equation holds, then Bob concludes that the message <em>M</em>′ was actually signed by Alice. If <a id="p939"/>the equation fails to hold, Bob concludes either that the information he received was corrupted by transmission errors or that the pair (<em>M</em>′, <em>σ</em>) is an attempted forgery.</li></ul>
<p class="noindent">Because a digital signature provides both authentication of the signer’s identity and authentication of the contents of the signed message, it is analogous to a handwritten signature at the end of a written document.</p>
<p>A digital signature must be verifiable by anyone who has access to the signer’s public key. A signed message can be verified by one party and then passed on to other parties who can also verify the signature. For example, the message might be an electronic check from Alice to Bob. After Bob verifies Alice’s signature on the check, he can give the check to his bank, who can then also verify the signature and effect the appropriate funds transfer.</p>
<p>A signed message may or may not be encrypted. The message can be “in the clear” and not protected from disclosure. By composing the above protocols for encryption and for signatures, Alice can create a message to Bob that is both signed and encrypted. Alice first appends her digital signature to the message and then encrypts the resulting message/signature pair with Bob’s public key. Bob decrypts the received message with his secret key to obtain both the original message and its digital signature. Bob can then verify the signature using Alice’s public key. The corresponding combined process using paper-based systems would be to sign the paper document and then seal the document inside a paper envelope that is opened only by the intended recipient.</p>
<p class="level4"><strong>The RSA cryptosystem</strong></p>
<p class="noindent">In the <span class="blue"><strong><em>RSA public-key cryptosystem</em></strong></span>, a participant creates a public key and a secret key with the following procedure:</p>
<ol class="olnoindent" epub:type="list">
<li>Select at random two large prime numbers <em>p</em> and <em>q</em> such that <em>p</em> ≠ <em>q</em>. The primes <em>p</em> and <em>q</em> might be, say, 1024 bits each.</li>
<li class="litop">Compute <em>n</em> = <em>pq</em>.</li>
<li class="litop">Select a small odd integer <em>e</em> that is relatively prime to <em><span class="symbolfont">ϕ</span></em>(<em>n</em>), which, by equation (31.21), equals (<em>p</em> – 1)(<em>q</em> – 1).</li>
<li class="litop">Compute <em>d</em> as the multiplicative inverse of <em>e</em>, modulo <em><span class="symbolfont">ϕ</span></em>(<em>n</em>). (Corollary 31.26 guarantees that <em>d</em> exists and is uniquely defined. You can use the technique of <a href="chapter031.xhtml#Sec_31.4">Section 31.4</a> to compute <em>d</em>, given <em>e</em> and <em><span class="symbolfont">ϕ</span></em>(<em>n</em>).)</li>
<li class="litop">Publish the pair <em>P</em> = (<em>e</em>, <em>n</em>) as the participant’s <span class="blue"><strong><em>RSA public key</em></strong></span>.</li>
<li class="litop">Keep secret the pair <em>S</em> = (<em>d</em>, <em>n</em>) as the participant’s <span class="blue"><strong><em>RSA secret key</em></strong></span>.</li></ol>
<a id="p940"/>
<p>For this scheme, the domain <span class="script">D</span> is the set <span class="font1">ℤ</span><sub><em>n</em></sub>. To transform a message <em>M</em> associated with a public key <em>P</em> = (<em>e</em>, <em>n</em>), compute</p>
<p class="eqr"><img alt="art" src="images/Art_P1216.jpg"/></p>
<p class="noindent">To transform a ciphertext <em>C</em> associated with a secret key <em>S</em> = (<em>d</em>, <em>n</em>), compute</p>
<p class="eqr"><img alt="art" src="images/Art_P1217.jpg"/></p>
<p class="noindent">These equations apply to both encryption and signatures. To create a signature, the signer’s secret key is applied to the message to be signed, rather than to a ciphertext. To verify a signature, the public key of the signer is applied to the signature rather than to a message to be encrypted.</p>
<p>To implement the public-key and secret-key operations (31.37) and (31.38), you can use the procedure M<small>ODULAR</small>-E<small>XPONENTIATION</small> described in <a href="chapter031.xhtml#Sec_31.6">Section 31.6</a>. To analyze the running time of these operations, assume that the public key (<em>e</em>, <em>n</em>) and secret key (<em>d</em>, <em>n</em>) satisfy 1g <em>e</em> = <em>O</em>(1), 1g <em>d</em> ≤ <em>β</em>, and 1g <em>n</em> ≤ <em>β</em>. Then, applying a public key requires <em>O</em>(1) modular multiplications and uses <em>O</em>(<em>β</em><sup>2</sup>) bit operations. Applying a secret key requires <em>O</em>(<em>β</em>) modular multiplications, using <em>O</em>(<em>β</em><sup>3</sup>) bit operations.</p>
<p class="theo"><strong><em>Theorem 31.36 (Correctness of RSA)</em></strong></p>
<p class="noindent">The RSA equations (31.37) and (31.38) define inverse transformations of <span class="font1">ℤ</span><sub><em>n</em></sub> satisfying equations (31.35) and (31.36).</p>
<p class="proof"><strong><em>Proof</em></strong>   From equations (31.37) and (31.38), we have that for any <em>M</em> ∈ <span class="font1">ℤ</span><sub><em>n</em></sub>,</p>
<p class="eql"><em>P</em>(<em>S</em>(<em>M</em>)) = <em>S</em>(<em>P</em>(<em>M</em>)) = <em>M</em><sup><em>ed</em></sup> (mod <em>n</em>).</p>
<p class="noindent">Since <em>e</em> and <em>d</em> are multiplicative inverses modulo <em><span class="symbolfont">ϕ</span></em>(<em>n</em>) = (<em>p</em> – 1)(<em>q</em> – 1),</p>
<p class="eql"><em>ed</em> = 1 + <em>k</em>(<em>p</em> – 1)(<em>q</em> – 1)</p>
<p class="noindent">for some integer <em>k</em>. But then, if <em>M</em> ≠ 0 (mod <em>p</em>), we have</p>
<table class="table2b">
<tr>
<td class="td2"><em>M</em><sup><em>ed</em></sup></td>
<td class="td2">= <em>M</em>(<em>M</em><sup><em>p</em>–1</sup>)<sup><em>k</em>(<em>q</em>–1)</sup></td>
<td class="td2">(mod <em>p</em>)</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">= <em>M</em>((<em>M</em> mod <em>p</em>)<sup><em>p</em>–1</sup>)<sup><em>k</em>(<em>q</em>–1)</sup></td>
<td class="td2">(mod <em>p</em>)</td>
<td class="td2"/>
</tr>
<tr>
<td class="td2"/>
<td class="td2">= <em>M</em>(1)<sup><em>k</em>(<em>q</em>–1)</sup></td>
<td class="td2">(mod <em>p</em>)</td>
<td class="td2">(by Theorem 31.31)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">= <em>M</em></td>
<td class="td2">(mod <em>p</em>)</td>
<td class="td2"/>
</tr>
</table>
<p class="noindent">Also, <em>M</em><sup><em>ed</em></sup> = <em>M</em> (mod <em>p</em>) if <em>M</em> = 0 (mod <em>p</em>). Thus,</p>
<p class="eql"><em>M</em><sup><em>ed</em></sup> = <em>M</em> (mod <em>p</em>)</p>
<p class="noindent">for all <em>M</em>. Similarly,</p>
<a id="p941"/>
<p class="eql"><em>M</em><sup><em>ed</em></sup> = <em>M</em> (mod <em>q</em>)</p>
<p class="noindent">for all <em>M</em>. Thus, by Corollary 31.29 to the Chinese remainder theorem,</p>
<p class="eql"><em>M</em><sup><em>ed</em></sup> = <em>M</em> (mod <em>n</em>)</p>
<p class="noindent">for all <em>M</em>.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The security of the RSA cryptosystem rests in large part on the difficulty of factoring large integers. If an adversary can factor the modulus <em>n</em> in a public key, then the adversary can derive the secret key from the public key, using the knowledge of the factors <em>p</em> and <em>q</em> in the same way that the creator of the public key used them. Therefore, if factoring large integers is easy, then breaking the RSA cryptosystem is easy. The converse statement, that if factoring large integers is hard, then breaking RSA is hard, is unproven. After two decades of research, however, no easier method has been found to break the RSA public-key cryptosystem than to factor the modulus <em>n</em>. And factoring large integers is surprisingly difficult. By randomly selecting and multiplying together two 1024-bit primes, you can create a public key that cannot be “broken” in any feasible amount of time with current technology. In the absence of a fundamental breakthrough in the design of number-theoretic algorithms, and when implemented with care following recommended standards, the RSA cryptosystem is capable of providing a high degree of security in applications.</p>
<p>In order to achieve security with the RSA cryptosystem, however, you should use integers that are quite long—more than 1000 bits—to resist possible advances in the art of factoring. In 2021, RSA moduli are commonly in the range of 2048 to 4096 bits. To create moduli of such sizes, you must find large primes efficiently. <a href="chapter031.xhtml#Sec_31.8">Section 31.8</a> addresses this problem.</p>
<p>For efficiency, RSA is often used in a “hybrid” or “key-management” mode with fast cryptosystems that are not public-key cryptosystems. With such a <span class="blue"><strong><em>symmetric-key</em></strong></span> system, the encryption and decryption keys are identical. If Alice wishes to send a long message <em>M</em> to Bob privately, she selects a random key <em>K</em> for the fast symmetric-key cryptosystem and encrypts <em>M</em> using <em>K</em>, obtaining ciphertext <em>C</em>, where <em>C</em> is as long as <em>M</em>, but <em>K</em> is quite short. Then she encrypts <em>K</em> using Bob’s public RSA key. Since <em>K</em> is short, computing <em>P</em><sub><em>B</em></sub>(<em>K</em>) is fast (much faster than computing <em>P</em><sub><em>B</em></sub>(<em>M</em>)). She then transmits (<em>C</em>, <em>P</em><sub><em>B</em></sub>(<em>K</em>)) to Bob, who decrypts <em>P</em><sub><em>B</em></sub>(<em>K</em>) to obtain <em>K</em> and then uses <em>K</em> to decrypt <em>C</em>, obtaining <em>M</em>.</p>
<p>A similar hybrid approach creates digital signatures efficiently. This approach combines RSA with a public <span class="blue"><strong><em>collision-resistant hash function</em></strong></span> <em>h</em>—a function that is easy to compute but for which it is computationally infeasible to find two messages <em>M</em> and <em>M</em>′ such that <em>h</em>(<em>M</em>) = <em>h</em>(<em>M</em>′). The value <em>h</em>(<em>M</em>) is a short (say, 256-bit) “fingerprint” of the message <em>M</em>. If Alice wishes to sign a message <em>M</em>, she first applies <em>h</em> to <em>M</em> to obtain the fingerprint <em>h</em>(<em>M</em>), which she then encrypts with her secret key. She sends (<em>M</em>, <em>S</em><sub><em>A</em></sub>(<em>h</em>(<em>M</em>))) to Bob as her signed version of <em>M</em>. <a id="p942"/>Bob can verify the signature by computing <em>h</em>(<em>M</em>) and verifying that <em>P</em><sub><em>A</em></sub> applied to <em>S</em><sub><em>A</em></sub>(<em>h</em>(<em>M</em>)) as received equals <em>h</em>(<em>M</em>). Because no one can create two messages with the same fingerprint, it is computationally infeasible to alter a signed message and preserve the validity of the signature.</p>
<p>One way to distribute public keys uses <span class="blue"><strong><em>certificates</em></strong></span>. For example, assume that there is a “trusted authority” <em>T</em> whose public key is known by everyone. Alice can obtain from <em>T</em> a signed message (her certificate) stating that “Alice’s public key is <em>P</em><sub><em>A</em></sub>.” This certificate is “self-authenticating” since everyone knows <em>P</em><sub><em>T</em></sub>. Alice can include her certificate with her signed messages, so that the recipient has Alice’s public key immediately available in order to verify her signature. Because her key was signed by <em>T</em>, the recipient knows that Alice’s key is really Alice’s.</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>31.7-1</em></strong></p>
<p class="noindent">Consider an RSA key set with <em>p</em> = 11, <em>q</em> = 29, <em>n</em> = 319, and <em>e</em> = 3. What value of <em>d</em> should be used in the secret key? What is the encryption of the message <em>M</em> = 100?</p>
<p class="level3"><strong><em>31.7-2</em></strong></p>
<p class="noindent">Prove that if Alice’s public exponent <em>e</em> is 3 and an adversary obtains Alice’s secret exponent <em>d</em>, where 0 &lt; <em>d</em> &lt; <em><span class="symbolfont">ϕ</span></em>(<em>n</em>), then the adversary can factor Alice’s modulus <em>n</em> in time polynomial in the number of bits in <em>n</em>. (Although you are not asked to prove it, you might be interested to know that this result remains true even if the condition <em>e</em> = 3 is removed. See Miller [<a epub:type="noteref" href="bibliography001.xhtml#endnote_327">327</a>].)</p>
<p class="level3"><span class="font1">★</span> <strong><em>31.7-3</em></strong></p>
<p class="noindent">Prove that RSA is multiplicative in the sense that</p>
<p class="eql"><em>P</em><sub><em>A</em></sub>(<em>M</em><sub>1</sub>)<em>P</em><sub><em>A</em></sub>(<em>M</em><sub>2</sub>) = <em>P</em><sub><em>A</em></sub>(<em>M</em><sub>1</sub><em>M</em><sub>2</sub>) (mod <em>n</em>).</p>
<p class="noindent">Use this fact to prove that if an adversary had a procedure that could efficiently decrypt 1% of messages from <span class="font1">ℤ</span><sub><em>n</em></sub> encrypted with <em>P</em><sub><em>A</em></sub>, then the adversary could employ a probabilistic algorithm to decrypt every message encrypted with <em>P</em><sub><em>A</em></sub> with high probability.</p>
</section>
<p class="line1"/>
<section title="⋆ 31.8 Primality testing">
<a id="Sec_31.8"/>
<p class="level1" id="h1-184"><a href="toc.xhtml#Rh1-184"><span class="font1">★</span> <strong>31.8    Primality testing</strong></a></p>
<p class="noindent">This section shows how to find large primes. We begin with a discussion of the density of primes, proceed to examine a plausible, but incomplete, approach to <a id="p943"/>primality testing, and then present an effective randomized primality test due to Miller and Rabin.</p>
<p class="level4"><strong>The density of prime numbers</strong></p>
<p class="noindent">Many applications, such as cryptography, call for finding large “random” primes. Fortunately, large primes are not too rare, so that it is feasible to test random integers of the appropriate size until you find one that is prime. The <span class="blue"><strong><em>prime distribution function</em></strong></span> <em>π</em>(<em>n</em>) specifies the number of primes that are less than or equal to <em>n</em>. For example, <em>π</em>(10) = 4, since there are 4 prime numbers less than or equal to 10, namely, 2, 3, 5, and 7. The prime number theorem gives a useful approximation to <em>π</em>(<em>n</em>).</p>
<p class="theo"><strong><em>Theorem 31.37 (Prime number theorem)</em></strong></p>
<p class="eql"><img alt="art" src="images/Art_P1218.jpg"/></p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">The approximation <em>n</em>/ln <em>n</em> gives reasonably accurate estimates of <em>π</em>(<em>n</em>) even for small <em>n</em>. For example, it is off by less than 6% at <em>n</em> = 10<sup>9</sup>, where <em>π</em>(<em>n</em>) = 50,847,534 and <em>n</em>/ln <em>n</em> ≈ 48,254,942. (To a number theorist, 10<sup>9</sup> is a small number.)</p>
<p>The process of randomly selecting an integer <em>n</em> and determining whether it is prime is really just a Bernoulli trial (see <a href="appendix003.xhtml#Sec_C.4">Section C.4</a>). By the prime number theorem, the probability of a success—that is, the probability that <em>n</em> is prime—is approximately 1/ln <em>n</em>. The geometric distribution says how many trials must occur to obtain a success, and by equation (C.36) on page 1197, the expected number of trials is approximately ln <em>n</em>. Thus, in order to find a prime that has the same length as <em>n</em> by testing integers chosen randomly near <em>n</em>, the expected number examined would be approximately ln <em>n</em>. For example, the expectation is that finding a 1024-bit prime would require testing approximately ln 2<sup>1024</sup> ≈ 710 randomly chosen 1024-bit numbers for primality. (Of course, to cut this figure in half, choose only odd integers.)</p>
<p>The remainder of this section shows how to determine whether a large odd integer <em>n</em> is prime. For notational convenience, we assume that <em>n</em> has the prime factorization</p>
<p class="eql"><img alt="art" src="images/Art_P1219.jpg"/></p>
<p class="noindent">where <em>r</em> ≥ 1, <em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, …, <em>p</em><sub><em>r</em></sub> are the prime factors of <em>n</em>, and <em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>, …, <em>e</em><sub><em>r</em></sub> are positive integers. The integer <em>n</em> is prime if and only if <em>r</em> = 1 and <em>e</em><sub>1</sub> = 1.</p>
<p>One simple approach to the problem of testing for primality is <span class="blue"><strong><em>trial division</em></strong></span>: try dividing <em>n</em> by each integer 2, 3, 5, 7, 9, …, <img alt="art" src="images/Art_P1220.jpg"/>, skipping even integers greater <a id="p944"/>than 2. We can conclude that <em>n</em> is prime if and only if none of the trial divisors divides <em>n</em>. Assuming that each trial division takes constant time, the worst-case running time is <img alt="art" src="images/Art_P1221.jpg"/>, which is exponential in the length of <em>n</em>. (Recall that if <em>n</em> is encoded in binary using <em>β</em> bits, then <em>β</em> = <span class="font1">⌈</span>1g(<em>n</em> + 1)<span class="font1">⌉</span>, and so <img alt="art" src="images/Art_P1222.jpg"/>.) Thus, trial division works well only if <em>n</em> is very small or happens to have a small prime factor. When it works, trial division has the advantage that it not only determines whether <em>n</em> is prime or composite, it also determines one of <em>n</em>’s prime factors if <em>n</em> is composite.</p>
<p>This section focuses on finding out whether a given number <em>n</em> is prime. If <em>n</em> is composite, we won’t worry about finding its prime factorization. Computing the prime factorization of a number is computationally expensive. You might be surprised that it turns out to be much easier to ascertain whether a given number is prime than it is to determine the prime factorization of the number if it is not prime.</p>
<p class="level4"><strong>Pseudoprimality testing</strong></p>
<p class="noindent">We’ll start with a method for primality testing that “almost works” and, in fact, is good enough for many practical applications. Later on, we’ll refine this method to remove the small defect. Let <img alt="art" src="images/Art_P1223.jpg"/> denote the nonzero elements of <span class="font1">ℤ</span><sub><em>n</em></sub>:</p>
<p class="eql"><img alt="art" src="images/Art_P1224.jpg"/></p>
<p class="noindent">If <em>n</em> is prime, then <img alt="art" src="images/Art_P1225.jpg"/>.</p>
<p>We say that <em>n</em> is a <span class="blue"><strong><em>base-a pseudoprime</em></strong></span> if <em>n</em> is composite and</p>
<p class="eqr"><img alt="art" src="images/Art_P1226.jpg"/></p>
<p class="noindent">Fermat’s theorem (Theorem 31.31 on page 932) implies that if <em>n</em> is prime, then <em>n</em> satisfies equation (31.39) for every <em>a</em> in <img alt="art" src="images/Art_P1227.jpg"/>. Thus, if there is any <img alt="art" src="images/Art_P1228.jpg"/> such that <em>n</em> does <em>not</em> satisfy equation (31.39), then <em>n</em> is certainly composite. Surprisingly, the converse <em>almost</em> holds, so that this criterion forms an almost perfect test for primality. Instead of trying every value of <img alt="art" src="images/Art_P1228.jpg"/>, test to see whether <em>n</em> satisfies equation (31.39) for just <em>a</em> = 2. If not, then declare <em>n</em> to be composite by returning <small>COMPOSITE</small>. Otherwise, return <small>PRIME</small>, guessing that <em>n</em> is prime (when, in fact, all we know is that <em>n</em> is either prime or a base-2 pseudoprime).</p>
<p>The procedure P<small>SEUDOPRIME</small> on the next page pretends in this manner to check whether <em>n</em> is prime. It uses the procedure M<small>ODULAR</small>-E<small>XPONENTIATION</small> from <a href="chapter031.xhtml#Sec_31.6">Section 31.6</a>. It assumes that the input <em>n</em> is an odd integer greater than 2. This procedure can make errors, but only of one type. That is, if it says that <em>n</em> is composite, then it is always correct. If it says that <em>n</em> is prime, however, then it makes an error only if <em>n</em> is a base-2 pseudoprime.</p>
<p>How often does P<small>SEUDOPRIME</small> err? Surprisingly rarely. There are only 22 values of <em>n</em> less than 10,000 for which it errs, the first four of which are 341, 561, 645, <a id="p945"/></p>
<div class="pull-quote1">
<p class="box-heading">P<small>SEUDOPRIME</small>(<em>n</em>)</p>
<table class="table1">
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1" colspan="2">
<p class="noindent"><strong>if</strong> M<small>ODULAR</small>-E<small>XPONENTIATION</small>(2, <em>n</em> – 1, <em>n</em>) ≠ 1 (mod <em>n</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1"><p class="p2"><strong>return</strong> <small>COMPOSITE</small></p></td>
<td class="td1"><span class="red"><strong>//</strong> definitely</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1"><strong>else return</strong> <small>PRIME</small></td>
<td class="td1"><span class="red"><strong>//</strong> we hope!</span></td>
</tr>
</table>
</div>
<p class="noindent">and 1105. We won’t prove it, but the probability that this program makes an error on a randomly chosen <em>β</em>-bit number goes to 0 as <em>β</em> approaches ∞. Using more precise estimates due to Pomerance [<a epub:type="noteref" href="bibliography001.xhtml#endnote_361">361</a>] of the number of base-2 pseudoprimes of a given size, a randomly chosen 512-bit number that is called prime by P<small>SEUDOPRIME</small> has less than one chance in 10<sup>20</sup> of being a base-2 pseudoprime, and a randomly chosen 1024-bit number that is called prime has less than one chance in 10<sup>41</sup> of being a base-2 pseudoprime. Thus, if you are merely trying to find a large prime for some application, for all practical purposes you almost never go wrong by choosing large numbers at random until one of them causes P<small>SEUDOPRIME</small> to return <small>PRIME</small>. But when the numbers being tested for primality are not randomly chosen, you might need a better approach for testing primality. As we’ll see, a little more cleverness, and some randomization, will yield a primality-testing method that works well on all inputs.</p>
<p>Since P<small>SEUDOPRIME</small> checks equation (31.39) for only <em>a</em> = 2, you might think that you could eliminate all the errors by simply checking equation (31.39) for a second base number, say <em>a</em> = 3. Better yet, you could check equation (31.39) for even more values of <em>a</em>. Unfortunately, even checking for several values of <em>a</em> does not eliminate all errors, because there exist composite integers <em>n</em>, known as <span class="blue"><strong><em>Carmichael numbers</em></strong></span>, that satisfy equation (31.39) for <em>all</em> <img alt="art" src="images/Art_P1230.jpg"/>. (The equation does fail when gcd(<em>a</em>, <em>n</em>) &gt; 1—that is, when <img alt="art" src="images/Art_P1231.jpg"/>—but demonstrating that <em>n</em> is composite by finding such an <em>a</em> can be difficult if <em>n</em> has only large prime factors.) The first three Carmichael numbers are 561, 1105, and 1729. Carmichael numbers are extremely rare. For example, only 255 of them are less than 100,000,000. Exercise 31.8-2 helps explain why they are so rare.</p>
<p>Let’s see how to improve the primality test so that Carmichael numbers won’t fool it.</p>
<p class="level4"><strong>The Miller-Rabin randomized primality test</strong></p>
<p class="noindent">The Miller-Rabin primality test overcomes the problems of the simple procedure P<small>SEUDOPRIME</small> with two modifications:</p>
<ul class="ulnoindent" epub:type="list">
<li>It tries several randomly chosen base values <em>a</em> instead of just one base value.</li>
<li class="litop">While computing each modular exponentiation, it looks for a nontrivial square root of 1, modulo <em>n</em>, during the final set of squarings. If it finds one, it stops <a id="p946"/>and returns <small>COMPOSITE</small>. Corollary 31.35 from <a href="chapter031.xhtml#Sec_31.6">Section 31.6</a> justifies detecting composites in this manner.</li></ul>
<p>The pseudocode for the Miller-Rabin primality test appears in the procedures M<small>ILLER</small>-R<small>ABIN</small> and W<small>ITNESS</small>. The input <em>n</em> &gt; 2 to M<small>ILLER</small>-R<small>ABIN</small> is the odd number to be tested for primality, and <em>s</em> is the number of randomly chosen base values from <img alt="art" src="images/Art_P1232.jpg"/> to be tried. The code uses the random-number generator R<small>ANDOM</small> described on page 129: R<small>ANDOM</small>(2, <em>n</em> – 2) returns a randomly chosen integer <em>a</em> satisfying 2 ≤ <em>a</em> ≤ <em>n</em> – 2. (This range of values avoids having <em>a</em> = ≥1 (mod <em>n</em>).) The call of the auxiliary procedure W<small>ITNESS</small>(<em>a</em>, <em>n</em>) returns <small>TRUE</small> if and only if <em>a</em> is a “witness” to the compositeness of <em>n</em>—that is, if it is possible using <em>a</em> to prove (in a manner that we will see) that <em>n</em> is composite. The test W<small>ITNESS</small>(<em>a</em>, <em>n</em>) is an extension of, but more effective than, the test in equation (31.39) that formed the basis for P<small>SEUDOPRIME</small>, using <em>a</em> = 2.</p>
<p>Let’s first understand how W<small>ITNESS</small> works, and then we’ll see how the Miller-Rabin primality test uses it. Let <em>n</em> – 1 = 2<sup><em>t</em></sup><em>u</em> where <em>t</em> ≥ 1 and <em>u</em> is odd. That is, the binary representation of <em>n</em> – 1 is the binary representation of the odd integer <em>u</em> followed by exactly <em>t</em> zeros. Therefore, <img alt="art" src="images/Art_P1233.jpg"/>, so that one way to compute <em>a</em><sup><em>n</em>−1</sup> mod <em>n</em> is to first compute <em>a</em><sup><em>u</em></sup> mod <em>n</em> and then square the result <em>t</em> times successively.</p>
<div class="pull-quote1">
<table class="table1a1">
<tr>
<td class="td1" colspan="2"><p class="box-heading">M<small>ILLER</small>-R<small>ABIN</small>(<em>n</em>, <em>s</em>)</p></td>
<td class="td1"><span class="red"><strong>//</strong> <em>n</em> &gt; 2 is odd</span></td>
</tr>
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1" colspan="2"><strong>for</strong> <em>j</em> = 1 <strong>to</strong> <em>s</em></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1" colspan="2"><p class="p2"><em>a</em> = R<small>ANDOM</small>(2, <em>n</em> – 2)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>if</strong> W<small>ITNESS</small>(<em>a</em>, <em>n</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1"><p class="p3"><strong>return</strong> <small>COMPOSITE</small></p></td>
<td class="td1"><span class="red"><strong>//</strong> definitely</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1"><strong>return</strong> <small>PRIME</small></td>
<td class="td1"><span class="red"><strong>//</strong> almost surely</span></td>
</tr>
<tr>
<td class="td1" colspan="2"><p class="box-headinga">W<small>ITNESS</small>(<em>a</em>, <em>n</em>)</p></td>
</tr>
<tr>
<td class="td1w"><span class="x-small">1</span></td>
<td class="td1" colspan="2"><p class="noindent">let <em>t</em> and <em>u</em> be such that <em>t</em> ≥ 1, <em>u</em> is odd, and <em>n</em> – 1 = 2<sup><em>t</em></sup><em>u</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">2</span></td>
<td class="td1" colspan="2"><p class="noindent"><em>x</em><sub>0</sub> = M<small>ODULAR</small>-E<small>XPONENTIATION</small>(<em>a</em>, <em>u</em>, <em>n</em>)</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">3</span></td>
<td class="td1" colspan="2"><p class="noindent"><strong>for</strong> <em>i</em> = 1 <strong>to</strong> <em>t</em></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">4</span></td>
<td class="td1" colspan="2"><p class="p2"><img alt="art" src="images/Art_P1234.jpg"/></p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">5</span></td>
<td class="td1" colspan="2"><p class="p2"><strong>if</strong> <em>x</em><sub><em>i</em></sub> == 1 and <em>x</em><sub><em>i</em>–1</sub> ≠ 1 and <em>x</em><sub><em>i</em>–1</sub> ≠ <em>n</em> – 1</p></td>
</tr>
<tr>
<td class="td1"><span class="x-small">6</span></td>
<td class="td1"><p class="p3"><strong>return</strong> <small>TRUE</small></p></td>
<td class="td1"><span class="red"><strong>//</strong> found a nontrivial square root of 1</span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">7</span></td>
<td class="td1" colspan="2"><strong>if</strong> <em>x</em><sub><em>t</em></sub> ≠ 1</td>
</tr>
<tr>
<td class="td1"><span class="x-small">8</span></td>
<td class="td1"><p class="p2"><strong>return</strong> <small>TRUE</small></p></td>
<td class="td1"><span class="red"><strong>//</strong> composite, as in P<small>SEUDOPRIME</small></span></td>
</tr>
<tr>
<td class="td1"><span class="x-small">9</span></td>
<td class="td1" colspan="2"><strong>return</strong> <small>FALSE</small></td>
</tr>
</table>
</div>
<a id="p947"/>
<p>This pseudocode for W<small>ITNESS</small> computes <em>a</em><sup><em>n</em>–1</sup> mod <em>n</em> by first computing the value <em>x</em><sub>0</sub> = <em>a</em><sup><em>u</em></sup> mod <em>n</em> in line 2 and then repeatedly squaring the result <em>t</em> times in the <strong>for</strong> loop of lines 3–6. By induction on <em>i</em>, the sequence <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, …, <em>x</em><sub><em>t</em></sub> of values computed satisfies the equation <img alt="art" src="images/Art_P1235.jpg"/> for <em>i</em> = 0, 1, …, <em>t</em>, so that in particular <em>x</em><sub><em>t</em></sub> = <em>a</em><sup><em>n</em>–1</sup> (mod <em>n</em>). After line 4 performs a squaring step, however, the loop will terminate early if lines 5–6 detect that a nontrivial square root of 1 has just been discovered. (We’ll explain these tests shortly.) If so, the procedure stops and returns <small>TRUE</small>. Lines 7–8 return <small>TRUE</small> if the value computed for <em>x</em><sub><em>t</em></sub> = <em>a</em><sup><em>n</em>–1</sup> (mod <em>n</em>) is not equal to 1, just as the P<small>SEUDOPRIME</small> procedure returns <small>COMPOSITE</small> in this case. Line 9 returns <small>FALSE</small> if lines 6 or 8 have not returned <small>TRUE</small>.</p>
<p>The following lemma proves the correctness of W<small>ITNESS</small>.</p>
<p class="lem"><strong><em>Lemma 31.38</em></strong></p>
<p class="noindent">If W<small>ITNESS</small>(<em>a</em>, <em>n</em>) returns <small>TRUE</small>, then a proof that <em>n</em> is composite can be constructed using <em>a</em> as a witness.</p>
<p class="proof"><strong><em>Proof</em></strong>   If W<small>ITNESS</small> returns <small>TRUE</small> from line 8, it’s because line 7 determined that <em>x</em><sub><em>t</em></sub> = <em>a</em><sup><em>n</em>–1</sup> mod <em>n</em> ≠ 1. If <em>n</em> is prime, however, Fermat’s theorem (Theorem 31.31) says that <em>a</em><sup><em>n</em>–1</sup> = 1 (mod <em>n</em>) for all <img alt="art" src="images/Art_P1236.jpg"/>. Since <img alt="art" src="images/Art_P1237.jpg"/> if <em>n</em> is prime, Fermat’s theorem also says that <em>a</em><sup><em>n</em>–1</sup> = 1 (mod <em>n</em>) for all <img alt="art" src="images/Art_P1238.jpg"/>. Therefore, <em>n</em> cannot be prime, and the equation <em>a</em><sup><em>n</em>–1</sup> mod <em>n</em> ≠ 1 proves this fact.</p>
<p>If W<small>ITNESS</small> returns <small>TRUE</small> from line 6, then it has discovered that <em>x</em><sub><em>i</em>–1</sub> is a nontrivial square root of 1, modulo <em>n</em>, since we have that <em>x</em><sub><em>i</em>–1</sub> ≠ ±1 (mod <em>n</em>) yet <img alt="art" src="images/Art_P1239.jpg"/>. Corollary 31.35 on page 934 states that only if <em>n</em> is composite can there exist a nontrivial square root of 1, modulo <em>n</em>, so that demonstrating that <em>x</em><sub><em>i</em>–1</sub> is a nontrivial square root of 1, modulo <em>n</em> proves that <em>n</em> is composite.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="space-break">Thus, if the call W<small>ITNESS</small>(<em>a</em>, <em>n</em>) returns <small>TRUE</small>, then <em>n</em> is surely composite, and the witness <em>a</em>, along with the reason that the procedure returns <small>TRUE</small> (did it return from line 6 or from line 8?), provides a proof that <em>n</em> is composite.</p>
<p>Let’s explore an alternative view of the behavior of W<small>ITNESS</small> as a function of the sequence <em>X</em> = <span class="font1"><span class="font1">〈</span></span><em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, …, <em>x</em><sub><em>t</em></sub><span class="font1"><span class="font1">〉</span></span>. We’ll find this view useful later on, when we analyze the error rate of the Miller-Rabin primality test. Note that if <em>x</em><sub><em>i</em></sub> = 1 for some 0 ≤ <em>i</em> &lt; <em>t</em>, W<small>ITNESS</small> might not compute the rest of the sequence. If it were to do so, however, each value <em>x</em><sub><em>i</em>+1</sub>, <em>x</em><sub><em>i</em>+2</sub>, …, <em>x</em><sub><em>t</em></sub> would be 1, so we can consider these positions in the sequence <em>X</em> as being all 1s. There are four cases:</p>
<ol class="olnoindent" epub:type="list">
<li><em>X</em> = <span class="font1"><span class="font1">〈</span></span>…, <em>d</em><span class="font1"><span class="font1">〉</span></span>, where <em>d</em> ≠ 1: the sequence <em>X</em> does not end in 1. Return <small>TRUE</small> in line 8, since <em>a</em> is a witness to the compositeness of <em>n</em> (by Fermat’s Theorem).<a id="p948"/></li>
<li class="litop"><em>X</em> = <span class="font1"><span class="font1">〈</span></span>1, 1, …, 1<span class="font1"><span class="font1">〉</span></span>: the sequence <em>X</em> is all 1s. Return <small>FALSE</small>, since <em>a</em> is not a witness to the compositeness of <em>n</em>.</li>
<li class="litop"><em>X</em> = <span class="font1"><span class="font1">〈</span></span>…, –1, 1, …, 1<span class="font1"><span class="font1">〉</span></span>: the sequence <em>X</em> ends in 1, and the last non-1 is equal to –1. Return <small>FALSE</small>, since <em>a</em> is not a witness to the compositeness of <em>n</em>.</li>
<li class="litop"><em>X</em> = <span class="font1"><span class="font1">〈</span></span>…, <em>d</em>, 1, …, 1<span class="font1"><span class="font1">〉</span></span>, where <em>d</em> ≠ ±1: the sequence <em>X</em> ends in 1, but the last non-1 is not –1. Return <small>TRUE</small> in line 6: <em>a</em> is a witness to the compositeness of <em>n</em>, since <em>d</em> is a nontrivial square root of 1.</li></ol>
<p>Now, let’s examine the Miller-Rabin primality test based on how it uses the W<small>ITNESS</small> procedure. As before, assume that <em>n</em> is an odd integer greater than 2.</p>
<p>The procedure M<small>ILLER</small>-R<small>ABIN</small> is a probabilistic search for a proof that <em>n</em> is composite. The main loop (beginning on line 1) picks up to <em>s</em> random values of <em>a</em> from <img alt="art" src="images/Art_P1240.jpg"/>, except for 1 and <em>n</em> – 1 (line 2). If it picks a value of <em>a</em> that is a witness to the compositeness of <em>n</em>, then M<small>ILLER</small>-R<small>ABIN</small> returns <small>COMPOSITE</small> on line 4. Such a result is always correct, by the correctness of W<small>ITNESS</small>. If M<small>ILLER</small>-R<small>ABIN</small> finds no witness in <em>s</em> trials, then the procedure assumes that it found no witness because no witnesses exist, and therefore it assumes that <em>n</em> is prime. We’ll see that this result is likely to be correct if <em>s</em> is large enough, but there is still a tiny chance that the procedure could be unlucky in its choice of <em>s</em> random values of <em>a</em>, so that even though the procedure failed to find a witness, at least one witness exists.</p>
<p>To illustrate the operation of M<small>ILLER</small>-R<small>ABIN</small>, let <em>n</em> be the Carmichael number 561, so that <em>n</em> – 1 = 560 = 2<sup>4</sup> · 35, <em>t</em> = 4, and <em>u</em> = 35. If the procedure chooses <em>a</em> = 7 as a base, the column for <em>b</em> = 35 in <a href="chapter031.xhtml#Fig_31-4">Figure 31.4</a> (<a href="chapter031.xhtml#Sec_31.6">Section 31.6</a>) shows that W<small>ITNESS</small> computes <em>x</em><sub>0</sub> = <em>a</em><sup>35</sup> = 241 (mod 561). Because of how the M<small>ODULAR</small>-E<small>XPONENTIATION</small> procedure operates recursively on its parameter <em>b</em>, the first four columns in <a href="chapter031.xhtml#Fig_31-4">Figure 31.4</a> represent the factor 2<sup>4</sup> of 560—the rightmost four zeros in the binary representation of 560—reading these four zeros from right to left in the binary representation. Thus W<small>ITNESS</small> computes the sequence <em>X</em> = <span class="font1"><span class="font1">〈</span></span>241, 298, 166, 67, 1<span class="font1"><span class="font1">〉</span></span>. Then, in the last squaring step, W<small>ITNESS</small> discovers that <em>a</em><sup>280</sup> is a nontrivial square root of 1 since <em>a</em><sup>280</sup> = 67 (mod <em>n</em>) and (<em>a</em><sup>280</sup>)<sup>2</sup> = <em>a</em><sup>560</sup> = 1 (mod <em>n</em>). Therefore, <em>a</em> = 7 is a witness to the compositeness of <em>n</em>, W<small>ITNESS</small>(7, <em>n</em>) returns <small>TRUE</small>, and M<small>ILLER</small>-R<small>ABIN</small> returns <small>COMPOSITE</small>.</p>
<p>If <em>n</em> is a <em>β</em>-bit number, M<small>ILLER</small>-R<small>ABIN</small> requires <em>O</em>(<em>sβ</em>) arithmetic operations and <em>O</em>(<em>sβ</em><sup>3</sup>) bit operations, since it requires asymptotically no more work than <em>s</em> modular exponentiations.</p>
<p class="level4"><strong>Error rate of the Miller-Rabin primality test</strong></p>
<p class="noindent">If M<small>ILLER</small>-R<small>ABIN</small> returns <small>PRIME</small>, then there is a very slim chance that it has made an error. Unlike P<small>SEUDOPRIME</small>, however, the chance of error does not depend on <em>n</em>: there are no bad inputs for this procedure. Rather, it depends on the size of <em>s</em> <a id="p949"/>and the “luck of the draw” in choosing base values <em>a</em>. Moreover, since each test is more stringent than a simple check of equation (31.39), we can expect on general principles that the error rate should be small for randomly chosen integers <em>n</em>. The following theorem presents a more precise argument.</p>
<p class="theo"><strong><em>Theorem 31.39</em></strong></p>
<p class="noindent">If <em>n</em> is an odd composite number, then the number of witnesses to the compositeness of <em>n</em> is at least (<em>n</em> – 1)/2.</p>
<p class="proof"><strong><em>Proof</em></strong>   The proof shows that the number of nonwitnesses is at most (<em>n</em> – 1)/2, which implies the theorem.</p>
<p>We start by claiming that any nonwitness must be a member of <img alt="art" src="images/Art_Zastn.jpg"/>. Why? Consider any nonwitness <em>a</em>. It must satisfy <em>a</em><sup><em>n</em>–1</sup> = 1 (mod <em>n</em>) or, equivalently, <em>a</em> · <em>a</em><sup><em>n</em>−2</sup> = 1 (mod <em>n</em>). Thus the equation <em>ax</em> = 1 (mod <em>n</em>) has a solution, namely <em>a</em><sup><em>n</em>−2</sup>. By Corollary 31.21 on page 924, gcd(<em>a</em>, <em>n</em>) | 1, which in turn implies that gcd(<em>a</em>, <em>n</em>) = 1. Therefore, <em>a</em> is a member of <img alt="art" src="images/Art_Zastn.jpg"/>, and all nonwitnesses belong to <img alt="art" src="images/Art_Zastn.jpg"/>.</p>
<p>To complete the proof, we show that not only are all nonwitnesses contained in <img alt="art" src="images/Art_Zastn.jpg"/>, they are all contained in a proper subgroup <em>B</em> of <img alt="art" src="images/Art_Zastn.jpg"/> (recall that <em>B</em> is a <em>proper</em> subgroup of <img alt="art" src="images/Art_Zastn.jpg"/> when <em>B</em> is subgroup of <img alt="art" src="images/Art_Zastn.jpg"/> but <em>B</em> is not equal to <img alt="art" src="images/Art_Zastn.jpg"/>). By Corollary 31.16 on page 921, we then have <img alt="art" src="images/Art_P1241.jpg"/>. Since <img alt="art" src="images/Art_P1242.jpg"/>, we obtain |<em>B</em>| ≤ (<em>n</em> – 1)/2. Therefore, if all nonwitnesses are contained in a proper subgroup of <img alt="art" src="images/Art_Zastn.jpg"/>, then the number of nonwitnesses is at most (<em>n</em> – 1)/2, so that the number of witnesses must be at least (<em>n</em> – 1)/2.</p>
<p>To find a proper subgroup <em>B</em> of <img alt="art" src="images/Art_Zastn.jpg"/> containing all of the nonwitnesses, we consider two cases.</p>
<p><em>Case 1:</em> There exists an <img alt="art" src="images/Art_P1243.jpg"/> such that</p>
<p class="eql"><em>x</em><sup><em>n</em>–1</sup> ≠ 1 (mod <em>n</em>).</p>
<p class="noindent">In other words, <em>n</em> is not a Carmichael number. Since, as noted earlier, Carmichael numbers are extremely rare, case 1 is the more typical case (e.g., when <em>n</em> has been chosen randomly and is being tested for primality).</p>
<p>Let <img alt="art" src="images/Art_P1244.jpg"/>. The set <em>B</em> must be nonempty, since 1 ∈ <em>B</em>. The set <em>B</em> is closed under multiplication modulo <em>n</em>, and so <em>B</em> is a subgroup of <img alt="art" src="images/Art_Zastn.jpg"/> by Theorem 31.14. Every nonwitness belongs to <em>B</em>, since a nonwitness <em>a</em> satisfies <em>a</em><sup><em>n</em>–1</sup> = 1 (mod <em>n</em>). Since <img alt="art" src="images/Art_P1245.jpg"/>, we have that <em>B</em> is a proper subgroup of <img alt="art" src="images/Art_Zastn.jpg"/>.</p>
<p><em>Case 2:</em> For all <img alt="art" src="images/Art_P1246.jpg"/>,</p>
<p class="eqr"><img alt="art" src="images/Art_P1247.jpg"/></p>
<a id="p950"/>
<p class="noindent">In other words, <em>n</em> is a Carmichael number. This case is extremely rare in practice. Unlike a pseudoprimality test, however, the Miller-Rabin test can efficiently determine that Carmichael numbers are composite, as we’re about to see.</p>
<p>In this case, <em>n</em> cannot be a prime power. To see why, suppose to the contrary that <em>n</em> = <em>p</em><sup><em>e</em></sup>, where <em>p</em> is a prime and <em>e</em> &gt; 1. We derive a contradiction as follows. Since we assume that <em>n</em> is odd, <em>p</em> must also be odd. Theorem 31.32 on page 933 implies that <img alt="art" src="images/Art_Zastn.jpg"/> is a cyclic group: it contains a generator <em>g</em> such that <img alt="art" src="images/Art_P1248.jpg"/>. (The formula for <em><span class="symbolfont">ϕ</span></em>(<em>n</em>) comes from equation (31.21) on page 920.) By equation (31.40), we have <em>g</em><sup><em>n</em>–1</sup> = 1 (mod <em>n</em>). Then the discrete logarithm theorem (Theorem 31.33 on page 933, taking <em>y</em> = 0) implies that <em>n</em> – 1 = 0 (mod <em>ϕ</em> (<em>n</em>)), or</p>
<p class="eql">(<em>p</em> – 1)<em>p</em><sup><em>e</em>−1</sup> | <em>p</em><sup><em>e</em></sup> – 1.</p>
<p class="noindent">This statement is a contradiction for <em>e</em> &gt; 1, since (<em>p</em> – 1)<em>p</em><sup><em>e</em>−1</sup> is divisible by the prime <em>p</em>, but <em>p</em><sup><em>e</em></sup> – 1 is not. Thus <em>n</em> is not a prime power.</p>
<p>Since the odd composite number <em>n</em> is not a prime power, we decompose it into a product <em>n</em><sub>1</sub><em>n</em><sub>2</sub>, where <em>n</em><sub>1</sub> and <em>n</em><sub>2</sub> are odd numbers greater than 1 that are relatively prime to each other. (There may be several ways to decompose <em>n</em>, and it does not matter which one we choose. For example, if <img alt="art" src="images/Art_P1249.jpg"/>, then we can choose <img alt="art" src="images/Art_P1250.jpg"/> and <img alt="art" src="images/Art_P1251.jpg"/>.)</p>
<p>Recall that <em>t</em> and <em>u</em> are such that <em>n</em> – 1 = 2<sup><em>t</em></sup><em>u</em>, where <em>t</em> ≥ 1 and <em>u</em> is odd, and that for an input <em>a</em>, the procedure W<small>ITNESS</small> computes the sequence</p>
<p class="eql"><img alt="art" src="images/Art_P1252.jpg"/></p>
<p class="noindent">where all computations are performed modulo <em>n</em>.</p>
<p>Let us call a pair (<em>v</em>, <em>j</em>) of integers <span class="blue"><strong><em>acceptable</em></strong></span> if <img alt="art" src="images/Art_P1253.jpg"/>, and</p>
<p class="eql"><img alt="art" src="images/Art_P1254.jpg"/></p>
<p class="noindent">Acceptable pairs certainly exist, since <em>u</em> is odd. Choose <em>v</em> = <em>n</em> – 1 and <em>j</em> = 0, and let <em>u</em> = 2<em>k</em> + 1, so that <img alt="art" src="images/Art_P1255.jpg"/>. Taking this number modulo <em>n</em> gives (<em>n</em> – 1)<sup>2<em>k</em>+1</sup> = (<em>n</em> – 1)<sup>2<em>k</em></sup> · (<em>n</em> – 1) = (–1)<sup>2<em>k</em></sup> · –1 = −1 (mod <em>n</em>). Thus, (<em>n</em> – 1, 0) is an acceptable pair. Now pick the largest possible <em>j</em> such that there exists an acceptable pair (<em>v</em>, <em>j</em>), and fix <em>v</em> so that (<em>v</em>, <em>j</em>) is an acceptable pair. Let</p>
<p class="eql"><img alt="art" src="images/Art_P1256.jpg"/></p>
<p class="noindent">Since <em>B</em> is closed under multiplication modulo <em>n</em>, it is a subgroup of <img alt="art" src="images/Art_Zastn.jpg"/>. By Theorem 31.15 on page 921, therefore, |<em>B</em>| divides <img alt="art" src="images/Art_P1257.jpg"/>. Every nonwitness must be a member of <em>B</em>, since the sequence <em>X</em> produced by a nonwitness must either be all 1s or else contain a –1 no later than the <em>j</em>th position, by the maximality of <em>j</em>. <a id="p951"/>(If (<em>a</em>, <em>j</em>′) is acceptable, where <em>a</em> is a nonwitness, we must have <em>j</em>′ ≤ <em>j</em> by how we chose <em>j</em>.)</p>
<p>We now use the existence of <em>v</em> to demonstrate that there exists a <img alt="art" src="images/Art_P1258.jpg"/>, and hence that <em>B</em> is a proper subgroup of <img alt="art" src="images/Art_Zastn.jpg"/>. Since <img alt="art" src="images/Art_P1259.jpg"/>, we also have <img alt="art" src="images/Art_P1260.jpg"/> by Corollary 31.29 to the Chinese remainder theorem. By Corollary 31.28, there exists a <em>w</em> simultaneously satisfying the equations</p>
<table class="table2b">
<tr>
<td class="td2"><em>w</em></td>
<td class="td2">= <em>v</em> (mod <em>n</em><sub>1</sub>),</td>
</tr>
<tr>
<td class="td2"><em>w</em></td>
<td class="td2">= 1 (mod <em>n</em><sub>2</sub>).</td>
</tr>
</table>
<p class="noindent">Therefore,</p>
<p class="eql"><img alt="art" src="images/Art_P1261.jpg"/></p>
<p class="noindent">Corollary 31.29 gives that <img alt="art" src="images/Art_P1262.jpg"/> implies <img alt="art" src="images/Art_P1263.jpg"/> and also that <img alt="art" src="images/Art_P1264.jpg"/> implies <img alt="art" src="images/Art_P1265.jpg"/>. Hence, we conclude that <img alt="art" src="images/Art_P1266.jpg"/>, and so <em>w</em> ∉ <em>B</em>.</p>
<p>It remains to show that <img alt="art" src="images/Art_P1267.jpg"/>. We start by working separately modulo <em>n</em><sub>1</sub> and modulo <em>n</em><sub>2</sub>. Working modulo <em>n</em><sub>1</sub>, since <img alt="art" src="images/Art_P1268.jpg"/>, we have that gcd(<em>v</em>, <em>n</em>) = 1. Also, we have gcd(<em>v</em>, <em>n</em><sub>1</sub>) = 1, since if <em>v</em> does not have any common divisors with <em>n</em>, then it certainly does not have any common divisors with <em>n</em><sub>1</sub>. Since <em>w</em> = <em>v</em> (mod <em>n</em><sub>1</sub>), we see that gcd(<em>w</em>, <em>n</em><sub>1</sub>) = 1. Working modulo <em>n</em><sub>2</sub>, we have <em>w</em> = 1 (mod <em>n</em><sub>2</sub>) implies gcd(<em>w</em>, <em>n</em><sub>2</sub>) = 1 by Exercise 31.2-3. Since gcd(<em>w</em>, <em>n</em><sub>1</sub>) = 1 and gcd(<em>w</em>, <em>n</em><sub>2</sub>) = 1, Theorem 31.6 on page 908 yields gcd(<em>w</em>, <em>n</em><sub>1</sub><em>n</em><sub>2</sub>) = gcd(<em>w</em>, <em>n</em>) = 1. That is, <img alt="art" src="images/Art_P1269.jpg"/>.</p>
<p>Therefore, we have <img alt="art" src="images/Art_P1270.jpg"/>, and we can conclude in case 2 that <em>B</em>, which includes all nonwitnesses, is a proper subgroup of <img alt="art" src="images/Art_Zastn.jpg"/> and therefore has size at most (<em>n</em> – 1)/2.</p>
<p>In either case, the number of witnesses to the compositeness of <em>n</em> is at least (<em>n</em> – 1)/2.</p>
<p class="right"><span class="font1">▪</span></p>
<p class="theo"><strong><em>Theorem 31.40</em></strong></p>
<p class="noindent">For any odd integer <em>n</em> &gt; 2 and positive integer <em>s</em>, the probability that M<small>ILLER</small>-R<small>ABIN</small>(<em>n</em>, <em>s</em>) errs is at most 2<sup>–<em>s</em></sup>.</p>
<p class="proof"><strong><em>Proof</em></strong>   By Theorem 31.39, if <em>n</em> is composite, then each execution of the <strong>for</strong> loop of lines 1–4 of M<small>ILLER</small>-R<small>ABIN</small> has a probability of at least 1/2 of discovering a witness to the compositeness of <em>n</em>. M<small>ILLER</small>-R<small>ABIN</small> makes an error only if it is so unlucky as to miss discovering a witness to the compositeness of <em>n</em> on each of the <em>s</em> iterations of the main loop. The probability of such a sequence of misses is at most 2<sup>–<em>s</em></sup>.</p>
<p class="right"><span class="font1">▪</span></p>
<a id="p952"/>
<p>If <em>n</em> is prime, M<small>ILLER</small>-R<small>ABIN</small> always reports P<small>RIME</small>, and if <em>n</em> is composite, the chance that M<small>ILLER</small>-R<small>ABIN</small> reports P<small>RIME</small> is at most 2<sup>−<em>s</em></sup>.</p>
<p>When applying M<small>ILLER</small>-R<small>ABIN</small> to a large randomly chosen integer <em>n</em>, however, we need to consider as well the prior probability that <em>n</em> is prime, in order to correctly interpret M<small>ILLER</small>-R<small>ABIN</small>’s result. Suppose that we fix a bit length <em>β</em> and choose at random an integer <em>n</em> of length <em>β</em> bits to be tested for primality, so that <em>β</em> ≈ 1g <em>n</em> ≈ 1.443 ln <em>n</em>. Let <em>A</em> denote the event that <em>n</em> is prime. By the prime number theorem (Theorem 31.37), the probability that <em>n</em> is prime is approximately</p>
<table class="table2b">
<tr>
<td class="td2">Pr {<em>A</em>}</td>
<td class="td2">≈</td>
<td class="td2">1/ln <em>n</em></td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≈</td>
<td class="td2">1.443/<em>β</em>.</td>
</tr>
</table>
<p class="noindent">Now let <em>B</em> denote the event that M<small>ILLER</small>-R<small>ABIN</small> returns P<small>RIME</small>. We have that <img alt="art" src="images/Art_P1271.jpg"/> (or equivalently, that Pr{<em>B</em> | <em>A</em>} = 1) and <img alt="art" src="images/Art_P1272.jpg"/> (or equivalently, that <img alt="art" src="images/Art_P1273.jpg"/>).</p>
<p>But what is Pr{<em>A</em> | <em>B</em>}, the probability that <em>n</em> is prime, given that M<small>ILLER</small>-R<small>ABIN</small> has returned P<small>RIME</small>? By the alternate form of Bayes’s theorem (equation (C.20) on page 1189) and approximating <img alt="art" src="images/Art_P1274.jpg"/>, we have</p>
<p class="eql"><img alt="art" src="images/Art_P1275.jpg"/></p>
<p class="noindent">This probability does not exceed 1/2 until <em>s</em> exceeds 1g(ln <em>n</em> – 1). Intuitively, that many initial trials are needed just for the confidence derived from failing to find a witness to the compositeness of <em>n</em> to overcome the prior bias in favor of <em>n</em> being composite. For a number with <em>β</em> = 1024 bits, this initial testing requires about</p>
<table class="table2b">
<tr>
<td class="td2">lg(ln <em>n</em> – 1)</td>
<td class="td2">≈</td>
<td class="td2">lg(<em>β</em>/1.443)</td>
</tr>
<tr>
<td class="td2"/>
<td class="td2">≈</td>
<td class="td2">9</td>
</tr>
</table>
<p class="noindent">trials. In any case, choosing <em>s</em> = 50 should suffice for almost any imaginable application.</p>
<p>In fact, the situation is much better. If you are trying to find large primes by applying M<small>ILLER</small>-R<small>ABIN</small> to large randomly chosen odd integers, then choosing a small value of <em>s</em> (say 3) is unlikely to lead to erroneous results, though we won’t prove it here. The reason is that for a randomly chosen odd composite integer <em>n</em>, the expected number of nonwitnesses to the compositeness of <em>n</em> is likely to be considerably smaller than (<em>n</em> – 1)/2.</p>
<a id="p953"/>
<p>If the integer <em>n</em> is not chosen randomly, however, the best that can be proven is that the number of nonwitnesses is at most (<em>n</em> – 1)/4, using an improved version of Theorem 31.39. Furthermore, there do exist integers <em>n</em> for which the number of nonwitnesses is (<em>n</em> – 1)/4.</p>
<p class="level4"><strong>Exercises</strong></p>
<p class="level3"><strong><em>31.8-1</em></strong></p>
<p class="noindent">Prove that if an odd integer <em>n</em> &gt; 1 is not a prime or a prime power, then there exists a nontrivial square root of 1, modulo <em>n</em>.</p>
<p class="level3"><span class="font1">★</span> <strong><em>31.8-2</em></strong></p>
<p class="noindent">It is possible to strengthen Euler’s theorem (Theorem 31.30) slightly to the form</p>
<p class="eql"><img alt="art" src="images/Art_P1276.jpg"/></p>
<p class="noindent">where <img alt="art" src="images/Art_P1277.jpg"/> and λ(<em>n</em>) is defined by</p>
<p class="eql"><img alt="art" src="images/Art_P1278.jpg"/></p>
<p class="noindent">Prove that <em>λ</em>(<em>n</em>) | <em><span class="symbolfont">ϕ</span></em>(<em>n</em>). A composite number <em>n</em> is a Carmichael number if <em>λ</em>(<em>n</em>) | <em>n</em> – 1. The smallest Carmichael number is 561 = 3 · 11 · 17, for which <em>λ</em>(<em>n</em>) = 1cm(2, 10, 16) = 80, which divides 560. Prove that Carmichael numbers must be both “square-free” (not divisible by the square of any prime) and the product of at least three primes. (For this reason, they are not common.)</p>
<p class="level3"><strong><em>31.8-3</em></strong></p>
<p class="noindent">Prove that if <em>x</em> is a nontrivial square root of 1, modulo <em>n</em>, then gcd(<em>x</em> − 1, <em>n</em>) and gcd(<em>x</em> + 1, <em>n</em>) are both nontrivial divisors of <em>n</em>.</p>
</section>
<p class="line1"/>
<section title="Problems">
<p class="level1" id="h1-185"><strong>Problems</strong></p>
<section title="31-1 Binary gcd algorithm">
<p class="level3"><strong><em>31-1     Binary gcd algorithm</em></strong></p>
<p class="noindent">Most computers can perform the operations of subtraction, testing the parity (odd or even) of a binary integer, and halving more quickly than computing remainders. This problem investigates the <span class="blue"><strong><em>binary gcd algorithm</em></strong></span>, which avoids the remainder computations used in Euclid’s algorithm.</p>
<p class="nl"><strong><em>a.</em></strong> Prove that if <em>a</em> and <em>b</em> are both even, then gcd(<em>a</em>, <em>b</em>) = 2 · gcd(<em>a</em>/2, <em>b</em>/2).</p>
<p class="nl"><strong><em>b.</em></strong> Prove that if <em>a</em> is odd and <em>b</em> is even, then gcd(<em>a</em>, <em>b</em>) = gcd(<em>a</em>, <em>b</em>/2).</p>
<p class="nl"><strong><em>c.</em></strong> Prove that if <em>a</em> and <em>b</em> are both odd, then gcd(<em>a</em>, <em>b</em>) = gcd((<em>a</em> – <em>b</em>)/2, <em>b</em>).</p>
<a id="p954"/>
<p class="nl"><strong><em>d.</em></strong> Design an efficient binary gcd algorithm for input integers <em>a</em> and <em>b</em>, where <em>a</em> ≥ <em>b</em>, that runs in <em>O</em>(1g <em>a</em>) time. Assume that each subtraction, parity test, and halving takes unit time.</p>
</section>
<section title="31-2 Analysis of bit operations in Euclid’s algorithm">
<p class="level3"><strong><em>31-2     Analysis of bit operations in Euclid’s algorithm</em></strong></p>
<p class="nla1"><strong><em>a.</em></strong> Consider the ordinary “paper and pencil” algorithm for long division: dividing <em>a</em> by <em>b</em>, which yields a quotient <em>q</em> and remainder <em>r</em>. Show that this method requires <em>O</em>((1 + 1g <em>q</em>)1g <em>b</em>) bit operations.</p>
<p class="nl"><strong><em>b.</em></strong> Define <em>μ</em>(<em>a</em>, <em>b</em>) = (1 + 1g <em>a</em>)(1 + 1g <em>b</em>). Show that the number of bit operations performed by E<small>UCLID</small> in reducing the problem of computing gcd(<em>a</em>, <em>b</em>) to that of computing gcd(<em>b</em>, <em>a</em> mod <em>b</em>) is at most <em>c</em>(<em>μ</em>(<em>a</em>, <em>b</em>) – <em>μ</em>(<em>b</em>, <em>a</em> mod <em>b</em>)) for some sufficiently large constant <em>c</em> &gt; 0.</p>
<p class="nl"><strong><em>c.</em></strong> Show that E<small>UCLID</small>(<em>a</em>, <em>b</em>) requires <em>O</em>(<em>μ</em>(<em>a</em>, <em>b</em>)) bit operations in general and <em>O</em>(<em>β</em><sup>2</sup>) bit operations when applied to two <em>β</em>-bit inputs.</p>
</section>
<section title="31-3 Three algorithms for Fibonacci numbers">
<p class="level3"><strong><em>31-3     Three algorithms for Fibonacci numbers</em></strong></p>
<p class="noindent">This problem compares the efficiency of three methods for computing the <em>n</em>th Fibonacci number <em>F</em><sub><em>n</em></sub>, given <em>n</em>. Assume that the cost of adding, subtracting, or multiplying two numbers is <em>O</em>(1), independent of the size of the numbers.</p>
<p class="nl"><strong><em>a.</em></strong> Show that the running time of the straightforward recursive method for computing <em>F</em><sub><em>n</em></sub> based on recurrence (3.31) on page 69 is exponential in <em>n</em>. (See, for example, the F<small>IB</small> procedure on page 751.)</p>
<p class="nl"><strong><em>b.</em></strong> Show how to compute <em>F</em><sub><em>n</em></sub> in <em>O</em>(<em>n</em>) time using memoization.</p>
<p class="nl"><strong><em>c.</em></strong> Show how to compute <em>F</em><sub><em>n</em></sub> in <em>O</em>(1g <em>n</em>) time using only integer addition and multiplication. (<em>Hint:</em> Consider the matrix <img alt="art" src="images/Art_P1279.jpg"/> and its powers.)</p>
<p class="nl"><strong><em>d.</em></strong> Assume now that adding two <em>β</em>-bit numbers takes Θ(<em>β</em>) time and that multiplying two <em>β</em>-bit numbers takes Θ(<em>β</em><sup>2</sup>) time. What is the running time of these three methods under this more reasonable cost measure for the elementary arithmetic operations?</p>
</section>
<section title="31-4 Quadratic residues">
<p class="level2"><strong><em>31-4     Quadratic residues</em></strong></p>
<p class="noindent">Let <em>p</em> be an odd prime. A number <img alt="art" src="images/Art_P1280.jpg"/> is a <span class="blue"><strong><em>quadratic residue</em></strong></span> modulo <em>p</em>, if the equation <em>x</em><sup>2</sup> = <em>a</em> (mod <em>p</em>) has a solution for the unknown <em>x</em>.</p>
<p class="nl"><strong><em>a.</em></strong> Show that there are exactly (<em>p</em> – 1)/2 quadratic residues, modulo <em>p</em>.</p>
<a id="p955"/>
<p class="nl"><strong><em>b.</em></strong> If <em>p</em> is prime, we define the <span class="blue"><strong><em>Legendre symbol</em></strong></span> <img alt="art" src="images/Art_P1281.jpg"/>, for <img alt="art" src="images/Art_P1282.jpg"/>, to be 1 if <em>a</em> is a quadratic residue, modulo <em>p</em>, and –1 otherwise. Prove that if <img alt="art" src="images/Art_P1283.jpg"/>, then</p>
<p class="eqnl"><img alt="art" src="images/Art_P1284.jpg"/></p>
<p class="nl-parat">Give an efficient algorithm that determines whether a given number <em>a</em> is a quadratic residue, modulo <em>p</em>. Analyze the efficiency of your algorithm.</p>
<p class="nl"><strong><em>c.</em></strong> Prove that if <em>p</em> is a prime of the form 4<em>k</em> + 3 and <em>a</em> is a quadratic residue in <img alt="art" src="images/Art_P1285.jpg"/>, then <em>a</em><sup><em>k</em>+1</sup> mod <em>p</em> is a square root of <em>a</em>, modulo <em>p</em>. How much time is required to find the square root of a quadratic residue <em>a</em>, modulo <em>p</em>?</p>
<p class="nl"><strong><em>d.</em></strong> Describe an efficient randomized algorithm for finding a nonquadratic residue, modulo an arbitrary prime <em>p</em>, that is, a member of <img alt="art" src="images/Art_Zastp.jpg"/> that is not a quadratic residue. How many arithmetic operations does your algorithm require on average?</p>
</section>
</section>
<p class="line1"/>
<section title="Chapter notes">
<p class="level1" id="h1-186"><strong>Chapter notes</strong></p>
<p class="noindent">Knuth [<a epub:type="noteref" href="bibliography001.xhtml#endnote_260">260</a>] contains a good discussion of algorithms for finding the greatest common divisor, as well as other basic number-theoretic algorithms. Dixon [<a epub:type="noteref" href="bibliography001.xhtml#endnote_121">121</a>] gives an overview of factorization and primality testing. Bach [<a epub:type="noteref" href="bibliography001.xhtml#endnote_33">33</a>], Riesel [<a epub:type="noteref" href="bibliography001.xhtml#endnote_378">378</a>], and Bach and Shallit [<a epub:type="noteref" href="bibliography001.xhtml#endnote_34">34</a>] provide overviews of the basics of computational number theory; Shoup [<a epub:type="noteref" href="bibliography001.xhtml#endnote_411">411</a>] provides a more recent survey. The conference proceedings edited by Pomerance [<a epub:type="noteref" href="bibliography001.xhtml#endnote_362">362</a>] contains several excellent survey articles.</p>
<p>Knuth [<a epub:type="noteref" href="bibliography001.xhtml#endnote_260">260</a>] discusses the origin of Euclid’s algorithm. It appears in Book 7, Propositions 1 and 2, of the Greek mathematician Euclid’s <em>Elements</em>, which was written around 300 <small>B</small>.<small>C</small>.<small>E</small>. Euclid’s description may have been derived from an algorithm due to Eudoxus around 375 <small>B</small>.<small>C</small>.<small>E</small>. Euclid’s algorithm may hold the honor of being the oldest nontrivial algorithm, rivaled only by an algorithm for multiplication known to the ancient Egyptians. Shallit [<a epub:type="noteref" href="bibliography001.xhtml#endnote_407">407</a>] chronicles the history of the analysis of Euclid’s algorithm.</p>
<p>Knuth attributes a special case of the Chinese remainder theorem (Theorem 31.27) to the Chinese mathematician Sun-Ts<span class="font1">ŭ</span>, who lived sometime between 200 <small>B</small>.<small>C</small>.<small>E</small>. and 200 <small>C</small>.<small>E</small>.—the date is quite uncertain. The same special case was given by the Greek mathematician Nichomachus around 100 <small>C</small>.<small>E</small>. It was generalized by Qin Jiushao in 1247. The Chinese remainder theorem was finally stated and proved in its full generality by L. Euler in 1734.</p>
<p>The randomized primality-testing algorithm presented here is due to Miller [<a epub:type="noteref" href="bibliography001.xhtml#endnote_327">327</a>] and Rabin [<a epub:type="noteref" href="bibliography001.xhtml#endnote_373">373</a>] and is the fastest randomized primality-testing algorithm known, <a id="p956"/>to within constant factors. The proof of Theorem 31.40 is a slight adaptation of one suggested by Bach [<a epub:type="noteref" href="bibliography001.xhtml#endnote_32">32</a>]. A proof of a stronger result for M<small>ILLER</small>-R<small>ABIN</small> was given by Monier [<a epub:type="noteref" href="bibliography001.xhtml#endnote_332">332</a>, <a epub:type="noteref" href="bibliography001.xhtml#endnote_333">333</a>]. For many years primality-testing was the classic example of a problem where randomization appeared to be necessary to obtain an efficient (polynomial-time) algorithm. In 2002, however, Agrawal, Kayal, and Saxena [<a epub:type="noteref" href="bibliography001.xhtml#endnote_4">4</a>] surprised everyone with their deterministic polynomial-time primality-testing algorithm. Until then, the fastest deterministic primality testing algorithm known, due to Cohen and Lenstra [<a epub:type="noteref" href="bibliography001.xhtml#endnote_97">97</a>], ran in (1g <em>n</em>)<sup><em>O</em>(1g1g1g <em>n</em>)</sup> time on input <em>n</em>, which is just slightly superpolynomial. Nonetheless, for practical purposes, randomized primality-testing algorithms remain more efficient and are generally preferred.</p>
<p>Beauchemin, Brassard, Crépeau, Goutier, and Pomerance [<a epub:type="noteref" href="bibliography001.xhtml#endnote_40">40</a>] nicely discuss the problem of finding large “random” primes.</p>
<p>The concept of a public-key cryptosystem is due to Diffie and Hellman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_115">115</a>]. The RSA cryptosystem was proposed in 1977 by Rivest, Shamir, and Adleman [<a epub:type="noteref" href="bibliography001.xhtml#endnote_380">380</a>]. Since then, the field of cryptography has blossomed. Our understanding of the RSA cryptosystem has deepened, and modern implementations use significant refinements of the basic techniques presented here. In addition, many new techniques have been developed for proving cryptosystems to be secure. For example, Goldwasser and Micali [<a epub:type="noteref" href="bibliography001.xhtml#endnote_190">190</a>] show that randomization can be an effective tool in the design of secure public-key encryption schemes. For signature schemes, Goldwasser, Micali, and Rivest [<a epub:type="noteref" href="bibliography001.xhtml#endnote_191">191</a>] present a digital-signature scheme for which every conceivable type of forgery is provably as difficult as factoring. Katz and Lindell [<a epub:type="noteref" href="bibliography001.xhtml#endnote_253">253</a>] provide an overview of modern cryptography.</p>
<p>The best algorithms for factoring large numbers have a running time that grows roughly exponentially with the cube root of the length of the number <em>n</em> to be factored. The general number-field sieve factoring algorithm (as developed by Buhler, Lenstra, and Pomerance [<a epub:type="noteref" href="bibliography001.xhtml#endnote_77">77</a>] as an extension of the ideas in the number-field sieve factoring algorithm by Pollard [<a epub:type="noteref" href="bibliography001.xhtml#endnote_360">360</a>] and Lenstra et al. [<a epub:type="noteref" href="bibliography001.xhtml#endnote_295">295</a>] and refined by Coppersmith [<a epub:type="noteref" href="bibliography001.xhtml#endnote_102">102</a>] and others) is perhaps the most efficient such algorithm in general for large inputs. Although it is difficult to give a rigorous analysis of this algorithm, under reasonable assumptions we can derive a running-time estimate of <em>L</em>(1/3, <em>n</em>)<sup>1.902+<em>o</em>(1)</sup>, where <img alt="art" src="images/Art_P1286.jpg"/>.</p>
<p>The elliptic-curve method due to Lenstra [<a epub:type="noteref" href="bibliography001.xhtml#endnote_296">296</a>] may be more effective for some inputs than the number-field sieve method, since it can find a small prime factor <em>p</em> quite quickly. With this method, the time to find <em>p</em> is estimated to be <img alt="art" src="images/Art_P1287.jpg"/>.</p>
</section>
</section>
</div>
</body>
</html>