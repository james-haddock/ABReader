<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" xml:lang="en-us" lang="en-us">
  <head>
    <title>Clean Architecture</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="h2f" id="ch8"><a id="page_69" class="calibre3"></a><span class="gray">8</span><br class="calibre12"/>OCP: T<small class="calibre7">HE</small> O<small class="calibre7">PEN</small>-C<small class="calibre7">LOSED</small> P<small class="calibre7">RINCIPLE</small></h2>
<div class="image1"><img src="../images/00028.jpeg" alt="Image" class="calibre2"/></div>
<p class="noindent1"><a id="page_70"></a>The Open-Closed Principle (OCP) was coined in 1988 by Bertrand Meyer.<sup class="calibre10"><a id="ch8fn-1" href="part0020.html#ch8fn1">1</a></sup> It says:</p>
<p class="blockquote"><em class="calibre9">A software artifact should be open for extension but closed for modification.</em></p>
<p class="noindent1">In other words, the behavior of a software artifact ought to be extendible, without having to modify that artifact.</p>
<p class="noindent1">This, of course, is the most fundamental reason that we study software architecture. Clearly, if simple extensions to the requirements force massive changes to the software, then the architects of that software system have engaged in a spectacular failure.</p>
<p class="noindent1">Most students of software design recognize the OCP as a principle that guides them in the design of classes and modules. But the principle takes on even greater significance when we consider the level of architectural components.</p>
<p class="noindent1">A thought experiment will make this clear.</p>
<h3 class="h1" id="toclev_35">A T<small class="calibre13">HOUGHT</small> E<small class="calibre13">XPERIMENT</small></h3>
<p class="noindent1">Imagine, for a moment, that we have a system that displays a financial summary on a web page. The data on the page is scrollable, and negative numbers are rendered in red.</p>
<p class="noindent1">Now imagine that the stakeholders ask that this same information be turned into a report to be printed on a black-and-white printer. The report should be properly paginated, with appropriate page headers, page footers, and column labels. Negative numbers should be surrounded by parentheses.</p>
<p class="noindent1">Clearly, some new code must be written. But how much old code will have to change?</p>
<p class="noindent1"><a id="page_71"></a>A good software architecture would reduce the amount of changed code to the barest minimum. Ideally, zero.</p>
<p class="noindent1">How? By properly separating the things that change for different reasons (the Single Responsibility Principle), and then organizing the dependencies between those things properly (the Dependency Inversion Principle).</p>
<p class="noindent1">By applying the SRP, we might come up with the data-flow view shown in <a href="part0020.html#ch8fig1">Figure 8.1</a>. Some analysis procedure inspects the financial data and produces reportable data, which is then formatted appropriately by the two reporter processes.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00029.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch8fig1"></a><strong class="calibre8">Figure 8.1</strong> Applying the SRP</p>
</div>
<p class="noindent1">The essential insight here is that generating the report involves two separate responsibilities: the calculation of the reported data, and the presentation of that data into a web- and printer-friendly form.</p>
<p class="noindent1">Having made this separation, we need to organize the source code dependencies to ensure that changes to one of those responsibilities do not cause changes in the other. Also, the new organization should ensure that the behavior can be extended without undo modification.</p>
<p class="noindent1">We accomplish this by partitioning the processes into classes, and separating those classes into components, as shown by the double lines in the diagram in <a href="part0020.html#ch8fig2">Figure 8.2</a>. In this figure, the component at the upper left is the <em class="calibre9">Controller</em>. At the upper right, we have the <em class="calibre9">Interactor</em>. At the lower right, there is the <em class="calibre9">Database</em>. Finally, at the lower left, there are four components that represent the <em class="calibre9">Presenters</em> and the <em class="calibre9">Views</em>.</p>
<div class="fig-heading">
<div class="image1"><a id="page_72"></a><img src="../images/00030.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch8fig2"></a><strong class="calibre8">Figure 8.2</strong> Partitioning the processes into classes and separating the classes into components</p>
</div>
<p class="noindent1">Classes marked with <code class="calibre11">&lt;I&gt;</code> are interfaces; those marked with <code class="calibre11">&lt;DS&gt;</code> are data structures. Open arrowheads are <em class="calibre9">using</em> relationships. Closed arrowheads are <em class="calibre9">implements</em> or <em class="calibre9">inheritance</em> relationships.</p>
<p class="noindent1">The first thing to notice is that all the dependencies are <em class="calibre9">source code</em> dependencies. An arrow pointing from class A to class B means that the source code of class A mentions the name of class B, but class B mentions nothing about class A. Thus, in <a href="part0020.html#ch8fig2">Figure 8.2</a>, <code class="calibre11">FinancialDataMapper</code> knows about <code class="calibre11">FinancialDataGateway</code> through an <em class="calibre9">implements</em> relationship, but <code class="calibre11">FinancialGateway</code> knows nothing at all about <code class="calibre11">FinancialDataMapper</code>.</p>
<p class="noindent1">The next thing to notice is that each double line is crossed <em class="calibre9">in one direction only</em>. This means that all component relationships are unidirectional, as <a id="page_73"></a>shown in the component graph in <a href="part0020.html#ch8fig3">Figure 8.3</a>. These arrows point toward the components that we want to protect from change.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00031.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch8fig3"></a><strong class="calibre8">Figure 8.3</strong> The component relationships are unidirectional</p>
</div>
<p class="noindent1">Let me say that again: If component A should be protected from changes in component B, then component B should depend on component A.</p>
<p class="noindent1">We want to protect the <em class="calibre9">Controller</em> from changes in the <em class="calibre9">Presenters</em>. We want to protect the <em class="calibre9">Presenters</em> from changes in the <em class="calibre9">Views</em>. We want to protect the <em class="calibre9">Interactor</em> from changes in—well, <em class="calibre9">anything</em>.</p>
<p class="noindent1">The <em class="calibre9">Interactor</em> is in the position that best conforms to the OCP. Changes to the <em class="calibre9">Database</em>, or the <em class="calibre9">Controller</em>, or the <em class="calibre9">Presenters</em>, or the <em class="calibre9">Views</em>, will have no impact on the <em class="calibre9">Interactor</em>.</p>
<p class="noindent1">Why should the <em class="calibre9">Interactor</em> hold such a privileged position? Because it contains the business rules. The <em class="calibre9">Interactor</em> contains the highest-level policies <a id="page_74"></a>of the application. All the other components are dealing with peripheral concerns. The <em class="calibre9">Interactor</em> deals with the central concern.</p>
<p class="noindent1">Even though the <em class="calibre9">Controller</em> is peripheral to the <em class="calibre9">Interactor</em>, it is nevertheless central to the <em class="calibre9">Presenters</em> and <em class="calibre9">Views</em>. And while the <em class="calibre9">Presenters</em> might be peripheral to the <em class="calibre9">Controller</em>, they are central to the <em class="calibre9">Views</em>.</p>
<p class="noindent1">Notice how this creates a hierarchy of protection based on the notion of “level.” <em class="calibre9">Interactors</em> are the highest-level concept, so they are the most protected. <em class="calibre9">Views</em> are among the lowest-level concepts, so they are the least protected. <em class="calibre9">Presenters</em> are higher level than <em class="calibre9">Views</em>, but lower level than the <em class="calibre9">Controller</em> or the <em class="calibre9">Interactor</em>.</p>
<p class="noindent1">This is how the OCP works at the architectural level. Architects separate functionality based on how, why, and when it changes, and then organize that separated functionality into a hierarchy of components. Higher-level components in that hierarchy are protected from the changes made to lower-level components.</p>
<h3 class="h1" id="toclev_36">D<small class="calibre13">IRECTIONAL</small> C<small class="calibre13">ONTROL</small></h3>
<p class="noindent1">If you recoiled in horror from the class design shown earlier, look again. Much of the complexity in that diagram was intended to make sure that the dependencies between the components pointed in the correct direction.</p>
<p class="noindent1">For example, the <code class="calibre11">FinancialDataGateway</code> interface between the <code class="calibre11">FinancialReportGenerator</code> and the <code class="calibre11">FinancialDataMapper</code> exists to invert the dependency that would otherwise have pointed from the <em class="calibre9">Interactor</em> component to the <em class="calibre9">Database</em> component. The same is true of the <code class="calibre11">FinancialReportPresenter</code> interface, and the two <em class="calibre9">View</em> interfaces.</p>
<h3 class="h1" id="toclev_37">I<small class="calibre13">NFORMATION</small> H<small class="calibre13">IDING</small></h3>
<p class="noindent1">The <code class="calibre11">FinancialReportRequester</code> interface serves a different purpose. It is there to protect the <code class="calibre11">FinancialReportController</code> from knowing too much <a id="page_75"></a>about the internals of the <em class="calibre9">Interactor</em>. If that interface were not there, then the <em class="calibre9">Controller</em> would have transitive dependencies on the <code class="calibre11">FinancialEntities</code>.</p>
<p class="noindent1">Transitive dependencies are a violation of the general principle that software entities should not depend on things they don’t directly use. We’ll encounter that principle again when we talk about the Interface Segregation Principle and the Common Reuse Principle.</p>
<p class="noindent1">So, even though our first priority is to protect the <em class="calibre9">Interactor</em> from changes to the <em class="calibre9">Controller</em>, we also want to protect the <em class="calibre9">Controller</em> from changes to the <em class="calibre9">Interactor</em> by hiding the internals of the <em class="calibre9">Interactor</em>.</p>
<h3 class="h1" id="toclev_38">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The OCP is one of the driving forces behind the architecture of systems. The goal is to make the system easy to extend without incurring a high impact of change. This goal is accomplished by partitioning the system into components, and arranging those components into a dependency hierarchy that protects higher-level components from changes in lower-level components.<a id="page_76"></a></p>
<p class="fn"><a id="ch8fn1" href="part0020.html#ch8fn-1">1</a>. Bertrand Meyer. <em class="calibre9">Object Oriented Software Construction</em>, Prentice Hall, 1988, p. 23.</p>
</body></html>
