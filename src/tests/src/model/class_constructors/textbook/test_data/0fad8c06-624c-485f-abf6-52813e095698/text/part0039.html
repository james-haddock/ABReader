<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" xml:lang="en-us" lang="en-us">
  <head>
    <title>Clean Architecture</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="h2f" id="ch25"><a id="page_221" class="calibre3"></a><span class="gray">25</span><br class="calibre12"/>L<small class="calibre7">AYERS AND</small> B<small class="calibre7">OUNDARIES</small></h2>
<div class="image1"><img src="../images/00089.jpeg" alt="Image" class="calibre2"/></div>
<p class="noindent1"><a id="page_222"></a>It is easy to think of systems as being composed of three components: UI, business rules, and database. For some simple systems, this is sufficient. For most systems, though, the number of components is larger than that.</p>
<p class="noindent1">Consider, for example, a simple computer game. It is easy to imagine the three components. The UI handles all messages from the player to the game rules. The game rules store the state of the game in some kind of persistent data structure. But is that all there is?</p>
<h3 class="h1" id="toclev_127">H<small class="calibre13">UNT THE</small> W<small class="calibre13">UMPUS</small></h3>
<p class="noindent1">Let’s put some flesh on these bones. Let’s assume that the game is the venerable Hunt the Wumpus adventure game from 1972. This text-based game uses very simple commands like GO EAST and SHOOT WEST. The player enters a command, and the computer responds with what the player sees, smells, hears, and experiences. The player is hunting for a Wumpus in a system of caverns, and must avoid traps, pits, and other dangers lying in wait. If you are interested, the rules of the game are easy to find on the web.</p>
<p class="noindent1">Let’s assume that we’ll keep the text-based UI, but decouple it from the game rules so that our version can use different languages in different markets. The game rules will communicate with the UI component using a language-independent API, and the UI will translate the API into the appropriate human language.</p>
<p class="noindent1">If the source code dependencies are properly managed, as shown in <a href="part0039.html#ch25fig1">Figure 25.1</a>, then any number of UI components can reuse the same game rules. The game rules do not know, nor do they care, which human language is being used.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00090.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch25fig1"></a><strong class="calibre8">Figure 25.1</strong> Any number of UI components can reuse the game rules</p>
</div>
<p class="noindent1"><a id="page_223"></a>Let’s also assume that the state of the game is maintained on some persistent store—perhaps in flash, or perhaps in the cloud, or maybe just in RAM. In any of those cases, we don’t want the game rules to know the details. So, again, we’ll create an API that the game rules can use to communicate with the data storage component.</p>
<p class="noindent1">We don’t want the game rules to know anything about the different kinds of data storage, so the dependencies have to be properly directed following the Dependency Rule, as shown in <a href="part0039.html#ch25fig2">Figure 25.2</a>.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00091.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch25fig2"></a><strong class="calibre8">Figure 25.2</strong> Following the Dependency Rule</p>
</div>
<h3 class="h1" id="toclev_128">C<small class="calibre13">LEAN</small> A<small class="calibre13">RCHITECTURE</small>?</h3>
<p class="noindent1">It should be clear that we could easily apply the clean architecture approach in this context,<sup class="calibre10"><a id="ch25fn1"></a><a href="part0039.html#ch25fn-1">1</a></sup> with all the use cases, boundaries, entities, and corresponding data structures. But have we really found all the significant architectural boundaries?</p>
<p class="noindent1">For example, language is not the only axis of change for the UI. We also might want to vary the mechanism by which we communicate the text. For example, we might want to use a normal shell window, or text messages, or a chat application. There are many different possibilities.</p>
<p class="noindent1">That means that there is a potential architectural boundary defined by this axis of change. Perhaps we should construct an API that crosses that boundary and isolates the language from the communications mechanism; that idea is illustrated in <a href="part0039.html#ch25fig3">Figure 25.3</a>.</p>
<div class="fig-heading">
<div class="image1"><a id="page_224"></a><img src="../images/00092.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch25fig3"></a><strong class="calibre8">Figure 25.3</strong> The revised diagram</p>
</div>
<p class="noindent1">The diagram in <a href="part0039.html#ch25fig3">Figure 25.3</a> has gotten a little complicated, but should contain no surprises. The dashed outlines indicate abstract components that define an API that is implemented by the components above or below them. For example, the <code class="calibre11">Language</code> API is implemented by <code class="calibre11">English</code> and <code class="calibre11">Spanish</code>.</p>
<p class="noindent1"><code class="calibre11">GameRules</code> communicates with <code class="calibre11">Language</code> through an API that <code class="calibre11">GameRules</code> defines and <code class="calibre11">Language</code> implements. <code class="calibre11">Language</code> communicates with <code class="calibre11">TextDelivery</code> using an API that <code class="calibre11">Language</code> defines but <code class="calibre11">TextDelivery</code> implements. The API is defined and owned by the user, rather than by the implementer.</p>
<p class="noindent1">If we were to look inside <code class="calibre11">GameRules</code>, we would find polymorphic <code class="calibre11">Boundary</code> interfaces used by the code inside <code class="calibre11">GameRules</code> and implemented by the code inside the <code class="calibre11">Language</code> component. We would also find polymorphic <code class="calibre11">Boundary</code> interfaces used by <code class="calibre11">Language</code> and implemented by code inside <code class="calibre11">GameRules</code>.</p>
<p class="noindent1">If we were to look inside of <code class="calibre11">Language</code>, we would find the same thing: Polymorphic <code class="calibre11">Boundary</code> interfaces implemented by the code inside <code class="calibre11">TextDelivery</code>, and polymorphic <code class="calibre11">Boundary</code> interfaces used by <code class="calibre11">TextDelivery</code> and implemented by <code class="calibre11">Language</code>.</p>
<p class="noindent1">In each case, the API defined by those <code class="calibre11">Boundary</code> interfaces is owned by the upstream component.</p>
<p class="noindent1"><a id="page_225"></a>The variations, such as <code class="calibre11">English</code>, <code class="calibre11">SMS</code>, and <code class="calibre11">CloudData</code>, are provided by polymorphic interfaces defined in the abstract API component, and implemented by the concrete components that serve them. For example, we would expect polymorphic interfaces defined in <code class="calibre11">Language</code> to be implemented by <code class="calibre11">English</code> and <code class="calibre11">Spanish</code>.</p>
<p class="noindent1">We can simplify this diagram by eliminating all the variations and focusing on just the API components. <a href="part0039.html#ch25fig4">Figure 25.4</a> shows this diagram.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00093.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch25fig4"></a><strong class="calibre8">Figure 25.4</strong> Simplified diagram</p>
</div>
<p class="noindent1">Notice that the diagram is oriented in <a href="part0039.html#ch25fig4">Figure 25.4</a> so that all the arrows point up. This puts <code class="calibre11">GameRules</code> at the top. This orientation makes sense because <code class="calibre11">GameRules</code> is the component that contains the highest-level policies.</p>
<p class="noindent1">Consider the direction of information flow. All input comes from the user through the <code class="calibre11">TextDelivery</code> component at the bottom left. That information rises through the <code class="calibre11">Language</code> component, getting translated into commands to <code class="calibre11">GameRules</code>. <code class="calibre11">GameRules</code> processes the user input and sends appropriate data down to <code class="calibre11">DataStorage</code> at the lower right.</p>
<p class="noindent1"><a id="page_226"></a><code class="calibre11">GameRules</code> then sends output back down to <code class="calibre11">Language</code>, which translates the API back to the appropriate language and then delivers that language to the user through <code class="calibre11">TextDelivery</code>.</p>
<p class="noindent1">This organization effectively divides the flow of data into two streams.<sup class="calibre10"><a id="ch25fn2"></a><a href="part0039.html#ch25fn-2">2</a></sup> The stream on the left is concerned with communicating with the user, and the stream on the right is concerned with data persistence. Both streams meet at the top<sup class="calibre10"><a id="ch25fn3"></a><a href="part0039.html#ch25fn-3">3</a></sup> at <code class="calibre11">GameRules</code>, which is the ultimate processor of the data that goes through both streams.</p>
<h3 class="h1" id="toclev_129">C<small class="calibre13">ROSSING THE</small> S<small class="calibre13">TREAMS</small></h3>
<p class="noindent1">Are there always two data streams as in this example? No, not at all. Imagine that we would like to play Hunt the Wumpus on the net with multiple players. In this case, we would need a network component, like that shown in <a href="part0039.html#ch25fig5">Figure 25.5</a>. This organization divides the data flow into three streams, all controlled by the <code class="calibre11">GameRules</code>.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00094.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch25fig5"></a><strong class="calibre8">Figure 25.5</strong> Adding a network component</p>
</div>
<p class="noindent1">So, as systems become more complex, the component structure may split into many such streams.</p>
<h3 class="h1" id="toclev_130"><a id="page_227" class="calibre3"></a>S<small class="calibre13">PLITTING THE</small> S<small class="calibre13">TREAMS</small></h3>
<p class="noindent1">At this point you may be thinking that all the streams eventually meet at the top in a single component. If only life were so simple! The reality, of course, is much more complex.</p>
<p class="noindent1">Consider the <code class="calibre11">GameRules</code> component for Hunt the Wumpus. Part of the game rules deal with the mechanics of the map. They know how the caverns are connected, and which objects are located in each cavern. They know how to move the player from cavern to cavern, and how to determine the events that the player must deal with.</p>
<p class="noindent1">But there is another set of policies at an even higher level—policies that know the health of the player, and the cost or benefit of a particular event. These policies could cause the player to gradually lose health, or to gain health by discovering food. The lower-level mechanics policy would declare events to this higher-level policy, such as <code class="calibre11">FoundFood</code> or <code class="calibre11">FellInPit</code>. The higher-level policy would then manage the state of the player (as shown in <a href="part0039.html#ch25fig6">Figure 25.6</a>). Eventually that policy would decide whether the player wins or loses.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00095.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch25fig6"></a><strong class="calibre8">Figure 25.6</strong> The higher-level policy manages the player</p>
</div>
<p class="noindent1"><a id="page_228"></a>Is this an architectural boundary? Do we need an API that separates <code class="calibre11">MoveManagement</code> from <code class="calibre11">PlayerManagement</code>? Well, let’s make this a bit more interesting and add micro-services.</p>
<p class="noindent1">Let’s assume that we’ve got a massive multiplayer version of Hunt the Wumpus. <code class="calibre11">MoveManagement</code> is handled locally within the player’s computer, but <code class="calibre11">PlayerManagement</code> is handled by a server. <code class="calibre11">PlayerManagement</code> offers a micro-service API to all the connected <code class="calibre11">MoveManagement</code> components.</p>
<p class="noindent1">The diagram in <a href="part0039.html#ch25fig7">Figure 25.7</a> depicts this scenario in a somewhat abbreviated fashion. The <code class="calibre11">Network</code> elements are a bit more complex than depicted—but you can probably still get the idea. A full-fledged architectural boundary exists between <code class="calibre11">MoveManagement</code> and <code class="calibre11">PlayerManagement</code> in this case.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00096.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch25fig7"></a><strong class="calibre8">Figure 25.7</strong> Adding a micro-service API</p>
</div>
<h3 class="h1" id="toclev_131">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">What does all this mean? Why have I taken this absurdly simply program, which could be implemented in 200 lines of Kornshell, and extrapolated it out with all these crazy architectural boundaries?</p>
<p class="noindent1">This example is intended to show that architectural boundaries exist everywhere. We, as architects, must be careful to recognize when they are needed. We also have to be aware that such boundaries, when fully implemented, are expensive. <a id="page_229"></a>At the same time, we have to recognize that when such boundaries are ignored, they are very expensive to add in later—even in the presence of comprehensive test-suites and refactoring discipline.</p>
<p class="noindent1">So what do we do, we architects? The answer is dissatisfying. On the one hand, some very smart people have told us, over the years, that we should not anticipate the need for abstraction. This is the philosophy of YAGNI: “You aren’t going to need it.” There is wisdom in this message, since over-engineering is often much worse than under-engineering. On the other hand, when you discover that you truly do need an architectural boundary where none exists, the costs and risks can be very high to add such a boundary.</p>
<p class="noindent1">So there you have it. O Software Architect, you must see the future. You must guess—intelligently. You must weigh the costs and determine where the architectural boundaries lie, and which should be fully implemented, and which should be partially implemented, and which should be ignored.</p>
<p class="noindent1">But this is not a one-time decision. You don’t simply decide at the start of a project which boundaries to implement and which to ignore. Rather, you <em class="calibre9">watch</em>. You pay attention as the system evolves. You note where boundaries may be required, and then carefully watch for the first inkling of friction because those boundaries don’t exist.</p>
<p class="noindent1">At that point, you weigh the costs of implementing those boundaries versus the cost of ignoring them—and you review that decision frequently. Your goal is to implement the boundaries right at the inflection point where the cost of implementing becomes less than the cost of ignoring.</p>
<p class="noindent1">It takes a watchful eye.<a id="page_230"></a></p>
<p class="fn"><a id="ch25fn-1"></a><a href="part0039.html#ch25fn1">1</a>. It should be just as clear that we would not apply the clean architecture approach to something as trivial as this game. After all, the entire program can probably be written in 200 lines of code or less. In this case, we’re using a simple program as a proxy for a much larger system with significant architectural boundaries.</p>
<p class="fn"><a id="ch25fn-2"></a><a href="part0039.html#ch25fn2">2</a>. If you are confused by the direction of the arrows, remember that they point in the direction of source code dependencies, not in the direction of data flow.</p>
<p class="fn"><a id="ch25fn-3"></a><a href="part0039.html#ch25fn3">3</a>. In days long past, we would have called that top component the Central Transform. <em class="calibre9">See Practical Guide to Structured Systems Design</em>, 2nd ed., Meilir Page-Jones, 1988.</p>
</body></html>
