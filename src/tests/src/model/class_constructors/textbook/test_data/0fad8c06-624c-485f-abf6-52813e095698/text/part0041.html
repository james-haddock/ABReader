<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" xml:lang="en-us" lang="en-us">
  <head>
    <title>Clean Architecture</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="h2f" id="ch27"><a id="page_239" class="calibre3"></a><span class="gray">27</span><br class="calibre12"/>S<small class="calibre7">ERVICES:</small> G<small class="calibre7">REAT AND</small> S<small class="calibre7">MALL</small></h2>
<div class="image1"><img src="../images/00098.jpeg" alt="Image" class="calibre2"/></div>
<p class="noindent1">Service-oriented “architectures” and micro-service “architectures” have become very popular of late. The reasons for their current popularity include the following:</p>
<p class="indenthangingb">• Services seem to be strongly decoupled from each other. As we shall see, this is only partially true.</p>
<p class="indenthangingb">• Services appear to support independence of development and deployment. Again, as we shall see, this is only partially true.</p>
<h3 class="h1" id="toclev_134"><a id="page_240" class="calibre3"></a>S<small class="calibre13">ERVICE</small> A<small class="calibre13">RCHITECTURE</small>?</h3>
<p class="noindent1">First, let’s consider the notion that using services, by their nature, is an architecture. This is patently untrue. The architecture of a system is defined by boundaries that separate high-level policy from low-level detail and follow the Dependency Rule. Services that simply separate application behaviors are little more than expensive function calls, and are not necessarily architecturally significant.</p>
<p class="noindent1">This is not to say that all services <em class="calibre9">should</em> be architecturally significant. There are often substantial benefits to creating services that separate functionality across processes and platforms—whether they obey the Dependency Rule or not. It’s just that services, in and of themselves, do not define an architecture.</p>
<p class="noindent1">A helpful analogy is the organization of functions. The architecture of a monolithic or component-based system is defined by certain function calls that cross architectural boundaries and follow the Dependency Rule. Many other functions in those systems, however, simply separate one behavior from another and are not architecturally significant.</p>
<p class="noindent1">So it is with services. Services are, after all, just function calls across process and/or platform boundaries. Some of those services are architecturally significant, and some aren’t. Our interest, in this chapter, is with the former.</p>
<h3 class="h1" id="toclev_135">S<small class="calibre13">ERVICE</small> B<small class="calibre13">ENEFITS</small>?</h3>
<p class="noindent1">The question mark in the preceding heading indicates that this section is going to challenge the current popular orthodoxy of service architecture. Let’s tackle the benefits one at a time.</p>
<h4 class="h2">T<small class="calibre13">HE</small> D<small class="calibre13">ECOUPLING</small> F<small class="calibre13">ALLACY</small></h4>
<p class="noindent1">One of the big supposed benefits of breaking a system up into services is that services are strongly decoupled from each other. After all, each service runs in a different process, or even a different processor; therefore those services do not have access to each other’s variables. What’s more, the interface of each service must be well defined.</p>
<p class="noindent1"><a id="page_241"></a>There is certainly some truth to this—but not very much truth. Yes, services are decoupled at the level of individual variables. However, they can still be coupled by shared resources within a processor, or on the network. What’s more, they are strongly coupled by the data they share.</p>
<p class="noindent1">For example, if a new field is added to a data record that is passed between services, then every service that operates on the new field must be changed. The services must also strongly agree about the interpretation of the data in that field. Thus those services are strongly coupled to the data record and, therefore, indirectly coupled to each other.</p>
<p class="noindent1">As for interfaces being well defined, that’s certainly true—but it is no less true for functions. Service interfaces are no more formal, no more rigorous, and no better defined than function interfaces. Clearly, then, this benefit is something of an illusion.</p>
<h4 class="h2">T<small class="calibre13">HE</small> F<small class="calibre13">ALLACY OF</small> I<small class="calibre13">NDEPENDENT</small> D<small class="calibre13">EVELOPMENT AND</small> D<small class="calibre13">EPLOYMENT</small></h4>
<p class="noindent1">Another of the supposed benefits of services is that they can be owned and operated by a dedicated team. That team can be responsible for writing, maintaining, and operating the service as part of a dev-ops strategy. This independence of development and deployment is presumed to be <em class="calibre9">scalable</em>. It is believed that large enterprise systems can be created from dozens, hundreds, or even thousands of independently developable and deployable services. Development, maintenance, and operation of the system can be partitioned between a similar number of independent teams.</p>
<p class="noindent1">There is some truth to this belief—but only some. First, history has shown that large enterprise systems can be built from monoliths and component-based systems as well as service-based systems. Thus services are not the only option for building scalable systems.</p>
<p class="noindent1">Second, the decoupling fallacy means that services cannot always be independently developed, deployed, and operated. To the extent that they are coupled by data or behavior, the development, deployment, and operation must be coordinated.</p>
<h3 class="h1" id="toclev_136"><a id="page_242" class="calibre3"></a>T<small class="calibre13">HE</small> K<small class="calibre13">ITTY</small> P<small class="calibre13">ROBLEM</small></h3>
<p class="noindent1">As an example of these two fallacies, let’s look at our taxi aggregator system again. Remember, this system knows about many taxi providers in a given city, and allows customers to order rides. Let’s assume that the customers select taxis based on a number of criteria, such as pickup time, cost, luxury, and driver experience.</p>
<p class="noindent1">We wanted our system to be scalable, so we chose to build it out of lots of little micro-services. We subdivided our development staff into many small teams, each of which is responsible for developing, maintaining, and operating a correspondingly<sup class="calibre10"><a id="ch27fn1"></a><a href="part0041.html#ch27fn-1">1</a></sup> small number of services.</p>
<p class="noindent1">The diagram in <a href="part0041.html#ch27fig1">Figure 27.1</a> shows how our fictitious architects arranged services to implement this application. The <code class="calibre11">TaxiUI</code> service deals with the customers, who use mobile devices to order taxis. The <code class="calibre11">TaxiFinder</code> service examines the inventories of the various <code class="calibre11">TaxiSuppliers</code> and determines which taxies are possible candidates for the user. It deposits these into a short-term data record attached to that user. The <code class="calibre11">TaxiSelector</code> service takes the user’s criteria of cost, time, luxury, and so forth, and chooses an appropriate taxi from among the candidates. It hands that taxi off to the <code class="calibre11">TaxiDispatcher</code> service, which orders the appropriate taxi.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00099.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch27fig1"></a><strong class="calibre8">Figure 27.1</strong> Services arranged to implement the taxi aggregator system</p>
</div>
<p class="noindent1"><a id="page_243"></a>Now let us suppose that this system has been in operation for more than a year. Our staff of developers have been happily developing new features while maintaining and operating all these services.</p>
<p class="noindent1">One bright and cheerful day, the marketing department holds a meeting with the development team. In this meeting, they announce their plans to offer a kitten delivery service to the city. Users can order kittens to be delivered to their homes or to their places of business.</p>
<p class="noindent1">The company will set up several kitten collection points across the city. When a kitten order is placed, a nearby taxi will be selected to collect a kitten from one of those collection points, and then deliver it to the appropriate address.</p>
<p class="noindent1">One of the taxi suppliers has agreed to participate in this program. Others are likely to follow. Still others may decline.</p>
<p class="noindent1">Of course, some drivers may be allergic to cats, so those drivers should never be selected for this service. Also, some customers will undoubtedly have similar allergies, so a vehicle that has been used to deliver kittens within the last 3 days should not be selected for customers who declare such allergies.</p>
<p class="noindent1">Look at that diagram of services. How many of those services will have to change to implement this feature? <em class="calibre9">All of them</em>. Clearly, the development and deployment of the kitty feature will have to be very carefully coordinated.</p>
<p class="noindent1">In other words, the services are all coupled, and cannot be independently developed, deployed, and maintained.</p>
<p class="noindent1">This is the problem with cross-cutting concerns. Every software system must face this problem, whether service oriented or not. Functional decompositions, of the kind depicted in the service diagram in <a href="part0041.html#ch27fig1">Figure 27.1</a>, are very vulnerable to new features that cut across all those functional behaviors.</p>
<h3 class="h1" id="toclev_137"><a id="page_244" class="calibre3"></a>O<small class="calibre13">BJECTS TO THE</small> R<small class="calibre13">ESCUE</small></h3>
<p class="noindent1">How would we have solved this problem in a component-based architecture? Careful consideration of the SOLID design principles would have prompted us to create a set of classes that could be polymorphically extended to handle new features.</p>
<p class="noindent1">The diagram in <a href="part0041.html#ch27fig2">Figure 27.2</a> shows the strategy. The classes in this diagram roughly correspond to the services shown in <a href="part0041.html#ch27fig1">Figure 27.1</a>. However, note the boundaries. Note also that the dependencies follow the Dependency Rule.</p>
<p class="noindent1">Much of the logic of the original services is preserved within the base classes of the object model. However, that portion of the logic that was specific to <em class="calibre9">rides</em> has been extracted into a <code class="calibre11">Rides</code> component. The new feature for kittens has been placed into a <code class="calibre11">Kittens</code> component. These two components override the abstract base classes in the original components using a pattern such as <em class="calibre9">Template Method or Strategy</em>.</p>
<p class="noindent1">Note again that the two new components, <code class="calibre11">Rides</code> and <code class="calibre11">Kittens</code>, follow the Dependency Rule. Note also that the classes that implement those features are created by factories under the control of the UI.</p>
<p class="noindent1">Clearly, in this scheme, when the Kitty feature is implemented, the <code class="calibre11">TaxiUI</code> must change. But nothing else needs to be changed. Rather, a new jar file, or Gem, or DLL is added to the system and dynamically loaded at runtime.</p>
<p class="noindent1">Thus the Kitty feature is decoupled, and independently developable and deployable.</p>
<div class="fig-heading">
<div class="image1"><a id="page_245"></a><img src="../images/00100.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch27fig2"></a><strong class="calibre8">Figure 27.2</strong> Using an object-oriented approach to deal with cross-cutting concerns</p>
</div>
<h3 class="h1" id="toclev_138">C<small class="calibre13">OMPONENT</small>-B<small class="calibre13">ASED</small> S<small class="calibre13">ERVICES</small></h3>
<p class="noindent1">The obvious question is: Can we do that for services? And the answer is, of course: Yes! Services do not need to be little monoliths. Services can, instead, be designed using the SOLID principles, and given a component structure so that new components can be added to them without changing the existing components within the service.</p>
<p class="noindent1"><a id="page_246"></a>Think of a service in Java as a set of abstract classes in one or more jar files. hink of each new feature or feature extension as another jar file that contains classes that extend the abstract classes in the first jar files. Deploying a new feature then becomes not a matter of redeploying the services, but rather a matter of simply <em class="calibre9">adding</em> the new jar files to the load paths of those services. In other words, adding new features conforms to the Open-Closed Principle.</p>
<p class="noindent1">The service diagram in <a href="part0041.html#ch27fig3">Figure 27.3</a> shows the structure. The services still exist as before, but each has its own internal component design, allowing new features to be added as new derivative classes. Those derivative classes live within their own components.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00101.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch27fig3"></a><strong class="calibre8">Figure 27.3</strong> Each service has its own internal component design, enabling new features to be added as new derivative classes</p>
</div>
<h3 class="h1" id="toclev_139">C<small class="calibre13">ROSS</small>-C<small class="calibre13">UTTING</small> C<small class="calibre13">ONCERNS</small></h3>
<p class="noindent1">What we have learned is that architectural boundaries do not fall <em class="calibre9">between</em> services. Rather, those boundaries run <em class="calibre9">through</em> the services, dividing them into components.</p>
<p class="noindent1"><a id="page_247"></a>To deal with the cross-cutting concerns that all significant systems face, services must be designed with internal component architectures that follow the Dependency Rule, as shown in the diagram in <a href="part0041.html#ch27fig4">Figure 27.4</a>. Those services do not define the architectural boundaries of the system; instead, the components within the services do.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00102.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch27fig4"></a><strong class="calibre8">Figure 27.4</strong> Services must be designed with internal component architectures that follow the Dependency Rule</p>
</div>
<h3 class="h1" id="toclev_140">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">As useful as services are to the scalability and develop-ability of a system, they are not, in and of themselves, architecturally significant elements. The architecture of a system is defined by the boundaries drawn within that system, and by the dependencies that cross those boundaries. That architecture is not defined by the physical mechanisms by which elements communicate and execute.</p>
<p class="noindent1">A service might be a single component, completely surrounded by an architectural boundary. Alternatively, a service might be composed of several components separated by architectural boundaries. In rare<sup class="calibre10"><a id="ch27fn2"></a><a href="part0041.html#ch27fn-2">2</a></sup> cases, clients and services may be so coupled as to have no architectural significance whatever.</p>
<p class="fn"><a id="page_248"></a><a id="ch27fn-1"></a><a href="part0041.html#ch27fn1">1</a>. Therefore the number of micro-services will be roughly equal to the number of programmers.</p>
<p class="fn"><a id="ch27fn-2"></a><a href="part0041.html#ch27fn2">2</a>. We hope they are rare. Unfortunately, experience suggests otherwise.</p>
</body></html>
