<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" xml:lang="en-us" lang="en-us">
  <head>
    <title>Chapter 14 Component Coupling</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="h2f" id="ch14"><a id="page_111" class="calibre3"></a><span class="gray">14</span><br class="calibre12"/>C<small class="calibre7">OMPONENT</small> C<small class="calibre7">OUPLING</small></h2>
<div class="image1"><img src="../images/00046.jpeg" alt="Image" class="calibre2"/></div>
<p class="noindent1">The next three principles deal with the relationships between components. Here again we will run into the tension between develop-ability and logical design. The forces that impinge upon the architecture of a component structure are technical, political, and volatile.</p>
<h3 class="h1" id="toclev_60"><a id="page_112" class="calibre3"></a>T<small class="calibre13">HE</small> A<small class="calibre13">CYCLIC</small> D<small class="calibre13">EPENDENCIES</small> P<small class="calibre13">RINCIPLE</small></h3>
<p class="blockquote"><em class="calibre9">Allow no cycles in the component dependency graph.</em></p>
<p class="noindent1">Have you ever worked all day, gotten some stuff working, and then gone home, only to arrive the next morning to find that your stuff no longer works? Why doesn’t it work? Because somebody stayed later than you and changed something you depend on! I call this “the morning after syndrome.”</p>
<p class="noindent1">The “morning after syndrome” occurs in development environments where many developers are modifying the same source files. In relatively small projects with just a few developers, it isn’t too big a problem. But as the size of the project and the development team grow, the mornings after can get pretty nightmarish. It is not uncommon for weeks to go by without the team being able to build a stable version of the project. Instead, everyone keeps on changing and changing their code trying to make it work with the last changes that someone else made.</p>
<p class="noindent1">Over the last several decades, two solutions to this problem have evolved, both of which came from the telecommunications industry. The first is “the weekly build,” and the second is the Acyclic Dependencies Principle (ADP).</p>
<h4 class="h2">T<small class="calibre13">HE</small> W<small class="calibre13">EEKLY</small> B<small class="calibre13">UILD</small></h4>
<p class="noindent1">The weekly build used to be common in medium-sized projects. It works like this: All the developers ignore each other for the first four days of the week. They all work on private copies of the code, and don’t worry about integrating their work on a collective basis. Then, on Friday, they integrate all their changes and build the system.</p>
<p class="noindent1">This approach has the wonderful advantage of allowing the developers to live in an isolated world for four days out of five. The disadvantage, of course, is the large integration penalty that is paid on Friday.</p>
<p class="noindent1">Unfortunately, as the project grows, it becomes less feasible to finish integrating the project on Friday. The integration burden grows until it starts <a id="page_113"></a>to overflow into Saturday. A few such Saturdays are enough to convince the developers that integration should really begin on Thursday—and so the start of integration slowly creeps toward the middle of the week.</p>
<p class="noindent1">As the duty cycle of development versus integration decreases, the efficiency of the team decreases, too. Eventually this situation becomes so frustrating that the developers, or the project managers, declare that the schedule should be changed to a biweekly build. This suffices for a time, but the integration time continues to grow with project size.</p>
<p class="noindent1">Eventually, this scenario leads to a crisis. To maintain efficiency, the build schedule has to be continually lengthened—but lengthening the build schedule increases project risks. Integration and testing become increasingly harder to do, and the team loses the benefit of rapid feedback.</p>
<h4 class="h2">E<small class="calibre13">LIMINATING</small> D<small class="calibre13">EPENDENCY</small> C<small class="calibre13">YCLES</small></h4>
<p class="noindent1">The solution to this problem is to partition the development environment into releasable components. The components become units of work that can be the responsibility of a single developer, or a team of developers. When developers get a component working, they release it for use by the other developers. They give it a release number and move it into a directory for other teams to use. They then continue to modify their component in their own private areas. Everyone else uses the released version.</p>
<p class="noindent1">As new releases of a component are made available, other teams can decide whether they will immediately adopt the new release. If they decide not to, they simply continue using the old release. Once they decide that they are ready, they begin to use the new release.</p>
<p class="noindent1">Thus no team is at the mercy of the others. Changes made to one component do not need to have an immediate affect on other teams. Each team can decide for itself when to adapt its own components to new releases of the components. Moreover, integration happens in small increments. There is no single point in time when all developers must come together and integrate everything they are doing.</p>
<p class="noindent1"><a id="page_114"></a>This is a very simple and rational process, and it is widely used. To make it work successfully, however, you must <em class="calibre9">manage</em> the dependency structure of the components. <em class="calibre9">There can be no cycles</em>. If there are cycles in the dependency structure, then the “morning after syndrome” cannot be avoided.</p>
<p class="noindent1">Consider the component diagram in <a href="part0027.html#ch14fig1">Figure 14.1</a>. It shows a rather typical structure of components assembled into an application. The function of this application is unimportant for the purpose of this example. What <em class="calibre9">is</em> important is the dependency structure of the components. Notice that this structure is a <em class="calibre9">directed graph</em>. The components are the <em class="calibre9">nodes</em>, and the dependency relationships are the <em class="calibre9">directed edges</em>.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00047.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig1"></a><strong class="calibre8">Figure 14.1</strong> Typical component diagram</p>
</div>
<p class="noindent1">Notice one more thing: Regardless of which component you begin at, it is impossible to follow the dependency relationships and wind up back at that component. This structure has no cycles. It is a <em class="calibre9">directed acyclic graph</em> (DAG).</p>
<p class="noindent1">Now consider what happens when the team responsible for <code class="calibre11">Presenters</code> makes a new release of their component. It is easy to find out who is affected <a id="page_115"></a>by this release; you just follow the dependency arrows backward. Thus <code class="calibre11">View</code> and <code class="calibre11">Main</code> will both be affected. The developers currently working on those components will have to decide when they should integrate their work with the new release of <code class="calibre11">Presenters</code>.</p>
<p class="noindent1">Notice also that when <code class="calibre11">Main</code> is released, it has utterly no effect on any of the other components in the system. They don’t know about <code class="calibre11">Main</code>, and they don’t care when it changes. This is nice. It means that the impact of releasing <code class="calibre11">Main</code> is relatively small.</p>
<p class="noindent1">When the developers working on the <code class="calibre11">Presenters</code> component would like to run a test of that component, they just need to build their version of <code class="calibre11">Presenters</code> with the versions of the <code class="calibre11">Interactors</code> and <code class="calibre11">Entities</code> components that they are currently using. None of the other components in the system need be involved. This is nice. It means that the developers working on <code class="calibre11">Presenters</code> have relatively little work to do to set up a test, and that they have relatively few variables to consider.</p>
<p class="noindent1">When it is time to release the whole system, the process proceeds from the bottom up. First the <code class="calibre11">Entities</code> component is compiled, tested, and released. Then the same is done for <code class="calibre11">Database</code> and <code class="calibre11">Interactors</code>. These components are followed by <code class="calibre11">Presenters</code>, <code class="calibre11">View</code>, <code class="calibre11">Controllers</code>, and then <code class="calibre11">Authorizer</code>. <code class="calibre11">Main</code> goes last. This process is very clear and easy to deal with. We know how to build the system because we understand the dependencies between its parts.</p>
<h4 class="h2">T<small class="calibre13">HE</small> E<small class="calibre13">FFECT OF</small> A C<small class="calibre13">YCLE IN THE</small> C<small class="calibre13">OMPONENT</small> D<small class="calibre13">EPENDENCY</small> G<small class="calibre13">RAPH</small></h4>
<p class="noindent1">Suppose that a new requirement forces us to change one of the classes in <code class="calibre11">Entities</code> such that it makes use of a class in <code class="calibre11">Authorizer</code>. For example, let’s say that the <code class="calibre11">User</code> class in <code class="calibre11">Entities</code> uses the <code class="calibre11">Permissions</code> class in <code class="calibre11">Authorizer</code>. This creates a dependency cycle, as shown in <a href="part0027.html#ch14fig2">Figure 14.2</a>.</p>
<p class="noindent1">This cycle creates some immediate problems. For example, the developers working on the <code class="calibre11">Database</code> component know that to release it, the component <a id="page_116"></a>must be compatible with <code class="calibre11">Entities</code>. However, with the cycle in place, the <code class="calibre11">Database</code> component must now <em class="calibre9">also</em> be compatible with <code class="calibre11">Authorizer</code>. But <code class="calibre11">Authorizer</code> depends on <code class="calibre11">Interactors</code>. This makes <code class="calibre11">Database</code> much more difficult to release. <code class="calibre11">Entities</code>, <code class="calibre11">Authorizer</code>, and <code class="calibre11">Interactors</code> have, in effect, become one large component—which means that all of the developers working on any of those components will experience the dreaded “morning after syndrome.” They will be stepping all over one another because they must all use exactly the same release of one another’s components.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00048.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig2"></a><strong class="calibre8">Figure 14.2</strong> A dependency cycle</p>
</div>
<p class="noindent1">But this is just part of the trouble. Consider what happens when we want to test the <code class="calibre11">Entities</code> component. To our chagrin, we find that we must build and integrate with <code class="calibre11">Authorizer</code> and <code class="calibre11">Interactors</code>. This level of coupling between components is troubling, if not intolerable.</p>
<p class="noindent1">You may have wondered why you have to include so many different libraries, and so much of everybody else’s stuff, just to run a simple unit test of one of your classes. If you investigate the matter a bit, you will probably discover that there are cycles in the dependency graph. Such cycles make it very difficult to isolate components. Unit testing and releasing become very difficult and error prone. In addition, build issues grow geometrically with the number of modules.</p>
<p class="noindent1"><a id="page_117"></a>Moreover, when there are cycles in the dependency graph, it can be very difficult to work out the order in which you must build the components. Indeed, there probably is no correct order. This can lead to some very nasty problems in languages like Java that read their declarations from compiled binary files.</p>
<h4 class="h2">B<small class="calibre13">REAKING THE</small> C<small class="calibre13">YCLE</small></h4>
<p class="noindent1">It is always possible to break a cycle of components and reinstate the dependency graph as a DAG. There are two primary mechanisms for doing so:</p>
<p class="indenthangingn"><strong class="calibre8">1.</strong> Apply the Dependency Inversion Principle (DIP). In the case in <a href="part0027.html#ch14fig3">Figure 14.3</a>, we could create an interface that has the methods that <code class="calibre11">User</code> needs. We could then put that interface into <code class="calibre11">Entities</code> and inherit it into <code class="calibre11">Authorizer</code>. This inverts the dependency between <code class="calibre11">Entities</code> and <code class="calibre11">Authorizer</code>, thereby breaking the cycle.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00049.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig3"></a><strong class="calibre8">Figure 14.3</strong> Inverting the dependency between <code class="calibre11">Entities</code> and <code class="calibre11">Authorizer</code></p>
<p class="indenthangingn"><strong class="calibre8">2.</strong> Create a new component that both <code class="calibre11">Entities</code> and <code class="calibre11">Authorizer</code> depend on. Move the class(es) that they both depend on into that new component (<a href="part0027.html#ch14fig4">Figure 14.4</a>).</p>
<div class="fig-heading">
<div class="image1"><a id="page_118"></a><img src="../images/00050.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig4"></a><strong class="calibre8">Figure 14.4</strong> The new component that both <code class="calibre11">Entities</code> and <code class="calibre11">Authorizer</code> depend on</p>
</div>
</div>
<h4 class="h2">T<small class="calibre13">HE</small> “J<small class="calibre13">ITTERS”</small></h4>
<p class="noindent1">The second solution implies that the component structure is volatile in the presence of changing requirements. Indeed, as the application grows, the component dependency structure jitters and grows. Thus the dependency structure must always be monitored for cycles. When cycles occur, they must be broken somehow. Sometimes this will mean creating new components, making the dependency structure grow.</p>
<h3 class="h1" id="toclev_61">T<small class="calibre13">OP</small>-D<small class="calibre13">OWN</small> D<small class="calibre13">ESIGN</small></h3>
<p class="noindent1">The issues we have discussed so far lead to an inescapable conclusion: The component structure cannot be designed from the top down. It is not one of the first things about the system that is designed, but rather evolves as the system grows and changes.</p>
<p class="noindent1">Some readers may find this point to be counterintuitive. We have come to expect that large-grained decompositions, like components, will also be high-level <em class="calibre9">functional</em> decompositions.</p>
<p class="noindent1"><a id="page_119"></a>When we see a large-grained grouping such as a component dependency structure, we believe that the components ought to somehow represent the functions of the system. Yet this does not seem to be an attribute of component dependency diagrams.</p>
<p class="noindent1">In fact, component dependency diagrams have very little do to with describing the function of the application. Instead, they are a map to the <em class="calibre9">buildability</em> and <em class="calibre9">maintainability</em> of the application. This is why they aren’t designed at the beginning of the project. There is no software to build or maintain, so there is no need for a build and maintenance map. But as more and more modules accumulate in the early stages of implementation and design, there is a growing need to manage the dependencies so that the project can be developed without the “morning after syndrome.” Moreover, we want to keep changes as localized as possible, so we start paying attention to the SRP and CCP and collocate classes that are likely to change together.</p>
<p class="noindent1">One of the overriding concerns with this dependency structure is the isolation of volatility. We don’t want components that change frequently and for capricious reasons to affect components that otherwise ought to be stable. For example, we don’t want cosmetic changes to the GUI to have an impact on our business rules. We don’t want the addition or modification of reports to have an impact on our highest-level policies. Consequently, the component dependency graph is created and molded by architects to protect stable high-value components from volatile components.</p>
<p class="noindent1">As the application continues to grow, we start to become concerned about creating reusable elements. At this point, the CRP begins to influence the composition of the components. Finally, as cycles appear, the ADP is applied and the component dependency graph jitters and grows.</p>
<p class="noindent1">If we tried to design the component dependency structure before we designed any classes, we would likely fail rather badly. We would not know much about common closure, we would be unaware of any reusable elements, and we would almost certainly create components that produced dependency cycles. Thus the component dependency structure grows and evolves with the logical design of the system.</p>
<h3 class="h1" id="toclev_62"><a id="page_120" class="calibre3"></a>T<small class="calibre13">HE</small> S<small class="calibre13">TABLE</small> D<small class="calibre13">EPENDENCIES</small> P<small class="calibre13">RINCIPLE</small></h3>
<p class="blockquote"><em class="calibre9">Depend in the direction of stability.</em></p>
<p class="noindent1">Designs cannot be completely static. Some volatility is necessary if the design is to be maintained. By conforming to the Common Closure Principle (CCP), we create components that are sensitive to certain kinds of changes but immune to others. Some of these components are <em class="calibre9">designed</em> to be volatile. We <em class="calibre9">expect</em> them to change.</p>
<p class="noindent1">Any component that we expect to be volatile should not be depended on by a component that is difficult to change. Otherwise, the volatile component will also be difficult to change.</p>
<p class="noindent1">It is the perversity of software that a module that you have designed to be easy to change can be made difficult to change by someone else who simply hangs a dependency on it. Not a line of source code in your module need change, yet your module will suddenly become more challenging to change. By conforming to the Stable Dependencies Principle (SDP), we ensure that modules that are intended to be easy to change are not depended on by modules that are harder to change.</p>
<h4 class="h2">S<small class="calibre13">TABILITY</small></h4>
<p class="noindent1">What is meant by “stability”? Stand a penny on its side. Is it stable in that position? You would likely say “no.” However, unless disturbed, it will remain in that position for a very long time. Thus stability has nothing directly to do with frequency of change. The penny is not changing, but it is difficult to think of it as stable.</p>
<p class="noindent1"><em class="calibre9">Webster’s Dictionary</em> says that something is stable if it is “not easily moved.” Stability is related to the amount of work required to make a change. On the one hand, the standing penny is not stable because it requires very little work to topple it. On the other hand, a table is very stable because it takes a considerable amount of effort to turn it over.</p>
<p class="noindent1">How does this relate to software? Many factors may make a software component hard to change—for example, its size, complexity, and clarity, among <a id="page_121"></a>other characteristics. We will ignore all those factors and focus on something different here. One sure way to make a software component difficult to change, is to make lots of other software components depend on it. A component with lots of incoming dependencies is very stable because it requires a great deal of work to reconcile any changes with all the dependent components.</p>
<p class="noindent1">The diagram in <a href="part0027.html#ch14fig5">Figure 14.5</a> shows <code class="calibre11">X</code>, which is a stable component. Three components depend on <code class="calibre11">X</code>, so it has three good reasons not to change. We say that <code class="calibre11">X</code> is <em class="calibre9">responsible</em> to those three components. Conversely, <code class="calibre11">X</code> depends on nothing, so it has no external influence to make it change. We say it is <em class="calibre9">independent</em>.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00051.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig5"></a><strong class="calibre8">Figure 14.5</strong> <code class="calibre11">X</code>: a stable component</p>
</div>
<p class="noindent1"><a href="part0027.html#ch14fig6">Figure 14.6</a> shows <code class="calibre11">Y</code>, which is a very unstable component. No other components depend on <code class="calibre11">Y</code>, so we say that it is irresponsible. <code class="calibre11">Y</code> also has three components that it depends on, so changes may come from three external sources. We say that <code class="calibre11">Y</code> is dependent.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00052.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig6"></a><strong class="calibre8">Figure 14.6</strong> <code class="calibre11">Y</code>: a very unstable component</p>
</div>
<h4 class="h2"><a id="page_122" class="calibre3"></a>S<small class="calibre13">TABILITY</small> M<small class="calibre13">ETRICS</small></h4>
<p class="noindent1">How can we measure the stability of a component? One way is to count the number of dependencies that enter and leave that component. These counts will allow us to calculate the <em class="calibre9">positional</em> stability of the component.</p>
<p class="indenthangingb">• <em class="calibre9">Fan-in</em>: Incoming dependencies. This metric identifies the number of classes outside this component that depend on classes within the component.</p>
<p class="indenthangingb">• <em class="calibre9">Fan-out</em>: Outgoing depenencies. This metric identifies the number of classes inside this component that depend on classes outside the component.</p>
<p class="indenthangingb">• <em class="calibre9">I</em>: Instability: <em class="calibre9">I</em> = <em class="calibre9">Fan-out</em> , (<em class="calibre9">Fan-in</em> + <em class="calibre9">Fan-out</em>). This metric has the range [0, 1]. <em class="calibre9">I</em> = 0 indicates a maximally stable component. <em class="calibre9">I</em> = 1 indicates a maximally unstable component.</p>
<p class="noindent1">The <em class="calibre9">Fan-in</em> and <em class="calibre9">Fan-out</em> metrics<sup class="calibre10"><a id="ch14fn-1" href="part0027.html#ch14fn1">1</a></sup> are calculated by counting the number of <em class="calibre9">classes</em> outside the component in question that have dependencies with the classes inside the component in question. Consider the example in <a href="part0027.html#ch14fig7">Figure 14.7</a>.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00053.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig7"></a><strong class="calibre8">Figure 14.7</strong> Our example</p>
</div>
<p class="noindent1">Let’s say we want to calculate the stability of the component <code class="calibre11">Cc</code>. We find that there are three classes outside <code class="calibre11">Cc</code> that depend on classes in <code class="calibre11">Cc</code>. Thus, <em class="calibre9">Fan-in</em> = 3. Moreover, there is one class outside <code class="calibre11">Cc</code> that classes in <code class="calibre11">Cc</code> depend on. Thus, <em class="calibre9">Fan-out</em> = 1 and <em class="calibre9">I</em> = 1/4.</p>
<p class="noindent1"><a id="page_123"></a>In C++, these dependencies are typically represented by <code class="calibre11">#include</code> statements. Indeed, the <em class="calibre9">I</em> metric is easiest to calculate when you have organized your source code such that there is one class in each source file. In Java, the <em class="calibre9">I</em> metric can be calculated by counting <code class="calibre11">import</code> statements and qualified names.</p>
<p class="noindent1">When the <em class="calibre9">I</em> metric is equal to 1, it means that no other component depends on this component (<em class="calibre9">Fan-in</em> = 0), and this component depends on other components (<em class="calibre9">Fan-ou</em>t &gt; 0). This situation is as unstable as a component can get; it is irresponsible and dependent. Its lack of dependents gives the component no reason not to change, and the components that it depends on may give it ample reason to change.</p>
<p class="noindent1">In contrast, when the <em class="calibre9">I</em> metric is equal to 0, it means that the component is depended on by other components (<em class="calibre9">Fan-in</em> &gt; 0), but does not itself depend on any other components (<em class="calibre9">Fan-ou</em>t = 0). Such a component is <em class="calibre9">responsible</em> and <em class="calibre9">independent</em>. It is as stable as it can get. Its dependents make it hard to change the component, and its has no dependencies that might force it to change.</p>
<p class="noindent1">The SDP says that the <em class="calibre9">I</em> metric of a component should be larger than the <em class="calibre9">I</em> metrics of the components that it depends on. That is, <em class="calibre9">I</em> metrics should <em class="calibre9">decrease</em> in the direction of dependency.</p>
<h4 class="h2">N<small class="calibre13">OT</small> A<small class="calibre13">LL</small> C<small class="calibre13">OMPONENTS</small> S<small class="calibre13">HOULD</small> B<small class="calibre13">E</small> S<small class="calibre13">TABLE</small></h4>
<p class="noindent1">If all the components in a system were maximally stable, the system would be unchangeable. This is not a desirable situation. Indeed, we want to design our component structure so that some components are unstable and some are stable. The diagram in <a href="part0027.html#ch14fig8">Figure 14.8</a> shows an ideal configuration for a system with three components.</p>
<p class="noindent1">The changeable components are on top and depend on the stable component at the bottom. Putting the unstable components at the top of the diagram is a useful convention because any arrow that points <em class="calibre9">up</em> is violating the SDP (and, as we shall see later, the ADP).</p>
<div class="fig-heading">
<div class="image1"><a id="page_124"></a><img src="../images/00054.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig8"></a><strong class="calibre8">Figure 14.8</strong> An ideal configuration for a system with three components</p>
</div>
<p class="noindent1">The diagram in <a href="part0027.html#ch14fig9">Figure 14.9</a> shows how the SDP can be violated.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00055.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig9"></a><strong class="calibre8">Figure 14.9</strong> SDP violation</p>
</div>
<p class="noindent1"><code class="calibre11">Flexible</code> is a component that we have designed to be easy to change. We want <code class="calibre11">Flexible</code> to be unstable. However, some developer, working in the component named <code class="calibre11">Stable</code>, has hung a dependency on <code class="calibre11">Flexible</code>. This violates the SDP because the <em class="calibre9">I</em> metric for <code class="calibre11">Stable</code> is much smaller than the <em class="calibre9">I</em> metric for <code class="calibre11">Flexible</code>. As a result, <code class="calibre11">Flexible</code> will no longer be easy to change. A change to <code class="calibre11">Flexible</code> will force us to deal with <code class="calibre11">Stable</code> and all its dependents.</p>
<p class="noindent1">To fix this problem, we somehow have to break the dependence of <code class="calibre11">Stable</code> on <code class="calibre11">Flexible</code>. Why does this dependency exist? Let’s assume that there is a <a id="page_125"></a>class <code class="calibre11">C</code> within <code class="calibre11">Flexible</code> that another class <code class="calibre11">U</code> within <code class="calibre11">Stable</code> needs to use (<a href="part0027.html#ch14fig10">Figure 14.10</a>).</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00056.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig10"></a><strong class="calibre8">Figure 14.10</strong> <code class="calibre11">U</code> within <code class="calibre11">Stable</code> uses <code class="calibre11">C</code> within <code class="calibre11">Flexible</code></p>
</div>
<p class="noindent1">We can fix this by employing the DIP. We create an interface class called <code class="calibre11">US</code> and put it in a component named <code class="calibre11">UServer</code>. We make sure that this interface declares all the methods that <code class="calibre11">U</code> needs to use. We then make <code class="calibre11">C</code> implement this interface as shown in <a href="part0027.html#ch14fig11">Figure 14.11</a>. This breaks the dependency of <code class="calibre11">Stable</code> on <code class="calibre11">Flexible</code>, and forces both components to depend on <code class="calibre11">UServer</code>. <code class="calibre11">UServer</code> is very stable (<em class="calibre9">I</em> = 0), and <code class="calibre11">Flexible</code> retains its necessary instability (<em class="calibre9">I</em> = 1). All the dependencies now flow in the direction of <em class="calibre9">decreasing I</em>.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00057.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig11"></a><strong class="calibre8">Figure 14.11</strong> <code class="calibre11">C</code> implements the interface class <code class="calibre11">US</code></p>
</div>
<h5 class="h3">Abstract Components</h5>
<p class="noindent1">You may find it strange that we would create a component—in this example, <code class="calibre11">UService</code>—that contains nothing but an interface. Such a component contains no executable code! It turns out, however, that this is a very common, and necessary, tactic when using statically typed languages like Java and C#. These abstract components are very stable and, therefore, are ideal targets for less stable components to depend on.</p>
<p class="noindent1">When using dynamically typed languages like Ruby and Python, these abstract components don’t exist at all, nor do the dependencies that would <a id="page_126"></a>have targeted them. Dependency structures in these languages are much simpler because dependency inversion does not require either the declaration or the inheritance of interfaces.</p>
<h3 class="h1" id="toclev_63">T<small class="calibre13">HE</small> S<small class="calibre13">TABLE</small> A<small class="calibre13">BSTRACTIONS</small> P<small class="calibre13">RINCIPLE</small></h3>
<p class="blockquote"><em class="calibre9">A component should be as abstract as it is stable.</em></p>
<h4 class="h2">W<small class="calibre13">HERE</small> D<small class="calibre13">O</small> W<small class="calibre13">E</small> P<small class="calibre13">UT THE</small> H<small class="calibre13">IGH</small>-L<small class="calibre13">EVEL</small> P<small class="calibre13">OLICY</small>?</h4>
<p class="noindent1">Some software in the system should not change very often. This software represents high-level architecture and policy decisions. We don’t want these business and architectural decisions to be volatile. Thus the software that encapsulates the high-level policies of the system should be placed into stable components (<em class="calibre9">I</em> = 0). Unstable components (<em class="calibre9">I</em> = 1) should contain only the software that is volatile—software that we want to be able to quickly and easily change.</p>
<p class="noindent1">However, if the high-level policies are placed into stable components, then the source code that represents those policies will be difficult to change. This could make the overall architecture inflexible. How can a component that is maximally stable (<em class="calibre9">I</em> = 0) be flexible enough to withstand change? The answer is found in the OCP. This principle tells us that it is possible and desirable to create classes that are flexible enough to be extended without requiring modification. Which kind of classes conform to this principle? <em class="calibre9">Abstract</em> classes.</p>
<h4 class="h2">I<small class="calibre13">NTRODUCING THE</small> S<small class="calibre13">TABLE</small> A<small class="calibre13">BSTRACTIONS</small> P<small class="calibre13">RINCIPLE</small></h4>
<p class="noindent1">The Stable Abstractions Principle (SAP) sets up a relationship between stability and abstractness. On the one hand, it says that a stable component should also be abstract so that its stability does not prevent it from being extended. On the other hand, it says that an unstable component should be concrete since it its instability allows the concrete code within it to be easily changed.</p>
<p class="noindent1"><a id="page_127"></a>Thus, if a component is to be stable, it should consist of interfaces and abstract classes so that it can be extended. Stable components that are extensible are flexible and do not overly constrain the architecture.</p>
<p class="noindent1">The SAP and the SDP combined amount to the DIP for components. This is true because the SDP says that dependencies should run in the direction of stability, and the SAP says that stability implies abstraction. Thus <em class="calibre9">dependencies run in the direction of abstraction.</em></p>
<p class="noindent1">The DIP, however, is a principle that deals with classes—and with classes there are no shades of gray. Either a class is abstract or it is not. The combination of the SDP and the SAP deals with components, and allows that a component can be partially abstract and partially stable.</p>
<h4 class="h2">M<small class="calibre13">EASURING</small> A<small class="calibre13">BSTRACTION</small></h4>
<p class="noindent1">The <em class="calibre9">A</em> metric is a measure of the abstractness of a component. Its value is simply the ratio of interfaces and abstract classes in a component to the total number of classes in the component.</p>
<p class="indenthangingb">• <em class="calibre9">Nc:</em> The number of classes in the component.</p>
<p class="indenthangingb">• <em class="calibre9">Na:</em> The number of abstract classes and interfaces in the component.</p>
<p class="indenthangingb">• <em class="calibre9">A:</em> Abstractness. <em class="calibre9">A</em> = <em class="calibre9">Na</em> ÷ <em class="calibre9">Nc.</em></p>
<p class="noindent1">The <em class="calibre9">A</em> metric ranges from 0 to 1. A value of 0 implies that the component has no abstract classes at all. A value of 1 implies that the component contains nothing but abstract classes.</p>
<h4 class="h2">T<small class="calibre13">HE</small> M<small class="calibre13">AIN</small> S<small class="calibre13">EQUENCE</small></h4>
<p class="noindent1">We are now in a position to define the relationship between stability (<em class="calibre9">I</em>) and abstractness (<em class="calibre9">A</em>). To do so, we create a graph with <em class="calibre9">A</em> on the vertical axis and <em class="calibre9">I</em> on the horizontal axis (<a href="part0027.html#ch14fig12">Figure 14.12</a>). If we plot the two “good” kinds of components on this graph, we will find the components that are maximally stable and abstract at the upper left at (0, 1). The components that are maximally unstable and concrete are at the lower right at (1, 0).</p>
<div class="fig-heading">
<div class="image1"><a id="page_128"></a><img src="../images/00058.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig12"></a><strong class="calibre8">Figure 14.12</strong> The I/A graph</p>
</div>
<p class="noindent1">Not all components fall into one of these two positions, because components often have <em class="calibre9">degrees</em> of abstraction and stability. For example, it is very common for one abstract class to derive from another abstract class. The derivative is an abstraction that has a dependency. Thus, though it is maximally abstract, it will not be maximally stable. Its dependency will decrease its stability.</p>
<p class="noindent1">Since we cannot enforce a rule that all components sit at either (0, 1) or (1, 0), we must assume that there is a locus of points on the <em class="calibre9">A</em>/<em class="calibre9">I</em> graph that defines reasonable positions for components. We can infer what that locus is by finding the areas where components should <em class="calibre9">not</em> be—in other words, by determining the zones of <em class="calibre9">exclusion</em> (Figure 11.13).</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00059.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig13"></a><strong class="calibre8">Figure 14.13</strong> Zones of exclusion</p>
</div>
<h5 class="h3"><a id="page_129"></a>The Zone of Pain</h5>
<p class="noindent1">Consider a component in the area of (0, 0). This is a highly stable and concrete component. Such a component is not desirable because it is rigid. It cannot be extended because it is not abstract, and it is very difficult to change because of its stability. Thus we do not normally expect to see well-designed components sitting near (0, 0). The area around (0, 0) is a zone of exclusion called the <em class="calibre9">Zone of Pain</em>.</p>
<p class="noindent1">Some software entities do, in fact, fall within the Zone of Pain. An example would be a database schema. Database schemas are notoriously volatile, extremely concrete, and highly depended on. This is one reason why the interface between OO applications and databases is so difficult to manage, and why schema updates are generally painful.</p>
<p class="noindent1">Another example of software that sits near the area of (0, 0) is a concrete utility library. Although such a library has an <em class="calibre9">I</em> metric of 1, it may actually be nonvolatile. Consider the <code class="calibre11">String</code> component, for example. Even though all the classes within it are concrete, it is so commonly used that changing it would create chaos. Therefore <code class="calibre11">String</code> is nonvolatile.</p>
<p class="noindent1">Nonvolatile components are harmless in the (0, 0) zone since they are not likely to be changed. For that reason, it is only volatile software components that are problematic in the Zone of Pain. The more volatile a component in the Zone of Pain, the more “painful” it is. Indeed, we might consider volatility to be a third axis of the graph. With this understanding, <a href="part0027.html#ch14fig13">Figure 14.13</a> shows only the most painful plane, where volatility = 1.</p>
<h5 class="h3">The Zone of Uselessness</h5>
<p class="noindent1">Consider a component near (1, 1). This location is undesirable because it is maximally abstract, yet has no dependents. Such components are useless. Thus this area is called the <em class="calibre9">Zone of Uselessness</em>.</p>
<p class="noindent1">The software entities that inhabit this region are a kind of detritus. They are often leftover abstract classes that no one ever implemented. We find them in systems from time to time, sitting in the code base, unused.</p>
<p class="noindent1"><a id="page_130"></a>A component that has a position deep within the Zone of Uselessness must contain a significant fraction of such entities. Clearly, the presence of such useless entities is undesirable.</p>
<h4 class="h2">A<small class="calibre13">VOIDING THE</small> Z<small class="calibre13">ONES OF</small> E<small class="calibre13">XCLUSION</small></h4>
<p class="noindent1">It seems clear that our most volatile components should be kept as far from both zones of exclusion as possible. The locus of points that are maximally distant from each zone is the line that connects (1, 0) and (0, 1). I call this line the <em class="calibre9">Main Sequence</em>.<sup class="calibre10"><a id="ch14fn-2" href="part0027.html#ch14fn2">2</a></sup></p>
<p class="noindent1">A component that sits on the Main Sequence is not “too abstract” for its stability, nor is it “too unstable” for its abstractness. It is neither useless nor particularly painful. It is depended on to the extent that it is abstract, and it depends on others to the extent that it is concrete.</p>
<p class="noindent1">The most desirable position for a component is at one of the two endpoints of the Main Sequence. Good architects strive to position the majority of their components at those endpoints. However, in my experience, some small fraction of the components in a large system are neither perfectly abstract nor perfectly stable. Those components have the best characteristics if they are on, <em class="calibre9">or close</em>, to the Main Sequence.</p>
<h4 class="h2">D<small class="calibre13">ISTANCE FROM THE</small> M<small class="calibre13">AIN</small> S<small class="calibre13">EQUENCE</small></h4>
<p class="noindent1">This leads us to our last metric. If it is desirable for components to be on, or close, to the Main Sequence, then we can create a metric that measures how far away a component is from this ideal.</p>
<p class="indenthangingb">• <em class="calibre9">D</em><sup class="calibre10"><a id="ch14fn-3" href="part0027.html#ch14fn3">3</a></sup>: Distance. <em class="calibre9">D</em> = |<em class="calibre9">A</em>+<em class="calibre9">I</em>–1| . The range of this metric is [0, 1]. A value of 0 indicates that the component is directly on the Main Sequence. A value of 1 indicates that the component is as far away as possible from the Main Sequence.</p>
<p class="noindent1"><a id="page_131"></a>Given this metric, a design can be analyzed for its overall conformance to the Main Sequence. The <em class="calibre9">D</em> metric for each component can be calculated. Any component that has a <em class="calibre9">D</em> value that is not near zero can be reexamined and restructured.</p>
<p class="noindent1">Statistical analysis of a design is also possible. We can calculate the mean and variance of all the <em class="calibre9">D</em> metrics for the components within a design. We would expect a conforming design to have a mean and variance that are close to zero. The variance can be used to establish “control limits” so as to identify components that are “exceptional” in comparison to all the others.</p>
<p class="noindent1">In the scatterplot in <a href="part0027.html#ch14fig14">Figure 14.14</a>, we see that the bulk of the components lie along the Main Sequence, but some of them are more than one standard deviation (<em class="calibre9">Z</em> = 1) away from the mean. These aberrant components are worth examining more closely. For some reason, they are either very abstract with few dependents or very concrete with many dependents.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00060.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig14"></a><strong class="calibre8">Figure 14.14</strong> Scatterplot of the components</p>
</div>
<p class="noindent1">Another way to use the metrics is to plot the <em class="calibre9">D</em> metric of each component over time. The graph in <a href="part0027.html#ch14fig15">Figure 14.15</a> is a mock-up of such a plot. You can see <a id="page_132"></a>that some strange dependencies have been creeping into the <code class="calibre11">Payroll</code> component over the last few releases. The plot shows a control threshold at <em class="calibre9">D</em> = 0.1. The R2.1 point has exceeded this control limit, so it would be worth our while to find out why this component is so far from the main sequence.</p>
<div class="fig-heading">
<div class="image1"><img src="../images/00061.jpeg" alt="Image" class="calibre2"/></div>
<p class="fig-caption"><a id="ch14fig15"></a><strong class="calibre8">Figure 14.15</strong> Plot of D for a single component over time</p>
</div>
<h3 class="h1" id="toclev_64">C<small class="calibre13">ONCLUSION</small></h3>
<p class="noindent1">The <em class="calibre9">dependency management metrics</em> described in this chapter measure the conformance of a design to a pattern of dependency and abstraction that I think is a “good” pattern. Experience has shown that certain dependencies are good and others are bad. This pattern reflects that experience. However, a metric is not a god; it is merely a measurement against an arbitrary standard. These metrics are imperfect, at best, but it is my hope that you find them useful.</p>
<p class="fn"><a id="ch14fn1" href="part0027.html#ch14fn-1">1</a>. In previous publications, I used the names <em class="calibre9">Efferent</em> and <em class="calibre9">Afferent</em> couplings (Ce and Ca) for <em class="calibre9">Fan-out</em> and Fan-in, respectively. That was just hubris on my part: I liked the metaphor of the central nervous system.</p>
<p class="fn"><a id="ch14fn2" href="part0027.html#ch14fn-2">2</a>. The author begs the reader’s indulgence for the arrogance of borrowing such an important term from astronomy.</p>
<p class="fn"><a id="ch14fn3" href="part0027.html#ch14fn-3">3</a>. In previous publications, I called this metric D′. I see no reason to continue that practice.</p>
</body></html>
