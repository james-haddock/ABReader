<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" xml:lang="en-us" lang="en-us">
  <head>
    <title>Clean Architecture</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="h2f" id="preface"><a id="page_xix" class="calibre3"></a>P<small class="calibre7">REFACE</small></h2>
<p class="noindent">The title of this book is <em class="calibre9">Clean Architecture</em>. That’s an audacious name. Some would even call it arrogant. So why did I choose that title, and why did I write this book?</p>
<p class="noindent">I wrote my very first line of code in 1964, at the age of 12. The year is now 2016, so I have been writing code for more than half a century. In that time, I have learned a few things about how to structure software systems—things that I believe others would likely find valuable.</p>
<p class="noindent">I learned these things by building many systems, both large and small. I have built small embedded systems and large batch processing systems. I have built real-time systems and web systems. I have built console apps, GUI apps, process control apps, games, accounting systems, telecommunications systems, design tools, drawing apps, and many, many others.</p>
<p class="noindent">I have built single-threaded apps, multithreaded apps, apps with few heavy-weight processes, apps with many light-weight processes, multiprocessor apps, database apps, mathematical apps, computational geometry apps, and many, many others.</p>
<p class="noindent"><a id="page_xx"></a>I’ve built a lot of apps. I’ve built a lot of systems. And from them all, and by taking them all into consideration, I’ve learned something startling.</p>
<p class="noindent"><em class="calibre9">The architecture rules are the same!</em></p>
<p class="noindent">This is startling because the systems that I have built have all been so radically different. Why should such different systems all share similar rules of architecture? My conclusion is that <em class="calibre9">the rules of software architecture are independent of every other variable</em>.</p>
<p class="noindent">This is even more startling when you consider the change that has taken place in hardware over the same half-century. I started programming on machines the size of kitchen refrigerators that had half-megahertz cycle times, 4K of core memory, 32K of disk memory, and a 10 character per second teletype interface. I am writing this preface on a bus while touring in South Africa. I am using a MacBook with four i7 cores running at 2.8 gigahertz each. It has 16 gigabytes of RAM, a terabyte of SSD, and a 2880×1800 retina display capable of showing extremely high-definition video. The difference in computational power is staggering. Any reasonable analysis will show that this MacBook is at least 10<sup class="calibre10">22</sup> more powerful than those early computers that I started using half a century ago.</p>
<p class="noindent">Twenty-two orders of magnitude is a very large number. It is the number of angstroms from Earth to Alpha-Centuri. It is the number of electrons in the change in your pocket or purse. And yet that number—that number <em class="calibre9">at least—</em>is the computational power increase that I have experienced in my own lifetime.</p>
<p class="noindent">And with all that vast change in computational power, what has been the effect on the software I write? It’s gotten bigger certainly. I used to think 2000 lines was a big program. After all, it was a full box of cards that weighed 10 pounds. Now, however, a program isn’t really big until it exceeds 100,000 lines.</p>
<p class="noindent">The software has also gotten much more performant. We can do things today that we could scarcely dream about in the 1960s. <em class="calibre9">The Forbin Project</em>, <em class="calibre9">The <a id="page_xxi"></a>Moon Is a Harsh Mistress</em>, and <em class="calibre9">2001: A Space Odyssey</em> all tried to imagine our current future, but missed the mark rather significantly. They all imagined huge machines that gained sentience. What we have instead are impossibly small machines that are still … just machines.{xx}</p>
<p class="noindent">And there is one thing more about the software we have now, compared to the software from back then: <em class="calibre9">It’s made of the same stuff.</em> It’s made of <code class="calibre11">if</code> statements, assignment statements, and <code class="calibre11">while</code> loops.</p>
<p class="noindent">Oh, you might object and say that we’ve got much better languages and superior paradigms. After all, we program in Java, or C#, or Ruby, and we use object-oriented design. True—and yet the code is still just an assemblage of sequence, selection, and iteration, just as it was back in the 1960s and 1950s.</p>
<p class="noindent">When you really look closely at the practice of programming computers, you realize that very little has changed in 50 years. The languages have gotten a little better. The tools have gotten fantastically better. But the basic building blocks of a computer program have not changed.</p>
<p class="noindent">If I took a computer programmer from 1966 forward in time to 2016 and put her<sup class="calibre10"><a id="prefacefn1"></a><a href="part0007.html#prefacefn-1">1</a></sup> in front of my MacBook running IntelliJ and showed her Java, she might need 24 hours to recover from the shock. But then she would be able to write the code. Java just isn’t that different from C, or even from Fortran.</p>
<p class="noindent">And if I transported you back to 1966 and showed you how to write and edit PDP-8 code by punching paper tape on a 10 character per second teletype, you might need 24 hours to recover from the disappointment. But then you would be able to write the code. The code just hasn’t changed that much.</p>
<p class="noindent">That’s the secret: This changelessness of the code is the reason that the rules of software architecture are so consistent across system types. The rules of software architecture are the rules of ordering and assembling the building <a id="page_xxii"></a>blocks of programs. And since those building blocks are universal and haven’t changed, the rules for ordering them are likewise universal and changeless.</p>
<p class="noindent">Younger programmers might think this is nonsense. They might insist that everything is new and different nowadays, that the rules of the past are past and gone. If that is what they think, they are sadly mistaken. The rules have not changed. Despite all the new languages, and all the new frameworks, and all the paradigms, the rules are the same now as they were when Alan Turing wrote the first machine code in 1946.</p>
<p class="noindent">But one thing has changed: Back then, we didn’t know what the rules were. Consequently, we broke them, over and over again. Now, with half a century of experience behind us, we have a grasp of those rules.</p>
<p class="noindent">And it is those rules—those timeless, changeless, rules—that this book is all about.</p>
<div class="box">
<p class="noindent1">Register your copy of <em class="calibre9">Clean Architecture</em> on the InformIT site for convenient access to updates and/or corrections as they become available. To start the registration process, go to <a href="http://informit.com/register">informit.com/register</a> and log in or create an account. Enter the product ISBN (9780134494166) and click Submit. Look on the Registered Products tab for an Access Bonus Content link next to this product, and follow that link to access the bonus materials.</p>
</div>
<p class="fn"><a id="prefacefn-1"></a><a href="part0007.html#prefacefn1">1</a>. And she very likely would be female since, back then, women made up a large fraction of programmers.</p>
</body></html>
