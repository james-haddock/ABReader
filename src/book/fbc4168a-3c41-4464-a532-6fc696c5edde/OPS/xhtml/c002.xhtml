<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>2 Building Abstractions with Data</title>
<link href="../styles/MIT_style.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:5e22faf7-6d97-43f5-a05d-571a507bcb19" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<h1><a id="c2-title-0001"/><span class="chapterNumber">2</span><br/><span class="chapterTitle">Building Abstractions with Data</span></h1>
</header>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c2-para-0001"/>We now come to the decisive step of mathematical abstraction: we forget about what the symbols stand for. . . .[The mathematician] need not be idle; there are many operations which he may carry out with these symbols, without ever having to look at the things they stand for.</p>
<p class="quote-epigraphsource">—Hermann Weyl, <i>The Mathematical Way of Thinking</i></p></blockquote>
<p class="paraaftertitle"><a id="c2-para-0002"/>We concentrated in chapter 1 on computational processes and on the role of functions in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine functions to form compound functions through composition, conditionals, and the use of parameters, and how to abstract processes by using function declarations. We saw that a function can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in functions. We also saw that higher-order functions enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming.</p>
<p><a id="c2-para-0003"/>In this chapter we are going to look at more complex data. All the functions in chapter 1 operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining functions to form compound functions, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form <i>compound data</i>.</p>
<p><a id="c2-para-0004"/>Why do we want compound data in a programming language? For the same reasons that we want compound functions: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to declare functions enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language.</p>
<p><a id="c2-para-0005"/>Consider the task of designing a system to perform arithmetic with rational numbers. We could imagine an operation <span class="KeyTerm1">add_rat</span> that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where <span class="KeyTerm1">add_rat</span> would be implemented by two functions (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could “glue together” a numerator and denominator to form a pair—a <i>compound data object</i>—that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit.</p>
<p><a id="c2-para-0006"/>The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called <i>data abstraction</i>. We will see how data abstraction makes programs much easier to design, maintain, and modify.</p>
<p><a id="c2-para-0007"/>The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a “linear combination” <i>ax</i> + <i>by</i>. We might like to write a function that would accept <i>a</i>, <i>b</i>, <i>x</i>, and <i>y</i> as arguments and return the value of <i>ax</i> + <i>by</i>. This presents no difficulty if the arguments are to be numbers, because we can readily declare the function</p>
<p class="Sp-text-1"><a id="c2-para-0008"/><b>function</b> linear_combination(a, b, x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0009"/>    <b>return</b> a * x + b * y;</p>
<p class="Sp-text-1"><a id="c2-para-0010"/>}</p>
<p class="paracontinue"><a id="c2-para-0011"/>But suppose we are not concerned only with numbers. Suppose we would like to describe a process that forms linear combinations whenever addition and multiplication are defined—for rational numbers, complex numbers, polynomials, or whatever. We could express this as a function of the form</p>
<p class="Sp-text-1"><a id="c2-para-0013"/><b>function</b> linear_combination(a, b, x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0014"/>    <b>return</b> add(mul(a, x), mul(b, y));</p>
<p class="Sp-text-1"><a id="c2-para-0015"/>}</p>
<p class="paracontinue"><a id="c2-para-0016"/>where <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span> are not the primitive functions <span class="KeyTerm1">+</span> and <span class="KeyTerm1">*</span> but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments <span class="KeyTerm1">a</span>, <span class="KeyTerm1">b</span>, <span class="KeyTerm1">x</span>, and <span class="KeyTerm1">y</span>. The key point is that the only thing <span class="KeyTerm1">linear_combination</span> should need to know about <span class="KeyTerm1">a</span>, <span class="KeyTerm1">b</span>, <span class="KeyTerm1">x</span>, and <span class="KeyTerm1">y</span> is that the functions <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span> will perform the appropriate manipulations. From the perspective of the function <span class="KeyTerm1">linear_combination</span>, it is irrelevant what <span class="KeyTerm1">a</span>, <span class="KeyTerm1">b</span>, <span class="KeyTerm1">x</span>, and <span class="KeyTerm1">y</span> are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a function such as <span class="KeyTerm1">linear_combination</span> to pass its arguments along to <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span> without having to know their detailed structure.<a id="c2-fn-0001a"/><a href="#c2-fn-0001"><sup>1</sup></a></p>
<p><a id="c2-para-0017"/>We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound functions, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable <i>abstraction barriers</i> between different parts of a program.</p>
<p><a id="c2-para-0018"/>We will see that the key to forming compound data is that a programming language should provide some kind of “glue” so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special “data” operations at all, only functions. This will further blur the distinction between “function” and “data,” which was already becoming tenuous toward the end of chapter 1. We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of <i>closure</i>—that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as <i>conventional interfaces</i> for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure.</p>
<p><a id="c2-para-0019"/>We will then augment the representational power of our language by introducing <i>symbolic expressions</i>—data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information. Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement <i>generic operations</i>, which must handle many different types of data. Maintaining modularity in the presence of generic operations requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce <i>data-directed programming</i> as a technique that allows individual data representations to be designed in isolation and then combined <i>additively</i> (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials.</p>
<section><a id="c2-title-0002"/>
<section>
<h2><a id="c2-sec-0002"/><span>2.1</span> <a id="c2-title-0003"/>Introduction to Data Abstraction</h2>
<p class="paraaftertitle"><a id="c2-para-0020"/>In section 1.1.8, we noted that a function used as an element in creating a more complex function could be regarded not only as a collection of particular operations but also as a functional abstraction. That is, the details of how the function was implemented could be suppressed, and the particular function itself could be replaced by any other function with the same overall behavior. In other words, we could make an abstraction that would separate the way the function would be used from the details of how the function would be implemented in terms of more primitive functions. The analogous notion for compound data is called <i>data abstraction</i>. Data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed from more primitive data objects.</p>
<p><a id="c2-para-0021"/>The basic idea of data abstraction is to structure the programs that are to use compound data objects so that they operate on “abstract data.” That is, our programs should use data in such a way as to make no assumptions about the data that are not strictly necessary for performing the task at hand. At the same time, a “concrete” data representation is defined independent of the programs that use the data. The interface between these two parts of our system will be a set of functions, called <i>selectors</i> and <i>constructors</i>, that implement the abstract data in terms of the concrete representation. To illustrate this technique, we will consider how to design a set of functions for manipulating rational numbers.</p>
<section>
<h3><a id="c2-sec-0003"/><span>2.1.1</span> <a id="c2-title-0004"/>Example: Arithmetic Operations for Rational Numbers</h3>
<p class="paraaftertitle"><a id="c2-para-0022"/>Suppose we want to do arithmetic with rational numbers. We want to be able to add, subtract, multiply, and divide them and to test whether two rational numbers are equal.</p>
<p><a id="c2-para-0023"/>Let us begin by assuming that we already have a way of constructing a rational number from a numerator and a denominator. We also assume that, given a rational number, we have a way of extracting (or selecting) its numerator and its denominator. Let us further assume that the constructor and selectors are available as functions:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">make_rat(</span><i>n</i><span class="KeyTerm1">,</span> <i>d</i><span class="KeyTerm1">)</span> returns the rational number whose numerator is the integer <i>n</i> and whose denominator is the integer <i>d</i>.</li>
<li><span class="KeyTerm1">numer(</span><i>x</i><span class="KeyTerm1">)</span> returns the numerator of the rational number <i>x</i>.</li>
<li><span class="KeyTerm1">denom(</span><i>x</i><span class="KeyTerm1">)</span> returns the denominator of the rational number <i>x</i>.</li>
</ul>

<p><a id="c2-para-0027"/>We are using here a powerful strategy of synthesis: <i>wishful thinking</i>. We haven't yet said how a rational number is represented, or how the functions <span class="KeyTerm1">numer</span>, <span class="KeyTerm1">denom</span>, and <span class="KeyTerm1">make_rat</span> should be implemented. Even so, if we did have these three functions, we could then add, subtract, multiply, divide, and test equality by using the following relations:</p>
<p><a id="c2-para-0028"/></p>
<figure id="c2-fig-0001"><img alt="c2-fig-5001.jpg" src="../images/c2-fig-5001.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p><a id="c2-para-0029"/>We can express these rules as functions:</p>
<p class="Sp-text-1"><a id="c2-para-0030"/><b>function</b> add_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0031"/>    <b>return</b> make_rat(numer(x) * denom(y) + numer(y) * denom(x),</p>
<p class="Sp-text-1"><a id="c2-para-0032"/>                    denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c2-para-0033"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0034"/><b>function</b> sub_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0035"/>    <b>return</b> make_rat(numer(x) * denom(y) - numer(y) * denom(x),</p>
<p class="Sp-text-1"><a id="c2-para-0036"/>                    denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c2-para-0037"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0038"/><b>function</b> mul_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0039"/>    <b>return</b> make_rat(numer(x) * numer(y),</p>
<p class="Sp-text-1"><a id="c2-para-0040"/>                    denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c2-para-0041"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0042"/><b>function</b> div_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0043"/>    <b>return</b> make_rat(numer(x) * denom(y),</p>
<p class="Sp-text-1"><a id="c2-para-0044"/>                    denom(x) * numer(y));</p>
<p class="Sp-text-1"><a id="c2-para-0045"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0046"/><b>function</b> equal_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0047"/>    <b>return</b> numer(x) * denom(y) === numer(y) * denom(x);</p>
<p class="Sp-text-1"><a id="c2-para-0048"/>}</p>
<p><a id="c2-para-0049"/>Now we have the operations on rational numbers defined in terms of the selector</p>
<p class="paracontinue"><a id="c2-para-0050"/>and constructor functions <span class="KeyTerm1">numer</span>, <span class="KeyTerm1">denom</span>, and <span class="KeyTerm1">make_rat</span>. But we haven't yet defined these. What we need is some way to glue together a numerator and a denominator to form a rational number.</p>
<section>
<h5><a id="c2-sec-0004"/><a id="c2-title-0005"/>Pairs</h5>
<p class="paraaftertitle"><a id="c2-para-0051"/>To enable us to implement the concrete level of our data abstraction, our JavaScript environment provides a compound structure called a <i>pair</i>, which can be constructed with the primitive function <span class="KeyTerm1">pair</span>. This function takes two arguments and returns a compound data object that contains the two arguments as parts. Given a pair, we can extract the parts using the primitive functions <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span>. Thus, we can use <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> as follows:</p>
<p class="Sp-text-1"><a id="c2-para-0052"/><b>const</b> x = pair(1, 2);</p>
<p class="Sp-text-1"><a id="c2-para-0053"/>head(x);</p>
<p class="Sp-text-1"><a id="c2-para-0054"/><i>1</i></p>
<p class="Sp-text-1"><a id="c2-para-0055"/>tail(x);</p>
<p class="Sp-text-1"><a id="c2-para-0056"/><i>2</i></p>
<p><a id="c2-para-0057"/>Notice that a pair is a data object that can be given a name and manipulated, just like a primitive data object. Moreover, <span class="KeyTerm1">pair</span> can be used to form pairs whose elements are pairs, and so on:</p>
<p class="Sp-text-1"><a id="c2-para-0058"/><b>const</b> x = pair(1, 2);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0059"/><b>const</b> y = pair(3, 4);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0060"/><b>const</b> z = pair(x, y);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0061"/>head(head(z));</p>
<p class="Sp-text-1"><a id="c2-para-0062"/><i>1</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0063"/>head(tail(z));</p>
<p class="Sp-text-1"><a id="c2-para-0064"/><i>3</i></p>
<p class="paracontinue"><a id="c2-para-0065"/>In section 2.2 we will see how this ability to combine pairs means that pairs can be used as general-purpose building blocks to create all sorts of complex data structures. The single compound-data primitive <i>pair</i>, implemented by the functions <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>, is the only glue we need. Data objects constructed from pairs are called <i>list-structured</i> data.</p>
</section>
<section>
<h5><a id="c2-sec-0005"/><a id="c2-title-0006"/>Representing rational numbers</h5>
<p class="paraaftertitle"><a id="c2-para-0066"/>Pairs offer a natural way to complete the rational-number system. Simply represent a rational number as a pair of two integers: a numerator and a denominator. Then <span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, and <span class="KeyTerm1">denom</span> are readily implemented as follows:<a id="c2-fn-0002a"/><a href="#c2-fn-0002"><sup>2</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0067"/><b>function</b> make_rat(n, d) { <b>return</b> pair(n, d); }</p>
<p class="Sp-text-1"><a id="c2-para-0068"/><b>function</b> numer(x) { <b>return</b> head(x); }</p>
<p class="Sp-text-1"><a id="c2-para-0069"/><b>function</b> denom(x) { <b>return</b> tail(x); }</p>
<p class="paracontinue"><a id="c2-para-0073"/>Also, in order to display the results of our computations, we can print rational numbers by printing the numerator, a slash, and the denominator. We use the primitive function <span class="KeyTerm1">stringify</span> to turn any value (here a number) into a string. The operator <span class="KeyTerm1">+</span> in JavaScript is <i>overloaded</i>; it can be applied to two numbers or to two strings, and in the latter case it returns the result of <i>concatenating</i> the two strings.<a id="c2-fn-0003a"/><a href="#c2-fn-0003"><sup>3</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0074"/><b>function</b> print_rat(x) {</p>
<p class="Sp-text-1"><a id="c2-para-0075"/>    <b>return</b> display(stringify(numer(x)) + " / " + stringify(denom(x)));</p>
<p class="Sp-text-1"><a id="c2-para-0076"/>}</p>
<p class="paracontinue"><a id="c2-para-0077"/>Now we can try our rational-number functions:<a id="c2-fn-0004a"/><a href="#c2-fn-0004"><sup>4</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0078"/><b>const</b> one_half = make_rat(1, 2);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0079"/>print_rat(one_half);</p>
<p class="Sp-text-1"><a id="c2-para-0080"/><i>"1 / 2"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0081"/><b>const</b> one_third = make_rat(1, 3);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0082"/>print_rat(add_rat(one_half, one_third));</p>
<p class="Sp-text-1"><a id="c2-para-0083"/><i>"5 / 6"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0084"/>print_rat(mul_rat(one_half, one_third));</p>
<p class="Sp-text-1"><a id="c2-para-0085"/><i>"1 / 6"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0086"/>print_rat(add_rat(one_third, one_third));</p>
<p class="Sp-text-1"><a id="c2-para-0087"/><i>"6 / 9"</i></p>
<p><a id="c2-para-0088"/>As the final example shows, our rational-number implementation does not reduce rational numbers to lowest terms. We can remedy this by changing <span class="KeyTerm1">make_rat</span>. If we have a <span class="KeyTerm1">gcd</span> function like the one in section 1.2.5 that produces the greatest common divisor of two integers, we can use <span class="KeyTerm1">gcd</span> to reduce the numerator and the denominator to lowest terms before constructing the pair:</p>
<p class="Sp-text-1"><a id="c2-para-0089"/><b>function</b> make_rat(n, d) {</p>
<p class="Sp-text-1"><a id="c2-para-0090"/>    <b>const</b> g = gcd(n, d);</p>
<p class="Sp-text-1"><a id="c2-para-0091"/>    <b>return</b> pair(n / g, d / g);</p>
<p class="Sp-text-1"><a id="c2-para-0092"/>}</p>
<p class="paracontinue"><a id="c2-para-0093"/>Now we have</p>
<p class="Sp-text-1"><a id="c2-para-0094"/>print_rat(add_rat(one_third, one_third));</p>
<p class="Sp-text-1"><a id="c2-para-0095"/><i>"2 / 3"</i></p>
<p class="paracontinue"><a id="c2-para-0096"/>as desired. This modification was accomplished by changing the constructor <span class="KeyTerm1">make_ rat</span> without changing any of the functions (such as <span class="KeyTerm1">add_rat</span> and <span class="KeyTerm1">mul_rat</span>) that implement the actual operations.</p>
</section>
<section>
<h5><a id="c2-sec-0006"/><a id="c2-title-0007"/>Exercise 2.1</h5>
<p class="paraaftertitle"><a id="c2-para-0097"/>Define a better version of <span class="KeyTerm1">make_rat</span> that handles both positive and negative arguments. The function <span class="KeyTerm1">make_rat</span> should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.</p>
</section>
</section>
<section>
<h3><a id="c2-sec-0007"/><span>2.1.2</span> <a id="c2-title-0008"/>Abstraction Barriers</h3>
<p class="paraaftertitle"><a id="c2-para-0098"/>Before continuing with more examples of compound data and data abstraction, let us consider some of the issues raised by the rational-number example. We defined the rational-number operations in terms of a constructor <span class="KeyTerm1">make_rat</span> and selectors <span class="KeyTerm1">numer</span> and <span class="KeyTerm1">denom</span>. In general, the underlying idea of data abstraction is to identify for each type of data object a basic set of operations in terms of which all manipulations of data objects of that type will be expressed, and then to use only those operations in manipulating the data.</p>
<p><a id="c2-para-0099"/>We can envision the structure of the rational-number system as shown in <a id="c2-fig-0002a"/><a href="#c2-fig-0002">figure 2.1</a>. The horizontal lines represent <i>abstraction barriers</i> that isolate different “levels” of the system. At each level, the barrier separates the programs (above) that use the data abstraction from the programs (below) that implement the data abstraction. Programs that use rational numbers manipulate them solely in terms of the functions supplied “for public use” by the rational-number package: <span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">sub_rat</span>, <span class="KeyTerm1">mul_rat</span>, <span class="KeyTerm1">div_rat</span>, and <span class="KeyTerm1">equal_rat</span>. These, in turn, are implemented solely in terms of the constructor and selectors <span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, and <span class="KeyTerm1">denom</span>, which themselves are implemented in terms of pairs. The details of how pairs are implemented are irrelevant to the rest of the rational-number package so long as pairs can be manipulated by the use of <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>. In effect, functions at each level are the interfaces that define the abstraction barriers and connect the different levels. This simple idea has many advantages. One advantage is that it makes programs much easier to maintain and to modify. Any complex data structure can be represented in a variety of ways with the primitive data structures provided by a programming language. Of course, the choice of representation influences the programs that operate on it; thus, if the representation were to be changed at some later time, all such programs might have to be modified accordingly. This task could be time-consuming and expensive in the case of large programs unless the dependence on the representation were to be confined by design to a very few program modules.</p>
<figure id="c2-fig-0002"><img alt="c2-fig-0001.jpg" src="../images/c2-fig-0001.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0002a">Figure 2.1</a></span> <a id="c2-para-0100"/>Data-abstraction barriers in the rational-number package.</p></figcaption></figure>
<p><a id="c2-para-0101"/>For example, an alternate way to address the problem of reducing rational numbers to lowest terms is to perform the reduction whenever we access the parts of a rational number, rather than when we construct it. This leads to different constructor and selector functions:</p>
<p class="Sp-text-1"><a id="c2-para-0102"/><b>function</b> make_rat(n, d) {</p>
<p class="Sp-text-1"><a id="c2-para-0103"/>    <b>return</b> pair(n, d);</p>
<p class="Sp-text-1"><a id="c2-para-0104"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0105"/><b>function</b> numer(x) {</p>
<p class="Sp-text-1"><a id="c2-para-0106"/>    <b>const</b> g = gcd(head(x), tail(x));</p>
<p class="Sp-text-1"><a id="c2-para-0107"/>    <b>return</b> head(x) / g;</p>
<p class="Sp-text-1"><a id="c2-para-0108"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0109"/><b>function</b> denom(x) {</p>
<p class="Sp-text-1"><a id="c2-para-0110"/>    <b>const</b> g = gcd(head(x), tail(x));</p>
<p class="Sp-text-1"><a id="c2-para-0111"/>    <b>return</b> tail(x) / g;</p>
<p class="Sp-text-1"><a id="c2-para-0112"/>}</p>
<p class="paracontinue"><a id="c2-para-0113"/>The difference between this implementation and the previous one lies in when we compute the <span class="KeyTerm1">gcd</span>. If in our typical use of rational numbers we access the numerators and denominators of the same rational numbers many times, it would be preferable to compute the <span class="KeyTerm1">gcd</span> when the rational numbers are constructed. If not, we may be better off waiting until access time to compute the <span class="KeyTerm1">gcd</span>. In any case, when we change from one representation to the other, the functions <span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">sub_rat</span>, and so on do not have to be modified at all.</p>
<p><a id="c2-para-0114"/>Constraining the dependence on the representation to a few interface functions helps us design programs as well as modify them, because it allows us to maintain the flexibility to consider alternate implementations. To continue with our simple example, suppose we are designing a rational-number package and we can't decide initially whether to perform the <span class="KeyTerm1">gcd</span> at construction time or at selection time. The data-abstraction methodology gives us a way to defer that decision without losing the ability to make progress on the rest of the system.</p>
<section>
<h5><a id="c2-sec-0008"/><a id="c2-title-0009"/>Exercise 2.2</h5>
<p class="paraaftertitle"><a id="c2-para-0115"/>Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Declare a constructor <span class="KeyTerm1">make_segment</span> and selectors <span class="KeyTerm1">start_segment</span> and <span class="KeyTerm1">end_segment</span> that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the <i>x</i> coordinate and the <i>y</i> coordinate. Accordingly, specify a constructor <span class="KeyTerm1">make_point</span> and selectors <span class="KeyTerm1">x_point</span> and <span class="KeyTerm1">y_point</span> that define this representation. Finally, using your selectors and constructors, declare a function <span class="KeyTerm1">midpoint_segment</span> that takes a line segment as argument and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your functions, you'll need a way to print points:</p>
<p class="Sp-text-1"><a id="c2-para-0116"/><b>function</b> print_point(p) {</p>
<p class="Sp-text-1"><a id="c2-para-0117"/>    <b>return</b> display("(" + stringify(x_point(p)) + ", "</p>
<p class="Sp-text-1"><a id="c2-para-0118"/>                       + stringify(y_point(p)) + ")");</p>
<p class="Sp-text-1"><a id="c2-para-0119"/>}</p>
</section>
<section>
<h5><a id="c2-sec-0009"/><a id="c2-title-0010"/>Exercise 2.3</h5>
<p class="paraaftertitle"><a id="c2-para-0120"/>Implement a representation for rectangles in a plane. (Hint: You may want to make use of exercise 2.2.) In terms of your constructors and selectors, create functions that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area functions will work using either representation?</p>
</section>
</section>
<section>
<h3><a id="c2-sec-0010"/><span>2.1.3</span> <a id="c2-title-0011"/>What Is Meant by Data?</h3>
<p class="paraaftertitle"><a id="c2-para-0121"/>We began the rational-number implementation in section 2.1.1 by implementing the rational-number operations <span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">sub_rat</span>, and so on in terms of three unspecified functions: <span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, and <span class="KeyTerm1">denom</span>. At that point, we could think of the operations as being defined in terms of data objects—numerators, denominators, and rational numbers—whose behavior was specified by the latter three functions.</p>
<p><a id="c2-para-0122"/>But exactly what is meant by <i>data</i>? It is not enough to say “whatever is implemented by the given selectors and constructors.” Clearly, not every arbitrary set of three functions can serve as an appropriate basis for the rational-number implementation. We need to guarantee that, if we construct a rational number <span class="KeyTerm1">x</span> from a pair of integers <span class="KeyTerm1">n</span> and <span class="KeyTerm1">d</span>, then extracting the <span class="KeyTerm1">numer</span> and the <span class="KeyTerm1">denom</span> of <span class="KeyTerm1">x</span> and dividing them should yield the same result as dividing <span class="KeyTerm1">n</span> by <span class="KeyTerm1">d</span>. In other words, <span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, and <span class="KeyTerm1">denom</span> must satisfy the condition that, for any integer <span class="KeyTerm1">n</span> and any nonzero integer <span class="KeyTerm1">d</span>, if <span class="KeyTerm1">x</span> is <span class="KeyTerm1">make_rat(n, d)</span>, then</p>
<p><a id="c2-para-0123"/></p>
<figure id="c2-fig-0003"><img alt="c2-fig-5002.jpg" src="../images/c2-fig-5002.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c2-para-0124"/>In fact, this is the only condition <span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, and <span class="KeyTerm1">denom</span> must fulfill in order to form a suitable basis for a rational-number representation. In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these functions must fulfill in order to be a valid representation.<a id="c2-fn-0005a"/><a href="#c2-fn-0005"><sup>5</sup></a></p>
<p><a id="c2-para-0125"/>This point of view can serve to define not only “high-level” data objects, such as rational numbers, but lower-level objects as well. Consider the notion of a pair, which we used in order to define our rational numbers. We never actually said what a pair was, only that the language supplied functions <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> for operating on pairs. But the only thing we need to know about these three operations is that if we glue two objects together using <span class="KeyTerm1">pair</span> we can retrieve the objects using <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span>. That is, the operations satisfy the condition that, for any objects <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span>, if <span class="KeyTerm1">z</span> is <span class="KeyTerm1">pair(x, y)</span> then <span class="KeyTerm1">head(z)</span> is <span class="KeyTerm1">x</span> and <span class="KeyTerm1">tail(z)</span> is <span class="KeyTerm1">y</span>. Indeed, we mentioned that these three functions are included as primitives in our language. However, any triple of functions that satisfies the above condition can be used as the basis for implementing pairs. This point is illustrated strikingly by the fact that we could implement <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> without using any data structures at all but only using functions. Here are the definitions:<a id="c2-fn-0006a"/><a href="#c2-fn-0006"><sup>6</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0126"/><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0127"/>    <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c2-para-0128"/>        <b>return</b> m === 0</p>
<p class="Sp-text-1"><a id="c2-para-0129"/>               ? x</p>
<p class="Sp-text-1"><a id="c2-para-0130"/>               : m === 1</p>
<p class="Sp-text-1"><a id="c2-para-0131"/>               ? y</p>
<p class="Sp-text-1"><a id="c2-para-0132"/>               : error(m, "argument not 0 or 1 – pair");</p>
<p class="Sp-text-1"><a id="c2-para-0133"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-0134"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c2-para-0135"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0136"/><b>function</b> head(z) { <b>return</b> z(0); }</p>
<p class="Sp-text-1"><a id="c2-para-0137"/><b>function</b> tail(z) { <b>return</b> z(1); }</p>
<p class="paracontinue"><a id="c2-para-0138"/>This use of functions corresponds to nothing like our intuitive notion of what data should be. Nevertheless, all we need to do to show that this is a valid way to represent pairs is to verify that these functions satisfy the condition given above.</p>
<p><a id="c2-para-0139"/>The subtle point to notice is that the value returned by <span class="KeyTerm1">pair(x, y)</span> is a function—namely the internally defined function <span class="KeyTerm1">dispatch</span>, which takes one argument and returns either <span class="KeyTerm1">x</span> or <span class="KeyTerm1">y</span> depending on whether the argument is 0 or 1. Correspondingly, <span class="KeyTerm1">head(z)</span> is defined to apply <span class="KeyTerm1">z</span> to 0. Hence, if <span class="KeyTerm1">z</span> is the function formed by <span class="KeyTerm1">pair(x, y)</span>, then <span class="KeyTerm1">z</span> applied to 0 will yield <span class="KeyTerm1">x</span>. Thus, we have shown that <span class="KeyTerm1">head(pair(x, y))</span> yields <span class="KeyTerm1">x</span>, as desired. Similarly, <span class="KeyTerm1">tail(pair(x, y))</span> applies the function returned by <span class="KeyTerm1">pair(x, y)</span> to 1, which returns <span class="KeyTerm1">y</span>. Therefore, this functional implementation of pairs is a valid implementation, and if we access pairs using only <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> we cannot distinguish this implementation from one that uses “real” data structures.</p>
<p><a id="c2-para-0141"/>The point of exhibiting the functional representation of pairs is not that our language works this way (an efficient implementation of pairs might use JavaScript's primitive <i>vector</i> data structure) but that it could work this way. The functional representation, although obscure, is a perfectly adequate way to represent pairs, since it fulfills the only conditions that pairs need to fulfill. This example also demonstrates that the ability to manipulate functions as objects automatically provides the ability to represent compound data. This may seem a curiosity now, but functional representations of data will play a central role in our programming repertoire. This style of programming is often called <i>message passing</i>, and we will be using it as a basic tool in chapter 3 when we address the issues of modeling and simulation.</p>
<section>
<h5><a id="c2-sec-0011"/><a id="c2-title-0012"/>Exercise 2.4</h5>
<p class="paraaftertitle"><a id="c2-para-0142"/>Here is an alternative functional representation of pairs. For this representation, verify that <span class="KeyTerm1">head(pair(x, y))</span> yields <span class="KeyTerm1">x</span> for any objects <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span>.</p>
<p class="Sp-text-1"><a id="c2-para-0143"/><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0144"/>    <b>return</b> m =&gt; m(x, y);</p>
<p class="Sp-text-1"><a id="c2-para-0145"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0146"/><b>function</b> head(z) {</p>
<p class="Sp-text-1"><a id="c2-para-0147"/>    <b>return</b> z((p, q) =&gt; p);</p>
<p class="Sp-text-1"><a id="c2-para-0148"/>}</p>
<p class="paracontinue"><a id="c2-para-0149"/>What is the corresponding definition of <span class="KeyTerm1">tail</span>? (Hint: To verify that this works, make use of the substitution model of section 1.1.5.)</p>
</section>
<section>
<h5><a id="c2-sec-0012"/><a id="c2-title-0013"/>Exercise 2.5</h5>
<p class="paraaftertitle"><a id="c2-para-0150"/>Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair <i>a</i> and <i>b</i> as the integer that is the product 2<i><sup>a</sup></i>3<i><sup>b</sup></i>. Give the corresponding definitions of the functions <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>.</p>
</section>
<section>
<h5><a id="c2-sec-0013"/><a id="c2-title-0014"/>Exercise 2.6</h5>
<p class="paraaftertitle"><a id="c2-para-0151"/>In case representing pairs as functions (exercise 2.4) wasn't mind-boggling enough, consider that, in a language that can manipulate functions, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as</p>
<p class="Sp-text-1"><a id="c2-para-0152"/><b>const</b> zero = f =&gt; x =&gt; x;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0153"/><b>function</b> add_1(n) {</p>
<p class="Sp-text-1"><a id="c2-para-0154"/>    <b>return</b> f =&gt; x =&gt; f(n(f)(x));</p>
<p class="Sp-text-1"><a id="c2-para-0155"/>}</p>
<p class="paracontinue"><a id="c2-para-0156"/>This representation is known as <i>Church numerals</i>, after its inventor, Alonzo Church, the logician who invented the <i>λ</i> calculus.</p>
<p><a id="c2-para-0157"/>Define <span class="KeyTerm1">one</span> and <span class="KeyTerm1">two</span> directly (not in terms of <span class="KeyTerm1">zero</span> and <span class="KeyTerm1">add_1</span>). (Hint: Use substitution to evaluate <span class="KeyTerm1">add_1(zero)</span>). Give a direct definition of the addition function <span class="KeyTerm1">plus</span> (not in terms of repeated application of <span class="KeyTerm1">add_1</span>).</p>
</section>
</section>
<section>
<h3><a id="c2-sec-0014"/><span>2.1.4</span> <a id="c2-title-0015"/>Extended Exercise: Interval Arithmetic</h3>
<p class="paraaftertitle"><a id="c2-para-0158"/>Alyssa P. Hacker is designing a system to help people solve engineering problems. One feature she wants to provide in her system is the ability to manipulate inexact quantities (such as measured parameters of physical devices) with known precision, so that when computations are done with such approximate quantities the results will be numbers of known precision.</p>
<p><a id="c2-para-0159"/>Electrical engineers will be using Alyssa's system to compute electrical quantities. It is sometimes necessary for them to compute the value of a parallel equivalent resistance <i>R<sub>p</sub></i> of two resistors <i>R</i><sub>1</sub> and <i>R</i><sub>2</sub> using the formula</p>
<p><a id="c2-para-0160"/></p>
<figure id="c2-fig-0004"><img alt="c2-fig-5003.jpg" src="../images/c2-fig-5003.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c2-para-0161"/>Resistance values are usually known only up to some tolerance guaranteed by the manufacturer of the resistor. For example, if you buy a resistor labeled “6.8 ohms with 10% tolerance” you can only be sure that the resistor has a resistance between 6.8 – 0.68 = 6.12 and 6.8 + 0.68 = 7.48 ohms. Thus, if you have a 6.8-ohm 10% resistor in parallel with a 4.7-ohm 5% resistor, the resistance of the combination can range from about 2.58 ohms (if the two resistors are at the lower bounds) to about 2.97 ohms (if the two resistors are at the upper bounds).</p>
<p><a id="c2-para-0162"/>Alyssa's idea is to implement “interval arithmetic” as a set of arithmetic operations for combining “intervals” (objects that represent the range of possible values of an inexact quantity). The result of adding, subtracting, multiplying, or dividing two intervals is itself an interval, representing the range of the result.</p>
<p><a id="c2-para-0163"/>Alyssa postulates the existence of an abstract object called an “interval” that has two endpoints: a lower bound and an upper bound. She also presumes that, given the endpoints of an interval, she can construct the interval using the data constructor <span class="KeyTerm1">make_interval</span>. Alyssa first writes a function for adding two intervals. She reasons that the minimum value the sum could be is the sum of the two lower bounds and the maximum value it could be is the sum of the two upper bounds:</p>
<p class="Sp-text-1"><a id="c2-para-0164"/><b>function</b> add_interval(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0165"/>    <b>return</b> make_interval(lower_bound(x) + lower_bound(y),</p>
<p class="Sp-text-1"><a id="c2-para-0166"/>                         upper_bound(x) + upper_bound(y));</p>
<p class="Sp-text-1"><a id="c2-para-0167"/>}</p>
<p class="paracontinue"><a id="c2-para-0168"/>Alyssa also works out the product of two intervals by finding the minimum and the maximum of the products of the bounds and using them as the bounds of the resulting interval. (The functions <span class="KeyTerm1">math_min</span> and <span class="KeyTerm1">math_max</span> are primitives that find the minimum or maximum of any number of arguments.)</p>
<p class="Sp-text-1"><a id="c2-para-0169"/><b>function</b> mul_interval(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0170"/>    <b>const</b> p1 = lower_bound(x) * lower_bound(y); </p>
<p class="Sp-text-1"><a id="c2-para-0171"/>    <b>const</b> p2 = lower_bound(x) * upper_bound(y);</p>
<p class="Sp-text-1"><a id="c2-para-0172"/>    <b>const</b> p3 = upper_bound(x) * lower_bound(y);</p>
<p class="Sp-text-1"><a id="c2-para-0173"/>    <b>const</b> p4 = upper_bound(x) * upper_bound(y);</p>
<p class="Sp-text-1"><a id="c2-para-0174"/>    <b>return</b> make_interval(math_min(p1, p2, p3, p4),</p>
<p class="Sp-text-1"><a id="c2-para-0175"/>                         math_max(p1, p2, p3, p4));</p>
<p class="Sp-text-1"><a id="c2-para-0176"/>}</p>
<p class="paracontinue"><a id="c2-para-0177"/>To divide two intervals, Alyssa multiplies the first by the reciprocal of the second. Note that the bounds of the reciprocal interval are the reciprocal of the upper bound and the reciprocal of the lower bound, in that order.</p>
<p class="Sp-text-1"><a id="c2-para-0178"/><b>function</b> div_interval(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-0179"/>    <b>return</b> mul_interval(x, make_interval(1 / upper_bound(y),</p>
<p class="Sp-text-1"><a id="c2-para-0180"/>                                         1 / lower_bound(y)));</p>
<p class="Sp-text-1"><a id="c2-para-0181"/>}</p>
<section>
<h5><a id="c2-sec-0015"/><a id="c2-title-0016"/>Exercise 2.7</h5>
<p class="paraaftertitle"><a id="c2-para-0182"/>Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor:</p>
<p class="Sp-text-1"><a id="c2-para-0183"/><b>function</b> make_interval(x, y) { <b>return</b> pair(x, y); }</p>
<p class="paracontinue"><a id="c2-para-0184"/>Define selectors <span class="KeyTerm1">upper_bound</span> and <span class="KeyTerm1">lower_bound</span> to complete the implementation.</p>
</section>
<section>
<h5><a id="c2-sec-0016"/><a id="c2-title-0017"/>Exercise 2.8</h5>
<p class="paraaftertitle"><a id="c2-para-0185"/>Using reasoning analogous to Alyssa's, describe how the difference of two intervals may be computed. Define a corresponding subtraction function, called <span class="KeyTerm1">sub_interval</span>.</p>
</section>
<section>
<h5><a id="c2-sec-0017"/><a id="c2-title-0018"/>Exercise 2.9</h5>
<p class="paraaftertitle"><a id="c2-para-0186"/>The <i>width</i> of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.</p>
</section>
<section>
<h5><a id="c2-sec-0018"/><a id="c2-title-0019"/>Exercise 2.10</h5>
<p class="paraaftertitle"><a id="c2-para-0187"/>Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Modify Alyssa's program to check for this condition and to signal an error if it occurs.</p>
</section>
<section>
<h5><a id="c2-sec-0019"/><a id="c2-title-0020"/>Exercise 2.11</h5>
<p class="paraaftertitle"><a id="c2-para-0188"/>In passing, Ben also cryptically comments: “By testing the signs of the endpoints of the intervals, it is possible to break <span class="KeyTerm1">mul_interval</span> into nine cases, only one of which requires more than two multiplications.” Rewrite this function using Ben's suggestion.</p>
<p><a id="c2-para-0189"/>After debugging her program, Alyssa shows it to a potential user, who complains that her program solves the wrong problem. He wants a program that can deal with numbers represented as a center value and an additive tolerance; for example, he wants to work with intervals such as 3.5 ± 0.15 rather than [3.35, 3.65]. Alyssa returns to her desk and fixes this problem by supplying an alternate constructor and alternate selectors:</p>
<p class="Sp-text-1"><a id="c2-para-0190"/><b>function</b> make_center_width(c, w) {</p>
<p class="Sp-text-1"><a id="c2-para-0191"/>    <b>return</b> make_interval(c - w, c + w);</p>
<p class="Sp-text-1"><a id="c2-para-0192"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0193"/><b>function</b> center(i) {</p>
<p class="Sp-text-1"><a id="c2-para-0194"/>    <b>return</b> (lower_bound(i) + upper_bound(i)) / 2;</p>
<p class="Sp-text-1"><a id="c2-para-0195"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0196"/><b>function</b> width(i) {</p>
<p class="Sp-text-1"><a id="c2-para-0197"/>    <b>return</b> (upper_bound(i) - lower_bound(i)) / 2;</p>
<p class="Sp-text-1"><a id="c2-para-0198"/>}</p>
<p><a id="c2-para-0199"/>Unfortunately, most of Alyssa's users are engineers. Real engineering situations usually involve measurements with only a small uncertainty, measured as the ratio of the width of the interval to the midpoint of the interval. Engineers usually specify percentage tolerances on the parameters of devices, as in the resistor specifications given earlier.</p>
</section>
<section>
<h5><a id="c2-sec-0020"/><a id="c2-title-0021"/>Exercise 2.12</h5>
<p class="paraaftertitle"><a id="c2-para-0200"/>Define a constructor <span class="KeyTerm1">make_center_percent</span> that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector <span class="KeyTerm1">percent</span> that produces the percentage tolerance for a given interval. The <span class="KeyTerm1">center</span> selector is the same as the one shown above.</p>
</section>
<section>
<h5><a id="c2-sec-0021"/><a id="c2-title-0022"/>Exercise 2.13</h5>
<p class="paraaftertitle"><a id="c2-para-0201"/>Show that under the assumption of small percentage tolerances there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.</p>
<p><a id="c2-para-0202"/>After considerable work, Alyssa P. Hacker delivers her finished system. Several years later, after she has forgotten all about it, she gets a frenzied call from an irate user, Lem E. Tweakit. It seems that Lem has noticed that the formula for parallel resistors can be written in two algebraically equivalent ways:</p>
<p><a id="c2-para-0203"/></p>
<figure id="c2-fig-0005"><img alt="c2-fig-5004.jpg" src="../images/c2-fig-5004.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c2-para-0204"/>and</p>
<p><a id="c2-para-0205"/></p>
<figure id="c2-fig-0006"><img alt="c2-fig-5005.jpg" src="../images/c2-fig-5005.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c2-para-0206"/>He has written the following two programs, each of which computes the parallelresistors formula differently:</p>
<p class="Sp-text-1"><a id="c2-para-0207"/><b>function</b> par1(r1, r2) {</p>
<p class="Sp-text-1"><a id="c2-para-0208"/>    <b>return</b> div_interval(mul_interval(r1, r2),</p>
<p class="Sp-text-1"><a id="c2-para-0209"/>                        add_interval(r1, r2));</p>
<p class="Sp-text-1"><a id="c2-para-0210"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0211"/><b>function</b> par2(r1, r2) {</p>
<p class="Sp-text-1"><a id="c2-para-0212"/>    <b>const</b> one = make_interval(1, 1);</p>
<p class="Sp-text-1"><a id="c2-para-0213"/>    <b>return</b> div_interval(one,</p>
<p class="Sp-text-1"><a id="c2-para-0214"/>                        add_interval(div_interval(one, r1),</p>
<p class="Sp-text-1"><a id="c2-para-0215"/>                                     div_interval(one, r2)));</p>
<p class="Sp-text-1"><a id="c2-para-0216"/>}</p>
<p class="paracontinue"><a id="c2-para-0217"/>Lem complains that Alyssa's program gives different answers for the two ways of computing. This is a serious complaint.</p>
</section>
<section>
<h5><a id="c2-sec-0022"/><a id="c2-title-0023"/>Exercise 2.14</h5>
<p class="paraaftertitle"><a id="c2-para-0218"/>Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals <i>A</i> and <i>B</i>, and use them in computing the expressions <i>A</i>/<i>A</i> and <i>A</i>/<i>B</i>. You will get the most insight by using intervals whose width is a small percentage of the center value. Examine the results of the computation in center-percent form (see exercise 2.12).</p>
</section>
<section>
<h5><a id="c2-sec-0023"/><a id="c2-title-0024"/>Exercise 2.15</h5>
<p class="paraaftertitle"><a id="c2-para-0219"/>Eva Lu Ator, another user, has also noticed the different intervals computed by different but algebraically equivalent expressions. She says that a formula to compute with intervals using Alyssa's system will produce tighter error bounds if it can be written in such a form that no name that represents an uncertain number is repeated. Thus, she says, <span class="KeyTerm1">par2</span> is a “better” program for parallel resistances than <span class="KeyTerm1">par1</span>. Is she right? Why?</p>
</section>
<section>
<h5><a id="c2-sec-0024"/><a id="c2-title-0025"/>Exercise 2.16</h5>
<p class="paraaftertitle"><a id="c2-para-0220"/>Explain, in general, why equivalent algebraic expressions may lead to different answers. Can you devise an interval-arithmetic package that does not have this shortcoming, or is this task impossible? (Warning: This problem is very difficult.)</p>
</section>
</section>
</section>
<section>
<h2><a id="c2-sec-0025"/><span>2.2</span> <a id="c2-title-0026"/>Hierarchical Data and the Closure Property</h2>
<p class="paraaftertitle"><a id="c2-para-0221"/>As we have seen, pairs provide a primitive “glue” that we can use to construct compound data objects. <a id="c2-fig-0007a"/><a href="#c2-fig-0007">Figure 2.2</a> shows a standard way to visualize a pair—in this case, the pair formed by <span class="KeyTerm1">pair(1, 2)</span>. In this representation, which is called <i>box-and-pointer notation</i>, each compound object is shown as a <i>pointer</i> to a box. The box for a pair has two parts, the left part containing the head of the pair and the right part containing the tail.</p>
<figure id="c2-fig-0007"><img alt="c2-fig-0002.jpg" src="../images/c2-fig-0002.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0007a">Figure 2.2</a></span> <a id="c2-para-0222"/>Box-and-pointer representation of <span class="KeyTerm1">pair(1, 2)</span>.</p></figcaption></figure>
<p><a id="c2-para-0223"/>We have already seen that <span class="KeyTerm1">pair</span> can be used to combine not only numbers but pairs as well. (You made use of this fact, or should have, in doing exercises 2.2 and 2.3.) As a consequence, pairs provide a universal building block from which we can construct all sorts of data structures. <a id="c2-fig-0008a"/><a href="#c2-fig-0008">Figure 2.3</a> shows two ways to use pairs to combine the numbers 1, 2, 3, and 4.</p>
<figure id="c2-fig-0008"><img alt="c2-fig-0003.jpg" src="../images/c2-fig-0003.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0008a">Figure 2.3</a></span> <a id="c2-para-0224"/>Two ways to combine 1, 2, 3, and 4 using pairs.</p></figcaption></figure>
<p><a id="c2-para-0225"/>The ability to create pairs whose elements are pairs is the essence of list structure's importance as a representational tool. We refer to this ability as the <i>closure property</i> of <span class="KeyTerm1">pair</span>. In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.<a id="c2-fn-0007a"/><a href="#c2-fn-0007"><sup>7</sup></a> Closure is the key to power in any means of combination because it permits us to create <i>hierarchical</i> structures—structures made up of parts, which themselves are made up of parts, and so on.</p>
<p><a id="c2-para-0226"/>From the outset of chapter 1, we've made essential use of closure in dealing with functions, because all but the very simplest programs rely on the fact that the elements of a combination can themselves be combinations. In this section, we take up the consequences of closure for compound data. We describe some conventional techniques for using pairs to represent sequences and trees, and we exhibit a graphics language that illustrates closure in a vivid way.</p>
<section>
<h3><a id="c2-sec-0026"/><span>2.2.1</span> <a id="c2-title-0027"/>Representing Sequences</h3>
<p class="paraaftertitle"><a id="c2-para-0227"/>One of the useful structures we can build with pairs is a <i>sequence</i>—an ordered collection of data objects. There are, of course, many ways to represent sequences in terms of pairs. One particularly straightforward representation is illustrated in <a id="c2-fig-0009a"/><a href="#c2-fig-0009">figure 2.4</a>, where the sequence 1, 2, 3, 4 is represented as a chain of pairs. The <span class="KeyTerm1">head</span> of each pair is the corresponding item in the chain, and the <span class="KeyTerm1">tail</span> of the pair is the next pair in the chain. The <span class="KeyTerm1">tail</span> of the final pair signals the end of the sequence, represented in box-and-pointer diagrams as a diagonal line and in programs as JavaScript's primitive value <span class="KeyTerm1"><b>null</b></span>. The entire sequence is constructed by nested <span class="KeyTerm1">pair</span> operations:</p>
<figure id="c2-fig-0009"><img alt="c2-fig-0004.jpg" src="../images/c2-fig-0004.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0009a">Figure 2.4</a></span> <a id="c2-para-0228"/>The sequence 1, 2, 3, 4 represented as a chain of pairs.</p></figcaption></figure>
<p class="Sp-text-1"><a id="c2-para-0229"/>pair(1,</p>
<p class="Sp-text-1"><a id="c2-para-0230"/>     pair(2,</p>
<p class="Sp-text-1"><a id="c2-para-0231"/>          pair(3,</p>
<p class="Sp-text-1"><a id="c2-para-0232"/>               pair(4, <b>null</b>))));</p>
<p><a id="c2-para-0233"/>Such a sequence of pairs, formed by nested <span class="KeyTerm1">pair</span> applications, is called a <i>list</i>, and our JavaScript environment provides a primitive called <span class="KeyTerm1">list</span> to help in constructing lists.<a id="c2-fn-0008a"/><a href="#c2-fn-0008"><sup>8</sup></a> The above sequence could be produced by <span class="KeyTerm1">list(1, 2, 3, 4)</span>. In general,</p>
<p class="Sp-text-1"><a id="c2-para-0234"/>list(<span class="KeyTerm2"><i>a</i><sub>1</sub></span>, <span class="KeyTerm2"><i>a</i><sub>2</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>a<sub>n</sub></i></span>)</p>
<p class="paracontinue"><a id="c2-para-0235"/>is equivalent to</p>
<p class="Sp-text-1"><a id="c2-para-0236"/>pair(<span class="KeyTerm2"><i>a</i><sub>1</sub></span>, pair(<span class="KeyTerm2"><i>a</i><sub>2</sub></span>, pair(<i>. . .</i>, pair(<span class="KeyTerm2"><i>a<sub>n</sub></i></span>, <b>null</b>)<i>. . .</i>)))</p>
<p class="paracontinue"><a id="c2-para-0237"/>Our interpreter prints pairs using a textual representation of box-and-pointer diagrams that we call <i>box notation</i>. The result of <span class="KeyTerm1">pair(1, 2)</span> is printed as <span class="KeyTerm1">[1, 2]</span>, and the data object in <a href="#c2-fig-0009">figure 2.4</a> is printed as <span class="KeyTerm1">[1, [2, [3, [4, <b>null</b>]]]]</span>:</p>
<p class="Sp-text-1"><a id="c2-para-0238"/><b>const</b> one_through_four = list(1, 2, 3, 4);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0239"/>one_through_four;</p>
<p class="Sp-text-1"><a id="c2-para-0240"/><i>[1, [2, [3, [4, null]]]]</i></p>
<p><a id="c2-para-0241"/>We can think of <span class="KeyTerm1">head</span> as selecting the first item in the list, and of <span class="KeyTerm1">tail</span> as selecting the sublist consisting of all but the first item. Nested applications of <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> can be used to extract the second, third, and subsequent items in the list. The constructor <span class="KeyTerm1">pair</span> makes a list like the original one, but with an additional item at the beginning.</p>
<p class="Sp-text-1"><a id="c2-para-0242"/>head(one_through_four);</p>
<p class="Sp-text-1"><a id="c2-para-0243"/><i>1</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0244"/>tail(one_through_four);</p>
<p class="Sp-text-1"><a id="c2-para-0245"/><i>[2, [3, [4, null]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0246"/>head(tail(one_through_four));</p>
<p class="Sp-text-1"><a id="c2-para-0247"/><i>2</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0248"/>pair(10, one_through_four);</p>
<p class="Sp-text-1"><a id="c2-para-0249"/><i>[10, [1, [2, [3, [4, null]]]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0250"/>pair(5, one_through_four);</p>
<p class="Sp-text-1"><a id="c2-para-0251"/><i>[5, [1, [2, [3, [4, null]]]]]</i></p>
<p class="paracontinue"><a id="c2-para-0252"/>The value <span class="KeyTerm1"><b>null</b></span>, used to terminate the chain of pairs, can be thought of as a sequence of no elements, the <i>empty list</i>.<a id="c2-fn-0009a"/><a href="#c2-fn-0009"><sup>9</sup></a></p>
<p><a id="c2-para-0253"/>Box notation is sometimes difficult to read. In this book, when we want to indicate the list nature of a data structure, we will employ the alternative <i>list notation</i>: Whenever possible, list notation uses applications of <span class="KeyTerm1">list</span> whose evaluation would result in the desired structure. For example, instead of the box notation</p>
<p class="Sp-text-1"><a id="c2-para-0254"/><i>[1, [[2, 3], [[4, [5, null]], [6, null]]]]</i></p>
<p class="paracontinue"><a id="c2-para-0255"/>we write</p>
<p class="Sp-text-1"><a id="c2-para-0256"/><i>list(1, [2, 3], list(4, 5), 6)</i></p>
<p class="paracontinue"><a id="c2-para-0257"/>in list notation.<a id="c2-fn-0010a"/><a href="#c2-fn-0010"><sup>10</sup></a></p>
<section>
<h5><a id="c2-sec-0027"/><a id="c2-title-0028"/>List operations</h5>
<p class="paraaftertitle"><a id="c2-para-0258"/>The use of pairs to represent sequences of elements as lists is accompanied by conventional programming techniques for manipulating lists by successively using <span class="KeyTerm1">tail</span> to walk down the lists. For example, the function <span class="KeyTerm1">list_ref</span> takes as arguments a list and a number <i>n</i> and returns the <i>n</i>th item of the list. It is customary to number the elements of the list beginning with 0. The method for computing <span class="KeyTerm1">list_ref</span> is the following:</p>
<ul style="list-style-type:disc">
<li>For <i>n</i> = 0, <span class="KeyTerm1">list_ref</span> should return the <span class="KeyTerm1">head</span> of the list.</li>
<li>Otherwise, <span class="KeyTerm1">list_ref</span> should return the (<i>n</i> – 1)st item of the <span class="KeyTerm1">tail</span> of the list.</li>
</ul>

<p class="Sp-text-1"><a id="c2-para-0261"/><b>function</b> list_ref(items, n) {</p>
<p class="Sp-text-1"><a id="c2-para-0262"/>    <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c2-para-0263"/>           ? head(items)</p>
<p class="Sp-text-1"><a id="c2-para-0264"/>           : list_ref(tail(items), n - 1);</p>
<p class="Sp-text-1"><a id="c2-para-0265"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0266"/><b>const</b> squares = list(1, 4, 9, 16, 25);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0267"/>list_ref(squares, 3);</p>
<p class="Sp-text-1"><a id="c2-para-0268"/><i>16</i></p>
<p><a id="c2-para-0269"/>Often we walk down the whole list. To aid in this, our JavaScript environment includes a primitive predicate <span class="KeyTerm1">is_null</span>, which tests whether its argument is the empty list. The function <span class="KeyTerm1">length</span>, which returns the number of items in a list, illustrates this typical pattern of use:</p>
<p class="Sp-text-1"><a id="c2-para-0270"/><b>function</b> length(items) {</p>
<p class="Sp-text-1"><a id="c2-para-0271"/>    <b>return</b> is_null(items)</p>
<p class="Sp-text-1"><a id="c2-para-0272"/>           ? 0</p>
<p class="Sp-text-1"><a id="c2-para-0273"/>           : 1 + length(tail(items));</p>
<p class="Sp-text-1"><a id="c2-para-0274"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0275"/><b>const</b> odds = list(1, 3, 5, 7);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0276"/>length(odds);</p>
<p class="Sp-text-1"><a id="c2-para-0277"/><i>4</i></p>
<p class="paracontinue"><a id="c2-para-0278"/>The <span class="KeyTerm1">length</span> function implements a simple recursive plan. The reduction step is:</p>
<ul style="list-style-type:disc">
<li>The <span class="KeyTerm1">length</span> of any list is 1 plus the <span class="KeyTerm1">length</span> of the <span class="KeyTerm1">tail</span> of the list.</li>
</ul>

<p class="paracontinue"><a id="c2-para-0280"/>This is applied successively until we reach the base case:</p>
<ul style="list-style-type:disc">
<li>The <span class="KeyTerm1">length</span> of the empty list is 0.</li>
</ul>

<p class="paracontinue"><a id="c2-para-0282"/>We could also compute <span class="KeyTerm1">length</span> in an iterative style:</p>
<p class="Sp-text-1"><a id="c2-para-0283"/><b>function</b> length(items) {</p>
<p class="Sp-text-1"><a id="c2-para-0284"/>    <b>function</b> length_iter(a, count) {</p>
<p class="Sp-text-1"><a id="c2-para-0285"/>        <b>return</b> is_null(a)</p>
<p class="Sp-text-1"><a id="c2-para-0286"/>               ? count</p>
<p class="Sp-text-1"><a id="c2-para-0287"/>               : length_iter(tail(a), count + 1);</p>
<p class="Sp-text-1"><a id="c2-para-0288"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-0289"/>    <b>return</b> length_iter(items, 0);</p>
<p class="Sp-text-1"><a id="c2-para-0290"/>}</p>
<p><a id="c2-para-0291"/>Another conventional programming technique is to construct an answer list by adjoining elements to the front of the list with <span class="KeyTerm1">pair</span> while walking down a list using <span class="KeyTerm1">tail</span>, as in the function <span class="KeyTerm1">append</span>, which takes two lists as arguments and combines their elements to make a new list:</p>
<p class="Sp-text-1"><a id="c2-para-0292"/>append(squares, odds);</p>
<p class="Sp-text-1"><a id="c2-para-0293"/><i>list(1, 4, 9, 16, 25, 1, 3, 5, 7)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0294"/>append(odds, squares);</p>
<p class="Sp-text-1"><a id="c2-para-0295"/><i>list(1, 3, 5, 7, 1, 4, 9, 16, 25)</i></p>
<p class="paracontinue"><a id="c2-para-0296"/>The function <span class="KeyTerm1">append</span> is also implemented using a recursive plan. To <span class="KeyTerm1">append</span> lists <span class="KeyTerm1">list1</span> and <span class="KeyTerm1">list2</span>, do the following:</p>
<ul style="list-style-type:disc">
<li>If <span class="KeyTerm1">list1</span> is the empty list, then the result is just <span class="KeyTerm1">list2</span>.</li>
<li>Otherwise, <span class="KeyTerm1">append</span> the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">list1</span> and <span class="KeyTerm1">list2</span>, and adjoin the <span class="KeyTerm1">head</span> of <span class="KeyTerm1">list1</span> to the result:</li>
</ul>

<p class="Sp-text-1"><a id="c2-para-0299"/><b>function</b> append(list1, list2) {</p>
<p class="Sp-text-1"><a id="c2-para-0300"/>    <b>return</b> is_null(list1)</p>
<p class="Sp-text-1"><a id="c2-para-0301"/>           ? list2</p>
<p class="Sp-text-1"><a id="c2-para-0302"/>           : pair(head(list1), append(tail(list1), list2));</p>
<p class="Sp-text-1"><a id="c2-para-0303"/>}</p>
</section>
<section>
<h5><a id="c2-sec-0028"/><a id="c2-title-0029"/>Exercise 2.17</h5>
<p class="paraaftertitle"><a id="c2-para-0304"/>Define a function <span class="KeyTerm1">last_pair</span> that returns the list that contains only the last element of a given (nonempty) list:</p>
<p class="Sp-text-1"><a id="c2-para-0305"/>last_pair(list(23, 72, 149, 34));</p>
<p class="Sp-text-1"><a id="c2-para-0306"/><i>list(34)</i></p>
</section>
<section>
<h5><a id="c2-sec-0029"/><a id="c2-title-0030"/>Exercise 2.18</h5>
<p class="paraaftertitle"><a id="c2-para-0307"/>Define a function <span class="KeyTerm1">reverse</span> that takes a list as argument and returns a list of the same elements in reverse order:</p>
<p class="Sp-text-1"><a id="c2-para-0308"/>reverse(list(1, 4, 9, 16, 25));</p>
<p class="Sp-text-1"><a id="c2-para-0309"/><i>list(25, 16, 9, 4, 1)</i></p>
</section>
<section>
<h5><a id="c2-sec-0030"/><a id="c2-title-0031"/>Exercise 2.19</h5>
<p class="paraaftertitle"><a id="c2-para-0310"/>Consider the change-counting program of section 1.2.2. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways to change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the function <span class="KeyTerm1">first_denomination</span> and partly into the function <span class="KeyTerm1">count_change</span> (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.</p>
<p><a id="c2-para-0311"/>We want to rewrite the function <span class="KeyTerm1">cc</span> so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:</p>
<p class="Sp-text-1"><a id="c2-para-0312"/><b>const</b> us_coins = list(50, 25, 10, 5, 1);</p>
<p class="Sp-text-1"><a id="c2-para-0313"/><b>const</b> uk_coins = list(100, 50, 20, 10, 5, 2, 1);</p>
<p class="paracontinue"><a id="c2-para-0314"/>We could then call <span class="KeyTerm1">cc</span> as follows:</p>
<p class="Sp-text-1"><a id="c2-para-0315"/>cc(100, us_coins);</p>
<p class="Sp-text-1"><a id="c2-para-0316"/><i>292</i></p>
<p class="paracontinue"><a id="c2-para-0317"/>To do this will require changing the program <span class="KeyTerm1">cc</span> somewhat. It will still have the same form, but it will access its second argument differently, as follows:</p>
<p class="Sp-text-1"><a id="c2-para-0318"/><b>function</b> cc(amount, coin_values) {</p>
<p class="Sp-text-1"><a id="c2-para-0319"/>    <b>return</b> amount === 0</p>
<p class="Sp-text-1"><a id="c2-para-0320"/>           ? 1</p>
<p class="Sp-text-1"><a id="c2-para-0321"/>           : amount &lt; 0 || no_more(coin_values)</p>
<p class="Sp-text-1"><a id="c2-para-0322"/>           ? 0</p>
<p class="Sp-text-1"><a id="c2-para-0323"/>           : cc(amount, except_first_denomination(coin_values)) +</p>
<p class="Sp-text-1"><a id="c2-para-0324"/>             cc(amount - first_denomination(coin_values), coin_values);</p>
<p class="Sp-text-1"><a id="c2-para-0325"/>}</p>
<p class="paracontinue"><a id="c2-para-0326"/>Define the functions <span class="KeyTerm1">first_denomination</span>, <span class="KeyTerm1">except_first_denomination</span>, and <span class="KeyTerm1">no_more</span> in terms of primitive operations on list structures. Does the order of the list <span class="KeyTerm1">coin_values</span> affect the answer produced by <span class="KeyTerm1">cc</span>? Why or why not?</p>
</section>
<section>
<h5><a id="c2-sec-0031"/><a id="c2-title-0032"/>Exercise 2.20</h5>
<p class="paraaftertitle"><a id="c2-para-0327"/>In the presence of higher-order functions, it is not strictly necessary for functions to have multiple parameters; one would suffice. If we have a function such as <span class="KeyTerm1">plus</span> that naturally requires two arguments, we could write a variant of the function to which we pass the arguments one at at time. An application of the variant to the first argument could return a function that we can then apply to the second argument, and so on. This practice—called <i>currying</i> and named after the American mathematician and logician Haskell Brooks Curry—is quite common in programming languages such as Haskell and OCaml. In JavaScript, a curried version of <span class="KeyTerm1">plus</span> looks as follows.</p>
<p class="Sp-text-1"><a id="c2-para-0328"/><b>function</b> plus_curried(x) {</p>
<p class="Sp-text-1"><a id="c2-para-0329"/>    <b>return</b> y =&gt; x + y;</p>
<p class="Sp-text-1"><a id="c2-para-0330"/>}</p>
<p class="paracontinue"><a id="c2-para-0331"/>Write a function <span class="KeyTerm1">brooks</span> that takes a curried function as first argument and as second argument a list of arguments to which the curried function is then applied, one by one, in the given order. For example, the following application of <span class="KeyTerm1">brooks</span> should have the same effect as <span class="KeyTerm1">plus_curried(3)(4)</span>:</p>
<p class="Sp-text-1"><a id="c2-para-0332"/>brooks(plus_curried, list(3, 4));</p>
<p class="Sp-text-1"><a id="c2-para-0333"/><i>7</i></p>
<p class="paracontinue"><a id="c2-para-0334"/>While we are at it, we might as well curry the function <span class="KeyTerm1">brooks</span>! Write a function <span class="KeyTerm1">brooks_curried</span> that can be applied as follows:</p>
<p class="Sp-text-1"><a id="c2-para-0335"/>brooks_curried(list(plus_curried, 3, 4));</p>
<p class="Sp-text-1"><a id="c2-para-0336"/><i>7</i></p>
<p class="paracontinue"><a id="c2-para-0337"/>With this function <span class="KeyTerm1">brooks_curried</span>, what are the results of evaluating the following two statements?</p>
<p class="Sp-text-1"><a id="c2-para-0338"/>brooks_curried(list(brooks_curried,</p>
<p class="Sp-text-1"><a id="c2-para-0339"/>                    list(plus_curried, 3, 4)));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0340"/>brooks_curried(list(brooks_curried,</p>
<p class="Sp-text-1"><a id="c2-para-0341"/>                    list(brooks_curried,</p>
<p class="Sp-text-1"><a id="c2-para-0342"/>                         list(plus_curried, 3, 4))));</p>
</section>
<section>
<h5><a id="c2-sec-0032"/><a id="c2-title-0033"/>Mapping over lists</h5>
<p class="paraaftertitle"><a id="c2-para-0343"/>One extremely useful operation is to apply some transformation to each element in a list and generate the list of results. For instance, the following function scales each number in a list by a given factor:</p>
<p class="Sp-text-1"><a id="c2-para-0344"/><b>function</b> scale_list(items, factor) {</p>
<p class="Sp-text-1"><a id="c2-para-0345"/>    <b>return</b> is_null(items)</p>
<p class="Sp-text-1"><a id="c2-para-0346"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-0347"/>           : pair(head(items) * factor,</p>
<p class="Sp-text-1"><a id="c2-para-0348"/>                  scale_list(tail(items), factor));</p>
<p class="Sp-text-1"><a id="c2-para-0349"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0350"/>scale_list(list(1, 2, 3, 4, 5), 10);</p>
<p class="Sp-text-1"><a id="c2-para-0351"/><i>[10, [20, [30, [40, [50, null]]]]]</i></p>
<p><a id="c2-para-0352"/>We can abstract this general idea and capture it as a common pattern expressed as a higher-order function, just as in section 1.3. The higher-order function here is called <span class="KeyTerm1">map</span>. The function <span class="KeyTerm1">map</span> takes as arguments a function of one argument and a list, and returns a list of the results produced by applying the function to each element in the list:</p>
<p class="Sp-text-1"><a id="c2-para-0353"/><b>function</b> map(fun, items) {</p>
<p class="Sp-text-1"><a id="c2-para-0354"/>    <b>return</b> is_null(items)</p>
<p class="Sp-text-1"><a id="c2-para-0355"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-0356"/>           : pair(fun(head(items)),</p>
<p class="Sp-text-1"><a id="c2-para-0357"/>                  map(fun, tail(items)));</p>
<p class="Sp-text-1"><a id="c2-para-0358"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0359"/>map(abs, list(-10, 2.5, -11.6, 17));</p>
<p class="Sp-text-1"><a id="c2-para-0360"/><i>[10, [2.5, [11.6, [17, null]]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0361"/>map(x =&gt; x * x, list(1, 2, 3, 4));</p>
<p class="Sp-text-1"><a id="c2-para-0362"/><i>[1, [4, [9, [16, null]]]]</i></p>
<p class="paracontinue"><a id="c2-para-0363"/>Now we can give a new definition of <span class="KeyTerm1">scale_list</span> in terms of <span class="KeyTerm1">map</span>:</p>
<p class="Sp-text-1"><a id="c2-para-0364"/><b>function</b> scale_list(items, factor) {</p>
<p class="Sp-text-1"><a id="c2-para-0365"/>    <b>return</b> map(x =&gt; x * factor, items);</p>
<p class="Sp-text-1"><a id="c2-para-0366"/>}</p>
<p><a id="c2-para-0367"/>The function <span class="KeyTerm1">map</span> is an important construct, not only because it captures a common pattern, but because it establishes a higher level of abstraction in dealing with lists. In the original definition of <span class="KeyTerm1">scale_list</span>, the recursive structure of the program draws attention to the element-by-element processing of the list. Defining <span class="KeyTerm1">scale_list</span> in terms of <span class="KeyTerm1">map</span> suppresses that level of detail and emphasizes that scaling transforms a list of elements to a list of results. The difference between the two definitions is not that the computer is performing a different process (it isn't) but that we think about the process differently. In effect, <span class="KeyTerm1">map</span> helps establish an abstraction barrier that isolates the implementation of functions that transform lists from the details of how the elements of the list are extracted and combined. Like the barriers shown in <a href="#c2-fig-0002">figure 2.1</a>, this abstraction gives us the flexibility to change the low-level details of how sequences are implemented, while preserving the conceptual framework of operations that transform sequences to sequences. Section 2.2.3 expands on this use of sequences as a framework for organizing programs.</p>
</section>
<section>
<h5><a id="c2-sec-0033"/><a id="c2-title-0034"/>Exercise 2.21</h5>
<p class="paraaftertitle"><a id="c2-para-0368"/>The function <span class="KeyTerm1">square_list</span> takes a list of numbers as argument and returns a list of the squares of those numbers.</p>
<p class="Sp-text-1"><a id="c2-para-0369"/>square_list(list(1, 2, 3, 4));</p>
<p class="Sp-text-1"><a id="c2-para-0370"/><i>[1, [4, [9, [16, null]]]]</i></p>
<p class="paracontinue"><a id="c2-para-0371"/>Here are two different definitions of <span class="KeyTerm1">square_list</span>. Complete both of them by filling in the missing expressions:</p>
<p class="Sp-text-1"><a id="c2-para-0372"/><b>function</b> square_list(items) {</p>
<p class="Sp-text-1"><a id="c2-para-0373"/>    <b>return</b> is_null(items)</p>
<p class="Sp-text-1"><a id="c2-para-0374"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-0375"/>           : pair(〈??〉, 〈??〉);</p>
<p class="Sp-text-1"><a id="c2-para-0376"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0377"/><b>function</b> square_list(items) {</p>
<p class="Sp-text-1"><a id="c2-para-0378"/>    <b>return</b> map(〈??〉, 〈??〉);</p>
<p class="Sp-text-1"><a id="c2-para-0379"/><sub>}</sub></p>
</section>
<section>
<h5><a id="c2-sec-0034"/><a id="c2-title-0035"/>Exercise 2.22</h5>
<p class="paraaftertitle"><a id="c2-para-0380"/>Louis Reasoner tries to rewrite the first <span class="KeyTerm1">square_list</span> function of exercise 2.21 so that it evolves an iterative process:</p>
<p class="Sp-text-1"><a id="c2-para-0381"/><b>function</b> square_list(items) {</p>
<p class="Sp-text-1"><a id="c2-para-0382"/>    <b>function</b> iter(things, answer) {</p>
<p class="Sp-text-1"><a id="c2-para-0383"/>        <b>return</b> is_null(things)</p>
<p class="Sp-text-1"><a id="c2-para-0384"/>               ? answer</p>
<p class="Sp-text-1"><a id="c2-para-0385"/>               : iter(tail(things),</p>
<p class="Sp-text-1"><a id="c2-para-0386"/>                      pair(square(head(things)),</p>
<p class="Sp-text-1"><a id="c2-para-0387"/>                           answer));</p>
<p class="Sp-text-1"><a id="c2-para-0388"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-0389"/>    <b>return</b> iter(items, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c2-para-0390"/>}</p>
<p class="paracontinue"><a id="c2-para-0391"/>Unfortunately, defining <span class="KeyTerm1">square_list</span> this way produces the answer list in the reverse order of the one desired. Why?</p>
<p><a id="c2-para-0392"/>Louis then tries to fix his bug by interchanging the arguments to <span class="KeyTerm1">pair</span>:</p>
<p class="Sp-text-1"><a id="c2-para-0393"/><b>function</b> square_list(items) {</p>
<p class="Sp-text-1"><a id="c2-para-0394"/>    <b>function</b> iter(things, answer) {</p>
<p class="Sp-text-1"><a id="c2-para-0395"/>        <b>return</b> is_null(things)</p>
<p class="Sp-text-1"><a id="c2-para-0396"/>               ? answer</p>
<p class="Sp-text-1"><a id="c2-para-0397"/>               : iter(tail(things),</p>
<p class="Sp-text-1"><a id="c2-para-0398"/>                      pair(answer,</p>
<p class="Sp-text-1"><a id="c2-para-0399"/>                           square(head(things))));</p>
<p class="Sp-text-1"><a id="c2-para-0400"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-0401"/>    <b>return</b> iter(items, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c2-para-0402"/>}</p>
<p class="paracontinue"><a id="c2-para-0403"/>This doesn't work either. Explain.</p>
</section>
<section>
<h5><a id="c2-sec-0035"/><a id="c2-title-0036"/>Exercise 2.23</h5>
<p class="paraaftertitle"><a id="c2-para-0404"/>The function <span class="KeyTerm1">for_each</span> is similar to <span class="KeyTerm1">map</span>. It takes as arguments a function and a list of elements. However, rather than forming a list of the results, <span class="KeyTerm1">for_each</span> just applies the function to each of the elements in turn, from left to right. The values returned by applying the function to the elements are not used at all—<span class="KeyTerm1">for_each</span> is used with functions that perform an action, such as printing. For example,</p>
<p class="Sp-text-1"><a id="c2-para-0405"/>for_each(x =&gt; display(x), list(57, 321, 88));</p>
<p class="Sp-text-1"><a id="c2-para-0406"/><i>57</i></p>
<p class="Sp-text-1"><a id="c2-para-0407"/><i>321</i></p>
<p class="Sp-text-1"><a id="c2-para-0408"/><i>88</i></p>
<p class="paracontinue"><a id="c2-para-0409"/>The value returned by the call to <span class="KeyTerm1">for_each</span> (not illustrated above) can be something arbitrary, such as true. Give an implementation of <span class="KeyTerm1">for_each</span>.</p>
</section>
</section>
<section>
<h3><a id="c2-sec-0036"/><span>2.2.2</span> <a id="c2-title-0037"/>Hierarchical Structures</h3>
<p class="paraaftertitle"><a id="c2-para-0410"/>The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object <span class="KeyTerm1">[[1, [2, <b>null</b>]], [3, [4, <b>null</b>]]]</span> constructed by</p>
<p class="Sp-text-1"><a id="c2-para-0411"/>pair(list(1, 2), list(3, 4));</p>
<p class="paracontinue"><a id="c2-para-0412"/>as a list of three items, the first of which is itself a list, <span class="KeyTerm1">[1, [2, <b>null</b>]]</span>. <a id="c2-fig-0010a"/><a href="#c2-fig-0010">Figure 2.5</a> shows the representation of this structure in terms of pairs.</p>
<figure id="c2-fig-0010"><img alt="c2-fig-0005.jpg" src="../images/c2-fig-0005.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0010a">Figure 2.5</a></span> <a id="c2-para-0413"/>Structure formed by <span class="KeyTerm1">pair(list(1, 2), list(3, 4))</span>.</p></figcaption></figure>
<p><a id="c2-para-0414"/>Another way to think of sequences whose elements are sequences is as <i>trees</i>. The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. <a id="c2-fig-0011a"/><a href="#c2-fig-0011">Figure 2.6</a> shows the structure in <a href="#c2-fig-0010">figure 2.5</a> viewed as a tree.</p>
<figure id="c2-fig-0011"><img alt="c2-fig-0006.jpg" src="../images/c2-fig-0006.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0011a">Figure 2.6</a></span> <a id="c2-para-0415"/>The list structure in <a href="#c2-fig-0010">figure 2.5</a> viewed as a tree.</p></figcaption></figure>
<p><a id="c2-para-0416"/>Recursion is a natural tool for dealing with tree structures, since we can often reduce operations on trees to operations on their branches, which reduce in turn to operations on the branches of the branches, and so on, until we reach the leaves of the tree. As an example, compare the <span class="KeyTerm1">length</span> function of section 2.2.1 with the <span class="KeyTerm1">count_leaves</span> function, which returns the total number of leaves of a tree:</p>
<p class="Sp-text-1"><a id="c2-para-0417"/><b>const</b> x = pair(list(1, 2), list(3, 4));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0418"/>length(x);</p>
<p class="Sp-text-1"><a id="c2-para-0419"/><i>3</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0420"/>count_leaves(x);</p>
<p class="Sp-text-1"><a id="c2-para-0421"/><i>4</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0422"/>list(x, x);</p>
<p class="Sp-text-1"><a id="c2-para-0423"/><i>list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0424"/>length(list(x, x));</p>
<p class="Sp-text-1"><a id="c2-para-0425"/><i>2</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0426"/>count_leaves(list(x, x));</p>
<p class="Sp-text-1"><a id="c2-para-0427"/><i>8</i></p>
<p><a id="c2-para-0428"/>To implement <span class="KeyTerm1">count_leaves</span>, recall the recursive plan for computing <span class="KeyTerm1">length</span>:</p>
<ul style="list-style-type:disc">
<li>The <span class="KeyTerm1">length</span> of a list <span class="KeyTerm1">x</span> is 1 plus the <span class="KeyTerm1">length</span> of the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">x</span>.</li>
<li>The <span class="KeyTerm1">length</span> of the empty list is 0.</li>
</ul>

<p class="paracontinue"><a id="c2-para-0431"/>The function <span class="KeyTerm1">count_leaves</span> is similar. The value for the empty list is the same:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">count_leaves</span> of the empty list is 0.</li>
</ul>

<p class="paracontinue"><a id="c2-para-0433"/>But in the reduction step, where we strip off the <span class="KeyTerm1">head</span> of the list, we must take into account that the <span class="KeyTerm1">head</span> may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">count_leaves</span> of a tree <span class="KeyTerm1">x</span> is <span class="KeyTerm1">count_leaves</span> of the <span class="KeyTerm1">head</span> of <span class="KeyTerm1">x</span> plus <span class="KeyTerm1">count_leaves</span> of the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">x</span>.</li>
</ul>
<p class="paracontinue"><a id="c2-para-0435"/>Finally, by taking <span class="KeyTerm1">head</span>s we reach actual leaves, so we need another base case:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">count_leaves</span> of a leaf is 1.</li>
</ul>

<p class="paracontinue"><a id="c2-para-0437"/>To aid in writing recursive functions on trees, our JavaScript environment provides the primitive predicate <span class="KeyTerm1">is_pair</span>, which tests whether its argument is a pair. Here is the complete function:<a id="c2-fn-0011a"/><a href="#c2-fn-0011"><sup>11</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0438"/><b>function</b> count_leaves(x) {</p>
<p class="Sp-text-1"><a id="c2-para-0439"/>    <b>return</b> is_null(x)</p>
<p class="Sp-text-1"><a id="c2-para-0440"/>           ? 0</p>
<p class="Sp-text-1"><a id="c2-para-0441"/>           : ! is_pair(x)</p>
<p class="Sp-text-1"><a id="c2-para-0442"/>           ? 1</p>
<p class="Sp-text-1"><a id="c2-para-0443"/>           : count_leaves(head(x)) + count_leaves(tail(x));</p>
<p class="Sp-text-1"><a id="c2-para-0444"/>}</p>
<section>
<h5><a id="c2-sec-0037"/><a id="c2-title-0038"/>Exercise 2.24</h5>
<p class="paraaftertitle"><a id="c2-para-0445"/>Suppose we evaluate the expression <span class="KeyTerm1">list(1, list(2, list(3, 4)))</span>. Give the result printed by the interpreter, the corresponding box-and-pointer structure, and the interpretation of this as a tree (as in <a href="#c2-fig-0011">figure 2.6</a>).</p>
</section>
<section>
<h5><a id="c2-sec-0038"/><a id="c2-title-0039"/>Exercise 2.25</h5>
<p class="paraaftertitle"><a id="c2-para-0446"/>Give combinations of <span class="KeyTerm1">head</span>s and <span class="KeyTerm1">tail</span>s that will pick 7 from each of the following lists, given in list notation:</p>
<p class="Sp-text-1"><a id="c2-para-0447"/>list(1, 3, list(5, 7), 9)</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0448"/>list(list(7))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0449"/>list(1, list(2, list(3, list(4, list(5, list(6, 7))))))</p>
</section>
<section>
<h5><a id="c2-sec-0039"/><a id="c2-title-0040"/>Exercise 2.26</h5>
<p class="paraaftertitle"><a id="c2-para-0450"/>Suppose we define <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> to be two lists:</p>
<p class="Sp-text-1"><a id="c2-para-0451"/><b>const</b> x = list(1, 2, 3);</p>
<p class="Sp-text-1"><a id="c2-para-0452"/><b>const</b> y = list(4, 5, 6);</p>
<p class="paracontinue"><a id="c2-para-0453"/>What is the result of evaluating each of the following expressions, in box notation and list notation?</p>
<p class="Sp-text-1"><a id="c2-para-0454"/>append(x, y)</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0455"/>pair(x, y)</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0456"/>list(x, y)</p>
</section>
<section>
<h5><a id="c2-sec-0040"/><a id="c2-title-0041"/>Exercise 2.27</h5>
<p class="paraaftertitle"><a id="c2-para-0457"/>Modify your <span class="KeyTerm1">reverse</span> function of exercise 2.18 to produce a <span class="KeyTerm1">deep_reverse</span> function that takes a list as argument and returns as its value the list with its elements reversed and with all sublists deep-reversed as well. For example,</p>
<p class="Sp-text-1"><a id="c2-para-0458"/><b>const</b> x = list(list(1, 2), list(3, 4));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0459"/>x;</p>
<p class="Sp-text-1"><a id="c2-para-0460"/><i>list(list(1, 2), list(3, 4))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0461"/>reverse(x);</p>
<p class="Sp-text-1"><a id="c2-para-0462"/><i>list(list(3, 4), list(1, 2))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0463"/>deep_reverse(x);</p>
<p class="Sp-text-1"><a id="c2-para-0464"/><i>list(list(4, 3), list(2, 1))</i></p>
</section>
<section>
<h5><a id="c2-sec-0041"/><a id="c2-title-0042"/>Exercise 2.28</h5>
<p class="paraaftertitle"><a id="c2-para-0465"/>Write a function <span class="KeyTerm1">fringe</span> that takes as argument a tree (represented as a list) and returns a list whose elements are all the leaves of the tree arranged in left-to-right order. For example,</p>
<p class="Sp-text-1"><a id="c2-para-0466"/><b>const</b> x = list(list(1, 2), list(3, 4));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0467"/>fringe(x);</p>
<p class="Sp-text-1"><a id="c2-para-0468"/><i>list(1, 2, 3, 4)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0469"/>fringe(list(x, x));</p>
<p class="Sp-text-1"><a id="c2-para-0470"/><i>list(1, 2, 3, 4, 1, 2, 3, 4)</i></p>
</section>
<section>
<h5><a id="c2-sec-0042"/><a id="c2-title-0043"/>Exercise 2.29</h5>
<p class="paraaftertitle"><a id="c2-para-0471"/>A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile using compound data by constructing it from two branches (for example, using <span class="KeyTerm1">list</span>):</p>
<p class="Sp-text-1"><a id="c2-para-0472"/><b>function</b> make_mobile(left, right) {</p>
<p class="Sp-text-1"><a id="c2-para-0473"/>    <b>return</b> list(left, right);</p>
<p class="Sp-text-1"><a id="c2-para-0474"/>}</p>
<p class="paracontinue"><a id="c2-para-0475"/>A branch is constructed from a <span class="KeyTerm1">length</span> (which must be a number) together with a <span class="KeyTerm1">structure</span>, which may be either a number (representing a simple weight) or another mobile:</p>
<p class="Sp-text-1"><a id="c2-para-0476"/><b>function</b> make_branch(length, structure) {</p>
<p class="Sp-text-1"><a id="c2-para-0477"/>    <b>return</b> list(length, structure);</p>
<p class="Sp-text-1"><a id="c2-para-0478"/>}</p>
<ol class="BS_NumberListA">
<li><a id="c2-li-0014"/><span>a. </span>Write the corresponding selectors <span class="KeyTerm1">left_branch</span> and <span class="KeyTerm1">right_branch</span>, which return the branches of a mobile, and <span class="KeyTerm1">branch_length</span> and <span class="KeyTerm1">branch_structure</span>, which return the components of a branch.</li>
<li><a id="c2-li-0015"/><span>b. </span>Using your selectors, define a function <span class="KeyTerm1">total_weight</span> that returns the total weight of a mobile.</li>
<li><a id="c2-li-0016"/><span>c. </span>A mobile is said to be <i>balanced</i> if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and if each of the submobiles hanging off its branches is balanced. Design a predicate that tests whether a binary mobile is balanced.</li>
<li><a id="c2-li-0017"/><span>d. </span>Suppose we change the representation of mobiles so that the constructors are
<p class="Sp-text-1"><a id="c2-para-0483"/><b>function</b> make_mobile(left, right) {</p>
<p class="Sp-text-1"><a id="c2-para-0484"/>    <b>return</b> pair(left, right);</p>
<p class="Sp-text-1"><a id="c2-para-0485"/>}</p>
<p class="Sp-text-1"><a id="c2-para-0486"/><b>function</b> make_branch(length, structure) {</p>
<p class="Sp-text-1"><a id="c2-para-0487"/>    <b>return</b> pair(length, structure);</p>
<p class="Sp-text-1"><a id="c2-para-0488"/>}</p>
<p class="paracontinue"><a id="c2-para-0489"/>How much do you need to change your programs to convert to the new representation?</p></li>
</ol>
</section>
<section>
<h5><a id="c2-sec-0043"/><a id="c2-title-0044"/>Mapping over trees</h5>
<p class="paraaftertitle"><a id="c2-para-0490"/>Just as <span class="KeyTerm1">map</span> is a powerful abstraction for dealing with sequences, <span class="KeyTerm1">map</span> together with recursion is a powerful abstraction for dealing with trees. For instance, the <span class="KeyTerm1">scale_tree</span> function, analogous to <span class="KeyTerm1">scale_list</span> of section 2.2.1, takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for <span class="KeyTerm1">scale_tree</span> is similar to the one for <span class="KeyTerm1">count_leaves</span>:</p>
<p class="Sp-text-1"><a id="c2-para-0491"/><b>function</b> scale_tree(tree, factor) {</p>
<p class="Sp-text-1"><a id="c2-para-0492"/>    <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c2-para-0493"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-0494"/>           : ! is_pair(tree)</p>
<p class="Sp-text-1"><a id="c2-para-0495"/>           ? tree * factor</p>
<p class="Sp-text-1"><a id="c2-para-0496"/>           : pair(scale_tree(head(tree), factor),</p>
<p class="Sp-text-1"><a id="c2-para-0497"/>                  scale_tree(tail(tree), factor));</p>
<p class="Sp-text-1"><a id="c2-para-0498"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0499"/>scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)),</p>
<p class="Sp-text-1"><a id="c2-para-0500"/>           10);</p>
<p class="Sp-text-1"><a id="c2-para-0501"/><i>list(10, list(20, list(30, 40), 50), list(60, 70))</i></p>
<p><a id="c2-para-0502"/>Another way to implement <span class="KeyTerm1">scale_tree</span> is to regard the tree as a sequence of sub-trees and use <span class="KeyTerm1">map</span>. We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor:</p>
<p class="Sp-text-1"><a id="c2-para-0503"/><b>function</b> scale_tree(tree, factor) {</p>
<p class="Sp-text-1"><a id="c2-para-0504"/>    <b>return</b> map(sub_tree =&gt; is_pair(sub_tree)</p>
<p class="Sp-text-1"><a id="c2-para-0505"/>                           ? scale_tree(sub_tree, factor)</p>
<p class="Sp-text-1"><a id="c2-para-0506"/>                           : sub_tree * factor,</p>
<p class="Sp-text-1"><a id="c2-para-0507"/>               tree);</p>
<p class="Sp-text-1"><a id="c2-para-0508"/>}</p>
<p class="paracontinue"><a id="c2-para-0509"/>Many tree operations can be implemented by similar combinations of sequence operations and recursion.</p>
</section>
<section>
<h5><a id="c2-sec-0044"/><a id="c2-title-0045"/>Exercise 2.30</h5>
<p class="paraaftertitle"><a id="c2-para-0510"/>Declare a function <span class="KeyTerm1">square_tree</span> analogous to the <span class="KeyTerm1">square_list</span> function of exercise 2.21. That is, <span class="KeyTerm1">square_tree</span> should behave as follows:</p>
<p class="Sp-text-1"><a id="c2-para-0511"/>square_tree(list(1,</p>
<p class="Sp-text-1"><a id="c2-para-0512"/>                 list(2, list(3, 4), 5),</p>
<p class="Sp-text-1"><a id="c2-para-0513"/>                 list(6, 7)));</p>
<p class="Sp-text-1"><a id="c2-para-0514"/><i>list(1, list(4, list(9, 16), 25), list(36, 49)))</i></p>
<p class="paracontinue"><a id="c2-para-0515"/>Declare <span class="KeyTerm1">square_tree</span> both directly (i.e., without using any higher-order functions) and also by using <span class="KeyTerm1">map</span> and recursion.</p>
</section>
<section>
<h5><a id="c2-sec-0045"/><a id="c2-title-0046"/>Exercise 2.31</h5>
<p class="paraaftertitle"><a id="c2-para-0516"/>Abstract your answer to exercise 2.30 to produce a function <span class="KeyTerm1">tree_map</span> with the property that <span class="KeyTerm1">square_tree</span> could be declared as</p>
<p class="Sp-text-1"><a id="c2-para-0517"/><b>function</b> square_tree(tree) { <b>return</b> tree_map(square, tree); }</p>
</section>
<section>
<h5><a id="c2-sec-0046"/><a id="c2-title-0047"/>Exercise 2.32</h5>
<p class="paraaftertitle"><a id="c2-para-0518"/>We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is <span class="KeyTerm1">list(1, 2, 3)</span>, then the set of all subsets is</p>
<p class="Sp-text-1"><a id="c2-para-0519"/>list(<b>null</b>, list(3), list(2), list(2, 3),</p>
<p class="Sp-text-1"><a id="c2-para-0520"/>     list(1), list(1, 3), list(1, 2),</p>
<p class="Sp-text-1"><a id="c2-para-0521"/>     list(1, 2, 3))</p>
<p class="paracontinue"><a id="c2-para-0522"/>Complete the following declaration of a function that generates the set of subsets of a set and give a clear explanation of why it works:</p>
<p class="Sp-text-1"><a id="c2-para-0523"/><b>function</b> subsets(s) {</p>
<p class="Sp-text-1"><a id="c2-para-0524"/>    <b>if</b> (is_null(s)) {</p>
<p class="Sp-text-1"><a id="c2-para-0525"/>        <b>return</b> list(<b>null</b>);</p>
<p class="Sp-text-1"><a id="c2-para-0526"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-0527"/>        <b>const</b> rest = subsets(tail(s));</p>
<p class="Sp-text-1"><a id="c2-para-0528"/>        <b>return</b> append(rest, map( ?? , rest));</p>
<p class="Sp-text-1"><a id="c2-para-0529"/>    <sub>}</sub></p>
<p class="Sp-text-1"><a id="c2-para-0530"/>}</p>
</section>
</section>
<section>
<h3><a id="c2-sec-0047"/><span>2.2.3</span> <a id="c2-title-0048"/>Sequences as Conventional Interfaces</h3>
<p class="paraaftertitle"><a id="c2-para-0531"/>In working with compound data, we've stressed how data abstraction permits us to design programs without becoming enmeshed in the details of data representations, and how abstraction preserves for us the flexibility to experiment with alternative representations. In this section, we introduce another powerful design principle for working with data structures—the use of <i>conventional interfaces</i>.</p>
<p><a id="c2-para-0532"/>In section 1.3 we saw how program abstractions, implemented as higher-order functions, can capture common patterns in programs that deal with numerical data. Our ability to formulate analogous operations for working with compound data depends crucially on the style in which we manipulate our data structures. Consider, for example, the following function, analogous to the <span class="KeyTerm1">count_leaves</span> function of section 2.2.2, which takes a tree as argument and computes the sum of the squares of the leaves that are odd:</p>
<p class="Sp-text-1"><a id="c2-para-0533"/><b>function</b> sum_odd_squares(tree) {</p>
<p class="Sp-text-1"><a id="c2-para-0534"/>    <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c2-para-0535"/>           ? 0</p>
<p class="Sp-text-1"><a id="c2-para-0536"/>           : ! is_pair(tree)</p>
<p class="Sp-text-1"><a id="c2-para-0537"/>           ? is_odd(tree) ? square(tree) : 0</p>
<p class="Sp-text-1"><a id="c2-para-0538"/>           : sum_odd_squares(head(tree)) +</p>
<p class="Sp-text-1"><a id="c2-para-0539"/>             sum_odd_squares(tail(tree));</p>
<p class="Sp-text-1"><a id="c2-para-0540"/>}</p>
<p class="paracontinue"><a id="c2-para-0541"/>On the surface, this function is very different from the following one, which constructs a list of all the even Fibonacci numbers Fib(<i>k</i>), where <i>k</i> is less than or equal to a given integer <i>n</i>:</p>
<p class="Sp-text-1"><a id="c2-para-0542"/><b>function</b> even_fibs(n) {</p>
<p class="Sp-text-1"><a id="c2-para-0543"/>    <b>function</b> next(k) {</p>
<p class="Sp-text-1"><a id="c2-para-0544"/>        <b>if</b> (k &gt; n) {</p>
<p class="Sp-text-1"><a id="c2-para-0545"/>            <b>return null</b>;</p>
<p class="Sp-text-1"><a id="c2-para-0546"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-0547"/>            <b>const</b> f = fib(k);</p>
<p class="Sp-text-1"><a id="c2-para-0548"/>            <b>return</b> is_even(f)</p>
<p class="Sp-text-1"><a id="c2-para-0549"/>                   ? pair(f, next(k + 1))</p>
<p class="Sp-text-1"><a id="c2-para-0550"/>                   : next(k + 1);</p>
<p class="Sp-text-1"><a id="c2-para-0551"/>        }</p>
<p class="Sp-text-1"><a id="c2-para-0552"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-0553"/>    <b>return</b> next(0);</p>
<p class="Sp-text-1"><a id="c2-para-0554"/>}</p>
<p><a id="c2-para-0555"/>Despite the fact that these two functions are structurally very different, a more abstract description of the two computations reveals a great deal of similarity. The first program</p>
<ul style="list-style-type:disc">
<li>enumerates the leaves of a tree;</li>
<li>filters them, selecting the odd ones;</li>
<li>squares each of the selected ones; and</li>
<li>accumulates the results using <span class="KeyTerm1">+</span>, starting with 0.</li>
</ul>

<p class="paracontinue"><a id="c2-para-0560"/>The second program</p>
<ul style="list-style-type:disc">
<li>enumerates the integers from 0 to <i>n</i>;</li>
<li>computes the Fibonacci number for each integer;</li>
<li>filters them, selecting the even ones; and</li>
<li>accumulates the results using <span class="KeyTerm1">pair</span>, starting with the empty list.</li>
</ul>

<p><a id="c2-para-0565"/>A signal-processing engineer would find it natural to conceptualize these processes in terms of signals flowing through a cascade of stages, each of which implements part of the program plan, as shown in <a id="c2-fig-0012a"/><a href="#c2-fig-0012">figure 2.7</a>. In <span class="KeyTerm1">sum_odd_squares</span>, we begin with an <i>enumerator</i>, which generates a “signal” consisting of the leaves of a given tree. This signal is passed through a <i>filter</i>, which eliminates all but the odd elements. The resulting signal is in turn passed through a <i>map</i>, which is a “transducer” that applies the <span class="KeyTerm1">square</span> function to each element. The output of the map is then fed to an <i>accumulator</i>, which combines the elements using <span class="KeyTerm1">+</span>, starting from an initial 0. The plan for <span class="KeyTerm1">even_fibs</span> is analogous.</p>
<figure id="c2-fig-0012"><img alt="c2-fig-0007.jpg" src="../images/c2-fig-0007.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0012a">Figure 2.7</a></span> <a id="c2-para-0566"/>The signal-flow plans for the functions <span class="KeyTerm1">sum_odd_squares</span> (top) and <span class="KeyTerm1">even_fibs</span> (bottom) reveal the commonality between the two programs.</p></figcaption></figure>
<p><a id="c2-para-0567"/>Unfortunately, the two function declarations above fail to exhibit this signal-flow structure. For instance, if we examine the <span class="KeyTerm1">sum_odd_squares</span> function, we find that the enumeration is implemented partly by the <span class="KeyTerm1">is_null</span> and <span class="KeyTerm1">is_pair</span> tests and partly by the tree-recursive structure of the function. Similarly, the accumulation is found partly in the tests and partly in the addition used in the recursion. In general, there are no distinct parts of either function that correspond to the elements in the signalflow description. Our two functions decompose the computations in a different way, spreading the enumeration over the program and mingling it with the map, the filter, and the accumulation. If we could organize our programs to make the signal-flow structure manifest in the functions we write, this would increase the conceptual clarity of the resulting program.</p>
<section>
<h5><a id="c2-sec-0048"/><a id="c2-title-0049"/>Sequence Operations</h5>
<p class="paraaftertitle"><a id="c2-para-0568"/>The key to organizing programs so as to more clearly reflect the signal-flow structure is to concentrate on the “signals” that flow from one stage in the process to the next. If we represent these signals as lists, then we can use list operations to implement the processing at each of the stages. For instance, we can implement the mapping stages of the signal-flow diagrams using the <span class="KeyTerm1">map</span> function from section 2.2.1:</p>
<p class="Sp-text-1"><a id="c2-para-0569"/>map(square, list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c2-para-0570"/><i>list(1, 4, 9, 16, 25)</i></p>
<p><a id="c2-para-0571"/>Filtering a sequence to select only those elements that satisfy a given predicate is accomplished by</p>
<p class="Sp-text-1"><a id="c2-para-0572"/><b>function</b> filter(predicate, sequence) {</p>
<p class="Sp-text-1"><a id="c2-para-0573"/>    <b>return</b> is_null(sequence)</p>
<p class="Sp-text-1"><a id="c2-para-0574"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-0575"/>           : predicate(head(sequence))</p>
<p class="Sp-text-1"><a id="c2-para-0576"/>           ? pair(head(sequence),</p>
<p class="Sp-text-1"><a id="c2-para-0577"/>                  filter(predicate, tail(sequence)))</p>
<p class="Sp-text-1"><a id="c2-para-0578"/>           : filter(predicate, tail(sequence));</p>
<p class="Sp-text-1"><a id="c2-para-0579"/>}</p>
<p class="paracontinue"><a id="c2-para-0580"/>For example,</p>
<p class="Sp-text-1"><a id="c2-para-0581"/>filter(is_odd, list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c2-para-0582"/><i>list(1, 3, 5)</i></p>
<p><a id="c2-para-0583"/>Accumulations can be implemented by</p>
<p class="Sp-text-1"><a id="c2-para-0584"/><b>function</b> accumulate(op, initial, sequence) {</p>
<p class="Sp-text-1"><a id="c2-para-0585"/>    <b>return</b> is_null(sequence)</p>
<p class="Sp-text-1"><a id="c2-para-0586"/>           ? initial</p>
<p class="Sp-text-1"><a id="c2-para-0587"/>           : op(head(sequence),</p>
<p class="Sp-text-1"><a id="c2-para-0588"/>                accumulate(op, initial, tail(sequence)));</p>
<p class="Sp-text-1"><a id="c2-para-0589"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0590"/>accumulate(plus, 0, list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c2-para-0591"/><i>15</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0592"/>accumulate(times, 1, list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c2-para-0593"/><i>120</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0594"/>accumulate(pair, <b>null</b>, list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c2-para-0595"/><i>list(1, 2, 3, 4, 5)</i></p>
<p><a id="c2-para-0596"/>All that remains to implement signal-flow diagrams is to enumerate the sequence of elements to be processed. For <span class="KeyTerm1">even_fibs</span>, we need to generate the sequence of integers in a given range, which we can do as follows:</p>
<p class="Sp-text-1"><a id="c2-para-0597"/><b>function</b> enumerate_interval(low, high) {</p>
<p class="Sp-text-1"><a id="c2-para-0598"/>    <b>return</b> low &gt; high</p>
<p class="Sp-text-1"><a id="c2-para-0599"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-0600"/>           : pair(low,</p>
<p class="Sp-text-1"><a id="c2-para-0601"/>                  enumerate_interval(low + 1, high));</p>
<p class="Sp-text-1"><a id="c2-para-0602"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0603"/>enumerate_interval(2, 7);</p>
<p class="Sp-text-1"><a id="c2-para-0604"/><i>list(2, 3, 4, 5, 6, 7)</i></p>
<p class="paracontinue"><a id="c2-para-0605"/>To enumerate the leaves of a tree, we can use<a id="c2-fn-0012a"/><a href="#c2-fn-0012"><sup>12</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0606"/><b>function</b> enumerate_tree(tree) {</p>
<p class="Sp-text-1"><a id="c2-para-0607"/>    <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c2-para-0608"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-0609"/>           : ! is_pair(tree)</p>
<p class="Sp-text-1"><a id="c2-para-0610"/>           ? list(tree)</p>
<p class="Sp-text-1"><a id="c2-para-0611"/>           : append(enumerate_tree(head(tree)),</p>
<p class="Sp-text-1"><a id="c2-para-0612"/>                    enumerate_tree(tail(tree)));</p>
<p class="Sp-text-1"><a id="c2-para-0613"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0614"/>enumerate_tree(list(1, list(2, list(3, 4)), 5));</p>
<p class="Sp-text-1"><a id="c2-para-0615"/><i>list(1, 2, 3, 4, 5)</i></p>
<p><a id="c2-para-0616"/>Now we can reformulate <span class="KeyTerm1">sum_odd_squares</span> and <span class="KeyTerm1">even_fibs</span> as in the signalflow diagrams. For <span class="KeyTerm1">sum_odd_squares</span>, we enumerate the sequence of leaves of the tree, filter this to keep only the odd numbers in the sequence, square each element, and sum the results:</p>
<p class="Sp-text-1"><a id="c2-para-0617"/><b>function</b> sum_odd_squares(tree) {</p>
<p class="Sp-text-1"><a id="c2-para-0618"/>    <b>return</b> accumulate(plus,</p>
<p class="Sp-text-1"><a id="c2-para-0619"/>                      0,</p>
<p class="Sp-text-1"><a id="c2-para-0620"/>                      map(square,</p>
<p class="Sp-text-1"><a id="c2-para-0621"/>                          filter(is_odd,</p>
<p class="Sp-text-1"><a id="c2-para-0622"/>                                 enumerate_tree(tree))));</p>
<p class="Sp-text-1"><a id="c2-para-0623"/>}</p>
<p class="paracontinue"><a id="c2-para-0624"/>For <span class="KeyTerm1">even_fibs</span>, we enumerate the integers from 0 to <i>n</i>, generate the Fibonacci number for each of these integers, filter the resulting sequence to keep only the even elements, and accumulate the results into a list:</p>
<p class="Sp-text-1"><a id="c2-para-0625"/><b>function</b> even_fibs(n) {</p>
<p class="Sp-text-1"><a id="c2-para-0626"/>    <b>return</b> accumulate(pair,</p>
<p class="Sp-text-1"><a id="c2-para-0627"/>                      <b>null</b>,</p>
<p class="Sp-text-1"><a id="c2-para-0628"/>                      filter(is_even,</p>
<p class="Sp-text-1"><a id="c2-para-0629"/>                             map(fib,</p>
<p class="Sp-text-1"><a id="c2-para-0630"/>                                 enumerate_interval(0, n))));</p>
<p class="Sp-text-1"><a id="c2-para-0631"/>}</p>
<p><a id="c2-para-0632"/>The value of expressing programs as sequence operations is that this helps us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces. We can encourage modular design by providing a library of standard components together with a conventional interface for connecting the components in flexible ways.</p>
<p><a id="c2-para-0633"/>Modular construction is a powerful strategy for controlling complexity in engineering design. In real signal-processing applications, for example, designers regularly build systems by cascading elements selected from standardized families of filters and transducers. Similarly, sequence operations provide a library of standard program elements that we can mix and match. For instance, we can reuse pieces from the <span class="KeyTerm1">sum_odd_squares</span> and <span class="KeyTerm1">even_fibs</span> functions in a program that constructs a list of the squares of the first <i>n</i> + 1 Fibonacci numbers:</p>
<p class="Sp-text-1"><a id="c2-para-0634"/><b>function</b> list_fib_squares(n) {</p>
<p class="Sp-text-1"><a id="c2-para-0635"/>    <b>return</b> accumulate(pair,</p>
<p class="Sp-text-1"><a id="c2-para-0636"/>                      <b>null</b>,</p>
<p class="Sp-text-1"><a id="c2-para-0637"/>                      map(square,</p>
<p class="Sp-text-1"><a id="c2-para-0638"/>                          map(fib,</p>
<p class="Sp-text-1"><a id="c2-para-0639"/>                              enumerate_interval(0, n))));</p>
<p class="Sp-text-1"><a id="c2-para-0640"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0641"/>list_fib_squares(10);</p>
<p class="Sp-text-1"><a id="c2-para-0642"/><i>list(0, 1, 1, 4, 9, 25, 64, 169, 441, 1156, 3025)</i></p>
<p class="paracontinue"><a id="c2-para-0643"/>We can rearrange the pieces and use them in computing the product of the squares of the odd integers in a sequence:</p>
<p class="Sp-text-1"><a id="c2-para-0644"/><b>function</b> product_of_squares_of_odd_elements(sequence) {</p>
<p class="Sp-text-1"><a id="c2-para-0645"/>    <b>return</b> accumulate(times,</p>
<p class="Sp-text-1"><a id="c2-para-0646"/>                      1,</p>
<p class="Sp-text-1"><a id="c2-para-0647"/>                      map(square,</p>
<p class="Sp-text-1"><a id="c2-para-0648"/>                          filter(is_odd, sequence)));</p>
<p class="Sp-text-1"><a id="c2-para-0649"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0650"/>product_of_squares_of_odd_elements(list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c2-para-0651"/><i>225</i></p>
<p><a id="c2-para-0652"/>We can also formulate conventional data-processing applications in terms of sequence operations. Suppose we have a sequence of personnel records and we want to find the salary of the highest-paid programmer. Assume that we have a selector <span class="KeyTerm1">salary</span> that returns the salary of a record, and a predicate <span class="KeyTerm1">is_programmer</span> that tests if a record is for a programmer. Then we can write</p>
<p class="Sp-text-1"><a id="c2-para-0653"/><b>function</b> salary_of_highest_paid_programmer(records) {</p>
<p class="Sp-text-1"><a id="c2-para-0654"/>    <b>return</b> accumulate(math_max,</p>
<p class="Sp-text-1"><a id="c2-para-0655"/>                      0,</p>
<p class="Sp-text-1"><a id="c2-para-0656"/>                      map(salary,</p>
<p class="Sp-text-1"><a id="c2-para-0657"/>                          filter(is_programmer, records)));</p>
<p class="Sp-text-1"><a id="c2-para-0658"/>}</p>
<p class="paracontinue"><a id="c2-para-0659"/>These examples give just a hint of the vast range of operations that can be expressed as sequence operations.<a id="c2-fn-0013a"/><a href="#c2-fn-0013"><sup>13</sup></a></p>
<p><a id="c2-para-0660"/>Sequences, implemented here as lists, serve as a conventional interface that permits us to combine processing modules. Additionally, when we uniformly represent structures as sequences, we have localized the data-structure dependencies in our programs to a small number of sequence operations. By changing these, we can experiment with alternative representations of sequences, while leaving the overall design of our programs intact. We will exploit this capability in section 3.5, when we generalize the sequence-processing paradigm to admit infinite sequences.</p>
</section>
<section>
<h5><a id="c2-sec-0049"/><a id="c2-title-0050"/>Exercise 2.33</h5>
<p class="paraaftertitle"><a id="c2-para-0661"/>Fill in the missing expressions to complete the following definitions of some basic listmanipulation operations as accumulations:</p>
<p class="Sp-text-1"><a id="c2-para-0662"/><b>function</b> map(f, sequence) {</p>
<p class="Sp-text-1"><a id="c2-para-0663"/>    <b>return</b> accumulate((x, y) =&gt; 〈??〉,</p>
<p class="Sp-text-1"><a id="c2-para-0664"/>                      <b>null</b>, sequence);</p>
<p class="Sp-text-1"><a id="c2-para-0665"/><sub>}</sub></p>
<p class="Sp-text-1"><a id="c2-para-0666"/><b>function</b> append(seq1, seq2) {</p>
<p class="Sp-text-1"><a id="c2-para-0667"/>    <b>return</b> accumulate(pair, 〈??〉, 〈??〉);</p>
<p class="Sp-text-1"><a id="c2-para-0668"/><sub>}</sub></p>
<p class="Sp-text-1"><a id="c2-para-0669"/><b>function</b> length(sequence) {</p>
<p class="Sp-text-1"><a id="c2-para-0670"/>    <b>return</b> accumulate( 〈??〉, 0, sequence);</p>
<p class="Sp-text-1"><a id="c2-para-0671"/><sub>}</sub></p>
</section>
<section>
<h5><a id="c2-sec-0050"/><a id="c2-title-0051"/>Exercise 2.34</h5>
<p class="paraaftertitle"><a id="c2-para-0672"/>Evaluating a polynomial in <i>x</i> at a given value of <i>x</i> can be formulated as an accumulation. We evaluate the polynomial</p>
<p class="Sp-text-2"><a id="c2-para-0673"/><i>a<sub>n</sub>x<sup>n</sup></i> + <i>a<sub>n</sub></i><sub>–1</sub><i>x<sup>n</sup></i><sup>–1</sup> + · · · + <i>a</i><sub>1</sub><i>x</i> + <i>a</i><sub>0</sub></p>
<p class="paracontinue"><a id="c2-para-0674"/>using a well-known algorithm called <i>Horner's rule</i>, which structures the computation as </p>
<p class="Sp-text-2"><a id="c2-para-0675"/>(· · · (a<sub>n</sub>x + a<sub>n–1</sub>)x + · · · + a<sub>1</sub>) x + a<sub>0</sub></p>
<p class="paracontinue"><a id="c2-para-0676"/>In other words, we start with <i>a<sub>n</sub></i>, multiply by <i>x</i>, add <i>a<sub>n</sub></i><sub>–1</sub>, multiply by <i>x</i>, and so on, until we reach <i>a</i><sub>0</sub>.<a id="c2-fn-0014a"/><a href="#c2-fn-0014"><sup>14</sup></a> Fill in the following template to produce a function that evaluates a polynomial using Horner's rule. Assume that the coefficients of the polynomial are arranged in a sequence, from <i>a</i><sub>0</sub> through <i>a<sub>n</sub></i>.</p>
<p class="Sp-text-1"><a id="c2-para-0677"/><b>function</b> horner_eval(x, coefficient_sequence) {</p>
<p class="Sp-text-1"><a id="c2-para-0678"/>    <b>return</b> accumulate((this_coeff, higher_terms) =&gt; ?? ,</p>
<p class="Sp-text-1"><a id="c2-para-0679"/>                      0,</p>
<p class="Sp-text-1"><a id="c2-para-0680"/>                      coefficient_sequence);</p>
<p class="Sp-text-1"><a id="c2-para-0681"/>}</p>
<p class="paracontinue"><a id="c2-para-0682"/>For example, to compute 1 + 3<i>x</i> + 5<i>x</i><sup>3</sup> + <i>x</i><sup>5</sup> at <i>x</i> = 2 you would evaluate</p>
<p class="Sp-text-1"><a id="c2-para-0683"/>horner_eval(2, list(1, 3, 0, 5, 0, 1));</p>
</section>
<section>
<h5><a id="c2-sec-0051"/><a id="c2-title-0052"/>Exercise 2.35</h5>
<p class="paraaftertitle"><a id="c2-para-0684"/>Redefine <span class="KeyTerm1">count_leaves</span> from section 2.2.2 as an accumulation:</p>
<p class="Sp-text-1"><a id="c2-para-0685"/><b>function</b> count_leaves(t) {</p>
<p class="Sp-text-1"><a id="c2-para-0686"/>    <b>return</b> accumulate( ?? , ?? , map( ?? , ?? ));</p>
<p class="Sp-text-1"><a id="c2-para-0687"/><sub>}</sub></p>
</section>
<section>
<h5><a id="c2-sec-0052"/><a id="c2-title-0053"/>Exercise 2.36</h5>
<p class="paraaftertitle"><a id="c2-para-0688"/>The function <span class="KeyTerm1">accumulate_n</span> is similar to <span class="KeyTerm1">accumulate</span> except that it takes as its third argument a sequence of sequences, which are all assumed to have the same number of elements. It applies the designated accumulation function to combine all the first elements of the sequences, all the second elements of the sequences, and so on, and returns a sequence of the results. For instance, if <span class="KeyTerm1">s</span> is a sequence containing four sequences</p>
<p class="Sp-text-1"><a id="c2-para-0689"/>list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9), list(10, 11, 12))</p>
<p class="paracontinue"><a id="c2-para-0690"/>then the value of <span class="KeyTerm1">accumulate_n(plus, 0, s)</span> should be the sequence <span class="KeyTerm1">list(22, 26, 30)</span>. Fill in the missing expressions in the following definition of <span class="KeyTerm1">accumulate_n</span>:</p>
<p class="Sp-text-1"><a id="c2-para-0691"/><b>function</b> accumulate_n(op, init, seqs) {</p>
<p class="Sp-text-1"><a id="c2-para-0692"/>    <b>return</b> is_null(head(seqs))</p>
<p class="Sp-text-1"><a id="c2-para-0693"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-0694"/>           : pair(accumulate(op, init, 〈??〉),</p>
<p class="Sp-text-1"><a id="c2-para-0695"/>                  accumulate_n(op, init, 〈??〉));</p>
<p class="Sp-text-1"><a id="c2-para-0696"/><sub>}</sub></p>
</section>
<section>
<h5><a id="c2-sec-0053"/><a id="c2-title-0054"/>Exercise 2.37</h5>
<p class="paraaftertitle"><a id="c2-para-0697"/>Suppose we represent vectors <i>v</i> = (<i>v<sub>i</sub></i>) as sequences of numbers, and matrices <i>m</i> = (<i>m<sub>ij</sub></i>) as sequences of vectors (the rows of the matrix). For example, the matrix</p>
<p><a id="c2-para-0698"/></p>
<figure id="c2-fig-0013"><img alt="c2-fig-5006.jpg" src="../images/c2-fig-5006.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c2-para-0699"/>is represented as the following sequence:</p>
<p class="Sp-text-1"><a id="c2-para-0700"/>list(list(1, 2, 3, 4),</p>
<p class="Sp-text-1"><a id="c2-para-0701"/>     list(4, 5, 6, 6),</p>
<p class="Sp-text-1"><a id="c2-para-0702"/>     list(6, 7, 8, 9))</p>
<p class="paracontinue"><a id="c2-para-0703"/>With this representation, we can use sequence operations to concisely express the basic matrix and vector operations. These operations (which are described in any book on matrix algebra) are the following:</p>
<p><a id="c2-para-0704"/></p>
<figure id="c2-fig-0014"><img alt="c2-fig-5007.jpg" src="../images/c2-fig-5007.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c2-para-0705"/>We can define the dot product as<a id="c2-fn-0015a"/><a href="#c2-fn-0015"><sup>15</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0706"/><b>function</b> dot_product(v, w) {</p>
<p class="Sp-text-1"><a id="c2-para-0707"/>    <b>return</b> accumulate(plus, 0, accumulate_n(times, 1, list(v, w)));</p>
<p class="Sp-text-1"><a id="c2-para-0708"/>}</p>
<p class="paracontinue"><a id="c2-para-0709"/>Fill in the missing expressions in the following functions for computing the other matrix operations. (The function <span class="KeyTerm1">accumulate_n</span> is declared in exercise 2.36.)</p>
<p class="Sp-text-1"><a id="c2-para-0710"/><b>function</b> matrix_times_vector(m, v) {</p>
<p class="Sp-text-1"><a id="c2-para-0711"/>    <b>return</b> map( ?? , m);</p>
<p class="Sp-text-1"><a id="c2-para-0712"/><sub>}</sub></p>
<p class="Sp-text-1"><a id="c2-para-0713"/><b>function</b> transpose(mat) {</p>
<p class="Sp-text-1"><a id="c2-para-0714"/>    <b>return</b> accumulate_n( ?? , ?? , mat);</p>
<p class="Sp-text-1"><a id="c2-para-0715"/><sub>}</sub></p>
<p class="Sp-text-1"><a id="c2-para-0716"/><b>function</b> matrix_times_matrix(n, m) {</p>
<p class="Sp-text-1"><a id="c2-para-0717"/>    <b>const</b> cols = transpose(n);</p>
<p class="Sp-text-1"><a id="c2-para-0718"/>    <b>return</b> map( ?? , m);</p>
<p class="Sp-text-1"><a id="c2-para-0719"/><sub>}</sub></p>
</section>
<section>
<h5><a id="c2-sec-0054"/><a id="c2-title-0055"/>Exercise 2.38</h5>
<p class="paraaftertitle"><a id="c2-para-0720"/>The <span class="KeyTerm1">accumulate</span> function is also known as <span class="KeyTerm1">fold_right</span>, because it combines the first element of the sequence with the result of combining all the elements to the right. There is also a <span class="KeyTerm1">fold_left</span>, which is similar to <span class="KeyTerm1">fold_right</span>, except that it combines elements working in the opposite direction:</p>
<p class="Sp-text-1"><a id="c2-para-0721"/><b>function</b> fold_left(op, initial, sequence) {</p>
<p class="Sp-text-1"><a id="c2-para-0722"/>    <b>function</b> iter(result, rest) {</p>
<p class="Sp-text-1"><a id="c2-para-0723"/>        <b>return</b> is_null(rest)</p>
<p class="Sp-text-1"><a id="c2-para-0724"/>               ? result</p>
<p class="Sp-text-1"><a id="c2-para-0725"/>               : iter(op(result, head(rest)),</p>
<p class="Sp-text-1"><a id="c2-para-0726"/>                      tail(rest));</p>
<p class="Sp-text-1"><a id="c2-para-0727"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-0728"/>    <b>return</b> iter(initial, sequence);</p>
<p class="Sp-text-1"><a id="c2-para-0729"/>}</p>
<p class="paracontinue"><a id="c2-para-0730"/>What are the values of</p>
<p class="Sp-text-1"><a id="c2-para-0731"/>fold_right(divide, 1, list(1, 2, 3));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0732"/>fold_left(divide, 1, list(1, 2, 3));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0733"/>fold_right(list, <b>null</b>, list(1, 2, 3));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0734"/>fold_left(list, <b>null</b>, list(1, 2, 3));</p>
<p class="paracontinue"><a id="c2-para-0735"/>Give a property that <span class="KeyTerm1">op</span> should satisfy to guarantee that <span class="KeyTerm1">fold_right</span> and <span class="KeyTerm1">fold_left</span> will produce the same values for any sequence.</p>
</section>
<section>
<h5><a id="c2-sec-0055"/><a id="c2-title-0056"/>Exercise 2.39</h5>
<p class="paraaftertitle"><a id="c2-para-0736"/>Complete the following definitions of <span class="KeyTerm1">reverse</span> (exercise 2.18) in terms of <span class="KeyTerm1">fold_right</span> and <span class="KeyTerm1">fold_left</span> from exercise 2.38:</p>
<p class="Sp-text-1"><a id="c2-para-0737"/><b>function</b> reverse(sequence) {</p>
<p class="Sp-text-1"><a id="c2-para-0738"/>    <b>return</b> fold_right((x, y) =&gt; ?? , <b>null</b>, sequence);</p>
<p class="Sp-text-1"><a id="c2-para-0739"/><sub>}</sub></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0740"/><b>function</b> reverse(sequence) {</p>
<p class="Sp-text-1"><a id="c2-para-0741"/>    <b>return</b> fold_left((x, y) =&gt; ?? , <b>null</b>, sequence);</p>
<p class="Sp-text-1"><a id="c2-para-0742"/><sub>}</sub></p>
</section>
<section>
<h5><a id="c2-sec-0056"/><a id="c2-title-0057"/>Nested Mappings</h5>
<p class="paraaftertitle"><a id="c2-para-0743"/>We can extend the sequence paradigm to include many computations that are commonly expressed using nested loops.<a id="c2-fn-0016a"/><a href="#c2-fn-0016"><sup>16</sup></a> Consider this problem: Given a positive integer <i>n</i>, find all ordered pairs of distinct positive integers <i>i</i> and <i>j</i>, where 1 <i>j</i> &lt; <i>i n</i>, such that <i>i</i> + <i>j</i> is prime. For example, if <i>n</i> is 6, then the pairs are the following:</p>
<figure><figcaption class="tablecaption"><a id="c2-tbl-0001"/></figcaption>
<div class="big_device">
<table border="1"><tbody>
<tr>
<td><a id="c2-para-0744"/><i>i</i></td>
<td><a id="c2-para-0745"/>2</td>
<td><a id="c2-para-0746"/>3</td>
<td><a id="c2-para-0747"/>4</td>
<td><a id="c2-para-0748"/>4</td>
<td><a id="c2-para-0749"/>5</td>
<td><a id="c2-para-0750"/>6</td>
<td><a id="c2-para-0751"/>6</td></tr>
<tr>
<td><a id="c2-para-0752"/><i>j</i></td>
<td><a id="c2-para-0753"/>1</td>
<td><a id="c2-para-0754"/>2</td>
<td><a id="c2-para-0755"/>1</td>
<td><a id="c2-para-0756"/>3</td>
<td><a id="c2-para-0757"/>2</td>
<td><a id="c2-para-0758"/>1</td>
<td><a id="c2-para-0759"/>5</td></tr>
<tr>
<td><a id="c2-para-0760"/><i>i</i> + <i>j</i></td>
<td><a id="c2-para-0761"/>3</td>
<td><a id="c2-para-0762"/>5</td>
<td><a id="c2-para-0763"/>5</td>
<td><a id="c2-para-0764"/>7</td>
<td><a id="c2-para-0765"/>7</td>
<td><a id="c2-para-0766"/>7</td>
<td><a id="c2-para-0767"/>11</td></tr></tbody></table></div>
</figure>

<p class="paracontinue"><a id="c2-para-0768"/>A natural way to organize this computation is to generate the sequence of all ordered pairs of positive integers less than or equal to <i>n</i>, filter to select those pairs whose sum is prime, and then, for each pair (<i>i</i>, <i>j</i>) that passes through the filter, produce the triple (<i>i</i>, <i>j</i>, <i>i</i> + <i>j</i>).</p>
<p><a id="c2-para-0769"/>Here is a way to generate the sequence of pairs: For each integer <i>i n</i>, enumerate the integers <i>j</i> &lt; <i>i</i>, and for each such <i>i</i> and <i>j</i> generate the pair (<i>i</i>, <i>j</i>). In terms of sequence operations, we map along the sequence <span class="KeyTerm1">enumerate_interval(1, n)</span>. For each <i>i</i> in this sequence, we map along the sequence <span class="KeyTerm1">enumerate_interval(1, i - 1)</span>. For each <i>j</i> in this latter sequence, we generate the pair <span class="KeyTerm1">list(i, j)</span>. This gives us a sequence of pairs for each <i>i</i>. Combining all the sequences for all the <i>i</i> (by accumulating with <span class="KeyTerm1">append</span>) produces the required sequence of pairs:<a id="c2-fn-0017a"/><a href="#c2-fn-0017"><sup>17</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0770"/>accumulate(append,</p>
<p class="Sp-text-1"><a id="c2-para-0771"/>           <b>null</b>,</p>
<p class="Sp-text-1"><a id="c2-para-0772"/>           map(i =&gt; map(j =&gt; list(i, j),</p>
<p class="Sp-text-1"><a id="c2-para-0773"/>                        enumerate_interval(1, i - 1)),</p>
<p class="Sp-text-1"><a id="c2-para-0774"/>               enumerate_interval(1, n)));</p>
<p class="paracontinue"><a id="c2-para-0775"/>The combination of mapping and accumulating with <span class="KeyTerm1">append</span> is so common in this sort of program that we will isolate it as a separate function:</p>
<p class="Sp-text-1"><a id="c2-para-0776"/><b>function</b> flatmap(f, seq) {</p>
<p class="Sp-text-1"><a id="c2-para-0777"/>    <b>return</b> accumulate(append, <b>null</b>, map(f, seq));</p>
<p class="Sp-text-1"><a id="c2-para-0778"/>}</p>
<p class="paracontinue"><a id="c2-para-0779"/>Now filter this sequence of pairs to find those whose sum is prime. The filter predicate is called for each element of the sequence; its argument is a pair and it must extract the integers from the pair. Thus, the predicate to apply to each element in the sequence is</p>
<p class="Sp-text-1"><a id="c2-para-0780"/><b>function</b> is_prime_sum(pair) {</p>
<p class="Sp-text-1"><a id="c2-para-0781"/>    <b>return</b> is_prime(head(pair) + head(tail(pair)));</p>
<p class="Sp-text-1"><a id="c2-para-0782"/>}</p>
<p class="paracontinue"><a id="c2-para-0783"/>Finally, generate the sequence of results by mapping over the filtered pairs using the following function, which constructs a triple consisting of the two elements of the pair along with their sum:</p>
<p class="Sp-text-1"><a id="c2-para-0784"/><b>function</b> make_pair_sum(pair) {</p>
<p class="Sp-text-1"><a id="c2-para-0785"/>    <b>return</b> list(head(pair), head(tail(pair)),</p>
<p class="Sp-text-1"><a id="c2-para-0786"/>                head(pair) + head(tail(pair)));</p>
<p class="Sp-text-1"><a id="c2-para-0787"/>}</p>
<p class="paracontinue"><a id="c2-para-0788"/>Combining all these steps yields the complete function:</p>
<p class="Sp-text-1"><a id="c2-para-0789"/><b>function</b> prime_sum_pairs(n) {</p>
<p class="Sp-text-1"><a id="c2-para-0790"/>    <b>return</b> map(make_pair_sum,</p>
<p class="Sp-text-1"><a id="c2-para-0791"/>               filter(is_prime_sum,</p>
<p class="Sp-text-1"><a id="c2-para-0792"/>                      flatmap(i =&gt; map(j =&gt; list(i, j),</p>
<p class="Sp-text-1"><a id="c2-para-0793"/>                                       enumerate_interval(1, i - 1)),</p>
<p class="Sp-text-1"><a id="c2-para-0794"/>                              enumerate_interval(1, n))));</p>
<p class="Sp-text-1"><a id="c2-para-0795"/>}</p>
<p><a id="c2-para-0796"/>Nested mappings are also useful for sequences other than those that enumerate intervals. Suppose we wish to generate all the permutations of a set <i>S</i>; that is, all the ways of ordering the items in the set. For instance, the permutations of {1, 2, 3} are {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, and {3, 2, 1}. Here is a plan for generating the permutations of <i>S</i>: For each item <i>x</i> in <i>S</i>, recursively generate the sequence of permutations of <i>S</i> – <i>x</i>,<a id="c2-fn-0018a"/><a href="#c2-fn-0018"><sup>18</sup></a> and adjoin <i>x</i> to the front of each one. This yields, for each <i>x</i> in <i>S</i>, the sequence of permutations of <i>S</i> that begin with <i>x</i>. Combining these sequences for all <i>x</i> gives all the permutations of <i>S</i>:<a id="c2-fn-0019a"/><a href="#c2-fn-0019"><sup>19</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0797"/><b>function</b> permutations(s) {</p>
<p class="Sp-text-1"><a id="c2-para-0798"/>    <b>return</b> is_null(s) <span class="KeyTerm2"><i>// empty set?</i></span></p>
<p class="Sp-text-1"><a id="c2-para-0799"/>           ? list(<b>null</b>) <span class="KeyTerm2"><i>// sequence containing empty set</i></span></p>
<p class="Sp-text-1"><a id="c2-para-0800"/>           : flatmap(x =&gt; map(p =&gt; pair(x, p),</p>
<p class="Sp-text-1"><a id="c2-para-0801"/>                              permutations(remove(x, s))),</p>
<p class="Sp-text-1"><a id="c2-para-0802"/>                     s);</p>
<p class="Sp-text-1"><a id="c2-para-0803"/>}</p>
<p class="paracontinue"><a id="c2-para-0804"/>Notice how this strategy reduces the problem of generating permutations of <i>S</i> to the problem of generating the permutations of sets with fewer elements than <i>S</i>. In the terminal case, we work our way down to the empty list, which represents a set of no elements. For this, we generate <span class="KeyTerm1">list(<b>null</b>)</span>, which is a sequence with one item, namely the set with no elements. The <span class="KeyTerm1">remove</span> function used in <span class="KeyTerm1">permutations</span> returns all the items in a given sequence except for a given item. This can be expressed as a simple filter:</p>
<p class="Sp-text-1"><a id="c2-para-0805"/><b>function</b> remove(item, sequence) {</p>
<p class="Sp-text-1"><a id="c2-para-0806"/>    <b>return</b> filter(x =&gt; ! (x === item),</p>
<p class="Sp-text-1"><a id="c2-para-0807"/>                  sequence);</p>
<p class="Sp-text-1"><a id="c2-para-0808"/>}</p>
</section>
<section>
<h5><a id="c2-sec-0057"/><a id="c2-title-0058"/>Exercise 2.40</h5>
<p class="paraaftertitle"><a id="c2-para-0809"/>Write a function <span class="KeyTerm1">unique_pairs</span> that, given an integer <i>n</i>, generates the sequence of pairs (<i>i</i>, <i>j</i>) with 1 <i>j</i> &lt; <i>i n</i>. Use <span class="KeyTerm1">unique_pairs</span> to simplify the definition of <span class="KeyTerm1">prime_sum_pairs</span> given above.</p>
</section>
<section>
<h5><a id="c2-sec-0058"/><a id="c2-title-0059"/>Exercise 2.41</h5>
<p class="paraaftertitle"><a id="c2-para-0810"/>Write a function to find all ordered triples of distinct positive integers <i>i</i>, <i>j</i>, and <i>k</i> less than or equal to a given integer <i>n</i> that sum to a given integer <i>s</i>.</p>
</section>
<section>
<h5><a id="c2-sec-0059"/><a id="c2-title-0060"/>Exercise 2.42</h5>
<p class="paraaftertitle"><a id="c2-para-0811"/>The “eight-queens puzzle” asks how to place eight queens on a chessboard so that no queen is in check from any other (i.e., no two queens are in the same row, column, or diagonal). One possible solution is shown in <a id="c2-fig-0015a"/><a href="#c2-fig-0015">figure 2.8</a>. One way to solve the puzzle is to work across the board, placing a queen in each column. Once we have placed <i>k</i> – 1 queens, we must place the <i>k</i>th queen in a position where it does not check any of the queens already on the board. We can formulate this approach recursively: Assume that we have already generated the sequence of all possible ways to place <i>k</i> – 1 queens in the first <i>k</i> – 1 columns of the board. For each of these ways, generate an extended set of positions by placing a queen in each row of the <i>k</i>th column. Now filter these, keeping only the positions for which the queen in the <i>k</i>th column is safe with respect to the other queens. This produces the sequence of all ways to place <i>k</i> queens in the first <i>k</i> columns. By continuing this process, we will produce not only one solution, but all solutions to the puzzle.</p>
<figure id="c2-fig-0015"><img alt="c2-fig-0008.jpg" src="../images/c2-fig-0008.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0015a">Figure 2.8</a></span> <a id="c2-para-0812"/>A solution to the eight-queens puzzle.</p></figcaption></figure>
<p><a id="c2-para-0813"/>We implement this solution as a function <span class="KeyTerm1">queens</span>, which returns a sequence of all solutions to the problem of placing <i>n</i> queens on an <i>n n</i> chessboard. The function <span class="KeyTerm1">queens</span> has an internal function <span class="KeyTerm1">queens_cols</span> that returns the sequence of all ways to place queens in the first <i>k</i> columns of the board.</p>
<p class="Sp-text-1"><a id="c2-para-0814"/><b>function</b> queens(board_size) {</p>
<p class="Sp-text-1"><a id="c2-para-0815"/>    <b>function</b> queen_cols(k) {</p>
<p class="Sp-text-1"><a id="c2-para-0816"/>        <b>return</b> k === 0</p>
<p class="Sp-text-1"><a id="c2-para-0817"/>               ? list(empty_board)</p>
<p class="Sp-text-1"><a id="c2-para-0818"/>               : filter(positions =&gt; is_safe(k, positions),</p>
<p class="Sp-text-1"><a id="c2-para-5818"/>                        flatmap(rest_of_queens =&gt;</p>
<p class="Sp-text-1"><a id="c2-para-0819"/>                                  map(new_row =&gt;</p>
<p class="Sp-text-1"><a id="c2-para-0820"/>                                        adjoin_position(new_row, k,</p>
<p class="Sp-text-1"><a id="c2-para-0821"/>                                                        rest_of_queens),</p>
<p class="Sp-text-1"><a id="c2-para-5821"/>                                      enumerate_interval(1, board_size)),</p>
<p class="Sp-text-1"><a id="c2-para-0822"/>                                queen_cols(k - 1)));</p>
<p class="Sp-text-1"><a id="c2-para-0823"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-0824"/>    <b>return</b> queen_cols(board_size);</p>
<p class="Sp-text-1"><a id="c2-para-0825"/>}</p>
<p class="paracontinue"><a id="c2-para-0826"/>In this function <span class="KeyTerm1">rest_of_queens</span> is a way to place <i>k</i> – 1 queens in the first <i>k</i> – 1 columns, and <span class="KeyTerm1">new_row</span> is a proposed row in which to place the queen for the <i>k</i>th column. Complete the program by implementing the representation for sets of board positions, including the function <span class="KeyTerm1">adjoin_position</span>, which adjoins a new row-column position to a set of positions, and <span class="KeyTerm1">empty_board</span>, which represents an empty set of positions. You must also write the function <span class="KeyTerm1">is_safe</span>, which determines for a set of positions whether the queen in the <i>k</i>th column is safe with respect to the others. (Note that we need only check whether the new queen is safe—the other queens are already guaranteed safe with respect to each other.)</p>
</section>
<section>
<h5><a id="c2-sec-0060"/><a id="c2-title-0061"/>Exercise 2.43</h5>
<p class="paraaftertitle"><a id="c2-para-0827"/>Louis Reasoner is having a terrible time doing exercise 2.42. His <span class="KeyTerm1">queens</span> function seems to work, but it runs extremely slowly. (Louis never does manage to wait long enough for it to solve even the 6 6 case.) When Louis asks Eva Lu Ator for help, she points out that he has interchanged the order of the nested mappings in the <span class="KeyTerm1">flatmap</span>, writing it as</p>
<p class="Sp-text-1"><a id="c2-para-0828"/>flatmap(new_row =&gt;</p>
<p class="Sp-text-1"><a id="c2-para-0829"/>          map(rest_of_queens =&gt;</p>
<p class="Sp-text-1"><a id="c2-para-0830"/>                adjoin_position(new_row, k, rest_of_queens),</p>
<p class="Sp-text-1"><a id="c2-para-0831"/>              queen_cols(k - 1)),</p>
<p class="Sp-text-1"><a id="c2-para-0832"/>        enumerate_interval(1, board_size));</p>
<p class="paracontinue"><a id="c2-para-0833"/>Explain why this interchange makes the program run slowly. Estimate how long it will take Louis's program to solve the eight-queens puzzle, assuming that the program in exercise 2.42 solves the puzzle in time <i>T</i>.</p>
</section>
</section>
<section>
<h3><a id="c2-sec-0061"/><span>2.2.4</span> <a id="c2-title-0062"/>Example: A Picture Language</h3>
<p class="paraaftertitle"><a id="c2-para-0834"/>This section presents a simple language for drawing pictures that illustrates the power of data abstraction and closure, and also exploits higher-order functions in an essential way. The language is designed to make it easy to experiment with patterns such as the ones in <a id="c2-fig-0016a"/><a href="#c2-fig-0016">figure 2.9</a>, which are composed of repeated elements that are shifted and scaled.<a id="c2-fn-0020a"/><a href="#c2-fn-0020"><sup>20</sup></a> In this language, the data objects being combined are represented as functions rather than as list structure. Just as <span class="KeyTerm1">pair</span>, which satisfies the closure property, allowed us to easily build arbitrarily complicated list structure, the operations in this language, which also satisfy the closure property, allow us to easily build arbitrarily complicated patterns.</p>
<figure id="c2-fig-0016"><img alt="c2-fig-0009.jpg" src="../images/c2-fig-0009.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0016a">Figure 2.9</a></span> <a id="c2-para-0835"/>Designs generated with the picture language.</p></figcaption></figure>
<section>
<h5><a id="c2-sec-0062"/><a id="c2-title-0063"/>The picture language</h5>
<p class="paraaftertitle"><a id="c2-para-0836"/>When we began our study of programming in section 1.1, we emphasized the importance of describing a language by focusing on the language's primitives, its means of combination, and its means of abstraction. We'll follow that framework here.</p>
<p><a id="c2-para-0837"/>Part of the elegance of this picture language is that there is only one kind of element, called a <i>painter</i>. A painter draws an image that is shifted and scaled to fit within a designated parallelogram-shaped frame. For example, there's a primitive painter we'll call <span class="KeyTerm1">wave</span> that makes a crude line drawing, as shown in <a id="c2-fig-0017a"/><a href="#c2-fig-0017">figure 2.10</a>. The actual shape of the drawing depends on the frame—all four images in <a href="#c2-fig-0017">figure 2.10</a> are produced by the same <span class="KeyTerm1">wave</span> painter, but with respect to four different frames. Painters can be more elaborate than this: The primitive painter called <span class="KeyTerm1">rogers</span> paints a picture of MIT's founder, William Barton Rogers, as shown in <a id="c2-fig-0018a"/><a href="#c2-fig-0018">figure 2.11</a>.<a id="c2-fn-0021a"/><a href="#c2-fn-0021"><sup>21</sup></a> The four images in <a href="#c2-fig-0018">figure 2.11</a> are drawn with respect to the same four frames as the <span class="KeyTerm1">wave</span> images in <a href="#c2-fig-0017">figure 2.10</a>.</p>
<figure id="c2-fig-0017"><img alt="c2-fig-0010.jpg" src="../images/c2-fig-0010.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0017a">Figure 2.10</a></span> <a id="c2-para-0838"/>Images produced by the <span class="KeyTerm1">wave</span> painter, with respect to four different frames. The frames, shown with dashed lines, are not part of the images.</p></figcaption></figure>
<figure id="c2-fig-0018"><img alt="c2-fig-0011.jpg" src="../images/c2-fig-0011.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0018a">Figure 2.11</a></span> <a id="c2-para-0839"/>Images of William Barton Rogers, founder and first president of MIT, painted with respect to the same four frames as in <a href="#c2-fig-0017">figure 2.10</a> (original image courtesy MIT Museum).</p></figcaption></figure>
<p><a id="c2-para-0840"/>To combine images, we use various operations that construct new painters from given painters. For example, the <span class="KeyTerm1">beside</span> operation takes two painters and produces a new, compound painter that draws the first painter's image in the left half of the frame and the second painter's image in the right half of the frame. Similarly, <span class="KeyTerm1">below</span> takes two painters and produces a compound painter that draws the first painter's image below the second painter's image. Some operations transform a single painter to produce a new painter. For example, <span class="KeyTerm1">flip_vert</span> takes a painter and produces a painter that draws its image upside-down, and <span class="KeyTerm1">flip_horiz</span> produces a painter that draws the original painter's image left-to-right reversed.</p>
<p><a id="c2-para-0848"/><a id="c2-fig-0019a"/><a href="#c2-fig-0019">Figure 2.12</a> shows the drawing of a painter called <span class="KeyTerm1">wave4</span> that is built up in two stages starting from <span class="KeyTerm1">wave</span>:</p>
<p class="Sp-text-1"><a id="c2-para-0850"/><b>const</b> wave2 = beside(wave, flip_vert(wave));</p>
<p class="Sp-text-1"><a id="c2-para-0851"/><b>const</b> wave4 = below(wave2, wave2);</p>
<p class="paracontinue"><a id="c2-para-0852"/>In building up a complex image in this manner we are exploiting the fact that painters are closed under the language's means of combination. The <span class="KeyTerm1">beside</span> or <span class="KeyTerm1">below</span> of two painters is itself a painter; therefore, we can use it as an element in making more complex painters. As with building up list structure using <span class="KeyTerm1">pair</span>, the closure of our data under the means of combination is crucial to the ability to create complex structures while using only a few operations.</p>
<figure id="c2-fig-0019"><img alt="c2-fig-0012.jpg" src="../images/c2-fig-0012.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0019a">Figure 2.12</a></span> <a id="c2-para-0849"/>Creating a complex figure, starting from the <span class="KeyTerm1">wave</span> painter of <a href="#c2-fig-0017">figure 2.10</a>.</p></figcaption></figure>
<p><a id="c2-para-0853"/>Once we can combine painters, we would like to be able to abstract typical patterns of combining painters. We will implement the painter operations as JavaScript functions. This means that we don't need a special abstraction mechanism in the picture language: Since the means of combination are ordinary JavaScript functions, we automatically have the capability to do anything with painter operations that we can do with functions. For example, we can abstract the pattern in <span class="KeyTerm1">wave4</span> as</p>
<p class="Sp-text-1"><a id="c2-para-0854"/><b>function</b> flipped_pairs(painter) {</p>
<p class="Sp-text-1"><a id="c2-para-0855"/>    <b>const</b> painter2 = beside(painter, flip_vert(painter));</p>
<p class="Sp-text-1"><a id="c2-para-0856"/>    <b>return</b> below(painter2, painter2);</p>
<p class="Sp-text-1"><a id="c2-para-0857"/>}</p>
<p class="paracontinue"><a id="c2-para-0858"/>and declare <span class="KeyTerm1">wave4</span> as an instance of this pattern:</p>
<p class="Sp-text-1"><a id="c2-para-0859"/><b>const</b> wave4 = flipped_pairs(wave);</p>
<p><a id="c2-para-0860"/>We can also define recursive operations. Here's one that makes painters split and branch towards the right as shown in <a id="c2-fig-0020a"/><a id="c2-fig-0021a"/><a href="#c2-fig-0020">figures 2.13 and 2.14</a>:</p>
<p class="Sp-text-1"><a id="c2-para-0863"/><b>function</b> right_split(painter, n) {</p>
<p class="Sp-text-1"><a id="c2-para-0864"/>    <b>if</b> (n === 0) {</p>
<p class="Sp-text-1"><a id="c2-para-0865"/>        <b>return</b> painter;</p>
<p class="Sp-text-1"><a id="c2-para-0866"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-0867"/>        <b>const</b> smaller = right_split(painter, n - 1);</p>
<p class="Sp-text-1"><a id="c2-para-0868"/>        <b>return</b> beside(painter, below(smaller, smaller));</p>
<p class="Sp-text-1"><a id="c2-para-0869"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-0870"/>}</p>
<figure id="c2-fig-0020"><img alt="c2-fig-0013.jpg" src="../images/c2-fig-0013.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0020a">Figure 2.13</a></span> <a id="c2-para-0861"/>Recursive plans for <span class="KeyTerm1">right_split</span> and <span class="KeyTerm1">corner_split</span>.</p></figcaption></figure>
<figure id="c2-fig-0021"><img alt="c2-fig-0014.jpg" src="../images/c2-fig-0014.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0021a">Figure 2.14</a></span> <a id="c2-para-0862"/>The recursive operation <span class="KeyTerm1">right_split</span> applied to the painters <span class="KeyTerm1">wave</span> and <span class="KeyTerm1">rogers</span>. Combining four <span class="KeyTerm1">corner_split</span> figures produces symmetric <span class="KeyTerm1">square_limit</span> as shown in <a href="#c2-fig-0016">figure 2.9</a>.</p></figcaption></figure>
<p class="paracontinue"><a id="c2-para-0871"/>We can produce balanced patterns by branching upwards as well as towards the right (see exercise 2.44 and <a href="#c2-fig-0020">figures 2.13 and 2.14</a>):</p>
<p class="Sp-text-1"><a id="c2-para-0872"/><b>function</b> corner_split(painter, n) {</p>
<p class="Sp-text-1"><a id="c2-para-0873"/>    <b>if</b> (n === 0) {</p>
<p class="Sp-text-1"><a id="c2-para-0874"/>        <b>return</b> painter;</p>
<p class="Sp-text-1"><a id="c2-para-0875"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-0876"/>        <b>const</b> up = up_split(painter, n - 1);</p>
<p class="Sp-text-1"><a id="c2-para-0877"/>        <b>const</b> right = right_split(painter, n - 1);</p>
<p class="Sp-text-1"><a id="c2-para-0878"/>        <b>const</b> top_left = beside(up, up);</p>
<p class="Sp-text-1"><a id="c2-para-0879"/>        <b>const</b> bottom_right = below(right, right);</p>
<p class="Sp-text-1"><a id="c2-para-0880"/>        <b>const</b> corner = corner_split(painter, n - 1);</p>
<p class="Sp-text-1"><a id="c2-para-0881"/>        <b>return</b> beside(below(painter, top_left),</p>
<p class="Sp-text-1"><a id="c2-para-0882"/>                      below(bottom_right, corner));</p>
<p class="Sp-text-1"><a id="c2-para-0883"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-0884"/>}</p>
<p class="paracontinue"><a id="c2-para-0885"/>By placing four copies of a <span class="KeyTerm1">corner_split</span> appropriately, we obtain a pattern called <span class="KeyTerm1">square_limit</span>, whose application to <span class="KeyTerm1">wave</span> and <span class="KeyTerm1">rogers</span> is shown in <a href="#c2-fig-0016">figure 2.9</a>:</p>
<p class="Sp-text-1"><a id="c2-para-0886"/><b>function</b> square_limit(painter, n) {</p>
<p class="Sp-text-1"><a id="c2-para-0887"/>    <b>const</b> quarter = corner_split(painter, n);</p>
<p class="Sp-text-1"><a id="c2-para-0888"/>    <b>const</b> half = beside(flip_horiz(quarter), quarter);</p>
<p class="Sp-text-1"><a id="c2-para-0889"/>    <b>return</b> below(flip_vert(half), half);</p>
<p class="Sp-text-1"><a id="c2-para-0890"/>}</p>
</section>
<section>
<h5><a id="c2-sec-0063"/><a id="c2-title-0064"/>Exercise 2.44</h5>
<p class="paraaftertitle"><a id="c2-para-0891"/>Declare the function <span class="KeyTerm1">up_split</span> used by <span class="KeyTerm1">corner_split</span>. It is similar to <span class="KeyTerm1">right_split</span>, except that it switches the roles of <span class="KeyTerm1">below</span> and <span class="KeyTerm1">beside</span>.</p>
</section>
<section>
<h5><a id="c2-sec-0064"/><a id="c2-title-0065"/>Higher-order operations</h5>
<p class="paraaftertitle"><a id="c2-para-0892"/>In addition to abstracting patterns of combining painters, we can work at a higher level, abstracting patterns of combining painter operations. That is, we can view the painter operations as elements to manipulate and can write means of combination for these elements—functions that take painter operations as arguments and create new painter operations.</p>
<p><a id="c2-para-0893"/>For example, <span class="KeyTerm1">flipped_pairs</span> and <span class="KeyTerm1">square_limit</span> each arrange four copies of a painter's image in a square pattern; they differ only in how they orient the copies. One way to abstract this pattern of painter combination is with the following function, which takes four one-argument painter operations and produces a painter operation that transforms a given painter with those four operations and arranges the results in a square.<a id="c2-fn-0022a"/><a href="#c2-fn-0022"><sup>22</sup></a> The functions <span class="KeyTerm1">tl</span>, <span class="KeyTerm1">tr</span>, <span class="KeyTerm1">bl</span>, and <span class="KeyTerm1">br</span> are the transformations to apply to the top left copy, the top right copy, the bottom left copy, and the bottom right copy, respectively.</p>
<p class="Sp-text-1"><a id="c2-para-0894"/><b>function</b> square_of_four(tl, tr, bl, br) {</p>
<p class="Sp-text-1"><a id="c2-para-0895"/>    <b>return</b> painter =&gt; {</p>
<p class="Sp-text-1"><a id="c2-para-0896"/>        <b>const</b> top = beside(tl(painter), tr(painter));</p>
<p class="Sp-text-1"><a id="c2-para-0897"/>        <b>const</b> bottom = beside(bl(painter), br(painter));</p>
<p class="Sp-text-1"><a id="c2-para-0898"/>        <b>return</b> below(bottom, top);</p>
<p class="Sp-text-1"><a id="c2-para-0899"/>    };</p>
<p class="Sp-text-1"><a id="c2-para-0900"/>}</p>
<p class="paracontinue"><a id="c2-para-0901"/>Then <span class="KeyTerm1">flipped_pairs</span> can be defined in terms of <span class="KeyTerm1">square_of_four</span> as follows:<a id="c2-fn-0023a"/><a href="#c2-fn-0023"><sup>23</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0902"/><b>function</b> flipped_pairs(painter) {</p>
<p class="Sp-text-1"><a id="c2-para-0903"/>    <b>const</b> combine4 = square_of_four(identity, flip_vert,</p>
<p class="Sp-text-1"><a id="c2-para-0904"/>                                    identity, flip_vert);</p>
<p class="Sp-text-1"><a id="c2-para-0905"/>    <b>return</b> combine4(painter);</p>
<p class="Sp-text-1"><a id="c2-para-0906"/>}</p>
<p class="paracontinue"><a id="c2-para-0907"/>and <span class="KeyTerm1">square_limit</span> can be expressed as<a id="c2-fn-0024a"/><a href="#c2-fn-0024"><sup>24</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0908"/><b>function</b> square_limit(painter, n) {</p>
<p class="Sp-text-1"><a id="c2-para-0909"/>    <b>const</b> combine4 = square_of_four(flip_horiz, identity,</p>
<p class="Sp-text-1"><a id="c2-para-0910"/>                                    rotate180, flip_vert);</p>
<p class="Sp-text-1"><a id="c2-para-0911"/>    <b>return</b> combine4(corner_split(painter, n));</p>
<p class="Sp-text-1"><a id="c2-para-0912"/>}</p>
</section>
<section>
<h5><a id="c2-sec-0065"/><a id="c2-title-0066"/>Exercise 2.45</h5>
<p class="paraaftertitle"><a id="c2-para-0913"/>The functions <span class="KeyTerm1">right_split</span> and <span class="KeyTerm1">up_split</span> can be expressed as instances of a general splitting operation. Declare a function <span class="KeyTerm1">split</span> with the property that evaluating</p>
<p class="Sp-text-1"><a id="c2-para-0914"/><b>const</b> right_split = split(beside, below);</p>
<p class="Sp-text-1"><a id="c2-para-0915"/><b>const</b> up_split = split(below, beside);</p>
<p class="paracontinue"><a id="c2-para-0916"/>produces functions <span class="KeyTerm1">right_split</span> and <span class="KeyTerm1">up_split</span> with the same behaviors as the ones already declared.</p>
</section>
<section>
<h5><a id="c2-sec-0066"/><a id="c2-title-0067"/>Frames</h5>
<p class="paraaftertitle"><a id="c2-para-0917"/>Before we can show how to implement painters and their means of combination, we must first consider frames. A frame can be described by three vectors—an origin vector and two edge vectors. The origin vector specifies the offset of the frame's origin from some absolute origin in the plane, and the edge vectors specify the offsets of the frame's corners from its origin. If the edges are perpendicular, the frame will be rectangular. Otherwise the frame will be a more general parallelogram.</p>
<p><a id="c2-para-0918"/><a id="c2-fig-0022a"/><a href="#c2-fig-0022">Figure 2.15</a> shows a frame and its associated vectors. In accordance with data abstraction, we need not be specific yet about how frames are represented, other than to say that there is a constructor <span class="KeyTerm1">make_frame</span>, which takes three vectors and produces a frame, and three corresponding selectors <span class="KeyTerm1">origin_frame</span>, <span class="KeyTerm1">edge1_frame</span>, and <span class="KeyTerm1">edge2_frame</span> (see exercise 2.47).</p>
<figure id="c2-fig-0022"><img alt="c2-fig-0015.jpg" src="../images/c2-fig-0015.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0022a">Figure 2.15</a></span> <a id="c2-para-0919"/>A frame is described by three vectors—an origin and two edges.</p></figcaption></figure>
<p><a id="c2-para-0920"/>We will use coordinates in the unit square (0 ≤ <i>x</i>, <i>y</i> ≤ 1) to specify images. With each frame, we associate a <i>frame coordinate map</i>, which will be used to shift and scale images to fit the frame. The map transforms the unit square into the frame by mapping the vector <b>v</b> = (<i>x</i>, <i>y</i>) to the vector sum</p>
<p class="Sp-text-2"><a id="c2-para-0921"/>Origin(Frame) + <i>x</i> · Edge<sub>1</sub> (Frame) + <i>y ·</i> Edge<sub>2</sub> (Frame)</p>
<p class="paracontinue"><a id="c2-para-0924"/>For example, (0, 0) is mapped to the origin of the frame, (1, 1) to the vertex diagonally opposite the origin, and (0.5, 0.5) to the center of the frame. We can create a frame's coordinate map with the following function:<a id="c2-fn-0025a"/><a href="#c2-fn-0025"><sup>25</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0925"/><b>function</b> frame_coord_map(frame) {</p>
<p class="Sp-text-1"><a id="c2-para-0926"/>    <b>return</b> v =&gt; add_vect(origin_frame(frame),</p>
<p class="Sp-text-1"><a id="c2-para-0927"/>                         add_vect(scale_vect(xcor_vect(v),</p>
<p class="Sp-text-1"><a id="c2-para-0928"/>                                             edge1_frame(frame)),</p>
<p class="Sp-text-1"><a id="c2-para-0929"/>                                  scale_vect(ycor_vect(v),</p>
<p class="Sp-text-1"><a id="c2-para-0930"/>                                             edge2_frame(frame))));</p>
<p class="Sp-text-1"><a id="c2-para-0931"/>}</p>
<p class="paracontinue"><a id="c2-para-0932"/>Observe that applying <span class="KeyTerm1">frame_coord_map</span> to a frame returns a function that, given a vector, returns a vector. If the argument vector is in the unit square, the result vector will be in the frame. For example,</p>
<p class="Sp-text-1"><a id="c2-para-0933"/>frame_coord_map(a_frame)(make_vect(0, 0)); </p>
<p class="paracontinue"><a id="c2-para-0934"/>returns the same vector as</p>
<p class="Sp-text-1"><a id="c2-para-0935"/>origin_frame(a_frame);</p>
</section>
<section>
<h5><a id="c2-sec-0067"/><a id="c2-title-0068"/>Exercise 2.46</h5>
<p class="paraaftertitle"><a id="c2-para-0936"/>A two-dimensional vector <i>v</i> running from the origin to a point can be represented as a pair consisting of an <i>x</i>-coordinate and a <i>y</i>-coordinate. Implement a data abstraction for vectors by giving a constructor <span class="KeyTerm1">make_vect</span> and corresponding selectors <span class="KeyTerm1">xcor_vect</span> and <span class="KeyTerm1">ycor_vect</span>. In terms of your selectors and constructor, implement functions <span class="KeyTerm1">add_vect</span>, <span class="KeyTerm1">sub_vect</span>, and <span class="KeyTerm1">scale_vect</span> that perform the operations vector addition, vector subtraction, and multiplying a vector by a scalar:</p>
<figure><figcaption class="tablecaption"><a id="c2-tbl-0002"/></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c2-para-0937"/>(<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>) + (<i>x</i><sub>2</sub>, <i>y</i><sub>2</sub>)</td>
<td><a id="c2-para-0938"/>=</td>
<td><a id="c2-para-0939"/>(<i>x</i><sub>1</sub> + <i>x</i><sub>2</sub>, <i>y</i><sub>1</sub> + <i>y</i><sub>2</sub>)</td></tr>
<tr>
<td><a id="c2-para-0940"/>(<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>) – (<i>x</i><sub>2</sub>, <i>y</i><sub>2</sub>)</td>
<td><a id="c2-para-0941"/>=</td>
<td><a id="c2-para-0942"/>(<i>x</i><sub>1</sub> – <i>x</i><sub>2</sub>, <i>y</i><sub>1</sub> – <i>y</i><sub>2</sub>)</td></tr>
<tr>
<td><a id="c2-para-0943"/><i>s ·</i> (<i>x</i>, <i>y</i>)</td>
<td><a id="c2-para-0944"/>=</td>
<td><a id="c2-para-0945"/>(<i>sx</i>, <i>sy</i>)</td></tr></tbody></table></div></figure>
</section>
<section>
<h5><a id="c2-sec-0068"/><a id="c2-title-0069"/>Exercise 2.47</h5>
<p class="paraaftertitle"><a id="c2-para-0946"/>Here are two possible constructors for frames:</p>
<p class="Sp-text-1"><a id="c2-para-0947"/><b>function</b> make_frame(origin, edge1, edge2) {</p>
<p class="Sp-text-1"><a id="c2-para-0948"/>    <b>return</b> list(origin, edge1, edge2);</p>
<p class="Sp-text-1"><a id="c2-para-0949"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-0950"/><b>function</b> make_frame(origin, edge1, edge2) {</p>
<p class="Sp-text-1"><a id="c2-para-0951"/>   <b>return</b> pair(origin, pair(edge1, edge2));</p>
<p class="Sp-text-1"><a id="c2-para-0952"/>}</p>
<p class="paracontinue"><a id="c2-para-0953"/>For each constructor supply the appropriate selectors to produce an implementation for frames.</p>
</section>
<section>
<h5><a id="c2-sec-0069"/><a id="c2-title-0070"/>Painters</h5>
<p class="paraaftertitle"><a id="c2-para-0954"/>A painter is represented as a function that, given a frame as argument, draws a particular image shifted and scaled to fit the frame. That is to say, if <span class="KeyTerm1">p</span> is a painter and <span class="KeyTerm1">f</span> is a frame, then we produce <span class="KeyTerm1">p</span>'s image in <span class="KeyTerm1">f</span> by calling <span class="KeyTerm1">p</span> with <span class="KeyTerm1">f</span> as argument.</p>
<p><a id="c2-para-0955"/>The details of how primitive painters are implemented depend on the particular characteristics of the graphics system and the type of image to be drawn. For instance, suppose we have a function <span class="KeyTerm1">draw_line</span> that draws a line on the screen between two specified points. Then we can create painters for line drawings, such as the <span class="KeyTerm1">wave</span> painter in <a href="#c2-fig-0017">figure 2.10</a>, from lists of line segments as follows:<a id="c2-fn-0026a"/><a href="#c2-fn-0026"><sup>26</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-0956"/><b>function</b> segments_to_painter(segment_list) {</p>
<p class="Sp-text-1"><a id="c2-para-0957"/>    <b>return</b> frame =&gt;</p>
<p class="Sp-text-1"><a id="c2-para-0958"/>             for_each(segment =&gt;</p>
<p class="Sp-text-1"><a id="c2-para-0959"/>                        draw_line(</p>
<p class="Sp-text-1"><a id="c2-para-0960"/>                            frame_coord_map(frame)</p>
<p class="Sp-text-1"><a id="c2-para-0961"/>                                (start_segment(segment)),</p>
<p class="Sp-text-1"><a id="c2-para-0962"/>                            frame_coord_map(frame)</p>
<p class="Sp-text-1"><a id="c2-para-0963"/>                                (end_segment(segment))),</p>
<p class="Sp-text-1"><a id="c2-para-0964"/>                      segment_list);</p>
<p class="Sp-text-1"><a id="c2-para-0965"/>}</p>
<p class="paracontinue"><a id="c2-para-0966"/>The segments are given using coordinates with respect to the unit square. For each segment in the list, the painter transforms the segment endpoints with the frame coordinate map and draws a line between the transformed points.</p>
<p><a id="c2-para-0967"/>Representing painters as functions erects a powerful abstraction barrier in the picture language. We can create and intermix all sorts of primitive painters, based on a variety of graphics capabilities. The details of their implementation do not matter. Any function can serve as a painter, provided that it takes a frame as argument and draws something scaled to fit the frame.<a id="c2-fn-0027a"/><a href="#c2-fn-0027"><sup>27</sup></a></p>
</section>
<section>
<h5><a id="c2-sec-0070"/><a id="c2-title-0071"/>Exercise 2.48</h5>
<p class="paraaftertitle"><a id="c2-para-0968"/>A directed line segment in the plane can be represented as a pair of vectors—the vector running from the origin to the start-point of the segment, and the vector running from the origin to the end-point of the segment. Use your vector representation from exercise 2.46 to define a representation for segments with a constructor <span class="KeyTerm1">make_segment</span> and selectors <span class="KeyTerm1">start_segment</span> and <span class="KeyTerm1">end_segment</span>.</p>
</section>
<section>
<h5><a id="c2-sec-0071"/><a id="c2-title-0072"/>Exercise 2.49</h5>
<p class="paraaftertitle"><a id="c2-para-0969"/>Use <span class="KeyTerm1">segments_to_painter</span> to define the following primitive painters:</p>
<ol class="BS_NumberListA">
<li><a id="c2-li-0026"/><span>a. </span>The painter that draws the outline of the designated frame.</li>
<li><a id="c2-li-0027"/><span>b. </span>The painter that draws an “X” by connecting opposite corners of the frame.</li>
<li><a id="c2-li-0028"/><span>c. </span>The painter that draws a diamond shape by connecting the midpoints of the sides of the frame.</li>
<li><a id="c2-li-0029"/><span>d. </span>The <span class="KeyTerm1">wave</span> painter.</li>
</ol>
</section>
<section>
<h5><a id="c2-sec-0072"/><a id="c2-title-0073"/>Transforming and combining painters</h5>
<p class="paraaftertitle"><a id="c2-para-0974"/>An operation on painters (such as <span class="KeyTerm1">flip_vert</span> or <span class="KeyTerm1">beside</span>) works by creating a painter that invokes the original painters with respect to frames derived from the argument frame. Thus, for example, <span class="KeyTerm1">flip_vert</span> doesn't have to know how a painter works in order to flip it—it just has to know how to turn a frame upside down: The flipped painter just uses the original painter, but in the inverted frame.</p>
<p><a id="c2-para-0975"/>Painter operations are based on the function <span class="KeyTerm1">transform_painter</span>, which takes as arguments a painter and information on how to transform a frame and produces a new painter. The transformed painter, when called on a frame, transforms the frame and calls the original painter on the transformed frame. The arguments to <span class="KeyTerm1">transform_painter</span> are points (represented as vectors) that specify the corners of the new frame: When mapped into the frame, the first point specifies the new frame's origin and the other two specify the ends of its edge vectors. Thus, arguments within the unit square specify a frame contained within the original frame.</p>
<p class="Sp-text-1"><a id="c2-para-0976"/><b>function</b> transform_painter(painter, origin, corner1, corner2) {</p>
<p class="Sp-text-1"><a id="c2-para-0977"/>    <b>return</b> frame =&gt; {</p>
<p class="Sp-text-1"><a id="c2-para-0978"/>             <b>const</b> m = frame_coord_map(frame);</p>
<p class="Sp-text-1"><a id="c2-para-0979"/>             <b>const</b> new_origin = m(origin);</p>
<p class="Sp-text-1"><a id="c2-para-0980"/>             <b>return</b> painter(make_frame(</p>
<p class="Sp-text-1"><a id="c2-para-0981"/>                                new_origin,</p>
<p class="Sp-text-1"><a id="c2-para-0982"/>                                sub_vect(m(corner1), new_origin),</p>
<p class="Sp-text-1"><a id="c2-para-0983"/>                                sub_vect(m(corner2), new_origin)));</p>
<p class="Sp-text-1"><a id="c2-para-0984"/>           };</p>
<p class="Sp-text-1"><a id="c2-para-0985"/>}</p>
<p><a id="c2-para-0986"/>Here's how to flip painter images vertically:</p>
<p class="Sp-text-1"><a id="c2-para-0987"/><b>function</b> flip_vert(painter) {</p>
<p class="Sp-text-1"><a id="c2-para-0988"/>    <b>return</b> transform_painter(painter,</p>
<p class="Sp-text-1"><a id="c2-para-0989"/>                             make_vect(0, 1),  <span class="KeyTerm2"><i>// new origin</i></span></p>
<p class="Sp-text-1"><a id="c2-para-0990"/>                             make_vect(1, 1),  <span class="KeyTerm2"><i>// new end of edge1</i></span></p>
<p class="Sp-text-1"><a id="c2-para-0991"/>                             make_vect(0, 0)); <span class="KeyTerm2"><i>// new end of edge2</i></span></p>
<p class="Sp-text-1"><a id="c2-para-0992"/>}</p>
<p class="paracontinue"><a id="c2-para-0993"/>Using <span class="KeyTerm1">transform_painter</span>, we can easily define new transformations. For example, we can declare a painter that shrinks its image to the upper-right quarter of the frame it is given:</p>
<p class="Sp-text-1"><a id="c2-para-0994"/><b>function</b> shrink_to_upper_right(painter) {</p>
<p class="Sp-text-1"><a id="c2-para-0995"/>    <b>return</b> transform_painter(painter,</p>
<p class="Sp-text-1"><a id="c2-para-0996"/>                             make_vect(0.5, 0.5),</p>
<p class="Sp-text-1"><a id="c2-para-0997"/>                             make_vect(1, 0.5),</p>
<p class="Sp-text-1"><a id="c2-para-0998"/>                             make_vect(0.5, 1));</p>
<p class="Sp-text-1"><a id="c2-para-0999"/>}</p>
<p class="paracontinue"><a id="c2-para-1000"/>Other transformations rotate images counterclockwise by 90 degrees<a id="c2-fn-0028a"/><a href="#c2-fn-0028"><sup>28</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-1001"/><b>function</b> rotate90(painter) {</p>
<p class="Sp-text-1"><a id="c2-para-1002"/>    <b>return</b> transform_painter(painter,</p>
<p class="Sp-text-1"><a id="c2-para-1003"/>                             make_vect(1, 0),</p>
<p class="Sp-text-1"><a id="c2-para-1004"/>                             make_vect(1, 1),</p>
<p class="Sp-text-1"><a id="c2-para-1005"/>                             make_vect(0, 0));</p>
<p class="Sp-text-1"><a id="c2-para-1006"/>}</p>
<p class="paracontinue"><a id="c2-para-1007"/>or squash images towards the center of the frame:<a id="c2-fn-0029a"/><a href="#c2-fn-0029"><sup>29</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-1008"/><b>function</b> squash_inwards(painter) {</p>
<p class="Sp-text-1"><a id="c2-para-1009"/>    <b>return</b> transform_painter(painter,</p>
<p class="Sp-text-1"><a id="c2-para-1010"/>                             make_vect(0, 0),</p>
<p class="Sp-text-1"><a id="c2-para-1011"/>                             make_vect(0.65, 0.35),</p>
<p class="Sp-text-1"><a id="c2-para-1012"/>                             make_vect(0.35, 0.65));</p>
<p class="Sp-text-1"><a id="c2-para-1013"/>}</p>
<p><a id="c2-para-1014"/>Frame transformation is also the key to defining means of combining two or more painters. The <span class="KeyTerm1">beside</span> function, for example, takes two painters, transforms them to paint in the left and right halves of an argument frame respectively, and produces a new, compound painter. When the compound painter is given a frame, it calls the first transformed painter to paint in the left half of the frame and calls the second transformed painter to paint in the right half of the frame:</p>
<p class="Sp-text-1"><a id="c2-para-1015"/><b>function</b> beside(painter1, painter2) {</p>
<p class="Sp-text-1"><a id="c2-para-1016"/>    <b>const</b> split_point = make_vect(0.5, 0);</p>
<p class="Sp-text-1"><a id="c2-para-1017"/>    <b>const</b> paint_left = transform_painter(painter1,</p>
<p class="Sp-text-1"><a id="c2-para-1018"/>                                         make_vect(0, 0),</p>
<p class="Sp-text-1"><a id="c2-para-1019"/>                                         split_point,</p>
<p class="Sp-text-1"><a id="c2-para-1020"/>                                         make_vect(0, 1));</p>
<p class="Sp-text-1"><a id="c2-para-1021"/>    <b>const</b> paint_right = transform_painter(painter2,</p>
<p class="Sp-text-1"><a id="c2-para-1022"/>                                         split_point,</p>
<p class="Sp-text-1"><a id="c2-para-1023"/>                                         make_vect(1, 0),</p>
<p class="Sp-text-1"><a id="c2-para-1024"/>                                         make_vect(0.5, 1));</p>
<p class="Sp-text-1"><a id="c2-para-1025"/>    <b>return</b> frame =&gt; {</p>
<p class="Sp-text-1"><a id="c2-para-1026"/>               paint_left(frame);</p>
<p class="Sp-text-1"><a id="c2-para-1027"/>               paint_right(frame);</p>
<p class="Sp-text-1"><a id="c2-para-1028"/>           };</p>
<p class="Sp-text-1"><a id="c2-para-1029"/>}</p>
<p><a id="c2-para-1030"/>Observe how the painter data abstraction, and in particular the representation of painters as functions, makes <span class="KeyTerm1">beside</span> easy to implement. The <span class="KeyTerm1">beside</span> function need not know anything about the details of the component painters other than that each painter will draw something in its designated frame.</p>
</section>
<section>
<h5><a id="c2-sec-0073"/><a id="c2-title-0074"/>Exercise 2.50</h5>
<p class="paraaftertitle"><a id="c2-para-1031"/>Declare the transformation <span class="KeyTerm1">flip_horiz</span>, which flips painters horizontally, and transformations that rotate painters counterclockwise by 180 degrees and 270 degrees.</p>
</section>
<section>
<h5><a id="c2-sec-0074"/><a id="c2-title-0075"/>Exercise 2.51</h5>
<p class="paraaftertitle"><a id="c2-para-1032"/>Declare the <span class="KeyTerm1">below</span> operation for painters. The function <span class="KeyTerm1">below</span> takes two painters as arguments. The resulting painter, given a frame, draws with the first painter in the bottom of the frame and with the second painter in the top. Define <span class="KeyTerm1">below</span> in two different ways—first by writing a function that is analogous to the <span class="KeyTerm1">beside</span> function given above, and again in terms of <span class="KeyTerm1">beside</span> and suitable rotation operations (from exercise 2.50).</p>
</section>
<section>
<h5><a id="c2-sec-0075"/><a id="c2-title-0076"/>Levels of language for robust design</h5>
<p class="paraaftertitle"><a id="c2-para-1033"/>The picture language exploits some of the critical ideas we've introduced about abstraction with functions and data. The fundamental data abstractions, painters, are implemented using functional representations, which enables the language to handle different basic drawing capabilities in a uniform way. The means of combination satisfy the closure property, which permits us to easily build up complex designs. Finally, all the tools for abstracting functions are available to us for abstracting means of combination for painters.</p>
<p><a id="c2-para-1034"/>We have also obtained a glimpse of another crucial idea about languages and program design. This is the approach of <i>stratified design</i>, the notion that a complex system should be structured as a sequence of levels that are described using a sequence of languages. Each level is constructed by combining parts that are regarded as primitive at that level, and the parts constructed at each level are used as primitives at the next level. The language used at each level of a stratified design has primitives, means of combination, and means of abstraction appropriate to that level of detail.</p>
<p><a id="c2-para-1035"/>Stratified design pervades the engineering of complex systems. For example, in computer engineering, resistors and transistors are combined (and described using a language of analog circuits) to produce parts such as and-gates and or-gates, which form the primitives of a language for digital-circuit design.<a id="c2-fn-0030a"/><a href="#c2-fn-0030"><sup>30</sup></a> These parts are combined to build processors, bus structures, and memory systems, which are in turn combined to form computers, using languages appropriate to computer architecture. Computers are combined to form distributed systems, using languages appropriate for describing network interconnections, and so on.</p>
<p><a id="c2-para-1036"/>As a tiny example of stratification, our picture language uses primitive elements (primitive painters) that specify points and lines to provide the shapes of a painter like <span class="KeyTerm1">rogers</span>. The bulk of our description of the picture language focused on combining these primitives, using geometric combiners such as <span class="KeyTerm1">beside</span> and <span class="KeyTerm1">below</span>. We also worked at a higher level, regarding <span class="KeyTerm1">beside</span> and <span class="KeyTerm1">below</span> as primitives to be manipulated in a language whose operations, such as <span class="KeyTerm1">square_of_four</span>, capture common patterns of combining geometric combiners.</p>
<p><a id="c2-para-1037"/>Stratified design helps make programs <i>robust</i>, that is, it makes it likely that small changes in a specification will require correspondingly small changes in the program. For instance, suppose we wanted to change the image based on <span class="KeyTerm1">wave</span> shown in <a href="#c2-fig-0016">figure 2.9</a>. We could work at the lowest level to change the detailed appearance of the <span class="KeyTerm1">wave</span> element; we could work at the middle level to change the way <span class="KeyTerm1">corner_split</span> replicates the <span class="KeyTerm1">wave</span>; we could work at the highest level to change how <span class="KeyTerm1">square_limit</span> arranges the four copies of the corner. In general, each level of a stratified design provides a different vocabulary for expressing the characteristics of the system, and a different kind of ability to change it.</p>
</section>
<section>
<h5><a id="c2-sec-0076"/><a id="c2-title-0077"/>Exercise 2.52</h5>
<p class="paraaftertitle"><a id="c2-para-1038"/>Make changes to the square limit of <span class="KeyTerm1">wave</span> shown in <a href="#c2-fig-0016">figure 2.9</a> by working at each of the levels described above. In particular:</p>
<ol class="BS_NumberListA">
<li><a id="c2-li-0030"/><span>a. </span>Add some segments to the primitive <span class="KeyTerm1">wave</span> painter of exercise 2.49 (to add a smile, for example).</li>
<li><a id="c2-li-0031"/><span>b. </span>Change the pattern constructed by <span class="KeyTerm1">corner_split</span> (for example, by using only one copy of the <span class="KeyTerm1">up_split</span> and <span class="KeyTerm1">right_split</span> images instead of two).</li>
<li><a id="c2-li-0032"/><span>c. </span>Modify the version of <span class="KeyTerm1">square_limit</span> that uses <span class="KeyTerm1">square_of_four</span> so as to assemble the corners in a different pattern. (For example, you might make the big Mr. Rogers look outward from each corner of the square.)</li>
</ol>
</section>
</section>
</section>
<section>
<h2><a id="c2-sec-0077"/><span>2.3</span> <a id="c2-title-0078"/>Symbolic Data</h2>
<p class="paraaftertitle"><a id="c2-para-1042"/>All the compound data objects we have used so far were constructed ultimately from numbers. In this section we extend the representational capability of our language by introducing the ability to work with strings of characters as data.</p>
<section>
<h3><a id="c2-sec-0078"/><span>2.3.1</span> <a id="c2-title-0079"/>Strings</h3>
<p class="paraaftertitle"><a id="c2-para-1043"/>So far, we have used strings in order to display messages, using the functions <span class="KeyTerm1">display</span> and <span class="KeyTerm1">error</span> (as for example in exercise 1.22). We can form compound data using strings and have lists such as</p>
<p class="Sp-text-1"><a id="c2-para-1044"/>list("a", "b", "c", "d")</p>
<p class="Sp-text-1"><a id="c2-para-1045"/>list(23, 45, 17)</p>
<p class="Sp-text-1"><a id="c2-para-1046"/>list(list("Jakob", 27), list("Lova", 9), list("Luisa", 24))</p>
<p class="paracontinue"><a id="c2-para-1047"/>In order to distinguish strings from names, we surround them with double quotation marks. For example, the JavaScript expression <span class="KeyTerm1">z</span> denotes the value of the name <span class="KeyTerm1">z</span>, whereas the JavaScript expression <span class="KeyTerm1">"z"</span> denotes a string that consists of a single character, namely the last letter in the English alphabet in lower case.</p>
<p><a id="c2-para-1048"/>Via quotation marks, we can distinguish between strings and names:</p>
<p class="Sp-text-1"><a id="c2-para-1049"/><b>const</b> a = 1;</p>
<p class="Sp-text-1"><a id="c2-para-1050"/><b>const</b> b = 2;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1051"/>list(a, b);</p>
<p class="Sp-text-1"><a id="c2-para-1052"/><i>[1, [2, null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1053"/>list("a", "b");</p>
<p class="Sp-text-1"><a id="c2-para-1054"/><i>["a", ["b", null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1055"/>list("a", b);</p>
<p class="Sp-text-1"><a id="c2-para-1056"/><i>["a", [2, null]]</i></p>
<p><a id="c2-para-1057"/>In section 1.1.6, we introduced <span class="KeyTerm1">===</span> and <span class="KeyTerm1">!==</span> as primitive predicates on numbers. From now on, we shall allow two strings as operands of <span class="KeyTerm1">===</span> and <span class="KeyTerm1">!==</span>. The predicate <span class="KeyTerm1">===</span> returns true if and only if the two strings are the same, and <span class="KeyTerm1">!==</span> returns true if and only if the two strings are not the same.<a id="c2-fn-0031a"/><a href="#c2-fn-0031"><sup>31</sup></a> Using <span class="KeyTerm1">===</span>, we can implement a useful function called <span class="KeyTerm1">member</span>. This takes two arguments: a string and a list of strings or a number and a list of numbers. If the first argument is not contained in the list (i.e., is not <span class="KeyTerm1">===</span> to any item in the list), then <span class="KeyTerm1">member</span> returns <span class="KeyTerm1"><b>null</b></span>. Otherwise, it returns the sublist of the list beginning with the first occurrence of the string or number:</p>
<p class="Sp-text-1"><a id="c2-para-1058"/><b>function</b> member(item, x) {</p>
<p class="Sp-text-1"><a id="c2-para-1059"/>    <b>return</b> is_null(x)</p>
<p class="Sp-text-1"><a id="c2-para-1060"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-1061"/>           : item === head(x)</p>
<p class="Sp-text-1"><a id="c2-para-1062"/>           ? x</p>
<p class="Sp-text-1"><a id="c2-para-1063"/>           : member(item, tail(x));</p>
<p class="Sp-text-1"><a id="c2-para-1064"/>}</p>
<p class="paracontinue"><a id="c2-para-1065"/>For example, the value of</p>
<p class="Sp-text-1"><a id="c2-para-1066"/>member("apple", list("pear", "banana", "prune"))</p>
<p class="paracontinue"><a id="c2-para-1067"/>is <span class="KeyTerm1"><b>null</b></span>, whereas the value of</p>
<p class="Sp-text-1"><a id="c2-para-1068"/>member("apple", list("x", "y", "apple", "pear"))</p>
<p class="paracontinue"><a id="c2-para-1069"/>is <span class="KeyTerm1">list("apple", "pear")</span>.</p>
<section>
<h5><a id="c2-sec-0079"/><a id="c2-title-0080"/>Exercise 2.53</h5>
<p class="paraaftertitle"><a id="c2-para-1070"/>What is the result of evaluating each of the following expressions, in box notation and list notation?</p>
<p class="Sp-text-1"><a id="c2-para-1071"/>list("a", "b", "c")</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-5071"/>list(list("george"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1072"/>tail(list(list("x1", "x2"), list("y1", "y2")))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1073"/>tail(head(list(list("x1", "x2"), list("y1", "y2"))))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1074"/>member("red", list("blue", "shoes", "yellow", "socks"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1075"/>member("red", list("red", "shoes", "blue", "socks"))</p>
</section>
<section>
<h5><a id="c2-sec-0080"/><a id="c2-title-0081"/>Exercise 2.54</h5>
<p class="paraaftertitle"><a id="c2-para-1076"/>Two lists are said to be <span class="KeyTerm1">equal</span> if they contain equal elements arranged in the same order. For example,</p>
<p class="Sp-text-1"><a id="c2-para-1077"/>equal(list("this", "is", "a", "list"), list("this", "is", "a", "list"))</p>
<p class="paracontinue"><a id="c2-para-1078"/>is true, but</p>
<p class="Sp-text-1"><a id="c2-para-1079"/>equal(list("this", "is", "a", "list"), list("this", list("is", "a"), "list"))</p>
<p class="paracontinue"><a id="c2-para-1080"/>is false. To be more precise, we can define <span class="KeyTerm1">equal</span> recursively in terms of the basic <span class="KeyTerm1">===</span> equality of numbers and strings by saying that <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> are <span class="KeyTerm1">equal</span> if they are both strings or both numbers and they are <span class="KeyTerm1">===</span>, or if they are both pairs such that <span class="KeyTerm1">head(a)</span> is <span class="KeyTerm1">equal</span> to <span class="KeyTerm1">head(b)</span> and <span class="KeyTerm1">tail(a)</span> is <span class="KeyTerm1">equal</span> to <span class="KeyTerm1">tail(b)</span>. Using this idea, implement <span class="KeyTerm1">equal</span> as a function.</p>
</section>
<section>
<h5><a id="c2-sec-0081"/><a id="c2-title-0082"/>Exercise 2.55</h5>
<p class="paraaftertitle"><a id="c2-para-1081"/>The JavaScript interpreter reads the characters after a double quotation mark <span class="KeyTerm1">"</span> until it finds another double quotation mark. All characters between the two are part of the string, excluding the double quotation marks themselves. But what if we want a string to contain double quotation marks? For this purpose, JavaScript also allows <i>single</i> quotation marks to delimit strings, as for example in <span class="KeyTerm1">'say your name aloud'</span>. Within singly-quoted strings, we can use double quotation marks, and vice versa, so <span class="KeyTerm1">'say "your name" aloud'</span> and <span class="KeyTerm1">"say 'your name' aloud"</span> are valid strings that have different characters at positions 4 and 14, if we start counting at 0. Depending on the font in use, two single quotation marks might not be easily distinguishable from a double quotation mark. Can you spot which is which and work out the value of the following expression?</p>
<p class="Sp-text-1"><a id="c2-para-1082"/>' " ' === " "</p>
</section>
</section>
<section>
<h3><a id="c2-sec-0082"/><span>2.3.2</span> <a id="c2-title-0083"/>Example: Symbolic Differentiation</h3>
<p class="paraaftertitle"><a id="c2-para-1083"/>As an illustration of symbol manipulation and a further illustration of data abstraction, consider the design of a function that performs symbolic differentiation of algebraic expressions. We would like the function to take as arguments an algebraic expression and a variable and to return the derivative of the expression with respect to the variable. For example, if the arguments to the function are <i>ax</i><sup>2</sup> + <i>bx</i> + <i>c</i> and <i>x</i>, the function should return 2<i>ax</i> + <i>b</i>. Symbolic differentiation is of special historical significance in the programming language Lisp.<a id="c2-fn-0032a"/><a href="#c2-fn-0032"><sup>32</sup></a> It was one of the motivating examples behind the development of a computer language for symbol manipulation. Furthermore, it marked the beginning of the line of research that led to the development of powerful systems for symbolic mathematical work, which are today routinely used by applied mathematicians and physicists.</p>
<p><a id="c2-para-1084"/>In developing the symbolic-differentiation program, we will follow the same strategy of data abstraction that we followed in developing the rational-number system of section 2.1.1. That is, we will first define a differentiation algorithm that operates on abstract objects such as “sums,” “products,” and “variables” without worrying about how these are to be represented. Only afterward will we address the representation problem.</p>
<section>
<h5><a id="c2-sec-0083"/><a id="c2-title-0084"/>The differentiation program with abstract data</h5>
<p class="paraaftertitle"><a id="c2-para-1085"/>To keep things simple, we will consider a very simple symbolic-differentiation program that handles expressions that are built up using only the operations of addition and multiplication with two arguments. Differentiation of any such expression can be carried out by applying the following reduction rules:</p>
<p><a id="c2-para-1086"/></p>
<figure id="c2-fig-0023"><img alt="c2-fig-5008.jpg" src="../images/c2-fig-5008.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p><a id="c2-para-1087"/>Observe that the latter two rules are recursive in nature. That is, to obtain the derivative of a sum we first find the derivatives of the terms and add them. Each of the terms may in turn be an expression that needs to be decomposed. Decomposing into smaller and smaller pieces will eventually produce pieces that are either constants or variables, whose derivatives will be either 0 or 1.</p>
<p><a id="c2-para-1088"/>To embody these rules in a function we indulge in a little wishful thinking, as we did in designing the rational-number implementation. If we had a means for representing algebraic expressions, we should be able to tell whether an expression is a sum, a product, a constant, or a variable. We should be able to extract the parts of an expression. For a sum, for example, we want to be able to extract the addend (first term) and the augend (second term). We should also be able to construct expressions from parts. Let us assume that we already have functions to implement the following selectors, constructors, and predicates:</p>
<figure><figcaption class="tablecaption"><a id="c2-tbl-0003"/></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c2-para-1089"/><span class="KeyTerm1">is_variable(e)</span></td>
<td><a id="c2-para-1090"/>Is <span class="KeyTerm1">e</span> a variable?</td></tr>
<tr>
<td><a id="c2-para-1091"/><span class="KeyTerm1">is_same_variable(v1, v2)</span></td>
<td><a id="c2-para-1092"/>Are <span class="KeyTerm1">v1</span> and <span class="KeyTerm1">v2</span> the same variable?</td></tr>
<tr>
<td><a id="c2-para-1093"/><span class="KeyTerm1">is_sum(e)</span></td>
<td><a id="c2-para-1094"/>Is <span class="KeyTerm1">e</span> a sum?</td></tr>
<tr>
<td><a id="c2-para-1095"/><span class="KeyTerm1">addend(e)</span></td>
<td><a id="c2-para-1096"/>Addend of the sum <span class="KeyTerm1">e</span>.</td></tr>
<tr>
<td><a id="c2-para-1097"/><span class="KeyTerm1">augend(e)</span></td>
<td><a id="c2-para-1098"/>Augend of the sum <span class="KeyTerm1">e</span>.</td></tr>
<tr>
<td><a id="c2-para-1099"/><span class="KeyTerm1">make_sum(a1, a2)</span></td>
<td><a id="c2-para-1100"/>Construct the sum of <span class="KeyTerm1">a1</span> and <span class="KeyTerm1">a2</span>.</td></tr>
<tr>
<td><a id="c2-para-1101"/><span class="KeyTerm1">is_product(e)</span></td>
<td><a id="c2-para-1102"/>Is <span class="KeyTerm1">e</span> a product?</td></tr>
<tr>
<td><a id="c2-para-1103"/><span class="KeyTerm1">multiplier(e)</span></td>
<td><a id="c2-para-1104"/>Multiplier of the product <span class="KeyTerm1">e</span>.</td></tr>
<tr>
<td><a id="c2-para-1105"/><span class="KeyTerm1">multiplicand(e)</span></td>
<td><a id="c2-para-1106"/>Multiplicand of the product <span class="KeyTerm1">e</span>.</td></tr>
<tr>
<td><a id="c2-para-1107"/><span class="KeyTerm1">make_product(m1, m2)</span></td>
<td><a id="c2-para-1108"/>Construct the product of <span class="KeyTerm1">m1</span> and <span class="KeyTerm1">m2</span>.</td></tr></tbody></table></div></figure>

<p class="paracontinue"><a id="c2-para-1109"/>Using these, and the primitive predicate <span class="KeyTerm1">is_number</span>, which identifies numbers, we can express the differentiation rules as the following function:</p>
<p class="Sp-text-1"><a id="c2-para-1110"/><b>function</b> deriv(exp, variable) {</p>
<p class="Sp-text-1"><a id="c2-para-1111"/>    <b>return</b> is_number(exp)</p>
<p class="Sp-text-1"><a id="c2-para-1112"/>           ? 0</p>
<p class="Sp-text-1"><a id="c2-para-1113"/>           : is_variable(exp)</p>
<p class="Sp-text-1"><a id="c2-para-1114"/>           ? is_same_variable(exp, variable) ? 1 : 0</p>
<p class="Sp-text-1"><a id="c2-para-1115"/>           : is_sum(exp)</p>
<p class="Sp-text-1"><a id="c2-para-1116"/>           ? make_sum(deriv(addend(exp), variable),</p>
<p class="Sp-text-1"><a id="c2-para-1117"/>                      deriv(augend(exp), variable))</p>
<p class="Sp-text-1"><a id="c2-para-1118"/>           : is_product(exp)</p>
<p class="Sp-text-1"><a id="c2-para-1119"/>           ? make_sum(make_product(multiplier(exp),</p>
<p class="Sp-text-1"><a id="c2-para-1120"/>                                   deriv(multiplicand(exp),</p>
<p class="Sp-text-1"><a id="c2-para-1121"/>                                         variable)),</p>
<p class="Sp-text-1"><a id="c2-para-1122"/>                     make_product(deriv(multiplier(exp),</p>
<p class="Sp-text-1"><a id="c2-para-1123"/>                                         variable),</p>
<p class="Sp-text-1"><a id="c2-para-1124"/>                                  multiplicand(exp)))</p>
<p class="Sp-text-1"><a id="c2-para-1125"/>           : error(exp, "unknown expression type – deriv");</p>
<p class="Sp-text-1"><a id="c2-para-1126"/>}</p>
<p class="paracontinue"><a id="c2-para-1127"/>This <span class="KeyTerm1">deriv</span> function incorporates the complete differentiation algorithm. Since it is expressed in terms of abstract data, it will work no matter how we choose to represent algebraic expressions, as long as we design a proper set of selectors and constructors. This is the issue we must address next.</p>
</section>
<section>
<h5><a id="c2-sec-0084"/><a id="c2-title-0085"/>Representing algebraic expressions</h5>
<p class="paraaftertitle"><a id="c2-para-1128"/>We can imagine many ways to use list structure to represent algebraic expressions. For example, we could use lists of symbols that mirror the usual algebraic notation, representing <i>ax</i> + <i>b</i> as <span class="KeyTerm1">list("a", "*", "x", "+", "b")</span>. However, it will be more convenient if we reflect the mathematical structure of the expression in the JavaScript value representing it; that is, to represent <i>ax</i> + <i>b</i> as <span class="KeyTerm1">list("+", list("*", "a", "x"), "b")</span>. Placing a binary operator in front of its operands is called <i>prefix notation</i>, in contrast with the infix notation introduced in section 1.1.1. With prefix notation, our data representation for the differentiation problem is as follows:</p>
<ul style="list-style-type:disc">
<li>The variables are just strings. They are identified by the primitive predicate <span class="KeyTerm1">is_string</span>:
<p class="Sp-text-1"><a id="c2-para-1130"/>    <b>function</b> is_variable(x) { <b>return</b> is_string(x); }</p></li>
<li>Two variables are the same if the strings representing them are equal:
<p class="Sp-text-1"><a id="c2-para-1132"/>    <b>function</b> is_same_variable(v1, v2) {</p>
<p class="Sp-text-1"><a id="c2-para-1133"/>        <b>return</b> is_variable(v1) &amp;&amp; is_variable(v2) &amp;&amp; v1 === v2;</p>
<p class="Sp-text-1"><a id="c2-para-1134"/>    }</p></li>
<li>Sums and products are constructed as lists:
<p class="Sp-text-1"><a id="c2-para-1136"/>    <b>function</b> make_sum(a1, a2) { <b>return</b> list("+", a1, a2); }</p>
<p class="Sp-text-1"><a id="c2-para-1137"/>    <b>function</b> make_product(m1, m2) { <b>return</b> list("*", m1, m2); }</p></li>
<li>A sum is a list whose first element is the string <span class="KeyTerm1">"+"</span>:
<p class="Sp-text-1"><a id="c2-para-1139"/>    <b>function</b> is_sum(x) {</p>
<p class="Sp-text-1"><a id="c2-para-1140"/>        <b>return</b> is_pair(x) &amp;&amp; head(x) === "+";</p>
<p class="Sp-text-1"><a id="c2-para-1141"/>    }</p></li>
<li>The addend is the second item of the sum list:
<p class="Sp-text-1"><a id="c2-para-1143"/>    <b>function</b> addend(s) { <b>return</b> head(tail(s)); }</p></li>
<li>The augend is the third item of the sum list:
<p class="Sp-text-1"><a id="c2-para-1145"/>    <b>function</b> augend(s) { <b>return</b> head(tail(tail(s))); }</p></li>
<li>A product is a list whose first element is the string <span class="KeyTerm1">"*"</span>:
<p class="Sp-text-1"><a id="c2-para-1147"/>    <b>function</b> is_product(x) {</p>
<p class="Sp-text-1"><a id="c2-para-1148"/>        <b>return</b> is_pair(x) &amp;&amp; head(x) === "*";</p>
<p class="Sp-text-1"><a id="c2-para-1149"/>    }</p></li>
<li>The multiplier is the second item of the product list:
<p class="Sp-text-1"><a id="c2-para-1151"/>    <b>function</b> multiplier(s) { <b>return</b> head(tail(s)); }</p></li>
<li>The multiplicand is the third item of the product list:
<p class="Sp-text-1"><a id="c2-para-1153"/>    <b>function</b> multiplicand(s) { <b>return</b> head(tail(tail(s))); }</p></li>
</ul>

<p class="paracontinue"><a id="c2-para-1154"/>Thus, we need only combine these with the algorithm as embodied by <span class="KeyTerm1">deriv</span> in order to have a working symbolic-differentiation program. Let us look at some examples of its behavior:</p>
<p class="Sp-text-1"><a id="c2-para-1155"/>deriv(list("+", "x", 3), "x");</p>
<p class="Sp-text-1"><a id="c2-para-1156"/><i>list("+", 1, 0)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1157"/>deriv(list("*", "x", "y"), "x");</p>
<p class="Sp-text-1"><a id="c2-para-1158"/><i>list("+", list("*", "x", 0), list("*", 1, "y"))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1159"/>deriv(list("*", list("*", "x", "y"), list("+", "x", 3)), "x");</p>
<p class="Sp-text-1"><a id="c2-para-1160"/><i>list("+", list("*", list("*", "x", "y"), list("+", 1, 0)),</i></p>
<p class="Sp-text-1"><a id="c2-para-1161"/>          <i>list("*", list("+", list("*", "x", 0), list("*", 1, "y")),</i> </p>
<p class="Sp-text-1"><a id="c2-para-1162"/>                    <i>list("+", "x", 3)))</i></p>
<p class="paracontinue"><a id="c2-para-1163"/>The program produces answers that are correct; however, they are unsimplified. It is true that</p>
<p><a id="c2-para-1164"/></p>
<figure id="c2-fig-0024"><img alt="c2-fig-5009.jpg" src="../images/c2-fig-5009.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c2-para-1165"/>but we would like the program to know that <i>x ·</i> 0 = 0, 1 <i>· y</i> = <i>y</i>, and 0 + <i>y</i> = <i>y</i>. The answer for the second example should have been simply <span class="KeyTerm1">y</span>. As the third example shows, this becomes a serious issue when the expressions are complex.</p>
<p><a id="c2-para-1166"/>Our difficulty is much like the one we encountered with the rational-number implementation: we haven't reduced answers to simplest form. To accomplish the rational-number reduction, we needed to change only the constructors and the selectors of the implementation. We can adopt a similar strategy here. We won't change <span class="KeyTerm1">deriv</span> at all. Instead, we will change <span class="KeyTerm1">make_sum</span> so that if both summands are numbers, <span class="KeyTerm1">make_sum</span> will add them and return their sum. Also, if one of the summands is 0, then <span class="KeyTerm1">make_sum</span> will return the other summand.</p>
<p class="Sp-text-1"><a id="c2-para-1167"/><b>function</b> make_sum(a1, a2) {</p>
<p class="Sp-text-1"><a id="c2-para-1168"/>    <b>return</b> number_equal(a1, 0)</p>
<p class="Sp-text-1"><a id="c2-para-1169"/>           ? a2</p>
<p class="Sp-text-1"><a id="c2-para-1170"/>           : number_equal(a2, 0)</p>
<p class="Sp-text-1"><a id="c2-para-1171"/>           ? a1</p>
<p class="Sp-text-1"><a id="c2-para-1172"/>           : is_number(a1) &amp;&amp; is_number(a2)</p>
<p class="Sp-text-1"><a id="c2-para-1173"/>           ? a1 + a2</p>
<p class="Sp-text-1"><a id="c2-para-1174"/>           : list("+", a1, a2);</p>
<p class="Sp-text-1"><a id="c2-para-1175"/>}</p>
<p class="paracontinue"><a id="c2-para-1176"/>This uses the function <span class="KeyTerm1">number_equal</span>, which checks whether an expression is equal to a given number:</p>
<p class="Sp-text-1"><a id="c2-para-1177"/><b>function</b> number_equal(exp, num) {</p>
<p class="Sp-text-1"><a id="c2-para-1178"/>    <b>return</b> is_number(exp) &amp;&amp; exp === num;</p>
<p class="Sp-text-1"><a id="c2-para-1179"/>}</p>
<p class="paracontinue"><a id="c2-para-1180"/>Similarly, we will change <span class="KeyTerm1">make_product</span> to build in the rules that 0 times anything is 0 and 1 times anything is the thing itself:</p>
<p class="Sp-text-1"><a id="c2-para-1181"/><b>function</b> make_product(m1, m2) {</p>
<p class="Sp-text-1"><a id="c2-para-1182"/>    <b>return</b> number_equal(m1, 0) || number_equal(m2, 0)</p>
<p class="Sp-text-1"><a id="c2-para-1183"/>           ? 0</p>
<p class="Sp-text-1"><a id="c2-para-1184"/>           : number_equal(m1, 1)</p>
<p class="Sp-text-1"><a id="c2-para-1185"/>           ? m2</p>
<p class="Sp-text-1"><a id="c2-para-1186"/>           : number_equal(m2, 1)</p>
<p class="Sp-text-1"><a id="c2-para-1187"/>           ? m1</p>
<p class="Sp-text-1"><a id="c2-para-1188"/>           : is_number(m1) &amp;&amp; is_number(m2)</p>
<p class="Sp-text-1"><a id="c2-para-1189"/>           ? m1 * m2</p>
<p class="Sp-text-1"><a id="c2-para-1190"/>           : list("*", m1, m2);</p>
<p class="Sp-text-1"><a id="c2-para-1191"/>}</p>
<p class="paracontinue"><a id="c2-para-1192"/>Here is how this version works on our three examples:</p>
<p class="Sp-text-1"><a id="c2-para-1193"/>deriv(list("+", "x", 3), "x");</p>
<p class="Sp-text-1"><a id="c2-para-1194"/><i>1</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1195"/>deriv(list("*", "x", "y"), "x");</p>
<p class="Sp-text-1"><a id="c2-para-1196"/><i>"y"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1197"/>deriv(list("*", list("*", "x", "y"), list("+", "x", 3)), "x");</p>
<p class="Sp-text-1"><a id="c2-para-1198"/><i>list("+", list("*", "x", "y"), list("*", "y", list("+", "x", 3)))</i></p>
<p class="paracontinue"><a id="c2-para-1199"/>Although this is quite an improvement, the third example shows that there is still a long way to go before we get a program that puts expressions into a form that we might agree is “simplest.” The problem of algebraic simplification is complex because, among other reasons, a form that may be simplest for one purpose may not be for another.</p>
</section>
<section>
<h5><a id="c2-sec-0085"/><a id="c2-title-0086"/>Exercise 2.56</h5>
<p class="paraaftertitle"><a id="c2-para-1200"/>Show how to extend the basic differentiator to handle more kinds of expressions. For instance, implement the differentiation rule</p>
<p><a id="c2-para-1201"/></p>
<figure id="c2-fig-0025"><img alt="c2-fig-5010.jpg" src="../images/c2-fig-5010.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c2-para-1202"/>by adding a new clause to the <span class="KeyTerm1">deriv</span> program and defining appropriate functions <span class="KeyTerm1">is_exp</span>, <span class="KeyTerm1">base</span>, <span class="KeyTerm1">exponent</span>, and <span class="KeyTerm1">make_exp</span>. (You may use the string <span class="KeyTerm1">"**"</span> to denote exponentiation.) Build in the rules that anything raised to the power 0 is 1 and anything raised to the power 1 is the thing itself.</p>
</section>
<section>
<h5><a id="c2-sec-0086"/><a id="c2-title-0087"/>Exercise 2.57</h5>
<p class="paraaftertitle"><a id="c2-para-1203"/>Extend the differentiation program to handle sums and products of arbitrary numbers of (two or more) terms. Then the last example above could be expressed as</p>
<p class="Sp-text-1"><a id="c2-para-1204"/>deriv(list("*", "x", "y", list("+", "x", 3)), "x");</p>
<p class="paracontinue"><a id="c2-para-1205"/>Try to do this by changing only the representation for sums and products, without changing the <span class="KeyTerm1">deriv</span> function at all. For example, the <span class="KeyTerm1">addend</span> of a sum would be the first term, and the <span class="KeyTerm1">augend</span> would be the sum of the rest of the terms.</p>
</section>
<section>
<h5><a id="c2-sec-0087"/><a id="c2-title-0088"/>Exercise 2.58</h5>
<p class="paraaftertitle"><a id="c2-para-1206"/>Suppose we want to modify the differentiation program so that it works with ordinary mathematical notation, in which <span class="KeyTerm1">"+"</span> and <span class="KeyTerm1">"*"</span> are infix rather than prefix operators. Since the differentiation program is defined in terms of abstract data, we can modify it to work with different representations of expressions solely by changing the predicates, selectors, and constructors that define the representation of the algebraic expressions on which the differentiator is to operate.</p>
<ol class="BS_NumberListA">
<li><a id="c2-li-0042"/><span>a. </span>Show how to do this in order to differentiate algebraic expressions presented in infix form, as in this example:
<p class="Sp-text-1"><a id="c2-para-1208"/>list("x", "+", list(3, "*", list("x", "+", list("y", "+", 2))))</p>
<p class="paracontinue"><a id="c2-para-1209"/>To simplify the task, assume that <span class="KeyTerm1">"+"</span> and <span class="KeyTerm1">"*"</span> always take two arguments and that expressions are fully parenthesized.</p></li>
<li><a id="c2-li-0043"/><span>b. </span>The problem becomes substantially harder if we allow a notation closer to ordinary infix notation, which omits unnecessary parentheses and assumes that multiplication has higher precedence than addition, as in this example:
<p class="Sp-text-1"><a id="c2-para-1211"/>list("x", "+", "3", "*", list("x", "+", "y", "+", 2))</p>
<p class="paracontinue"><a id="c2-para-1212"/>Can you design appropriate predicates, selectors, and constructors for this notation such that our derivative program still works?</p></li>
</ol>
</section>
</section>
<section>
<h3><a id="c2-sec-0088"/><span>2.3.3</span> <a id="c2-title-0089"/>Example: Representing Sets</h3>
<p class="paraaftertitle"><a id="c2-para-1213"/>In the previous examples we built representations for two kinds of compound data objects: rational numbers and algebraic expressions. In one of these examples we had the choice of simplifying (reducing) the expressions at either construction time or selection time, but other than that the choice of a representation for these structures in terms of lists was straightforward. When we turn to the representation of sets, the choice of a representation is not so obvious. Indeed, there are a number of possible representations, and they differ significantly from one another in several ways.</p>
<p><a id="c2-para-1214"/>Informally, a set is simply a collection of distinct objects. To give a more precise definition we can employ the method of data abstraction. That is, we define “set” by specifying the operations that are to be used on sets. These are <span class="KeyTerm1">union_set</span>, <span class="KeyTerm1">intersection_set</span>, <span class="KeyTerm1">is_element_of_set</span>, and <span class="KeyTerm1">adjoin_set</span>. The function <span class="KeyTerm1">is_ element_of_set</span> is a predicate that determines whether a given element is a member of a set. The function <span class="KeyTerm1">adjoin_set</span> takes an object and a set as arguments and returns a set that contains the elements of the original set and also the adjoined element. The function <span class="KeyTerm1">union_set</span> computes the union of two sets, which is the set containing each element that appears in either argument. The function <span class="KeyTerm1">intersection_set</span> computes the intersection of two sets, which is the set containing only elements that appear in both arguments. From the viewpoint of data abstraction, we are free to design any representation that implements these operations in a way consistent with the interpretations given above.<a id="c2-fn-0033a"/><a href="#c2-fn-0033"><sup>33</sup></a></p>
<section>
<h5><a id="c2-sec-0089"/><a id="c2-title-0090"/>Sets as unordered lists</h5>
<p class="paraaftertitle"><a id="c2-para-1215"/>One way to represent a set is as a list of its elements in which no element appears more than once. The empty set is represented by the empty list. In this representation, <span class="KeyTerm1">is_element_of_set</span> is similar to the function <span class="KeyTerm1">member</span> of section 2.3.1. It uses <span class="KeyTerm1">equal</span> instead of <span class="KeyTerm1">===</span> so that the set elements need not be just numbers or strings:</p>
<p class="Sp-text-1"><a id="c2-para-1216"/><b>function</b> is_element_of_set(x, set) {</p>
<p class="Sp-text-1"><a id="c2-para-1217"/>    <b>return</b> is_null(set)</p>
<p class="Sp-text-1"><a id="c2-para-1218"/>           ? <b>false</b></p>
<p class="Sp-text-1"><a id="c2-para-1219"/>           : equal(x, head(set))</p>
<p class="Sp-text-1"><a id="c2-para-1220"/>           ? <b>true</b></p>
<p class="Sp-text-1"><a id="c2-para-1221"/>           : is_element_of_set(x, tail(set));</p>
<p class="Sp-text-1"><a id="c2-para-1222"/>}</p>
<p class="paracontinue"><a id="c2-para-1223"/>Using this, we can write <span class="KeyTerm1">adjoin_set</span>. If the object to be adjoined is already in the set, we just return the set. Otherwise, we use <span class="KeyTerm1">pair</span> to add the object to the list that represents the set:</p>
<p class="Sp-text-1"><a id="c2-para-1224"/><b>function</b> adjoin_set(x, set) {</p>
<p class="Sp-text-1"><a id="c2-para-1225"/>    <b>return</b> is_element_of_set(x, set)</p>
<p class="Sp-text-1"><a id="c2-para-1226"/>           ? set</p>
<p class="Sp-text-1"><a id="c2-para-1227"/>           : pair(x, set);</p>
<p class="Sp-text-1"><a id="c2-para-1228"/>}</p>
<p class="paracontinue"><a id="c2-para-1229"/>For <span class="KeyTerm1">intersection_set</span> we can use a recursive strategy. If we know how to form the intersection of <span class="KeyTerm1">set2</span> and the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">set1</span>, we only need to decide whether to include the <span class="KeyTerm1">head</span> of <span class="KeyTerm1">set1</span> in this. But this depends on whether <span class="KeyTerm1">head(set1)</span> is also in <span class="KeyTerm1">set2</span>. Here is the resulting function:</p>
<p class="Sp-text-1"><a id="c2-para-1230"/><b>function</b> intersection_set(set1, set2) {</p>
<p class="Sp-text-1"><a id="c2-para-1231"/>    <b>return</b> is_null(set1) || is_null(set2)</p>
<p class="Sp-text-1"><a id="c2-para-1232"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-1233"/>           : is_element_of_set(head(set1), set2)</p>
<p class="Sp-text-1"><a id="c2-para-1234"/>           ? pair(head(set1), intersection_set(tail(set1), set2))</p>
<p class="Sp-text-1"><a id="c2-para-1235"/>           : intersection_set(tail(set1), set2);</p>
<p class="Sp-text-1"><a id="c2-para-1236"/>}</p>
<p><a id="c2-para-1237"/>In designing a representation, one of the issues we should be concerned with is efficiency. Consider the number of steps required by our set operations. Since they all use <span class="KeyTerm1">is_element_of_set</span>, the speed of this operation has a major impact on the efficiency of the set implementation as a whole. Now, in order to check whether an object is a member of a set, <span class="KeyTerm1">is_element_of_set</span> may have to scan the entire set. (In the worst case, the object turns out not to be in the set.) Hence, if the set has <i>n</i> elements, <span class="KeyTerm1">is_element_of_set</span> might take up to <i>n</i> steps. Thus, the number of steps required grows as Θ(<i>n</i>). The number of steps required by <span class="KeyTerm1">adjoin_set</span>, which uses this operation, also grows as Θ(<i>n</i>). For <span class="KeyTerm1">intersection_set</span>, which does an <span class="KeyTerm1">is_element_of_set</span> check for each element of <span class="KeyTerm1">set1</span>, the number of steps required grows as the product of the sizes of the sets involved, or Θ(<i>n</i><sup>2</sup>) for two sets of size <i>n</i>. The same will be true of <span class="KeyTerm1">union_set</span>.</p>
</section>
<section>
<h5><a id="c2-sec-0090"/><a id="c2-title-0091"/>Exercise 2.59</h5>
<p class="paraaftertitle"><a id="c2-para-1238"/>Implement the <span class="KeyTerm1">union_set</span> operation for the unordered-list representation of sets.</p>
</section>
<section>
<h5><a id="c2-sec-0091"/><a id="c2-title-0092"/>Exercise 2.60</h5>
<p class="paraaftertitle"><a id="c2-para-1239"/>We specified that a set would be represented as a list with no duplicates. Now suppose we allow duplicates. For instance, the set {1, 2, 3} could be represented as the list <span class="KeyTerm1">list(2, 3, 2, 1, 3, 2, 2)</span>. Design functions <span class="KeyTerm1">is_element_of_set</span>, <span class="KeyTerm1">adjoin_set</span>, <span class="KeyTerm1">union_set</span>, and <span class="KeyTerm1">intersection_set</span> that operate on this representation. How does the efficiency of each compare with the corresponding function for the non-duplicate represen-tation? Are there applications for which you would use this representation in preference to the non-duplicate one?</p>
</section>
<section>
<h5><a id="c2-sec-0092"/><a id="c2-title-0093"/>Sets as ordered lists</h5>
<p class="paraaftertitle"><a id="c2-para-1240"/>One way to speed up our set operations is to change the representation so that the set elements are listed in increasing order. To do this, we need some way to compare two objects so that we can say which is bigger. For example, we could compare strings lexicographically, or we could agree on some method for assigning a unique number to an object and then compare the elements by comparing the corresponding numbers. To keep our discussion simple, we will consider only the case where the set elements are numbers, so that we can compare elements using <span class="KeyTerm1">&gt;</span> and <span class="KeyTerm1">&lt;</span>. We will represent a set of numbers by listing its elements in increasing order. Whereas our first representation above allowed us to represent the set {1, 3, 6, 10} by listing the elements in any order, our new representation allows only the list <span class="KeyTerm1">list(1, 3, 6, 10)</span>.</p>
<p><a id="c2-para-1241"/>One advantage of ordering shows up in <span class="KeyTerm1">is_element_of_set</span>: In checking for the presence of an item, we no longer have to scan the entire set. If we reach a set element that is larger than the item we are looking for, then we know that the item is not in the set:</p>
<p class="Sp-text-1"><a id="c2-para-1242"/><b>function</b> is_element_of_set(x, set) {</p>
<p class="Sp-text-1"><a id="c2-para-1243"/>    <b>return</b> is_null(set)</p>
<p class="Sp-text-1"><a id="c2-para-1244"/>           ? <b>false</b></p>
<p class="Sp-text-1"><a id="c2-para-1245"/>           : x === head(set)</p>
<p class="Sp-text-1"><a id="c2-para-1246"/>           ? <b>true</b></p>
<p class="Sp-text-1"><a id="c2-para-1247"/>           : x &lt; head(set)</p>
<p class="Sp-text-1"><a id="c2-para-1248"/>           ? <b>false</b></p>
<p class="Sp-text-1"><a id="c2-para-1249"/>           : <i>//</i> x &gt; head(set)</p>
<p class="Sp-text-1"><a id="c2-para-1250"/>             is_element_of_set(x, tail(set));</p>
<p class="Sp-text-1"><a id="c2-para-1251"/>}</p>
<p class="paracontinue"><a id="c2-para-1252"/>How many steps does this save? In the worst case, the item we are looking for may be the largest one in the set, so the number of steps is the same as for the unordered representation. On the other hand, if we search for items of many different sizes we can expect that sometimes we will be able to stop searching at a point near the beginning of the list and that other times we will still need to examine most of the list. On the average we should expect to have to examine about half of the items in the set. Thus, the average number of steps required will be about <i>n</i>/2. This is still Θ(<i>n</i>) growth, but it does save us, on the average, a factor of 2 in number of steps over the previous implementation.</p>
<p><a id="c2-para-1253"/>We obtain a more impressive speedup with <span class="KeyTerm1">intersection_set</span>. In the unordered representation this operation required Θ(<i>n</i><sup>2</sup>) steps, because we performed a complete scan of <span class="KeyTerm1">set2</span> for each element of <span class="KeyTerm1">set1</span>. But with the ordered representation, we can use a more clever method. Begin by comparing the initial elements, <span class="KeyTerm1">x1</span> and <span class="KeyTerm1">x2</span>, of the two sets. If <span class="KeyTerm1">x1</span> equals <span class="KeyTerm1">x2</span>, then that gives an element of the intersection, and the rest of the intersection is the intersection of the <span class="KeyTerm1">tail</span>s of the two sets. Suppose, however, that <span class="KeyTerm1">x1</span> is less than <span class="KeyTerm1">x2</span>. Since <span class="KeyTerm1">x2</span> is the smallest element in <span class="KeyTerm1">set2</span>, we can immediately conclude that <span class="KeyTerm1">x1</span> cannot appear anywhere in <span class="KeyTerm1">set2</span> and hence is not in the intersection. Hence, the intersection is equal to the intersection of <span class="KeyTerm1">set2</span> with the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">set1</span>. Similarly, if <span class="KeyTerm1">x2</span> is less than <span class="KeyTerm1">x1</span>, then the intersection is given by the intersection of <span class="KeyTerm1">set1</span> with the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">set2</span>. Here is the function:</p>
<p class="Sp-text-1"><a id="c2-para-1254"/><b>function</b> intersection_set(set1, set2) {</p>
<p class="Sp-text-1"><a id="c2-para-1255"/>    <b>if</b> (is_null(set1) || is_null(set2)) {</p>
<p class="Sp-text-1"><a id="c2-para-1256"/>        <b>return null</b>;</p>
<p class="Sp-text-1"><a id="c2-para-1257"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-1258"/>        <b>const</b> x1 = head(set1);</p>
<p class="Sp-text-1"><a id="c2-para-1259"/>        <b>const</b> x2 = head(set2);</p>
<p class="Sp-text-1"><a id="c2-para-1260"/>        <b>return</b> x1 === x2</p>
<p class="Sp-text-1"><a id="c2-para-1261"/>               ? pair(x1, intersection_set(tail(set1), tail(set2)))</p>
<p class="Sp-text-1"><a id="c2-para-1262"/>               : x1 &lt; x2</p>
<p class="Sp-text-1"><a id="c2-para-1263"/>               ? intersection_set(tail(set1), set2)</p>
<p class="Sp-text-1"><a id="c2-para-1264"/>               : <i>//</i> x2 &lt; x1</p>
<p class="Sp-text-1"><a id="c2-para-1265"/>                 intersection_set(set1, tail(set2));</p>
<p class="Sp-text-1"><a id="c2-para-1266"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1267"/>}</p>
<p class="paracontinue"><a id="c2-para-1268"/>To estimate the number of steps required by this process, observe that at each step we reduce the intersection problem to computing intersections of smaller sets—removing the first element from <span class="KeyTerm1">set1</span> or <span class="KeyTerm1">set2</span> or both. Thus, the number of steps required is at most the sum of the sizes of <span class="KeyTerm1">set1</span> and <span class="KeyTerm1">set2</span>, rather than the product of the sizes as with the unordered representation. This is Θ(<i>n</i>) growth rather than Θ(<i>n</i><sup>2</sup>)—a considerable speedup, even for sets of moderate size.</p>
</section>
<section>
<h5><a id="c2-sec-0093"/><a id="c2-title-0094"/>Exercise 2.61</h5>
<p class="paraaftertitle"><a id="c2-para-1269"/>Give an implementation of <span class="KeyTerm1">adjoin_set</span> using the ordered representation. By analogy with <span class="KeyTerm1">is_element_of_set</span> show how to take advantage of the ordering to produce a function that requires on the average about half as many steps as with the unordered representation.</p>
</section>
<section>
<h5><a id="c2-sec-0094"/><a id="c2-title-0095"/>Exercise 2.62</h5>
<p class="paraaftertitle"><a id="c2-para-1270"/>Give a Θ(<i>n</i>) implementation of <span class="KeyTerm1">union_set</span> for sets represented as ordered lists.</p>
</section>
<section>
<h5><a id="c2-sec-0095"/><a id="c2-title-0096"/>Sets as binary trees</h5>
<p class="paraaftertitle"><a id="c2-para-1271"/>We can do better than the ordered-list representation by arranging the set elements in the form of a tree. Each node of the tree holds one element of the set, called the “entry” at that node, and a link to each of two other (possibly empty) nodes. The “left” link points to elements smaller than the one at the node, and the “right” link to elements greater than the one at the node. <a id="c2-fig-0026a"/><a href="#c2-fig-0026">Figure 2.16</a> shows some trees that represent the set {1, 3, 5, 7, 9, 11}. The same set may be represented by a tree in a number of different ways. The only thing we require for a valid representation is that all elements in the left subtree be smaller than the node entry and that all elements in the right subtree be larger.</p>
<figure id="c2-fig-0026"><img alt="c2-fig-0016.jpg" src="../images/c2-fig-0016.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0026a">Figure 2.16</a></span> <a id="c2-para-1272"/>Various binary trees that represent the set {1, 3, 5, 7, 9, 11}.</p></figcaption></figure>
<p><a id="c2-para-1273"/>The advantage of the tree representation is this: Suppose we want to check whether a number <i>x</i> is contained in a set. We begin by comparing <i>x</i> with the entry in the top node. If <i>x</i> is less than this, we know that we need only search the left subtree; if <i>x</i> is greater, we need only search the right subtree. Now, if the tree is “balanced,” each of these subtrees will be about half the size of the original. Thus, in one step we have reduced the problem of searching a tree of size <i>n</i> to searching a tree of size <i>n</i>/2. Since the size of the tree is halved at each step, we should expect that the number of steps needed to search a tree of size <i>n</i> grows as Θ(log <i>n</i>).<a id="c2-fn-0034a"/><a href="#c2-fn-0034"><sup>34</sup></a> For large sets, this will be a significant speedup over the previous representations.</p>
<p><a id="c2-para-1274"/>We can represent trees by using lists. Each node will be a list of three items: the entry at the node, the left subtree, and the right subtree. A left or a right subtree of the empty list will indicate that there is no subtree connected there. We can describe this representation by the following functions:<a id="c2-fn-0035a"/><a href="#c2-fn-0035"><sup>35</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-1275"/><b>function</b> entry(tree) { <b>return</b> head(tree); }</p>
<p class="Sp-text-1"><a id="c2-para-1276"/><b>function</b> left_branch(tree) { <b>return</b> head(tail(tree)); }</p>
<p class="Sp-text-1"><a id="c2-para-1277"/><b>function</b> right_branch(tree) { <b>return</b> head(tail(tail(tree))); }</p>
<p class="Sp-text-1"><a id="c2-para-1278"/><b>function</b> make_tree(entry, left, right) {</p>
<p class="Sp-text-1"><a id="c2-para-1279"/>    <b>return</b> list(entry, left, right);</p>
<p class="Sp-text-1"><a id="c2-para-1280"/>}</p>
<p><a id="c2-para-1281"/>Now we can write <span class="KeyTerm1">is_element_of_set</span> using the strategy described above:</p>
<p class="Sp-text-1"><a id="c2-para-1282"/><b>function</b> is_element_of_set(x, set) {</p>
<p class="Sp-text-1"><a id="c2-para-1283"/>    <b>return</b> is_null(set)</p>
<p class="Sp-text-1"><a id="c2-para-1284"/>           ? <b>false</b></p>
<p class="Sp-text-1"><a id="c2-para-1285"/>           : x === entry(set)</p>
<p class="Sp-text-1"><a id="c2-para-1286"/>           ? <b>true</b></p>
<p class="Sp-text-1"><a id="c2-para-1287"/>           : x &lt; entry(set)</p>
<p class="Sp-text-1"><a id="c2-para-1288"/>           ? is_element_of_set(x, left_branch(set))</p>
<p class="Sp-text-1"><a id="c2-para-1289"/>           : <i>//</i> x &gt; entry(set)</p>
<p class="Sp-text-1"><a id="c2-para-1290"/>             is_element_of_set(x, right_branch(set));</p>
<p class="Sp-text-1"><a id="c2-para-1291"/>}</p>
<p><a id="c2-para-1292"/>Adjoining an item to a set is implemented similarly and also requires Θ(log <i>n</i>) steps. To adjoin an item <span class="KeyTerm1">x</span>, we compare <span class="KeyTerm1">x</span> with the node entry to determine whether <span class="KeyTerm1">x</span> should be added to the right or to the left branch, and having adjoined <span class="KeyTerm1">x</span> to the appropriate branch we piece this newly constructed branch together with the original entry and the other branch. If <span class="KeyTerm1">x</span> is equal to the entry, we just return the node. If we are asked to adjoin <span class="KeyTerm1">x</span> to an empty tree, we generate a tree that has <span class="KeyTerm1">x</span> as the entry and empty right and left branches. Here is the function:</p>
<p class="Sp-text-1"><a id="c2-para-1293"/><b>function</b> adjoin_set(x, set) {</p>
<p class="Sp-text-1"><a id="c2-para-1294"/>    <b>return</b> is_null(set)</p>
<p class="Sp-text-1"><a id="c2-para-1295"/>           ? make_tree(x, <b>null</b>, <b>null</b>)</p>
<p class="Sp-text-1"><a id="c2-para-1296"/>           : x === entry(set)</p>
<p class="Sp-text-1"><a id="c2-para-1297"/>           ? set</p>
<p class="Sp-text-1"><a id="c2-para-1298"/>           : x &lt; entry(set)</p>
<p class="Sp-text-1"><a id="c2-para-1299"/>           ? make_tree(entry(set),</p>
<p class="Sp-text-1"><a id="c2-para-1300"/>                       adjoin_set(x, left_branch(set)),</p>
<p class="Sp-text-1"><a id="c2-para-1301"/>                       right_branch(set))</p>
<p class="Sp-text-1"><a id="c2-para-1302"/>           : <i>//</i> x &gt; entry(set)</p>
<p class="Sp-text-1"><a id="c2-para-1303"/>             make_tree(entry(set),</p>
<p class="Sp-text-1"><a id="c2-para-1304"/>                       left_branch(set),</p>
<p class="Sp-text-1"><a id="c2-para-1305"/>                       adjoin_set(x, right_branch(set)));</p>
<p class="Sp-text-1"><a id="c2-para-1306"/>}</p>
<p><a id="c2-para-1307"/>The above claim that searching the tree can be performed in a logarithmic number of steps rests on the assumption that the tree is “balanced,” i.e., that the left and the right subtree of every tree have approximately the same number of elements, so that each subtree contains about half the elements of its parent. But how can we be certain that the trees we construct will be balanced? Even if we start with a balanced tree, adding elements with <span class="KeyTerm1">adjoin_set</span> may produce an unbalanced result. Since the position of a newly adjoined element depends on how the element compares with the items already in the set, we can expect that if we add elements “randomly” the tree will tend to be balanced on the average. But this is not a guarantee. For example, if we start with an empty set and adjoin the numbers 1 through 7 in sequence we end up with the highly unbalanced tree shown in <a id="c2-fig-0027a"/><a href="#c2-fig-0027">figure 2.17</a>. In this tree all the left subtrees are empty, so it has no advantage over a simple ordered list. One way to solve this problem is to define an operation that transforms an arbitrary tree into a balanced tree with the same elements. Then we can perform this transformation after every few <span class="KeyTerm1">adjoin_set</span> operations to keep our set in balance. There are also other ways to solve this problem, most of which involve designing new data structures for which searching and insertion both can be done in Θ(log <i>n</i>) steps.<a id="c2-fn-0036a"/><a href="#c2-fn-0036"><sup>36</sup></a></p>
<figure id="c2-fig-0027"><img alt="c2-fig-0017.jpg" src="../images/c2-fig-0017.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0027a">Figure 2.17</a></span> <a id="c2-para-1308"/>Unbalanced tree produced by adjoining 1 through 7 in sequence.</p></figcaption></figure>
</section>
<section>
<h5><a id="c2-sec-0096"/><a id="c2-title-0097"/>Exercise 2.63</h5>
<p class="paraaftertitle"><a id="c2-para-1309"/>Each of the following two functions converts a binary tree to a list.</p>
<p class="Sp-text-1"><a id="c2-para-1310"/><b>function</b> tree_to_list_1(tree) {</p>
<p class="Sp-text-1"><a id="c2-para-1311"/>    <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c2-para-1312"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-1313"/>           : append(tree_to_list_1(left_branch(tree)),</p>
<p class="Sp-text-1"><a id="c2-para-1314"/>                    pair(entry(tree),</p>
<p class="Sp-text-1"><a id="c2-para-1315"/>                         tree_to_list_1(right_branch(tree))));</p>
<p class="Sp-text-1"><a id="c2-para-1316"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1317"/><b>function</b> tree_to_list_2(tree) {</p>
<p class="Sp-text-1"><a id="c2-para-1318"/>    <b>function</b> copy_to_list(tree, result_list) {</p>
<p class="Sp-text-1"><a id="c2-para-1319"/>        <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c2-para-1320"/>               ? result_list</p>
<p class="Sp-text-1"><a id="c2-para-1321"/>               : copy_to_list(left_branch(tree),</p>
<p class="Sp-text-1"><a id="c2-para-1322"/>                              pair(entry(tree),</p>
<p class="Sp-text-1"><a id="c2-para-1323"/>                                   copy_to_list(right_branch(tree),</p>
<p class="Sp-text-1"><a id="c2-para-1324"/>                                                result_list)));</p>
<p class="Sp-text-1"><a id="c2-para-1325"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1326"/>    <b>return</b> copy_to_list(tree, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c2-para-1327"/>}</p>
<ol class="BS_NumberListA">
<li><a id="c2-li-0044"/><span>a. </span>Do the two functions produce the same result for every tree? If not, how do the results differ? What lists do the two functions produce for the trees in <a href="#c2-fig-0026">figure 2.16</a>?</li>
<li><a id="c2-li-0045"/><span>b. </span>Do the two functions have the same order of growth in the number of steps required to convert a balanced tree with <i>n</i> elements to a list? If not, which one grows more slowly?</li>
</ol>
</section>
<section>
<h5><a id="c2-sec-0097"/><a id="c2-title-0098"/>Exercise 2.64</h5>
<p class="paraaftertitle"><a id="c2-para-1330"/>The following function <span class="KeyTerm1">list_to_tree</span> converts an ordered list to a balanced binary tree. The helper function <span class="KeyTerm1">partial_tree</span> takes as arguments an integer <i>n</i> and list of at least <i>n</i> elements and constructs a balanced tree containing the first <i>n</i> elements of the list. The result returned by <span class="KeyTerm1">partial_tree</span> is a pair (formed with <span class="KeyTerm1">pair</span>) whose <span class="KeyTerm1">head</span> is the constructed tree and whose <span class="KeyTerm1">tail</span> is the list of elements not included in the tree.</p>
<p class="Sp-text-1"><a id="c2-para-1331"/><b>function</b> list_to_tree(elements) {</p>
<p class="Sp-text-1"><a id="c2-para-1332"/>    <b>return</b> head(partial_tree(elements, length(elements)));</p>
<p class="Sp-text-1"><a id="c2-para-1333"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1334"/><b>function</b> partial_tree(elts, n) {</p>
<p class="Sp-text-1"><a id="c2-para-1335"/>    <b>if</b> (n === 0) {</p>
<p class="Sp-text-1"><a id="c2-para-1336"/>        <b>return</b> pair(<b>null</b>, elts);</p>
<p class="Sp-text-1"><a id="c2-para-1337"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-1338"/>        <b>const</b> left_size = math_floor((n - 1) / 2);</p>
<p class="Sp-text-1"><a id="c2-para-1339"/>        <b>const</b> left_result = partial_tree(elts, left_size);</p>
<p class="Sp-text-1"><a id="c2-para-1340"/>        <b>const</b> left_tree = head(left_result);</p>
<p class="Sp-text-1"><a id="c2-para-1341"/>        <b>const</b> non_left_elts = tail(left_result);</p>
<p class="Sp-text-1"><a id="c2-para-1342"/>        <b>const</b> right_size = n - (left_size + 1);</p>
<p class="Sp-text-1"><a id="c2-para-1343"/>        <b>const</b> this_entry = head(non_left_elts);</p>
<p class="Sp-text-1"><a id="c2-para-1344"/>        <b>const</b> right_result = partial_tree(tail(non_left_elts), right_size);</p>
<p class="Sp-text-1"><a id="c2-para-1345"/>        <b>const</b> right_tree = head(right_result);</p>
<p class="Sp-text-1"><a id="c2-para-1346"/>        <b>const</b> remaining_elts = tail(right_result);</p>
<p class="Sp-text-1"><a id="c2-para-1347"/>        <b>return</b> pair(make_tree(this_entry, left_tree, right_tree),</p>
<p class="Sp-text-1"><a id="c2-para-1348"/>                    remaining_elts);</p>
<p class="Sp-text-1"><a id="c2-para-1349"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1350"/>}</p>
<ol class="BS_NumberListA">
<li><a id="c2-li-0046"/><span>a. </span>Write a short paragraph explaining as clearly as you can how <span class="KeyTerm1">partial_tree</span> works. Draw the tree produced by <span class="KeyTerm1">list_to_tree</span> for the list <span class="KeyTerm1">list(1, 3, 5, 7, 9, 11)</span>.</li>
<li><a id="c2-li-0047"/><span>b. </span>What is the order of growth in the number of steps required by <span class="KeyTerm1">list_to_tree</span> to convert a list of <i>n</i> elements?</li>
</ol>
</section>
<section>
<h5><a id="c2-sec-0098"/><a id="c2-title-0099"/>Exercise 2.65</h5>
<p class="paraaftertitle"><a id="c2-para-1353"/>Use the results of exercises 2.63 and 2.64 to give Θ(<i>n</i>) implementations of <span class="KeyTerm1">union_set</span> and <span class="KeyTerm1">intersection_set</span> for sets implemented as (balanced) binary trees.<a id="c2-fn-0037a"/><a href="#c2-fn-0037"><sup>37</sup></a></p>
</section>
<section>
<h5><a id="c2-sec-0099"/><a id="c2-title-0100"/>Sets and information retrieval</h5>
<p class="paraaftertitle"><a id="c2-para-1354"/>We have examined options for using lists to represent sets and have seen how the choice of representation for a data object can have a large impact on the performance of the programs that use the data. Another reason for concentrating on sets is that the techniques discussed here appear again and again in applications involving information retrieval.</p>
<p><a id="c2-para-1355"/>Consider a data base containing a large number of individual records, such as the personnel files for a company or the transactions in an accounting system. A typical data-management system spends a large amount of time accessing or modifying the data in the records and therefore requires an efficient method for accessing records. This is done by identifying a part of each record to serve as an identifying <i>key</i>. A key can be anything that uniquely identifies the record. For a personnel file, it might be an employee's ID number. For an accounting system, it might be a transaction number. Whatever the key is, when we define the record as a data structure we should include a <span class="KeyTerm1">key</span> selector function that retrieves the key associated with a given record.</p>
<p><a id="c2-para-1356"/>Now we represent the data base as a set of records. To locate the record with a given key we use a function <span class="KeyTerm1">lookup</span>, which takes as arguments a key and a data base and which returns the record that has that key, or false if there is no such record. The function <span class="KeyTerm1">lookup</span> is implemented in almost the same way as <span class="KeyTerm1">is_element_of_set</span>. For example, if the set of records is implemented as an unordered list, we could use</p>
<p class="Sp-text-1"><a id="c2-para-1357"/><b>function</b> lookup(given_key, set_of_records) {</p>
<p class="Sp-text-1"><a id="c2-para-1358"/>    <b>return</b> is_null(set_of_records)</p>
<p class="Sp-text-1"><a id="c2-para-1359"/>           ? <b>false</b></p>
<p class="Sp-text-1"><a id="c2-para-1360"/>           : equal(given_key, key(head(set_of_records)))</p>
<p class="Sp-text-1"><a id="c2-para-1361"/>           ? head(set_of_records)</p>
<p class="Sp-text-1"><a id="c2-para-1362"/>           : lookup(given_key, tail(set_of_records));</p>
<p class="Sp-text-1"><a id="c2-para-1363"/>}</p>
<p><a id="c2-para-1364"/>Of course, there are better ways to represent large sets than as unordered lists. Information-retrieval systems in which records have to be “randomly accessed” are typically implemented by a tree-based method, such as the binary-tree representation discussed previously. In designing such a system the methodology of data abstraction can be a great help. The designer can create an initial implementation using a simple, straightforward representation such as unordered lists. This will be unsuitable for the eventual system, but it can be useful in providing a “quick and dirty” data base with which to test the rest of the system. Later on, the data representation can be modified to be more sophisticated. If the data base is accessed in terms of abstract selectors and constructors, this change in representation will not require any changes to the rest of the system.</p>
</section>
<section>
<h5><a id="c2-sec-0100"/><a id="c2-title-0101"/>Exercise 2.66</h5>
<p class="paraaftertitle"><a id="c2-para-1365"/>Implement the <span class="KeyTerm1">lookup</span> function for the case where the set of records is structured as a binary tree, ordered by the numerical values of the keys.</p>
</section>
</section>
<section>
<h3><a id="c2-sec-0101"/><span>2.3.4</span> <a id="c2-title-0102"/>Example: Huffman Encoding Trees</h3>
<p class="paraaftertitle"><a id="c2-para-1366"/>This section provides practice in the use of list structure and data abstraction to manipulate sets and trees. The application is to methods for representing data as sequences of ones and zeros (bits). For example, the ASCII standard code used to represent text in computers encodes each character as a sequence of seven bits. Using seven bits allows us to distinguish 2<sup>7</sup>, or 128, possible different characters. In general, if we want to distinguish <i>n</i> different symbols, we will need to use log<sub>2</sub> <i>n</i> bits per symbol. If all our messages are made up of the eight symbols A, B, C, D, E, F, G, and H, we can choose a code with three bits per character, for example</p>
<figure><figcaption class="tablecaption"><a id="c2-tbl-0004"/></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c2-para-1367"/>A</td>
<td><a id="c2-para-1368"/>000</td>
<td><a id="c2-para-1369"/>C</td>
<td><a id="c2-para-1370"/>010</td>
<td><a id="c2-para-1371"/>E</td>
<td><a id="c2-para-1372"/>100</td>
<td><a id="c2-para-1373"/>G</td>
<td><a id="c2-para-1374"/>110</td></tr>
<tr>
<td><a id="c2-para-1375"/>B</td>
<td><a id="c2-para-1376"/>001</td>
<td><a id="c2-para-1377"/>D</td>
<td><a id="c2-para-1378"/>011</td>
<td><a id="c2-para-1379"/>F</td>
<td><a id="c2-para-1380"/>101</td>
<td><a id="c2-para-1381"/>H</td>
<td><a id="c2-para-1382"/>111</td></tr></tbody></table></div>
</figure>

<p class="paracontinue"><a id="c2-para-1383"/>With this code, the message</p>
<p class="Sp-text-2"><a id="c2-para-1384"/>BACADAEAFABBAAAGAH</p>
<p class="paracontinue"><a id="c2-para-1385"/>is encoded as the string of 54 bits</p>
<p class="Sp-text-2"><a id="c2-para-1386"/>001000010000011000100000101000001001000000000110000111</p>
<p><a id="c2-para-1387"/>Codes such as ASCII and the A-through-H code above are known as <i>fixed-length</i> codes, because they represent each symbol in the message with the same number of bits. It is sometimes advantageous to use <i>variable-length</i> codes, in which different symbols may be represented by different numbers of bits. For example, Morse code does not use the same number of dots and dashes for each letter of the alphabet. In particular, E, the most frequent letter, is represented by a single dot. In general, if our messages are such that some symbols appear very frequently and some very rarely, we can encode data more efficiently (i.e., using fewer bits per message) if we assign shorter codes to the frequent symbols. Consider the following alternative code for the letters A through H:</p>
<figure><figcaption class="tablecaption"><a id="c2-tbl-0005"/></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c2-para-1388"/>A</td>
<td><a id="c2-para-1389"/>0</td>
<td><a id="c2-para-1390"/>C</td>
<td><a id="c2-para-1391"/>1010</td>
<td><a id="c2-para-1392"/>E</td>
<td><a id="c2-para-1393"/>1100</td>
<td><a id="c2-para-1394"/>G</td>
<td><a id="c2-para-1395"/>1110</td></tr>
<tr>
<td><a id="c2-para-1396"/>B</td>
<td><a id="c2-para-1397"/>100</td>
<td><a id="c2-para-1398"/>D</td>
<td><a id="c2-para-1399"/>1011</td>
<td><a id="c2-para-1400"/>F</td>
<td><a id="c2-para-1401"/>1101</td>
<td><a id="c2-para-1402"/>H</td>
<td><a id="c2-para-1403"/>1111</td></tr></tbody></table></div>
</figure>

<p class="paracontinue"><a id="c2-para-1404"/>With this code, the same message as above is encoded as the string</p>
<p class="Sp-text-2"><a id="c2-para-1405"/>100010100101101100011010100100000111001111</p>
<p class="paracontinue"><a id="c2-para-1406"/>This string contains 42 bits, so it saves more than 20% in space in comparison with the fixed-length code shown above.</p>
<p><a id="c2-para-1407"/>One of the difficulties of using a variable-length code is knowing when you have reached the end of a symbol in reading a sequence of zeros and ones. Morse code solves this problem by using a special <i>separator code</i> (in this case, a pause) after the sequence of dots and dashes for each letter. Another solution is to design the code in such a way that no complete code for any symbol is the beginning (or <i>prefix</i>) of the code for another symbol. Such a code is called a <i>prefix code</i>. In the example above, A is encoded by 0 and B is encoded by 100, so no other symbol can have a code that begins with 0 or with 100.</p>
<p><a id="c2-para-1408"/>In general, we can attain significant savings if we use variable-length prefix codes that take advantage of the relative frequencies of the symbols in the messages to be encoded. One particular scheme for doing this is called the Huffman encoding method, after its discoverer, David Huffman. A Huffman code can be represented as a binary tree whose leaves are the symbols that are encoded. At each non-leaf node of the tree there is a set containing all the symbols in the leaves that lie below the node. In addition, each symbol at a leaf is assigned a weight (which is its relative frequency), and each non-leaf node contains a weight that is the sum of all the weights of the leaves lying below it. The weights are not used in the encoding or the decoding process. We will see below how they are used to help construct the tree.</p>
<p><a id="c2-para-1409"/><a id="c2-fig-0028a"/><a href="#c2-fig-0028">Figure 2.18</a> shows the Huffman tree for the A-through-H code given above. The weights at the leaves indicate that the tree was designed for messages in which A appears with relative frequency 8, B with relative frequency 3, and the other letters each with relative frequency 1.</p>
<figure id="c2-fig-0028"><img alt="c2-fig-0018.jpg" src="../images/c2-fig-0018.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0028a">Figure 2.18</a></span> <a id="c2-para-1410"/>A Huffman encoding tree.</p></figcaption></figure>
<p><a id="c2-para-1411"/>Given a Huffman tree, we can find the encoding of any symbol by starting at the root and moving down until we reach the leaf that holds the symbol. Each time we move down a left branch we add a 0 to the code, and each time we move down a right branch we add a 1. (We decide which branch to follow by testing to see which branch either is the leaf node for the symbol or contains the symbol in its set.) For example, starting from the root of the tree in <a href="#c2-fig-0028">figure 2.18</a>, we arrive at the leaf for D by following a right branch, then a left branch, then a right branch, then a right branch; hence, the code for D is 1011.</p>
<p><a id="c2-para-1412"/>To decode a bit sequence using a Huffman tree, we begin at the root and use the successive zeros and ones of the bit sequence to determine whether to move down the left or the right branch. Each time we come to a leaf, we have generated a new symbol in the message, at which point we start over from the root of the tree to find the next symbol. For example, suppose we are given the tree above and the sequence 10001010. Starting at the root, we move down the right branch (since the first bit of the string is 1), then down the left branch (since the second bit is 0), then down the left branch (since the third bit is also 0). This brings us to the leaf for B, so the first symbol of the decoded message is B. Now we start again at the root, and we make a left move because the next bit in the string is 0. This brings us to the leaf for A. Then we start again at the root with the rest of the string 1010, so we move right, left, right, left and reach C. Thus, the entire message is BAC.</p>
<section>
<h5><a id="c2-sec-0102"/><a id="c2-title-0103"/>Generating Huffman trees</h5>
<p class="paraaftertitle"><a id="c2-para-1413"/>Given an “alphabet” of symbols and their relative frequencies, how do we construct the “best” code? (In other words, which tree will encode messages with the fewest bits?) Huffman gave an algorithm for doing this and showed that the resulting code is indeed the best variable-length code for messages where the relative frequency of the symbols matches the frequencies with which the code was constructed. We will not prove this optimality of Huffman codes here, but we will show how Huffman trees are constructed.<a id="c2-fn-0038a"/><a href="#c2-fn-0038"><sup>38</sup></a></p>
<p><a id="c2-para-1414"/>The algorithm for generating a Huffman tree is very simple. The idea is to arrange the tree so that the symbols with the lowest frequency appear farthest away from the root. Begin with the set of leaf nodes, containing symbols and their frequencies, as determined by the initial data from which the code is to be constructed. Now find two leaves with the lowest weights and merge them to produce a node that has these two nodes as its left and right branches. The weight of the new node is the sum of the two weights. Remove the two leaves from the original set and replace them by this new node. Now continue this process. At each step, merge two nodes with the smallest weights, removing them from the set and replacing them with a node that has these two as its left and right branches. The process stops when there is only one node left, which is the root of the entire tree. Here is how the Huffman tree of <a href="#c2-fig-0028">figure 2.18</a> was generated:</p>
<figure><figcaption class="tablecaption"><a id="c2-tbl-0006"/></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c2-para-1415"/>Initial leaves</td>
<td><a id="c2-para-1416"/>{(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}</td></tr>
<tr>
<td><a id="c2-para-1417"/>Merge</td>
<td><a id="c2-para-1418"/>{(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}</td></tr>
<tr>
<td><a id="c2-para-1419"/>Merge</td>
<td><a id="c2-para-1420"/>{(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}</td></tr>
<tr>
<td><a id="c2-para-1421"/>Merge</td>
<td><a id="c2-para-1422"/>{(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}</td></tr>
<tr>
<td><a id="c2-para-1423"/>Merge</td>
<td><a id="c2-para-1424"/>{(A 8) (B 3) ({C D} 2) ({E F G H} 4)}</td></tr>
<tr>
<td><a id="c2-para-1425"/>Merge</td>
<td><a id="c2-para-1426"/>{(A 8) ({B C D} 5) ({E F G H} 4)}</td></tr>
<tr>
<td><a id="c2-para-1427"/>Merge</td>
<td><a id="c2-para-1428"/>{(A 8) ({B C D E F G H} 9)}</td></tr>
<tr>
<td><a id="c2-para-1429"/>Final merge</td>
<td><a id="c2-para-1430"/>{({A B C D E F G H} 17)}</td></tr></tbody></table></div></figure>

<p class="paracontinue"><a id="c2-para-1431"/>The algorithm does not always specify a unique tree, because there may not be unique smallest-weight nodes at each step. Also, the choice of the order in which the two nodes are merged (i.e., which will be the right branch and which will be the left branch) is arbitrary.</p>
</section>
<section>
<h5><a id="c2-sec-0103"/><a id="c2-title-0104"/>Representing Huffman trees</h5>
<p class="paraaftertitle"><a id="c2-para-1432"/>In the exercises below we will work with a system that uses Huffman trees to encode and decode messages and generates Huffman trees according to the algorithm outlined above. We will begin by discussing how trees are represented.</p>
<p><a id="c2-para-1433"/>Leaves of the tree are represented by a list consisting of the string <span class="KeyTerm1">"leaf"</span>, the symbol at the leaf, and the weight:</p>
<p class="Sp-text-1"><a id="c2-para-1434"/><b>function</b> make_leaf(symbol, weight) {</p>
<p class="Sp-text-1"><a id="c2-para-1435"/>    <b>return</b> list("leaf", symbol, weight);</p>
<p class="Sp-text-1"><a id="c2-para-1436"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1437"/><b>function</b> is_leaf(object) {</p>
<p class="Sp-text-1"><a id="c2-para-1438"/>    <b>return</b> head(object) === "leaf";</p>
<p class="Sp-text-1"><a id="c2-para-1439"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1440"/><b>function</b> symbol_leaf(x) { <b>return</b> head(tail(x)); }</p>
<p class="Sp-text-1"><a id="c2-para-1441"/><b>function</b> weight_leaf(x) { <b>return</b> head(tail(tail(x))); }</p>
<p class="paracontinue"><a id="c2-para-1442"/>A general tree will be a list of a string <span class="KeyTerm1">"code_tree"</span>, a left branch, a right branch, a set of symbols, and a weight. The set of symbols will be simply a list of the symbols, rather than some more sophisticated set representation. When we make a tree by merging two nodes, we obtain the weight of the tree as the sum of the weights of the nodes, and the set of symbols as the union of the sets of symbols for the nodes. Since our symbol sets are represented as lists, we can form the union by using the <span class="KeyTerm1">append</span> function we defined in section 2.2.1:</p>
<p class="Sp-text-1"><a id="c2-para-1443"/><b>function</b> make_code_tree(left, right) {</p>
<p class="Sp-text-1"><a id="c2-para-1444"/>    <b>return</b> list("code_tree", left, right,</p>
<p class="Sp-text-1"><a id="c2-para-1445"/>                append(symbols(left), symbols(right)),</p>
<p class="Sp-text-1"><a id="c2-para-1446"/>                weight(left) + weight(right));</p>
<p class="Sp-text-1"><a id="c2-para-1447"/>}</p>
<p class="paracontinue"><a id="c2-para-1448"/>If we make a tree in this way, we have the following selectors:</p>
<p class="Sp-text-1"><a id="c2-para-1449"/><b>function</b> left_branch(tree) { <b>return</b> head(tail(tree)); }</p>
<p class="Sp-text-1"><a id="c2-para-1450"/><b>function</b> right_branch(tree) { <b>return</b> head(tail(tail(tree))); }</p>
<p class="Sp-text-1"><a id="c2-para-1451"/><b>function</b> symbols(tree) {</p>
<p class="Sp-text-1"><a id="c2-para-1452"/>    <b>return</b> is_leaf(tree)</p>
<p class="Sp-text-1"><a id="c2-para-1453"/>           ? list(symbol_leaf(tree))</p>
<p class="Sp-text-1"><a id="c2-para-1454"/>           : head(tail(tail(tail(tree))));</p>
<p class="Sp-text-1"><a id="c2-para-1455"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1456"/><b>function</b> weight(tree) {</p>
<p class="Sp-text-1"><a id="c2-para-1457"/>    <b>return</b> is_leaf(tree)</p>
<p class="Sp-text-1"><a id="c2-para-1458"/>           ? weight_leaf(tree)</p>
<p class="Sp-text-1"><a id="c2-para-1459"/>           : head(tail(tail(tail(tail(tree)))));</p>
<p class="Sp-text-1"><a id="c2-para-1460"/>}</p>
<p class="paracontinue"><a id="c2-para-1461"/>The functions <span class="KeyTerm1">symbols</span> and <span class="KeyTerm1">weight</span> must do something slightly different depending on whether they are called with a leaf or a general tree. These are simple examples of <i>generic functions</i> (functions that can handle more than one kind of data), which we will have much more to say about in sections 2.4 and 2.5.</p>
</section>
<section>
<h5><a id="c2-sec-0104"/><a id="c2-title-0105"/>The decoding function</h5>
<p class="paraaftertitle"><a id="c2-para-1462"/>The following function implements the decoding algorithm. It takes as arguments a list of zeros and ones, together with a Huffman tree.</p>
<p class="Sp-text-1"><a id="c2-para-1463"/><b>function</b> decode(bits, tree) {</p>
<p class="Sp-text-1"><a id="c2-para-1464"/>    <b>function</b> decode_1(bits, current_branch) {</p>
<p class="Sp-text-1"><a id="c2-para-1465"/>        <b>if</b> (is_null(bits)) {</p>
<p class="Sp-text-1"><a id="c2-para-1466"/>            <b>return null</b>;</p>
<p class="Sp-text-1"><a id="c2-para-1467"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-1468"/>            <b>const</b> next_branch = choose_branch(head(bits),</p>
<p class="Sp-text-1"><a id="c2-para-1469"/>                                              current_branch);</p>
<p class="Sp-text-1"><a id="c2-para-1470"/>            <b>return</b> is_leaf(next_branch)</p>
<p class="Sp-text-1"><a id="c2-para-1471"/>                   ? pair(symbol_leaf(next_branch),</p>
<p class="Sp-text-1"><a id="c2-para-1472"/>                          decode_1(tail(bits), tree))</p>
<p class="Sp-text-1"><a id="c2-para-1473"/>                   : decode_1(tail(bits), next_branch);</p>
<p class="Sp-text-1"><a id="c2-para-1474"/>        }</p>
<p class="Sp-text-1"><a id="c2-para-1475"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1476"/>    <b>return</b> decode_1(bits, tree);</p>
<p class="Sp-text-1"><a id="c2-para-1477"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1478"/><b>function</b> choose_branch(bit, branch) {</p>
<p class="Sp-text-1"><a id="c2-para-1479"/>    <b>return</b> bit === 0</p>
<p class="Sp-text-1"><a id="c2-para-1480"/>           ? left_branch(branch)</p>
<p class="Sp-text-1"><a id="c2-para-1481"/>           : bit === 1</p>
<p class="Sp-text-1"><a id="c2-para-1482"/>           ? right_branch(branch)</p>
<p class="Sp-text-1"><a id="c2-para-1483"/>           : error(bit, "bad bit – choose_branch");</p>
<p class="Sp-text-1"><a id="c2-para-1484"/>}</p>
<p class="paracontinue"><a id="c2-para-1485"/>The function <span class="KeyTerm1">decode_1</span> takes two arguments: the list of remaining bits and the current position in the tree. It keeps moving “down” the tree, choosing a left or a right branch according to whether the next bit in the list is a zero or a one. (This is done with the function <span class="KeyTerm1">choose_branch</span>.) When it reaches a leaf, it returns the symbol at that leaf as the next symbol in the message by adjoining it to the result of decoding the rest of the message, starting at the root of the tree. Note the error check in the final clause of <span class="KeyTerm1">choose_branch</span>, which complains if the function finds something other than a zero or a one in the input data.</p>
</section>
<section>
<h5><a id="c2-sec-0105"/><a id="c2-title-0106"/>Sets of weighted elements</h5>
<p class="paraaftertitle"><a id="c2-para-1486"/>In our representation of trees, each non-leaf node contains a set of symbols, which we have represented as a simple list. However, the tree-generating algorithm discussed above requires that we also work with sets of leaves and trees, successively merging the two smallest items. Since we will be required to repeatedly find the smallest item in a set, it is convenient to use an ordered representation for this kind of set.</p>
<p><a id="c2-para-1487"/>We will represent a set of leaves and trees as a list of elements, arranged in increasing order of weight. The following <span class="KeyTerm1">adjoin_set</span> function for constructing sets is similar to the one described in exercise 2.61; however, items are compared by their weights, and the element being added to the set is never already in it.</p>
<p class="Sp-text-1"><a id="c2-para-1488"/><b>function</b> adjoin_set(x, set) {</p>
<p class="Sp-text-1"><a id="c2-para-1489"/>    <b>return</b> is_null(set)</p>
<p class="Sp-text-1"><a id="c2-para-1490"/>           ? list(x)</p>
<p class="Sp-text-1"><a id="c2-para-1491"/>           : weight(x) &lt; weight(head(set))</p>
<p class="Sp-text-1"><a id="c2-para-1492"/>           ? pair(x, set)</p>
<p class="Sp-text-1"><a id="c2-para-1493"/>           : pair(head(set), adjoin_set(x, tail(set)));</p>
<p class="Sp-text-1"><a id="c2-para-1494"/>}</p>
<p><a id="c2-para-1495"/>The following function takes a list of symbol-frequency pairs such as</p>
<p class="Sp-text-1"><a id="c2-para-1496"/>list(list("A", 4), list("B", 2), list("C", 1), list("D", 1))</p>
<p class="paracontinue"><a id="c2-para-1497"/>and constructs an initial ordered set of leaves, ready to be merged according to the Huffman algorithm:</p>
<p class="Sp-text-1"><a id="c2-para-1498"/><b>function</b> make_leaf_set(pairs) {</p>
<p class="Sp-text-1"><a id="c2-para-1499"/>    <b>if</b> (is_null(pairs)) {</p>
<p class="Sp-text-1"><a id="c2-para-1500"/>        <b>return null</b>;</p>
<p class="Sp-text-1"><a id="c2-para-1501"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-1502"/>        <b>const</b> first_pair = head(pairs);</p>
<p class="Sp-text-1"><a id="c2-para-1503"/>        <b>return</b> adjoin_set(</p>
<p class="Sp-text-1"><a id="c2-para-1504"/>                   make_leaf(head(first_pair),        <span class="KeyTerm2"><i>// symbol</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1505"/>                             head(tail(first_pair))), <span class="KeyTerm2"><i>// frequency</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1506"/>                   make_leaf_set(tail(pairs)));</p>
<p class="Sp-text-1"><a id="c2-para-1507"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1508"/>}</p>
</section>
<section>
<h5><a id="c2-sec-0106"/><a id="c2-title-0107"/>Exercise 2.67</h5>
<p class="paraaftertitle"><a id="c2-para-1509"/>Declare an encoding tree and a sample message:</p>
<p class="Sp-text-1"><a id="c2-para-1510"/><b>const</b> sample_tree = make_code_tree(make_leaf("A", 4),</p>
<p class="Sp-text-1"><a id="c2-para-1511"/>                                   make_code_tree(make_leaf("B", 2),</p>
<p class="Sp-text-1"><a id="c2-para-1512"/>                                                  make_code_tree(</p>
<p class="Sp-text-1"><a id="c2-para-1513"/>                                                      make_leaf("D", 1),</p>
<p class="Sp-text-1"><a id="c2-para-1514"/>                                                      make_leaf("C", 1))));</p>
<p class="Sp-text-1"><a id="c2-para-1515"/><b>const</b> sample_message = list(0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0);</p>
<p class="paracontinue"><a id="c2-para-1516"/>Use the <span class="KeyTerm1">decode</span> function to decode the message, and give the result.</p>
</section>
<section>
<h5><a id="c2-sec-0107"/><a id="c2-title-0108"/>Exercise 2.68</h5>
<p class="paraaftertitle"><a id="c2-para-1517"/>The <span class="KeyTerm1">encode</span> function takes as arguments a message and a tree and produces the list of bits that gives the encoded message.</p>
<p class="Sp-text-1"><a id="c2-para-1518"/><b>function</b> encode(message, tree) {</p>
<p class="Sp-text-1"><a id="c2-para-1519"/>    <b>return</b> is_null(message)</p>
<p class="Sp-text-1"><a id="c2-para-1520"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c2-para-1521"/>           : append(encode_symbol(head(message), tree),</p>
<p class="Sp-text-1"><a id="c2-para-1522"/>                    encode(tail(message), tree));</p>
<p class="Sp-text-1"><a id="c2-para-1523"/>}</p>
<p class="paracontinue"><a id="c2-para-1524"/>The function <span class="KeyTerm1">encode_symbol</span>, which you must write, returns the list of bits that encodes a given symbol according to a given tree. You should design <span class="KeyTerm1">encode_symbol</span> so that it signals an error if the symbol is not in the tree at all. Test your function by encoding the result you obtained in exercise 2.67 with the sample tree and seeing whether it is the same as the original sample message.</p>
</section>
<section>
<h5><a id="c2-sec-0108"/><a id="c2-title-0109"/>Exercise 2.69</h5>
<p class="paraaftertitle"><a id="c2-para-1525"/>The following function takes as its argument a list of symbol-frequency pairs (where no symbol appears in more than one pair) and generates a Huffman encoding tree according to the Huffman algorithm.</p>
<p class="Sp-text-1"><a id="c2-para-1526"/><b>function</b> generate_huffman_tree(pairs) {</p>
<p class="Sp-text-1"><a id="c2-para-1527"/>    <b>return</b> successive_merge(make_leaf_set(pairs));</p>
<p class="Sp-text-1"><a id="c2-para-1528"/>}</p>
<p class="paracontinue"><a id="c2-para-1529"/>The function <span class="KeyTerm1">make_leaf_set</span> that transforms the list of pairs into an ordered set of leaves is given above. Write the function <span class="KeyTerm1">successive_merge</span> using <span class="KeyTerm1">make_code_tree</span> to successively merge the smallest-weight elements of the set until there is only one element left, which is the desired Huffman tree. (This function is slightly tricky, but not really complicated. If you find yourself designing a complex function, then you are almost certainly doing something wrong. You can take significant advantage of the fact that we are using an ordered set representation.)</p>
</section>
<section>
<h5><a id="c2-sec-0109"/><a id="c2-title-0110"/>Exercise 2.70</h5>
<p class="paraaftertitle"><a id="c2-para-1530"/>The following eight-symbol alphabet with associated relative frequencies was designed to efficiently encode the lyrics of 1950s rock songs. (Note that the “symbols” of an “alphabet” need not be individual letters.)</p>
<figure><figcaption class="tablecaption"><a id="c2-tbl-0007"/></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c2-para-1531"/>A</td>
<td><a id="c2-para-1532"/>2</td>
<td><a id="c2-para-1533"/>NA</td>
<td><a id="c2-para-1534"/>16</td></tr>
<tr>
<td><a id="c2-para-1535"/>BOOM</td>
<td><a id="c2-para-1536"/>1</td>
<td><a id="c2-para-1537"/>SHA</td>
<td><a id="c2-para-1538"/>3</td></tr>
<tr>
<td><a id="c2-para-1539"/>GET</td>
<td><a id="c2-para-1540"/>2</td>
<td><a id="c2-para-1541"/>YIP</td>
<td><a id="c2-para-1542"/>9</td></tr>
<tr>
<td><a id="c2-para-1543"/>JOB</td>
<td><a id="c2-para-1544"/>2</td>
<td><a id="c2-para-1545"/>WAH</td>
<td><a id="c2-para-1546"/>1</td></tr></tbody></table></div>
</figure>

<p class="paracontinue"><a id="c2-para-1547"/>Use <span class="KeyTerm1">generate_huffman_tree</span> (exercise 2.69) to generate a corresponding Huffman tree, and use <span class="KeyTerm1">encode</span> (exercise 2.68) to encode the following message:</p>
<p class="Sp-text-2"><a id="c2-para-1548"/>Get a job</p>
<p class="Sp-text-2"><a id="c2-para-1549"/>Sha na na na na na na na na</p>
<p class="Sp-text-2"><a id="c2-para-1550"/>Get a job</p>
<p class="Sp-text-2"><a id="c2-para-1551"/>Sha na na na na na na na na</p>
<p class="Sp-text-2"><a id="c2-para-1552"/>Wah yip yip yip yip yip yip yip yip yip</p>
<p class="Sp-text-2"><a id="c2-para-1553"/>Sha boom</p>
<p class="paracontinue"><a id="c2-para-1554"/>How many bits are required for the encoding? What is the smallest number of bits that would be needed to encode this song if we used a fixed-length code for the eight-symbol alphabet?</p>
</section>
<section>
<h5><a id="c2-sec-0110"/><a id="c2-title-0111"/>Exercise 2.71</h5>
<p class="paraaftertitle"><a id="c2-para-1555"/>Suppose we have a Huffman tree for an alphabet of <i>n</i> symbols, and that the relative frequencies of the symbols are 1, 2, 4, . . ., 2<i><sup>n</sup></i><sup>–1</sup>. Sketch the tree for <i>n</i>=5; for <i>n</i>=10. In such a tree (for general <i>n</i>) how may bits are required to encode the most frequent symbol? the least frequent symbol?</p>
</section>
<section>
<h5><a id="c2-sec-0111"/><a id="c2-title-0112"/>Exercise 2.72</h5>
<p class="paraaftertitle"><a id="c2-para-1556"/>Consider the encoding function that you designed in exercise 2.68. What is the order of growth in the number of steps needed to encode a symbol? Be sure to include the number of steps needed to search the symbol list at each node encountered. To answer this question in general is difficult. Consider the special case where the relative frequencies of the <i>n</i> symbols are as described in exercise 2.71, and give the order of growth (as a function of <i>n</i>) of the number of steps needed to encode the most frequent and least frequent symbols in the alphabet.</p>
</section>
</section>
</section>
<section>
<h2><a id="c2-sec-0112"/><span>2.4</span> <a id="c2-title-0113"/>Multiple Representations for Abstract Data</h2>
<p class="paraaftertitle"><a id="c2-para-1557"/>We have introduced data abstraction, a methodology for structuring systems in such a way that much of a program can be specified independent of the choices involved in implementing the data objects that the program manipulates. For example, we saw in section 2.1.1 how to separate the task of designing a program that uses rational numbers from the task of implementing rational numbers in terms of the computer language's primitive mechanisms for constructing compound data. The key idea was to erect an abstraction barrier—in this case, the selectors and constructors for rational numbers (<span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, <span class="KeyTerm1">denom</span>)—that isolates the way rational numbers are used from their underlying representation in terms of list structure. A similar abstraction barrier isolates the details of the functions that perform rational arithmetic (<span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">sub_rat</span>, <span class="KeyTerm1">mul_rat</span>, and <span class="KeyTerm1">div_rat</span>) from the “higher-level” functions that use rational numbers. The resulting program has the structure shown in <a href="#c2-fig-0002">figure 2.1</a>.</p>
<p><a id="c2-para-1558"/>These data-abstraction barriers are powerful tools for controlling complexity. By isolating the underlying representations of data objects, we can divide the task of designing a large program into smaller tasks that can be performed separately. But this kind of data abstraction is not yet powerful enough, because it may not always make sense to speak of “the underlying representation” for a data object.</p>
<p><a id="c2-para-1559"/>For one thing, there might be more than one useful representation for a data object, and we might like to design systems that can deal with multiple representations. To take a simple example, complex numbers may be represented in two almost equivalent ways: in rectangular form (real and imaginary parts) and in polar form (magnitude and angle). Sometimes rectangular form is more appropriate and sometimes polar form is more appropriate. Indeed, it is perfectly plausible to imagine a system in which complex numbers are represented in both ways, and in which the functions for manipulating complex numbers work with either representation.</p>
<p><a id="c2-para-1560"/>More importantly, programming systems are often designed by many people working over extended periods of time, subject to requirements that change over time. In such an environment, it is simply not possible for everyone to agree in advance on choices of data representation. So in addition to the data-abstraction barriers that isolate representation from use, we need abstraction barriers that isolate different design choices from each other and permit different choices to coexist in a single program. Furthermore, since large programs are often created by combining preexisting modules that were designed in isolation, we need conventions that permit programmers to incorporate modules into larger systems <i>additively</i>, that is, without having to redesign or reimplement these modules.</p>
<p><a id="c2-para-1561"/>In this section, we will learn how to cope with data that may be represented in different ways by different parts of a program. This requires constructing <i>generic functions</i>—functions that can operate on data that may be represented in more than one way. Our main technique for building generic functions will be to work in terms of data objects that have <i>type tags</i>, that is, data objects that include explicit information about how they are to be processed. We will also discuss <i>data-directed</i> programming, a powerful and convenient implementation strategy for additively assembling systems with generic operations.</p>
<p><a id="c2-para-1562"/>We begin with the simple complex-number example. We will see how type tags and data-directed style enable us to design separate rectangular and polar representations for complex numbers while maintaining the notion of an abstract “complex-number” data object. We will accomplish this by defining arithmetic functions for complex numbers (<span class="KeyTerm1">add_complex</span>, <span class="KeyTerm1">sub_complex</span>, <span class="KeyTerm1">mul_complex</span>, and <span class="KeyTerm1">div_complex</span>) in terms of generic selectors that access parts of a complex number independent of how the number is represented. The resulting complex-number system, as shown in <a id="c2-fig-0029a"/><a href="#c2-fig-0029">figure 2.19</a>, contains two different kinds of abstraction barriers. The “horizontal” abstraction barriers play the same role as the ones in <a href="#c2-fig-0002">figure 2.1</a>. They isolate “higher-level” operations from “lower-level” representations. In addition, there is a “vertical” barrier that gives us the ability to separately design and install alternative representations.</p>
<figure id="c2-fig-0029"><img alt="c2-fig-0019.jpg" src="../images/c2-fig-0019.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0029a">Figure 2.19</a></span> <a id="c2-para-1563"/>Data-abstraction barriers in the complex-number system.</p></figcaption></figure>
<p><a id="c2-para-1564"/>In section 2.5 we will show how to use type tags and data-directed style to develop a generic arithmetic package. This provides functions (<span class="KeyTerm1">add</span>, <span class="KeyTerm1">mul</span>, and so on) that can be used to manipulate all sorts of “numbers” and can be easily extended when a new kind of number is needed. In section 2.5.3, we'll show how to use generic arithmetic in a system that performs symbolic algebra.</p>
<section>
<h3><a id="c2-sec-0113"/><span>2.4.1</span> <a id="c2-title-0114"/>Representations for Complex Numbers</h3>
<p class="paraaftertitle"><a id="c2-para-1565"/>We will develop a system that performs arithmetic operations on complex numbers as a simple but unrealistic example of a program that uses generic operations. We begin by discussing two plausible representations for complex numbers as ordered pairs: rectangular form (real part and imaginary part) and polar form (magnitude and angle).<a id="c2-fn-0039a"/><a href="#c2-fn-0039"><sup>39</sup></a> Section 2.4.2 will show how both representations can be made to coexist in a single system through the use of type tags and generic operations.</p>
<p><a id="c2-para-1566"/>Like rational numbers, complex numbers are naturally represented as ordered pairs. The set of complex numbers can be thought of as a two-dimensional space with two orthogonal axes, the “real” axis and the “imaginary” axis. (See <a id="c2-fig-0030a"/><a href="#c2-fig-0030">figure 2.20</a>.) From this point of view, the complex number <i>z</i> = <i>x</i> + <i>iy</i> (where <i>i</i><sup>2</sup> = –1) can be thought of as the point in the plane whose real coordinate is <i>x</i> and whose imaginary coordinate is <i>y</i>. Addition of complex numbers reduces in this representation to addition of coordinates:</p>

<figure><figcaption class="tablecaption"><a id="c2-tbl-0008"/></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c2-para-1568"/>Real-part(<i>z</i><sub>1</sub> + <i>z</i><sub>2</sub>)</td>
<td><a id="c2-para-1569"/>=</td>
<td><a id="c2-para-1570"/>Real-part(<i>z</i><sub>1</sub>) + Real-part(<i>z</i><sub>2</sub>)</td></tr>
<tr>
<td><a id="c2-para-1571"/>Imaginary-part(<i>z</i><sub>1</sub> + <i>z</i><sub>2</sub>)</td>
<td><a id="c2-para-1572"/>=</td>
<td><a id="c2-para-1573"/>Imaginary-part(<i>z</i><sub>1</sub>) + Imaginary-part(<i>z</i><sub>2</sub>)</td></tr></tbody></table></div></figure>

<figure id="c2-fig-0030"><img alt="c2-fig-0020.jpg" src="../images/c2-fig-0020.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0030a">Figure 2.20</a></span> <a id="c2-para-1567"/>Complex numbers as points in the plane.</p></figcaption></figure>
<p><a id="c2-para-1574"/>When multiplying complex numbers, it is more natural to think in terms of representing a complex number in polar form, as a magnitude and an angle (<i>r</i> and <i>A</i> in <a href="#c2-fig-0030">figure 2.20</a>). The product of two complex numbers is the vector obtained by stretching one complex number by the length of the other and then rotating it through the angle of the other:</p>
<figure><figcaption class="tablecaption"><a id="c2-tbl-0009"/></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c2-para-1575"/>Magnitude(<i>z</i><sub>1</sub> <i>· z</i><sub>2</sub>)</td>
<td><a id="c2-para-1576"/>=</td>
<td><a id="c2-para-1577"/>Magnitude(<i>z</i><sub>1</sub>) <i>·</i> Magnitude(<i>z</i><sub>2</sub>)</td></tr>
<tr>
<td><a id="c2-para-1578"/>Angle(<i>z</i><sub>1</sub> <i>· z</i><sub>2</sub>)</td>
<td><a id="c2-para-1579"/>=</td>
<td><a id="c2-para-1580"/>Angle(<i>z</i><sub>1</sub>) + Angle(<i>z</i><sub>2</sub>)</td></tr></tbody></table></div></figure>

<p><a id="c2-para-1581"/>Thus, there are two different representations for complex numbers, which are appropriate for different operations. Yet, from the viewpoint of someone writing a program that uses complex numbers, the principle of data abstraction suggests that all the operations for manipulating complex numbers should be available regardless of which representation is used by the computer. For example, it is often useful to be able to find the magnitude of a complex number that is specified by rectangular coordinates. Similarly, it is often useful to be able to determine the real part of a complex number that is specified by polar coordinates.</p>
<p><a id="c2-para-1582"/>To design such a system, we can follow the same data-abstraction strategy we followed in designing the rational-number package in section 2.1.1. Assume that the operations on complex numbers are implemented in terms of four selectors: <span class="KeyTerm1">real_part</span>, <span class="KeyTerm1">imag_part</span>, <span class="KeyTerm1">magnitude</span>, and <span class="KeyTerm1">angle</span>. Also assume that we have two functions for constructing complex numbers: <span class="KeyTerm1">make_from_real_imag</span> returns a complex number with specified real and imaginary parts, and <span class="KeyTerm1">make_from_mag_ang</span> returns a complex number with specified magnitude and angle. These functions have the property that, for any complex number <span class="KeyTerm1">z</span>, both</p>
<p class="Sp-text-1"><a id="c2-para-1583"/>make_from_real_imag(real_part(z), imag_part(z));</p>
<p class="paracontinue"><a id="c2-para-1584"/>and</p>
<p class="Sp-text-1"><a id="c2-para-1585"/>make_from_mag_ang(magnitude(z), angle(z));</p>
<p class="paracontinue"><a id="c2-para-1586"/>produce complex numbers that are equal to <span class="KeyTerm1">z</span>.</p>
<p><a id="c2-para-1587"/>Using these constructors and selectors, we can implement arithmetic on complex numbers using the “abstract data” specified by the constructors and selectors, just as we did for rational numbers in section 2.1.1. As shown in the formulas above, we can add and subtract complex numbers in terms of real and imaginary parts while multiplying and dividing complex numbers in terms of magnitudes and angles:</p>
<p class="Sp-text-1"><a id="c2-para-1588"/><b>function</b> add_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c2-para-1589"/>    <b>return</b> make_from_real_imag(real_part(z1) + real_part(z2),</p>
<p class="Sp-text-1"><a id="c2-para-1590"/>                               imag_part(z1) + imag_part(z2));</p>
<p class="Sp-text-1"><a id="c2-para-1591"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1592"/><b>function</b> sub_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c2-para-1593"/>    <b>return</b> make_from_real_imag(real_part(z1) - real_part(z2),</p>
<p class="Sp-text-1"><a id="c2-para-1594"/>                               imag_part(z1) - imag_part(z2));</p>
<p class="Sp-text-1"><a id="c2-para-1595"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1596"/><b>function</b> mul_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c2-para-1597"/>    <b>return</b> make_from_mag_ang(magnitude(z1) * magnitude(z2),</p>
<p class="Sp-text-1"><a id="c2-para-1598"/>                             angle(z1) + angle(z2));</p>
<p class="Sp-text-1"><a id="c2-para-1599"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1600"/><b>function</b> div_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c2-para-1601"/>    <b>return</b> make_from_mag_ang(magnitude(z1) / magnitude(z2),</p>
<p class="Sp-text-1"><a id="c2-para-1602"/>                             angle(z1) - angle(z2));</p>
<p class="Sp-text-1"><a id="c2-para-1603"/>}</p>
<p><a id="c2-para-1604"/>To complete the complex-number package, we must choose a representation and we must implement the constructors and selectors in terms of primitive numbers and primitive list structure. There are two obvious ways to do this: We can represent a complex number in “rectangular form” as a pair (real part, imaginary part) or in “polar form” as a pair (magnitude, angle). Which shall we choose?</p>
<p><a id="c2-para-1605"/>In order to make the different choices concrete, imagine that there are two programmers, Ben Bitdiddle and Alyssa P. Hacker, who are independently designing representations for the complex-number system. Ben chooses to represent complex numbers in rectangular form. With this choice, selecting the real and imaginary parts of a complex number is straightforward, as is constructing a complex number with given real and imaginary parts. To find the magnitude and the angle, or to construct a complex number with a given magnitude and angle, he uses the trigonometric relations</p>
<figure><figcaption class="tablecaption"><a id="c2-tbl-0010"/></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c2-para-1606"/><i>x</i> = <i>r</i> cos <i>A</i></td>
<td><a id="c2-para-1607"/><i>r</i> = <img alt="c2-fig-5011.jpg" src="../images/c2-fig-5011.jpg"/></td></tr>
<tr>
<td><a id="c2-para-1608"/><i>y</i> = <i>r</i> sin <i>A</i></td>
<td><a id="c2-para-1609"/><i>A</i> = arctan(<i>y</i>, <i>x</i>)</td></tr></tbody></table></div></figure>

<p class="paracontinue"><a id="c2-para-1610"/>which relate the real and imaginary parts (<i>x</i>, <i>y</i>) to the magnitude and the angle (<i>r</i>, <i>A</i>).<a id="c2-fn-0040a"/><a href="#c2-fn-0040"><sup>40</sup></a> Ben's representation is therefore given by the following selectors and constructors:</p>
<p class="Sp-text-1"><a id="c2-para-1611"/><b>function</b> real_part(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1612"/><b>function</b> imag_part(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1613"/><b>function</b> magnitude(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1614"/>    <b>return</b> math_sqrt(square(real_part(z)) + square(imag_part(z)));</p>
<p class="Sp-text-1"><a id="c2-para-1615"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1616"/><b>function</b> angle(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1617"/>    <b>return</b> math_atan2(imag_part(z), real_part(z));</p>
<p class="Sp-text-1"><a id="c2-para-1618"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1619"/><b>function</b> make_from_real_imag(x, y) { <b>return</b> pair(x, y); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1620"/><b>function</b> make_from_mag_ang(r, a) {</p>
<p class="Sp-text-1"><a id="c2-para-1621"/>    <b>return</b> pair(r * math_cos(a), r * math_sin(a));</p>
<p class="Sp-text-1"><a id="c2-para-1622"/>}</p>
<p><a id="c2-para-1623"/>Alyssa, in contrast, chooses to represent complex numbers in polar form. For her, selecting the magnitude and angle is straightforward, but she has to use the trigonometric relations to obtain the real and imaginary parts. Alyssa's representation is:</p>
<p class="Sp-text-1"><a id="c2-para-1624"/><b>function</b> real_part(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1625"/>    <b>return</b> magnitude(z) * math_cos(angle(z));</p>
<p class="Sp-text-1"><a id="c2-para-1626"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1627"/><b>function</b> imag_part(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1628"/>    <b>return</b> magnitude(z) * math_sin(angle(z));</p>
<p class="Sp-text-1"><a id="c2-para-1629"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1630"/><b>function</b> magnitude(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1631"/><b>function</b> angle(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1632"/><b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1633"/>    <b>return</b> pair(math_sqrt(square(x) + square(y)),</p>
<p class="Sp-text-1"><a id="c2-para-1634"/>                math_atan2(y, x));</p>
<p class="Sp-text-1"><a id="c2-para-1635"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1636"/><b>function</b> make_from_mag_ang(r, a) { <b>return</b> pair(r, a); }</p>
<p><a id="c2-para-1637"/>The discipline of data abstraction ensures that the same implementation of <span class="KeyTerm1">add_ complex</span>, <span class="KeyTerm1">sub_complex</span>, <span class="KeyTerm1">mul_complex</span>, and <span class="KeyTerm1">div_complex</span> will work with either Ben's representation or Alyssa's representation.</p>
</section>
<section>
<h3><a id="c2-sec-0114"/><span>2.4.2</span> <a id="c2-title-0115"/>Tagged data</h3>
<p class="paraaftertitle"><a id="c2-para-1638"/>One way to view data abstraction is as an application of the “principle of least commitment.” In implementing the complex-number system in section 2.4.1, we can use either Ben's rectangular representation or Alyssa's polar representation. The abstraction barrier formed by the selectors and constructors permits us to defer to the last possible moment the choice of a concrete representation for our data objects and thus retain maximum flexibility in our system design.</p>
<p><a id="c2-para-1639"/>The principle of least commitment can be carried to even further extremes. If we desire, we can maintain the ambiguity of representation even <i>after</i> we have designed the selectors and constructors, and elect to use both Ben's representation <i>and</i> Alyssa's representation. If both representations are included in a single system, however, we will need some way to distinguish data in polar form from data in rectangular form. Otherwise, if we were asked, for instance, to find the <span class="KeyTerm1">magnitude</span> of the pair (3, 4), we wouldn't know whether to answer 5 (interpreting the number in rectangular form) or 3 (interpreting the number in polar form). A straightforward way to accomplish this distinction is to include a <i>type tag</i>—the string <span class="KeyTerm1">"rectangular"</span> or <span class="KeyTerm1">"polar"</span>—as part of each complex number. Then when we need to manipulate a complex number we can use the tag to decide which selector to apply.</p>
<p><a id="c2-para-1640"/>In order to manipulate tagged data, we will assume that we have functions <span class="KeyTerm1">type_tag</span> and <span class="KeyTerm1">contents</span> that extract from a data object the tag and the actual contents (the polar or rectangular coordinates, in the case of a complex number). We will also postulate a function <span class="KeyTerm1">attach_tag</span> that takes a tag and contents and produces a tagged data object. A straightforward way to implement this is to use ordinary list structure:</p>
<p class="Sp-text-1"><a id="c2-para-1641"/><b>function</b> attach_tag(type_tag, contents) {</p>
<p class="Sp-text-1"><a id="c2-para-1642"/>    <b>return</b> pair(type_tag, contents);</p>
<p class="Sp-text-1"><a id="c2-para-1643"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1644"/><b>function</b> type_tag(datum) {</p>
<p class="Sp-text-1"><a id="c2-para-1645"/>    <b>return</b> is_pair(datum)</p>
<p class="Sp-text-1"><a id="c2-para-1646"/>           ? head(datum)</p>
<p class="Sp-text-1"><a id="c2-para-1647"/>           : error(datum, "bad tagged datum – type_tag");</p>
<p class="Sp-text-1"><a id="c2-para-1648"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1649"/><b>function</b> contents(datum) {</p>
<p class="Sp-text-1"><a id="c2-para-1650"/>    <b>return</b> is_pair(datum)</p>
<p class="Sp-text-1"><a id="c2-para-1651"/>           ? tail(datum)</p>
<p class="Sp-text-1"><a id="c2-para-1652"/>           : error(datum, "bad tagged datum – contents");</p>
<p class="Sp-text-1"><a id="c2-para-1653"/>}</p>
<p><a id="c2-para-1654"/>Using <span class="KeyTerm1">type_tag</span>, we can define predicates <span class="KeyTerm1">is_rectangular</span> and <span class="KeyTerm1">is_polar</span>, which recognize rectangular and polar numbers, respectively:</p>
<p class="Sp-text-1"><a id="c2-para-1655"/><b>function</b> is_rectangular(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1656"/>    <b>return</b> type_tag(z) === "rectangular";</p>
<p class="Sp-text-1"><a id="c2-para-1657"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1658"/><b>function</b> is_polar(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1659"/>    <b>return</b> type_tag(z) === "polar";</p>
<p class="Sp-text-1"><a id="c2-para-1660"/>}</p>
<p><a id="c2-para-1661"/>With type tags, Ben and Alyssa can now modify their code so that their two different representations can coexist in the same system. Whenever Ben constructs a complex number, he tags it as rectangular. Whenever Alyssa constructs a complex number, she tags it as polar. In addition, Ben and Alyssa must make sure that the names of their functions do not conflict. One way to do this is for Ben to append the suffix <span class="KeyTerm1">rectangular</span> to the name of each of his representation functions and for Alyssa to append <span class="KeyTerm1">polar</span> to the names of hers. Here is Ben's revised rectangular representation from section 2.4.1:</p>
<p class="Sp-text-1"><a id="c2-para-1662"/><b>function</b> real_part_rectangular(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1663"/><b>function</b> imag_part_rectangular(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1664"/><b>function</b> magnitude_rectangular(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1665"/>    <b>return</b> math_sqrt(square(real_part_rectangular(z)) +</p>
<p class="Sp-text-1"><a id="c2-para-1666"/>                     square(imag_part_rectangular(z)));</p>
<p class="Sp-text-1"><a id="c2-para-1667"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1668"/><b>function</b> angle_rectangular(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1669"/>    <b>return</b> math_atan(imag_part_rectangular(z),</p>
<p class="Sp-text-1"><a id="c2-para-1670"/>                     real_part_rectangular(z));</p>
<p class="Sp-text-1"><a id="c2-para-1671"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1672"/><b>function</b> make_from_real_imag_rectangular(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1673"/>    <b>return</b> attach_tag("rectangular", pair(x, y));</p>
<p class="Sp-text-1"><a id="c2-para-1674"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1675"/><b>function</b> make_from_mag_ang_rectangular(r, a) {</p>
<p class="Sp-text-1"><a id="c2-para-1676"/>    <b>return</b> attach_tag("rectangular",</p>
<p class="Sp-text-1"><a id="c2-para-1677"/>                      pair(r * math_cos(a), r * math_sin(a)));</p>
<p class="Sp-text-1"><a id="c2-para-1678"/>}</p>
<p class="paracontinue"><a id="c2-para-1679"/>and here is Alyssa's revised polar representation:</p>
<p class="Sp-text-1"><a id="c2-para-1680"/><b>function</b> real_part_polar(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1681"/>    <b>return</b> magnitude_polar(z) * math_cos(angle_polar(z));</p>
<p class="Sp-text-1"><a id="c2-para-1682"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1683"/><b>function</b> imag_part_polar(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1684"/>    <b>return</b> magnitude_polar(z) * math_sin(angle_polar(z));</p>
<p class="Sp-text-1"><a id="c2-para-1685"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1686"/><b>function</b> magnitude_polar(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1687"/><b>function</b> angle_polar(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1688"/><b>function</b> make_from_real_imag_polar(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1689"/>    <b>return</b> attach_tag("polar",</p>
<p class="Sp-text-1"><a id="c2-para-1690"/>                      pair(math_sqrt(square(x) + square(y)),</p>
<p class="Sp-text-1"><a id="c2-para-1691"/>                           math_atan(y, x)));</p>
<p class="Sp-text-1"><a id="c2-para-1692"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1693"/><b>function</b> make_from_mag_ang_polar(r, a) {</p>
<p class="Sp-text-1"><a id="c2-para-1694"/>    <b>return</b> attach_tag("polar", pair(r, a));</p>
<p class="Sp-text-1"><a id="c2-para-1695"/>}</p>
<p><a id="c2-para-1696"/>Each generic selector is implemented as a function that checks the tag of its argument and calls the appropriate function for handling data of that type. For example, to obtain the real part of a complex number, <span class="KeyTerm1">real_part</span> examines the tag to determine whether to use Ben's <span class="KeyTerm1">real_part_rectangular</span> or Alyssa's <span class="KeyTerm1">real_ part_polar</span>. In either case, we use <span class="KeyTerm1">contents</span> to extract the bare, untagged datum and send this to the rectangular or polar function as required:</p>
<p class="Sp-text-1"><a id="c2-para-1697"/><b>function</b> real_part(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1698"/>    <b>return</b> is_rectangular(z)</p>
<p class="Sp-text-1"><a id="c2-para-1699"/>           ? real_part_rectangular(contents(z))</p>
<p class="Sp-text-1"><a id="c2-para-1700"/>           : is_polar(z)</p>
<p class="Sp-text-1"><a id="c2-para-1701"/>           ? real_part_polar(contents(z))</p>
<p class="Sp-text-1"><a id="c2-para-1702"/>           : error(z, "unknown type – real_part");</p>
<p class="Sp-text-1"><a id="c2-para-1703"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1704"/><b>function</b> imag_part(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1705"/>    <b>return</b> is_rectangular(z)</p>
<p class="Sp-text-1"><a id="c2-para-1706"/>           ? imag_part_rectangular(contents(z))</p>
<p class="Sp-text-1"><a id="c2-para-1707"/>           : is_polar(z)</p>
<p class="Sp-text-1"><a id="c2-para-1708"/>           ? imag_part_polar(contents(z))</p>
<p class="Sp-text-1"><a id="c2-para-1709"/>           : error(z, "unknown type – imag_part");</p>
<p class="Sp-text-1"><a id="c2-para-1710"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1711"/><b>function</b> magnitude(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1712"/>    <b>return</b> is_rectangular(z)</p>
<p class="Sp-text-1"><a id="c2-para-1713"/>           ? magnitude_rectangular(contents(z))</p>
<p class="Sp-text-1"><a id="c2-para-1714"/>           : is_polar(z)</p>
<p class="Sp-text-1"><a id="c2-para-1715"/>           ? magnitude_polar(contents(z))</p>
<p class="Sp-text-1"><a id="c2-para-1716"/>           : error(z, "unknown type – magnitude");</p>
<p class="Sp-text-1"><a id="c2-para-1717"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1718"/><b>function</b> angle(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1719"/>    <b>return</b> is_rectangular(z)</p>
<p class="Sp-text-1"><a id="c2-para-1720"/>           ? angle_rectangular(contents(z))</p>
<p class="Sp-text-1"><a id="c2-para-1721"/>           : is_polar(z)</p>
<p class="Sp-text-1"><a id="c2-para-1722"/>           ? angle_polar(contents(z))</p>
<p class="Sp-text-1"><a id="c2-para-1723"/>           : error(z, "unknown type – angle");</p>
<p class="Sp-text-1"><a id="c2-para-1724"/>}</p>
<p><a id="c2-para-1725"/>To implement the complex-number arithmetic operations, we can use the same functions <span class="KeyTerm1">add_complex</span>, <span class="KeyTerm1">sub_complex</span>, <span class="KeyTerm1">mul_complex</span>, and <span class="KeyTerm1">div_complex</span> from section 2.4.1, because the selectors they call are generic, and so will work with either representation. For example, the function <span class="KeyTerm1">add_complex</span> is still</p>
<p class="Sp-text-1"><a id="c2-para-1726"/><b>function</b> add_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c2-para-1727"/>    <b>return</b> make_from_real_imag(real_part(z1) + real_part(z2),</p>
<p class="Sp-text-1"><a id="c2-para-1728"/>                               imag_part(z1) + imag_part(z2));</p>
<p class="Sp-text-1"><a id="c2-para-1729"/>}</p>
<p><a id="c2-para-1730"/>Finally, we must choose whether to construct complex numbers using Ben's representation or Alyssa's representation. One reasonable choice is to construct rectangular numbers whenever we have real and imaginary parts and to construct polar numbers whenever we have magnitudes and angles:</p>
<p class="Sp-text-1"><a id="c2-para-1731"/><b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1732"/>    <b>return</b> make_from_real_imag_rectangular(x, y);</p>
<p class="Sp-text-1"><a id="c2-para-1733"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1734"/><b>function</b> make_from_mag_ang(r, a) {</p>
<p class="Sp-text-1"><a id="c2-para-1735"/>    <b>return</b> make_from_mag_ang_polar(r, a);</p>
<p class="Sp-text-1"><a id="c2-para-1736"/>}</p>
<p><a id="c2-para-1737"/>The resulting complex-number system has the structure shown in <a id="c2-fig-0031a"/><a href="#c2-fig-0031">figure 2.21</a>. The system has been decomposed into three relatively independent parts: the complexnumber-arithmetic operations, Alyssa's polar implementation, and Ben's rectangular implementation. The polar and rectangular implementations could have been written by Ben and Alyssa working separately, and both of these can be used as underlying representations by a third programmer implementing the complexarithmetic functions in terms of the abstract constructor/selector interface.</p>
<figure id="c2-fig-0031"><img alt="c2-fig-0021.jpg" src="../images/c2-fig-0021.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0031a">Figure 2.21</a></span> <a id="c2-para-1738"/>Structure of the generic complex-arithmetic system.</p></figcaption></figure>
<p><a id="c2-para-1739"/>Since each data object is tagged with its type, the selectors operate on the data in a generic manner. That is, each selector is defined to have a behavior that depends upon the particular type of data it is applied to. Notice the general mechanism for interfacing the separate representations: Within a given representation implementation (say, Alyssa's polar package) a complex number is an untyped pair (magnitude, angle). When a generic selector operates on a number of <span class="KeyTerm1">polar</span> type, it strips off the tag and passes the contents on to Alyssa's code. Conversely, when Alyssa constructs a number for general use, she tags it with a type so that it can be appropriately recognized by the higher-level functions. This discipline of stripping off and attaching tags as data objects are passed from level to level can be an important organizational strategy, as we shall see in section 2.5.</p>
</section>
<section>
<h3><a id="c2-sec-0115"/><span>2.4.3</span> <a id="c2-title-0116"/>Data-Directed Programming and Additivity</h3>
<p class="paraaftertitle"><a id="c2-para-1740"/>The general strategy of checking the type of a datum and calling an appropriate function is called <i>dispatching on type</i>. This is a powerful strategy for obtaining modularity in system design. On the other hand, implementing the dispatch as in section 2.4.2 has two significant weaknesses. One weakness is that the generic interface functions (<span class="KeyTerm1">real_part</span>, <span class="KeyTerm1">imag_part</span>, <span class="KeyTerm1">magnitude</span>, and <span class="KeyTerm1">angle</span>) must know about all the different representations. For instance, suppose we wanted to incorporate a new representation for complex numbers into our complex-number system. We would need to identify this new representation with a type, and then add a clause to each of the generic interface functions to check for the new type and apply the appropriate selector for that representation.</p>
<p><a id="c2-para-1741"/>Another weakness of the technique is that even though the individual representations can be designed separately, we must guarantee that no two functions in the entire system have the same name. This is why Ben and Alyssa had to change the names of their original functions from section 2.4.1.</p>
<p><a id="c2-para-1742"/>The issue underlying both of these weaknesses is that the technique for implementing generic interfaces is not <i>additive</i>. The person implementing the generic selector functions must modify those functions each time a new representation is installed, and the people interfacing the individual representations must modify their code to avoid name conflicts. In each of these cases, the changes that must be made to the code are straightforward, but they must be made nonetheless, and this is a source of inconvenience and error. This is not much of a problem for the complexnumber system as it stands, but suppose there were not two but hundreds of different representations for complex numbers. And suppose that there were many generic selectors to be maintained in the abstract-data interface. Suppose, in fact, that no one programmer knew all the interface functions or all the representations. The problem is real and must be addressed in such programs as large-scale data-base-management systems.</p>
<p><a id="c2-para-1743"/>What we need is a means for modularizing the system design even further. This is provided by the programming technique known as <i>data-directed programming</i>. To understand how data-directed programming works, begin with the observation that whenever we deal with a set of generic operations that are common to a set of different types we are, in effect, dealing with a two-dimensional table that contains the possible operations on one axis and the possible types on the other axis. The entries in the table are the functions that implement each operation for each type of argument presented. In the complex-number system developed in the previous section, the correspondence between operation name, data type, and actual function was spread out among the various conditional clauses in the generic interface functions. But the same information could have been organized in a table, as shown in <a id="c2-fig-0032a"/><a href="#c2-fig-0032">figure 2.22</a>.</p>
<figure id="c2-fig-0032"><img alt="c2-fig-0022.jpg" src="../images/c2-fig-0022.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0032a">Figure 2.22</a></span> <a id="c2-para-1744"/>Table of operations for the complex-number system.</p></figcaption></figure>
<p><a id="c2-para-1745"/>Data-directed programming is the technique of designing programs to work with such a table directly. Previously, we implemented the mechanism that interfaces the complex-arithmetic code with the two representation packages as a set of functions that each perform an explicit dispatch on type. Here we will implement the interface as a single function that looks up the combination of the operation name and argument type in the table to find the correct function to apply, and then applies it to the contents of the argument. If we do this, then to add a new representation package to the system we need not change any existing functions; we need only add new entries to the table.</p>
<p><a id="c2-para-1746"/>To implement this plan, assume that we have two functions, <span class="KeyTerm1">put</span> and <span class="KeyTerm1">get</span>, for manipulating the operation-and-type table:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">put(</span><i>op</i><span class="KeyTerm1">,</span> <i>type</i><span class="KeyTerm1">,</span> <i>item</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c2-para-1748"/>installs the <i>item</i> in the table, indexed by the <i>op</i> and the <i>type</i>.</p></li>
<li><span class="KeyTerm1">get(</span><i>op</i><span class="KeyTerm1">,</span> <i>type</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c2-para-1750"/>looks up the <i>op</i>, <i>type</i> entry in the table and returns the item found there. If no item is found, <span class="KeyTerm1">get</span> returns a unique primitive value that is referred to by the name <span class="KeyTerm1">undefined</span> and recognized by the primitive predicate <span class="KeyTerm1">is_undefined</span>.<a id="c2-fn-0041a"/><a href="#c2-fn-0041"><sup>41</sup></a></p></li>
</ul>

<p class="paracontinue"><a id="c2-para-1751"/>For now, we can assume that <span class="KeyTerm1">put</span> and <span class="KeyTerm1">get</span> are included in our language. In chapter 3 (section 3.3.3) we will see how to implement these and other operations for manipulating tables.</p>
<p><a id="c2-para-1752"/>Here is how data-directed programming can be used in the complex-number system. Ben, who developed the rectangular representation, implements his code just as he did originally. He defines a collection of functions or a <i>package</i>, and interfaces these to the rest of the system by adding entries to the table that tell the system how to operate on rectangular numbers. This is accomplished by calling the following function:</p>
<p class="Sp-text-1"><a id="c2-para-1753"/><b>function</b> install_rectangular_package() {</p>
<p class="Sp-text-1"><a id="c2-para-1754"/>    <span class="KeyTerm2"><i>// internal functions</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1755"/>    <b>function</b> real_part(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1756"/>    <b>function</b> imag_part(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1757"/>    <b>function</b> make_from_real_imag(x, y) { <b>return</b> pair(x, y); }</p>
<p class="Sp-text-1"><a id="c2-para-1758"/>    <b>function</b> magnitude(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1759"/>        <b>return</b> math_sqrt(square(real_part(z)) + square(imag_part(z)));</p>
<p class="Sp-text-1"><a id="c2-para-1760"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1761"/>    <b>function</b> angle(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1762"/>        <b>return</b> math_atan(imag_part(z), real_part(z));</p>
<p class="Sp-text-1"><a id="c2-para-1763"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1764"/>    <b>function</b> make_from_mag_ang(r, a) {</p>
<p class="Sp-text-1"><a id="c2-para-1765"/>        <b>return</b> pair(r * math_cos(a), r * math_sin(a));</p>
<p class="Sp-text-1"><a id="c2-para-1766"/>    }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1767"/>    <span class="KeyTerm2"><i>// interface to the rest of the system</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1768"/>    <b>function</b> tag(x) { <b>return</b> attach_tag("rectangular", x); }</p>
<p class="Sp-text-1"><a id="c2-para-1769"/>    put("real_part", list("rectangular"), real_part);</p>
<p class="Sp-text-1"><a id="c2-para-1770"/>    put("imag_part", list("rectangular"), imag_part);</p>
<p class="Sp-text-1"><a id="c2-para-1771"/>    put("magnitude", list("rectangular"), magnitude);</p>
<p class="Sp-text-1"><a id="c2-para-1772"/>    put("angle", list("rectangular"), angle);</p>
<p class="Sp-text-1"><a id="c2-para-1773"/>    put("make_from_real_imag", "rectangular",</p>
<p class="Sp-text-1"><a id="c2-para-1774"/>        (x, y) =&gt; tag(make_from_real_imag(x, y)));</p>
<p class="Sp-text-1"><a id="c2-para-1775"/>    put("make_from_mag_ang", "rectangular",</p>
<p class="Sp-text-1"><a id="c2-para-1776"/>        (r, a) =&gt; tag(make_from_mag_ang(r, a)));</p>
<p class="Sp-text-1"><a id="c2-para-1777"/>    <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c2-para-1778"/>}</p>
<p><a id="c2-para-1779"/>Notice that the internal functions here are the same functions from section 2.4.1 that Ben wrote when he was working in isolation. No changes are necessary in order to interface them to the rest of the system. Moreover, since these function declarations are internal to the installation function, Ben needn't worry about name conflicts with other functions outside the rectangular package. To interface these to the rest of the system, Ben installs his <span class="KeyTerm1">real_part</span> function under the operation name <span class="KeyTerm1">real_part</span> and the type <span class="KeyTerm1">list("rectangular")</span>, and similarly for the other selectors.<a id="c2-fn-0042a"/><a href="#c2-fn-0042"><sup>42</sup></a> The interface also defines the constructors to be used by the external system.<a id="c2-fn-0043a"/><a href="#c2-fn-0043"><sup>43</sup></a> These are identical to Ben's internally defined constructors, except that they attach the tag.</p>
<p><a id="c2-para-1780"/>Alyssa's polar package is analogous:</p>
<p class="Sp-text-1"><a id="c2-para-1781"/><b>function</b> install_polar_package() {</p>
<p class="Sp-text-1"><a id="c2-para-1782"/>    <span class="KeyTerm2"><i>// internal functions</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1783"/>    <b>function</b> magnitude(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1784"/>    <b>function</b> angle(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c2-para-1785"/>    <b>function</b> make_from_mag_ang(r, a) { <b>return</b> pair(r, a); }</p>
<p class="Sp-text-1"><a id="c2-para-1786"/>    <b>function</b> real_part(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1787"/>        <b>return</b> magnitude(z) * math_cos(angle(z));</p>
<p class="Sp-text-1"><a id="c2-para-1788"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1789"/>    <b>function</b> imag_part(z) {</p>
<p class="Sp-text-1"><a id="c2-para-1790"/>        <b>return</b> magnitude(z) * math_sin(angle(z));</p>
<p class="Sp-text-1"><a id="c2-para-1791"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1792"/>    <b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1793"/>        <b>return</b> pair(math_sqrt(square(x) + square(y)),</p>
<p class="Sp-text-1"><a id="c2-para-1794"/>                    math_atan(y, x));</p>
<p class="Sp-text-1"><a id="c2-para-1795"/>    }    </p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1796"/>    <span class="KeyTerm2"><i>// interface to the rest of the system</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1797"/>    <b>function</b> tag(x) { <b>return</b> attach_tag("polar", x); }</p>
<p class="Sp-text-1"><a id="c2-para-1798"/>    put("real_part", list("polar"), real_part);</p>
<p class="Sp-text-1"><a id="c2-para-1799"/>    put("imag_part", list("polar"), imag_part);</p>
<p class="Sp-text-1"><a id="c2-para-1800"/>    put("magnitude", list("polar"), magnitude);</p>
<p class="Sp-text-1"><a id="c2-para-1801"/>    put("angle", list("polar"), angle);</p>
<p class="Sp-text-1"><a id="c2-para-1802"/>    put("make_from_real_imag", "polar",</p>
<p class="Sp-text-1"><a id="c2-para-1803"/>        (x, y) =&gt; tag(make_from_real_imag(x, y)));</p>
<p class="Sp-text-1"><a id="c2-para-1804"/>    put("make_from_mag_ang", "polar",</p>
<p class="Sp-text-1"><a id="c2-para-1805"/>        (r, a) =&gt; tag(make_from_mag_ang(r, a)));</p>
<p class="Sp-text-1"><a id="c2-para-1806"/>    <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c2-para-1807"/>}</p>
<p><a id="c2-para-1808"/>Even though Ben and Alyssa both still use their original functions defined with the same names as each other's (e.g., <span class="KeyTerm1">real_part</span>), these declarations are now internal to different functions (see section 1.1.8), so there is no name conflict.</p>
<p><a id="c2-para-1809"/>The complex-arithmetic selectors access the table by means of a general “operation” function called <span class="KeyTerm1">apply_generic</span>, which applies a generic operation to some arguments. The function <span class="KeyTerm1">apply_generic</span> looks in the table under the name of the operation and the types of the arguments and applies the resulting function if one is present:<a id="c2-fn-0044a"/><a href="#c2-fn-0044"><sup>44</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-1812"/><b>function</b> apply_generic(op, args) {</p>
<p class="Sp-text-1"><a id="c2-para-1813"/>    <b>const</b> type_tags = map(type_tag, args);</p>
<p class="Sp-text-1"><a id="c2-para-1814"/>    <b>const</b> fun = get(op, type_tags);</p>
<p class="Sp-text-1"><a id="c2-para-1815"/>    <b>return</b> ! is_undefined(fun)</p>
<p class="Sp-text-1"><a id="c2-para-1816"/>           ? apply_in_underlying_javascript(fun, map(contents, args))</p>
<p class="Sp-text-1"><a id="c2-para-1817"/>           : error(list(op, type_tags),</p>
<p class="Sp-text-1"><a id="c2-para-1818"/>                   "no method for these types – apply_generic");</p>
<p class="Sp-text-1"><a id="c2-para-1819"/>}</p>
<p class="paracontinue"><a id="c2-para-1820"/>Using <span class="KeyTerm1">apply_generic</span>, we can define our generic selectors as follows:</p>
<p class="Sp-text-1"><a id="c2-para-1821"/><b>function</b> real_part(z) { <b>return</b> apply_generic("real_part", list(z)); }</p>
<p class="Sp-text-1"><a id="c2-para-1822"/><b>function</b> imag_part(z) { <b>return</b> apply_generic("imag_part", list(z)); }</p>
<p class="Sp-text-1"><a id="c2-para-1823"/><b>function</b> magnitude(z) { <b>return</b> apply_generic("magnitude", list(z)); }</p>
<p class="Sp-text-1"><a id="c2-para-1824"/><b>function</b> angle(z)     { <b>return</b> apply_generic("angle", list(z));     }</p>
<p class="paracontinue"><a id="c2-para-1825"/>Observe that these do not change at all if a new representation is added to the system.</p>
<p><a id="c2-para-1826"/>We can also extract from the table the constructors to be used by the programs external to the packages in making complex numbers from real and imaginary parts and from magnitudes and angles. As in section 2.4.2, we construct rectangular numbers whenever we have real and imaginary parts, and polar numbers whenever we have magnitudes and angles:</p>
<p class="Sp-text-1"><a id="c2-para-1827"/><b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1828"/>    <b>return</b> get("make_from_real_imag", "rectangular")(x, y);</p>
<p class="Sp-text-1"><a id="c2-para-1829"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1830"/><b>function</b> make_from_mag_ang(r, a) {</p>
<p class="Sp-text-1"><a id="c2-para-1831"/>    <b>return</b> get("make_from_mag_ang", "polar")(r, a);</p>
<p class="Sp-text-1"><a id="c2-para-1832"/>}</p>
<section>
<h5><a id="c2-sec-0116"/><a id="c2-title-0117"/>Exercise 2.73</h5>
<p class="paraaftertitle"><a id="c2-para-1833"/>Section 2.3.2 described a program that performs symbolic differentiation:</p>
<p class="Sp-text-1"><a id="c2-para-1834"/><b>function</b> deriv(exp, variable) {</p>
<p class="Sp-text-1"><a id="c2-para-1835"/>    <b>return</b> is_number(exp)</p>
<p class="Sp-text-1"><a id="c2-para-1836"/>           ? 0</p>
<p class="Sp-text-1"><a id="c2-para-1837"/>           : is_variable(exp)</p>
<p class="Sp-text-1"><a id="c2-para-1838"/>           ? is_same_variable(exp, variable) ? 1 : 0</p>
<p class="Sp-text-1"><a id="c2-para-1839"/>           : is_sum(exp)</p>
<p class="Sp-text-1"><a id="c2-para-1840"/>           ? make_sum(deriv(addend(exp), variable),</p>
<p class="Sp-text-1"><a id="c2-para-1841"/>                      deriv(augend(exp), variable))</p>
<p class="Sp-text-1"><a id="c2-para-1842"/>           : is_product(exp)</p>
<p class="Sp-text-1"><a id="c2-para-1843"/>           ? make_sum(make_product(multiplier(exp),</p>
<p class="Sp-text-1"><a id="c2-para-1844"/>                                   deriv(multiplicand(exp), variable)),</p>
<p class="Sp-text-1"><a id="c2-para-1845"/>                      make_product(deriv(multiplier(exp), variable),</p>
<p class="Sp-text-1"><a id="c2-para-1846"/>                                   multiplicand(exp)))</p>
<p class="Sp-text-1"><a id="c2-para-1847"/>           <span class="KeyTerm2"><i>// more rules can be added here</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1848"/>           : error(exp, "unknown expression type – deriv");</p>
<p class="Sp-text-1"><a id="c2-para-1849"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1850"/>deriv(list("*", list("*", "x", "y"), list("+", "x", 4)), "x");</p>
<p class="Sp-text-1"><a id="c2-para-1851"/><i>list("+", list("*", list("*", x, y), list("+", 1, 0)),</i></p>
<p class="Sp-text-1"><a id="c2-para-1852"/>          <i>list("*", list("+", list("*", x, 0), list("*", 1, y)),</i></p>
<p class="Sp-text-1"><a id="c2-para-1853"/>                    <i>list("+", x, 4)))</i></p>
<p class="paracontinue"><a id="c2-para-1854"/>We can regard this program as performing a dispatch on the type of the expression to be differentiated. In this situation the “type tag” of the datum is the algebraic operator symbol (such as "+") and the operation being performed is <span class="KeyTerm1">deriv</span>. We can transform this program into data-directed style by rewriting the basic derivative function as</p>
<p class="Sp-text-1"><a id="c2-para-1855"/><b>function</b> deriv(exp, variable) {</p>
<p class="Sp-text-1"><a id="c2-para-1856"/>    <b>return</b> is_number(exp)</p>
<p class="Sp-text-1"><a id="c2-para-1857"/>           ? 0</p>
<p class="Sp-text-1"><a id="c2-para-1858"/>           : is_variable(exp)</p>
<p class="Sp-text-1"><a id="c2-para-1859"/>           ? is_same_variable(exp, variable) ? 1 : 0</p>
<p class="Sp-text-1"><a id="c2-para-1860"/>           : get("deriv", operator(exp))(operands(exp), variable);</p>
<p class="Sp-text-1"><a id="c2-para-1861"/>}</p>
<p class="Sp-text-1"><a id="c2-para-1862"/><b>function</b> operator(exp) { <b>return</b> head(exp); }</p>
<p class="Sp-text-1"><a id="c2-para-1863"/><b>function</b> operands(exp) { <b>return</b> tail(exp); }</p>
<ol class="BS_NumberListA">
<li><a id="c2-li-0050"/><span>a. </span>Explain what was done above. Why can't we assimilate the predicates <span class="KeyTerm1">is_number</span> and <span class="KeyTerm1">is_variable</span> into the data-directed dispatch?</li>
<li><a id="c2-li-0051"/><span>b. </span>Write the functions for derivatives of sums and products, and the auxiliary code required to install them in the table used by the program above.</li>
<li><a id="c2-li-0052"/><span>c. </span>Choose any additional differentiation rule that you like, such as the one for exponents (exercise 2.56), and install it in this data-directed system.</li>
<li><a id="c2-li-0053"/><span>d. </span>In this simple algebraic manipulator the type of an expression is the algebraic operator that binds it together. Suppose, however, we indexed the functions in the opposite way, so that the dispatch line in <span class="KeyTerm1">deriv</span> looked like
<p class="Sp-text-1"><a id="c2-para-1868"/>get(operator(exp), "deriv")(operands(exp), variable);</p>
<p class="paracontinue"><a id="c2-para-1869"/>What corresponding changes to the derivative system are required?</p></li>
</ol>
</section>
<section>
<h5><a id="c2-sec-0117"/><a id="c2-title-0118"/>Exercise 2.74</h5>
<p class="paraaftertitle"><a id="c2-para-1870"/>Insatiable Enterprises, Inc., is a highly decentralized conglomerate company consisting of a large number of independent divisions located all over the world. The company's computer facilities have just been interconnected by means of a clever network-interfacing scheme that makes the entire network appear to any user to be a single computer. Insatiable's president, in her first attempt to exploit the ability of the network to extract administrative information from division files, is dismayed to discover that, although all the division files have been implemented as data structures in JavaScript, the particular data structure used varies from division to division. A meeting of division managers is hastily called to search for a strategy to integrate the files that will satisfy headquarters’ needs while preserving the existing autonomy of the divisions.</p>
<p><a id="c2-para-1871"/>Show how such a strategy can be implemented with data-directed programming. As an example, suppose that each division's personnel records consist of a single file, which contains a set of records keyed on employees’ names. The structure of the set varies from division to division. Furthermore, each employee's record is itself a set (structured differently from division to division) that contains information keyed under identifiers such as <span class="KeyTerm1">address</span> and <span class="KeyTerm1">salary</span>. In particular:</p>
<ol class="BS_NumberListA">
<li><a id="c2-li-0054"/><span>a. </span>Implement for headquarters a <span class="KeyTerm1">get_record</span> function that retrieves a specified employee's record from a specified personnel file. The function should be applicable to any division's file. Explain how the individual divisions’ files should be structured. In particular, what type information must be supplied?</li>
<li><a id="c2-li-0055"/><span>b. </span>Implement for headquarters a <span class="KeyTerm1">get_salary</span> function that returns the salary information from a given employee's record from any division's personnel file. How should the record be structured in order to make this operation work?</li>
<li><a id="c2-li-0056"/><span>c. </span>Implement for headquarters a <span class="KeyTerm1">find_employee_record</span> function. This should search all the divisions’ files for the record of a given employee and return the record. Assume that this function takes as arguments an employee's name and a list of all the divisions’ files.</li>
<li><a id="c2-li-0057"/><span>d. </span>When Insatiable takes over a new company, what changes must be made in order to incorporate the new personnel information into the central system?</li>
</ol>
</section>
<section>
<h5><a id="c2-sec-0118"/><a id="c2-title-0119"/>Message passing</h5>
<p class="paraaftertitle"><a id="c2-para-1876"/>The key idea of data-directed programming is to handle generic operations in programs by dealing explicitly with operation-and-type tables, such as the table in <a href="#c2-fig-0032">figure 2.22</a>. The style of programming we used in section 2.4.2 organized the required dispatching on type by having each operation take care of its own dispatching. In effect, this decomposes the operation-and-type table into rows, with each generic operation function representing a row of the table.</p>
<p><a id="c2-para-1877"/>An alternative implementation strategy is to decompose the table into columns and, instead of using “intelligent operations” that dispatch on data types, to work with “intelligent data objects” that dispatch on operation names. We can do this by arranging things so that a data object, such as a rectangular number, is represented as a function that takes as input the required operation name and performs the operation indicated. In such a discipline, <span class="KeyTerm1">make_from_real_imag</span> could be written as</p>
<p class="Sp-text-1"><a id="c2-para-1878"/><b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1879"/>    <b>function</b> dispatch(op) {</p>
<p class="Sp-text-1"><a id="c2-para-1880"/>        <b>return</b> op === "real_part"</p>
<p class="Sp-text-1"><a id="c2-para-1881"/>               ? x</p>
<p class="Sp-text-1"><a id="c2-para-1882"/>               : op === "imag_part"</p>
<p class="Sp-text-1"><a id="c2-para-1883"/>               ? y</p>
<p class="Sp-text-1"><a id="c2-para-1884"/>               : op === "magnitude"</p>
<p class="Sp-text-1"><a id="c2-para-1885"/>               ? math_sqrt(square(x) + square(y))</p>
<p class="Sp-text-1"><a id="c2-para-1886"/>               : op === "angle"</p>
<p class="Sp-text-1"><a id="c2-para-1887"/>               ? math_atan(y, x)</p>
<p class="Sp-text-1"><a id="c2-para-1888"/>               : error(op, "unknown op – make_from_real_imag");</p>
<p class="Sp-text-1"><a id="c2-para-1889"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1890"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c2-para-1891"/>}</p>
<p class="paracontinue"><a id="c2-para-1892"/>The corresponding <span class="KeyTerm1">apply_generic</span> function, which applies a generic operation to an argument, now simply feeds the operation's name to the data object and lets the object do the work:<a id="c2-fn-0045a"/><a href="#c2-fn-0045"><sup>45</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-1893"/><b>function</b> apply_generic(op, arg) { <b>return</b> head(arg)(op); }</p>
<p class="paracontinue"><a id="c2-para-1894"/>Note that the value returned by <span class="KeyTerm1">make_from_real_imag</span> is a function—the internal <span class="KeyTerm1">dispatch</span> function. This is the function that is invoked when <span class="KeyTerm1">apply_generic</span> requests an operation to be performed.</p>
<p><a id="c2-para-1895"/>This style of programming is called <i>message passing</i>. The name comes from the image that a data object is an entity that receives the requested operation name as a “message.” We have already seen an example of message passing in section 2.1.3, where we saw how <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> could be defined with no data objects but only functions. Here we see that message passing is not a mathematical trick but a useful technique for organizing systems with generic operations. In the remainder of this chapter we will continue to use data-directed programming, rather than message passing, to discuss generic arithmetic operations. In chapter 3 we will return to message passing, and we will see that it can be a powerful tool for structuring simulation programs.</p>
</section>
<section>
<h5><a id="c2-sec-0119"/><a id="c2-title-0120"/>Exercise 2.75</h5>
<p class="paraaftertitle"><a id="c2-para-1896"/>Implement the constructor <span class="KeyTerm1">make_from_mag_ang</span> in message-passing style. This function should be analogous to the <span class="KeyTerm1">make_from_real_imag</span> function given above.</p>
</section>
<section>
<h5><a id="c2-sec-0120"/><a id="c2-title-0121"/>Exercise 2.76</h5>
<p class="paraaftertitle"><a id="c2-para-1897"/>As a large system with generic operations evolves, new types of data objects or new operations may be needed. For each of the three strategies—generic operations with explicit dispatch, data-directed style, and message-passing-style—describe the changes that must be made to a system in order to add new types or new operations. Which organization would be most appropriate for a system in which new types must often be added? Which would be most appropriate for a system in which new operations must often be added?</p>
</section>
</section>
</section>
<section>
<h2><a id="c2-sec-0121"/><span>2.5</span> <a id="c2-title-0122"/>Systems with Generic Operations</h2>
<p class="paraaftertitle"><a id="c2-para-1898"/>In the previous section, we saw how to design systems in which data objects can be represented in more than one way. The key idea is to link the code that specifies the data operations to the several representations by means of generic interface functions. Now we will see how to use this same idea not only to define operations that are generic over different representations but also to define operations that are generic over different kinds of arguments. We have already seen several different packages of arithmetic operations: the primitive arithmetic (<span class="KeyTerm1">+</span>, <span class="KeyTerm1">-</span>, <span class="KeyTerm1">*</span>, <span class="KeyTerm1">/</span>) built into our language, the rational-number arithmetic (<span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">sub_rat</span>, <span class="KeyTerm1">mul_rat</span>, <span class="KeyTerm1">div_rat</span>) of section 2.1.1, and the complex-number arithmetic that we implemented in section 2.4.3. We will now use data-directed techniques to construct a package of arithmetic operations that incorporates all the arithmetic packages we have already constructed.</p>
<p><a id="c2-para-1899"/><a id="c2-fig-0033a"/><a href="#c2-fig-0033">Figure 2.23</a> shows the structure of the system we shall build. Notice the abstraction barriers. From the perspective of someone using “numbers,” there is a single function <span class="KeyTerm1">add</span> that operates on whatever numbers are supplied. The function <span class="KeyTerm1">add</span> is part of a generic interface that allows the separate ordinary-arithmetic, rationalarithmetic, and complex-arithmetic packages to be accessed uniformly by programs that use numbers. Any individual arithmetic package (such as the complex package) may itself be accessed through generic functions (such as <span class="KeyTerm1">add_complex</span>) that combine packages designed for different representations (such as rectangular and polar). Moreover, the structure of the system is additive, so that one can design the individual arithmetic packages separately and combine them to produce a generic arithmetic system.</p>
<figure id="c2-fig-0033"><img alt="c2-fig-0023.jpg" src="../images/c2-fig-0023.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0033a">Figure 2.23</a></span> <a id="c2-para-1900"/>Generic arithmetic system.</p></figcaption></figure>
<section>
<h3><a id="c2-sec-0122"/><span>2.5.1</span> <a id="c2-title-0123"/>Generic Arithmetic Operations</h3>
<p class="paraaftertitle"><a id="c2-para-1901"/>The task of designing generic arithmetic operations is analogous to that of designing the generic complex-number operations. We would like, for instance, to have a generic addition function <span class="KeyTerm1">add</span> that acts like ordinary primitive addition <span class="KeyTerm1">+</span> on ordinary numbers, like <span class="KeyTerm1">add_rat</span> on rational numbers, and like <span class="KeyTerm1">add_complex</span> on complex numbers. We can implement <span class="KeyTerm1">add</span>, and the other generic arithmetic operations, by following the same strategy we used in section 2.4.3 to implement the generic selectors for complex numbers. We will attach a type tag to each kind of number and cause the generic function to dispatch to an appropriate package according to the data type of its arguments.</p>
<p><a id="c2-para-1902"/>The generic arithmetic functions are defined as follows:</p>
<p class="Sp-text-1"><a id="c2-para-1903"/><b>function</b> add(x, y) { <b>return</b> apply_generic("add", list(x, y)); }</p>
<p class="Sp-text-1"><a id="c2-para-1904"/><b>function</b> sub(x, y) { <b>return</b> apply_generic("sub", list(x, y)); }</p>
<p class="Sp-text-1"><a id="c2-para-1905"/><b>function</b> mul(x, y) { <b>return</b> apply_generic("mul", list(x, y)); }</p>
<p class="Sp-text-1"><a id="c2-para-1906"/><b>function</b> div(x, y) { <b>return</b> apply_generic("div", list(x, y)); }</p>
<p><a id="c2-para-1907"/>We begin by installing a package for handling <i>ordinary</i> numbers, that is, the primitive numbers of our language. We tag these with the string <span class="KeyTerm1">"javascript_number"</span>. The arithmetic operations in this package are the primitive arithmetic functions (so there is no need to define extra functions to handle the untagged numbers). Since these operations each take two arguments, they are installed in the table keyed by the list <span class="KeyTerm1">list("javascript_number", "javascript_number")</span>:</p>
<p class="Sp-text-1"><a id="c2-para-1908"/><b>function</b> install_javascript_number_package() {</p>
<p class="Sp-text-1"><a id="c2-para-1909"/>    <b>function</b> tag(x) {</p>
<p class="Sp-text-1"><a id="c2-para-1910"/>        <b>return</b> attach_tag("javascript_number", x);</p>
<p class="Sp-text-1"><a id="c2-para-1911"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1912"/>    put("add", list("javascript_number", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c2-para-1913"/>        (x, y) =&gt; tag(x + y));</p>
<p class="Sp-text-1"><a id="c2-para-1914"/>    put("sub", list("javascript_number", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c2-para-1915"/>        (x, y) =&gt; tag(x - y));</p>
<p class="Sp-text-1"><a id="c2-para-1916"/>    put("mul", list("javascript_number", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c2-para-1917"/>        (x, y) =&gt; tag(x * y));</p>
<p class="Sp-text-1"><a id="c2-para-1918"/>    put("div", list("javascript_number", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c2-para-1919"/>        (x, y) =&gt; tag(x / y));</p>
<p class="Sp-text-1"><a id="c2-para-1920"/>    put("make", "javascript_number",</p>
<p class="Sp-text-1"><a id="c2-para-1921"/>        x =&gt; tag(x));</p>
<p class="Sp-text-1"><a id="c2-para-1922"/>    <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c2-para-1923"/>}</p>
<p><a id="c2-para-1924"/>Users of the JavaScript-number package will create (tagged) ordinary numbers by means of the function:</p>
<p class="Sp-text-1"><a id="c2-para-1925"/><b>function</b> make_javascript_number(n) {</p>
<p class="Sp-text-1"><a id="c2-para-1926"/>    <b>return</b> get("make", "javascript_number")(n);</p>
<p class="Sp-text-1"><a id="c2-para-1927"/>}</p>
<p><a id="c2-para-1928"/>Now that the framework of the generic arithmetic system is in place, we can readily include new kinds of numbers. Here is a package that performs rational arithmetic. Notice that, as a benefit of additivity, we can use without modification the rational-number code from section 2.1.1 as the internal functions in the package:</p>
<p class="Sp-text-1"><a id="c2-para-1929"/><b>function</b> install_rational_package() {</p>
<p class="Sp-text-1"><a id="c2-para-1930"/>    <span class="KeyTerm2"><i>// internal functions</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1931"/>    <b>function</b> numer(x) { <b>return</b> head(x); }</p>
<p class="Sp-text-1"><a id="c2-para-1932"/>    <b>function</b> denom(x) { <b>return</b> tail(x); }</p>
<p class="Sp-text-1"><a id="c2-para-1933"/>    <b>function</b> make_rat(n, d) {</p>
<p class="Sp-text-1"><a id="c2-para-1934"/>        <b>const</b> g = gcd(n, d);</p>
<p class="Sp-text-1"><a id="c2-para-1935"/>        <b>return</b> pair(n / g, d / g);</p>
<p class="Sp-text-1"><a id="c2-para-1936"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1937"/>    <b>function</b> add_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1938"/>        <b>return</b> make_rat(numer(x) * denom(y) + numer(y) * denom(x),</p>
<p class="Sp-text-1"><a id="c2-para-1939"/>                        denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c2-para-1940"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1941"/>    <b>function</b> sub_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1942"/>        <b>return</b> make_rat(numer(x) * denom(y) - numer(y) * denom(x),</p>
<p class="Sp-text-1"><a id="c2-para-1943"/>                        denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c2-para-1944"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1945"/>    <b>function</b> mul_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1946"/>        <b>return</b> make_rat(numer(x) * numer(y),</p>
<p class="Sp-text-1"><a id="c2-para-1947"/>                        denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c2-para-1948"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1949"/>    <b>function</b> div_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1950"/>        <b>return</b> make_rat(numer(x) * denom(y),</p>
<p class="Sp-text-1"><a id="c2-para-1951"/>                        denom(x) * numer(y));</p>
<p class="Sp-text-1"><a id="c2-para-1952"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1953"/>    <span class="KeyTerm2"><i>// interface to rest of the system</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1954"/>    <b>function</b> tag(x) {</p>
<p class="Sp-text-1"><a id="c2-para-1955"/>        <b>return</b> attach_tag("rational", x);</p>
<p class="Sp-text-1"><a id="c2-para-1956"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1957"/>    put("add", list("rational", "rational"),</p>
<p class="Sp-text-1"><a id="c2-para-1958"/>        (x, y) =&gt; tag(add_rat(x, y)));</p>
<p class="Sp-text-1"><a id="c2-para-1959"/>    put("sub", list("rational", "rational"),</p>
<p class="Sp-text-1"><a id="c2-para-1960"/>        (x, y) =&gt; tag(sub_rat(x, y)));</p>
<p class="Sp-text-1"><a id="c2-para-1961"/>    put("mul", list("rational", "rational"),</p>
<p class="Sp-text-1"><a id="c2-para-1962"/>        (x, y) =&gt; tag(mul_rat(x, y)));</p>
<p class="Sp-text-1"><a id="c2-para-1963"/>    put("div", list("rational", "rational"),</p>
<p class="Sp-text-1"><a id="c2-para-1964"/>        (x, y) =&gt; tag(div_rat(x, y)));</p>
<p class="Sp-text-1"><a id="c2-para-1965"/>    put("make", "rational",</p>
<p class="Sp-text-1"><a id="c2-para-1966"/>        (n, d) =&gt; tag(make_rat(n, d)));</p>
<p class="Sp-text-1"><a id="c2-para-1967"/>    <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c2-para-1968"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-1969"/><b>function</b> make_rational(n, d) {</p>
<p class="Sp-text-1"><a id="c2-para-1970"/>    <b>return</b> get("make", "rational")(n, d);</p>
<p class="Sp-text-1"><a id="c2-para-1971"/>}</p>
<p><a id="c2-para-1972"/>We can install a similar package to handle complex numbers, using the tag <span class="KeyTerm1">"complex"</span>. In creating the package, we extract from the table the operations <span class="KeyTerm1">make_from_real_imag</span> and <span class="KeyTerm1">make_from_mag_ang</span> that were defined by the rectangular and polar packages. Additivity permits us to use, as the internal operations, the same <span class="KeyTerm1">add_complex</span>, <span class="KeyTerm1">sub_complex</span>, <span class="KeyTerm1">mul_complex</span>, and <span class="KeyTerm1">div_complex</span> functions from section 2.4.1.</p>
<p class="Sp-text-1"><a id="c2-para-1973"/><b>function</b> install_complex_package() {</p>
<p class="Sp-text-1"><a id="c2-para-1974"/>    <span class="KeyTerm2"><i>// imported functions from rectangular and polar packages</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1975"/>    <b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-1976"/>        <b>return</b> get("make_from_real_imag", "rectangular")(x, y);</p>
<p class="Sp-text-1"><a id="c2-para-1977"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1978"/>    <b>function</b> make_from_mag_ang(r, a) {</p>
<p class="Sp-text-1"><a id="c2-para-1979"/>        <b>return</b> get("make_from_mag_ang", "polar")(r, a);</p>
<p class="Sp-text-1"><a id="c2-para-1980"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1981"/>    <span class="KeyTerm2"><i>// internal functions</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1982"/>    <b>function</b> add_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c2-para-1983"/>        <b>return</b> make_from_real_imag(real_part(z1) + real_part(z2),</p>
<p class="Sp-text-1"><a id="c2-para-1984"/>                                   imag_part(z1) + imag_part(z2));</p>
<p class="Sp-text-1"><a id="c2-para-1985"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1986"/>    <b>function</b> sub_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c2-para-1987"/>        <b>return</b> make_from_real_imag(real_part(z1) - real_part(z2),</p>
<p class="Sp-text-1"><a id="c2-para-1988"/>                                   imag_part(z1) - imag_part(z2));</p>
<p class="Sp-text-1"><a id="c2-para-1989"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1990"/>    <b>function</b> mul_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c2-para-1991"/>        <b>return</b> make_from_mag_ang(magnitude(z1) * magnitude(z2),</p>
<p class="Sp-text-1"><a id="c2-para-1992"/>                                 angle(z1) + angle(z2));</p>
<p class="Sp-text-1"><a id="c2-para-1993"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1994"/><b>function</b> div_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c2-para-1995"/>    <b>return</b> make_from_mag_ang(magnitude(z1) / magnitude(z2),</p>
<p class="Sp-text-1"><a id="c2-para-1996"/>                                 angle(z1) - angle(z2));</p>
<p class="Sp-text-1"><a id="c2-para-1997"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-1998"/>    <span class="KeyTerm2"><i>// interface to rest of the system</i></span></p>
<p class="Sp-text-1"><a id="c2-para-1999"/>    <b>function</b> tag(z) { <b>return</b> attach_tag("complex", z); }</p>
<p class="Sp-text-1"><a id="c2-para-2000"/>    put("add", list("complex", "complex"),</p>
<p class="Sp-text-1"><a id="c2-para-2001"/>        (z1, z2) =&gt; tag(add_complex(z1, z2)));</p>
<p class="Sp-text-1"><a id="c2-para-2002"/>    put("sub", list("complex", "complex"),</p>
<p class="Sp-text-1"><a id="c2-para-2003"/>        (z1, z2) =&gt; tag(sub_complex(z1, z2)));</p>
<p class="Sp-text-1"><a id="c2-para-2004"/>    put("mul", list("complex", "complex"),</p>
<p class="Sp-text-1"><a id="c2-para-2005"/>        (z1, z2) =&gt; tag(mul_complex(z1, z2)));</p>
<p class="Sp-text-1"><a id="c2-para-2006"/>    put("div", list("complex", "complex"),</p>
<p class="Sp-text-1"><a id="c2-para-2007"/>        (z1, z2) =&gt; tag(div_complex(z1, z2)));</p>
<p class="Sp-text-1"><a id="c2-para-2008"/>    put("make_from_real_imag", "complex",</p>
<p class="Sp-text-1"><a id="c2-para-2009"/>        (x, y) =&gt; tag(make_from_real_imag(x, y)));</p>
<p class="Sp-text-1"><a id="c2-para-2010"/>    put("make_from_mag_ang", "complex",</p>
<p class="Sp-text-1"><a id="c2-para-2011"/>        (r, a) =&gt; tag(make_from_mag_ang(r, a)));</p>
<p class="Sp-text-1"><a id="c2-para-2012"/>    <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c2-para-2013"/>}</p>
<p><a id="c2-para-2014"/>Programs outside the complex-number package can construct complex numbers either from real and imaginary parts or from magnitudes and angles. Notice how the underlying functions, originally defined in the rectangular and polar packages, are exported to the complex package, and exported from there to the outside world.</p>
<p class="Sp-text-1"><a id="c2-para-2015"/><b>function</b> make_complex_from_real_imag(x, y){</p>
<p class="Sp-text-1"><a id="c2-para-2016"/>    <b>return</b> get("make_from_real_imag", "complex")(x, y);</p>
<p class="Sp-text-1"><a id="c2-para-2017"/>}</p>
<p class="Sp-text-1"><a id="c2-para-2018"/><b>function</b> make_complex_from_mag_ang(r, a){</p>
<p class="Sp-text-1"><a id="c2-para-2019"/>    <b>return</b> get("make_from_mag_ang", "complex")(r, a);</p>
<p class="Sp-text-1"><a id="c2-para-2020"/>}</p>
<p><a id="c2-para-2021"/>What we have here is a two-level tag system. A typical complex number, such as 3 + 4<i>i</i> in rectangular form, would be represented as shown in <a id="c2-fig-0034a"/><a href="#c2-fig-0034">figure 2.24</a>. The outer tag (<span class="KeyTerm1">"complex"</span>) is used to direct the number to the complex package. Once within the complex package, the next tag (<span class="KeyTerm1">"rectangular"</span>) is used to direct the number to the rectangular package. In a large and complicated system there might be many levels, each interfaced with the next by means of generic operations. As a data object is passed “downward,” the outer tag that is used to direct it to the appropriate package is stripped off (by applying <span class="KeyTerm1">contents</span>) and the next level of tag (if any) becomes visible to be used for further dispatching.</p>
<figure id="c2-fig-0034"><img alt="c2-fig-0024.jpg" src="../images/c2-fig-0024.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0034a">Figure 2.24</a></span> <a id="c2-para-2022"/>Representation of 3 + 4i in rectangular form.</p></figcaption></figure>
<p><a id="c2-para-2023"/>In the above packages, we used <span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">add_complex</span>, and the other arithmetic functions exactly as originally written. Once these declarations are internal to different installation functions, however, they no longer need names that are distinct from each other: we could simply name them <span class="KeyTerm1">add</span>, <span class="KeyTerm1">sub</span>, <span class="KeyTerm1">mul</span>, and <span class="KeyTerm1">div</span> in both packages.</p>
<section>
<h5><a id="c2-sec-0123"/><a id="c2-title-0124"/>Exercise 2.77</h5>
<p class="paraaftertitle"><a id="c2-para-2024"/>Louis Reasoner tries to evaluate the expression <span class="KeyTerm1">magnitude(z)</span> where <span class="KeyTerm1">z</span> is the object shown in <a href="#c2-fig-0034">figure 2.24</a>. To his surprise, instead of the answer 5 he gets an error message from <span class="KeyTerm1">apply_generic</span>, saying there is no method for the operation <span class="KeyTerm1">magnitude</span> on the types <span class="KeyTerm1">list("complex")</span>. He shows this interaction to Alyssa P. Hacker, who says “The problem is that the complex-number selectors were never defined for <span class="KeyTerm1">"complex"</span> numbers, just for <span class="KeyTerm1">"polar"</span> and <span class="KeyTerm1">"rectangular"</span> numbers. All you have to do to make this work is add the following to the <span class="KeyTerm1">complex</span> package:”</p>
<p class="Sp-text-1"><a id="c2-para-2025"/>put("real_part", list("complex"), real_part);</p>
<p class="Sp-text-1"><a id="c2-para-2026"/>put("imag_part", list("complex"), imag_part);</p>
<p class="Sp-text-1"><a id="c2-para-2027"/>put("magnitude", list("complex"), magnitude);</p>
<p class="Sp-text-1"><a id="c2-para-2028"/>put("angle",      list("complex"), angle);</p>
<p class="paracontinue"><a id="c2-para-2029"/>Describe in detail why this works. As an example, trace through all the functions called in evaluating the expression <span class="KeyTerm1">magnitude(z)</span> where <span class="KeyTerm1">z</span> is the object shown in <a href="#c2-fig-0034">figure 2.24</a>. In particular, how many times is <span class="KeyTerm1">apply_generic</span> invoked? What function is dispatched to in each case?</p>
</section>
<section>
<h5><a id="c2-sec-0124"/><a id="c2-title-0125"/>Exercise 2.78</h5>
<p class="paraaftertitle"><a id="c2-para-2030"/>The internal functions in the <span class="KeyTerm1">javascript_number</span> package are essentially nothing more than calls to the primitive functions <span class="KeyTerm1">+</span>, <span class="KeyTerm1">-</span>, etc. It was not possible to use the primitives of the language directly because our type-tag system requires that each data object have a type attached to it. In fact, however, all JavaScript implementations do have a type system, which they use internally. Primitive predicates such as <span class="KeyTerm1">is_string</span> and <span class="KeyTerm1">is_number</span> determine whether data objects have particular types. Modify the definitions of <span class="KeyTerm1">type_tag</span>, <span class="KeyTerm1">contents</span>, and <span class="KeyTerm1">attach_tag</span> from section 2.4.2 so that our generic system takes advantage of JavaScript's internal type system. That is to say, the system should work as before except that ordinary numbers should be represented simply as JavaScript numbers rather than as pairs whose <span class="KeyTerm1">head</span> is the string <span class="KeyTerm1">"javascript_number"</span>.</p>
</section>
<section>
<h5><a id="c2-sec-0125"/><a id="c2-title-0126"/>Exercise 2.79</h5>
<p class="paraaftertitle"><a id="c2-para-2031"/>Define a generic equality predicate <span class="KeyTerm1">is_equal</span> that tests the equality of two numbers, and install it in the generic arithmetic package. This operation should work for ordinary numbers, rational numbers, and complex numbers.</p>
</section>
<section>
<h5><a id="c2-sec-0126"/><a id="c2-title-0127"/>Exercise 2.80</h5>
<p class="paraaftertitle"><a id="c2-para-2032"/>Define a generic predicate <span class="KeyTerm1">is_equal_to_zero</span> that tests if its argument is zero, and install it in the generic arithmetic package. This operation should work for ordinary numbers, rational numbers, and complex numbers.</p>
</section>
</section>
<section>
<h3><a id="c2-sec-0127"/><span>2.5.2</span> <a id="c2-title-0128"/>Combining Data of Different Types</h3>
<p class="paraaftertitle"><a id="c2-para-2033"/>We have seen how to define a unified arithmetic system that encompasses ordinary numbers, complex numbers, rational numbers, and any other type of number we might decide to invent, but we have ignored an important issue. The operations we have defined so far treat the different data types as being completely independent. Thus, there are separate packages for adding, say, two ordinary numbers, or two complex numbers. What we have not yet considered is the fact that it is meaningful to define operations that cross the type boundaries, such as the addition of a complex number to an ordinary number. We have gone to great pains to introduce barriers between parts of our programs so that they can be developed and understood separately. We would like to introduce the cross-type operations in some carefully controlled way, so that we can support them without seriously violating our module boundaries.</p>
<p><a id="c2-para-2034"/>One way to handle cross-type operations is to design a different function for each possible combination of types for which the operation is valid. For example, we could extend the complex-number package so that it provides a function for adding complex numbers to ordinary numbers and installs this in the table using the tag <span class="KeyTerm1">list("complex", "javascript_number")</span>:<a id="c2-fn-0046a"/><a href="#c2-fn-0046"><sup>46</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-2035"/><span class="KeyTerm2"><span class="KeyTerm2"><i>// to be included in the complex package</i></span></span></p>
<p class="Sp-text-1"><a id="c2-para-2036"/><b>function</b> add_complex_to_javascript_num(z, x) {</p>
<p class="Sp-text-1"><a id="c2-para-2037"/>    <b>return</b> make_complex_from_real_imag(real_part(z) + x, imag_part(z));</p>
<p class="Sp-text-1"><a id="c2-para-2038"/>}</p>
<p class="Sp-text-1"><a id="c2-para-2039"/>put("add", list("complex", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c2-para-2040"/>    (z, x) =&gt; tag(add_complex_to_javascript_num(z, x)));</p>
<p><a id="c2-para-2041"/>This technique works, but it is cumbersome. With such a system, the cost of introducing a new type is not just the construction of the package of functions for that type but also the construction and installation of the functions that implement the cross-type operations. This can easily be much more code than is needed to define the operations on the type itself. The method also undermines our ability to combine separate packages additively, or least to limit the extent to which the implementors of the individual packages need to take account of other packages. For instance, in the example above, it seems reasonable that handling mixed operations on complex numbers and ordinary numbers should be the responsibility of the complex-number package. Combining rational numbers and complex numbers, however, might be done by the complex package, by the rational package, or by some third package that uses operations extracted from these two packages. Formulating coherent policies on the division of responsibility among packages can be an overwhelming task in designing systems with many packages and many cross-type operations.</p>
<section>
<h5><a id="c2-sec-0128"/><a id="c2-title-0129"/>Coercion</h5>
<p class="paraaftertitle"><a id="c2-para-2043"/>In the general situation of completely unrelated operations acting on completely unrelated types, implementing explicit cross-type operations, cumbersome though it may be, is the best that one can hope for. Fortunately, we can usually do better by taking advantage of additional structure that may be latent in our type system. Often the different data types are not completely independent, and there may be ways by which objects of one type may be viewed as being of another type. This process is called <i>coercion</i>. For example, if we are asked to arithmetically combine an ordinary number with a complex number, we can view the ordinary number as a complex number whose imaginary part is zero. This transforms the problem to that of combining two complex numbers, which can be handled in the ordinary way by the complex-arithmetic package.</p>
<p><a id="c2-para-2044"/>In general, we can implement this idea by designing coercion functions that transform an object of one type into an equivalent object of another type. Here is a typical coercion function, which transforms a given ordinary number to a complex number with that real part and zero imaginary part:</p>
<p class="Sp-text-1"><a id="c2-para-2045"/><b>function</b> javascript_number_to_complex(n) {</p>
<p class="Sp-text-1"><a id="c2-para-2046"/>    <b>return</b> make_complex_from_real_imag(contents(n), 0);</p>
<p class="Sp-text-1"><a id="c2-para-2047"/>}</p>
<p class="paracontinue"><a id="c2-para-2048"/>We install these coercion functions in a special coercion table, indexed under the names of the two types:</p>
<p class="Sp-text-1"><a id="c2-para-2049"/>put_coercion("javascript_number", "complex",</p>
<p class="Sp-text-1"><a id="c2-para-2050"/>             javascript_number_to_complex);</p>
<p class="paracontinue"><a id="c2-para-2051"/>(We assume that there are <span class="KeyTerm1">put_coercion</span> and <span class="KeyTerm1">get_coercion</span> functions available for manipulating this table.) Generally some of the slots in the table will be empty, because it is not generally possible to coerce an arbitrary data object of each type into all other types. For example, there is no way to coerce an arbitrary complex number to an ordinary number, so there will be no general <span class="KeyTerm1">complex_to_javascript_number</span> function included in the table.</p>
<p><a id="c2-para-2052"/>Once the coercion table has been set up, we can handle coercion in a uniform manner by modifying the <span class="KeyTerm1">apply_generic</span> function of section 2.4.3. When asked to apply an operation, we first check whether the operation is defined for the arguments’ types, just as before. If so, we dispatch to the function found in the operation-andtype table. Otherwise, we try coercion. For simplicity, we consider only the case where there are two arguments.<a id="c2-fn-0047a"/><a href="#c2-fn-0047"><sup>47</sup></a> We check the coercion table to see if objects of the first type can be coerced to the second type. If so, we coerce the first argument and try the operation again. If objects of the first type cannot in general be coerced to the second type, we try the coercion the other way around to see if there is a way to coerce the second argument to the type of the first argument. Finally, if there is no known way to coerce either type to the other type, we give up. Here is the function:</p>
<p class="Sp-text-1"><a id="c2-para-2053"/><b>function</b> apply_generic(op, args) {</p>
<p class="Sp-text-1"><a id="c2-para-2054"/>    <b>const</b> type_tags = map(type_tag, args);</p>
<p class="Sp-text-1"><a id="c2-para-2055"/>    <b>const</b> fun = get(op, type_tags);</p>
<p class="Sp-text-1"><a id="c2-para-2056"/>    <b>if</b> (! is_undefined(fun)) {</p>
<p class="Sp-text-1"><a id="c2-para-2057"/>        <b>return</b> apply(fun, map(contents, args));</p>
<p class="Sp-text-1"><a id="c2-para-2058"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-2059"/>        <b>if</b> (length(args) === 2) {</p>
<p class="Sp-text-1"><a id="c2-para-2060"/>            <b>const</b> type1 = head(type_tags);</p>
<p class="Sp-text-1"><a id="c2-para-2061"/>            <b>const</b> type2 = head(tail(type_tags));</p>
<p class="Sp-text-1"><a id="c2-para-2062"/>            <b>const</b> a1 = head(args);</p>
<p class="Sp-text-1"><a id="c2-para-2063"/>            <b>const</b> a2 = head(tail(args));</p>
<p class="Sp-text-1"><a id="c2-para-2064"/>            <b>const</b> t1_to_t2 = get_coercion(type1, type2);</p>
<p class="Sp-text-1"><a id="c2-para-2065"/>            <b>const</b> t2_to_t1 = get_coercion(type2, type1);</p>
<p class="Sp-text-1"><a id="c2-para-2066"/>            <b>return</b> ! is_undefined(t1_to_t2)</p>
<p class="Sp-text-1"><a id="c2-para-2067"/>                   ? apply_generic(op, list(t1_to_t2(a1), a2))</p>
<p class="Sp-text-1"><a id="c2-para-2068"/>                   : ! is_undefined(t2_to_t1)</p>
<p class="Sp-text-1"><a id="c2-para-2069"/>                   ? apply_generic(op, list(a1, t2_to_t1(a2)))</p>
<p class="Sp-text-1"><a id="c2-para-2070"/>                   : error(list(op, type_tags),</p>
<p class="Sp-text-1"><a id="c2-para-2071"/>                           "no method for these types");</p>
<p class="Sp-text-1"><a id="c2-para-2072"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-2073"/>            <b>return</b> error(list(op, type_tags),</p>
<p class="Sp-text-1"><a id="c2-para-2074"/>                         "no method for these types");</p>
<p class="Sp-text-1"><a id="c2-para-2075"/>        }</p>
<p class="Sp-text-1"><a id="c2-para-2076"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-2077"/>}</p>
<p><a id="c2-para-2078"/>This coercion scheme has many advantages over the method of defining explicit cross-type operations, as outlined above. Although we still need to write coercion functions to relate the types (possibly <i>n</i><sup>2</sup> functions for a system with <i>n</i> types), we need to write only one function for each pair of types rather than a different function for each collection of types and each generic operation.<a id="c2-fn-0048a"/><a href="#c2-fn-0048"><sup>48</sup></a> What we are counting on here is the fact that the appropriate transformation between types depends only on the types themselves, not on the operation to be applied.</p>
<p><a id="c2-para-2079"/>On the other hand, there may be applications for which our coercion scheme is not general enough. Even when neither of the objects to be combined can be converted to the type of the other it may still be possible to perform the operation by converting both objects to a third type. In order to deal with such complexity and still preserve modularity in our programs, it is usually necessary to build systems that take advantage of still further structure in the relations among types, as we discuss next.</p>
</section>
<section>
<h5><a id="c2-sec-0129"/><a id="c2-title-0130"/>Hierarchies of types</h5>
<p class="paraaftertitle"><a id="c2-para-2080"/>The coercion scheme presented above relied on the existence of natural relations between pairs of types. Often there is more “global” structure in how the different types relate to each other. For instance, suppose we are building a generic arithmetic system to handle integers, rational numbers, real numbers, and complex numbers. In such a system, it is quite natural to regard an integer as a special kind of rational number, which is in turn a special kind of real number, which is in turn a special kind of complex number. What we actually have is a so-called <i>hierarchy of types</i>, in which, for example, integers are a <i>subtype</i> of rational numbers (i.e., any operation that can be applied to a rational number can automatically be applied to an integer). Conversely, we say that rational numbers form a <i>supertype</i> of integers. The particular hierarchy we have here is of a very simple kind, in which each type has at most one supertype and at most one subtype. Such a structure, called a <i>tower</i>, is illustrated in <a id="c2-fig-0035a"/><a href="#c2-fig-0035">figure 2.25</a>.</p>
<figure id="c2-fig-0035"><img alt="c2-fig-0025.jpg" src="../images/c2-fig-0025.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0035a">Figure 2.25</a></span> <a id="c2-para-2081"/>A tower of types.</p></figcaption></figure>
<p><a id="c2-para-2082"/>If we have a tower structure, then we can greatly simplify the problem of adding a new type to the hierarchy, for we need only specify how the new type is embedded in the next supertype above it and how it is the supertype of the type below it. For example, if we want to add an integer to a complex number, we need not explicitly define a special coercion function <span class="KeyTerm1">integer_to_complex</span>. Instead, we define how an integer can be transformed into a rational number, how a rational number is transformed into a real number, and how a real number is transformed into a complex number. We then allow the system to transform the integer into a complex number through these steps and then add the two complex numbers.</p>
<p><a id="c2-para-2083"/>We can redesign our <span class="KeyTerm1">apply_generic</span> function in the following way: For each type, we need to supply a <span class="KeyTerm1">raise</span> function, which “raises” objects of that type one level in the tower. Then when the system is required to operate on objects of different types it can successively raise the lower types until all the objects are at the same level in the tower. (Exercises 2.83 and 2.84 concern the details of implementing such a strategy.)</p>
<p><a id="c2-para-2084"/>Another advantage of a tower is that we can easily implement the notion that every type “inherits” all operations defined on a supertype. For instance, if we do not supply a special function for finding the real part of an integer, we should nevertheless expect that <span class="KeyTerm1">real_part</span> will be defined for integers by virtue of the fact that integers are a subtype of complex numbers. In a tower, we can arrange for this to happen in a uniform way by modifying <span class="KeyTerm1">apply_generic</span>. If the required operation is not directly defined for the type of the object given, we raise the object to its supertype and try again. We thus crawl up the tower, transforming our argument as we go, until we either find a level at which the desired operation can be performed or hit the top (in which case we give up).</p>
<p><a id="c2-para-2085"/>Yet another advantage of a tower over a more general hierarchy is that it gives us a simple way to “lower” a data object to the simplest representation. For example, if we add 2 + 3<i>i</i> to 4 – 3<i>i</i>, it would be nice to obtain the answer as the integer 6 rather than as the complex number 6 + 0<i>i</i>. Exercise 2.85 discusses a way to implement such a lowering operation. (The trick is that we need a general way to distinguish those objects that can be lowered, such as 6 + 0<i>i</i>, from those that cannot, such as 6 + 2<i>i</i>.)</p>
</section>
<section>
<h5><a id="c2-sec-0130"/><a id="c2-title-0131"/>Inadequacies of hierarchies</h5>
<p class="paraaftertitle"><a id="c2-para-2086"/>If the data types in our system can be naturally arranged in a tower, this greatly simplifies the problems of dealing with generic operations on different types, as we have seen. Unfortunately, this is usually not the case. <a id="c2-fig-0036a"/><a href="#c2-fig-0036">Figure 2.26</a> illustrates a more complex arrangement of mixed types, this one showing relations among different types of geometric figures. We see that, in general, a type may have more than one subtype. Triangles and quadrilaterals, for instance, are both subtypes of polygons. In addition, a type may have more than one supertype. For example, an isosceles right triangle may be regarded either as an isosceles triangle or as a right triangle. This multiple-supertypes issue is particularly thorny, since it means that there is no unique way to “raise” a type in the hierarchy. Finding the “correct” supertype in which to apply an operation to an object may involve considerable searching through the entire type network on the part of a function such as <span class="KeyTerm1">apply_generic</span>. Since there generally are multiple subtypes for a type, there is a similar problem in coercing a value “down” the type hierarchy. Dealing with large numbers of interrelated types while still preserving modularity in the design of large systems is very difficult, and is an area of much current research.<a id="c2-fn-0049a"/><a href="#c2-fn-0049"><sup>49</sup></a></p>
<figure id="c2-fig-0036"><img alt="c2-fig-0026.jpg" src="../images/c2-fig-0026.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0036a">Figure 2.26</a></span> <a id="c2-para-2087"/>Relations among types of geometric figures.</p></figcaption></figure>
</section>
<section>
<h5><a id="c2-sec-0131"/><a id="c2-title-0132"/>Exercise 2.81</h5>
<p class="paraaftertitle"><a id="c2-para-2088"/>Louis Reasoner has noticed that <span class="KeyTerm1">apply_generic</span> may try to coerce the arguments to each other's type even if they already have the same type. Therefore, he reasons, we need to put functions in the coercion table to “coerce” arguments of each type to their own type. For example, in addition to the <span class="KeyTerm1">javascript_number_to_complex</span> coercion shown above, he would do:</p>
<p class="Sp-text-1"><a id="c2-para-2089"/><b>function</b> javascript_number_to_javascript_number(n) { <b>return</b> n; }</p>
<p class="Sp-text-1"><a id="c2-para-2090"/><b>function</b> complex_to_complex(n) { <b>return</b> n; }</p>
<p class="Sp-text-1"><a id="c2-para-2091"/>put_coercion("javascript_number", "javascript_number",</p>
<p class="Sp-text-1"><a id="c2-para-2092"/>             javascript_number_to_javascript_number);</p>
<p class="Sp-text-1"><a id="c2-para-2093"/>put_coercion("complex", "complex", complex_to_complex);</p>
<ol class="BS_NumberListA">
<li><a id="c2-li-0058"/><span>a. </span>With Louis's coercion functions installed, what happens if <span class="KeyTerm1">apply_generic</span> is called with two arguments of type <span class="KeyTerm1">"complex"</span> or two arguments of type <span class="KeyTerm1">"javascript_ number"</span> for an operation that is not found in the table for those types? For example, assume that we've defined a generic exponentiation operation:
<p class="Sp-text-1"><a id="c2-para-2095"/><b>function</b> exp(x, y) {</p>
<p class="Sp-text-1"><a id="c2-para-2096"/>    <b>return</b> apply_generic("exp", list(x, y));</p>
<p class="Sp-text-1"><a id="c2-para-2097"/>}</p>
<p class="paracontinue"><a id="c2-para-2098"/>and have put a function for exponentiation in the JavaScript-number package but not in any other package:</p>
<p class="Sp-text-1"><a id="c2-para-2099"/><span class="KeyTerm2"><i>// following added to JavaScript-number package</i></span></p>
<p class="Sp-text-1"><a id="c2-para-2100"/>put("exp", list("javascript_number", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c2-para-2101"/>    (x, y) =&gt; tag(math_exp(x, y))); <span class="KeyTerm2">// using primitive</span> math_exp</p>
<p class="paracontinue"><a id="c2-para-2102"/>What happens if we call <span class="KeyTerm1">exp</span> with two complex numbers as arguments?</p></li>
<li><a id="c2-li-0059"/><span>b. </span>Is Louis correct that something had to be done about coercion with arguments of the same type, or does <span class="KeyTerm1">apply_generic</span> work correctly as is?</li>
<li><a id="c2-li-0060"/><span>c. </span>Modify <span class="KeyTerm1">apply_generic</span> so that it doesn't try coercion if the two arguments have the same type.</li>
</ol>
</section>
<section>
<h5><a id="c2-sec-0132"/><a id="c2-title-0133"/>Exercise 2.82</h5>
<p class="paraaftertitle"><a id="c2-para-2105"/>Show how to generalize <span class="KeyTerm1">apply_generic</span> to handle coercion in the general case of multiple arguments. One strategy is to attempt to coerce all the arguments to the type of the first argument, then to the type of the second argument, and so on. Give an example of a situation where this strategy (and likewise the two-argument version given above) is not sufficiently general. (Hint: Consider the case where there are some suitable mixed-type operations present in the table that will not be tried.)</p>
</section>
<section>
<h5><a id="c2-sec-0133"/><a id="c2-title-0134"/>Exercise 2.83</h5>
<p class="paraaftertitle"><a id="c2-para-2106"/>Suppose you are designing a generic arithmetic system for dealing with the tower of types shown in <a href="#c2-fig-0035">figure 2.25</a>: integer, rational, real, complex. For each type (except complex), design a function that raises objects of that type one level in the tower. Show how to install a generic <span class="KeyTerm1">raise</span> operation that will work for each type (except complex).</p>
</section>
<section>
<h5><a id="c2-sec-0134"/><a id="c2-title-0135"/>Exercise 2.84</h5>
<p class="paraaftertitle"><a id="c2-para-2107"/>Using the <span class="KeyTerm1">raise</span> operation of exercise 2.83, modify the <span class="KeyTerm1">apply_generic</span> function so that it coerces its arguments to have the same type by the method of successive raising, as discussed in this section. You will need to devise a way to test which of two types is higher in the tower. Do this in a manner that is “compatible” with the rest of the system and will not lead to problems in adding new levels to the tower.</p>
</section>
<section>
<h5><a id="c2-sec-0135"/><a id="c2-title-0136"/>Exercise 2.85</h5>
<p class="paraaftertitle"><a id="c2-para-2108"/>This section mentioned a method for “simplifying” a data object by lowering it in the tower of types as far as possible. Design a function <span class="KeyTerm1">drop</span> that accomplishes this for the tower described in exercise 2.83. The key is to decide, in some general way, whether an object can be lowered. For example, the complex number 1.5 + 0<i>i</i> can be lowered as far as <span class="KeyTerm1">"real"</span>, the complex number 1 + 0<i>i</i> can be lowered as far as <span class="KeyTerm1">"integer"</span>, and the complex number 2 + 3<i>i</i> cannot be lowered at all. Here is a plan for determining whether an object can be lowered: Begin by defining a generic operation <span class="KeyTerm1">project</span> that “pushes” an object down in the tower. For example, projecting a complex number would involve throwing away the imaginary part. Then a number can be dropped if, when we <span class="KeyTerm1">project</span> it and <span class="KeyTerm1">raise</span> the result back to the type we started with, we end up with something equal to what we started with. Show how to implement this idea in detail, by writing a <span class="KeyTerm1">drop</span> function that drops an object as far as possible. You will need to design the various projection operations<a id="c2-fn-0050a"/><a href="#c2-fn-0050"><sup>50</sup></a> and install <span class="KeyTerm1">project</span> as a generic operation in the system. You will also need to make use of a generic equality predicate, such as described in exercise 2.79. Finally, use <span class="KeyTerm1">drop</span> to rewrite <span class="KeyTerm1">apply_generic</span> from exercise 2.84 so that it “simplifies” its answers.</p>
</section>
<section>
<h5><a id="c2-sec-0136"/><a id="c2-title-0137"/>Exercise 2.86</h5>
<p class="paraaftertitle"><a id="c2-para-2109"/>Suppose we want to handle complex numbers whose real parts, imaginary parts, magnitudes, and angles can be either ordinary numbers, rational numbers, or other numbers we might wish to add to the system. Describe and implement the changes to the system needed to accommodate this. You will have to define operations such as <span class="KeyTerm1">sine</span> and <span class="KeyTerm1">cosine</span> that are generic over ordinary numbers and rational numbers.</p>
</section>
</section>
<section>
<h3><a id="c2-sec-0137"/><span>2.5.3</span> <a id="c2-title-0138"/>Example: Symbolic Algebra</h3>
<p class="paraaftertitle"><a id="c2-para-2110"/>The manipulation of symbolic algebraic expressions is a complex process that illustrates many of the hardest problems that occur in the design of large-scale systems. An algebraic expression, in general, can be viewed as a hierarchical structure, a tree of operators applied to operands. We can construct algebraic expressions by starting with a set of primitive objects, such as constants and variables, and combining these by means of algebraic operators, such as addition and multiplication. As in other languages, we form abstractions that enable us to refer to compound objects in simple terms. Typical abstractions in symbolic algebra are ideas such as linear combination, polynomial, rational function, or trigonometric function. We can regard these as compound “types,” which are often useful for directing the processing of expressions. For example, we could describe the expression</p>
<p class="Sp-text-2"><a id="c2-para-2111"/><i>x</i><sup>2</sup> sin(<i>y</i><sup>2</sup> + 1) + <i>x</i> cos 2<i>y</i> + cos(<i>y</i><sup>3</sup> – 2<i>y</i><sup>2</sup>)</p>
<p class="paracontinue"><a id="c2-para-2112"/>as a polynomial in <i>x</i> with coefficients that are trigonometric functions of polynomials in <i>y</i> whose coefficients are integers.</p>
<p><a id="c2-para-2113"/>We will not attempt to develop a complete algebraic-manipulation system here. Such systems are exceedingly complex programs, embodying deep algebraic knowledge and elegant algorithms. What we will do is look at a simple but important part of algebraic manipulation: the arithmetic of polynomials. We will illustrate the kinds of decisions the designer of such a system faces, and how to apply the ideas of abstract data and generic operations to help organize this effort.</p>
<section>
<h5><a id="c2-sec-0138"/><a id="c2-title-0139"/>Arithmetic on polynomials</h5>
<p class="paraaftertitle"><a id="c2-para-2114"/>Our first task in designing a system for performing arithmetic on polynomials is to decide just what a polynomial is. Polynomials are normally defined relative to certain variables (the <i>indeterminates</i> of the polynomial). For simplicity, we will restrict ourselves to polynomials having just one indeterminate <i>(univariate polynomials</i>).<a id="c2-fn-0051a"/><a href="#c2-fn-0051"><sup>51</sup></a> We will define a polynomial to be a sum of terms, each of which is either a coefficient, a power of the indeterminate, or a product of a coefficient and a power of the indeterminate. A coefficient is defined as an algebraic expression that is not dependent upon the indeterminate of the polynomial. For example,</p>
<p class="Sp-text-2"><a id="c2-para-2115"/>5<i>x</i><sup>2</sup> + 3<i>x</i> + 7</p>
<p class="paracontinue"><a id="c2-para-2116"/>is a simple polynomial in <i>x</i>, and </p>
<p class="Sp-text-2"><a id="c2-para-2117"/>(<i>y</i><sup>2</sup> + 1)<i>x</i><sup>3</sup> + (2<i>y</i>)<i>x</i> + 1</p>
<p class="paracontinue"><a id="c2-para-2118"/>is a polynomial in <i>x</i> whose coefficients are polynomials in <i>y</i>.</p>
<p><a id="c2-para-2119"/>Already we are skirting some thorny issues. Is the first of these polynomials the same as the polynomial 5<i>y</i><sup>2</sup> + 3<i>y</i> + 7, or not? A reasonable answer might be “yes, if we are considering a polynomial purely as a mathematical function, but no, if we are considering a polynomial to be a syntactic form.” The second polynomial is algebraically equivalent to a polynomial in <i>y</i> whose coefficients are polynomials in <i>x</i>. Should our system recognize this, or not? Furthermore, there are other ways to represent a polynomial—for example, as a product of factors, or (for a univariate polynomial) as the set of roots, or as a listing of the values of the polynomial at a specified set of points.<a id="c2-fn-0052a"/><a href="#c2-fn-0052"><sup>52</sup></a> We can finesse these questions by deciding that in our algebraic-manipulation system a “polynomial” will be a particular syntactic form, not its underlying mathematical meaning.</p>
<p><a id="c2-para-2120"/>Now we must consider how to go about doing arithmetic on polynomials. In this simple system, we will consider only addition and multiplication. Moreover, we will insist that two polynomials to be combined must have the same indeterminate.</p>
<p><a id="c2-para-2121"/>We will approach the design of our system by following the familiar discipline of data abstraction. We will represent polynomials using a data structure called a <i>poly</i>, which consists of a variable and a collection of terms. We assume that we have selectors <span class="KeyTerm1">variable</span> and <span class="KeyTerm1">term_list</span> that extract those parts from a poly and a constructor <span class="KeyTerm1">make_poly</span> that assembles a poly from a given variable and a term list. A variable will be just a string, so we can use the <span class="KeyTerm1">is_same_variable</span> function of section 2.3.2 to compare variables. The following functions define addition and multiplication of polys:</p>
<p class="Sp-text-1"><a id="c2-para-2122"/><b>function</b> add_poly(p1, p2) {</p>
<p class="Sp-text-1"><a id="c2-para-2123"/>    <b>return</b> is_same_variable(variable(p1), variable(p2))</p>
<p class="Sp-text-1"><a id="c2-para-2124"/>           ? make_poly(variable(p1),</p>
<p class="Sp-text-1"><a id="c2-para-2125"/>                       add_terms(term_list(p1), term_list(p2)))</p>
<p class="Sp-text-1"><a id="c2-para-2126"/>           : error(list(p1, p2), "polys not in same var – add_poly");</p>
<p class="Sp-text-1"><a id="c2-para-2127"/>}</p>
<p class="Sp-text-1"><a id="c2-para-2128"/><b>function</b> mul_poly(p1, p2) {</p>
<p class="Sp-text-1"><a id="c2-para-2129"/>    <b>return</b> is_same_variable(variable(p1), variable(p2))</p>
<p class="Sp-text-1"><a id="c2-para-2130"/>           ? make_poly(variable(p1),</p>
<p class="Sp-text-1"><a id="c2-para-2131"/>                       mul_terms(term_list(p1), term_list(p2)))</p>
<p class="Sp-text-1"><a id="c2-para-2132"/>           : error(list(p1, p2), "polys not in same var – mul_poly");</p>
<p class="Sp-text-1"><a id="c2-para-2133"/>}</p>
<p><a id="c2-para-2134"/>To incorporate polynomials into our generic arithmetic system, we need to supply them with type tags. We'll use the tag <span class="KeyTerm1">"polynomial"</span>, and install appropriate operations on tagged polynomials in the operation table. We'll embed all our code in an installation function for the polynomial package, similar to the installation functions in section 2.5.1:</p>
<p class="Sp-text-1"><a id="c2-para-2135"/><b>function</b> install_polynomial_package() {</p>
<p class="Sp-text-1"><a id="c2-para-2136"/>    <span class="KeyTerm2"><i>// internal functions</i></span></p>
<p class="Sp-text-1"><a id="c2-para-2137"/>    <span class="KeyTerm2"><i>// representation of poly</i></span></p>
<p class="Sp-text-1"><a id="c2-para-2138"/>    <b>function</b> make_poly(variable, term_list) {</p>
<p class="Sp-text-1"><a id="c2-para-2139"/>        <b>return</b> pair(variable, term_list);</p>
<p class="Sp-text-1"><a id="c2-para-2140"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-2141"/>    <b>function</b> variable(p) { <b>return</b> head(p); }</p>
<p class="Sp-text-1"><a id="c2-para-2142"/>    <b>function</b> term_list(p) { <b>return</b> tail(p); }</p>
<p class="Sp-text-1"><a id="c2-para-2143"/>    〈<span class="KeyTerm2"><i>functions</i></span> is_same_variable <span class="KeyTerm2"><i>and</i></span> is_variable <span class="KeyTerm2"><i>from</i> <i>section 2.3.2</i></span>〉    </p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-2144"/>    <span class="KeyTerm2"><i>// representation of terms and term lists</i></span></p>
<p class="Sp-text-1"><a id="c2-para-2145"/>    〈<span class="KeyTerm2"><i>functions</i></span> adjoin_term…coeff <span class="KeyTerm2"><i>from text below</i></span>〉</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-2146"/>    <b>function</b> add_poly(p1, p2) { … }</p>
<p class="Sp-text-1"><a id="c2-para-2147"/>    〈<span class="KeyTerm2"><i>functions used by</i></span> add_poly〉</p>
<p class="Sp-text-1"><a id="c2-para-2148"/>    <b>function</b> mul_poly(p1, p2) { … }</p>
<p class="Sp-text-1"><a id="c2-para-2149"/>    〈<span class="KeyTerm2"><i>functions used by</i></span> mul_poly〉    </p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-2150"/>    <span class="KeyTerm2"><i>// interface to rest of the system</i></span></p>
<p class="Sp-text-1"><a id="c2-para-2151"/>    <b>function</b> tag(p) { <b>return</b> attach_tag("polynomial", p); }</p>
<p class="Sp-text-1"><a id="c2-para-2152"/>    put("add", list("polynomial", "polynomial"),</p>
<p class="Sp-text-1"><a id="c2-para-2153"/>        (p1, p2) =&gt; tag(add_poly(p1, p2)));</p>
<p class="Sp-text-1"><a id="c2-para-2154"/>    put("mul", list("polynomial", "polynomial"),</p>
<p class="Sp-text-1"><a id="c2-para-2155"/>        (p1, p2) =&gt; tag(mul_poly(p1, p2)));</p>
<p class="Sp-text-1"><a id="c2-para-2156"/>    put("make", "polynomial",</p>
<p class="Sp-text-1"><a id="c2-para-2157"/>        (variable, terms) =&gt; tag(make_poly(variable, terms)));</p>
<p class="Sp-text-1"><a id="c2-para-2158"/>    <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c2-para-2159"/>}</p>
<p><a id="c2-para-2160"/>Polynomial addition is performed termwise. Terms of the same order (i.e., with the same power of the indeterminate) must be combined. This is done by forming a new term of the same order whose coefficient is the sum of the coefficients of the addends. Terms in one addend for which there are no terms of the same order in the other addend are simply accumulated into the sum polynomial being constructed.</p>
<p><a id="c2-para-2161"/>In order to manipulate term lists, we will assume that we have a constructor <span class="KeyTerm1">the_empty_termlist</span> that returns an empty term list and a constructor <span class="KeyTerm1">adjoin_ term</span> that adjoins a new term to a term list. We will also assume that we have a predicate <span class="KeyTerm1">is_empty_termlist</span> that tells if a given term list is empty, a selector <span class="KeyTerm1">first_term</span> that extracts the highest-order term from a term list, and a selector <span class="KeyTerm1">rest_terms</span> that returns all but the highest-order term. To manipulate terms, we will suppose that we have a constructor <span class="KeyTerm1">make_term</span> that constructs a term with given order and coefficient, and selectors <span class="KeyTerm1">order</span> and <span class="KeyTerm1">coeff</span> that return, respectively, the order and the coefficient of the term. These operations allow us to consider both terms and term lists as data abstractions, whose concrete representations we can worry about separately.</p>
<p><a id="c2-para-2162"/>Here is the function that constructs the term list for the sum of two polynomials;<a id="c2-fn-0053a"/><a href="#c2-fn-0053"><sup>53</sup></a> note that we slightly extend the syntax of conditional statements described in section 1.3.2 by admitting another conditional statement in place of the block following <span class="KeyTerm1"><b>else</b></span>:</p>
<p class="Sp-text-1"><a id="c2-para-2163"/><b>function</b> add_terms(L1, L2) {</p>
<p class="Sp-text-1"><a id="c2-para-2164"/>    <b>if</b> (is_empty_termlist(L1)) {</p>
<p class="Sp-text-1"><a id="c2-para-2165"/>        <b>return</b> L2;</p>
<p class="Sp-text-1"><a id="c2-para-2166"/>    } <b>else if</b> (is_empty_termlist(L2)) {</p>
<p class="Sp-text-1"><a id="c2-para-2167"/>        <b>return</b> L1;</p>
<p class="Sp-text-1"><a id="c2-para-2168"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-2169"/>        <b>const</b> t1 = first_term(L1);</p>
<p class="Sp-text-1"><a id="c2-para-2170"/>        <b>const</b> t2 = first_term(L2);</p>
<p class="Sp-text-1"><a id="c2-para-2171"/>        <b>return</b> order(t1) &gt; order(t2)</p>
<p class="Sp-text-1"><a id="c2-para-2172"/>               ? adjoin_term(t1, add_terms(rest_terms(L1), L2))</p>
<p class="Sp-text-1"><a id="c2-para-2173"/>               : order(t1) &lt; order(t2)</p>
<p class="Sp-text-1"><a id="c2-para-2174"/>               ? adjoin_term(t2, add_terms(L1, rest_terms(L2)))</p>
<p class="Sp-text-1"><a id="c2-para-2175"/>               : adjoin_term(make_term(order(t1),</p>
<p class="Sp-text-1"><a id="c2-para-2176"/>                                       add(coeff(t1), coeff(t2))),</p>
<p class="Sp-text-1"><a id="c2-para-2177"/>                             add_terms(rest_terms(L1),</p>
<p class="Sp-text-1"><a id="c2-para-2178"/>                                       rest_terms(L2)));</p>
<p class="Sp-text-1"><a id="c2-para-2179"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-2180"/>}</p>
<p class="paracontinue"><a id="c2-para-2181"/>The most important point to note here is that we used the generic addition function <span class="KeyTerm1">add</span> to add together the coefficients of the terms being combined. This has powerful consequences, as we will see below.</p>
<p><a id="c2-para-2182"/>In order to multiply two term lists, we multiply each term of the first list by all the terms of the other list, repeatedly using <span class="KeyTerm1">mul_term_by_all_terms</span>, which multiplies a given term by all terms in a given term list. The resulting term lists (one for each term of the first list) are accumulated into a sum. Multiplying two terms forms a term whose order is the sum of the orders of the factors and whose coefficient is the product of the coefficients of the factors:</p>
<p class="Sp-text-1"><a id="c2-para-2183"/><b>function</b> mul_terms(L1, L2) {</p>
<p class="Sp-text-1"><a id="c2-para-2184"/>    <b>return</b> is_empty_termlist(L1)</p>
<p class="Sp-text-1"><a id="c2-para-2185"/>          ? the_empty_termlist</p>
<p class="Sp-text-1"><a id="c2-para-2186"/>          : add_terms(mul_term_by_all_terms(</p>
<p class="Sp-text-1"><a id="c2-para-2187"/>                                first_term(L1), L2),</p>
<p class="Sp-text-1"><a id="c2-para-2188"/>                      mul_terms(rest_terms(L1), L2));</p>
<p class="Sp-text-1"><a id="c2-para-2189"/>}</p>
<p class="Sp-text-1"><a id="c2-para-2190"/><b>function</b> mul_term_by_all_terms(t1, L) {</p>
<p class="Sp-text-1"><a id="c2-para-2191"/>    <b>if</b> (is_empty_termlist(L)) {</p>
<p class="Sp-text-1"><a id="c2-para-2192"/>        <b>return</b> the_empty_termlist;</p>
<p class="Sp-text-1"><a id="c2-para-2193"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-2194"/>        <b>const</b> t2 = first_term(L);</p>
<p class="Sp-text-1"><a id="c2-para-2195"/>        <b>return</b> adjoin_term(</p>
<p class="Sp-text-1"><a id="c2-para-2196"/>                   make_term(order(t1) + order(t2),</p>
<p class="Sp-text-1"><a id="c2-para-2197"/>                             mul(coeff(t1), coeff(t2))),</p>
<p class="Sp-text-1"><a id="c2-para-2198"/>                   mul_term_by_all_terms(t1, rest_terms(L)));</p>
<p class="Sp-text-1"><a id="c2-para-2199"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-2200"/>}</p>
<p><a id="c2-para-2201"/>This is really all there is to polynomial addition and multiplication. Notice that, since we operate on terms using the generic functions <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span>, our polynomial package is automatically able to handle any type of coefficient that is known about by the generic arithmetic package. If we include a coercion mechanism such as one of those discussed in section 2.5.2, then we also are automatically able to handle operations on polynomials of different coefficient types, such as</p>
<p><a id="c2-para-2202"/></p>
<figure id="c2-fig-0037"><img alt="c2-fig-5012.jpg" src="../images/c2-fig-5012.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p><a id="c2-para-2203"/>Because we installed the polynomial addition and multiplication functions <span class="KeyTerm1">add_ poly</span> and <span class="KeyTerm1">mul_poly</span> in the generic arithmetic system as the <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span> operations for type <span class="KeyTerm1">polynomial</span>, our system is also automatically able to handle polynomial operations such as</p>
<p class="Sp-text-2"><a id="c2-para-2204"/>(<i>y</i> + 1)<i>x</i><sup>2</sup> + (<i>y</i><sup>2</sup> + 1)<i>x</i> + (<i>y</i> – 1) · (<i>y</i> – 2)<i>x</i> + (<i>y</i><sup>3</sup> + 7)</p>
<p class="paracontinue"><a id="c2-para-2205"/>The reason is that when the system tries to combine coefficients, it will dispatch through <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span>. Since the coefficients are themselves polynomials (in <i>y</i>), these will be combined using <span class="KeyTerm1">add_poly</span> and <span class="KeyTerm1">mul_poly</span>. The result is a kind of “datadirected recursion” in which, for example, a call to <span class="KeyTerm1">mul_poly</span> will result in recursive calls to <span class="KeyTerm1">mul_poly</span> in order to multiply the coefficients. If the coefficients of the coefficients were themselves polynomials (as might be used to represent polynomials in three variables), the data direction would ensure that the system would follow through another level of recursive calls, and so on through as many levels as the structure of the data dictates.<a id="c2-fn-0054a"/><a href="#c2-fn-0054"><sup>54</sup></a></p>
</section>
<section>
<h5><a id="c2-sec-0139"/><a id="c2-title-0140"/>Representing term lists</h5>
<p class="paraaftertitle"><a id="c2-para-2206"/>Finally, we must confront the job of implementing a good representation for term lists. A term list is, in effect, a set of coefficients keyed by the order of the term. Hence, any of the methods for representing sets, as discussed in section 2.3.3, can be applied to this task. On the other hand, our functions <span class="KeyTerm1">add_terms</span> and <span class="KeyTerm1">mul_terms</span> always access term lists sequentially from highest to lowest order. Thus, we will use some kind of ordered list representation.</p>
<p><a id="c2-para-2207"/>How should we structure the list that represents a term list? One consideration is the “density” of the polynomials we intend to manipulate. A polynomial is said to be <i>dense</i> if it has nonzero coefficients in terms of most orders. If it has many zero terms it is said to be <i>sparse</i>. For example,</p>
<p class="Sp-text-2"><a id="c2-para-2208"/><i>A</i>:  <i>x</i><sup>5</sup> + 2<i>x</i><sup>4</sup> + 3<i>x</i><sup>2</sup> – 2<i>x</i> – 5</p>
<p class="paracontinue"><a id="c2-para-2209"/>is a dense polynomial, whereas</p>
<p class="Sp-text-2"><a id="c2-para-2210"/><i>B</i>:  <i>x</i><sup>100</sup> + 2<i>x</i><sup>2</sup> + 1</p>
<p class="paracontinue"><a id="c2-para-2211"/>is sparse.</p>
<p><a id="c2-para-2212"/>The term list of a dense polynomial is most efficiently represented as a list of the coefficients. For example, the polynomial <i>A</i> above would be nicely represented as <span class="KeyTerm1">list(1, 2, 0, 3, -2, -5)</span>. The order of a term in this representation is the length of the sublist beginning with that term's coefficient, decremented by 1.<a id="c2-fn-0055a"/><a href="#c2-fn-0055"><sup>55</sup></a> This would be a terrible representation for a sparse polynomial such as <i>B</i>: There would be a giant list of zeros punctuated by a few lonely nonzero terms. A more reasonable representation of the term list of a sparse polynomial is as a list of the nonzero terms, where each term is a list containing the order of the term and the coefficient for that order. In such a scheme, polynomial <i>B</i> is efficiently represented as <span class="KeyTerm1">list(list(100, 1), list(2, 2), list(0, 1))</span>. As most polynomial manipulations are performed on sparse polynomials, we will use this method. We will assume that term lists are represented as lists of terms, arranged from highest-order to lowest-order term. Once we have made this decision, implementing the selectors and constructors for terms and term lists is straightforward:<a id="c2-fn-0056a"/><a href="#c2-fn-0056"><sup>56</sup></a></p>
<p class="Sp-text-1"><a id="c2-para-2213"/><b>function</b> adjoin_term(term, term_list) {</p>
<p class="Sp-text-1"><a id="c2-para-2214"/>    <b>return</b> is_equal_to_zero(coeff(term))</p>
<p class="Sp-text-1"><a id="c2-para-2215"/>           ? term_list</p>
<p class="Sp-text-1"><a id="c2-para-2216"/>           : pair(term, term_list);</p>
<p class="Sp-text-1"><a id="c2-para-2217"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-2218"/><b>const</b> the_empty_termlist = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c2-para-2219"/><b>function</b> first_term(term_list) { <b>return</b> head(term_list); }</p>
<p class="Sp-text-1"><a id="c2-para-2220"/><b>function</b> rest_terms(term_list) { <b>return</b> tail(term_list); }</p>
<p class="Sp-text-1"><a id="c2-para-2221"/><b>function</b> is_empty_termlist(term_list) { <b>return</b> is_null(term_list); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-2222"/><b>function</b> make_term(order, coeff) { <b>return</b> list(order, coeff); }</p>
<p class="Sp-text-1"><a id="c2-para-2223"/><b>function</b> order(term) { <b>return</b> head(term); }</p>
<p class="Sp-text-1"><a id="c2-para-2224"/><b>function</b> coeff(term) { <b>return</b> head(tail(term)); }</p>
<p class="paracontinue"><a id="c2-para-2225"/>where <span class="KeyTerm1">is_equal_to_zero</span> is as defined in exercise 2.80. (See also exercise 2.87 below.)</p>
<p><a id="c2-para-2226"/>Users of the polynomial package will create (tagged) polynomials by means of the function:</p>
<p class="Sp-text-1"><a id="c2-para-2227"/><b>function</b> make_polynomial(variable, terms) {</p>
<p class="Sp-text-1"><a id="c2-para-2228"/>    <b>return</b> get("make", "polynomial")(variable, terms);</p>
<p class="Sp-text-1"><a id="c2-para-2229"/>}</p>
</section>
<section>
<h5><a id="c2-sec-0140"/><a id="c2-title-0141"/>Exercise 2.87</h5>
<p class="paraaftertitle"><a id="c2-para-2230"/>Install <span class="KeyTerm1">is_equal_to_zero</span> for polynomials in the generic arithmetic package. This will allow <span class="KeyTerm1">adjoin_term</span> to work for polynomials with coefficients that are themselves polynomials.</p>
</section>
<section>
<h5><a id="c2-sec-0141"/><a id="c2-title-0142"/>Exercise 2.88</h5>
<p class="paraaftertitle"><a id="c2-para-2231"/>Extend the polynomial system to include subtraction of polynomials. (Hint: You may find it helpful to define a generic negation operation.)</p>
</section>
<section>
<h5><a id="c2-sec-0142"/><a id="c2-title-0143"/>Exercise 2.89</h5>
<p class="paraaftertitle"><a id="c2-para-2232"/>Declare functions that implement the term-list representation described above as appropriate for dense polynomials.</p>
</section>
<section>
<h5><a id="c2-sec-0143"/><a id="c2-title-0144"/>Exercise 2.90</h5>
<p class="paraaftertitle"><a id="c2-para-2233"/>Suppose we want to have a polynomial system that is efficient for both sparse and dense polynomials. One way to do this is to allow both kinds of term-list representations in our system. The situation is analogous to the complex-number example of section 2.4, where we allowed both rectangular and polar representations. To do this we must distinguish different types of term lists and make the operations on term lists generic. Redesign the polynomial system to implement this generalization. This is a major effort, not a local change.</p>
</section>
<section>
<h5><a id="c2-sec-0144"/><a id="c2-title-0145"/>Exercise 2.91</h5>
<p class="paraaftertitle"><a id="c2-para-2234"/>A univariate polynomial can be divided by another one to produce a polynomial quotient and a polynomial remainder. For example,</p>
<p class="Sp-text-2"><a id="c2-para-2235"/><img alt="c2-fig-5013.jpg" src="../images/c2-fig-5013.jpg"/> = <i>x</i><sup>3</sup> + <i>x</i>, remainder <i>x</i> – 1</p>
<p class="paracontinue"><a id="c2-para-2236"/>Division can be performed via long division. That is, divide the highest-order term of the dividend by the highest-order term of the divisor. The result is the first term of the quotient. Next, multiply the result by the divisor, subtract that from the dividend, and produce the rest of the answer by recursively dividing the difference by the divisor. Stop when the order of the divisor exceeds the order of the dividend and declare the dividend to be the remainder. Also, if the dividend ever becomes zero, return zero as both quotient and remainder.</p>
<p><a id="c2-para-2237"/>We can design a <span class="KeyTerm1">div_poly</span> function on the model of <span class="KeyTerm1">add_poly</span> and <span class="KeyTerm1">mul_poly</span>. The function checks to see if the two polys have the same variable. If so, <span class="KeyTerm1">div_poly</span> strips off the variable and passes the problem to <span class="KeyTerm1">div_terms</span>, which performs the division operation on term lists. The function <span class="KeyTerm1">div_poly</span> finally reattaches the variable to the result supplied by <span class="KeyTerm1">div_terms</span>. It is convenient to design <span class="KeyTerm1">div_terms</span> to compute both the quotient and the remainder of a division. The function <span class="KeyTerm1">div_terms</span> can take two term lists as arguments and return a list of the quotient term list and the remainder term list.</p>
<p><a id="c2-para-2238"/>Complete the following definition of <span class="KeyTerm1">div_terms</span> by filling in the missing parts. Use this to implement <span class="KeyTerm1">div_poly</span>, which takes two polys as arguments and returns a list of the quotient and remainder polys.</p>
<p class="Sp-text-1"><a id="c2-para-2239"/><b>function</b> div_terms(L1, L2) {</p>
<p class="Sp-text-1"><a id="c2-para-2240"/>    <b>if</b> (is_empty_termlist(L1)) {</p>
<p class="Sp-text-1"><a id="c2-para-2241"/>        <b>return</b> list(the_empty_termlist, the_empty_termlist);</p>
<p class="Sp-text-1"><a id="c2-para-2242"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-2243"/>        <b>const</b> t1 = first_term(L1);</p>
<p class="Sp-text-1"><a id="c2-para-2244"/>        <b>const</b> t2 = first_term(L2);</p>
<p class="Sp-text-1"><a id="c2-para-2245"/>        <b>if</b> (order(t2) &gt; order(t1)) {</p>
<p class="Sp-text-1"><a id="c2-para-2246"/>            <b>return</b> list(the_empty_termlist, L1);</p>
<p class="Sp-text-1"><a id="c2-para-2247"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c2-para-2248"/>            <b>const</b> new_c = div(coeff(t1), coeff(t2));</p>
<p class="Sp-text-1"><a id="c2-para-2249"/>            <b>const</b> new_o = order(t1) - order(t2);</p>
<p class="Sp-text-1"><a id="c2-para-2250"/>            <b>const</b> rest_of_result = 〈<span class="KeyTerm2"><i>compute rest of result recursively</i></span>〉;</p>
<p class="Sp-text-1"><a id="c2-para-2251"/>            〈<span class="KeyTerm2"><i>form and return complete result</i></span>〉</p>
<p class="Sp-text-1"><a id="c2-para-2252"/>        <sub>}</sub></p>
<p class="Sp-text-1"><a id="c2-para-2253"/>    }</p>
<p class="Sp-text-1"><a id="c2-para-2254"/>}</p>
</section>
<section>
<h5><a id="c2-sec-0145"/><a id="c2-title-0146"/>Hierarchies of types in symbolic algebra</h5>
<p class="paraaftertitle"><a id="c2-para-2255"/>Our polynomial system illustrates how objects of one type (polynomials) may in fact be complex objects that have objects of many different types as parts. This poses no real difficulty in defining generic operations. We need only install appropriate generic operations for performing the necessary manipulations of the parts of the compound types. In fact, we saw that polynomials form a kind of “recursive data abstraction,” in that parts of a polynomial may themselves be polynomials. Our generic operations and our data-directed programming style can handle this complication without much trouble.</p>
<p><a id="c2-para-2256"/>On the other hand, polynomial algebra is a system for which the data types cannot be naturally arranged in a tower. For instance, it is possible to have polynomials in <i>x</i> whose coefficients are polynomials in <i>y</i>. It is also possible to have polynomials in <i>y</i> whose coefficients are polynomials in <i>x</i>. Neither of these types is “above” the other in any natural way, yet it is often necessary to add together elements from each set. There are several ways to do this. One possibility is to convert one polynomial to the type of the other by expanding and rearranging terms so that both polynomials have the same principal variable. One can impose a towerlike structure on this by ordering the variables and thus always converting any polynomial to a “canonical form” with the highest-priority variable dominant and the lower-priority variables buried in the coefficients. This strategy works fairly well, except that the conversion may expand a polynomial unnecessarily, making it hard to read and perhaps less efficient to work with. The tower strategy is certainly not natural for this domain or for any domain where the user can invent new types dynamically using old types in various combining forms, such as trigonometric functions, power series, and integrals.</p>
<p><a id="c2-para-2257"/>It should not be surprising that controlling coercion is a serious problem in the design of large-scale algebraic-manipulation systems. Much of the complexity of such systems is concerned with relationships among diverse types. Indeed, it is fair to say that we do not yet completely understand coercion. In fact, we do not yet completely understand the concept of a data type. Nevertheless, what we know provides us with powerful structuring and modularity principles to support the design of large systems.</p>
</section>
<section>
<h5><a id="c2-sec-0146"/><a id="c2-title-0147"/>Exercise 2.92</h5>
<p class="paraaftertitle"><a id="c2-para-2258"/>By imposing an ordering on variables, extend the polynomial package so that addition and multiplication of polynomials works for polynomials in different variables. (This is not easy!)</p>
</section>
<section>
<h5><a id="c2-sec-0147"/><a id="c2-title-0148"/>Extended exercise: Rational functions</h5>
<p class="paraaftertitle"><a id="c2-para-2259"/>We can extend our generic arithmetic system to include <i>rational functions</i>. These are “fractions” whose numerator and denominator are polynomials, such as</p>
<p><a id="c2-para-2260"/></p>
<figure id="c2-fig-0038"><img alt="c2-fig-5014.jpg" src="../images/c2-fig-5014.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c2-para-2261"/>The system should be able to add, subtract, multiply, and divide rational functions, and to perform such computations as</p>
<p><a id="c2-para-2262"/></p>
<figure id="c2-fig-0039"><img alt="c2-fig-5015.jpg" src="../images/c2-fig-5015.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c2-para-2263"/>(Here the sum has been simplified by removing common factors. Ordinary “cross multiplication” would have produced a fourth-degree polynomial over a fifth-degree polynomial.)</p>
<p><a id="c2-para-2264"/>If we modify our rational-arithmetic package so that it uses generic operations, then it will do what we want, except for the problem of reducing fractions to lowest terms.</p>
</section>
<section>
<h5><a id="c2-sec-0148"/><a id="c2-title-0149"/>Exercise 2.93</h5>
<p class="paraaftertitle"><a id="c2-para-2265"/>Modify the rational-arithmetic package to use generic operations, but change <span class="KeyTerm1">make_rat</span> so that it does not attempt to reduce fractions to lowest terms. Test your system by calling <span class="KeyTerm1">make_rational</span> on two polynomials to produce a rational function</p>
<p class="Sp-text-1"><a id="c2-para-2266"/><b>const</b> p1 = make_polynomial("x", list(make_term(2, 1), make_term(0, 1)));</p>
<p class="Sp-text-1"><a id="c2-para-2267"/><b>const</b> p2 = make_polynomial("x", list(make_term(3, 1), make_term(0, 1)));</p>
<p class="Sp-text-1"><a id="c2-para-2268"/><b>const</b> rf = make_rational(p2, p1);</p>
<p class="paracontinue"><a id="c2-para-2269"/>Now add <span class="KeyTerm1">rf</span> to itself, using <span class="KeyTerm1">add</span>. You will observe that this addition function does not reduce fractions to lowest terms.</p>
<p><a id="c2-para-2270"/>We can reduce polynomial fractions to lowest terms using the same idea we used with integers: modifying <span class="KeyTerm1">make_rat</span> to divide both the numerator and the denominator by their greatest common divisor. The notion of “greatest common divisor” makes sense for polynomials. In fact, we can compute the GCD of two polynomials using essentially the same Euclid's Algorithm that works for integers.<a id="c2-fn-0057a"/><a href="#c2-fn-0057"><sup>57</sup></a> The integer version is</p>
<p class="Sp-text-1"><a id="c2-para-2271"/><b>function</b> gcd(a, b) {</p>
<p class="Sp-text-1"><a id="c2-para-2272"/>    <b>return</b> b === 0</p>
<p class="Sp-text-1"><a id="c2-para-2273"/>           ? a</p>
<p class="Sp-text-1"><a id="c2-para-2274"/>           : gcd(b, a % b);</p>
<p class="Sp-text-1"><a id="c2-para-2275"/>}</p>
<p class="paracontinue"><a id="c2-para-2276"/>Using this, we could make the obvious modification to define a GCD operation that works on term lists:</p>
<p class="Sp-text-1"><a id="c2-para-2277"/><b>function</b> gcd_terms(a, b) {</p>
<p class="Sp-text-1"><a id="c2-para-2278"/>    <b>return</b> is_empty_termlist(b)</p>
<p class="Sp-text-1"><a id="c2-para-2279"/>           ? a</p>
<p class="Sp-text-1"><a id="c2-para-2280"/>           : gcd_terms(b, remainder_terms(a, b));</p>
<p class="Sp-text-1"><a id="c2-para-2281"/>}</p>
<p class="paracontinue"><a id="c2-para-2282"/>where <span class="KeyTerm1">remainder_terms</span> picks out the remainder component of the list returned by the term-list division operation <span class="KeyTerm1">div_terms</span> that was implemented in exercise 2.91.</p>
</section>
<section>
<h5><a id="c2-sec-0149"/><a id="c2-title-0150"/>Exercise 2.94</h5>
<p class="paraaftertitle"><a id="c2-para-2283"/>Using <span class="KeyTerm1">div_terms</span>, implement the function <span class="KeyTerm1">remainder_terms</span> and use this to define <span class="KeyTerm1">gcd_ terms</span> as above. Now write a function <span class="KeyTerm1">gcd_poly</span> that computes the polynomial GCD of two polys. (The function should signal an error if the two polys are not in the same variable.) Install in the system a generic operation <span class="KeyTerm1">greatest_common_divisor</span> that reduces to <span class="KeyTerm1">gcd_poly</span> for polynomials and to ordinary <span class="KeyTerm1">gcd</span> for ordinary numbers. As a test, try</p>
<p class="Sp-text-1"><a id="c2-para-2284"/><b>const</b> p1 = make_polynomial("x", list(make_term(4, 1), make_term(3, -1),</p>
<p class="Sp-text-1"><a id="c2-para-2285"/>                                     make_term(2, -2), make_term(1, 2)));</p>
<p class="Sp-text-1"><a id="c2-para-2286"/><b>const</b> p2 = make_polynomial("x", list(make_term(3, 1), make_term(1, -1)));</p>
<p class="Sp-text-1"><a id="c2-para-2287"/>greatest_common_divisor(p1, p2);</p>
<p class="paracontinue"><a id="c2-para-2288"/>and check your result by hand.</p>
</section>
<section>
<h5><a id="c2-sec-0150"/><a id="c2-title-0151"/>Exercise 2.95</h5>
<p class="paraaftertitle"><a id="c2-para-2289"/>Define <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and <i>P</i><sub>3</sub> to be the polynomials</p>
<p class="Sp-text-2"><a id="c2-para-2290"/><i>P</i><sub>1</sub>:  <i>x</i><sup>2</sup> – 2<i>x</i> + 1</p>
<p class="Sp-text-2"><a id="c2-para-2291"/><i>P</i><sub>2</sub>:  11<i>x</i><sup>2</sup> + 7</p>
<p class="Sp-text-2"><a id="c2-para-2292"/><i>P</i><sub>3</sub>:  13<i>x</i> + 5</p>
<p class="paracontinue"><a id="c2-para-2293"/>Now define <i>Q</i><sub>1</sub> to be the product of <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub> and <i>Q</i><sub>2</sub> to be the product of <i>P</i><sub>1</sub> and <i>P</i><sub>3</sub>, and use <span class="KeyTerm1">greatest_common_divisor</span> (exercise 2.94) to compute the GCD of <i>Q</i><sub>1</sub> and <i>Q</i><sub>2</sub>. Note that the answer is not the same as <i>P</i><sub>1</sub>. This example introduces noninteger operations into the computation, causing difficulties with the GCD algorithm.<a id="c2-fn-0058a"/><a href="#c2-fn-0058"><sup>58</sup></a> To understand what is happening, try tracing <span class="KeyTerm1">gcd_terms</span> while computing the GCD or try performing the division by hand.</p>
<p><a id="c2-para-2294"/>We can solve the problem exhibited in exercise 2.95 if we use the following modification of the GCD algorithm (which really works only in the case of polynomials with integer coefficients). Before performing any polynomial division in the GCD computation, we multiply the dividend by an integer constant factor, chosen to guarantee that no fractions will arise during the division process. Our answer will thus differ from the actual GCD by an integer constant factor, but this does not matter in the case of reducing rational functions to lowest terms; the GCD will be used to divide both the numerator and denominator, so the integer constant factor will cancel out.</p>
<p><a id="c2-para-2295"/>More precisely, if <i>P</i> and <i>Q</i> are polynomials, let <i>O</i><sub>1</sub> be the order of <i>P</i> (i.e., the order of the largest term of <i>P</i>) and let <i>O</i><sub>2</sub> be the order of <i>Q</i>. Let <i>c</i> be the leading coefficient of <i>Q</i>. Then it can be shown that, if we multiply <i>P</i> by the <i>integerizing factor c</i><sup>1+</sup><i><sup>O</sup></i><sup>1–</sup><i><sup>O</sup></i><sup>2,</sup> the resulting polynomial can be divided by <i>Q</i> by using the <span class="KeyTerm1">div_terms</span> algorithm without introducing any fractions. The operation of multiplying the dividend by this constant and then dividing is sometimes called the <i>pseudodivision</i> of <i>P</i> by <i>Q</i>. The remainder of the division is called the <i>pseudoremainder</i>.</p>
</section>
<section>
<h5><a id="c2-sec-0151"/><a id="c2-title-0152"/>Exercise 2.96</h5>
<ol class="BS_NumberListA">
<li><a id="c2-li-0061"/><span>a. </span>Implement the function <span class="KeyTerm1">pseudoremainder_terms</span>, which is just like <span class="KeyTerm1">remainder_terms</span> except that it multiplies the dividend by the integerizing factor described above before calling <span class="KeyTerm1">div_terms</span>. Modify <span class="KeyTerm1">gcd_terms</span> to use <span class="KeyTerm1">pseudoremainder_terms</span>, and verify that <span class="KeyTerm1">greatest_common_divisor</span> now produces an answer with integer coefficients on the example in exercise 2.95.</li>
<li><a id="c2-li-0062"/><span>b. </span>The GCD now has integer coefficients, but they are larger than those of <i>P</i><sub>1</sub>. Modify <span class="KeyTerm1">gcd_terms</span> so that it removes common factors from the coefficients of the answer by dividing all the coefficients by their (integer) greatest common divisor.</li>
</ol>
<p><a id="c2-para-2298"/>Thus, here is how to reduce a rational function to lowest terms:</p>
<ul style="list-style-type:disc">
<li>Compute the GCD of the numerator and denominator, using the version of <span class="KeyTerm1">gcd_ terms</span> from exercise 2.96.</li>
<li>When you obtain the GCD, multiply both numerator and denominator by the same integerizing factor before dividing through by the GCD, so that division by the GCD will not introduce any noninteger coefficients. As the factor you can use the leading coefficient of the GCD raised to the power 1 + <i>O</i><sub>1</sub> – <i>O</i><sub>2</sub>, where <i>O</i><sub>2</sub> is the order of the GCD and <i>O</i><sub>1</sub> is the maximum of the orders of the numerator and denominator. This will ensure that dividing the numerator and denominator by the GCD will not introduce any fractions.</li>
<li>The result of this operation will be a numerator and denominator with integer coefficients. The coefficients will normally be very large because of all of the integerizing factors, so the last step is to remove the redundant factors by computing the (integer) greatest common divisor of all the coefficients of the numerator and the denominator and dividing through by this factor.</li>
</ul>
</section>
<section>
<h5><a id="c2-sec-0152"/><a id="c2-title-0153"/>Exercise 2.97</h5>
<ol class="BS_NumberListA">
<li><a id="c2-li-0066"/><span>a. </span>Implement this algorithm as a function <span class="KeyTerm1">reduce_terms</span> that takes two term lists <span class="KeyTerm1">n</span> and <span class="KeyTerm1">d</span> as arguments and returns a list <span class="KeyTerm1">nn</span>, <span class="KeyTerm1">dd</span>, which are <span class="KeyTerm1">n</span> and <span class="KeyTerm1">d</span> reduced to lowest terms via the algorithm given above. Also write a function <span class="KeyTerm1">reduce_poly</span>, analogous to <span class="KeyTerm1">add_poly</span>, that checks to see if the two polys have the same variable. If so, <span class="KeyTerm1">reduce_poly</span> strips off the variable and passes the problem to <span class="KeyTerm1">reduce_terms</span>, then reattaches the variable to the two term lists supplied by <span class="KeyTerm1">reduce_terms</span>.</li>
<li><a id="c2-li-0067"/><span>b. </span>Define a function analogous to <span class="KeyTerm1">reduce_terms</span> that does what the original <span class="KeyTerm1">make_rat</span> did for integers:
<p class="Sp-text-1"><a id="c2-para-2304"/><b>function</b> reduce_integers(n, d) {</p>
<p class="Sp-text-1"><a id="c2-para-2305"/>    <b>const</b> g = gcd(n, d);</p>
<p class="Sp-text-1"><a id="c2-para-2306"/>    <b>return</b> list(n / g, d / g);</p>
<p class="Sp-text-1"><a id="c2-para-2307"/>}</p>
<p class="paracontinue"><a id="c2-para-2308"/>and define <span class="KeyTerm1">reduce</span> as a generic operation that calls <span class="KeyTerm1">apply_generic</span> to dispatch either to <span class="KeyTerm1">reduce_poly</span> (for <span class="KeyTerm1">polynomial</span> arguments) or to <span class="KeyTerm1">reduce_integers</span> (for <span class="KeyTerm1">javascript_ number</span> arguments). You can now easily make the rational-arithmetic package reduce fractions to lowest terms by having <span class="KeyTerm1">make_rat</span> call <span class="KeyTerm1">reduce</span> before combining the given numerator and denominator to form a rational number. The system now handles rational expressions in either integers or polynomials. To test your program, try the example at the beginning of this extended exercise:</p>
<p class="Sp-text-1"><a id="c2-para-2309"/><b>const</b> p1 = make_polynomial("x", list(make_term(1, 1), make_term(0, 1)));</p>
<p class="Sp-text-1"><a id="c2-para-2310"/><b>const</b> p2 = make_polynomial("x", list(make_term(3, 1), make_term(0, -1)));</p>
<p class="Sp-text-1"><a id="c2-para-2311"/><b>const</b> p3 = make_polynomial("x", list(make_term(1, 1)));</p>
<p class="Sp-text-1"><a id="c2-para-2312"/><b>const</b> p4 = make_polynomial("x", list(make_term(2, 1), make_term(0, -1)));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-2313"/><b>const</b> rf1 = make_rational(p1, p2);</p>
<p class="Sp-text-1"><a id="c2-para-2314"/><b>const</b> rf2 = make_rational(p3, p4);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c2-para-2315"/>add(rf1, rf2);</p>
<p class="paracontinue"><a id="c2-para-2316"/>See if you get the correct answer, correctly reduced to lowest terms.</p></li>
</ol>
<p><a id="c2-para-2317"/>The GCD computation is at the heart of any system that does operations on rational functions. The algorithm used above, although mathematically straightforward, is extremely slow. The slowness is due partly to the large number of division operations and partly to the enormous size of the intermediate coefficients generated by the pseudodivisions. One of the active areas in the development of algebraicmanipulation systems is the design of better algorithms for computing polynomial GCDs.<a id="c2-fn-0059a"/><a href="#c2-fn-0059"><sup>59</sup></a></p>
</section>
</section>
</section>
</section>
<section class="BS_enoteSec">
<aside class="noteEntry"><a id="c2-fn-0001"/><a href="#c2-fn-0001a">1</a> The ability to directly manipulate functions provides an analogous increase in the expressive power of a programming language. For example, in section 1.3.1 we introduced the <span class="KeyTerm1">sum</span> function, which takes a function <span class="KeyTerm1">term</span> as an argument and computes the sum of the values of <span class="KeyTerm1">term</span> over some specified interval. In order to define <span class="KeyTerm1">sum</span>, it is crucial that we be able to speak of a function such as <span class="KeyTerm1">term</span> as an entity in its own right, without regard for how <span class="KeyTerm1">term</span> might be expressed with more primitive operations. Indeed, if we did not have the notion of “a function,” it is doubtful that we would ever even think of the possibility of defining an operation such as <span class="KeyTerm1">sum</span>. Moreover, insofar as performing the summation is concerned, the details of how <span class="KeyTerm1">term</span> may be constructed from more primitive operations are irrelevant.</aside>
<aside class="noteEntry"><a id="c2-fn-0002"/><a href="#c2-fn-0002a">2</a> Another way to define the selectors and constructor is
<br/><span class="BS_Sp-text-1_FN"><b>const</b> make_rat = pair;</span>
<br/><span class="BS_Sp-text-1_FN"><b>const</b> numer = head;</span>
<br/><span class="BS_Sp-text-1_FN"><b>const</b> denom = tail;</span>
<br/>The first definition associates the name <span class="KeyTerm1">make_rat</span> with the value of the expression <span class="KeyTerm1">pair</span>, which is the primitive function that constructs pairs. Thus <span class="KeyTerm1">make_rat</span> and <span class="KeyTerm1">pair</span> are names for the same primitive constructor.<br/>  Defining selectors and constructors in this way is efficient: Instead of <span class="KeyTerm1">make_rat</span> <i>calling</i> <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">make_rat</span> <i>is</i> <span class="KeyTerm1">pair</span>, so there is only one function called, not two, when <span class="KeyTerm1">make_rat</span> is called. On the other hand, doing this defeats debugging aids that trace function calls or put breakpoints on function calls: You may want to watch <span class="KeyTerm1">make_rat</span> being called, but you certainly don't want to watch every call to <span class="KeyTerm1">pair</span>.<br/>  We have chosen not to use this style of definition in this book.</aside>
<aside class="noteEntry"><a id="c2-fn-0003"/><a href="#c2-fn-0003a">3</a> In JavaScript, the operator <span class="KeyTerm1">+</span> can also be applied to a string and a number and to other operand combinations, but in this book, we choose to apply it either to two numbers or to two strings.</aside>
<aside class="noteEntry"><a id="c2-fn-0004"/><a href="#c2-fn-0004a">4</a> The primitive function <span class="KeyTerm1">display</span> introduced in exercise 1.22 returns its argument, but in the uses of <span class="KeyTerm1">print_rat</span> below, we show only what <span class="KeyTerm1">print_rat</span> prints, not what the interpreter prints as the value returned by <span class="KeyTerm1">print_rat</span>.</aside>
<aside class="noteEntry"><a id="c2-fn-0005"/><a href="#c2-fn-0005a">5</a> Surprisingly, this idea is very difficult to formulate rigorously. There are two approaches to giving such a formulation. One, pioneered by C. A. R. Hoare (1972), is known as the method of <i>abstract models</i>. It formalizes the “functions plus conditions” specification as outlined in the rational-number example above. Note that the condition on the rational-number representation was stated in terms of facts about integers (equality and division). In general, abstract models define new kinds of data objects in terms of previously defined types of data objects. Assertions about data objects can therefore be checked by reducing them to assertions about previously defined data objects. Another approach, introduced by Zilles at MIT, by Goguen, Thatcher, Wagner, and Wright at IBM (see Thatcher, Wagner, and Wright 1978), and by Guttag at Toronto (see Guttag 1977), is called <i>algebraic specification</i>. It regards the “functions” as elements of an abstract algebraic system whose behavior is specified by axioms that correspond to our “conditions,” and uses the techniques of abstract algebra to check assertions about data objects. Both methods are surveyed in the paper by Liskov and Zilles (1975).</aside>
<aside class="noteEntry"><a id="c2-fn-0006"/><a href="#c2-fn-0006a">6</a> The function <span class="KeyTerm1">error</span> introduced in section 1.3.3 takes as optional second argument a string that gets displayed before the first argument—for example, if <span class="KeyTerm1">m</span> is 42:
<br/><span class="BS_Sp-text-1_FN">Error in line 7: argument not 0 or 1 – pair: 42</span></aside>
<aside class="noteEntry"><a id="c2-fn-0007"/><a href="#c2-fn-0007a">7</a> The use of the word “closure” here comes from abstract algebra, where a set of elements is said to be closed under an operation if applying the operation to elements in the set produces an element that is again an element of the set. The programming languages community also (unfortunately) uses the word “closure” to describe a totally unrelated concept: A closure is an implementation technique for representing functions with free names. We do not use the word “closure” in this second sense in this book.</aside>
<aside class="noteEntry"><a id="c2-fn-0008"/><a href="#c2-fn-0008a">8</a> In this book, we use <i>list</i> to mean a chain of pairs terminated by the end-of-list marker. In contrast, the term <i>list structure</i> refers to any data structure made out of pairs, not just to lists.</aside>
<aside class="noteEntry"><a id="c2-fn-0009"/><a href="#c2-fn-0009a">9</a> The value <span class="KeyTerm1"><b>null</b></span> is used in JavaScript for various purposes, but in this book we shall only use it to represent the empty list.</aside>
<aside class="noteEntry"><a id="c2-fn-0010"/><a href="#c2-fn-0010a">10</a> Our JavaScript environment provides a primitive function <span class="KeyTerm1">display_list</span> that works like the primitive function <span class="KeyTerm1">display</span>, except that it uses list notation instead of box notation.</aside>
<aside class="noteEntry"><a id="c2-fn-0011"/><a href="#c2-fn-0011a">11</a> The order of the two predicates matters, since <span class="KeyTerm1"><b>null</b></span> satisfies <span class="KeyTerm1">is_null</span> and also is not a pair.</aside>
<aside class="noteEntry"><a id="c2-fn-0012"/><a href="#c2-fn-0012a">12</a> This is, in fact, precisely the <span class="KeyTerm1">fringe</span> function from exercise 2.28. Here we've renamed it to emphasize that it is part of a family of general sequence-manipulation functions.</aside>
<aside class="noteEntry"><a id="c2-fn-0013"/><a href="#c2-fn-0013a">13</a> Richard Waters (1979) developed a program that automatically analyzes traditional Fortran programs, viewing them in terms of maps, filters, and accumulations. He found that fully 90 percent of the code in the Fortran Scientific Subroutine Package fits neatly into this paradigm. One of the reasons for the success of Lisp as a programming language is that lists provide a standard medium for expressing ordered collections so that they can be manipulated using higher-order operations. Many modern languages, such as Python, have learned this lesson.</aside>
<aside class="noteEntry"><a id="c2-fn-0014"/><a href="#c2-fn-0014a">14</a> According to Knuth (1997b), this rule was formulated by W. G. Horner early in the nineteenth century, but the method was actually used by Newton over a hundred years earlier. Horner's rule evaluates the polynomial using fewer additions and multiplications than does the straightforward method of first computing <i>a<sub>n</sub>x<sup>n</sup></i>, then adding <i>a<sub>n</sub></i><sub>–1</sub><i>x<sup>n</sup></i><sup>–1</sup>, and so on. In fact, it is possible to prove that any algorithm for evaluating arbitrary polynomials must use at least as many additions and multiplications as does Horner's rule, and thus Horner's rule is an optimal algorithm for polynomial evaluation. This was proved (for the number of additions) by A. M. Ostrowski in a 1954 paper that essentially founded the modern study of optimal algorithms. The analogous statement for multiplications was proved by V. Y. Pan in 1966. The book by Borodin and Munro (1975) provides an overview of these and other results about optimal algorithms.</aside>
<aside class="noteEntry"><a id="c2-fn-0015"/><a href="#c2-fn-0015a">15</a> This definition uses the function <span class="KeyTerm1">accumulate_n</span> from exercise 2.36.</aside>
<aside class="noteEntry"><a id="c2-fn-0016"/><a href="#c2-fn-0016a">16</a> This approach to nested mappings was shown to us by David Turner, whose languages KRC and Miranda provide elegant formalisms for dealing with these constructs. The examples in this section (see also exercise 2.42) are adapted from Turner 1981. In section 3.5.3, we'll see how this approach generalizes to infinite sequences.</aside>
<aside class="noteEntry"><a id="c2-fn-0017"/><a href="#c2-fn-0017a">17</a> We're representing a pair here as a list of two elements rather than as an ordinary pair. Thus, the “pair” (<i>i</i>, <i>j</i>) is represented as <span class="KeyTerm1">list(i, j)</span>, not <span class="KeyTerm1">pair(i, j)</span>.</aside>
<aside class="noteEntry"><a id="c2-fn-0018"/><a href="#c2-fn-0018a">18</a> The set <i>S</i> – <i>x</i> is the set of all elements of <i>S</i>, excluding <i>x</i>.</aside>
<aside class="noteEntry"><a id="c2-fn-0019"/><a href="#c2-fn-0019a">19</a> The character sequence <i>//</i> in JavaScript programs is used to introduce <i>comments</i>. Everything from <i>//</i> to the end of the line is ignored by the interpreter. In this book we don't use many comments; we try to make our programs self-documenting by using descriptive names.</aside>
<aside class="noteEntry"><a id="c2-fn-0020"/><a href="#c2-fn-0020a">20</a> The picture language is based on the language Peter Henderson created to construct images like M.C. Escher's “Square Limit” woodcut (see Henderson 1982). The woodcut incorporates a repeated scaled pattern, similar to the arrangements drawn using the <span class="KeyTerm1">square_limit</span> function in this section.</aside>
<aside class="noteEntry"><a id="c2-fn-0021"/><a href="#c2-fn-0021a">21</a> William Barton Rogers (1804–1882) was the founder and first president of MIT. A geologist and talented teacher, he taught at William and Mary College and at the University of Virginia. In 1859 he moved to Boston, where he had more time for research, worked on a plan for establishing a “polytechnic institute,” and served as Massachusetts's first State Inspector of Gas Meters.<br/>  When MIT was established in 1861, Rogers was elected its first president. Rogers espoused an ideal of “useful learning” that was different from the university education of the time, with its overemphasis on the classics, which, as he wrote, “stand in the way of the broader, higher and more practical instruction and discipline of the natural and social sciences.” This education was likewise to be different from narrow trade-school education. In Rogers's words:
<blockquote class="quote">
<p class="quoteparafirst"><a id="c2-para-0842"/>The world-enforced distinction between the practical and the scientific worker is utterly futile, and the whole experience of modern times has demonstrated its utter worthlessness.</p></blockquote>Rogers served as president of MIT until 1870, when he resigned due to ill health. In 1878 the second president of MIT, John Runkle, resigned under the pressure of a financial crisis brought on by the Panic of 1873 and strain of fighting off attempts by Harvard to take over MIT. Rogers returned to hold the office of president until 1881.<br/>  Rogers collapsed and died while addressing MIT's graduating class at the commencement exercises of 1882. Runkle quoted Rogers's last words in a memorial address delivered that same year:
<blockquote class="quote">
<p class="quoteparafirst"><a id="c2-para-0844"/>“As I stand here today and see what the Institute is, . . . I call to mind the beginnings of science. I remember one hundred and fifty years ago Stephen Hales published a pamphlet on the subject of illuminating gas, in which he stated that his researches had demonstrated that 128 grains of bituminous coal—”</p>
<p class="quotepara"><a id="c2-para-0845"/>“Bituminous coal,” these were his last words on earth. Here he bent forward, as if consulting some notes on the table before him, then slowly regaining an erect position, threw up his hands, and was translated from the scene of his earthly labors and triumphs to “the tomorrow of death,” where the mysteries of life are solved, and the disembodied spirit finds unending satisfaction in contemplating the new and still unfathomable mysteries of the infinite future.</p></blockquote>In the words of Francis A. Walker (MIT's third president):
<blockquote class="quote">
<p class="quoteparafirst"><a id="c2-para-0847"/>All his life he had borne himself most faithfully and heroically, and he died as so good a knight would surely have wished, in harness, at his post, and in the very part and act of public duty.</p></blockquote></aside>
<aside class="noteEntry"><a id="c2-fn-0022"/><a href="#c2-fn-0022a">22</a> In <span class="KeyTerm1">square_of_four</span>, we use an extension of the syntax of lambda expressions that was introduced in section 1.3.2: The body of a lambda expression can be a block, not just a return expression. Such a lambda expression has the shape <span class="KeyTerm1">(</span><i>parameters</i><span class="KeyTerm1">) =&gt; {</span> <i>statements</i> <span class="KeyTerm1">}</span> or <i>parameter</i> <span class="KeyTerm1">=&gt; {</span> <i>statements</i> <span class="KeyTerm1">}</span>.</aside>
<aside class="noteEntry"><a id="c2-fn-0023"/><a href="#c2-fn-0023a">23</a> Equivalently, we could write
<br/><span class="BS_Sp-text-1_FN"><b>const</b> flipped_pairs = square_of_four(identity, flip_vert,</span>
<br/><span class="BS_Sp-text-1_FN">                                     identity, flip_vert);</span></aside>
<aside class="noteEntry"><a id="c2-fn-0024"/><a href="#c2-fn-0024a">24</a> The function <span class="KeyTerm1">rotate180</span> rotates a painter by 180 degrees. Instead of <span class="KeyTerm1">rotate180</span> we could say <span class="KeyTerm1">compose(flip_vert, flip_horiz)</span>, using the <span class="KeyTerm1">compose</span> function from exercise 1.42.</aside>
<aside class="noteEntry"><a id="c2-fn-0025"/><a href="#c2-fn-0025a">25</a> The function <span class="KeyTerm1">frame_coord_map</span> uses the vector operations described in exercise 2.46 below, which we assume have been implemented using some representation for vectors. Because of data abstraction, it doesn't matter what this vector representation is, so long as the vector operations behave correctly.</aside>
<aside class="noteEntry"><a id="c2-fn-0026"/><a href="#c2-fn-0026a">26</a> The function <span class="KeyTerm1">segments_to_painter</span> uses the representation for line segments described in exercise 2.48 below. It also uses the <span class="KeyTerm1">for_each</span> function described in exercise 2.23.</aside>
<aside class="noteEntry"><a id="c2-fn-0027"/><a href="#c2-fn-0027a">27</a> For example, the <span class="KeyTerm1">rogers</span> painter of <a href="#c2-fig-0018">figure 2.11</a> was constructed from a gray-level image. For each point in a given frame, the <span class="KeyTerm1">rogers</span> painter determines the point in the image that is mapped to it under the frame coordinate map, and shades it accordingly. By allowing different types of painters, we are capitalizing on the abstract data idea discussed in section 2.1.3, where we argued that a rational-number representation could be anything at all that satisfies an appropriate condition. Here we're using the fact that a painter can be implemented in any way at all, so long as it draws something in the designated frame. Section 2.1.3 also showed how pairs could be implemented as functions. Painters are our second example of a functional representation for data.</aside>
<aside class="noteEntry"><a id="c2-fn-0028"/><a href="#c2-fn-0028a">28</a> The function <span class="KeyTerm1">rotate90</span> is a pure rotation only for square frames, because it also stretches and shrinks the image to fit into the rotated frame.</aside>
<aside class="noteEntry"><a id="c2-fn-0029"/><a href="#c2-fn-0029a">29</a> The diamond-shaped images in <a href="#c2-fig-0017">figures 2.10 and 2.11</a> were created with <span class="KeyTerm1">squash_inwards</span> applied to <span class="KeyTerm1">wave</span> and <span class="KeyTerm1">rogers</span>.</aside>
<aside class="noteEntry"><a id="c2-fn-0030"/><a href="#c2-fn-0030a">30</a> Section 3.3.4 describes one such language.</aside>
<aside class="noteEntry"><a id="c2-fn-0031"/><a href="#c2-fn-0031a">31</a> We can consider two strings to be “the same” if they consist of the same characters in the same order. Such a definition skirts a deep issue that we are not yet ready to address: the meaning of “sameness” in a programming language. We will return to this in chapter 3 (section 3.1.3).</aside>
<aside class="noteEntry"><a id="c2-fn-0032"/><a href="#c2-fn-0032a">32</a> The original version of this book used the programming language Scheme, a dialect of Lisp.</aside>
<aside class="noteEntry"><a id="c2-fn-0033"/><a href="#c2-fn-0033a">33</a> If we want to be more formal, we can specify “consistent with the interpretations given above” to mean that the operations satisfy a collection of rules such as these:<ul style="list-style-type:disc">
<li>For any set <span class="KeyTerm1"><span class="KeyTerm1">S</span> </span>and any object <span class="KeyTerm1">x</span>, <span class="KeyTerm1">is_element_of_set(x, adjoin_set(x, S))</span> is true (informally: “Adjoining an object to a set produces a set that contains the object”).</li>
<li>For any sets <span class="KeyTerm1"><span class="KeyTerm1">S</span> </span>and <span class="KeyTerm1"><span class="KeyTerm1">T</span> </span>and any object <span class="KeyTerm1">x</span>, <span class="KeyTerm1">is_element_of_set(x, union_set(S, T))</span> is equal to <span class="KeyTerm1">is_element_of_set(x, S) || is_element_of_set(x, T)</span> (informally: “The elements of <span class="KeyTerm1">union_set(S, T)</span> are the elements that are in <span class="KeyTerm1"><span class="KeyTerm1">S</span> </span>or in <span class="KeyTerm1"><span class="KeyTerm1">T</span></span>”).</li>
<li>For any object <span class="KeyTerm1">x</span>, <span class="KeyTerm1">is_element_of_set(x, <b>null</b>)</span> is false (informally: “No object is an element of the empty set”).</li>
</ul></aside>
<aside class="noteEntry"><a id="c2-fn-0034"/><a href="#c2-fn-0034a">34</a> Halving the size of the problem at each step is the distinguishing characteristic of logarithmic growth, as we saw with the fast-exponentiation algorithm of section 1.2.4 and the half-interval search method of section 1.3.3.</aside>
<aside class="noteEntry"><a id="c2-fn-0035"/><a href="#c2-fn-0035a">35</a> We are representing sets in terms of trees, and trees in terms of lists—in effect, a data abstraction built upon a data abstraction. We can regard the functions <span class="KeyTerm1">entry</span>, <span class="KeyTerm1">left_branch</span>, <span class="KeyTerm1">right_branch</span>, and <span class="KeyTerm1">make_tree</span> as a way of isolating the abstraction of a “binary tree” from the particular way we might wish to represent such a tree in terms of list structure.</aside>
<aside class="noteEntry"><a id="c2-fn-0036"/><a href="#c2-fn-0036a">36</a> Examples of such structures include <i>B-trees</i> and <i>red-black trees</i>. There is a large literature on data structures devoted to this problem. See Cormen, Leiserson, Rivest, and Stein 2022.</aside>
<aside class="noteEntry"><a id="c2-fn-0037"/><a href="#c2-fn-0037a">37</a> Exercises 2.63–2.65 are due to Paul Hilfinger.</aside>
<aside class="noteEntry"><a id="c2-fn-0038"/><a href="#c2-fn-0038a">38</a> See Hamming 1980 for a discussion of the mathematical properties of Huffman codes.</aside>
<aside class="noteEntry"><a id="c2-fn-0039"/><a href="#c2-fn-0039a">39</a> In actual computational systems, rectangular form is preferable to polar form most of the time because of roundoff errors in conversion between rectangular and polar form. This is why the complex-number example is unrealistic. Nevertheless, it provides a clear illustration of the design of a system using generic operations and a good introduction to the more substantial systems to be developed later in this chapter.</aside>
<aside class="noteEntry"><a id="c2-fn-0040"/><a href="#c2-fn-0040a">40</a> The arctangent function referred to here, computed by JavaScript's <span class="KeyTerm1">math_atan2</span> function, is defined so as to take two arguments <i>y</i> and <i>x</i> and to return the angle whose tangent is <i>y</i>/<i>x</i>. The signs of the arguments determine the quadrant of the angle.</aside>
<aside class="noteEntry"><a id="c2-fn-0041"/><a href="#c2-fn-0041a">41</a> The name <span class="KeyTerm1">undefined</span> is predeclared in any JavaScript implementation and should not be used other than to refer to that primitive value.</aside>
<aside class="noteEntry"><a id="c2-fn-0042"/><a href="#c2-fn-0042a">42</a> We use the list <span class="KeyTerm1">list("rectangular")</span> rather than the string <span class="KeyTerm1">"rectangular"</span> to allow for the possibility of operations with multiple arguments, not all of the same type.</aside>
<aside class="noteEntry"><a id="c2-fn-0043"/><a href="#c2-fn-0043a">43</a> The type the constructors are installed under needn't be a list because a constructor is always used to make an object of one particular type.</aside>
<aside class="noteEntry"><a id="c2-fn-0044"/><a href="#c2-fn-0044a">44</a> The function <span class="KeyTerm1">apply_generic</span> uses the function <span class="KeyTerm1">apply_in_underlying_javascript</span> given in section 4.1.4 (footnote 18), which takes two arguments, a function and a list, and applies the function, using the elements in the list as arguments. For example,
<br/><span class="BS_Sp-text-1_FN">apply_in_underlying_javascript(sum_of_squares, list(1, 3))</span>
<br/>returns 10.</aside>
<aside class="noteEntry"><a id="c2-fn-0045"/><a href="#c2-fn-0045a">45</a> One limitation of this organization is it permits only generic functions of one argument.</aside>
<aside class="noteEntry"><a id="c2-fn-0046"/><a href="#c2-fn-0046a">46</a> We also have to supply an almost identical function to handle the types
<br/><span class="BS_Sp-text-1_FN">list("javascript_number", "complex").</span></aside>
<aside class="noteEntry"><a id="c2-fn-0047"/><a href="#c2-fn-0047a">47</a> See exercise 2.82 for generalizations.</aside>
<aside class="noteEntry"><a id="c2-fn-0048"/><a href="#c2-fn-0048a">48</a> If we are clever, we can usually get by with fewer than <i>n</i><sup>2</sup> coercion functions. For instance, if we know how to convert from type 1 to type 2 and from type 2 to type 3, then we can use this knowledge to convert from type 1 to type 3. This can greatly decrease the number of coercion functions we need to supply explicitly when we add a new type to the system. If we are willing to build the required amount of sophistication into our system, we can have it search the “graph” of relations among types and automatically generate those coercion functions that can be inferred from the ones that are supplied explicitly.</aside>
<aside class="noteEntry"><a id="c2-fn-0049"/><a href="#c2-fn-0049a">49</a> This statement, which also appears in the first edition of this book, is just as true now as it was when we wrote it in 1984. Developing a useful, general framework for expressing the relations among different types of entities (what philosophers call “ontology”) seems intractably difficult. The main difference between the confusion that existed in 1984 and the confusion that exists now is that now a variety of inadequate ontological theories have been embodied in a plethora of correspondingly inadequate programming languages. For example, much of the complexity of object-oriented programming languages—and the subtle and confusing differences among contemporary object-oriented languages—centers on the treatment of generic operations on interrelated types. Our own discussion of computational objects in chapter 3 avoids these issues entirely. Readers familiar with object-oriented programming will notice that we have much to say in chapter 3 about local state, but we do not even mention “classes” or “inheritance.” In fact, we suspect that these problems cannot be adequately addressed in terms of computer-language design alone, without also drawing on work in knowledge representation and automated reasoning.</aside>
<aside class="noteEntry"><a id="c2-fn-0050"/><a href="#c2-fn-0050a">50</a> A real number can be projected to an integer using the <span class="KeyTerm1">math_round</span> primitive, which returns the closest integer to its argument.</aside>
<aside class="noteEntry"><a id="c2-fn-0051"/><a href="#c2-fn-0051a">51</a> On the other hand, we will allow polynomials whose coefficients are themselves polynomials in other variables. This will give us essentially the same representational power as a full multivariate system, although it does lead to coercion problems, as discussed below.</aside>
<aside class="noteEntry"><a id="c2-fn-0052"/><a href="#c2-fn-0052a">52</a> For univariate polynomials, giving the value of a polynomial at a given set of points can be a particularly good representation. This makes polynomial arithmetic extremely simple. To obtain, for example, the sum of two polynomials represented in this way, we need only add the values of the polynomials at corresponding points. To transform back to a more familiar representation, we can use the Lagrange interpolation formula, which shows how to recover the coefficients of a polynomial of degree <i>n</i> given the values of the polynomial at <i>n</i> + 1 points.</aside>
<aside class="noteEntry"><a id="c2-fn-0053"/><a href="#c2-fn-0053a">53</a> This operation is very much like the ordered <span class="KeyTerm1">union_set</span> operation we developed in exercise 2.62. In fact, if we think of the terms of the polynomial as a set ordered according to the power of the indeterminate, then the program that produces the term list for a sum is almost identical to <span class="KeyTerm1">union_set</span>.</aside>
<aside class="noteEntry"><a id="c2-fn-0054"/><a href="#c2-fn-0054a">54</a> To make this work completely smoothly, we should also add to our generic arithmetic system the ability to coerce a “number” to a polynomial by regarding it as a polynomial of degree zero whose coefficient is the number. This is necessary if we are going to perform operations such as
<br/>[<i>x</i><sup>2</sup> + (<i>y</i> + 1)<i>x</i> + 5] + [<i>x</i><sup>2</sup> + 2<i>x</i> + 1]
<br/>which requires adding the coefficient <i>y</i> + 1 to the coefficient 2.</aside>
<aside class="noteEntry"><a id="c2-fn-0055"/><a href="#c2-fn-0055a">55</a> In these polynomial examples, we assume that we have implemented the generic arithmetic system using the type mechanism suggested in exercise 2.78. Thus, coefficients that are ordinary numbers will be represented as the numbers themselves rather than as pairs whose <span class="KeyTerm1">head</span> is the string <span class="KeyTerm1">"javascript_number"</span>.</aside>
<aside class="noteEntry"><a id="c2-fn-0056"/><a href="#c2-fn-0056a">56</a> Although we are assuming that term lists are ordered, we have implemented <span class="KeyTerm1">adjoin_term</span> to simply adjoin the new term to the front of the existing term list. We can get away with this so long as we guarantee that the functions (such as <span class="KeyTerm1">add_terms</span>) that use <span class="KeyTerm1">adjoin_term</span> always call it with a higher-order term than appears in the list. If we did not want to make such a guarantee, we could have implemented <span class="KeyTerm1">adjoin_term</span> to be similar to the <span class="KeyTerm1">adjoin_set</span> constructor for the ordered-list representation of sets (exercise 2.61).</aside>
<aside class="noteEntry"><a id="c2-fn-0057"/><a href="#c2-fn-0057a">57</a> The fact that Euclid's Algorithm works for polynomials is formalized in algebra by saying that polynomials form a kind of algebraic domain called a <i>Euclidean ring</i>. A Euclidean ring is a domain that admits addition, subtraction, and commutative multiplication, together with a way of assigning to each element <i>x</i> of the ring a positive integer “measure” <i>m</i>(<i>x</i>) with the properties that <i>m</i>(<i>xy</i>) <i>m</i>(<i>x</i>) for any nonzero <i>x</i> and <i>y</i> and that, given any <i>x</i> and <i>y</i>, there exists a <i>q</i> such that <i>y</i> = <i>qx</i> + <i>r</i> and either <i>r</i> = 0 or <i>m</i>(<i>r</i>) &lt; <i>m</i>(<i>x</i>). From an abstract point of view, this is what is needed to prove that Euclid's Algorithm works. For the domain of integers, the measure <i>m</i> of an integer is the absolute value of the integer itself. For the domain of polynomials, the measure of a polynomial is its degree.</aside>
<aside class="noteEntry"><a id="c2-fn-0058"/><a href="#c2-fn-0058a">58</a> In JavaScript, division of integers can produce limited-precision decimal numbers, and thus we may fail to get a valid divisor.</aside>
<aside class="noteEntry"><a id="c2-fn-0059"/><a href="#c2-fn-0059a">59</a> One extremely efficient and elegant method for computing polynomial GCDs was discovered by Richard Zippel (1979). The method is a probabilistic algorithm, as is the fast test for primality that we discussed in chapter 1. Zippel's book (1993) describes this method, together with other ways to compute polynomial GCDs.</aside>
</section>
</section>
</body>
</html>