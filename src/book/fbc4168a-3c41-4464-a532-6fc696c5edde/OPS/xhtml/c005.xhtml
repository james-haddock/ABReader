<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>5 Computing with Register Machines</title>
<link href="../styles/MIT_style.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:5e22faf7-6d97-43f5-a05d-571a507bcb19" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<h1><a id="c5-title-0001"/><span class="chapterNumber">5</span><br/><span class="chapterTitle">Computing with Register Machines</span></h1>
</header>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c5-para-0001"/>My aim is to show that the heavenly machine is not a kind of divine, live being, but a kind of clockwork (and he who believes that a clock has soul attributes the maker's glory to the work), insofar as nearly all the manifold motions are caused by a most simple and material force, just as all motions of the clock are caused by a single weight.</p>
<p class="quote-epigraphsource">—Johannes Kepler (letter to Herwart von Hohenburg, 1605)</p></blockquote>
<p class="paraaftertitle"><a id="c5-para-0002"/>We began this book by studying processes and by describing processes in terms of functions written in JavaScript. To explain the meanings of these functions, we used a succession of models of evaluation: the substitution model of chapter 1, the environment model of chapter 3, and the metacircular evaluator of chapter 4. Our examination of the metacircular evaluator, in particular, dispelled much of the mystery of how JavaScript-like languages are interpreted. But even the metacircular evaluator leaves important questions unanswered, because it fails to elucidate the mechanisms of control in a JavaScript system. For instance, the evaluator does not explain how the evaluation of a subexpression manages to return a value to the expression that uses this value. Also, the evaluator does not explain how some recursive functions can generate iterative processes (that is, be evaluated using constant space) whereas other recursive functions will generate recursive processes.<a id="c5-fn-0001a"/><a href="#c5-fn-0001"><sup>1</sup></a> This chapter addresses both of these issues.</p>
<p><a id="c5-para-0003"/>We will describe processes in terms of the step-by-step operation of a traditional computer. Such a computer, or <i>register machine</i>, sequentially executes <i>instructions</i> that manipulate the contents of a fixed set of storage elements called <i>registers</i>. A typical register-machine instruction applies a primitive operation to the contents of some registers and assigns the result to another register. Our descriptions of processes executed by register machines will look very much like “machine-language” programs for traditional computers. However, instead of focusing on the machine language of any particular computer, we will examine several JavaScript functions and design a specific register machine to execute each function. Thus, we will approach our task from the perspective of a hardware architect rather than that of a machine-language computer programmer. In designing register machines, we will develop mechanisms for implementing important programming constructs such as recursion. We will also present a language for describing designs for register machines. In section 5.2 we will implement a JavaScript program that uses these descriptions to simulate the machines we design.</p>
<p><a id="c5-para-0004"/>Most of the primitive operations of our register machines are very simple. For example, an operation might add the numbers fetched from two registers, producing a result to be stored into a third register. Such an operation can be performed by easily described hardware. In order to deal with list structure, however, we will also use the memory operations <span class="KeyTerm1">head</span>, <span class="KeyTerm1">tail</span>, and <span class="KeyTerm1">pair</span>, which require an elaborate storage-allocation mechanism. In section 5.3 we study their implementation in terms of more elementary operations.</p>
<p><a id="c5-para-0005"/>In section 5.4, after we have accumulated experience formulating simple functions as register machines, we will design a machine that carries out the algorithm described by the metacircular evaluator of section 4.1. This will fill in the gap in our understanding of how JavaScript programs are interpreted, by providing an explicit model for the mechanisms of control in the evaluator. In section 5.5 we will study a simple compiler that translates JavaScript programs into sequences of instructions that can be executed directly with the registers and operations of the evaluator register machine.</p>
<section><a id="c5-title-0002"/>
<section>
<h2><a id="c5-sec-0002"/><span>5.1</span> <a id="c5-title-0003"/>Designing Register Machines</h2>
<p class="paraaftertitle"><a id="c5-para-0006"/>To design a register machine, we must design its <i>data paths</i> (registers and operations) and the <i>controller</i> that sequences these operations. To illustrate the design of a simple register machine, let us examine Euclid's Algorithm, which is used to compute the greatest common divisor (GCD) of two integers. As we saw in section 1.2.5, Euclid's Algorithm can be carried out by an iterative process, as specified by the following function:</p>
<p class="Sp-text-1"><a id="c5-para-0007"/><b>function</b> gcd(a, b) {</p>
<p class="Sp-text-1"><a id="c5-para-0008"/>    <b>return</b> b === 0 ? a : gcd(b, a % b);</p>
<p class="Sp-text-1"><a id="c5-para-0009"/>}</p>
<p><a id="c5-para-0010"/>A machine to carry out this algorithm must keep track of two numbers, <i>a</i> and <i>b</i>, so let us assume that these numbers are stored in two registers with those names. The basic operations required are testing whether the contents of register <span class="KeyTerm1">b</span> is zero and computing the remainder of the contents of register <span class="KeyTerm1">a</span> divided by the contents of register <span class="KeyTerm1">b</span>. The remainder operation is a complex process, but assume for the moment that we have a primitive device that computes remainders. On each cycle of the GCD algorithm, the contents of register <span class="KeyTerm1">a</span> must be replaced by the contents of register <span class="KeyTerm1">b</span>, and the contents of <span class="KeyTerm1">b</span> must be replaced by the remainder of the old contents of <span class="KeyTerm1">a</span> divided by the old contents of <span class="KeyTerm1">b</span>. It would be convenient if these replacements could be done simultaneously, but in our model of register machines we will assume that only one register can be assigned a new value at each step. To accomplish the replacements, our machine will use a third “temporary” register, which we call <span class="KeyTerm1">t</span>. (First the remainder will be placed in <span class="KeyTerm1">t</span>, then the contents of <span class="KeyTerm1">b</span> will be placed in <span class="KeyTerm1">a</span>, and finally the remainder stored in <span class="KeyTerm1">t</span> will be placed in <span class="KeyTerm1">b</span>.)</p>
<p><a id="c5-para-0011"/>We can illustrate the registers and operations required for this machine by using the data-path diagram shown in <a id="c5-fig-0001a"/><a href="#c5-fig-0001">figure 5.1</a>. In this diagram, the registers (<span class="KeyTerm1">a</span>, <span class="KeyTerm1">b</span>, and <span class="KeyTerm1">t</span>) are represented by rectangles. Each way to assign a value to a register is indicated by an arrow with a button—drawn as — behind the head, pointing from the source of data to the register. When pushed, the button allows the value at the source to “flow” into the designated register. The label next to each button is the name we will use to refer to the button. The names are arbitrary, and can be chosen to have mnemonic value (for example, <span class="KeyTerm1">a&lt;-b</span> denotes pushing the button that assigns the contents of register <span class="KeyTerm1">b</span> to register <span class="KeyTerm1">a</span>). The source of data for a register can be another register (as in the <span class="KeyTerm1">a&lt;-b</span> assignment), an operation result (as in the <span class="KeyTerm1">t&lt;-r</span> assignment), or a constant (a built-in value that cannot be changed, represented in a data-path diagram by a triangle containing the constant).</p>
<figure id="c5-fig-0001"><img alt="c5-fig-0001.jpg" src="../images/c5-fig-0001.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0001a">Figure 5.1</a></span> <a id="c5-para-0012"/>Data paths for a GCD machine.</p></figcaption></figure>
<p><a id="c5-para-0013"/>An operation that computes a value from constants and the contents of registers is represented in a data-path diagram by a trapezoid containing a name for the operation. For example, the box marked <span class="KeyTerm1">rem</span> in <a href="#c5-fig-0001">figure 5.1</a> represents an operation that computes the remainder of the contents of the registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> to which it is attached. Arrows (without buttons) point from the input registers and constants to the box, and arrows connect the operation's output value to registers. A test is represented by a circle containing a name for the test. For example, our GCD machine has an operation that tests whether the contents of register <span class="KeyTerm1">b</span> is zero. A test also has arrows from its input registers and constants, but it has no output arrows; its value is used by the controller rather than by the data paths. Overall, the data-path diagram shows the registers and operations that are required for the machine and how they must be connected. If we view the arrows as wires and the buttons as switches, the datapath diagram is very like the wiring diagram for a machine that could be constructed from electrical components.</p>
<p><a id="c5-para-0014"/>In order for the data paths to actually compute GCDs, the buttons must be pushed in the correct sequence. We will describe this sequence in terms of a controller diagram, as illustrated in <a id="c5-fig-0002a"/><a href="#c5-fig-0002">figure 5.2</a>. The elements of the controller diagram indicate how the data-path components should be operated. The rectangular boxes in the controller diagram identify data-path buttons to be pushed, and the arrows describe the sequencing from one step to the next. The diamond in the diagram represents a decision. One of the two sequencing arrows will be followed, depending on the value of the data-path test identified in the diamond. We can interpret the controller in terms of a physical analogy: Think of the diagram as a maze in which a marble is rolling. When the marble rolls into a box, it pushes the data-path button that is named by the box. When the marble rolls into a decision node (such as the test for <span class="KeyTerm1">b</span> = 0), it leaves the node on the path determined by the result of the indicated test.</p>
<figure id="c5-fig-0002"><img alt="c5-fig-0002.jpg" src="../images/c5-fig-0002.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0002a">Figure 5.2</a></span> <a id="c5-para-0015"/>Controller for a GCD machine.</p></figcaption></figure>
<p class="paracontinue"><a id="c5-para-0016"/>Taken together, the data paths and the controller completely describe a machine for computing GCDs. We start the controller (the rolling marble) at the place marked <span class="KeyTerm1">start</span>, after placing numbers in registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span>. When the controller reaches <span class="KeyTerm1">done</span>, we will find the value of the GCD in register <span class="KeyTerm1">a</span>.</p>
<section><a id="c5-title-0004"/>
<section>
<h5><a id="c5-sec-0004"/><a id="c5-title-0005"/>Exercise 5.1</h5>
<p class="paraaftertitle"><a id="c5-para-0017"/>Design a register machine to compute factorials using the iterative algorithm specified by the following function. Draw data-path and controller diagrams for this machine.</p>
<p class="Sp-text-1"><a id="c5-para-0018"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c5-para-0019"/>    <b>function</b> iter(product, counter) {</p>
<p class="Sp-text-1"><a id="c5-para-0020"/>    <b>return</b> counter &gt; n</p>
<p class="Sp-text-1"><a id="c5-para-0021"/>           ? product</p>
<p class="Sp-text-1"><a id="c5-para-0022"/>           : iter(counter * product,</p>
<p class="Sp-text-1"><a id="c5-para-0023"/>                  counter + 1);</p>
<p class="Sp-text-1"><a id="c5-para-0024"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0025"/>    <b>return</b> iter(1, 1);</p>
<p class="Sp-text-1"><a id="c5-para-0026"/>}</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0005"/><span>5.1.1</span> <a id="c5-title-0006"/>A Language for Describing Register Machines</h3>
<p class="paraaftertitle"><a id="c5-para-0027"/>Data-path and controller diagrams are adequate for representing simple machines such as GCD, but they are unwieldy for describing large machines such as a JavaScript interpreter. To make it possible to deal with complex machines, we will create a language that presents, in textual form, all the information given by the datapath and controller diagrams. We will start with a notation that directly mirrors the diagrams.</p>
<p><a id="c5-para-0028"/>We define the data paths of a machine by describing the registers and the operations. To describe a register, we give it a name and specify the buttons that control assignment to it. We give each of these buttons a name and specify the source of the data that enters the register under the button's control. (The source is a register, a constant, or an operation.) To describe an operation, we give it a name and specify its inputs (registers or constants).</p>
<p><a id="c5-para-0029"/>We define the controller of a machine as a sequence of <i>instructions</i> together with <i>labels</i> that identify <i>entry points</i> in the sequence. An instruction is one of the following:</p>
<ul style="list-style-type:disc">
<li>The name of a data-path button to push to assign a value to a register. (This corresponds to a box in the controller diagram.)</li>
<li>A <span class="KeyTerm1">test</span> instruction, which performs a specified test.</li>
<li>A conditional branch (<span class="KeyTerm1">branch</span> instruction) to a location indicated by a controller label, based on the result of the previous test. (The test and branch together correspond to a diamond in the controller diagram.) If the test is false, the controller should continue with the next instruction in the sequence. Otherwise, the controller should continue with the instruction after the label.</li>
<li>An unconditional branch (<span class="KeyTerm1">go_to</span> instruction) naming a controller label at which to continue execution.</li>
</ul>

<p class="paracontinue"><a id="c5-para-0034"/>The machine starts at the beginning of the controller instruction sequence and stops when execution reaches the end of the sequence. Except when a branch changes the flow of control, instructions are executed in the order in which they are listed.</p>
<p><a id="c5-para-0035"/><a id="c5-fig-0003a"/><a href="#c5-fig-0003">Figure 5.3</a> shows the GCD machine described in this way. This example only hints at the generality of these descriptions, since the GCD machine is a very simple case: Each register has only one button, and each button and test is used only once in the controller.</p>
<figure id="c5-fig-0003"><img alt="c5-fig-0003.jpg" src="../images/c5-fig-0003.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0003a">Figure 5.3</a></span> <a id="c5-para-0036"/>A specification of the GCD machine.</p></figcaption></figure>
<p><a id="c5-para-0037"/>Unfortunately, it is difficult to read such a description. In order to understand the controller instructions we must constantly refer back to the definitions of the button names and the operation names, and to understand what the buttons do we may have to refer to the definitions of the operation names. We will thus transform our notation to combine the information from the data-path and controller descriptions so that we see it all together.</p>
<p><a id="c5-para-0038"/>To obtain this form of description, we will replace the arbitrary button and operation names by the definitions of their behavior. That is, instead of saying (in the controller) “Push button <span class="KeyTerm1">t&lt;-r</span>” and separately saying (in the data paths) “Button <span class="KeyTerm1">t&lt;-r</span> assigns the value of the <span class="KeyTerm1">rem</span> operation to register <span class="KeyTerm1">t</span>” and “The <span class="KeyTerm1">rem</span> operation's inputs are the contents of registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span>,” we will say (in the controller) “Push the button that assigns to register <span class="KeyTerm1">t</span> the value of the <span class="KeyTerm1">rem</span> operation on the contents of registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span>.” Similarly, instead of saying (in the controller) “Perform the <span class="KeyTerm1">=</span> test” and separately saying (in the data paths) “The <span class="KeyTerm1">=</span> test operates on the contents of register <span class="KeyTerm1">b</span> and the constant 0,” we will say “Perform the <span class="KeyTerm1">=</span> test on the contents of register <span class="KeyTerm1">b</span> and the constant 0.” We will omit the data-path description, leaving only the controller sequence. Thus, the GCD machine is described as follows:</p>
<p class="Sp-text-1"><a id="c5-para-0039"/>controller(</p>
<p class="Sp-text-1"><a id="c5-para-0040"/>  list(</p>
<p class="Sp-text-1"><a id="c5-para-0041"/>    "test_b",</p>
<p class="Sp-text-1"><a id="c5-para-0042"/>      test(list(op("="), reg("b"), constant(0))),</p>
<p class="Sp-text-1"><a id="c5-para-0043"/>      branch(label("gcd_done")),</p>
<p class="Sp-text-1"><a id="c5-para-0044"/>      assign("t", list(op("rem"), reg("a"), reg("b"))),</p>
<p class="Sp-text-1"><a id="c5-para-0045"/>      assign("a", reg("b")),</p>
<p class="Sp-text-1"><a id="c5-para-0046"/>      assign("b", reg("t")),</p>
<p class="Sp-text-1"><a id="c5-para-0047"/>      go_to(label("test_b")),</p>
<p class="Sp-text-1"><a id="c5-para-0048"/>    "gcd_done"))</p>
<p><a id="c5-para-0049"/>This form of description is easier to read than the kind illustrated in <a href="#c5-fig-0003">figure 5.3</a>, but it also has disadvantages:</p>
<ul style="list-style-type:disc">
<li>It is more verbose for large machines, because complete descriptions of the datapath elements are repeated whenever the elements are mentioned in the controller instruction sequence. (This is not a problem in the GCD example, because each operation and button is used only once.) Moreover, repeating the data-path descriptions obscures the actual data-path structure of the machine; it is not obvious for a large machine how many registers, operations, and buttons there are and how they are interconnected.</li>
<li>Because the controller instructions in a machine definition look like JavaScript expressions, it is easy to forget that they are not arbitrary JavaScript expressions. They can notate only legal machine operations. For example, operations can operate directly only on constants and the contents of registers, not on the results of other operations.</li>
</ul>

<p class="paracontinue"><a id="c5-para-0052"/>In spite of these disadvantages, we will use this register-machine language throughout this chapter, because we will be more concerned with understanding controllers than with understanding the elements and connections in data paths. We should keep in mind, however, that data-path design is crucial in designing real machines.</p>
<section>
<h5><a id="c5-sec-0006"/><a id="c5-title-0007"/>Exercise 5.2</h5>
<p class="paraaftertitle"><a id="c5-para-0053"/>Use the register-machine language to describe the iterative factorial machine of exercise 5.1.</p>
</section>
<section>
<h5><a id="c5-sec-0007"/><a id="c5-title-0008"/>Actions</h5>
<p class="paraaftertitle"><a id="c5-para-0054"/>Let us modify the GCD machine so that we can type in the numbers whose GCD we want and get the answer printed. We will not discuss how to make a machine that can read and print, but will assume (as we do when we use <span class="KeyTerm1">prompt</span> and <span class="KeyTerm1">display</span> in JavaScript) that they are available as primitive operations.<a id="c5-fn-0002a"/><a href="#c5-fn-0002"><sup>2</sup></a></p>
<p><a id="c5-para-0055"/>The operation <span class="KeyTerm1">prompt</span> is like the operations we have been using in that it produces a value that can be stored in a register. But <span class="KeyTerm1">prompt</span> does not take inputs from any registers; its value depends on something that happens outside the parts of the</p>
<p class="paracontinue"><a id="c5-para-0056"/>machine we are designing. We will allow our machine's operations to have such behavior, and thus will draw and notate the use of <span class="KeyTerm1">prompt</span> just as we do any other operation that computes a value.</p>
<p><a id="c5-para-0057"/>The operation <span class="KeyTerm1">display</span>, on the other hand, differs from the operations we have been using in a fundamental way: It does not produce an output value to be stored in a register. Though it has an effect, this effect is not on a part of the machine we are designing. We will refer to this kind of operation as an <i>action</i>. We will represent an action in a data-path diagram just as we represent an operation that computes a value—as a trapezoid that contains the name of the action. Arrows point to the action box from any inputs (registers or constants). We also associate a button with the action. Pushing the button makes the action happen. To make a controller push an action button we use a new kind of instruction called <span class="KeyTerm1">perform</span>. Thus, the action of printing the contents of register <span class="KeyTerm1">a</span> is represented in a controller sequence by the instruction</p>
<p class="Sp-text-1"><a id="c5-para-0058"/>perform(list(op("display"), reg("a")))</p>
<p><a id="c5-para-0059"/><a id="c5-fig-0004a"/><a href="#c5-fig-0004">Figure 5.4</a> shows the data paths and controller for the new GCD machine. Instead of having the machine stop after printing the answer, we have made it start over, so that it repeatedly reads a pair of numbers, computes their GCD, and prints the result. This structure is like the driver loops we used in the interpreters of chapter 4.</p>
<figure id="c5-fig-0004"><img alt="c5-fig-0004.jpg" src="../images/c5-fig-0004.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0004a">Figure 5.4</a></span> <a id="c5-para-0060"/>A GCD machine that reads inputs and prints results.</p></figcaption></figure>
</section>
</section>
<section>
<h3><a id="c5-sec-0008"/><span>5.1.2</span> <a id="c5-title-0009"/>Abstraction in Machine Design</h3>
<p class="paraaftertitle"><a id="c5-para-0061"/>We will often define a machine to include “primitive” operations that are actually very complex. For example, in sections 5.4 and 5.5 we will treat JavaScript's environment manipulations as primitive. Such abstraction is valuable because it allows us to ignore the details of parts of a machine so that we can concentrate on other aspects of the design. The fact that we have swept a lot of complexity under the rug, however, does not mean that a machine design is unrealistic. We can always replace the complex “primitives” by simpler primitive operations.</p>
<p><a id="c5-para-0062"/>Consider the GCD machine. The machine has an instruction that computes the remainder of the contents of registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> and assigns the result to register <span class="KeyTerm1">t</span>. If we want to construct the GCD machine without using a primitive remainder operation, we must specify how to compute remainders in terms of simpler operations, such as subtraction. Indeed, we can write a JavaScript function that finds remainders in this way:</p>
<p class="Sp-text-1"><a id="c5-para-0063"/><b>function</b> remainder(n, d) {</p>
<p class="Sp-text-1"><a id="c5-para-0064"/>    <b>return</b> n &lt; d</p>
<p class="Sp-text-1"><a id="c5-para-0065"/>           ? n</p>
<p class="Sp-text-1"><a id="c5-para-0066"/>           : remainder(n - d, d);</p>
<p class="Sp-text-1"><a id="c5-para-0067"/>}</p>
<p class="paracontinue"><a id="c5-para-0068"/>We can thus replace the remainder operation in the GCD machine's data paths with a subtraction operation and a comparison test. <a id="c5-fig-0005a"/><a href="#c5-fig-0005">Figure 5.5</a> shows the data paths and controller for the elaborated machine. The instruction</p>
<p class="Sp-text-1"><a id="c5-para-0070"/>assign("t", list(op("rem"), reg("a"), reg("b")))</p>
<p class="paracontinue"><a id="c5-para-0071"/>in the GCD controller definition is replaced by a sequence of instructions that contains a loop, as shown in <a id="c5-fig-0006a"/><a href="#c5-fig-0006">figure 5.6</a>.</p>
<figure id="c5-fig-0005"><img alt="c5-fig-0005.jpg" src="../images/c5-fig-0005.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0005a">Figure 5.5</a></span> <a id="c5-para-0069"/>Data paths and controller for the elaborated GCD machine.</p></figcaption></figure>
<figure id="c5-fig-0006"><img alt="c5-fig-0006.jpg" src="../images/c5-fig-0006.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0006a">Figure 5.6</a></span> <a id="c5-para-0072"/>Controller instruction sequence for the GCD machine in <a href="#c5-fig-0005">figure 5.5</a>.</p></figcaption></figure>
<section>
<h5><a id="c5-sec-0009"/><a id="c5-title-0010"/>Exercise 5.3</h5>
<p class="paraaftertitle"><a id="c5-para-0073"/>Design a machine to compute square roots using Newton's method, as described in section 1.1.7 and implemented with the following code in section 1.1.8:</p>
<p class="Sp-text-1"><a id="c5-para-0074"/><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c5-para-0075"/>    <b>function</b> is_good_enough(guess) {</p>
<p class="Sp-text-1"><a id="c5-para-0076"/>        <b>return</b> math_abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c5-para-0077"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0078"/>    <b>function</b> improve(guess) {</p>
<p class="Sp-text-1"><a id="c5-para-0079"/>        <b>return</b> average(guess, x / guess);</p>
<p class="Sp-text-1"><a id="c5-para-0080"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0081"/>    <b>function</b> sqrt_iter(guess) {</p>
<p class="Sp-text-1"><a id="c5-para-0082"/>        <b>return</b> is_good_enough(guess)</p>
<p class="Sp-text-1"><a id="c5-para-0083"/>               ? guess</p>
<p class="Sp-text-1"><a id="c5-para-0084"/>           : sqrt_iter(improve(guess));</p>
<p class="Sp-text-1"><a id="c5-para-0085"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0086"/>    <b>return</b> sqrt_iter(1);</p>
<p class="Sp-text-1"><a id="c5-para-0087"/>}</p>
<p class="paracontinue"><a id="c5-para-0088"/>Begin by assuming that <span class="KeyTerm1">is_good_enough</span> and <span class="KeyTerm1">improve</span> operations are available as primitives. Then show how to expand these in terms of arithmetic operations. Describe each version of the <span class="KeyTerm1">sqrt</span> machine design by drawing a data-path diagram and writing a controller definition in the register-machine language.</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0010"/><span>5.1.3</span> <a id="c5-title-0011"/>Subroutines</h3>
<p class="paraaftertitle"><a id="c5-para-0089"/>When designing a machine to perform a computation, we would often prefer to arrange for components to be shared by different parts of the computation rather than duplicate the components. Consider a machine that includes two GCD computations—one that finds the GCD of the contents of registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> and one that finds the GCD of the contents of registers <span class="KeyTerm1">c</span> and <span class="KeyTerm1">d</span>. We might start by assuming we have a primitive <span class="KeyTerm1">gcd</span> operation, then expand the two instances of <span class="KeyTerm1">gcd</span> in terms of more primitive operations. <a id="c5-fig-0007a"/><a href="#c5-fig-0007">Figure 5.7</a> shows just the GCD portions of the resulting machine's data paths, without showing how they connect to the rest of the machine. The figure also shows the corresponding portions of the machine's controller sequence.</p>
<figure id="c5-fig-0007"><img alt="c5-fig-0007.jpg" src="../images/c5-fig-0007.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0007a">Figure 5.7</a></span> <a id="c5-para-0090"/>Portions of the data paths and controller sequence for a machine with two GCD computations.</p></figcaption></figure>
<p><a id="c5-para-0091"/>This machine has two remainder operation boxes and two boxes for testing equality. If the duplicated components are complicated, as is the remainder box, this will not be an economical way to build the machine. We can avoid duplicating the data-path components by using the same components for both GCD computations, provided that doing so will not affect the rest of the larger machine's computation. If the values in registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> are not needed by the time the controller gets to <span class="KeyTerm1">gcd_2</span> (or if these values can be moved to other registers for safekeeping), we can change the machine so that it uses registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span>, rather than registers <span class="KeyTerm1">c</span> and <span class="KeyTerm1">d</span>, in computing the second GCD as well as the first. If we do this, we obtain the controller sequence shown in <a id="c5-fig-0008a"/><a href="#c5-fig-0008">figure 5.8</a>.</p>
<figure id="c5-fig-0008"><img alt="c5-fig-0008.jpg" src="../images/c5-fig-0008.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0008a">Figure 5.8</a></span> <a id="c5-para-0092"/>Portions of the controller sequence for a machine that uses the same datapath components for two different GCD computations.</p></figcaption></figure>
<p><a id="c5-para-0093"/>We have removed the duplicate data-path components (so that the data paths are again as in <a href="#c5-fig-0001">figure 5.1</a>), but the controller now has two GCD sequences that differ only in their entry-point labels. It would be better to replace these two sequences by branches to a single sequence—a <span class="KeyTerm1">gcd</span> <i>subroutine</i>—at the end of which we branch back to the correct place in the main instruction sequence. We can accomplish this as follows: Before branching to <span class="KeyTerm1">gcd</span>, we place a distinguishing value (such as 0 or 1) into a special register, <span class="KeyTerm1">continue</span>. At the end of the <span class="KeyTerm1">gcd</span> subroutine we return either to <span class="KeyTerm1">after_gcd_1</span> or to <span class="KeyTerm1">after_gcd_2</span>, depending on the value of the <span class="KeyTerm1">continue</span> register. <a id="c5-fig-0009a"/><a href="#c5-fig-0009">Figure 5.9</a> shows the relevant portion of the resulting controller sequence, which includes only a single copy of the <span class="KeyTerm1">gcd</span> instructions.</p>
<figure id="c5-fig-0009"><img alt="c5-fig-0009.jpg" src="../images/c5-fig-0009.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0009a">Figure 5.9</a></span> <a id="c5-para-0094"/>Using a <span class="KeyTerm1">continue</span> register to avoid the duplicate controller sequence in <a href="#c5-fig-0008">figure 5.8</a>.</p></figcaption></figure>
<p><a id="c5-para-0095"/>This is a reasonable approach for handling small problems, but it would be awkward if there were many instances of GCD computations in the controller sequence. To decide where to continue executing after the <span class="KeyTerm1">gcd</span> subroutine, we would need tests in the data paths and branch instructions in the controller for all the places that use <span class="KeyTerm1">gcd</span>. A more powerful method for implementing subroutines is to have the <span class="KeyTerm1">continue</span> register hold the label of the entry point in the controller sequence at which execution should continue when the subroutine is finished. Implementing this strategy requires a new kind of connection between the data paths and the controller of a register machine: There must be a way to assign to a register a label in the controller sequence in such a way that this value can be fetched from the register and used to continue execution at the designated entry point.</p>
<p><a id="c5-para-0096"/>To reflect this ability, we will extend the <span class="KeyTerm1">assign</span> instruction of the registermachine language to allow a register to be assigned as value a label from the controller sequence (as a special kind of constant). We will also extend the <span class="KeyTerm1">go_to</span> instruction to allow execution to continue at the entry point described by the contents of a register rather than only at an entry point described by a constant label. Using these new constructs we can terminate the <span class="KeyTerm1">gcd</span> subroutine with a branch to the location stored in the <span class="KeyTerm1">continue</span> register. This leads to the controller sequence shown in <a id="c5-fig-0010a"/><a href="#c5-fig-0010">figure 5.10</a>.</p>
<figure id="c5-fig-0010"><img alt="c5-fig-0010.jpg" src="../images/c5-fig-0010.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0010a">Figure 5.10</a></span> <a id="c5-para-0098"/>Assigning labels to the <span class="KeyTerm1">continue</span> register simplifies and generalizes the strategy shown in <a href="#c5-fig-0009">figure 5.9</a>.</p></figcaption></figure>
<p><a id="c5-para-0099"/>A machine with more than one subroutine could use multiple continuation registers (e.g., <span class="KeyTerm1">gcd_continue</span>, <span class="KeyTerm1">factorial_continue</span>) or we could have all subroutines share a single <span class="KeyTerm1">continue</span> register. Sharing is more economical, but we must be careful if we have a subroutine (<span class="KeyTerm1">sub1</span>) that calls another subroutine (<span class="KeyTerm1">sub2</span>). Unless <span class="KeyTerm1">sub1</span> saves the contents of <span class="KeyTerm1">continue</span> in some other register before setting up <span class="KeyTerm1">continue</span> for the call to <span class="KeyTerm1">sub2</span>, <span class="KeyTerm1">sub1</span> will not know where to go when it is finished. The mechanism developed in the next section to handle recursion also provides a better solution to this problem of nested subroutine calls.</p>
</section>
<section>
<h3><a id="c5-sec-0011"/><span>5.1.4</span> <a id="c5-title-0012"/>Using a Stack to Implement Recursion</h3>
<p class="paraaftertitle"><a id="c5-para-0100"/>With the ideas illustrated so far, we can implement any iterative process by specifying a register machine that has a register corresponding to each state variable of the process. The machine repeatedly executes a controller loop, changing the contents of the registers, until some termination condition is satisfied. At each point in the controller sequence, the state of the machine (representing the state of the iterative process) is completely determined by the contents of the registers (the values of the state variables).</p>
<p><a id="c5-para-0101"/>Implementing recursive processes, however, requires an additional mechanism. Consider the following recursive method for computing factorials, which we first examined in section 1.2.1:</p>
<p class="Sp-text-1"><a id="c5-para-0102"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c5-para-0103"/>    <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c5-para-0104"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-0105"/>           : n * factorial(n - 1);</p>
<p class="Sp-text-1"><a id="c5-para-0106"/>}</p>
<p class="paracontinue"><a id="c5-para-0107"/>As we see from the function, computing <i>n</i>! requires computing (<i>n</i> – 1)!. Our GCD machine, modeled on the function</p>
<p class="Sp-text-1"><a id="c5-para-0108"/><b>function</b> gcd(a, b) {</p>
<p class="Sp-text-1"><a id="c5-para-0109"/>    <b>return</b> b === 0 ? a : gcd(b, a % b);</p>
<p class="Sp-text-1"><a id="c5-para-0110"/>}</p>
<p class="paracontinue"><a id="c5-para-0111"/>similarly had to compute another GCD. But there is an important difference between the <span class="KeyTerm1">gcd</span> function, which reduces the original computation to a new GCD computation, and <span class="KeyTerm1">factorial</span>, which requires computing another factorial as a subproblem. In GCD, the answer to the new GCD computation is the answer to the original problem. To compute the next GCD, we simply place the new arguments in the input registers of the GCD machine and reuse the machine's data paths by executing the same controller sequence. When the machine is finished solving the final GCD problem, it has completed the entire computation.</p>
<p><a id="c5-para-0112"/>In the case of factorial (or any recursive process) the answer to the new factorial subproblem is not the answer to the original problem. The value obtained for (<i>n</i> – 1)! must be multiplied by <i>n</i> to get the final answer. If we try to imitate the GCD design, and solve the factorial subproblem by decrementing the <span class="KeyTerm1">n</span> register and rerunning the factorial machine, we will no longer have available the old value of <span class="KeyTerm1">n</span> by which to multiply the result. We thus need a second factorial machine to work on the</p>
<p class="paracontinue"><a id="c5-para-0113"/>subproblem. This second factorial computation itself has a factorial subproblem, which requires a third factorial machine, and so on. Since each factorial machine contains another factorial machine within it, the total machine contains an infinite nest of similar machines and hence cannot be constructed from a fixed, finite number of parts.</p>
<p><a id="c5-para-0114"/>Nevertheless, we can implement the factorial process as a register machine if we can arrange to use the same components for each nested instance of the machine. Specifically, the machine that computes <i>n</i>! should use the same components to work on the subproblem of computing (<i>n</i> – 1)!, on the subproblem for (<i>n</i> – 2)!, and so on. This is plausible because, although the factorial process dictates that an unbounded number of copies of the same machine are needed to perform a computation, only one of these copies needs to be active at any given time. When the machine encounters a recursive subproblem, it can suspend work on the main problem, reuse the same physical parts to work on the subproblem, then continue the suspended computation.</p>
<p><a id="c5-para-0115"/>In the subproblem, the contents of the registers will be different than they were in the main problem. (In this case the <span class="KeyTerm1">n</span> register is decremented.) In order to be able to continue the suspended computation, the machine must save the contents of any registers that will be needed after the subproblem is solved so that these can be restored to continue the suspended computation. In the case of factorial, we will save the old value of <span class="KeyTerm1">n</span>, to be restored when we are finished computing the factorial of the decremented <span class="KeyTerm1">n</span> register.<a id="c5-fn-0003a"/><a href="#c5-fn-0003"><sup>3</sup></a></p>
<p><a id="c5-para-0116"/>Since there is no a priori limit on the depth of nested recursive calls, we may need to save an arbitrary number of register values. These values must be restored in the reverse of the order in which they were saved, since in a nest of recursions the last subproblem to be entered is the first to be finished. This dictates the use of a <i>stack</i>, or “last in, first out” data structure, to save register values. We can extend the register-machine language to include a stack by adding two kinds of instructions: Values are placed on the stack using a <span class="KeyTerm1">save</span> instruction and restored from the stack using a <span class="KeyTerm1">restore</span> instruction. After a sequence of values has been <span class="KeyTerm1">save</span>d on the stack, a sequence of <span class="KeyTerm1">restore</span>s will retrieve these values in reverse order.<a id="c5-fn-0004a"/><a href="#c5-fn-0004"><sup>4</sup></a></p>
<p><a id="c5-para-0117"/>With the aid of the stack, we can reuse a single copy of the factorial machine's data paths for each factorial subproblem. There is a similar design issue in reusing the controller sequence that operates the data paths. To reexecute the factorial computation, the controller cannot simply loop back to the beginning, as with an iterative process, because after solving the (<i>n</i> – 1)! subproblem the machine must still multiply the result by <i>n</i>. The controller must suspend its computation of <i>n</i>!, solve the (<i>n</i> – 1)! subproblem, then continue its computation of <i>n</i>!. This view of the factorial computation suggests the use of the subroutine mechanism described in section 5.1.3, which has the controller use a <span class="KeyTerm1">continue</span> register to transfer to the part of the sequence that solves a subproblem and then continue where it left off on the main problem. We can thus make a factorial subroutine that returns to the entry point stored in the <span class="KeyTerm1">continue</span> register. Around each subroutine call, we save and restore <span class="KeyTerm1">continue</span> just as we do the <span class="KeyTerm1">n</span> register, since each “level” of the factorial computation will use the same <span class="KeyTerm1">continue</span> register. That is, the factorial subroutine must put a new value in <span class="KeyTerm1">continue</span> when it calls itself for a subproblem, but it will need the old value in order to return to the place that called it to solve a subproblem.</p>
<p><a id="c5-para-0118"/><a id="c5-fig-0011a"/><a href="#c5-fig-0011">Figure 5.11</a> shows the data paths and controller for a machine that implements the recursive <span class="KeyTerm1">factorial</span> function. The machine has a stack and three registers, called <span class="KeyTerm1">n</span>, <span class="KeyTerm1">val</span>, and <span class="KeyTerm1">continue</span>. To simplify the data-path diagram, we have not named the register-assignment buttons, only the stack-operation buttons (<span class="KeyTerm1">sc</span> and <span class="KeyTerm1">sn</span> to save registers, <span class="KeyTerm1">rc</span> and <span class="KeyTerm1">rn</span> to restore registers). To operate the machine, we put in register <span class="KeyTerm1">n</span> the number whose factorial we wish to compute and start the machine. When the machine reaches <span class="KeyTerm1">fact_done</span>, the computation is finished and the answer will be found in the <span class="KeyTerm1">val</span> register. In the controller sequence, <span class="KeyTerm1">n</span> and <span class="KeyTerm1">continue</span> are saved before each recursive call and restored upon return from the call. Returning from a call is accomplished by branching to the location stored in <span class="KeyTerm1">continue</span>. The register <span class="KeyTerm1">continue</span> is initialized when the machine starts so that the last return will go to <span class="KeyTerm1">fact_done</span>. The <span class="KeyTerm1">val</span> register, which holds the result of the factorial computation, is not saved before the recursive call, because the old contents of <span class="KeyTerm1">val</span> is not useful after the subroutine returns. Only the new value, which is the value produced by the subcomputation, is needed.</p>
<figure id="c5-fig-0011"><img alt="c5-fig-0011.jpg" src="../images/c5-fig-0011.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0011a">Figure 5.11</a></span> <a id="c5-para-0119"/>A recursive factorial machine.</p></figcaption></figure>
<p><a id="c5-para-0120"/>Although in principle the factorial computation requires an infinite machine, the machine in <a href="#c5-fig-0011">figure 5.11</a> is actually finite except for the stack, which is potentially unbounded. Any particular physical implementation of a stack, however, will be of finite size, and this will limit the depth of recursive calls that can be handled by the machine. This implementation of factorial illustrates the general strategy for realizing recursive algorithms as ordinary register machines augmented by stacks. When a recursive subproblem is encountered, we save on the stack the registers whose current values will be required after the subproblem is solved, solve the recursive subproblem, then restore the saved registers and continue execution on the main problem. The <span class="KeyTerm1">continue</span> register must always be saved. Whether there are other registers that need to be saved depends on the particular machine, since not all recursive computations need the original values of registers that are modified during solution of the subproblem (see exercise 5.4).</p>
<section>
<h5><a id="c5-sec-0012"/><a id="c5-title-0013"/>A double recursion</h5>
<p class="paraaftertitle"><a id="c5-para-0121"/>Let us examine a more complex recursive process, the tree-recursive computation of the Fibonacci numbers, which we introduced in section 1.2.2:</p>
<p class="Sp-text-1"><a id="c5-para-0122"/><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c5-para-0123"/>    <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c5-para-0124"/>           ? 0</p>
<p class="Sp-text-1"><a id="c5-para-0125"/>           : n === 1</p>
<p class="Sp-text-1"><a id="c5-para-0126"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-0127"/>           : fib(n - 1) + fib(n - 2);</p>
<p class="Sp-text-1"><a id="c5-para-0128"/>}</p>
<p class="paracontinue"><a id="c5-para-0129"/>Just as with factorial, we can implement the recursive Fibonacci computation as a register machine with registers <span class="KeyTerm1">n</span>, <span class="KeyTerm1">val</span>, and <span class="KeyTerm1">continue</span>. The machine is more complex than the one for factorial, because there are two places in the controller sequence where we need to perform recursive calls—once to compute Fib(<i>n</i> – 1) and once to compute Fib(<i>n</i> – 2). To set up for each of these calls, we save the registers whose values will be needed later, set the <span class="KeyTerm1">n</span> register to the number whose Fib we need to compute recursively (<i>n</i> – 1 or <i>n</i> – 2), and assign to <span class="KeyTerm1">continue</span> the entry point in the main sequence to which to return (<span class="KeyTerm1">afterfib_n_1</span> or <span class="KeyTerm1">afterfib_n_2</span>, respectively). We then go to <span class="KeyTerm1">fib_loop</span>. When we return from the recursive call, the answer is in <span class="KeyTerm1">val</span>. <a id="c5-fig-0012a"/><a href="#c5-fig-0012">Figure 5.12</a> shows the controller sequence for this machine.</p>
<figure id="c5-fig-0012"><img alt="c5-fig-0012.jpg" src="../images/c5-fig-0012.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0012a">Figure 5.12</a></span> <a id="c5-para-0130"/>Controller for a machine to compute Fibonacci numbers.</p></figcaption></figure>
</section>
<section>
<h5><a id="c5-sec-0013"/><a id="c5-title-0014"/>Exercise 5.4</h5>
<p class="paraaftertitle"><a id="c5-para-0131"/>Specify register machines that implement each of the following functions. For each machine, write a controller instruction sequence and draw a diagram showing the data paths.</p>
<ol class="BS_NumberListA">
<li><a id="c5-li-0007"/><span>a. </span>Recursive exponentiation:
<p class="Sp-text-1"><a id="c5-para-0133"/><b>function</b> expt(b, n) {</p>
<p class="Sp-text-1"><a id="c5-para-0134"/>    <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c5-para-0135"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-0136"/>           : b * expt(b, n - 1);</p>
<p class="Sp-text-1"><a id="c5-para-0137"/>}</p></li>
<li><a id="c5-li-0008"/><span>b. </span>Iterative exponentiation:
<p class="Sp-text-1"><a id="c5-para-0139"/><b>function</b> expt(b, n) {</p>
<p class="Sp-text-1"><a id="c5-para-0140"/>    <b>function</b> expt_iter(counter, product) {</p>
<p class="Sp-text-1"><a id="c5-para-0141"/>        <b>return</b> counter === 0</p>
<p class="Sp-text-1"><a id="c5-para-0142"/>               ? product</p>
<p class="Sp-text-1"><a id="c5-para-0143"/>               : expt_iter(counter - 1, b * product);</p>
<p class="Sp-text-1"><a id="c5-para-0144"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0145"/>    <b>return</b> expt_iter(n, 1);</p>
<p class="Sp-text-1"><a id="c5-para-0146"/>}</p></li>
</ol>
</section>
<section>
<h5><a id="c5-sec-0014"/><a id="c5-title-0015"/>Exercise 5.5</h5>
<p class="paraaftertitle"><a id="c5-para-0147"/>Hand-simulate the factorial and Fibonacci machines, using some nontrivial input (requiring execution of at least one recursive call). Show the contents of the stack at each significant point in the execution.</p>
</section>
<section>
<h5><a id="c5-sec-0015"/><a id="c5-title-0016"/>Exercise 5.6</h5>
<p class="paraaftertitle"><a id="c5-para-0148"/>Ben Bitdiddle observes that the Fibonacci machine's controller sequence has an extra <span class="KeyTerm1">save</span> and an extra <span class="KeyTerm1">restore</span>, which can be removed to make a faster machine. Where are these instructions?</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0016"/><span>5.1.5</span> <a id="c5-title-0017"/>Instruction Summary</h3>
<p class="paraaftertitle"><a id="c5-para-0149"/>A controller instruction in our register-machine language has one of the following forms, where each <i>input<sub>i</sub></i> is <span class="KeyTerm1">reg(</span><i>register</i>-<i>name</i><span class="KeyTerm1">)</span> or <span class="KeyTerm1">constant(</span><i>constant</i>-<i>value</i><span class="KeyTerm1">)</span>.</p>
<p><a id="c5-para-0150"/>These instructions were introduced in section 5.1.1:</p>
<p class="Sp-text-1"><a id="c5-para-0151"/>assign(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>, reg(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0152"/>assign(<span class="KeyTerm2"><i>register-name</i></span>, constant(<span class="KeyTerm2"><i>constant-value</i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0153"/>assign(<span class="KeyTerm2">register-name</span>, list(op(<span class="KeyTerm2"><i>operation-name</i></span>), <span class="KeyTerm2"><i>input</i><sub>1</sub></span>, . . ., <span class="KeyTerm2"><i>input<sub>n</sub></i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0154"/>perform(list(op(<span class="KeyTerm2"><i>operation-name</i></span>), <span class="KeyTerm2"><i>input</i><sub>1</sub></span>, . . ., <span class="KeyTerm2"><i>input<sub>n</sub></i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0155"/>test(list(op(<span class="KeyTerm2"><i>operation-name</i></span>), <span class="KeyTerm2"><i>input</i><sub>1</sub></span>, . . ., <span class="KeyTerm2"><i>input<sub>n</sub></i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0156"/>branch(label(<span class="KeyTerm2"><i>label-name</i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0157"/>go_to(label(<span class="KeyTerm2"><i>label-name</i></span>))</p>
<p><a id="c5-para-0158"/>The use of registers to hold labels was introduced in section 5.1.3:</p>
<p class="Sp-text-1"><a id="c5-para-0159"/>assign(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>, label(<span class="KeyTerm2"><i>label</i>-<i>name</i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0160"/>go_to(reg(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>))</p>
<p><a id="c5-para-0161"/>Instructions to use the stack were introduced in section 5.1.4:</p>
<p class="Sp-text-1"><a id="c5-para-0162"/>save(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>)</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0163"/>restore(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>)</p>
<p><a id="c5-para-0164"/>The only kind of <i>constant</i>-<i>value</i> we have seen so far is a number, but later we will also use strings and lists. For example, <span class="KeyTerm1">constant("abc")</span> is the string <span class="KeyTerm1">"abc"</span>, <span class="KeyTerm1">constant(<b>null</b>)</span> is the empty list, and <span class="KeyTerm1">constant(list("a", "b", "c"))</span> is the list <span class="KeyTerm1">list("a", "b", "c")</span>.</p>
</section>
</section>
<section>
<h2><a id="c5-sec-0017"/><span>5.2</span> <a id="c5-title-0018"/>A Register-Machine Simulator</h2>
<p class="paraaftertitle"><a id="c5-para-0165"/>In order to gain a good understanding of the design of register machines, we must test the machines we design to see if they perform as expected. One way to test a design is to hand-simulate the operation of the controller, as in exercise 5.5. But this is extremely tedious for all but the simplest machines. In this section we construct a simulator for machines described in the register-machine language. The simulator is a JavaScript program with four interface functions. The first uses a description of a register machine to construct a model of the machine (a data structure whose parts correspond to the parts of the machine to be simulated), and the other three allow us to simulate the machine by manipulating the model:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">make_machine(</span><i>register</i>-<i>names</i>, <i>operations</i>, <i>controller</i>)
<p class="paracontinue"><a id="c5-para-0167"/>constructs and returns a model of the machine with the given registers, operations, and controller.</p></li>
<li><span class="KeyTerm1">set_register_contents</span>(<i>machine</i>-<i>model</i>, <i>register</i>-<i>name</i>, <i>value</i>)
<p class="paracontinue"><a id="c5-para-0169"/>stores a value in a simulated register in the given machine.</p></li>
<li><span class="KeyTerm1">get_register_contents</span>(<i>machine</i>-<i>model</i>, <i>register</i>-<i>name</i>)
<p class="paracontinue"><a id="c5-para-0171"/>returns the contents of a simulated register in the given machine.</p></li>
<li><span class="KeyTerm1">start</span>(<i>machine</i>-<i>model</i>)
<p class="paracontinue"><a id="c5-para-0173"/>simulates the execution of the given machine, starting from the beginning of the controller sequence and stopping when it reaches the end of the sequence.</p></li>
</ul>

<p><a id="c5-para-0174"/>As an example of how these functions are used, we can define <span class="KeyTerm1">gcd_machine</span> to be a model of the GCD machine of section 5.1.1 as follows:</p>
<p class="Sp-text-1"><a id="c5-para-0175"/><b>const</b> gcd_machine =</p>
<p class="Sp-text-1"><a id="c5-para-0176"/>    make_machine(</p>
<p class="Sp-text-1"><a id="c5-para-0177"/>        list("a", "b", "t"),</p>
<p class="Sp-text-1"><a id="c5-para-0178"/>        list(list("rem", (a, b) =&gt; a % b),</p>
<p class="Sp-text-1"><a id="c5-para-0179"/>         list("=", (a, b) =&gt; a === b)),</p>
<p class="Sp-text-1"><a id="c5-para-0180"/>        list(</p>
<p class="Sp-text-1"><a id="c5-para-0181"/>          "test_b",</p>
<p class="Sp-text-1"><a id="c5-para-0182"/>            test(list(op("="), reg("b"), constant(0))),</p>
<p class="Sp-text-1"><a id="c5-para-0183"/>            branch(label("gcd_done")),</p>
<p class="Sp-text-1"><a id="c5-para-0184"/>            assign("t", list(op("rem"), reg("a"), reg("b"))),</p>
<p class="Sp-text-1"><a id="c5-para-0185"/>            assign("a", reg("b")),</p>
<p class="Sp-text-1"><a id="c5-para-0186"/>            assign("b", reg("t")),</p>
<p class="Sp-text-1"><a id="c5-para-0187"/>            go_to(label("test_b")),</p>
<p class="Sp-text-1"><a id="c5-para-0188"/>      "gcd_done"));</p>
<p class="paracontinue"><a id="c5-para-0189"/>The first argument to <span class="KeyTerm1">make_machine</span> is a list of register names. The next argument is a table (a list of two-element lists) that pairs each operation name with a JavaScript function that implements the operation (that is, produces the same output value given the same input values). The last argument specifies the controller as a list of labels and machine instructions, as in section 5.1.</p>
<p><a id="c5-para-0190"/>To compute GCDs with this machine, we set the input registers, start the machine, and examine the result when the simulation terminates:</p>
<p class="Sp-text-1"><a id="c5-para-0191"/>set_register_contents(gcd_machine, "a", 206);</p>
<p class="Sp-text-1"><a id="c5-para-0192"/><i>"done"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0193"/>set_register_contents(gcd_machine, "b", 40);</p>
<p class="Sp-text-1"><a id="c5-para-0194"/><i>"done"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0195"/>start(gcd_machine);</p>
<p class="Sp-text-1"><a id="c5-para-0196"/><i>"done"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0197"/>get_register_contents(gcd_machine, "a");</p>
<p class="Sp-text-1"><a id="c5-para-0198"/><i>2</i></p>
<p class="paracontinue"><a id="c5-para-0199"/>This computation will run much more slowly than a <span class="KeyTerm1">gcd</span> function written in JavaScript, because we will simulate low-level machine instructions, such as <span class="KeyTerm1">assign</span>, by much more complex operations.</p>
<section><a id="c5-title-0019"/>
<section>
<h5><a id="c5-sec-0019"/><a id="c5-title-0020"/>Exercise 5.7</h5>
<p class="paraaftertitle"><a id="c5-para-0200"/>Use the simulator to test the machines you designed in exercise 5.4.</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0020"/><span>5.2.1</span> <a id="c5-title-0021"/>The Machine Model</h3>
<p class="paraaftertitle"><a id="c5-para-0201"/>The machine model generated by <span class="KeyTerm1">make_machine</span> is represented as a function with local state using the message-passing techniques developed in chapter 3. To build this model, <span class="KeyTerm1">make_machine</span> begins by calling the function <span class="KeyTerm1">make_new_machine</span> to construct the parts of the machine model that are common to all register machines. This basic machine model constructed by <span class="KeyTerm1">make_new_machine</span> is essentially a container for some registers and a stack, together with an execution mechanism that processes the controller instructions one by one.</p>
<p><a id="c5-para-0202"/>The function <span class="KeyTerm1">make_machine</span> then extends this basic model (by sending it messages) to include the registers, operations, and controller of the particular machine being defined. First it allocates a register in the new machine for each of the supplied register names and installs the designated operations in the machine. Then it uses an <i>assembler</i> (described below in section 5.2.2) to transform the controller list into instructions for the new machine and installs these as the machine's instruction sequence. The function <span class="KeyTerm1">make_machine</span> returns as its value the modified machine model.</p>
<p class="Sp-text-1"><a id="c5-para-0203"/><b>function</b> make_machine(register_names, ops, controller) {</p>
<p class="Sp-text-1"><a id="c5-para-0204"/>    <b>const</b> machine = make_new_machine();</p>
<p class="Sp-text-1"><a id="c5-para-0205"/>    for_each(register_name =&gt;</p>
<p class="Sp-text-1"><a id="c5-para-0206"/>               machine("allocate_register")(register_name),</p>
<p class="Sp-text-1"><a id="c5-para-0207"/>             register_names);</p>
<p class="Sp-text-1"><a id="c5-para-0208"/>    machine("install_operations")(ops);</p>
<p class="Sp-text-1"><a id="c5-para-0209"/>    machine("install_instruction_sequence")</p>
<p class="Sp-text-1"><a id="c5-para-0210"/>           (assemble(controller, machine));</p>
<p class="Sp-text-1"><a id="c5-para-0211"/>    <b>return</b> machine;</p>
<p class="Sp-text-1"><a id="c5-para-0212"/>}</p>
<section>
<h5><a id="c5-sec-0021"/><a id="c5-title-0022"/>Registers</h5>
<p class="paraaftertitle"><a id="c5-para-0213"/>We will represent a register as a function with local state, as in chapter 3. The function <span class="KeyTerm1">make_register</span> creates a register that holds a value that can be accessed or changed:</p>
<p class="Sp-text-1"><a id="c5-para-0214"/><b>function</b> make_register(name) {</p>
<p class="Sp-text-1"><a id="c5-para-0215"/>    <b>let</b> contents = "*unassigned*";</p>
<p class="Sp-text-1"><a id="c5-para-0216"/>    <b>function</b> dispatch(message) {</p>
<p class="Sp-text-1"><a id="c5-para-0217"/>        <b>return</b> message === "get"</p>
<p class="Sp-text-1"><a id="c5-para-0218"/>               ? contents</p>
<p class="Sp-text-1"><a id="c5-para-0219"/>               : message === "set"</p>
<p class="Sp-text-1"><a id="c5-para-0220"/>               ? value =&gt; { contents = value; }</p>
<p class="Sp-text-1"><a id="c5-para-0221"/>               : error(message, "unknown request – make_register");</p>
<p class="Sp-text-1"><a id="c5-para-0222"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0223"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c5-para-0224"/>}</p>
<p class="paracontinue"><a id="c5-para-0225"/>The following functions are used to access registers:</p>
<p class="Sp-text-1"><a id="c5-para-0226"/><b>function</b> get_contents(register) {</p>
<p class="Sp-text-1"><a id="c5-para-0227"/>    <b>return</b> register("get");</p>
<p class="Sp-text-1"><a id="c5-para-0228"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0229"/><b>function</b> set_contents(register, value) {</p>
<p class="Sp-text-1"><a id="c5-para-0230"/>    <b>return</b> register("set")(value);</p>
<p class="Sp-text-1"><a id="c5-para-0231"/>}</p>
</section>
<section>
<h5><a id="c5-sec-0022"/><a id="c5-title-0023"/>The stack</h5>
<p class="paraaftertitle"><a id="c5-para-0232"/>We can also represent a stack as a function with local state. The function <span class="KeyTerm1">make_ stack</span> creates a stack whose local state consists of a list of the items on the stack. A stack accepts requests to <span class="KeyTerm1">push</span> an item onto the stack, to <span class="KeyTerm1">pop</span> the top item off the stack and return it, and to <span class="KeyTerm1">initialize</span> the stack to empty.</p>
<p class="Sp-text-1"><a id="c5-para-0233"/><b>function</b> make_stack() {</p>
<p class="Sp-text-1"><a id="c5-para-0234"/>    <b>let</b> stack = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c5-para-0235"/>    <b>function</b> push(x) {</p>
<p class="Sp-text-1"><a id="c5-para-0236"/>        stack = pair(x, stack);</p>
<p class="Sp-text-1"><a id="c5-para-0237"/>        <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c5-para-0238"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0239"/>    <b>function</b> pop() {</p>
<p class="Sp-text-1"><a id="c5-para-0240"/>        <b>if</b> (is_null(stack)) {</p>
<p class="Sp-text-1"><a id="c5-para-0241"/>            error("empty stack – pop");</p>
<p class="Sp-text-1"><a id="c5-para-0242"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c5-para-0243"/>            <b>const</b> top = head(stack);</p>
<p class="Sp-text-1"><a id="c5-para-0244"/>            stack = tail(stack);</p>
<p class="Sp-text-1"><a id="c5-para-0245"/>            <b>return</b> top;</p>
<p class="Sp-text-1"><a id="c5-para-0246"/>        }</p>
<p class="Sp-text-1"><a id="c5-para-0247"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0248"/>    <b>function</b> initialize() {</p>
<p class="Sp-text-1"><a id="c5-para-0249"/>        stack = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c5-para-0250"/>        <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c5-para-0251"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0252"/>    <b>function</b> dispatch(message) {</p>
<p class="Sp-text-1"><a id="c5-para-0253"/>        <b>return</b> message === "push"</p>
<p class="Sp-text-1"><a id="c5-para-0254"/>               ? push</p>
<p class="Sp-text-1"><a id="c5-para-0255"/>               : message === "pop"</p>
<p class="Sp-text-1"><a id="c5-para-0256"/>               ? pop()</p>
<p class="Sp-text-1"><a id="c5-para-0257"/>               : message === "initialize"</p>
<p class="Sp-text-1"><a id="c5-para-0258"/>               ? initialize()</p>
<p class="Sp-text-1"><a id="c5-para-0259"/>               : error(message, "unknown request – stack");</p>
<p class="Sp-text-1"><a id="c5-para-0260"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0261"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c5-para-0262"/>}</p>
<p class="paracontinue"><a id="c5-para-0263"/>The following functions are used to access stacks:</p>
<p class="Sp-text-1"><a id="c5-para-0264"/><b>function</b> pop(stack) {</p>
<p class="Sp-text-1"><a id="c5-para-0265"/>    <b>return</b> stack("pop");</p>
<p class="Sp-text-1"><a id="c5-para-0266"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0267"/><b>function</b> push(stack, value) {</p>
<p class="Sp-text-1"><a id="c5-para-0268"/>    <b>return</b> stack("push")(value);</p>
<p class="Sp-text-1"><a id="c5-para-0269"/>}</p>
</section>
<section>
<h5><a id="c5-sec-0023"/><a id="c5-title-0024"/>The basic machine</h5>
<p class="paraaftertitle"><a id="c5-para-0270"/>The <span class="KeyTerm1">make_new_machine</span> function, shown in <a id="c5-fig-0013a"/><a href="#c5-fig-0013">figure 5.13</a>, constructs an object whose local state consists of a stack, an initially empty instruction sequence, a list of operations that initially contains an operation to initialize the stack, and a <i>register table</i> that initially contains two registers, named <span class="KeyTerm1">flag</span> and <span class="KeyTerm1">pc</span> (for “program counter”). The internal function <span class="KeyTerm1">allocate_register</span> adds new entries to the register table, and the internal function <span class="KeyTerm1">lookup_register</span> looks up registers in the table.</p>
<figure id="c5-fig-0013"><img alt="c5-fig-0013.jpg" src="../images/c5-fig-0013.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0013a">Figure 5.13</a></span> <a id="c5-para-0271"/>The <span class="KeyTerm1">make_new_machine</span> function implements the basic machine model.</p></figcaption></figure>
<p><a id="c5-para-0272"/>The <span class="KeyTerm1">flag</span> register is used to control branching in the simulated machine. Our <span class="KeyTerm1">test</span> instructions set the contents of <span class="KeyTerm1">flag</span> to the result of the test (true or false). Our <span class="KeyTerm1">branch</span> instructions decide whether or not to branch by examining the contents of <span class="KeyTerm1">flag</span>.</p>
<p><a id="c5-para-0273"/>The <span class="KeyTerm1">pc</span> register determines the sequencing of instructions as the machine runs. This sequencing is implemented by the internal function <span class="KeyTerm1">execute</span>. In the simulation model, each machine instruction is a data structure that includes a function of no arguments, called the <i>instruction execution function</i>, such that calling this function simulates executing the instruction. As the simulation runs, <span class="KeyTerm1">pc</span> points to the place in the instruction sequence beginning with the next instruction to be executed. The function <span class="KeyTerm1">execute</span> gets that instruction, executes it by calling the instruction execution function, and repeats this cycle until there are no more instructions to execute (i.e., until <span class="KeyTerm1">pc</span> points to the end of the instruction sequence).</p>
<p><a id="c5-para-0274"/>As part of its operation, each instruction execution function modifies <span class="KeyTerm1">pc</span> to indicate the next instruction to be executed. The instructions <span class="KeyTerm1">branch</span> and <span class="KeyTerm1">go_to</span> change <span class="KeyTerm1">pc</span> to point to the new destination. All other instructions simply advance <span class="KeyTerm1">pc</span>, making it point to the next instruction in the sequence. Observe that each call to <span class="KeyTerm1">execute</span> calls <span class="KeyTerm1">execute</span> again, but this does not produce an infinite loop because running the instruction execution function changes the contents of <span class="KeyTerm1">pc</span>.</p>
<p><a id="c5-para-0275"/>The function <span class="KeyTerm1">make_new_machine</span> returns a dispatch function that implements message-passing access to the internal state. Notice that starting the machine is accomplished by setting <span class="KeyTerm1">pc</span> to the beginning of the instruction sequence and calling <span class="KeyTerm1">execute</span>.</p>
<p><a id="c5-para-0276"/>For convenience, we provide an alternate interface to a machine's <span class="KeyTerm1">start</span> operation, as well as functions to set and examine register contents, as specified at the beginning of section 5.2:</p>
<p class="Sp-text-1"><a id="c5-para-0277"/><b>function</b> start(machine) {</p>
<p class="Sp-text-1"><a id="c5-para-0278"/>    <b>return</b> machine("start");</p>
<p class="Sp-text-1"><a id="c5-para-0279"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0280"/><b>function</b> get_register_contents(machine, register_name) {</p>
<p class="Sp-text-1"><a id="c5-para-0281"/>    <b>return</b> get_contents(get_register(machine, register_name));</p>
<p class="Sp-text-1"><a id="c5-para-0282"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0283"/><b>function</b> set_register_contents(machine, register_name, value) {</p>
<p class="Sp-text-1"><a id="c5-para-0284"/>    set_contents(get_register(machine, register_name), value);</p>
<p class="Sp-text-1"><a id="c5-para-0285"/>    <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c5-para-0286"/>}</p>
<p class="paracontinue"><a id="c5-para-0287"/>These functions (and many functions in sections 5.2.2 and 5.2.3) use the following to look up the register with a given name in a given machine:</p>
<p class="Sp-text-1"><a id="c5-para-0288"/><b>function</b> get_register(machine, reg_name) {</p>
<p class="Sp-text-1"><a id="c5-para-0289"/>    <b>return</b> machine("get_register")(reg_name);</p>
<p class="Sp-text-1"><a id="c5-para-0290"/>}</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0024"/><span>5.2.2</span> <a id="c5-title-0025"/>The Assembler</h3>
<p class="paraaftertitle"><a id="c5-para-0291"/>The assembler transforms the sequence of controller instructions for a machine into a corresponding list of machine instructions, each with its execution function. Overall, the assembler is much like the evaluators we studied in chapter 4—there is an input language (in this case, the register-machine language) and we must perform an appropriate action for each type of component in the language.</p>
<p><a id="c5-para-0292"/>The technique of producing an execution function for each instruction is just what we used in section 4.1.7 to speed up the evaluator by separating analysis from runtime execution. As we saw in chapter 4, much useful analysis of JavaScript expressions could be performed without knowing the actual values of names. Here, analogously, much useful analysis of register-machine-language expressions can be performed without knowing the actual contents of machine registers. For example, we can replace references to registers by pointers to the register objects, and we can replace references to labels by pointers to the place in the instruction sequence that the label designates.</p>
<p><a id="c5-para-0293"/>Before it can generate the instruction execution functions, the assembler must know what all the labels refer to, so it begins by scanning the controller sequence to separate the labels from the instructions. As it scans the controller, it constructs both a list of instructions and a table that associates each label with a pointer into that list. Then the assembler augments the instruction list by inserting the execution function for each instruction.</p>
<p><a id="c5-para-0294"/>The <span class="KeyTerm1">assemble</span> function is the main entry to the assembler. It takes the controller sequence and the machine model as arguments and returns the instruction sequence to be stored in the model. The function <span class="KeyTerm1">assemble</span> calls <span class="KeyTerm1">extract_labels</span> to build the initial instruction list and label table from the supplied controller. The second argument to <span class="KeyTerm1">extract_labels</span> is a function to be called to process these results: This function uses <span class="KeyTerm1">update_insts</span> to generate the instruction execution functions and insert them into the instruction list, and returns the modified list.</p>
<p class="Sp-text-1"><a id="c5-para-0295"/><b>function</b> assemble(controller, machine) {</p>
<p class="Sp-text-1"><a id="c5-para-0296"/>    <b>return</b> extract_labels(controller,</p>
<p class="Sp-text-1"><a id="c5-para-0297"/>                          (insts, labels) =&gt; {</p>
<p class="Sp-text-1"><a id="c5-para-0298"/>                              update_insts(insts, labels, machine);</p>
<p class="Sp-text-1"><a id="c5-para-0299"/>                              <b>return</b> insts;</p>
<p class="Sp-text-1"><a id="c5-para-0300"/>                          });</p>
<p class="Sp-text-1"><a id="c5-para-0301"/>}</p>
<p><a id="c5-para-0302"/>The function <span class="KeyTerm1">extract_labels</span> takes a list <span class="KeyTerm1">controller</span> and a function <span class="KeyTerm1">receive</span> as arguments. The function <span class="KeyTerm1">receive</span> will be called with two values: (1) a list <span class="KeyTerm1">insts</span> of instruction data structures, each containing an instruction from <span class="KeyTerm1">controller</span>; and (2) a table called <span class="KeyTerm1">labels</span>, which associates each label from <span class="KeyTerm1">controller</span> with the position in the list <span class="KeyTerm1">insts</span> that the label designates.</p>
<p class="Sp-text-1"><a id="c5-para-0303"/><b>function</b> extract_labels(controller, receive) {</p>
<p class="Sp-text-1"><a id="c5-para-0304"/>    <b>return</b> is_null(controller)</p>
<p class="Sp-text-1"><a id="c5-para-0305"/>           ? receive(<b>null</b>, <b>null</b>)</p>
<p class="Sp-text-1"><a id="c5-para-0306"/>           : extract_labels(</p>
<p class="Sp-text-1"><a id="c5-para-0307"/>                 tail(controller),</p>
<p class="Sp-text-1"><a id="c5-para-0308"/>                 (insts, labels) =&gt; {</p>
<p class="Sp-text-1"><a id="c5-para-0309"/>                   <b>const</b> next_element = head(controller);</p>
<p class="Sp-text-1"><a id="c5-para-0310"/>                   <b>return</b> is_string(next_element)</p>
<p class="Sp-text-1"><a id="c5-para-0311"/>                          ? receive(insts,</p>
<p class="Sp-text-1"><a id="c5-para-0312"/>                                    pair(make_label_entry(next_element,</p>
<p class="Sp-text-1"><a id="c5-para-0313"/>                                                          insts),</p>
<p class="Sp-text-1"><a id="c5-para-0314"/>                                         labels))</p>
<p class="Sp-text-1"><a id="c5-para-0315"/>                          : receive(pair(make_inst(next_element),</p>
<p class="Sp-text-1"><a id="c5-para-0316"/>                                         insts),</p>
<p class="Sp-text-1"><a id="c5-para-0317"/>                                    labels);</p>
<p class="Sp-text-1"><a id="c5-para-0318"/>                 });</p>
<p class="Sp-text-1"><a id="c5-para-0319"/>}</p>
<p class="paracontinue"><a id="c5-para-0320"/>The function <span class="KeyTerm1">extract_labels</span> works by sequentially scanning the elements of the <span class="KeyTerm1">controller</span> and accumulating the <span class="KeyTerm1">insts</span> and the <span class="KeyTerm1">labels</span>. If an element is a string (and thus a label) an appropriate entry is added to the <span class="KeyTerm1">labels</span> table. Otherwise the element is accumulated onto the <span class="KeyTerm1">insts</span> list.<a id="c5-fn-0005a"/><a href="#c5-fn-0005"><sup>5</sup></a></p>
<p><a id="c5-para-0344"/>The function <span class="KeyTerm1">update_insts</span> modifies the instruction list, which initially contains only the controller instructions, to include the corresponding execution functions:</p>
<p class="Sp-text-1"><a id="c5-para-0345"/><b>function</b> update_insts(insts, labels, machine) {</p>
<p class="Sp-text-1"><a id="c5-para-0346"/>    <b>const</b> pc = get_register(machine, "pc");</p>
<p class="Sp-text-1"><a id="c5-para-0347"/>    <b>const</b> flag = get_register(machine, "flag");</p>
<p class="Sp-text-1"><a id="c5-para-0348"/>    <b>const</b> stack = machine("stack");</p>
<p class="Sp-text-1"><a id="c5-para-0349"/>    <b>const</b> ops = machine("operations");</p>
<p class="Sp-text-1"><a id="c5-para-0350"/>    <b>return</b> for_each(inst =&gt; set_inst_execution_fun(</p>
<p class="Sp-text-1"><a id="c5-para-0351"/>                                inst,</p>
<p class="Sp-text-1"><a id="c5-para-0352"/>                                make_execution_function(</p>
<p class="Sp-text-1"><a id="c5-para-0353"/>                                    inst_controller_instruction(inst),</p>
<p class="Sp-text-1"><a id="c5-para-0354"/>                                    labels, machine, pc,</p>
<p class="Sp-text-1"><a id="c5-para-0355"/>                                    flag, stack, ops)),</p>
<p class="Sp-text-1"><a id="c5-para-0356"/>                    insts);</p>
<p class="Sp-text-1"><a id="c5-para-0357"/>}</p>
<p><a id="c5-para-0358"/>The machine instruction data structure simply pairs the controller instruction with the corresponding execution function. The execution function is not yet available when <span class="KeyTerm1">extract_labels</span> constructs the instruction, and is inserted later by <span class="KeyTerm1">update_insts</span>.</p>
<p class="Sp-text-1"><a id="c5-para-0359"/><b>function</b> make_inst(inst_controller_instruction) {</p>
<p class="Sp-text-1"><a id="c5-para-0360"/>    <b>return</b> pair(inst_controller_instruction, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c5-para-0361"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0362"/><b>function</b> inst_controller_instruction(inst) {</p>
<p class="Sp-text-1"><a id="c5-para-0363"/>    <b>return</b> head(inst);</p>
<p class="Sp-text-1"><a id="c5-para-0364"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0365"/><b>function</b> inst_execution_fun(inst) {</p>
<p class="Sp-text-1"><a id="c5-para-0366"/>    <b>return</b> tail(inst);</p>
<p class="Sp-text-1"><a id="c5-para-0367"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0368"/><b>function</b> set_inst_execution_fun(inst, fun) {</p>
<p class="Sp-text-1"><a id="c5-para-0369"/>    set_tail(inst, fun);</p>
<p class="Sp-text-1"><a id="c5-para-0370"/>}</p>
<p class="paracontinue"><a id="c5-para-0371"/>The controller instruction is not used by our simulator, but is handy to keep around for debugging (see exercise 5.15).</p>
<p><a id="c5-para-0372"/>Elements of the label table are pairs:</p>
<p class="Sp-text-1"><a id="c5-para-0373"/><b>function</b> make_label_entry(label_name, insts) {</p>
<p class="Sp-text-1"><a id="c5-para-0374"/>    <b>return</b> pair(label_name, insts);</p>
<p class="Sp-text-1"><a id="c5-para-0375"/>}</p>
<p class="paracontinue"><a id="c5-para-0376"/>Entries will be looked up in the table with</p>
<p class="Sp-text-1"><a id="c5-para-0377"/><b>function</b> lookup_label(labels, label_name) {</p>
<p class="Sp-text-1"><a id="c5-para-0378"/>    <b>const</b> val = assoc(label_name, labels);</p>
<p class="Sp-text-1"><a id="c5-para-0379"/>    <b>return</b> is_undefined(val)</p>
<p class="Sp-text-1"><a id="c5-para-0380"/>           ? error(label_name, "undefined label – assemble")</p>
<p class="Sp-text-1"><a id="c5-para-0381"/>           : tail(val);</p>
<p class="Sp-text-1"><a id="c5-para-0382"/>}</p>
<section>
<h5><a id="c5-sec-0025"/><a id="c5-title-0026"/>Exercise 5.8</h5>
<p class="paraaftertitle"><a id="c5-para-0383"/>The following register-machine code is ambiguous, because the label <span class="KeyTerm1">here</span> is defined more than once:</p>
<p class="Sp-text-1"><a id="c5-para-0384"/>"start",</p>
<p class="Sp-text-1"><a id="c5-para-0385"/>  go_to(label("here")),</p>
<p class="Sp-text-1"><a id="c5-para-0386"/>"here",</p>
<p class="Sp-text-1"><a id="c5-para-0387"/>  assign("a", constant(3)),</p>
<p class="Sp-text-1"><a id="c5-para-0388"/>  go_to(label("there")),</p>
<p class="Sp-text-1"><a id="c5-para-0389"/>"here",</p>
<p class="Sp-text-1"><a id="c5-para-0390"/>  assign("a", constant(4)),</p>
<p class="Sp-text-1"><a id="c5-para-0391"/>  go_to(label("there")),</p>
<p class="Sp-text-1"><a id="c5-para-0392"/>"there",</p>
<p class="paracontinue"><a id="c5-para-0393"/>With the simulator as written, what will the contents of register <span class="KeyTerm1">a</span> be when control reaches <span class="KeyTerm1">there</span>? Modify the <span class="KeyTerm1">extract_labels</span> function so that the assembler will signal an error if the same label name is used to indicate two different locations.</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0026"/><span>5.2.3</span> <a id="c5-title-0027"/>Instructions and Their Execution Functions</h3>
<p class="paraaftertitle"><a id="c5-para-0394"/>The assembler calls <span class="KeyTerm1">make_execution_function</span> to generate the execution function for a controller instruction. Like the <span class="KeyTerm1">analyze</span> function in the evaluator of section 4.1.7, this dispatches on the type of instruction to generate the appropriate execution function. The details of these execution functions determine the meaning of the individual instructions in the register-machine language.</p>
<p class="Sp-text-1"><a id="c5-para-0395"/><b>function</b> make_execution_function(inst, labels, machine,</p>
<p class="Sp-text-1"><a id="c5-para-0396"/>                                 pc, flag, stack, ops) {</p>
<p class="Sp-text-1"><a id="c5-para-0397"/>    <b>const</b> inst_type = type(inst);</p>
<p class="Sp-text-1"><a id="c5-para-0398"/>    <b>return</b> inst_type === "assign"</p>
<p class="Sp-text-1"><a id="c5-para-0399"/>           ? make_assign_ef(inst, machine, labels, ops, pc)</p>
<p class="Sp-text-1"><a id="c5-para-0400"/>           : inst_type === "test"</p>
<p class="Sp-text-1"><a id="c5-para-0401"/>           ? make_test_ef(inst, machine, labels, ops, flag, pc)</p>
<p class="Sp-text-1"><a id="c5-para-0402"/>           : inst_type === "branch"</p>
<p class="Sp-text-1"><a id="c5-para-0403"/>           ? make_branch_ef(inst, machine, labels, flag, pc)</p>
<p class="Sp-text-1"><a id="c5-para-0404"/>           : inst_type === "go_to"</p>
<p class="Sp-text-1"><a id="c5-para-0405"/>           ? make_go_to_ef(inst, machine, labels, pc)</p>
<p class="Sp-text-1"><a id="c5-para-0406"/>           : inst_type === "save"</p>
<p class="Sp-text-1"><a id="c5-para-0407"/>           ? make_save_ef(inst, machine, stack, pc)</p>
<p class="Sp-text-1"><a id="c5-para-0408"/>           : inst_type === "restore"</p>
<p class="Sp-text-1"><a id="c5-para-0409"/>           ? make_restore_ef(inst, machine, stack, pc)</p>
<p class="Sp-text-1"><a id="c5-para-0410"/>           : inst_type === "perform"</p>
<p class="Sp-text-1"><a id="c5-para-0411"/>           ? make_perform_ef(inst, machine, labels, ops, pc)</p>
<p class="Sp-text-1"><a id="c5-para-0412"/>           : error(inst, "unknown instruction type – assemble");</p>
<p class="Sp-text-1"><a id="c5-para-0413"/>}</p>
<p class="paracontinue"><a id="c5-para-0414"/>The elements of the <span class="KeyTerm1">controller</span> sequence received by <span class="KeyTerm1">make_machine</span> and passed to <span class="KeyTerm1">assemble</span> are strings (for labels) and tagged lists (for instructions). The tag in an instruction is a string that identifies the instruction type, such as <span class="KeyTerm1">"go_to"</span>, and the remaining elements of the list contains the arguments, such as the destination of the <span class="KeyTerm1">go_to</span>. The dispatch in <span class="KeyTerm1">make_execution_function</span> uses</p>
<p class="Sp-text-1"><a id="c5-para-0415"/><b>function</b> type(instruction) { <b>return</b> head(instruction); }</p>
<p><a id="c5-para-0416"/>The tagged lists are constructed when the <span class="KeyTerm1">list</span> expression that is the third argument to <span class="KeyTerm1">make_machine</span> is evaluated. Each argument to that <span class="KeyTerm1">list</span> is either a string (which evaluates to itself) or a call to a constructor for an instruction tagged list. For example, <span class="KeyTerm1">assign("b", reg("t"))</span> calls the constructor <span class="KeyTerm1">assign</span> with arguments <span class="KeyTerm1">"b"</span> and the result of calling the constructor <span class="KeyTerm1">reg</span> with the argument <span class="KeyTerm1">"t"</span>. The constructors and their arguments determine the syntax of the individual instructions in the register-machine language. The instruction constructors and selectors are shown below, along with the execution-function generators that use the selectors.</p>
<section>
<h5><a id="c5-sec-0027"/><a id="c5-title-0028"/>The instruction <span class="KeyTerm1"><b>assign</b></span></h5>
<p class="paraaftertitle"><a id="c5-para-0417"/>The <span class="KeyTerm1">make_assign_ef</span> function makes execution functions for <span class="KeyTerm1">assign</span> instructions:</p>
<p class="Sp-text-1"><a id="c5-para-0418"/><b>function</b> make_assign_ef(inst, machine, labels, operations, pc) {</p>
<p class="Sp-text-1"><a id="c5-para-0419"/>    <b>const</b> target = get_register(machine, assign_reg_name(inst));</p>
<p class="Sp-text-1"><a id="c5-para-0420"/>    <b>const</b> value_exp = assign_value_exp(inst);</p>
<p class="Sp-text-1"><a id="c5-para-0421"/>    <b>const</b> value_fun =</p>
<p class="Sp-text-1"><a id="c5-para-0422"/>        is_operation_exp(value_exp)</p>
<p class="Sp-text-1"><a id="c5-para-0423"/>        ? make_operation_exp_ef(value_exp, machine, labels, operations)</p>
<p class="Sp-text-1"><a id="c5-para-0424"/>        : make_primitive_exp_ef(value_exp, machine, labels);</p>
<p class="Sp-text-1"><a id="c5-para-0425"/>    <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c5-para-0426"/>               set_contents(target, value_fun());</p>
<p class="Sp-text-1"><a id="c5-para-0427"/>               advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c5-para-0428"/>           };</p>
<p class="Sp-text-1"><a id="c5-para-0429"/>}</p>
<p class="paracontinue"><a id="c5-para-0430"/>The function <span class="KeyTerm1">assign</span> constructs <span class="KeyTerm1">assign</span> instructions. The selectors <span class="KeyTerm1">assign_reg_ name</span> and <span class="KeyTerm1">assign_value_exp</span> extract the register name and value expression from an <span class="KeyTerm1">assign</span> instruction.</p>
<p class="Sp-text-1"><a id="c5-para-0431"/><b>function</b> assign(register_name, source) {</p>
<p class="Sp-text-1"><a id="c5-para-0432"/>    <b>return</b> list("assign", register_name, source);</p>
<p class="Sp-text-1"><a id="c5-para-0433"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0434"/><b>function</b> assign_reg_name(assign_instruction) {</p>
<p class="Sp-text-1"><a id="c5-para-0435"/>    <b>return</b> head(tail(assign_instruction));</p>
<p class="Sp-text-1"><a id="c5-para-0436"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0437"/><b>function</b> assign_value_exp(assign_instruction) {</p>
<p class="Sp-text-1"><a id="c5-para-0438"/>    <b>return</b> head(tail(tail(assign_instruction)));</p>
<p class="Sp-text-1"><a id="c5-para-0439"/>}</p>
<p class="paracontinue"><a id="c5-para-0440"/>The function <span class="KeyTerm1">make_assign_ef</span> looks up the register name with <span class="KeyTerm1">get_register</span> to produce the target register object. The value expression is passed to <span class="KeyTerm1">make_ operation_exp_ef</span> if the value is the result of an operation, and it is passed to <span class="KeyTerm1">make_primitive_exp_ef</span> otherwise. These functions (shown below) analyze the value expression and produce an execution function for the value. This is a function of no arguments, called <span class="KeyTerm1">value_fun</span>, which will be evaluated during the simulation to produce the actual value to be assigned to the register. Notice that the work of looking up the register name and analyzing the value expression is performed just once, at assembly time, not every time the instruction is simulated. This saving of work is the reason we use execution functions, and corresponds directly to the saving in work we obtained by separating program analysis from execution in the evaluator of section 4.1.7.</p>
<p><a id="c5-para-0441"/>The result returned by <span class="KeyTerm1">make_assign_ef</span> is the execution function for the <span class="KeyTerm1">assign</span> instruction. When this function is called (by the machine model's <span class="KeyTerm1">execute</span> function), it sets the contents of the target register to the result obtained by executing <span class="KeyTerm1">value_fun</span>. Then it advances the <span class="KeyTerm1">pc</span> to the next instruction by running the function</p>
<p class="Sp-text-1"><a id="c5-para-0442"/><b>function</b> advance_pc(pc) {</p>
<p class="Sp-text-1"><a id="c5-para-0443"/>    set_contents(pc, tail(get_contents(pc)));</p>
<p class="Sp-text-1"><a id="c5-para-0444"/>}</p>
<p class="paracontinue"><a id="c5-para-0445"/>The function <span class="KeyTerm1">advance_pc</span> is the normal termination for all instructions except <span class="KeyTerm1">branch</span> and <span class="KeyTerm1">go_to</span>.</p>
</section>
<section>
<h5><a id="c5-sec-0028"/><a id="c5-title-0029"/>The instructions <span class="KeyTerm1"><b>test</b></span>, <span class="KeyTerm1"><b>branch</b></span>, and <span class="KeyTerm1"><b>go_to</b></span></h5>
<p class="paraaftertitle"><a id="c5-para-0446"/>The function <span class="KeyTerm1">make_test_ef</span> handles <span class="KeyTerm1">test</span> instructions in a similar way. It extracts the expression that specifies the condition to be tested and generates an execution function for it. At simulation time, the function for the condition is called, the result is assigned to the <span class="KeyTerm1">flag</span> register, and the <span class="KeyTerm1">pc</span> is advanced:</p>
<p class="Sp-text-1"><a id="c5-para-0447"/><b>function</b> make_test_ef(inst, machine, labels, operations, flag, pc) {</p>
<p class="Sp-text-1"><a id="c5-para-0448"/>    <b>const</b> condition = test_condition(inst);</p>
<p class="Sp-text-1"><a id="c5-para-0449"/>    <b>if</b> (is_operation_exp(condition)) {</p>
<p class="Sp-text-1"><a id="c5-para-0450"/>        <b>const</b> condition_fun = make_operation_exp_ef(</p>
<p class="Sp-text-1"><a id="c5-para-0451"/>                                  condition, machine,</p>
<p class="Sp-text-1"><a id="c5-para-0452"/>                                  labels, operations);</p>
<p class="Sp-text-1"><a id="c5-para-0453"/>        <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c5-para-0454"/>                   set_contents(flag, condition_fun());</p>
<p class="Sp-text-1"><a id="c5-para-0455"/>                   advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c5-para-0456"/>               };</p>
<p class="Sp-text-1"><a id="c5-para-0457"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c5-para-0458"/>        error(inst, "bad test instruction – assemble");</p>
<p class="Sp-text-1"><a id="c5-para-0459"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0460"/>}</p>
<p class="paracontinue"><a id="c5-para-0461"/>The function <span class="KeyTerm1">test</span> constructs <span class="KeyTerm1">test</span> instructions. The selector <span class="KeyTerm1">test_condition</span> extracts the condition from a test.</p>
<p class="Sp-text-1"><a id="c5-para-0462"/><b>function</b> test(condition) { <b>return</b> list("test", condition); }</p>
<p class="Sp-text-1"><a id="c5-para-0463"/><b>function</b> test_condition(test_instruction) {</p>
<p class="Sp-text-1"><a id="c5-para-0464"/>    <b>return</b> head(tail(test_instruction));</p>
<p class="Sp-text-1"><a id="c5-para-0465"/>}</p>
<p><a id="c5-para-0466"/>The execution function for a <span class="KeyTerm1">branch</span> instruction checks the contents of the <span class="KeyTerm1">flag</span> register and either sets the contents of the <span class="KeyTerm1">pc</span> to the branch destination (if the branch is taken) or else just advances the <span class="KeyTerm1">pc</span> (if the branch is not taken). Notice that the indicated destination in a <span class="KeyTerm1">branch</span> instruction must be a label, and the <span class="KeyTerm1">make_branch_ef</span> function enforces this. Notice also that the label is looked up at assembly time, not each time the <span class="KeyTerm1">branch</span> instruction is simulated.</p>
<p class="Sp-text-1"><a id="c5-para-0467"/><b>function</b> make_branch_ef(inst, machine, labels, flag, pc) {</p>
<p class="Sp-text-1"><a id="c5-para-0468"/>    <b>const</b> dest = branch_dest(inst);</p>
<p class="Sp-text-1"><a id="c5-para-0469"/>    <b>if</b> (is_label_exp(dest)) {</p>
<p class="Sp-text-1"><a id="c5-para-0470"/>        <b>const</b> insts = lookup_label(labels, label_exp_label(dest));</p>
<p class="Sp-text-1"><a id="c5-para-0471"/>        <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c5-para-0472"/>                   <b>if</b> (get_contents(flag)) {</p>
<p class="Sp-text-1"><a id="c5-para-0473"/>                       set_contents(pc, insts);</p>
<p class="Sp-text-1"><a id="c5-para-0474"/>                   } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c5-para-0475"/>                       advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c5-para-0476"/>                   }</p>
<p class="Sp-text-1"><a id="c5-para-0477"/>               };</p>
<p class="Sp-text-1"><a id="c5-para-0478"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c5-para-0479"/>        error(inst, "bad branch instruction – assemble");</p>
<p class="Sp-text-1"><a id="c5-para-0480"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0481"/>}</p>
<p class="paracontinue"><a id="c5-para-0482"/>The function <span class="KeyTerm1">branch</span> constructs <span class="KeyTerm1">branch</span> instructions. The selector <span class="KeyTerm1">branch_dest</span> extracts the destination from a branch.</p>
<p class="Sp-text-1"><a id="c5-para-0483"/><b>function</b> branch(label) { <b>return</b> list("branch", label); }</p>
<p class="Sp-text-1"><a id="c5-para-0484"/><b>function</b> branch_dest(branch_instruction) {</p>
<p class="Sp-text-1"><a id="c5-para-0485"/>    <b>return</b> head(tail(branch_instruction));</p>
<p class="Sp-text-1"><a id="c5-para-0486"/>}</p>
<p><a id="c5-para-0487"/>A <span class="KeyTerm1">go_to</span> instruction is similar to a branch, except that the destination may be specified either as a label or as a register, and there is no condition to check—the <span class="KeyTerm1">pc</span> is always set to the new destination.</p>
<p class="Sp-text-1"><a id="c5-para-0488"/><b>function</b> make_go_to_ef(inst, machine, labels, pc) {</p>
<p class="Sp-text-1"><a id="c5-para-0489"/>    <b>const</b> dest = go_to_dest(inst);</p>
<p class="Sp-text-1"><a id="c5-para-0490"/>    <b>if</b> (is_label_exp(dest)) {</p>
<p class="Sp-text-1"><a id="c5-para-0491"/>        <b>const</b> insts = lookup_label(labels, label_exp_label(dest));</p>
<p class="Sp-text-1"><a id="c5-para-0492"/>        <b>return</b> () =&gt; set_contents(pc, insts);</p>
<p class="Sp-text-1"><a id="c5-para-0493"/>    } <b>else if</b> (is_register_exp(dest)) {</p>
<p class="Sp-text-1"><a id="c5-para-0494"/>        <b>const</b> reg = get_register(machine, register_exp_reg(dest));</p>
<p class="Sp-text-1"><a id="c5-para-0495"/>        <b>return</b> () =&gt; set_contents(pc, get_contents(reg));</p>
<p class="Sp-text-1"><a id="c5-para-0496"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c5-para-0497"/>        error(inst, "bad go_to instruction – assemble");</p>
<p class="Sp-text-1"><a id="c5-para-0498"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0499"/>}</p>
<p class="paracontinue"><a id="c5-para-0500"/>The function <span class="KeyTerm1">go_to</span> constructs <span class="KeyTerm1">go_to</span> instructions. The selector <span class="KeyTerm1">go_to_dest</span> extracts the destination from a <span class="KeyTerm1">go_to</span> instruction.</p>
<p class="Sp-text-1"><a id="c5-para-0501"/><b>function</b> go_to(label) { <b>return</b> list("go_to", label); }</p>
<p class="Sp-text-1"><a id="c5-para-0502"/><b>function</b> go_to_dest(go_to_instruction) {</p>
<p class="Sp-text-1"><a id="c5-para-0503"/>    <b>return</b> head(tail(go_to_instruction));</p>
<p class="Sp-text-1"><a id="c5-para-0504"/>}</p>
</section>
<section>
<h5><a id="c5-sec-0029"/><a id="c5-title-0030"/>Other instructions</h5>
<p class="paraaftertitle"><a id="c5-para-0505"/>The stack instructions <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> simply use the stack with the designated register and advance the <span class="KeyTerm1">pc</span>:</p>
<p class="Sp-text-1"><a id="c5-para-0506"/><b>function</b> make_save_ef(inst, machine, stack, pc) {</p>
<p class="Sp-text-1"><a id="c5-para-0507"/>    <b>const</b> reg = get_register(machine, stack_inst_reg_name(inst));</p>
<p class="Sp-text-1"><a id="c5-para-0508"/>    <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c5-para-0509"/>               push(stack, get_contents(reg));</p>
<p class="Sp-text-1"><a id="c5-para-0510"/>               advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c5-para-0511"/>           };</p>
<p class="Sp-text-1"><a id="c5-para-0512"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0513"/><b>function</b> make_restore_ef(inst, machine, stack, pc) {</p>
<p class="Sp-text-1"><a id="c5-para-0514"/>    <b>const</b> reg = get_register(machine, stack_inst_reg_name(inst));</p>
<p class="Sp-text-1"><a id="c5-para-0515"/>    <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c5-para-0516"/>               set_contents(reg, pop(stack));</p>
<p class="Sp-text-1"><a id="c5-para-0517"/>               advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c5-para-0518"/>           };</p>
<p class="Sp-text-1"><a id="c5-para-0519"/>}</p>
<p class="paracontinue"><a id="c5-para-0520"/>The functions <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> construct <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> instructions. The selector <span class="KeyTerm1">stack_inst_reg_name</span> extracts the register name from such instructions.</p>
<p class="Sp-text-1"><a id="c5-para-0521"/><b>function</b> save(reg) { <b>return</b> list("save", reg); }</p>
<p class="Sp-text-1"><a id="c5-para-0522"/><b>function</b> restore(reg) { <b>return</b> list("restore", reg); }</p>
<p class="Sp-text-1"><a id="c5-para-0523"/><b>function</b> stack_inst_reg_name(stack_instruction) {</p>
<p class="Sp-text-1"><a id="c5-para-0524"/>    <b>return</b> head(tail(stack_instruction));</p>
<p class="Sp-text-1"><a id="c5-para-0525"/>}</p>
<p><a id="c5-para-0526"/>The final instruction type, handled by <span class="KeyTerm1">make_perform_ef</span>, generates an execution function for the action to be performed. At simulation time, the action function is executed and the <span class="KeyTerm1">pc</span> advanced.</p>
<p class="Sp-text-1"><a id="c5-para-0527"/><b>function</b> make_perform_ef(inst, machine, labels, operations, pc) {</p>
<p class="Sp-text-1"><a id="c5-para-0528"/>    <b>const</b> action = perform_action(inst);</p>
<p class="Sp-text-1"><a id="c5-para-0529"/>    <b>if</b> (is_operation_exp(action)) {</p>
<p class="Sp-text-1"><a id="c5-para-0530"/>        <b>const</b> action_fun = make_operation_exp_ef(action, machine,</p>
<p class="Sp-text-1"><a id="c5-para-0531"/>                                                 labels, operations);</p>
<p class="Sp-text-1"><a id="c5-para-0532"/>        <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c5-para-0533"/>                   action_fun();</p>
<p class="Sp-text-1"><a id="c5-para-0534"/>                   advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c5-para-0535"/>               };</p>
<p class="Sp-text-1"><a id="c5-para-0536"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c5-para-0537"/>        error(inst, "bad perform instruction – assemble");</p>
<p class="Sp-text-1"><a id="c5-para-0538"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0539"/>}</p>
<p class="paracontinue"><a id="c5-para-0540"/>The function <span class="KeyTerm1">perform</span> constructs <span class="KeyTerm1">perform</span> instructions. The selector <span class="KeyTerm1">perform_ action</span> extracts the action from a <span class="KeyTerm1">perform</span> instruction.</p>
<p class="Sp-text-1"><a id="c5-para-0541"/><b>function</b> perform(action) { <b>return</b> list("perform", action); }</p>
<p class="Sp-text-1"><a id="c5-para-0542"/><b>function</b> perform_action(perform_instruction) {</p>
<p class="Sp-text-1"><a id="c5-para-0543"/>    <b>return</b> head(tail(perform_instruction));</p>
<p class="Sp-text-1"><a id="c5-para-0544"/>}</p>
</section>
<section>
<h5><a id="c5-sec-0030"/><a id="c5-title-0031"/>Execution functions for subexpressions</h5>
<p class="paraaftertitle"><a id="c5-para-0545"/>The value of a <span class="KeyTerm1">reg</span>, <span class="KeyTerm1">label</span>, or <span class="KeyTerm1">constant</span> expression may be needed for assignment to a register (<span class="KeyTerm1">make_assign_ef</span>, above) or for input to an operation (<span class="KeyTerm1">make_ operation_exp_ef</span>, below). The following function generates execution functions to produce values for these expressions during the simulation:</p>
<p class="Sp-text-1"><a id="c5-para-0546"/><b>function</b> make_primitive_exp_ef(exp, machine, labels) {</p>
<p class="Sp-text-1"><a id="c5-para-0547"/>    <b>if</b> (is_constant_exp(exp)) {</p>
<p class="Sp-text-1"><a id="c5-para-0548"/>        <b>const</b> c = constant_exp_value(exp);</p>
<p class="Sp-text-1"><a id="c5-para-0549"/>        <b>return</b> () =&gt; c;</p>
<p class="Sp-text-1"><a id="c5-para-0550"/>    } <b>else if</b> (is_label_exp(exp)) {</p>
<p class="Sp-text-1"><a id="c5-para-0551"/>        <b>const</b> insts = lookup_label(labels, label_exp_label(exp));</p>
<p class="Sp-text-1"><a id="c5-para-0552"/>        <b>return</b> () =&gt; insts;</p>
<p class="Sp-text-1"><a id="c5-para-0553"/>    } <b>else if</b> (is_register_exp(exp)) {</p>
<p class="Sp-text-1"><a id="c5-para-0554"/>        <b>const</b> r = get_register(machine, register_exp_reg(exp));</p>
<p class="Sp-text-1"><a id="c5-para-0555"/>        <b>return</b> () =&gt; get_contents(r);</p>
<p class="Sp-text-1"><a id="c5-para-0556"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c5-para-0557"/>        error(exp, "unknown expression type – assemble");</p>
<p class="Sp-text-1"><a id="c5-para-0558"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0559"/>}</p>
<p class="paracontinue"><a id="c5-para-0560"/>The syntax of <span class="KeyTerm1">reg</span>, <span class="KeyTerm1">label</span>, and <span class="KeyTerm1">constant</span> expressions is determined by the following constructor functions, along with corresponding predicates and selectors.</p>
<p class="Sp-text-1"><a id="c5-para-0561"/><b>function</b> reg(name) { <b>return</b> list("reg", name); }</p>
<p class="Sp-text-1"><a id="c5-para-0562"/><b>function</b> is_register_exp(exp) { <b>return</b> is_tagged_list(exp, "reg"); }</p>
<p class="Sp-text-1"><a id="c5-para-0563"/><b>function</b> register_exp_reg(exp) { <b>return</b> head(tail(exp)); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0564"/><b>function</b> constant(value) { <b>return</b> list("constant", value); }</p>
<p class="Sp-text-1"><a id="c5-para-0565"/><b>function</b> is_constant_exp(exp) {</p>
<p class="Sp-text-1"><a id="c5-para-0566"/>    <b>return</b> is_tagged_list(exp, "constant");</p>
<p class="Sp-text-1"><a id="c5-para-0567"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0568"/><b>function</b> constant_exp_value(exp) { <b>return</b> head(tail(exp)); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0569"/><b>function</b> label(name) { <b>return</b> list("label", name); }</p>
<p class="Sp-text-1"><a id="c5-para-0570"/><b>function</b> is_label_exp(exp) { <b>return</b> is_tagged_list(exp, "label"); }</p>
<p class="Sp-text-1"><a id="c5-para-0571"/><b>function</b> label_exp_label(exp) { <b>return</b> head(tail(exp)); }</p>
<p><a id="c5-para-0572"/>The instructions <span class="KeyTerm1">assign</span>, <span class="KeyTerm1">perform</span>, and <span class="KeyTerm1">test</span> may include the application of a machine operation (specified by an <span class="KeyTerm1">op</span> expression) to some operands (specified by <span class="KeyTerm1">reg</span> and <span class="KeyTerm1">constant</span> expressions). The following function produces an execution function for an “operation expression”—a list containing the operation and operand expressions from the instruction:</p>
<p class="Sp-text-1"><a id="c5-para-0573"/><b>function</b> make_operation_exp_ef(exp, machine, labels, operations) {</p>
<p class="Sp-text-1"><a id="c5-para-0574"/>    <b>const</b> op = lookup_prim(operation_exp_op(exp), operations);</p>
<p class="Sp-text-1"><a id="c5-para-0575"/>    <b>const</b> afuns = map(e =&gt; make_primitive_exp_ef(e, machine, labels),</p>
<p class="Sp-text-1"><a id="c5-para-0576"/>                      operation_exp_operands(exp));</p>
<p class="Sp-text-1"><a id="c5-para-0577"/>    <b>return</b> () =&gt; apply_in_underlying_javascript(</p>
<p class="Sp-text-1"><a id="c5-para-0578"/>                     op, map(f =&gt; f(), afuns));</p>
<p class="Sp-text-1"><a id="c5-para-0579"/>}</p>
<p class="paracontinue"><a id="c5-para-0580"/>The syntax of operation expressions is determined by</p>
<p class="Sp-text-1"><a id="c5-para-0581"/><b>function</b> op(name) { <b>return</b> list("op", name); }</p>
<p class="Sp-text-1"><a id="c5-para-0582"/><b>function</b> is_operation_exp(exp) {</p>
<p class="Sp-text-1"><a id="c5-para-0583"/>    <b>return</b> is_pair(exp) &amp;&amp; is_tagged_list(head(exp), "op");</p>
<p class="Sp-text-1"><a id="c5-para-0584"/>}</p>
<p class="Sp-text-1"><a id="c5-para-0585"/><b>function</b> operation_exp_op(op_exp) { <b>return</b> head(tail(head(op_exp))); }</p>
<p class="Sp-text-1"><a id="c5-para-0586"/><b>function</b> operation_exp_operands(op_exp) { <b>return</b> tail(op_exp); }</p>
<p class="paracontinue"><a id="c5-para-0587"/>Observe that the treatment of operation expressions is very much like the treatment of function applications by the <span class="KeyTerm1">analyze_application</span> function in the evaluator of section 4.1.7 in that we generate an execution function for each operand. At simulation time, we call the operand functions and apply the JavaScript function that simulates the operation to the resulting values. We make use of the function <span class="KeyTerm1">apply_in_underlying_javascript</span>, as we did in <span class="KeyTerm1">apply_primitive_function</span> in section 4.1.4. This is needed to apply <span class="KeyTerm1">op</span> to all elements of the argument list <span class="KeyTerm1">afuns</span> produced by the first <span class="KeyTerm1">map</span>, as if they were separate arguments to <span class="KeyTerm1">op</span>. Without this, <span class="KeyTerm1">op</span> would have been restricted to be a unary function.</p>
<p><a id="c5-para-0588"/>The simulation function is found by looking up the operation name in the operation table for the machine:</p>
<p class="Sp-text-1"><a id="c5-para-0589"/><b>function</b> lookup_prim(symbol, operations) {</p>
<p class="Sp-text-1"><a id="c5-para-0590"/>    <b>const</b> val = assoc(symbol, operations);</p>
<p class="Sp-text-1"><a id="c5-para-0591"/>    <b>return</b> is_undefined(val)</p>
<p class="Sp-text-1"><a id="c5-para-0592"/>           ? error(symbol, "unknown operation – assemble")</p>
<p class="Sp-text-1"><a id="c5-para-0593"/>           : head(tail(val));</p>
<p class="Sp-text-1"><a id="c5-para-0594"/>}</p>
</section>
<section>
<h5><a id="c5-sec-0031"/><a id="c5-title-0032"/>Exercise 5.9</h5>
<p class="paraaftertitle"><a id="c5-para-0595"/>The treatment of machine operations above permits them to operate on labels as well as on constants and the contents of registers. Modify the expression-processing functions to enforce the condition that operations can be used only with registers and constants.</p>
</section>
<section>
<h5><a id="c5-sec-0032"/><a id="c5-title-0033"/>Exercise 5.10</h5>
<p class="paraaftertitle"><a id="c5-para-0596"/>When we introduced <span class="KeyTerm1">save</span> and restore in section 5.1.4, we didn't specify what would happen if you tried to restore a register that was not the last one saved, as in the sequence</p>
<p class="Sp-text-1"><a id="c5-para-0597"/>save(y);</p>
<p class="Sp-text-1"><a id="c5-para-0598"/>save(x);</p>
<p class="Sp-text-1"><a id="c5-para-0599"/>restore(y);</p>
<p class="paracontinue"><a id="c5-para-0600"/>There are several reasonable possibilities for the meaning of <span class="KeyTerm1">restore</span>:</p>
<ol class="BS_NumberListA">
<li><a id="c5-li-0013"/><span>a. </span><span class="KeyTerm1">restore(y)</span> puts into <span class="KeyTerm1">y</span> the last value saved on the stack, regardless of what register that value came from. This is the way our simulator behaves. Show how to take advantage of this behavior to eliminate one instruction from the Fibonacci machine of section 5.1.4 (<a href="#c5-fig-0012">figure 5.12</a>).</li>
<li><a id="c5-li-0014"/><span>b. </span><span class="KeyTerm1">restore(y)</span> puts into <span class="KeyTerm1">y</span> the last value saved on the stack, but only if that value was saved from <span class="KeyTerm1">y</span>; otherwise, it signals an error. Modify the simulator to behave this way. You will have to change <span class="KeyTerm1">save</span> to put the register name on the stack along with the value.</li>
<li><a id="c5-li-0015"/><span>c. </span><span class="KeyTerm1">restore(y)</span> puts into <span class="KeyTerm1">y</span> the last value saved from <span class="KeyTerm1">y</span> regardless of what other registers were saved after <span class="KeyTerm1">y</span> and not restored. Modify the simulator to behave this way. You will have to associate a separate stack with each register. You should make the <span class="KeyTerm1">initialize_stack</span> operation initialize all the register stacks.</li>
</ol>
</section>
<section>
<h5><a id="c5-sec-0033"/><a id="c5-title-0034"/>Exercise 5.11</h5>
<p class="paraaftertitle"><a id="c5-para-0604"/>The simulator can be used to help determine the data paths required for implementing a machine with a given controller. Extend the assembler to store the following information in the machine model:</p>
<ul style="list-style-type:disc">
<li>a list of all instructions, with duplicates removed, sorted by instruction type (<span class="KeyTerm1">assign</span>, <span class="KeyTerm1">go_to</span>, and so on);</li>
<li>a list (without duplicates) of the registers used to hold entry points (these are the registers referenced by <span class="KeyTerm1">go_to</span> instructions);</li>
<li>a list (without duplicates) of the registers that are <span class="KeyTerm1">save</span>d or <span class="KeyTerm1">restore</span>d;</li>
<li>for each register, a list (without duplicates) of the sources from which it is assigned (for example, the sources for register <span class="KeyTerm1">val</span> in the factorial machine of <a href="#c5-fig-0011">figure 5.11</a> are <span class="KeyTerm1">constant(1)</span> and <span class="KeyTerm1">list(op("*"), reg("n"), reg("val"))</span>).</li>
</ul>

<p class="paracontinue"><a id="c5-para-0609"/>Extend the message-passing interface to the machine to provide access to this new information. To test your analyzer, define the Fibonacci machine from <a href="#c5-fig-0012">figure 5.12</a> and examine the lists you constructed.</p>
</section>
<section>
<h5><a id="c5-sec-0034"/><a id="c5-title-0035"/>Exercise 5.12</h5>
<p class="paraaftertitle"><a id="c5-para-0610"/>Modify the simulator so that it uses the controller sequence to determine what registers the machine has rather than requiring a list of registers as an argument to <span class="KeyTerm1">make_machine</span>. Instead of preallocating the registers in <span class="KeyTerm1">make_machine</span>, you can allocate them one at a time when they are first seen during assembly of the instructions.</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0035"/><span>5.2.4</span> <a id="c5-title-0036"/>Monitoring Machine Performance</h3>
<p class="paraaftertitle"><a id="c5-para-0611"/>Simulation is useful not only for verifying the correctness of a proposed machine design but also for measuring the machine's performance. For example, we can install in our simulation program a “meter” that measures the number of stack operations used in a computation. To do this, we modify our simulated stack to keep track of the number of times registers are saved on the stack and the maximum depth reached by the stack, and add a message to the stack's interface that prints the statistics, as shown below. We also add an operation to the basic machine model to print the stack statistics, by initializing <span class="KeyTerm1">the_ops</span> in <span class="KeyTerm1">make_new_machine</span> to</p>
<p class="Sp-text-1"><a id="c5-para-0612"/>list(list("initialize_stack",</p>
<p class="Sp-text-1"><a id="c5-para-0613"/>          () =&gt; stack("initialize")),</p>
<p class="Sp-text-1"><a id="c5-para-0614"/>     list("print_stack_statistics",</p>
<p class="Sp-text-1"><a id="c5-para-0615"/>          () =&gt; stack("print_statistics")));</p>
<p class="paracontinue"><a id="c5-para-0616"/>Here is the new version of <span class="KeyTerm1">make_stack</span>:</p>
<p class="Sp-text-1"><a id="c5-para-0617"/><b>function</b> make_stack() {</p>
<p class="Sp-text-1"><a id="c5-para-0618"/>    <b>let</b> stack = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c5-para-0619"/>    <b>let</b> number_pushes = 0;</p>
<p class="Sp-text-1"><a id="c5-para-0620"/>    <b>let</b> max_depth = 0;</p>
<p class="Sp-text-1"><a id="c5-para-0621"/>    <b>let</b> current_depth = 0;</p>
<p class="Sp-text-1"><a id="c5-para-0622"/>    <b>function</b> push(x) {</p>
<p class="Sp-text-1"><a id="c5-para-0623"/>        stack = pair(x, stack);</p>
<p class="Sp-text-1"><a id="c5-para-0624"/>        number_pushes = number_pushes + 1;</p>
<p class="Sp-text-1"><a id="c5-para-0625"/>        current_depth = current_depth + 1;</p>
<p class="Sp-text-1"><a id="c5-para-0626"/>        max_depth = math_max(current_depth, max_depth);</p>
<p class="Sp-text-1"><a id="c5-para-0627"/>        <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c5-para-0628"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0629"/>    <b>function</b> pop() {</p>
<p class="Sp-text-1"><a id="c5-para-0630"/>        <b>if</b> (is_null(stack)) {</p>
<p class="Sp-text-1"><a id="c5-para-0631"/>            error("empty stack – pop");</p>
<p class="Sp-text-1"><a id="c5-para-0632"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c5-para-0633"/>            <b>const</b> top = head(stack);</p>
<p class="Sp-text-1"><a id="c5-para-0634"/>            stack = tail(stack);</p>
<p class="Sp-text-1"><a id="c5-para-0635"/>            current_depth = current_depth - 1;</p>
<p class="Sp-text-1"><a id="c5-para-0636"/>            <b>return</b> top;</p>
<p class="Sp-text-1"><a id="c5-para-0637"/>        }</p>
<p class="Sp-text-1"><a id="c5-para-0638"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0639"/>    <b>function</b> initialize() {</p>
<p class="Sp-text-1"><a id="c5-para-0640"/>        stack = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c5-para-0641"/>        number_pushes = 0;</p>
<p class="Sp-text-1"><a id="c5-para-0642"/>        max_depth = 0;</p>
<p class="Sp-text-1"><a id="c5-para-0643"/>        current_depth = 0;</p>
<p class="Sp-text-1"><a id="c5-para-0644"/>        <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c5-para-0645"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0646"/>    <b>function</b> print_statistics() {</p>
<p class="Sp-text-1"><a id="c5-para-0647"/>        display("total pushes = " + stringify(number_pushes));</p>
<p class="Sp-text-1"><a id="c5-para-0648"/>        display("maximum depth = " + stringify(max_depth));</p>
<p class="Sp-text-1"><a id="c5-para-0649"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0650"/>    <b>function</b> dispatch(message) {</p>
<p class="Sp-text-1"><a id="c5-para-0651"/>        <b>return</b> message === "push"</p>
<p class="Sp-text-1"><a id="c5-para-0652"/>               ? push</p>
<p class="Sp-text-1"><a id="c5-para-0653"/>               : message === "pop"</p>
<p class="Sp-text-1"><a id="c5-para-0654"/>               ? pop()</p>
<p class="Sp-text-1"><a id="c5-para-0655"/>               : message === "initialize"</p>
<p class="Sp-text-1"><a id="c5-para-0656"/>               ? initialize()</p>
<p class="Sp-text-1"><a id="c5-para-0657"/>               : message === "print_statistics"</p>
<p class="Sp-text-1"><a id="c5-para-0658"/>               ? print_statistics()</p>
<p class="Sp-text-1"><a id="c5-para-0659"/>               : error(message, "unknown request – stack");</p>
<p class="Sp-text-1"><a id="c5-para-0660"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0661"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c5-para-0662"/>}</p>
<p><a id="c5-para-0663"/>Exercises 5.14 through 5.18 describe other useful monitoring and debugging features that can be added to the register-machine simulator.</p>
<section>
<h5><a id="c5-sec-0036"/><a id="c5-title-0037"/>Exercise 5.13</h5>
<p class="paraaftertitle"><a id="c5-para-0664"/>Measure the number of pushes and the maximum stack depth required to compute <i>n</i>! for various small values of <i>n</i> using the factorial machine shown in <a href="#c5-fig-0011">Figure 5.11</a>. From your data determine formulas in terms of <i>n</i> for the total number of push operations and the maximum stack depth used in computing <i>n</i>! for any <i>n</i> &gt; 1. Note that each of these is a linear function of <i>n</i> and is thus determined by two constants. In order to get the statistics printed, you will have to augment the factorial machine with instructions to initialize the stack and print the statistics. You may want to also modify the machine so that it repeatedly reads a value for <i>n</i>, computes the factorial, and prints the result (as we did for the GCD machine in <a href="#c5-fig-0004">figure 5.4</a>), so that you will not have to repeatedly invoke <span class="KeyTerm1">get_register_contents</span>, <span class="KeyTerm1">set_register_contents</span>, and <span class="KeyTerm1">start</span>.</p>
</section>
<section>
<h5><a id="c5-sec-0037"/><a id="c5-title-0038"/>Exercise 5.14</h5>
<p class="paraaftertitle"><a id="c5-para-0665"/>Add <i>instruction counting</i> to the register machine simulation. That is, have the machine model keep track of the number of instructions executed. Extend the machine model's interface to accept a new message that prints the value of the instruction count and resets the count to zero.</p>
</section>
<section>
<h5><a id="c5-sec-0038"/><a id="c5-title-0039"/>Exercise 5.15</h5>
<p class="paraaftertitle"><a id="c5-para-0666"/>Augment the simulator to provide for <i>instruction tracing</i>. That is, before each instruction is executed, the simulator should print the instruction. Make the machine model accept <span class="KeyTerm1">trace_on</span> and <span class="KeyTerm1">trace_off</span> messages to turn tracing on and off.</p>
</section>
<section>
<h5><a id="c5-sec-0039"/><a id="c5-title-0040"/>Exercise 5.16</h5>
<p class="paraaftertitle"><a id="c5-para-0667"/>Extend the instruction tracing of exercise 5.15 so that before printing an instruction, the simulator prints any labels that immediately precede that instruction in the controller sequence. Be careful to do this in a way that does not interfere with instruction counting (exercise 5.14). You will have to make the simulator retain the necessary label information.</p>
</section>
<section>
<h5><a id="c5-sec-0040"/><a id="c5-title-0041"/>Exercise 5.17</h5>
<p class="paraaftertitle"><a id="c5-para-0668"/>Modify the <span class="KeyTerm1">make_register</span> function of section 5.2.1 so that registers can be traced. Registers should accept messages that turn tracing on and off. When a register is traced, assigning a value to the register should print the name of the register, the old contents of the register, and the new contents being assigned. Extend the interface to the machine model to permit you to turn tracing on and off for designated machine registers.</p>
</section>
<section>
<h5><a id="c5-sec-0041"/><a id="c5-title-0042"/>Exercise 5.18</h5>
<p class="paraaftertitle"><a id="c5-para-0669"/>Alyssa P. Hacker wants a <i>breakpoint</i> feature in the simulator to help her debug her machine designs. You have been hired to install this feature for her. She wants to be able to specify a place in the controller sequence where the simulator will stop and allow her to examine the state of the machine. You are to implement a function</p>
<p class="Sp-text-1"><a id="c5-para-0670"/>set_breakpoint(<span class="KeyTerm2"><i>machine</i></span>, <span class="KeyTerm2"><i>label</i></span>, <span class="KeyTerm2"><i>n</i></span>)</p>
<p class="paracontinue"><a id="c5-para-0671"/>that sets a breakpoint just before the <i>n</i>th instruction after the given label. For example,</p>
<p class="Sp-text-1"><a id="c5-para-0672"/>set_breakpoint(gcd_machine, "test_b", 4)</p>
<p class="paracontinue"><a id="c5-para-0673"/>installs a breakpoint in <span class="KeyTerm1">gcd_machine</span> just before the assignment to register <span class="KeyTerm1">a</span>. When the simulator reaches the breakpoint it should print the label and the offset of the breakpoint and stop executing instructions. Alyssa can then use <span class="KeyTerm1">get_register_contents</span> and <span class="KeyTerm1">set_register_contents</span> to manipulate the state of the simulated machine. She should then be able to continue execution by saying</p>
<p class="Sp-text-1"><a id="c5-para-0674"/>proceed_machine(<span class="KeyTerm2"><i>machine</i></span>)</p>
<p class="paracontinue"><a id="c5-para-0675"/>She should also be able to remove a specific breakpoint by means of</p>
<p class="Sp-text-1"><a id="c5-para-0676"/>cancel_breakpoint(<span class="KeyTerm2"><i>machine</i></span>, <span class="KeyTerm2"><i>label</i></span>, <span class="KeyTerm2"><i>n</i></span>)</p>
<p class="paracontinue"><a id="c5-para-0677"/>or to remove all breakpoints by means of</p>
<p class="Sp-text-1"><a id="c5-para-0678"/>cancel_all_breakpoints(<span class="KeyTerm2"><i>machine</i></span>)</p>
</section>
</section>
</section>
<section>
<h2><a id="c5-sec-0042"/><span>5.3</span> <a id="c5-title-0043"/>Storage Allocation and Garbage Collection</h2>
<p class="paraaftertitle"><a id="c5-para-0679"/>In section 5.4, we will show how to implement a JavaScript evaluator as a register machine. In order to simplify the discussion, we will assume that our register machines can be equipped with a <i>list-structured memory</i>, in which the basic operations for manipulating list-structured data are primitive. Postulating the existence of such a memory is a useful abstraction when one is focusing on the mechanisms of control in an interpreter, but this does not reflect a realistic view of the actual primitive data operations of contemporary computers. To obtain a more complete picture of how systems can support list-structured memory efficiently, we must investigate how list structure can be represented in a way that is compatible with conventional computer memories.</p>
<p><a id="c5-para-0680"/>There are two considerations in implementing list structure. The first is purely an issue of representation: how to represent the “box-and-pointer” structure of pairs, using only the storage and addressing capabilities of typical computer memories. The second issue concerns the management of memory as a computation proceeds. The operation of a JavaScript system depends crucially on the ability to continually create new data objects. These include objects that are explicitly created by the JavaScript functions being interpreted as well as structures created by the interpreter itself, such as environments and argument lists. Although the constant creation of new data objects would pose no problem on a computer with an infinite amount of rapidly addressable memory, computer memories are available only in finite sizes (more's the pity). JavaScript thus provide an <i>automatic storage allocation</i> facility to support the illusion of an infinite memory. When a data object is no longer needed, the memory allocated to it is automatically recycled and used to construct new data objects. There are various techniques for providing such automatic storage allocation. The method we shall discuss in this section is called <i>garbage collection</i>.</p>
<section>
<h3><a id="c5-sec-0043"/><span>5.3.1</span> <a id="c5-title-0044"/>Memory as Vectors</h3>
<p class="paraaftertitle"><a id="c5-para-0681"/>A conventional computer memory can be thought of as an array of cubbyholes, each of which can contain a piece of information. Each cubbyhole has a unique name, called its <i>address</i> or <i>location</i>. Typical memory systems provide two primitive operations: one that fetches the data stored in a specified location and one that assigns new data to a specified location. Memory addresses can be incremented to support sequential access to some set of the cubbyholes. More generally, many important data operations require that memory addresses be treated as data, which can be stored in memory locations and manipulated in machine registers. The representation of list structure is one application of such <i>address arithmetic</i>.</p>
<p><a id="c5-para-0682"/>To model computer memory, we use a new kind of data structure called a <i>vector</i>. Abstractly, a vector is a compound data object whose individual elements can be accessed by means of an integer index in an amount of time that is independent of the index.<a id="c5-fn-0006a"/><a href="#c5-fn-0006"><sup>6</sup></a> In order to describe memory operations, we use two functions for manipulating vectors:<a id="c5-fn-0007a"/><a href="#c5-fn-0007"><sup>7</sup></a></p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">vector_ref</span>(<i>vector</i>, <i>n</i>) returns the <i>n</i>th element of the vector.</li>
<li><span class="KeyTerm1">vector_set</span>(<i>vector</i>, <i>n</i>, <i>value</i>) sets the <i>n</i>th element of the vector to the designated value.</li>
</ul>

<p class="paracontinue"><a id="c5-para-0685"/>For example, if <span class="KeyTerm1">v</span> is a vector, then <span class="KeyTerm1">vector_ref(v, 5)</span> gets the fifth entry in the vector <span class="KeyTerm1">v</span> and <span class="KeyTerm1">vector_set(v, 5, 7)</span> changes the value of the fifth entry of the vector <span class="KeyTerm1">v</span> to 7.<a id="c5-fn-0008a"/><a href="#c5-fn-0008"><sup>8</sup></a> For computer memory, this access can be implemented through the use of address arithmetic to combine a <i>base address</i> that specifies the beginning location of a vector in memory with an <i>index</i> that specifies the offset of a particular element of the vector.</p>
<section>
<h5><a id="c5-sec-0044"/><a id="c5-title-0045"/>Representing data</h5>
<p class="paraaftertitle"><a id="c5-para-0686"/>We can use vectors to implement the basic pair structures required for a list-structured memory. Let us imagine that computer memory is divided into two vectors: <span class="KeyTerm1">the_heads</span> and <span class="KeyTerm1">the_tails</span>. We will represent list structure as follows: A pointer to a pair is an index into the two vectors. The <span class="KeyTerm1">head</span> of the pair is the entry in <span class="KeyTerm1">the_heads</span> with the designated index, and the tail of the pair is the entry in <span class="KeyTerm1">the_tails</span> with the designated index. We also need a representation for objects other than pairs (such as numbers and strings) and a way to distinguish one kind of data from another. There are many methods of accomplishing this, but they all reduce to using <i>typed pointers</i>, that is, to extending the notion of “pointer” to include information on data type.<a id="c5-fn-0009a"/><a href="#c5-fn-0009"><sup>9</sup></a> The data type enables the system to distinguish a pointer to a pair (which consists of the “pair” data type and an index into the memory vectors) from pointers to other kinds of data (which consist of some other data type and whatever is being used to represent data of that type). Two data objects are considered to be the same (<span class="KeyTerm1">===</span>) if their pointers are identical. <a id="c5-fig-0014a"/><a href="#c5-fig-0014">Figure 5.14</a> illustrates the use of this method to represent <span class="KeyTerm1">list(list(1, 2), 3, 4)</span>, whose box-and-pointer diagram is also shown. We use letter prefixes to denote the data-type information. Thus, a pointer to the pair with index 5 is denoted <span class="KeyTerm1">p5</span>, the empty list is denoted by the pointer <span class="KeyTerm1">e0</span>, and a pointer to the number 4 is denoted <span class="KeyTerm1">n4</span>. In the box-and-pointer diagram, we have indicated at the lower left of each pair the vector index that specifies where the <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> of the pair are stored. The blank locations in <span class="KeyTerm1">the_heads</span> and <span class="KeyTerm1">the_tails</span> may contain parts of other list structures (not of interest here).</p>
<figure id="c5-fig-0014"><img alt="c5-fig-0014.jpg" src="../images/c5-fig-0014.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0014a">Figure 5.14</a></span> <a id="c5-para-0687"/>Box-and-pointer and memory-vector representations of the list <span class="KeyTerm1">list(list(1, 2), 3, 4)</span>.</p></figcaption></figure>
<p><a id="c5-para-0688"/>A pointer to a number, such as <span class="KeyTerm1">n4</span>, might consist of a type indicating numeric data together with the actual representation of the number 4.<a id="c5-fn-0010a"/><a href="#c5-fn-0010"><sup>10</sup></a> To deal with numbers that are too large to be represented in the fixed amount of space allocated for a single pointer, we could use a distinct <i>bignum</i> data type, for which the pointer designates a list in which the parts of the number are stored.<a id="c5-fn-0011a"/><a href="#c5-fn-0011"><sup>11</sup></a></p>
<p><a id="c5-para-0689"/>A string might be represented as a typed pointer that designates a sequence of the characters that form the string's printed representation. The parser constructs such a sequence when it encounters a string literal, and the string-concatenation operator <span class="KeyTerm1">+</span> and string-producing primitive functions such as <span class="KeyTerm1">stringify</span> construct such a sequence. Since we want two instances of a string to be recognized as the “same” string by <span class="KeyTerm1">===</span> and we want <span class="KeyTerm1">===</span> to be a simple test for equality of pointers, we must ensure that if the system sees the same string twice, it will use the same pointer (to the same sequence of characters) to represent both occurrences. To accomplish this, the system maintains a table, called the <i>string pool</i>, of all the strings it has ever encountered. When the system is about to construct a string, it checks the string pool to see if it has ever before seen the same string. If it has not, it constructs a new string (a typed pointer to a new character sequence) and enters this pointer in the string pool. If the system has seen the string before, it returns the string pointer stored in the string pool. This process of replacing strings by unique pointers is called <i>string interning</i>.</p>
</section>
<section>
<h5><a id="c5-sec-0045"/><a id="c5-title-0046"/>Implementing the primitive list operations</h5>
<p class="paraaftertitle"><a id="c5-para-0690"/>Given the above representation scheme, we can replace each “primitive” list operation of a register machine with one or more primitive vector operations. We will use two registers, <span class="KeyTerm1">the_heads</span> and <span class="KeyTerm1">the_tails</span>, to identify the memory vectors, and will assume that <span class="KeyTerm1">vector_ref</span> and <span class="KeyTerm1">vector_set</span> are available as primitive operations. We also assume that numeric operations on pointers (such as incrementing a pointer, using a pair pointer to index a vector, or adding two numbers) use only the index portion of the typed pointer.</p>
<p><a id="c5-para-0691"/>For example, we can make a register machine support the instructions</p>
<p class="Sp-text-1"><a id="c5-para-0692"/>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, list(op("head"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0693"/>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, list(op("tail"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="paracontinue"><a id="c5-para-0694"/>if we implement these, respectively, as</p>
<p class="Sp-text-1"><a id="c5-para-0695"/>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, list(op("vector_ref"), reg("the_heads"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0696"/>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, list(op("vector_ref"), reg("the_tails"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="paracontinue"><a id="c5-para-0697"/>The instructions</p>
<p class="Sp-text-1"><a id="c5-para-0698"/>perform(list(op("set_head"), reg(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0699"/>perform(list(op("set_tail"), reg(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="paracontinue"><a id="c5-para-0700"/>are implemented as</p>
<p class="Sp-text-1"><a id="c5-para-0701"/>perform(list(op("vector_set"), reg("the_heads"), reg(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0702"/>perform(list(op("vector_set"), reg("the_tails"), reg(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p><a id="c5-para-0703"/>The operation <span class="KeyTerm1">pair</span> is performed by allocating an unused index and storing the arguments to <span class="KeyTerm1">pair</span> in <span class="KeyTerm1">the_heads</span> and <span class="KeyTerm1">the_tails</span> at that indexed vector position. We presume that there is a special register, <span class="KeyTerm1">free</span>, that always holds a pair pointer containing the next available index, and that we can increment the index part of that pointer to find the next free location.<a id="c5-fn-0012a"/><a href="#c5-fn-0012"><sup>12</sup></a> For example, the instruction</p>
<p class="Sp-text-1"><a id="c5-para-0704"/>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, list(op("pair"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>3</sub></span>)))</p>
<p class="paracontinue"><a id="c5-para-0705"/>is implemented as the following sequence of vector operations:<a id="c5-fn-0013a"/><a href="#c5-fn-0013"><sup>13</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-0706"/>perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c5-para-0707"/>             reg("the_heads"), reg("free"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>))),</p>
<p class="Sp-text-1"><a id="c5-para-0708"/>perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c5-para-0709"/>             reg("the_tails"), reg("free"), reg(<span class="KeyTerm2"><i>reg</i><sub>3</sub></span>))),</p>
<p class="Sp-text-1"><a id="c5-para-0710"/>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, reg("free")),</p>
<p class="Sp-text-1"><a id="c5-para-0711"/>assign("free", list(op("+"), reg("free"), constant(1)))</p>
<p><a id="c5-para-0712"/>The <span class="KeyTerm1">===</span> operation</p>
<p class="Sp-text-1"><a id="c5-para-0713"/>list(op("==="), reg(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>))</p>
<p class="paracontinue"><a id="c5-para-0714"/>simply tests the equality of all fields in the registers, and predicates such as <span class="KeyTerm1">is_pair</span>, <span class="KeyTerm1">is_null</span>, <span class="KeyTerm1">is_string</span>, and <span class="KeyTerm1">is_number</span> need only check the type field.</p>
</section>
<section>
<h5><a id="c5-sec-0046"/><a id="c5-title-0047"/>Implementing stacks</h5>
<p class="paraaftertitle"><a id="c5-para-0715"/>Although our register machines use stacks, we need do nothing special here, since stacks can be modeled in terms of lists. The stack can be a list of the saved values, pointed to by a special register <span class="KeyTerm1">the_stack</span>. Thus, <span class="KeyTerm1">save(</span><i>reg</i><span class="KeyTerm1">)</span> can be implemented as</p>
<p class="Sp-text-1"><a id="c5-para-0716"/>assign("the_stack", list(op("pair"), reg(<span class="KeyTerm2"><i>reg</i></span>), reg("the_stack")))</p>
<p class="paracontinue"><a id="c5-para-0717"/>Similarly, <span class="KeyTerm1">restore(</span><i>reg</i><span class="KeyTerm1">)</span> can be implemented as</p>
<p class="Sp-text-1"><a id="c5-para-0718"/>assign(<span class="KeyTerm2"><i>reg</i></span>, list(op("head"), reg("the_stack")))</p>
<p class="Sp-text-1"><a id="c5-para-0719"/>assign("the_stack", list(op("tail"), reg("the_stack")))</p>
<p class="paracontinue"><a id="c5-para-0720"/>and <span class="KeyTerm1">perform(list(op("initialize_stack")))</span> can be implemented as</p>
<p class="Sp-text-1"><a id="c5-para-0721"/>assign("the_stack", constant(<b>null</b>))</p>
<p class="paracontinue"><a id="c5-para-0722"/>These operations can be further expanded in terms of the vector operations given above. In conventional computer architectures, however, it is usually advantageous to allocate the stack as a separate vector. Then pushing and popping the stack can be accomplished by incrementing or decrementing an index into that vector.</p>
</section>
<section>
<h5><a id="c5-sec-0047"/><a id="c5-title-0048"/>Exercise 5.19</h5>
<p class="paraaftertitle"><a id="c5-para-0723"/>Draw the box-and-pointer representation and the memory-vector representation (as in <a href="#c5-fig-0014">figure 5.14</a>) of the list structure produced by</p>
<p class="Sp-text-1"><a id="c5-para-0724"/><b>const</b> x = pair(1, 2);</p>
<p class="Sp-text-1"><a id="c5-para-0725"/><b>const</b> y = list(x, x);</p>
<p class="paracontinue"><a id="c5-para-0726"/>with the <span class="KeyTerm1">free</span> pointer initially <span class="KeyTerm1">p1</span>. What is the final value of <span class="KeyTerm1">free</span> ? What pointers represent the values of <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span>?</p>
</section>
<section>
<h5><a id="c5-sec-0048"/><a id="c5-title-0049"/>Exercise 5.20</h5>
<p class="paraaftertitle"><a id="c5-para-0727"/>Implement register machines for the following functions. Assume that the list-structure memory operations are available as machine primitives.</p>
<ol class="BS_NumberListA">
<li><a id="c5-li-0022"/><span>a. </span>Recursive <span class="KeyTerm1">count_leaves</span>:
<p class="Sp-text-1"><a id="c5-para-0729"/><b>function</b> count_leaves(tree) {</p>
<p class="Sp-text-1"><a id="c5-para-0730"/>    <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c5-para-0731"/>           ? 0</p>
<p class="Sp-text-1"><a id="c5-para-0732"/>           : ! is_pair(tree)</p>
<p class="Sp-text-1"><a id="c5-para-0733"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-0734"/>           : count_leaves(head(tree)) +</p>
<p class="Sp-text-1"><a id="c5-para-0735"/>             count_leaves(tail(tree));</p>
<p class="Sp-text-1"><a id="c5-para-0736"/>}</p></li>
<li><a id="c5-li-0023"/><span>b. </span>Recursive <span class="KeyTerm1">count_leaves</span> with explicit counter:
<p class="Sp-text-1"><a id="c5-para-0738"/><b>function</b> count_leaves(tree) {</p>
<p class="Sp-text-1"><a id="c5-para-0739"/>    <b>function</b> count_iter(tree, n) {</p>
<p class="Sp-text-1"><a id="c5-para-0740"/>    <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c5-para-0741"/>               ? n</p>
<p class="Sp-text-1"><a id="c5-para-0742"/>               : ! is_pair(tree)</p>
<p class="Sp-text-1"><a id="c5-para-0743"/>               ? n + 1</p>
<p class="Sp-text-1"><a id="c5-para-0744"/>               : count_iter(tail(tree),</p>
<p class="Sp-text-1"><a id="c5-para-0745"/>                            count_iter(head(tree), n));</p>
<p class="Sp-text-1"><a id="c5-para-0746"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-0747"/>    <b>return</b> count_iter(tree, 0);</p>
<p class="Sp-text-1"><a id="c5-para-0748"/>}</p></li>
</ol>
</section>
<section>
<h5><a id="c5-sec-0049"/><a id="c5-title-0050"/>Exercise 5.21</h5>
<p class="paraaftertitle"><a id="c5-para-0749"/>Exercise 3.12 of section 3.3.1 presented an <span class="KeyTerm1">append</span> function that appends two lists to form a new list and an <span class="KeyTerm1">append_mutator</span> function that splices two lists together. Design a register machine to implement each of these functions. Assume that the list-structure memory operations are available as primitive operations.</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0050"/><span>5.3.2</span> <a id="c5-title-0051"/>Maintaining the Illusion of Infinite Memory</h3>
<p class="paraaftertitle"><a id="c5-para-0750"/>The representation method outlined in section 5.3.1 solves the problem of implementing list structure, provided that we have an infinite amount of memory. With a real computer we will eventually run out of free space in which to construct new pairs.<a id="c5-fn-0014a"/><a href="#c5-fn-0014"><sup>14</sup></a> However, most of the pairs generated in a typical computation are used only to hold intermediate results. After these results are accessed, the pairs are no longer needed—they are <i>garbage</i>. For instance, the computation</p>
<p class="Sp-text-1"><a id="c5-para-0751"/>accumulate((x, y) =&gt; x + y,</p>
<p class="Sp-text-1"><a id="c5-para-0752"/>           0,</p>
<p class="Sp-text-1"><a id="c5-para-0753"/>           filter(is_odd, enumerate_interval(0, n)))</p>
<p class="paracontinue"><a id="c5-para-0754"/>constructs two lists: the enumeration and the result of filtering the enumeration. When the accumulation is complete, these lists are no longer needed, and the allocated memory can be reclaimed. If we can arrange to collect all the garbage periodically, and if this turns out to recycle memory at about the same rate at which we construct new pairs, we will have preserved the illusion that there is an infinite amount of memory.</p>
<p><a id="c5-para-0755"/>In order to recycle pairs, we must have a way to determine which allocated pairs are not needed (in the sense that their contents can no longer influence the future of the computation). The method we shall examine for accomplishing this is known as <i>garbage collection</i>. Garbage collection is based on the observation that, at any moment in an interpretation based on list-structured memory, the only objects that can affect the future of the computation are those that can be reached by some succession of <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> operations starting from the pointers that are currently in the machine registers.<a id="c5-fn-0015a"/><a href="#c5-fn-0015"><sup>15</sup></a> Any memory cell that is not so accessible may be recycled.</p>
<p><a id="c5-para-5755"/>There are many ways to perform garbage collection. The method we shall examine here is called <i>stop-and-copy</i>. The basic idea is to divide memory into two halves: “working memory” and “free memory.” When <span class="KeyTerm1">pair</span> constructs pairs, it allocates these in working memory. When working memory is full, we perform garbage collection by locating all the useful pairs in working memory and copying these into consecutive locations in free memory. (The useful pairs are located by tracing all the <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> pointers, starting with the machine registers.) Since we do not copy the garbage, there will presumably be additional free memory that we can use to allocate new pairs. In addition, nothing in the working memory is needed, since all the useful pairs in it have been copied. Thus, if we interchange the roles of working memory and free memory, we can continue processing; new pairs will be allocated in the new working memory (which was the old free memory). When this is full, we can copy the useful pairs into the new free memory (which was the old working memory).<a id="c5-fn-0016a"/><a href="#c5-fn-0016"><sup>16</sup></a></p>
<section>
<h5><a id="c5-sec-0051"/><a id="c5-title-0052"/>Implementation of a stop-and-copy garbage collector</h5>
<p class="paraaftertitle"><a id="c5-para-0756"/>We now use our register-machine language to describe the stop-and-copy algorithm in more detail. We will assume that there is a register called <span class="KeyTerm1">root</span> that contains a pointer to a structure that eventually points at all accessible data. This can be arranged by storing the contents of all the machine registers in a preallocated list pointed at by <span class="KeyTerm1">root</span> just before starting garbage collection.<a id="c5-fn-0017a"/><a href="#c5-fn-0017"><sup>17</sup></a> We also assume that, in addition to the current working memory, there is free memory available into which we can copy the useful data. The current working memory consists of vectors whose base addresses are in registers called <span class="KeyTerm1">the_heads</span> and <span class="KeyTerm1">the_tails</span>, and the free memory is in registers called <span class="KeyTerm1">new_heads</span> and <span class="KeyTerm1">new_tails</span>.</p>
<p><a id="c5-para-0757"/>Garbage collection is triggered when we exhaust the free cells in the current working memory, that is, when a <span class="KeyTerm1">pair</span> operation attempts to increment the <span class="KeyTerm1">free</span> pointer beyond the end of the memory vector. When the garbage-collection process is complete, the <span class="KeyTerm1">root</span> pointer will point into the new memory, all objects accessible from the <span class="KeyTerm1">root</span> will have been moved to the new memory, and the <span class="KeyTerm1">free</span> pointer will indicate the next place in the new memory where a new pair can be allocated. In addition, the roles of working memory and new memory will have been interchanged—new pairs will be constructed in the new memory, beginning at the place indicated by <span class="KeyTerm1">free</span>, and the (previous) working memory will be available as the new memory for the next garbage collection. <a id="c5-fig-0015a"/><a href="#c5-fig-0015">Figure 5.15</a> shows the arrangement of memory just before and just after garbage collection.</p>
<figure id="c5-fig-0015"><img alt="c5-fig-0015.jpg" src="../images/c5-fig-0015.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0015a">Figure 5.15</a></span> <a id="c5-para-0759"/>Reconfiguration of memory by the garbage-collection process.</p></figcaption></figure>
<p><a id="c5-para-0760"/>The state of the garbage-collection process is controlled by maintaining two pointers: <span class="KeyTerm1">free</span> and <span class="KeyTerm1">scan</span>. These are initialized to point to the beginning of the new memory. The algorithm begins by relocating the pair pointed at by <span class="KeyTerm1">root</span> to the beginning of the new memory. The pair is copied, the <span class="KeyTerm1">root</span> pointer is adjusted to point to the new location, and the <span class="KeyTerm1">free</span> pointer is incremented. In addition, the old location of the pair is marked to show that its contents have been moved. This marking is done as follows: In the <span class="KeyTerm1">head</span> position, we place a special tag that signals that this is an already-moved object. (Such an object is traditionally called a <i>broken heart</i>.)<a id="c5-fn-0018a"/><a href="#c5-fn-0018"><sup>18</sup></a> In the <span class="KeyTerm1">tail</span> position we place a <i>forwarding address</i> that points at the location to which the object has been moved.</p>
<p><a id="c5-para-0761"/>After relocating the root, the garbage collector enters its basic cycle. At each step in the algorithm, the <span class="KeyTerm1">scan</span> pointer (initially pointing at the relocated root) points at a pair that has been moved to the new memory but whose <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> pointers still refer to objects in the old memory. These objects are each relocated, and the <span class="KeyTerm1">scan</span> pointer is incremented. To relocate an object (for example, the object indicated by the <span class="KeyTerm1">head</span> pointer of the pair we are scanning) we check to see if the object has already been moved (as indicated by the presence of a broken-heart tag in the <span class="KeyTerm1">head</span> position of the object). If the object has not already been moved, we copy it to the place indicated by <span class="KeyTerm1">free</span>, update <span class="KeyTerm1">free</span>, set up a broken heart at the object's old location, and update the pointer to the object (in this example, the <span class="KeyTerm1">head</span> pointer of the pair we are scanning) to point to the new location. If the object has already been moved, its forwarding address (found in the <span class="KeyTerm1">tail</span> position of the broken heart) is substituted for the pointer in the pair being scanned. Eventually, all accessible objects will have been moved and scanned, at which point the <span class="KeyTerm1">scan</span> pointer will overtake the <span class="KeyTerm1">free</span> pointer and the process will terminate.</p>
<p><a id="c5-para-0762"/>We can specify the stop-and-copy algorithm as a sequence of instructions for a register machine. The basic step of relocating an object is accomplished by a subroutine called <span class="KeyTerm1">relocate_old_result_in_new</span>. This subroutine gets its argument, a pointer to the object to be relocated, from a register named <span class="KeyTerm1">old</span>. It relocates the designated object (incrementing <span class="KeyTerm1">free</span> in the process), puts a pointer to the relocated object into a register called <span class="KeyTerm1">new</span>, and returns by branching to the entry point stored in the register <span class="KeyTerm1">relocate_continue</span>. To begin garbage collection, we invoke this subroutine to relocate the <span class="KeyTerm1">root</span> pointer, after initializing <span class="KeyTerm1">free</span> and <span class="KeyTerm1">scan</span>. When the relocation of <span class="KeyTerm1">root</span> has been accomplished, we install the new pointer as the new <span class="KeyTerm1">root</span> and enter the main loop of the garbage collector.</p>
<p class="Sp-text-1"><a id="c5-para-0763"/>"begin_garbage_collection",</p>
<p class="Sp-text-1"><a id="c5-para-0764"/>  assign("free", constant(0)),</p>
<p class="Sp-text-1"><a id="c5-para-0765"/>  assign("scan", constant(0)),</p>
<p class="Sp-text-1"><a id="c5-para-0766"/>  assign("old", reg("root")),</p>
<p class="Sp-text-1"><a id="c5-para-0767"/>  assign("relocate_continue", label("reassign_root")),</p>
<p class="Sp-text-1"><a id="c5-para-0768"/>  go_to(label("relocate_old_result_in_new")),</p>
<p class="Sp-text-1"><a id="c5-para-0769"/>"reassign_root",</p>
<p class="Sp-text-1"><a id="c5-para-0770"/>  assign("root", reg("new")),</p>
<p class="Sp-text-1"><a id="c5-para-0771"/>  go_to(label("gc_loop")),</p>
<p><a id="c5-para-0772"/>In the main loop of the garbage collector we must determine whether there are any more objects to be scanned. We do this by testing whether the <span class="KeyTerm1">scan</span> pointer is coincident with the <span class="KeyTerm1">free</span> pointer. If the pointers are equal, then all accessible objects have been relocated, and we branch to <span class="KeyTerm1">gc_flip</span>, which cleans things up so that we can continue the interrupted computation. If there are still pairs to be scanned, we call the relocate subroutine to relocate the <span class="KeyTerm1">head</span> of the next pair (by placing the <span class="KeyTerm1">head</span> pointer in <span class="KeyTerm1">old</span>). The <span class="KeyTerm1">relocate_continue</span> register is set up so that the subroutine will return to update the <span class="KeyTerm1">head</span> pointer.</p>
<p class="Sp-text-1"><a id="c5-para-0773"/>"gc_loop",</p>
<p class="Sp-text-1"><a id="c5-para-0774"/>  test(list(op("==="), reg("scan"), reg("free"))),</p>
<p class="Sp-text-1"><a id="c5-para-0775"/>  branch(label("gc_flip")),</p>
<p class="Sp-text-1"><a id="c5-para-0776"/>  assign("old", list(op("vector_ref"), reg("new_heads"), reg("scan"))),</p>
<p class="Sp-text-1"><a id="c5-para-0777"/>  assign("relocate_continue", label("update_head")),</p>
<p class="Sp-text-1"><a id="c5-para-0778"/>  go_to(label("relocate_old_result_in_new")),</p>
<p><a id="c5-para-0779"/>At <span class="KeyTerm1">update_head</span>, we modify the <span class="KeyTerm1">head</span> pointer of the pair being scanned, then proceed to relocate the <span class="KeyTerm1">tail</span> of the pair. We return to <span class="KeyTerm1">update_tail</span> when that relocation has been accomplished. After relocating and updating the <span class="KeyTerm1">tail</span>, we are finished scanning that pair, so we continue with the main loop.</p>
<p class="Sp-text-1"><a id="c5-para-0780"/>"update_head",</p>
<p class="Sp-text-1"><a id="c5-para-0781"/>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c5-para-0782"/>               reg("new_heads"), reg("scan"), reg("new"))),</p>
<p class="Sp-text-1"><a id="c5-para-0783"/>  assign("old", list(op("vector_ref"),</p>
<p class="Sp-text-1"><a id="c5-para-0784"/>                     reg("new_tails"), reg("scan"))),</p>
<p class="Sp-text-1"><a id="c5-para-0785"/>  assign("relocate_continue", label("update_tail")),</p>
<p class="Sp-text-1"><a id="c5-para-0786"/>  go_to(label("relocate_old_result_in_new")),</p>
<p class="Sp-text-1"><a id="c5-para-0787"/>"update_tail",</p>
<p class="Sp-text-1"><a id="c5-para-0788"/>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c5-para-0789"/>               reg("new_tails"), reg("scan"), reg("new"))),</p>
<p class="Sp-text-1"><a id="c5-para-0790"/>  assign("scan", list(op("+"), reg("scan"), constant(1))),</p>
<p class="Sp-text-1"><a id="c5-para-0791"/>  go_to(label("gc_loop")),</p>
<p><a id="c5-para-0792"/>The subroutine <span class="KeyTerm1">relocate_old_result_in_new</span> relocates objects as follows: If the object to be relocated (pointed at by <span class="KeyTerm1">old</span>) is not a pair, then we return the same pointer to the object unchanged (in <span class="KeyTerm1">new</span>). (For example, we may be scanning a pair whose <span class="KeyTerm1">head</span> is the number 4. If we represent the <span class="KeyTerm1">head</span> by <span class="KeyTerm1">n4</span>, as described in section 5.3.1, then we want the “relocated” <span class="KeyTerm1">head</span> pointer to still be <span class="KeyTerm1">n4</span>.) Otherwise, we must perform the relocation. If the <span class="KeyTerm1">head</span> position of the pair to be relocated contains a broken-heart tag, then the pair has in fact already been moved, so we retrieve the forwarding address (from the <span class="KeyTerm1">tail</span> position of the broken heart) and return this in <span class="KeyTerm1">new</span>. If the pointer in <span class="KeyTerm1">old</span> points at a yet-unmoved pair, then we move the pair to the first free cell in new memory (pointed at by <span class="KeyTerm1">free</span>) and set up the broken heart by storing a broken-heart tag and forwarding address at the old location. The subroutine <span class="KeyTerm1">relocate_old_result_in_new</span> uses a register <span class="KeyTerm1">oldht</span> to hold the <span class="KeyTerm1">head</span> or the <span class="KeyTerm1">tail</span> of the object pointed at by <span class="KeyTerm1">old</span>.<a id="c5-fn-0019a"/><a href="#c5-fn-0019"><sup>19</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-0793"/>"relocate_old_result_in_new",</p>
<p class="Sp-text-1"><a id="c5-para-0794"/>  test(list(op("is_pointer_to_pair"), reg("old"))),</p>
<p class="Sp-text-1"><a id="c5-para-0795"/>  branch(label("pair")),</p>
<p class="Sp-text-1"><a id="c5-para-0796"/>  assign("new", reg("old")),</p>
<p class="Sp-text-1"><a id="c5-para-0797"/>  go_to(reg("relocate_continue")),</p>
<p class="Sp-text-1"><a id="c5-para-0798"/>"pair",</p>
<p class="Sp-text-1"><a id="c5-para-0799"/>  assign("oldht", list(op("vector_ref"),</p>
<p class="Sp-text-1"><a id="c5-para-0800"/>                       reg("the_heads"), reg("old"))),</p>
<p class="Sp-text-1"><a id="c5-para-0801"/>  test(list(op("is_broken_heart"), reg("oldht"))),</p>
<p class="Sp-text-1"><a id="c5-para-0802"/>  branch(label("already_moved")),</p>
<p class="Sp-text-1"><a id="c5-para-0803"/>  assign("new", reg("free")),     <i>//</i> <span class="KeyTerm2"><i>new location for pair</i></span></p>
<p class="Sp-text-1"><a id="c5-para-0804"/>  <i>//</i> <span class="KeyTerm2"><i>Update</i></span> free <span class="KeyTerm2"><i>pointer</i></span></p>
<p class="Sp-text-1"><a id="c5-para-0805"/>  assign("free", list(op("+"), reg("free"), constant(1))),</p>
<p class="Sp-text-1"><a id="c5-para-0806"/>  <i>//</i> <span class="KeyTerm2"><i>Copy the head and tail to new memory</i></span></p>
<p class="Sp-text-1"><a id="c5-para-0807"/>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c5-para-0808"/>               reg("new_heads"), reg("new"),</p>
<p class="Sp-text-1"><a id="c5-para-0809"/>               reg("oldht"))),</p>
<p class="Sp-text-1"><a id="c5-para-0810"/>  assign("oldht", list(op("vector_ref"),</p>
<p class="Sp-text-1"><a id="c5-para-0811"/>                      reg("the_tails"), reg("old"))),</p>
<p class="Sp-text-1"><a id="c5-para-0812"/>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c5-para-0813"/>               reg("new_tails"), reg("new"),</p>
<p class="Sp-text-1"><a id="c5-para-0814"/>               reg("oldht"))),</p>
<p class="Sp-text-1"><a id="c5-para-0815"/>  <i>//</i> <span class="KeyTerm2"><i>Construct the broken heart</i></span></p>
<p class="Sp-text-1"><a id="c5-para-0816"/>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c5-para-0817"/>               reg("the_heads"), reg("old"),</p>
<p class="Sp-text-1"><a id="c5-para-0818"/>               constant("broken_heart"))),</p>
<p class="Sp-text-1"><a id="c5-para-0819"/>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c5-para-0820"/>               reg("the_tails"), reg("old"),</p>
<p class="Sp-text-1"><a id="c5-para-0821"/>               reg("new"))),</p>
<p class="Sp-text-1"><a id="c5-para-0822"/>  go_to(reg("relocate_continue")),</p>
<p class="Sp-text-1"><a id="c5-para-0823"/>"already_moved",</p>
<p class="Sp-text-1"><a id="c5-para-0824"/>  assign("new", list(op("vector_ref"),</p>
<p class="Sp-text-1"><a id="c5-para-0825"/>                     reg("the_tails"), reg("old"))),</p>
<p class="Sp-text-1"><a id="c5-para-0826"/>  go_to(reg("relocate_continue")),</p>
<p><a id="c5-para-0827"/>At the very end of the garbage collection process, we interchange the role of old and new memories by interchanging pointers: interchanging <span class="KeyTerm1">the_heads</span> with <span class="KeyTerm1">new_heads</span>, and <span class="KeyTerm1">the_tails</span> with <span class="KeyTerm1">new_tails</span>. We will then be ready to perform another garbage collection the next time memory runs out.</p>
<p class="Sp-text-1"><a id="c5-para-0828"/>"gc_flip",</p>
<p class="Sp-text-1"><a id="c5-para-0829"/>  assign("temp", reg("the_tails")),</p>
<p class="Sp-text-1"><a id="c5-para-0830"/>  assign("the_tails", reg("new_tails")),</p>
<p class="Sp-text-1"><a id="c5-para-0831"/>  assign("new_tails", reg("temp")),</p>
<p class="Sp-text-1"><a id="c5-para-0832"/>  assign("temp", reg("the_heads")),</p>
<p class="Sp-text-1"><a id="c5-para-0833"/>  assign("the_heads", reg("new_heads")),</p>
<p class="Sp-text-1"><a id="c5-para-0834"/>  assign("new_heads", reg("temp"))</p>
</section>
</section>
</section>
<section>
<h2><a id="c5-sec-0052"/><span>5.4</span> <a id="c5-title-0053"/>The Explicit-Control Evaluator</h2>
<p class="paraaftertitle"><a id="c5-para-0835"/>In section 5.1 we saw how to transform simple JavaScript programs into descriptions of register machines. We will now perform this transformation on a more complex program, the metacircular evaluator of sections 4.1.1–4.1.4, which shows how the behavior of a JavaScript interpreter can be described in terms of the functions <span class="KeyTerm1">evaluate</span> and <span class="KeyTerm1">apply</span>. The <i>explicit-control evaluator</i> that we develop in this section shows how the underlying function-calling and argument-passing mechanisms used in the evaluation process can be described in terms of operations on registers and stacks. In addition, the explicit-control evaluator can serve as an implementation of a JavaScript interpreter, written in a language that is very similar to the native machine language of conventional computers. The evaluator can be executed by the register-machine simulator of section 5.2. Alternatively, it can be used as a starting point for building a machine-language implementation of a JavaScript evaluator, or even a special-purpose machine for evaluating JavaScript programs. <a id="c5-fig-0016a"/><a href="#c5-fig-0016">Figure 5.16</a> shows such a hardware implementation: a silicon chip that acts as an evaluator for Scheme, the language used in place of JavaScript in the original edition of this book. The chip designers started with the data-path and controller specifications for a register machine similar to the evaluator described in this section and used design automation programs to construct the integrated-circuit layout.<a id="c5-fn-0020a"/><a href="#c5-fn-0020"><sup>20</sup></a></p>
<figure id="c5-fig-0016"><img alt="c5-fig-0016.jpg" src="../images/c5-fig-0016.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0016a">Figure 5.16</a></span> <a id="c5-para-0836"/>A silicon-chip implementation of an evaluator for Scheme.</p></figcaption></figure>
<section><a id="c5-title-0054"/>
<section>
<h5><a id="c5-sec-0054"/><a id="c5-title-0055"/>Registers and operations</h5>
<p class="paraaftertitle"><a id="c5-para-0837"/>In designing the explicit-control evaluator, we must specify the operations to be used in our register machine. We described the metacircular evaluator in terms of abstract syntax, using functions such as <span class="KeyTerm1">is_literal</span> and <span class="KeyTerm1">make_function</span>. In implementing the register machine, we could expand these functions into sequences of elementary list-structure memory operations, and implement these operations on our register machine. However, this would make our evaluator very long, obscuring the basic structure with details. To clarify the presentation, we will include as primitive operations of the register machine the syntax functions given in section 4.1.2 and the functions for representing environments and other runtime data given in sections 4.1.3 and 4.1.4. In order to completely specify an evaluator that could be programmed in a low-level machine language or implemented in hardware, we would replace these operations by more elementary operations, using the list-structure implementation we described in section 5.3.</p>
<p><a id="c5-para-0838"/>Our JavaScript evaluator register machine includes a stack and seven registers: <span class="KeyTerm1">comp</span>, <span class="KeyTerm1">env</span>, <span class="KeyTerm1">val</span>, <span class="KeyTerm1">continue</span>, <span class="KeyTerm1">fun</span>, <span class="KeyTerm1">argl</span>, and <span class="KeyTerm1">unev</span>. The <span class="KeyTerm1">comp</span> register is used to hold the component to be evaluated, and <span class="KeyTerm1">env</span> contains the environment in which the evaluation is to be performed. At the end of an evaluation, <span class="KeyTerm1">val</span> contains the value obtained by evaluating the component in the designated environment. The <span class="KeyTerm1">continue</span> register is used to implement recursion, as explained in section 5.1.4. (The evaluator needs to call itself recursively, since evaluating a component requires evaluating its subcomponents.) The registers <span class="KeyTerm1">fun</span>, <span class="KeyTerm1">argl</span>, and <span class="KeyTerm1">unev</span> are used in evaluating function applications.</p>
<p><a id="c5-para-0839"/>We will not provide a data-path diagram to show how the registers and operations of the evaluator are connected, nor will we give the complete list of machine operations. These are implicit in the evaluator's controller, which will be presented in detail.</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0055"/><span>5.4.1</span> <a id="c5-title-0056"/>The Dispatcher and Basic Evaluation</h3>
<p class="paraaftertitle"><a id="c5-para-0840"/>The central element in the evaluator is the sequence of instructions beginning at <span class="KeyTerm1">eval_dispatch</span>. This corresponds to the <span class="KeyTerm1">evaluate</span> function of the metacircular evaluator described in section 4.1.1. When the controller starts at <span class="KeyTerm1">eval_dispatch</span>, it evaluates the component specified by <span class="KeyTerm1">comp</span> in the environment specified by <span class="KeyTerm1">env</span>. When evaluation is complete, the controller will go to the entry point stored in <span class="KeyTerm1">continue</span>, and the <span class="KeyTerm1">val</span> register will hold the value of the component. As with the metacircular <span class="KeyTerm1">evaluate</span>, the structure of <span class="KeyTerm1">eval_dispatch</span> is a case analysis on the syntactic type of the component to be evaluated.<a id="c5-fn-0021a"/><a href="#c5-fn-0021"><sup>21</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-0841"/>"eval_dispatch",</p>
<p class="Sp-text-1"><a id="c5-para-0842"/>  test(list(op("is_literal"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0843"/>  branch(label("ev_literal")),</p>
<p class="Sp-text-1"><a id="c5-para-0844"/>  test(list(op("is_name"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0845"/>  branch(label("ev_name")),</p>
<p class="Sp-text-1"><a id="c5-para-0846"/>  test(list(op("is_application"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0847"/>  branch(label("ev_application")),</p>
<p class="Sp-text-1"><a id="c5-para-0848"/>  test(list(op("is_operator_combination"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0849"/>  branch(label("ev_operator_combination")),</p>
<p class="Sp-text-1"><a id="c5-para-0850"/>  test(list(op("is_conditional"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0851"/>  branch(label("ev_conditional")),</p>
<p class="Sp-text-1"><a id="c5-para-0852"/>  test(list(op("is_lambda_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0853"/>  branch(label("ev_lambda")),</p>
<p class="Sp-text-1"><a id="c5-para-0854"/>  test(list(op("is_sequence"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0855"/>  branch(label("ev_sequence")),</p>
<p class="Sp-text-1"><a id="c5-para-0856"/>  test(list(op("is_block"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0857"/>  branch(label("ev_block")),</p>
<p class="Sp-text-1"><a id="c5-para-0858"/>  test(list(op("is_return_statement"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0859"/>  branch(label("ev_return")),</p>
<p class="Sp-text-1"><a id="c5-para-0860"/>  test(list(op("is_function_declaration"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0861"/>  branch(label("ev_function_declaration")),</p>
<p class="Sp-text-1"><a id="c5-para-0862"/>  test(list(op("is_declaration"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0863"/>  branch(label("ev_declaration")),</p>
<p class="Sp-text-1"><a id="c5-para-0864"/>  test(list(op("is_assignment"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0865"/>  branch(label("ev_assignment")),</p>
<p class="Sp-text-1"><a id="c5-para-0866"/>  go_to(label("unknown_component_type")),</p>
<section>
<h5><a id="c5-sec-0056"/><a id="c5-title-0057"/>Evaluating simple expressions</h5>
<p class="paraaftertitle"><a id="c5-para-0867"/>Numbers and strings, names, and lambda expressions have no subexpressions to be evaluated. For these, the evaluator simply places the correct value in the <span class="KeyTerm1">val</span> register and continues execution at the entry point specified by <span class="KeyTerm1">continue</span>. Evaluation of simple expressions is performed by the following controller code:</p>
<p class="Sp-text-1"><a id="c5-para-0868"/>"ev_literal",</p>
<p class="Sp-text-1"><a id="c5-para-0869"/>  assign("val", list(op("literal_value"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0870"/>  go_to(reg("continue")),</p>
<p class="Sp-text-1"><a id="c5-para-0871"/>"ev_name",</p>
<p class="Sp-text-1"><a id="c5-para-0872"/>  assign("val", list(op("symbol_of_name"), reg("comp"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-0873"/>  assign("val", list(op("lookup_symbol_value"),</p>
<p class="Sp-text-1"><a id="c5-para-0874"/>                     reg("val"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-0875"/>  go_to(reg("continue")),</p>
<p class="Sp-text-1"><a id="c5-para-0876"/>"ev_lambda",</p>
<p class="Sp-text-1"><a id="c5-para-0877"/>  assign("unev", list(op("lambda_parameter_symbols"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0878"/>  assign("comp", list(op("lambda_body"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0879"/>  assign("val", list(op("make_function"),</p>
<p class="Sp-text-1"><a id="c5-para-0880"/>                     reg("unev"), reg("comp"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-0881"/>  go_to(reg("continue")),</p>
<p class="paracontinue"><a id="c5-para-0882"/>Observe how <span class="KeyTerm1">ev_lambda</span> uses the <span class="KeyTerm1">unev</span> and <span class="KeyTerm1">comp</span> registers to hold the parameters and body of the lambda expression so that they can be passed to the <span class="KeyTerm1">make_function</span> operation, along with the environment in <span class="KeyTerm1">env</span>.</p>
</section>
<section>
<h5><a id="c5-sec-0057"/><a id="c5-title-0058"/>Conditionals</h5>
<p class="paraaftertitle"><a id="c5-para-0883"/>As with the metacircular evaluator, syntactic forms are handled by selectively evaluating fragments of the component. For a conditional, we must evaluate the predicate and decide, based on the value of predicate, whether to evaluate the consequent or the alternative.</p>
<p><a id="c5-para-0884"/>Before evaluating the predicate, we save the conditional itself, which is in <span class="KeyTerm1">comp</span>, so that we can later extract the consequent or alternative. To evaluate the predicate expression, we move it to the <span class="KeyTerm1">comp</span> register and go to <span class="KeyTerm1">eval_dispatch</span>. The environment in the <span class="KeyTerm1">env</span> register is already the correct one in which to evaluate the predicate. However, we save <span class="KeyTerm1">env</span> because we will need it later to evaluate the consequent or the alternative. We set up <span class="KeyTerm1">continue</span> so that evaluation will resume at <span class="KeyTerm1">ev_conditional_decide</span> after the predicate has been evaluated. First, however, we save the old value of <span class="KeyTerm1">continue</span>, which we will need later in order to return to the evaluation of the statement that is waiting for the value of the conditional.</p>
<p class="Sp-text-1"><a id="c5-para-0885"/>"ev_conditional",</p>
<p class="Sp-text-1"><a id="c5-para-0886"/>  save("comp"), <i>//</i> <span class="KeyTerm2"><i>save conditional for later</i></span></p>
<p class="Sp-text-1"><a id="c5-para-0887"/>save("env"),</p>
<p class="Sp-text-1"><a id="c5-para-0888"/>save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-0889"/>assign("continue", label("ev_conditional_decide")),</p>
<p class="Sp-text-1"><a id="c5-para-0890"/>assign("comp", list(op("conditional_predicate"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0891"/>  go_to(label("eval_dispatch")), <i>//</i> <span class="KeyTerm2"><i>evaluate the predicate</i></span></p>
<p><a id="c5-para-0892"/>When we resume at <span class="KeyTerm1">ev_conditional_decide</span> after evaluating the predicate, we test whether it was true or false and, depending on the result, place either the consequent or the alternative in <span class="KeyTerm1">comp</span> before going to <span class="KeyTerm1">eval_dispatch</span>.<a id="c5-fn-0022a"/><a href="#c5-fn-0022"><sup>22</sup></a> Notice that restoring <span class="KeyTerm1">env</span> and <span class="KeyTerm1">continue</span> here sets up <span class="KeyTerm1">eval_dispatch</span> to have the correct environment and to continue at the right place to receive the value of the conditional.</p>
<p class="Sp-text-1"><a id="c5-para-0893"/>"ev_conditional_decide",</p>
<p class="Sp-text-1"><a id="c5-para-0894"/>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-0895"/>  restore("env"),</p>
<p class="Sp-text-1"><a id="c5-para-0896"/>  restore("comp"),</p>
<p class="Sp-text-1"><a id="c5-para-0897"/>  test(list(op("is_falsy"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-0898"/>  branch(label("ev_conditional_alternative")),</p>
<p class="Sp-text-1"><a id="c5-para-0899"/>"ev_conditional_consequent",</p>
<p class="Sp-text-1"><a id="c5-para-0900"/>  assign("comp", list(op("conditional_consequent"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0901"/>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"><a id="c5-para-0902"/>"ev_conditional_alternative",</p>
<p class="Sp-text-1"><a id="c5-para-0903"/>  assign("comp", list(op("conditional_alternative"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0904"/>  go_to(label("eval_dispatch")),</p>
</section>
<section>
<h5><a id="c5-sec-0058"/><a id="c5-title-0059"/>Sequence Evaluation</h5>
<p class="paraaftertitle"><a id="c5-para-0905"/>The portion of the explicit-control evaluator beginning at <span class="KeyTerm1">ev_sequence</span>, which handles sequences of statements, is analogous to the metacircular evaluator's <span class="KeyTerm1">eval_ sequence</span> function.</p>
<p><a id="c5-para-0906"/>The entries at <span class="KeyTerm1">ev_sequence_next</span> and <span class="KeyTerm1">ev_sequence_continue</span> form a loop that successively evaluates each statement in a sequence. The list of unevaluated statements is kept in <span class="KeyTerm1">unev</span>. At <span class="KeyTerm1">ev_sequence</span> we place the sequence of statements to be evaluated in <span class="KeyTerm1">unev</span>. If the sequence is empty, we set <span class="KeyTerm1">val</span> to <span class="KeyTerm1">undefined</span> and jump to <span class="KeyTerm1">continue</span> via <span class="KeyTerm1">ev_sequence_empty</span>. Otherwise we start the sequence-evaluation loop, first saving the value of <span class="KeyTerm1">continue</span> on the stack, because the <span class="KeyTerm1">continue</span> register will be used for local flow of control in the loop, and the original value is needed for continuing after the statement sequence. Before evaluating each statement, we check to see if there are additional statements to be evaluated in the sequence. If so, we save the rest of the unevaluated statements (held in <span class="KeyTerm1">unev</span>) and the environment in which these must be evaluated (held in <span class="KeyTerm1">env</span>) and call <span class="KeyTerm1">eval_dispatch</span> to evaluate the statement, which has been placed in <span class="KeyTerm1">comp</span>. The two saved registers are restored after this evaluation, at <span class="KeyTerm1">ev_sequence_continue</span>.</p>
<p><a id="c5-para-0907"/>The final statement in the sequence is handled differently, at the entry point <span class="KeyTerm1">ev_sequence_last_statement</span>. Since there are no more statements to be evaluated after this one, we need not save <span class="KeyTerm1">unev</span> or <span class="KeyTerm1">env</span> before going to <span class="KeyTerm1">eval_dispatch</span>. The value of the whole sequence is the value of the last statement, so after the evaluation of the last statement there is nothing left to do except continue at the entry point that was saved at <span class="KeyTerm1">ev_sequence</span>. Rather than setting up <span class="KeyTerm1">continue</span> to arrange for <span class="KeyTerm1">eval_dispatch</span> to return here and then restoring <span class="KeyTerm1">continue</span> from the stack and continuing at that entry point, we restore <span class="KeyTerm1">continue</span> from the stack before going to <span class="KeyTerm1">eval_dispatch</span>, so that <span class="KeyTerm1">eval_dispatch</span> will continue at that entry point after evaluating the statement.</p>
<p class="Sp-text-1"><a id="c5-para-0908"/>"ev_sequence",</p>
<p class="Sp-text-1"><a id="c5-para-0909"/>  assign("unev", list(op("sequence_statements"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0910"/>  test(list(op("is_empty_sequence"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c5-para-0911"/>  branch(label("ev_sequence_empty")),</p>
<p class="Sp-text-1"><a id="c5-para-0912"/>  save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-0913"/>"ev_sequence_next",</p>
<p class="Sp-text-1"><a id="c5-para-0914"/>  assign("comp", list(op("first_statement"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c5-para-0915"/>  test(list(op("is_last_statement"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c5-para-0916"/>  branch(label("ev_sequence_last_statement")),</p>
<p class="Sp-text-1"><a id="c5-para-0917"/>  save("unev"),</p>
<p class="Sp-text-1"><a id="c5-para-0918"/>  save("env"),</p>
<p class="Sp-text-1"><a id="c5-para-0919"/>  assign("continue", label("ev_sequence_continue")),</p>
<p class="Sp-text-1"><a id="c5-para-0920"/>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"><a id="c5-para-0921"/>"ev_sequence_continue",</p>
<p class="Sp-text-1"><a id="c5-para-0922"/>  restore("env"),</p>
<p class="Sp-text-1"><a id="c5-para-0923"/>  restore("unev"),</p>
<p class="Sp-text-1"><a id="c5-para-0924"/>  assign("unev", list(op("rest_statements"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c5-para-0925"/>  go_to(label("ev_sequence_next")),</p>
<p class="Sp-text-1"><a id="c5-para-0926"/>"ev_sequence_last_statement",</p>
<p class="Sp-text-1"><a id="c5-para-0927"/>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-0928"/>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-0929"/>"ev_sequence_empty",</p>
<p class="Sp-text-1"><a id="c5-para-0930"/>  assign("val", constant(undefined)),</p>
<p class="Sp-text-1"><a id="c5-para-0931"/>  go_to(reg("continue")),</p>
<p><a id="c5-para-0932"/>Unlike <span class="KeyTerm1">eval_sequence</span> in the metacircular evaluator, <span class="KeyTerm1">ev_sequence</span> does not need to check whether a return statement was evaluated so as to terminate the sequence evaluation. The “explicit control” in this evaluator allows a return statement to jump directly to the continuation of the current function application without resuming the sequence evaluation. Thus sequence evaluation does not need to be concerned with returns, or even be aware of the existence of return statements in the language. Because a return statement jumps out of the sequence-evaluation code, the restores of saved registers at <span class="KeyTerm1">ev_sequence_continue</span> won't be executed. We will see later how the return statement removes these values from the stack.</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0059"/><span>5.4.2</span> <a id="c5-title-0060"/>Evaluating Function Applications</h3>
<p class="paraaftertitle"><a id="c5-para-0933"/>A function application is specified by a combination containing a function expression and argument expressions. The function expression is a subexpression whose value is a function, and the argument expressions are subexpressions whose values are the arguments to which the function should be applied. The metacircular <span class="KeyTerm1">evaluate</span> handles applications by calling itself recursively to evaluate each element of the combination, and then passing the results to <span class="KeyTerm1">apply</span>, which performs the actual function application. The explicit-control evaluator does the same thing; these recursive calls are implemented by <span class="KeyTerm1">go_to</span> instructions, together with use of the stack to save registers that will be restored after the recursive call returns. Before each call we will be careful to identify which registers must be saved (because their values will be needed later).<a id="c5-fn-0023a"/><a href="#c5-fn-0023"><sup>23</sup></a></p>
<p><a id="c5-para-0934"/>As in the metacircular evaluator, operator combinations are transformed into applications of primitive functions corresponding to the operators. This takes place at <span class="KeyTerm1">ev_operator_combination</span>, which performs this transformation in place in <span class="KeyTerm1">comp</span> and falls through to <span class="KeyTerm1">ev_application</span>.<a id="c5-fn-0024a"/><a href="#c5-fn-0024"><sup>24</sup></a></p>
<p><a id="c5-para-0935"/>We begin the evaluation of an application by evaluating the function expression to produce a function, which will later be applied to the evaluated argument expressions. To evaluate the function expression, we move it to the <span class="KeyTerm1">comp</span> register and go to <span class="KeyTerm1">eval_dispatch</span>. The environment in the <span class="KeyTerm1">env</span> register is already the correct one in which to evaluate the function expression. However, we save <span class="KeyTerm1">env</span> because we will need it later to evaluate the argument expressions. We also extract the argument expressions into <span class="KeyTerm1">unev</span> and save this on the stack. We set up <span class="KeyTerm1">continue</span> so that <span class="KeyTerm1">eval_dispatch</span> will resume at <span class="KeyTerm1">ev_appl_did_function_expression</span> after the function expression has been evaluated. First, however, we save the old value of <span class="KeyTerm1">continue</span>, which tells the controller where to continue after the application.</p>
<p class="Sp-text-1"><a id="c5-para-0936"/>"ev_operator_combination",</p>
<p class="Sp-text-1"><a id="c5-para-0937"/>  assign("comp", list(op("operator_combination_to_application"),</p>
<p class="Sp-text-1"><a id="c5-para-0938"/>                      reg("comp"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-0939"/>"ev_application",</p>
<p class="Sp-text-1"><a id="c5-para-0940"/>  save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-0941"/>  save("env"),</p>
<p class="Sp-text-1"><a id="c5-para-0942"/>  assign("unev", list(op("arg_expressions"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0943"/>  save("unev"),</p>
<p class="Sp-text-1"><a id="c5-para-0944"/>  assign("comp", list(op("function_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-0945"/>  assign("continue", label("ev_appl_did_function_expression")),</p>
<p class="Sp-text-1"><a id="c5-para-0946"/>  go_to(label("eval_dispatch")),</p>
<p><a id="c5-para-0947"/>Upon returning from evaluating the function expression, we proceed to evaluate the argument expressions of the application and to accumulate the resulting arguments in a list, held in <span class="KeyTerm1">argl</span>. (This is like the evaluation of a sequence of statements, except that we collect the values.) First we restore the unevaluated argument expressions and the environment. We initialize <span class="KeyTerm1">argl</span> to an empty list. Then we assign to the <span class="KeyTerm1">fun</span> register the function that was produced by evaluating the function expression. If there are no argument expressions, we go directly to <span class="KeyTerm1">apply_dispatch</span>. Otherwise we save <span class="KeyTerm1">fun</span> on the stack and start the argument-evaluation loop:<a id="c5-fn-0025a"/><a href="#c5-fn-0025"><sup>25</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-0948"/>"ev_appl_did_function_expression",</p>
<p class="Sp-text-1"><a id="c5-para-0949"/>  restore("unev"), <i>//</i> <span class="KeyTerm2"><i>the argument expressions</i></span></p>
<p class="Sp-text-1"><a id="c5-para-0950"/>  restore("env"),</p>
<p class="Sp-text-1"><a id="c5-para-0951"/>  assign("argl", list(op("empty_arglist"))),</p>
<p class="Sp-text-1"><a id="c5-para-0952"/>  assign("fun", reg("val")), <i>//</i> <span class="KeyTerm2"><i>the function</i></span></p>
<p class="Sp-text-1"><a id="c5-para-0953"/>  test(list(op("is_null"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c5-para-0954"/>  branch(label("apply_dispatch")),</p>
<p class="Sp-text-1"><a id="c5-para-0955"/>  save("fun"),</p>
<p><a id="c5-para-0956"/>Each cycle of the argument-evaluation loop evaluates an argument expression from the list in <span class="KeyTerm1">unev</span> and accumulates the result into <span class="KeyTerm1">argl</span>. To evaluate an argument expression, we place it in the <span class="KeyTerm1">comp</span> register and go to <span class="KeyTerm1">eval_dispatch</span>, after setting <span class="KeyTerm1">continue</span> so that execution will resume with the argument-accumulation phase. But first we save the arguments accumulated so far (held in <span class="KeyTerm1">argl</span>), the environment (held in <span class="KeyTerm1">env</span>), and the remaining argument expressions to be evaluated (held in <span class="KeyTerm1">unev</span>). A special case is made for the evaluation of the last argument expression, which is handled at <span class="KeyTerm1">ev_appl_last_arg</span>.</p>
<p class="Sp-text-1"><a id="c5-para-0965"/>"ev_appl_argument_expression_loop",</p>
<p class="Sp-text-1"><a id="c5-para-0966"/>  save("argl"),</p>
<p class="Sp-text-1"><a id="c5-para-0967"/>  assign("comp", list(op("head"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c5-para-0968"/>  test(list(op("is_last_argument_expression"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c5-para-0969"/>  branch(label("ev_appl_last_arg")),</p>
<p class="Sp-text-1"><a id="c5-para-0970"/>  save("env"),</p>
<p class="Sp-text-1"><a id="c5-para-0971"/>  save("unev"),</p>
<p class="Sp-text-1"><a id="c5-para-0972"/>  assign("continue", label("ev_appl_accumulate_arg")),</p>
<p class="Sp-text-1"><a id="c5-para-0973"/>  go_to(label("eval_dispatch")),</p>
<p><a id="c5-para-0974"/>When an argument expression has been evaluated, the value is accumulated into the list held in <span class="KeyTerm1">argl</span>. The argument expression is then removed from the list of unevaluated argument expressions in <span class="KeyTerm1">unev</span>, and the argument-evaluation loop continues.</p>
<p class="Sp-text-1"><a id="c5-para-0975"/>"ev_appl_accumulate_arg",</p>
<p class="Sp-text-1"><a id="c5-para-0976"/>  restore("unev"),</p>
<p class="Sp-text-1"><a id="c5-para-0977"/>  restore("env"),</p>
<p class="Sp-text-1"><a id="c5-para-0978"/>  restore("argl"),</p>
<p class="Sp-text-1"><a id="c5-para-0979"/>  assign("argl", list(op("adjoin_arg"), reg("val"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c5-para-0980"/>  assign("unev", list(op("tail"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c5-para-0981"/>  go_to(label("ev_appl_argument_expression_loop")),</p>
<p><a id="c5-para-0982"/>Evaluation of the last argument expression is handled differently, as is the last statement in a sequence. There is no need to save the environment or the list of unevaluated argument expressions before going to <span class="KeyTerm1">eval_dispatch</span>, since they will not be required after the last argument expression is evaluated. Thus, we return from the evaluation to a special entry point <span class="KeyTerm1">ev_appl_accum_last_arg</span>, which restores the argument list, accumulates the new argument, restores the saved function, and goes off to perform the application.<a id="c5-fn-0026a"/><a href="#c5-fn-0026"><sup>26</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-0983"/>"ev_appl_last_arg",</p>
<p class="Sp-text-1"><a id="c5-para-0984"/>  assign("continue", label("ev_appl_accum_last_arg")),</p>
<p class="Sp-text-1"><a id="c5-para-0985"/>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"><a id="c5-para-0986"/>"ev_appl_accum_last_arg",</p>
<p class="Sp-text-1"><a id="c5-para-0987"/>  restore("argl"),</p>
<p class="Sp-text-1"><a id="c5-para-0988"/>  assign("argl", list(op("adjoin_arg"), reg("val"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c5-para-0989"/>  restore("fun"),</p>
<p class="Sp-text-1"><a id="c5-para-0990"/>  go_to(label("apply_dispatch")),</p>
<p><a id="c5-para-0991"/>The details of the argument-evaluation loop determine the order in which the interpreter evaluates the argument expressions of a combination (e.g., left to right or right to left—see exercise 3.8). This order is not determined by the metacircular evaluator, which inherits its control structure from the underlying JavaScript in which it is implemented.<a id="c5-fn-0027a"/><a href="#c5-fn-0027"><sup>27</sup></a> Because we use <span class="KeyTerm1">head</span> in <span class="KeyTerm1">ev_appl_argument_expression_loop</span> to extract successive argument expressions from <span class="KeyTerm1">unev</span> and <span class="KeyTerm1">tail</span> at <span class="KeyTerm1">ev_appl_ accumulate_arg</span> to extract the rest of the argument expressions, the explicitcontrol evaluator will evaluate the argument expressions of a combination in left-to-right order, as required by the ECMAScript specification.</p>
<section>
<h5><a id="c5-sec-0060"/><a id="c5-title-0061"/>Function Application</h5>
<p class="paraaftertitle"><a id="c5-para-0992"/>The entry point <span class="KeyTerm1">apply_dispatch</span> corresponds to the <span class="KeyTerm1">apply</span> function of the metacircular evaluator. By the time we get to <span class="KeyTerm1">apply_dispatch</span>, the <span class="KeyTerm1">fun</span> register contains the function to apply and <span class="KeyTerm1">argl</span> contains the list of evaluated arguments to which it must be applied. The saved value of <span class="KeyTerm1">continue</span> (originally passed to <span class="KeyTerm1">eval_dispatch</span> and saved at <span class="KeyTerm1">ev_application</span>), which tells where to return with the result of the function application, is on the stack. When the application is complete, the controller transfers to the entry point specified by the saved <span class="KeyTerm1">continue</span>, with the result of the application in <span class="KeyTerm1">val</span>. As with the metacircular <span class="KeyTerm1">apply</span>, there are two cases to consider. Either the function to be applied is a primitive or it is a compound function.</p>
<p class="Sp-text-1"><a id="c5-para-0993"/>"apply_dispatch",</p>
<p class="Sp-text-1"><a id="c5-para-0994"/>  test(list(op("is_primitive_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-0995"/>  branch(label("primitive_apply")),</p>
<p class="Sp-text-1"><a id="c5-para-0996"/>  test(list(op("is_compound_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-0997"/>  branch(label("compound_apply")),</p>
<p class="Sp-text-1"><a id="c5-para-0998"/>  go_to(label("unknown_function_type")),</p>
<p><a id="c5-para-0999"/>We assume that each primitive is implemented so as to obtain its arguments from <span class="KeyTerm1">argl</span> and place its result in <span class="KeyTerm1">val</span>. To specify how the machine handles primitives, we would have to provide a sequence of controller instructions to implement each primitive and arrange for <span class="KeyTerm1">primitive_apply</span> to dispatch to the instructions for the primitive identified by the contents of <span class="KeyTerm1">fun</span>. Since we are interested in the structure of the evaluation process rather than the details of the primitives, we will instead just use an <span class="KeyTerm1">apply_primitive_function</span> operation that applies the function in fun to the arguments in <span class="KeyTerm1">argl</span>. For the purpose of simulating the evaluator with the simulator of section 5.2 we use the function <span class="KeyTerm1">apply_primitive_function</span>, which calls on the underlying JavaScript system to perform the application, just as we did for the metacircular evaluator in section 4.1.1. After computing the value of the primitive application, we restore <span class="KeyTerm1">continue</span> and go to the designated entry point.</p>
<p class="Sp-text-1"><a id="c5-para-1000"/>"primitive_apply",</p>
<p class="Sp-text-1"><a id="c5-para-1001"/>  assign("val", list(op("apply_primitive_function"),</p>
<p class="Sp-text-1"><a id="c5-para-1002"/>                     reg("fun"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c5-para-1003"/>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1004"/>  go_to(reg("continue")),</p>
<p><a id="c5-para-1005"/>The sequence of instructions labeled <span class="KeyTerm1">compound_apply</span> specifies the application of compound functions. To apply a compound function, we proceed in a way similar to what we did in the metacircular evaluator. We construct a frame that binds the function's parameters to the arguments, use this frame to extend the environment carried by the function, and evaluate in this extended environment the body of the function.</p>
<p><a id="c5-para-1006"/>At this point the compound function is in register <span class="KeyTerm1">fun</span> and its arguments are in <span class="KeyTerm1">argl</span>. We extract the function's parameters into <span class="KeyTerm1">unev</span> and its environment into <span class="KeyTerm1">env</span>. We then replace the environment in <span class="KeyTerm1">env</span> with the environment constructed by extending it with bindings of the parameters to the given arguments. We then extract the body of the function into <span class="KeyTerm1">comp</span>. The natural next step would be to restore the saved <span class="KeyTerm1">continue</span> and proceed to <span class="KeyTerm1">eval_dispatch</span> to evaluate the body and go to the restored continuation with the result in <span class="KeyTerm1">val</span>, as is done for the last statement of a sequence. But there is a complication!</p>
<p><a id="c5-para-1007"/>The complication has two aspects. One is that at any point in the evaluation of the body, a return statement may require the function to return the value of the return expression as the value of the body. But a return statement may be nested arbitrarily deeply in the body; so the stack at the moment the return statement is encountered is not necessarily the stack that is needed for a return from the function. One way to make it possible to adjust the stack for the return is to put a <i>marker</i> on the stack that can be found by the return code. This is implemented by the <span class="KeyTerm1">push_marker_to_stack</span> instruction. The return code can then use the <span class="KeyTerm1">revert_stack_to_marker</span> instruction to restore the stack to the place indicated by the marker before evaluating the return expression.<a id="c5-fn-0028a"/><a href="#c5-fn-0028"><sup>28</sup></a></p>
<p><a id="c5-para-1008"/>The other aspect of the complication is that if the evaluation of the body terminates without executing a return statement, the value of the body must be <span class="KeyTerm1">undefined</span>. To handle this, we set up the <span class="KeyTerm1">continue</span> register to point to the entry point <span class="KeyTerm1">return_undefined</span> before going off to <span class="KeyTerm1">eval_dispatch</span> to evaluate the body. If a return statement is not encountered during evaluation of the body, evaluation of the body will continue at <span class="KeyTerm1">return_undefined</span>.</p>
<p class="Sp-text-1"><a id="c5-para-1009"/>"compound_apply",</p>
<p class="Sp-text-1"><a id="c5-para-1010"/>  assign("unev", list(op("function_parameters"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1011"/>  assign("env", list(op("function_environment"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1012"/>  assign("env", list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c5-para-1013"/>                     reg("unev"), reg("argl"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1014"/>  assign("comp", list(op("function_body"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1015"/>  push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c5-para-1016"/>  assign("continue", label("return_undefined")),</p>
<p class="Sp-text-1"><a id="c5-para-1017"/>  go_to(label("eval_dispatch")),</p>
<p><a id="c5-para-1018"/>The only places in the interpreter where the <span class="KeyTerm1">env</span> register is assigned a new value are <span class="KeyTerm1">compound_apply</span> and <span class="KeyTerm1">ev_block</span> (section 5.4.3). Just as in the metacircular evaluator, the new environment for evaluation of a function body is constructed from the environment carried by the function, together with the argument list and the corresponding list of names to be bound.</p>
<p><a id="c5-para-1019"/>When a return statement is evaluated at <span class="KeyTerm1">ev_return</span>, we use the <span class="KeyTerm1">revert_stack_</span> <span class="KeyTerm1">to_marker</span> instruction to restore the stack to its state at the beginning of the function call by removing all values from the stack down to and including the marker. As a consequence, <span class="KeyTerm1">restore("continue")</span> will restore the continuation of the function call, which was saved at <span class="KeyTerm1">ev_application</span>. We then proceed to evaluate the return expression, whose result will be placed in <span class="KeyTerm1">val</span> and thus be the value returned from the function when we continue after the evaluation of the return expression.</p>
<p class="Sp-text-1"><a id="c5-para-1020"/>"ev_return",</p>
<p class="Sp-text-1"><a id="c5-para-1021"/>  revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c5-para-1022"/>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1023"/>  assign("comp", list(op("return_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1024"/>  go_to(label("eval_dispatch")),</p>
<p><a id="c5-para-1025"/>If no return statement is encountered during evaluation of the function body, evaluation continues at <span class="KeyTerm1">return_undefined</span>, the continuation that was set up at <span class="KeyTerm1">compound_apply</span>. To return <span class="KeyTerm1">undefined</span> from the function, we put <span class="KeyTerm1">undefined</span> into <span class="KeyTerm1">val</span> and go to the entry point that was put onto the stack at <span class="KeyTerm1">ev_application</span>. Before we can restore that continuation from the stack, however, we must remove the marker that was saved at <span class="KeyTerm1">compound_apply</span>.</p>
<p class="Sp-text-1"><a id="c5-para-1026"/>"return_undefined",</p>
<p class="Sp-text-1"><a id="c5-para-1027"/>  revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c5-para-1028"/>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1029"/>  assign("val", constant(undefined)),</p>
<p class="Sp-text-1"><a id="c5-para-1030"/>  go_to(reg("continue")),</p>
</section>
<section>
<h5><a id="c5-sec-0061"/><a id="c5-title-0062"/>Return Statements and Tail Recursion</h5>
<p class="paraaftertitle"><a id="c5-para-1031"/>In chapter 1 we said that the process described by a function such as</p>
<p class="Sp-text-1"><a id="c5-para-1032"/><b>function</b> sqrt_iter(guess, x) {</p>
<p class="Sp-text-1"><a id="c5-para-1033"/>    <b>return</b> is_good_enough(guess, x)</p>
<p class="Sp-text-1"><a id="c5-para-1034"/>           ? guess</p>
<p class="Sp-text-1"><a id="c5-para-1035"/>           : sqrt_iter(improve(guess, x), x);</p>
<p class="Sp-text-1"><a id="c5-para-1036"/>}</p>
<p class="paracontinue"><a id="c5-para-1037"/>is an iterative process. Even though the function is syntactically recursive (defined in terms of itself), it is not logically necessary for an evaluator to save information in passing from one call to <span class="KeyTerm1">sqrt_iter</span> to the next.<a id="c5-fn-0029a"/><a href="#c5-fn-0029"><sup>29</sup></a> An evaluator that can execute a function such as <span class="KeyTerm1">sqrt_iter</span> without requiring increasing storage as the function continues to call itself is called a <i>tail-recursive</i> evaluator.</p>
<p><a id="c5-para-1038"/>The metacircular implementation of the evaluator in chapter 4 isn't tail-recursive. It implements a return statement as a constructor of a return value object containing the value to be returned and inspects the result of a function call to see whether it is such an object. If the evaluation of a function body produces a return value object, the return value of the function is the contents of that object; otherwise, the return value is <span class="KeyTerm1">undefined</span>. Both the construction of the return value object and the eventual inspection of the result of the function call are deferred operations, which lead to an accumulation of information on the stack.</p>
<p><a id="c5-para-1039"/>Our explicit-control evaluator <i>is</i> tail-recursive, because it does not need to wrap up return values for inspection and thus avoids the buildup of stack from deferred operations. At <span class="KeyTerm1">ev_return</span>, in order to evaluate the expression that computes the return value of a function, we transfer directly to <span class="KeyTerm1">eval_dispatch</span> with nothing more on the stack than right before the function call. We accomplish this by undoing any saves to the stack by the function (which are useless because we are returning) using <span class="KeyTerm1">revert_stack_to_marker</span>. Then, rather than arranging for <span class="KeyTerm1">eval_dispatch</span> to come back here and <i>then</i> restoring <span class="KeyTerm1">continue</span> from the stack and continuing at that entry point, we restore <span class="KeyTerm1">continue</span> from the stack <i>before</i> going to <span class="KeyTerm1">eval_dispatch</span> so that <span class="KeyTerm1">eval_dispatch</span> will continue at that entry point after evaluating the expression. Finally, we transfer to <span class="KeyTerm1">eval_dispatch</span> without saving any information on the stack. Thus, when we proceed to evaluate a return expression, the stack is the same as just before the call to the function whose return value we are about to compute. Hence, evaluating a return expression—even if it is a function call (as in <span class="KeyTerm1">sqrt_iter</span>, where the conditional expression reduces to a call to <span class="KeyTerm1">sqrt_iter</span>)—will not cause any information to accumulate on the stack.<a id="c5-fn-0030a"/><a href="#c5-fn-0030"><sup>30</sup></a></p>
<p><a id="c5-para-1040"/>If we did not think to take advantage of the fact that it is unnecessary to hold on to the useless information on the stack while evaluating a return expression, we might have taken the straightforward approach of evaluating the return expression, coming back to restore the stack, and finally continuing at the entry point that is waiting for the result of the function call:</p>
<p class="Sp-text-1"><a id="c5-para-1041"/>"ev_return",  <i>//</i> <span class="KeyTerm2"><i>alternative implementation: not tail-recursive</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1042"/>  assign("comp", list(op("return_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1043"/>  assign("continue", label("ev_restore_stack")),</p>
<p class="Sp-text-1"><a id="c5-para-1044"/>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"><a id="c5-para-1045"/>"ev_restore_stack",</p>
<p class="Sp-text-1"><a id="c5-para-1046"/>revert_stack_to_marker(),     <i>//</i> <span class="KeyTerm2"><i>undo saves in current function</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1047"/>restore("continue"),          <i>//</i> <span class="KeyTerm2"><i>undo save at</i></span> ev_application</p>
<p class="Sp-text-1"><a id="c5-para-1048"/>  go_to(reg("continue")),</p>
<p><a id="c5-para-1049"/>This may seem like a minor change to our previous code for evaluation of return statements: The only difference is that we delay undoing any register saves to the stack until after the evaluation of the return expression. The interpreter will still give the same value for any expression. But this change is fatal to the tail-recursive implementation, because we must now come back after evaluating the return expression in order to undo the (useless) register saves. These extra saves will accumulate during a nest of function calls. Consequently, processes such as <span class="KeyTerm1">sqrt_iter</span> will require space proportional to the number of iterations rather than requiring constant space. This difference can be significant. For example, with tail recursion, an infinite loop can be expressed using only the function-call and return mechanisms:</p>
<p class="Sp-text-1"><a id="c5-para-1050"/><b>function</b> count(n) {</p>
<p class="Sp-text-1"><a id="c5-para-1051"/>    display(n);</p>
<p class="Sp-text-1"><a id="c5-para-1052"/>    <b>return</b> count(n + 1);</p>
<p class="Sp-text-1"><a id="c5-para-1053"/>}</p>
<p class="paracontinue"><a id="c5-para-1054"/>Without tail recursion, such a function would eventually run out of stack space, and expressing a true iteration would require some control mechanism other than function call.</p>
<p><a id="c5-para-1055"/>Note that our JavaScript implementation requires the use of <span class="KeyTerm1"><b>return</b></span> in order to be tail-recursive. Because the undoing of the register saves takes place at <span class="KeyTerm1">ev_return</span>, removing <span class="KeyTerm1"><b>return</b></span> from the <span class="KeyTerm1">count</span> function above will cause it to eventually run out of stack space. This explains the use of <span class="KeyTerm1"><b>return</b></span> in the infinite driver loops in chapter 4.</p>
</section>
<section>
<h5><a id="c5-sec-0062"/><a id="c5-title-0063"/>Exercise 5.22</h5>
<p class="paraaftertitle"><a id="c5-para-1056"/>Explain how the stack builds up if <span class="KeyTerm1"><b>return</b></span> is removed from <span class="KeyTerm1">count</span>:</p>
<p class="Sp-text-1"><a id="c5-para-1057"/><b>function</b> count(n) {</p>
<p class="Sp-text-1"><a id="c5-para-1058"/>    display(n);</p>
<p class="Sp-text-1"><a id="c5-para-1059"/>    count(n + 1);</p>
<p class="Sp-text-1"><a id="c5-para-1060"/>}</p>
</section>
<section>
<h5><a id="c5-sec-0063"/><a id="c5-title-0064"/>Exercise 5.23</h5>
<p class="paraaftertitle"><a id="c5-para-1061"/>Implement the equivalent of <span class="KeyTerm1">push_marker_to_stack</span> by using <span class="KeyTerm1">save</span> at <span class="KeyTerm1">compound_apply</span> to store a special marker value on the stack. Implement the equivalent of <span class="KeyTerm1">revert_stack_ to_marker</span> at <span class="KeyTerm1">ev_return</span> and <span class="KeyTerm1">return_undefined</span> as a loop that repeatedly performs a <span class="KeyTerm1">restore</span> until it hits the marker. Note that this will require restoring a value to a register other than the one it was saved from. (Although we are careful to avoid that in our evaluator, our stack implementation actually allows it. See exercise 5.10.) This is necessary because the only way to pop from the stack is by restoring to a register. Hint: You will need to create a unique constant to serve as the marker, for example with <span class="KeyTerm1"><b>const</b> marker = list("marker")</span>. Because <span class="KeyTerm1">list</span> creates a new pair, it cannot be <span class="KeyTerm1">===</span> to anything else on the stack.</p>
</section>
<section>
<h5><a id="c5-sec-0064"/><a id="c5-title-0065"/>Exercise 5.24</h5>
<p class="paraaftertitle"><a id="c5-para-1062"/>Implement <span class="KeyTerm1">push_marker_to_stack</span> and <span class="KeyTerm1">revert_stack_to_marker</span> as register-machine instructions, following the implementation of <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> in section 5.2.3. Add functions <span class="KeyTerm1">push_marker</span> and <span class="KeyTerm1">pop_marker</span> to access stacks, mirroring the implementation of <span class="KeyTerm1">push</span> and <span class="KeyTerm1">pop</span> in section 5.2.1. Note that you do not need to actually insert a marker into the stack. Instead, you can add a local state variable to the stack model to keep track of the position of the last <span class="KeyTerm1">save</span> before each <span class="KeyTerm1">push_marker_to_stack</span>. If you choose to put a marker on the stack, see the hint in exercise 5.23.</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0065"/><span>5.4.3</span> <a id="c5-title-0066"/>Blocks, Assignments, and Declarations</h3>
<section>
<h5><a id="c5-sec-0066"/><a id="c5-title-0067"/>Blocks</h5>
<p class="paraaftertitle"><a id="c5-para-1063"/>The body of a block is evaluated with respect to the current environment extended by a frame that binds all local names to the value <span class="KeyTerm1">"*unassigned*"</span>. We temporarily make use of the <span class="KeyTerm1">val</span> register to hold the list of all variables declared in the block, which is obtained by <span class="KeyTerm1">scan_out_declarations</span> from section 4.1.1. The functions <span class="KeyTerm1">scan_out_declarations</span> and <span class="KeyTerm1">list_of_unassigned</span> are assumed to be available as machine operations.<a id="c5-fn-0031a"/><a href="#c5-fn-0031"><sup>31</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-1064"/>"ev_block",</p>
<p class="Sp-text-1"><a id="c5-para-1065"/>  assign("comp", list(op("block_body"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1066"/>  assign("val", list(op("scan_out_declarations"), reg("comp"))),</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-1067"/>save("comp"), <i>//</i> <span class="KeyTerm2"><i>so we can use it to temporarily hold</i></span> *unassigned* <span class="KeyTerm2"><i>values</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1068"/>  assign("comp", list(op("list_of_unassigned"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-1069"/>  assign("env", list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c5-para-1070"/>                     reg("val"), reg("comp"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1071"/>  restore("comp"), <i>//</i> <span class="KeyTerm2"><i>the block body</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1072"/>  go_to(label("eval_dispatch")),</p>
</section>
<section>
<h5><a id="c5-sec-0067"/><a id="c5-title-0068"/>Assignments and declarations</h5>
<p class="paraaftertitle"><a id="c5-para-1073"/>Assignments are handled by <span class="KeyTerm1">ev_assignment</span>, reached from <span class="KeyTerm1">eval_dispatch</span> with the assignment expression in <span class="KeyTerm1">comp</span>. The code at <span class="KeyTerm1">ev_assignment</span> first evaluates the value part of the expression and then installs the new value in the environment. The function <span class="KeyTerm1">assign_symbol_value</span> is assumed to be available as a machine operation.</p>
<p class="Sp-text-1"><a id="c5-para-1074"/>"ev_assignment",</p>
<p class="Sp-text-1"><a id="c5-para-1075"/>  assign("unev", list(op("assignment_symbol"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1076"/>  save("unev"), <i>//</i> <span class="KeyTerm2"><i>save variable for later</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1077"/>  assign("comp", list(op("assignment_value_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1078"/>  save("env"),</p>
<p class="Sp-text-1"><a id="c5-para-1079"/>  save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1080"/>  assign("continue", label("ev_assignment_install")),</p>
<p class="Sp-text-1"><a id="c5-para-1081"/>  go_to(label("eval_dispatch")), <i>//</i> <span class="KeyTerm2"><i>evaluate assignment value</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1082"/>"ev_assignment_install",</p>
<p class="Sp-text-1"><a id="c5-para-1083"/>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1084"/>  restore("env"),</p>
<p class="Sp-text-1"><a id="c5-para-1085"/>  restore("unev"),</p>
<p class="Sp-text-1"><a id="c5-para-1086"/>  perform(list(op("assign_symbol_value"),</p>
<p class="Sp-text-1"><a id="c5-para-1087"/>               reg("unev"), reg("val"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1088"/>  go_to(reg("continue")),</p>
<p><a id="c5-para-1089"/>Declarations of variables and constants are handled in a similar way. Note that whereas the value of an assignment is the value that was assigned, the value of a declaration is <span class="KeyTerm1">undefined</span>. This is handled by setting <span class="KeyTerm1">val</span> to <span class="KeyTerm1">undefined</span> before continuing. As in the metacircular evaluator, we transform a function declaration into a constant declaration whose value expression is a lambda expression. This happens at <span class="KeyTerm1">ev_function_declaration</span>, which makes the transformation in place in <span class="KeyTerm1">comp</span> and falls through to <span class="KeyTerm1">ev_declaration</span>.</p>
<p class="Sp-text-1"><a id="c5-para-1090"/>"ev_function_declaration",</p>
<p class="Sp-text-1"><a id="c5-para-1091"/>  assign("comp",</p>
<p class="Sp-text-1"><a id="c5-para-1092"/>         list(op("function_decl_to_constant_decl"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1093"/>"ev_declaration",</p>
<p class="Sp-text-1"><a id="c5-para-1094"/>  assign("unev", list(op("declaration_symbol"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1095"/>  save("unev"), <i>//</i> <span class="KeyTerm2"><i>save declared name</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1096"/>  assign("comp",</p>
<p class="Sp-text-1"><a id="c5-para-1097"/>         list(op("declaration_value_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1098"/>  save("env"),</p>
<p class="Sp-text-1"><a id="c5-para-1099"/>  save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1100"/>  assign("continue", label("ev_declaration_assign")),</p>
<p class="Sp-text-1"><a id="c5-para-1101"/>  go_to(label("eval_dispatch")), <i>//</i> <span class="KeyTerm2"><i>evaluate declaration value</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1102"/>"ev_declaration_assign",</p>
<p class="Sp-text-1"><a id="c5-para-1103"/>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1104"/>  restore("env"),</p>
<p class="Sp-text-1"><a id="c5-para-1105"/>  restore("unev"),</p>
<p class="Sp-text-1"><a id="c5-para-1106"/>  perform(list(op("assign_symbol_value"),</p>
<p class="Sp-text-1"><a id="c5-para-1107"/>               reg("unev"), reg("val"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1108"/>  assign("val", constant(undefined)),</p>
<p class="Sp-text-1"><a id="c5-para-1109"/>  go_to(reg("continue")),</p>
</section>
<section>
<h5><a id="c5-sec-0068"/><a id="c5-title-0069"/>Exercise 5.25</h5>
<p class="paraaftertitle"><a id="c5-para-1110"/>Extend the evaluator to handle while loops, by translating them to applications of a function <span class="KeyTerm1">while_loop</span>, as shown in exercise 4.7. You can paste the declaration of the function <span class="KeyTerm1">while_loop</span> in front of user programs. You may “cheat” by assuming that the syntax transformer <span class="KeyTerm1">while_to_application</span> is available as a machine operation. Refer to exercise 4.7 to discuss whether this approach works if return, break, and continue statements are allowed inside the while loop. If not, how can you modify the explicit-control evaluator to run programs with while loops that include these statements?</p>
</section>
<section>
<h5><a id="c5-sec-0069"/><a id="c5-title-0070"/>Exercise 5.26</h5>
<p class="paraaftertitle"><a id="c5-para-1111"/>Modify the evaluator so that it uses normal-order evaluation, based on the lazy evaluator of section 4.2.</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0070"/><span>5.4.4</span> <a id="c5-title-0071"/>Running the Evaluator</h3>
<p class="paraaftertitle"><a id="c5-para-1112"/>With the implementation of the explicit-control evaluator we come to the end of a development, begun in chapter 1, in which we have explored successively more precise models of the evaluation process. We started with the relatively informal substitution model, then extended this in chapter 3 to the environment model, which enabled us to deal with state and change. In the metacircular evaluator of chapter 4, we used JavaScript itself as a language for making more explicit the environment structure constructed during evaluation of an component. Now, with register machines, we have taken a close look at the evaluator's mechanisms for storage management, argument passing, and control. At each new level of description, we have had to raise issues and resolve ambiguities that were not apparent at the previous, less precise treatment of evaluation. To understand the behavior of the explicit-control evaluator, we can simulate it and monitor its performance.</p>
<p><a id="c5-para-1113"/>We will install a driver loop in our evaluator machine. This plays the role of the <span class="KeyTerm1">driver_loop</span> function of section 4.1.4. The evaluator will repeatedly print a prompt, read a program, evaluate the program by going to <span class="KeyTerm1">eval_dispatch</span>, and print the result. If nothing is entered at the prompt, we jump to the label <span class="KeyTerm1">evaluator_done</span>, which is the last entry point in the controller. The following instructions form the beginning of the explicit-control evaluator's controller sequence:<a id="c5-fn-0032a"/><a href="#c5-fn-0032"><sup>32</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-1114"/>"read_evaluate_print_loop",</p>
<p class="Sp-text-1"><a id="c5-para-1115"/>  perform(list(op("initialize_stack"))),</p>
<p class="Sp-text-1"><a id="c5-para-1116"/>  assign("comp", list(op("user_read"),</p>
<p class="Sp-text-1"><a id="c5-para-1117"/>                      constant("EC-evaluate input:"))),</p>
<p class="Sp-text-1"><a id="c5-para-1118"/>  assign("comp", list(op("parse"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1119"/>  test(list(op("is_null"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1120"/>  branch(label("evaluator_done")),</p>
<p class="Sp-text-1"><a id="c5-para-1121"/>  assign("env", list(op("get_current_environment"))),</p>
<p class="Sp-text-1"><a id="c5-para-1122"/>  assign("val", list(op("scan_out_declarations"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c5-para-1123"/>  save("comp"),    <i>//</i> <span class="KeyTerm2"><i>so we can use it to temporarily hold</i></span> *unassigned* <span class="KeyTerm2"><i>values</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1124"/>  assign("comp", list(op("list_of_unassigned"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-1125"/>  assign("env", list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c5-para-1126"/>                     reg("val"), reg("comp"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1127"/>  perform(list(op("set_current_environment"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1128"/>  restore("comp"), <i>//</i> <span class="KeyTerm2"><i>the program</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1129"/>  assign("continue", label("print_result")),</p>
<p class="Sp-text-1"><a id="c5-para-1130"/>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"><a id="c5-para-1131"/>"print_result",</p>
<p class="Sp-text-1"><a id="c5-para-1132"/>  perform(list(op("user_print"),</p>
<p class="Sp-text-1"><a id="c5-para-1133"/>               constant("EC-evaluate value:"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-1134"/>  go_to(label("read_evaluate_print_loop")),</p>
<p class="paracontinue"><a id="c5-para-1135"/>We store the current environment, initially the global environment, in the variable <span class="KeyTerm1">current_environment</span> and update it each time around the loop to remember past declarations. The operations <span class="KeyTerm1">get_current_environment</span> and <span class="KeyTerm1">set_current_ environment</span> simply get and set this variable.</p>
<p class="Sp-text-1"><a id="c5-para-1136"/><b>let</b> current_environment = the_global_environment;</p>
<p class="Sp-text-1"><a id="c5-para-1137"/><b>function</b> get_current_environment() {</p>
<p class="Sp-text-1"><a id="c5-para-1138"/>    <b>return</b> current_environment;</p>
<p class="Sp-text-1"><a id="c5-para-1139"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1140"/><b>function</b> set_current_environment(env) {</p>
<p class="Sp-text-1"><a id="c5-para-1141"/>    current_environment = env;</p>
<p class="Sp-text-1"><a id="c5-para-1142"/>}</p>
<p><a id="c5-para-1143"/>When we encounter an error in a function (such as the “unknown function type” error indicated at <span class="KeyTerm1">apply_dispatch</span>), we print an error message and return to the driver loop.<a id="c5-fn-0033a"/><a href="#c5-fn-0033"><sup>33</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-1144"/>"unknown_component_type",</p>
<p class="Sp-text-1"><a id="c5-para-1145"/>  assign("val", constant("unknown syntax")),</p>
<p class="Sp-text-1"><a id="c5-para-1146"/>  go_to(label("signal_error")),</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-1147"/>"unknown_function_type",</p>
<p class="Sp-text-1"><a id="c5-para-1148"/>  restore("continue"), <i>//</i> <span class="KeyTerm2"><i>clean up stack (from</i></span> apply_dispatch<span class="KeyTerm2"><i>)</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1149"/>  assign("val", constant("unknown function type")),</p>
<p class="Sp-text-1"><a id="c5-para-1150"/>  go_to(label("signal_error")),</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-1151"/>"signal_error",</p>
<p class="Sp-text-1"><a id="c5-para-1152"/>  perform(list(op("user_print"),</p>
<p class="Sp-text-1"><a id="c5-para-1153"/>               constant("EC-evaluator error:"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-1154"/>  go_to(label("read_evaluate_print_loop")),</p>
<p><a id="c5-para-1155"/>For the purposes of the simulation, we initialize the stack each time through the driver loop, since it might not be empty after an error (such as an undeclared name) interrupts an evaluation.<a id="c5-fn-0034a"/><a href="#c5-fn-0034"><sup>34</sup></a></p>
<p><a id="c5-para-1156"/>If we combine all the code fragments presented in sections 5.4.1–5.4.4, we can create an evaluator machine model that we can run using the register-machine simulator of section 5.2.</p>
<p class="Sp-text-1"><a id="c5-para-1157"/><b>const</b> eceval = make_machine(list("comp", "env", "val", "fun",</p>
<p class="Sp-text-1"><a id="c5-para-1158"/>                                 "argl", "continue", "unev"),</p>
<p class="Sp-text-1"><a id="c5-para-1159"/>                            eceval_operations,</p>
<p class="Sp-text-1"><a id="c5-para-1160"/>                            list("read_evaluate_print_loop",</p>
<p class="Sp-text-1"><a id="c5-para-1161"/>                                 〈<i>entire machine controller as given above</i>〉</p>
<p class="Sp-text-1"><a id="c5-para-1162"/>                                 "evaluator_done"));</p>
<p class="paracontinue"><a id="c5-para-1163"/>We must define JavaScript functions to simulate the operations used as primitives by the evaluator. These are the same functions we used for the metacircular evaluator in section 4.1, together with the few additional ones defined in footnotes throughout section 5.4.</p>
<p class="Sp-text-1"><a id="c5-para-1164"/><b>const</b> eceval_operations = list(list("is_literal", is_literal),</p>
<p class="Sp-text-1"><a id="c5-para-1165"/>                               〈<i>complete list of operations for eceval machine</i>〉);</p>
<p><a id="c5-para-1166"/>Finally, we can initialize the global environment and run the evaluator:</p>
<p class="Sp-text-1"><a id="c5-para-1167"/><b>const</b> the_global_environment = setup_environment();</p>
<p class="Sp-text-1"><a id="c5-para-1168"/>start(eceval);</p>
<p class="Sp-text-3"><a id="c5-para-1169"/><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c5-para-1170"/><b>function</b> append(x, y) {</p>
<p class="Sp-text-1"><a id="c5-para-1171"/>    <b>return</b> is_null(x)</p>
<p class="Sp-text-1"><a id="c5-para-1172"/>           ? y</p>
<p class="Sp-text-1"><a id="c5-para-1173"/>           : pair(head(x), append(tail(x), y));</p>
<p class="Sp-text-1"><a id="c5-para-1174"/>}</p>
<p class="Sp-text-3"><a id="c5-para-1175"/><i>EC-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c5-para-1176"/><i>undefined</i></p>
<p class="Sp-text-3"><a id="c5-para-1177"/><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c5-para-1178"/>append(list("a", "b", "c"), list("d", "e", "f"));</p>
<p class="Sp-text-3"><a id="c5-para-1179"/><i>EC-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c5-para-1180"/><i>["a", ["b", ["c", ["d", ["e", ["f", null]]]]]]</i></p>
<p><a id="c5-para-1181"/>Of course, evaluating programs in this way will take much longer than if we had directly typed them into JavaScript, because of the multiple levels of simulation involved. Our programs are evaluated by the explicit-control-evaluator machine, which is being simulated by a JavaScript program, which is itself being evaluated by the JavaScript interpreter.</p>
<section>
<h5><a id="c5-sec-0071"/><a id="c5-title-0072"/>Monitoring the performance of the evaluator</h5>
<p class="paraaftertitle"><a id="c5-para-1182"/>Simulation can be a powerful tool to guide the implementation of evaluators. Simulations make it easy not only to explore variations of the register-machine design but also to monitor the performance of the simulated evaluator. For example, one important factor in performance is how efficiently the evaluator uses the stack. We can observe the number of stack operations required to evaluate various programs by defining the evaluator register machine with the version of the simulator that collects statistics on stack use (section 5.2.4), and adding an instruction at the evaluator's <span class="KeyTerm1">print_result</span> entry point to print the statistics:</p>
<p class="Sp-text-1"><a id="c5-para-1183"/>"print_result",</p>
<p class="Sp-text-1"><a id="c5-para-1184"/>  perform(list(op("print_stack_statistics"))), <i>//</i> <span class="KeyTerm2"><i>added instruction</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1185"/>  <i>//</i> <span class="KeyTerm2"><i>rest is same as before</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1186"/>  perform(list(op("user_print"),</p>
<p class="Sp-text-1"><a id="c5-para-1187"/>               constant("EC-evaluate value:"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-1188"/>  go_to(label("read_evaluate_print_loop")),</p>
<p class="paracontinue"><a id="c5-para-1189"/>Interactions with the evaluator now look like this:</p>
<p class="Sp-text-3"><a id="c5-para-1190"/><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c5-para-1191"/><b>function</b> factorial (n) {</p>
<p class="Sp-text-1"><a id="c5-para-1192"/>    <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c5-para-1193"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-1194"/>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c5-para-1195"/>}</p>
<p class="Sp-text-3"><a id="c5-para-1196"/><i>total pushes = 4</i></p>
<p class="Sp-text-3"><a id="c5-para-1197"/><i>maximum depth = 3</i></p>
<p class="Sp-text-3"><a id="c5-para-1198"/><i>EC-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c5-para-1199"/><i>undefined</i></p>
<p class="Sp-text-3"><a id="c5-para-1200"/><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c5-para-1201"/>factorial(5);</p>
<p class="Sp-text-3"><a id="c5-para-1202"/><i>total pushes = 151</i></p>
<p class="Sp-text-3"><a id="c5-para-1203"/><i>maximum depth = 28</i></p>
<p class="Sp-text-3"><a id="c5-para-1204"/><i>EC-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c5-para-1205"/><i>120</i></p>
<p class="paracontinue"><a id="c5-para-1206"/>Note that the driver loop of the evaluator reinitializes the stack at the start of each interaction, so that the statistics printed will refer only to stack operations used to evaluate the previous program.</p>
</section>
<section>
<h5><a id="c5-sec-0072"/><a id="c5-title-0073"/>Exercise 5.27</h5>
<p class="paraaftertitle"><a id="c5-para-1207"/>Use the monitored stack to explore the tail-recursive property of the evaluator (section 5.4.2). Start the evaluator and define the iterative <span class="KeyTerm1">factorial</span> function from section 1.2.1:</p>
<p class="Sp-text-1"><a id="c5-para-1208"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c5-para-1209"/>    <b>function</b> iter(product, counter) {</p>
<p class="Sp-text-1"><a id="c5-para-1210"/>    <b>return</b> counter &gt; n</p>
<p class="Sp-text-1"><a id="c5-para-1211"/>           ? product</p>
<p class="Sp-text-1"><a id="c5-para-1212"/>           : iter(counter * product,</p>
<p class="Sp-text-1"><a id="c5-para-1213"/>                  counter + 1);</p>
<p class="Sp-text-1"><a id="c5-para-1214"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-1215"/>    <b>return</b> iter(1, 1);</p>
<p class="Sp-text-1"><a id="c5-para-1216"/>}</p>
<p class="paracontinue"><a id="c5-para-1217"/>Run the function with some small values of <i>n</i>. Record the maximum stack depth and the number of pushes required to compute <i>n</i>! for each of these values.</p>
<ol class="BS_NumberListA">
<li><a id="c5-li-0024"/><span>a. </span>You will find that the maximum depth required to evaluate <i>n</i>! is independent of <i>n</i>. What is that depth?</li>
<li><a id="c5-li-0025"/><span>b. </span>Determine from your data a formula in terms of <i>n</i> for the total number of push operations used in evaluating <i>n</i>! for any <i>n</i> 1. Note that the number of operations used is a linear function of <i>n</i> and is thus determined by two constants.</li>
</ol>
</section>
<section>
<h5><a id="c5-sec-0073"/><a id="c5-title-0074"/>Exercise 5.28</h5>
<p class="paraaftertitle"><a id="c5-para-1220"/>For comparison with exercise 5.27, explore the behavior of the following function for computing factorials recursively:</p>
<p class="Sp-text-1"><a id="c5-para-1221"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c5-para-1222"/>    <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c5-para-1223"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-1224"/>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c5-para-1225"/>}</p>
<p class="paracontinue"><a id="c5-para-1226"/>By running this function with the monitored stack, determine, as a function of <i>n</i>, the maximum depth of the stack and the total number of pushes used in evaluating <i>n</i>! for <i>n</i> 1. (Again, these functions will be linear.) Summarize your experiments by filling in the following table with the appropriate expressions in terms of <i>n</i>:</p>
<figure><figcaption class="tablecaption"><a id="c5-tbl-0001"/></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr style="border-bottom: 1px solid #000000;">
<td style="border-right: 1px solid #000000;"/>
<td style="border-right: 1px solid #000000;"><a id="c5-para-1227"/>Maximum depth</td>
<td><a id="c5-para-1228"/>Number of pushes</td></tr>
<tr style="border-bottom: 1px solid #000000;">
<td style="border-right: 1px solid #000000;"><a id="c5-para-1229"/>Recursive factorial</td>
<td style="border-right: 1px solid #000000;"/>
<td/></tr>
<tr style="border-bottom: 1px solid #000000;">
<td style="border-right: 1px solid #000000;"><a id="c5-para-1230"/>Iterative factorial</td>
<td style="border-right: 1px solid #000000;"/>
<td/></tr></tbody></table></div></figure>

<p class="paracontinue"><a id="c5-para-1231"/>The maximum depth is a measure of the amount of space used by the evaluator in carrying out the computation, and the number of pushes correlates well with the time required.</p>
</section>
<section>
<h5><a id="c5-sec-0074"/><a id="c5-title-0075"/>Exercise 5.29</h5>
<p class="paraaftertitle"><a id="c5-para-1232"/>Modify the definition of the evaluator by changing <span class="KeyTerm1">ev_return</span> as described in section 5.4.2 so that the evaluator is no longer tail-recursive. Rerun your experiments from exercises 5.27 and 5.28 to demonstrate that both versions of the <span class="KeyTerm1">factorial</span> function now require space that grows linearly with their input.</p>
</section>
<section>
<h5><a id="c5-sec-0075"/><a id="c5-title-0076"/>Exercise 5.30</h5>
<p class="paraaftertitle"><a id="c5-para-1233"/>Monitor the stack operations in the tree-recursive Fibonacci computation:</p>
<p class="Sp-text-1"><a id="c5-para-1234"/><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c5-para-1235"/>    <b>return</b> n &lt; 2 ? n : fib(n - 1) + fib(n - 2);</p>
<p class="Sp-text-1"><a id="c5-para-1236"/>}</p>
<ol class="BS_NumberListA">
<li><a id="c5-li-0026"/><span>a. </span>Give a formula in terms of <i>n</i> for the maximum depth of the stack required to compute Fib(<i>n</i>) for <i>n ≥</i> 2. Hint: In section 1.2.2 we argued that the space used by this process grows linearly with <i>n</i>.</li>
<li><a id="c5-li-0027"/><span>b. </span>Give a formula for the total number of pushes used to compute Fib(<i>n</i>) for <i>n ≥</i> 2. You should find that the number of pushes (which correlates well with the time used) grows exponentially with <i>n</i>. Hint: Let <i>S</i>(<i>n</i>) be the number of pushes used in computing Fib(<i>n</i>). You should be able to argue that there is a formula that expresses <i>S</i>(<i>n</i>) in terms of <i>S</i>(<i>n</i> – 1), <i>S</i>(<i>n</i> – 2), and some fixed “overhead” constant <i>k</i> that is independent of <i>n</i>. Give the formula, and say what <i>k</i> is. Then show that <i>S</i>(<i>n</i>) can be expressed as <i>a</i>Fib(<i>n</i> + 1) + <i>b</i> and give the values of <i>a</i> and <i>b</i>.</li>
</ol>
</section>
<section>
<h5><a id="c5-sec-0076"/><a id="c5-title-0077"/>Exercise 5.31</h5>
<p class="paraaftertitle"><a id="c5-para-1239"/>Our evaluator currently catches and signals only two kinds of errors—unknown component types and unknown function types. Other errors will take us out of the evaluator read-evaluate-print loop. When we run the evaluator using the register-machine simulator, these errors are caught by the underlying JavaScript system. This is analogous to the computer crashing when a user program makes an error.<a id="c5-fn-0035a"/><a href="#c5-fn-0035"><sup>35</sup></a> It is a large project to make a real error system work, but it is well worth the effort to understand what is involved here.</p>
<ol class="BS_NumberListA">
<li><a id="c5-li-0028"/><span>a. </span>Errors that occur in the evaluation process, such as an attempt to access an unbound name, could be caught by changing the lookup operation to make it return a distinguished condition code, which cannot be a possible value of any user name. The evaluator can test for this condition code and then do what is necessary to go to <span class="KeyTerm1">signal_error</span>. Find all of the places in the evaluator where such a change is necessary and fix them. This is lots of work.</li>
<li><a id="c5-li-0029"/><span>b. </span>Much worse is the problem of handling errors that are signaled by applying primitive functions such as an attempt to divide by zero or an attempt to extract the <span class="KeyTerm1">head</span> of a string. In a professionally written high-quality system, each primitive application is checked for safety as part of the primitive. For example, every call to <span class="KeyTerm1">head</span> could first check that the argument is a pair. If the argument is not a pair, the application would return a distinguished condition code to the evaluator, which would then report the failure. We could arrange for this in our register-machine simulator by making each primitive function check for applicability and returning an appropriate distinguished condition code on failure. Then the <span class="KeyTerm1">primitive_apply</span> code in the evaluator can check for the condition code and go to <span class="KeyTerm1">signal_error</span> if necessary. Build this structure and make it work. This is a major project.</li>
</ol>
</section>
</section>
</section>
<section>
<h2><a id="c5-sec-0077"/><span>5.5</span> <a id="c5-title-0078"/>Compilation</h2>
<p class="paraaftertitle"><a id="c5-para-1242"/>The explicit-control evaluator of section 5.4 is a register machine whose controller interprets JavaScript programs. In this section we will see how to run JavaScript programs on a register machine whose controller is not a JavaScript interpreter.</p>
<p><a id="c5-para-1243"/>The explicit-control evaluator machine is universal—it can carry out any computational process that can be described in JavaScript. The evaluator's controller orchestrates the use of its data paths to perform the desired computation. Thus, the evaluator's data paths are universal: They are sufficient to perform any computation we desire, given an appropriate controller.<a id="c5-fn-0036a"/><a href="#c5-fn-0036"><sup>36</sup></a></p>
<p><a id="c5-para-1244"/>Commercial general-purpose computers are register machines organized around a collection of registers and operations that constitute an efficient and convenient universal set of data paths. The controller for a general-purpose machine is an interpreter for a register-machine language like the one we have been using. This language is called the <i>native language</i> of the machine, or simply <i>machine language</i>. Programs written in machine language are sequences of instructions that use the machine's data paths. For example, the explicit-control evaluator's instruction sequence can be thought of as a machine-language program for a general-purpose computer rather than as the controller for a specialized interpreter machine.</p>
<p><a id="c5-para-1245"/>There are two common strategies for bridging the gap between higher-level languages and register-machine languages. The explicit-control evaluator illustrates the strategy of interpretation. An interpreter written in the native language of a machine configures the machine to execute programs written in a language (called the <i>source language</i>) that may differ from the native language of the machine performing the evaluation. The primitive functions of the source language are implemented as a library of subroutines written in the native language of the given machine. A program to be interpreted (called the <i>source program</i>) is represented as a data structure. The interpreter traverses this data structure, analyzing the source program. As it does so, it simulates the intended behavior of the source program by calling appropriate primitive subroutines from the library.</p>
<p><a id="c5-para-1246"/>In this section, we explore the alternative strategy of <i>compilation</i>. A compiler for a given source language and machine translates a source program into an equivalent program (called the <i>object program</i>) written in the machine's native language. The compiler that we implement in this section translates programs written in JavaScript into sequences of instructions to be executed using the explicit-control evaluator machine's data paths.<a id="c5-fn-0037a"/><a href="#c5-fn-0037"><sup>37</sup></a></p>
<p><a id="c5-para-1247"/>Compared with interpretation, compilation can provide a great increase in the efficiency of program execution, as we will explain below in the overview of the compiler. On the other hand, an interpreter provides a more powerful environment for interactive program development and debugging, because the source program being executed is available at run time to be examined and modified. In addition, because the entire library of primitives is present, new programs can be constructed and added to the system during debugging.</p>
<p><a id="c5-para-1248"/>In view of the complementary advantages of compilation and interpretation, modern program-development environments pursue a mixed strategy. These systems are generally organized so that interpreted functions and compiled functions can call each other. This enables a programmer to compile those parts of a program that are assumed to be debugged, thus gaining the efficiency advantage of compilation, while retaining the interpretive mode of execution for those parts of the program that are in the flux of interactive development and debugging.<a id="c5-fn-0038a"/><a href="#c5-fn-0038"><sup>38</sup></a> In section 5.5.7, after we have implemented the compiler, we will show how to interface it with our interpreter to produce an integrated interpreter-compiler system.</p>
<section><a id="c5-title-0079"/>
<section>
<h5><a id="c5-sec-0079"/><a id="c5-title-0080"/>An overview of the compiler</h5>
<p class="paraaftertitle"><a id="c5-para-1249"/>Our compiler is much like our interpreter, both in its structure and in the function it performs. Accordingly, the mechanisms used by the compiler for analyzing components will be similar to those used by the interpreter. Moreover, to make it easy to interface compiled and interpreted code, we will design the compiler to generate code that obeys the same conventions of register usage as the interpreter: The environment will be kept in the <span class="KeyTerm1">env</span> register, argument lists will be accumulated in <span class="KeyTerm1">argl</span>, a function to be applied will be in <span class="KeyTerm1">fun</span>, functions will return their answers in <span class="KeyTerm1">val</span>, and the location to which a function should return will be kept in <span class="KeyTerm1">continue</span>. In general, the compiler translates a source program into an object program that performs essentially the same register operations as would the interpreter in evaluating the same source program.</p>
<p><a id="c5-para-1250"/>This description suggests a strategy for implementing a rudimentary compiler: We traverse the component in the same way the interpreter does. When we encounter a register instruction that the interpreter would perform in evaluating the component, we do not execute the instruction but instead accumulate it into a sequence. The resulting sequence of instructions will be the object code. Observe the efficiency advantage of compilation over interpretation. Each time the interpreter evaluates a component—for example, <span class="KeyTerm1">f(96, 22)</span>—it performs the work of classifying the component (discovering that this is a function application) and testing for the end of the list of argument expressions (discovering that there are two argument expressions). With a compiler, the component is analyzed only once, when the instruction sequence is generated at compile time. The object code produced by the compiler contains only the instructions that evaluate the function expression and the two argument expressions, assemble the argument list, and apply the function (in <span class="KeyTerm1">fun</span>) to the arguments (in <span class="KeyTerm1">argl</span>).</p>
<p><a id="c5-para-1251"/>This is the same kind of optimization we implemented in the analyzing evaluator of section 4.1.7. But there are further opportunities to gain efficiency in compiled code. As the interpreter runs, it follows a process that must be applicable to any component in the language. In contrast, a given segment of compiled code is meant to execute some particular component. This can make a big difference, for example in the use of the stack to save registers. When the interpreter evaluates a component, it must be prepared for any contingency. Before evaluating a subcomponent, the interpreter saves all registers that will be needed later, because the subcomponent might require an arbitrary evaluation. A compiler, on the other hand, can exploit the structure of the particular component it is processing to generate code that avoids unnecessary stack operations.</p>
<p><a id="c5-para-1252"/>As a case in point, consider the application <span class="KeyTerm1">f(96, 22)</span>. Before the interpreter evaluates the function expression of the application, it prepares for this evaluation by saving the registers containing the argument expressions and the environment, whose values will be needed later. The interpreter then evaluates the function expression to obtain the result in <span class="KeyTerm1">val</span>, restores the saved registers, and finally moves the result from <span class="KeyTerm1">val</span> to <span class="KeyTerm1">fun</span>. However, in the particular expression we are dealing with, the function expression is the name <span class="KeyTerm1">f</span>, whose evaluation is accomplished by the machine operation <span class="KeyTerm1">lookup_symbol_value</span>, which does not alter any registers. The compiler that we implement in this section will take advantage of this fact and generate code that evaluates the function expression using the instruction</p>
<p class="Sp-text-1"><a id="c5-para-1253"/>assign("fun",</p>
<p class="Sp-text-1"><a id="c5-para-1254"/>       list(op("lookup_symbol_value"), constant("f"), reg("env")))</p>
<p class="paracontinue"><a id="c5-para-1255"/>where the argument to <span class="KeyTerm1">lookup_symbol_value</span> is extracted at compile time from the parser's representation of <span class="KeyTerm1">f(96, 22)</span>. This code not only avoids the unnecessary saves and restores but also assigns the value of the lookup directly to <span class="KeyTerm1">fun</span>, whereas the interpreter would obtain the result in <span class="KeyTerm1">val</span> and then move this to <span class="KeyTerm1">fun</span>.</p>
<p><a id="c5-para-1256"/>A compiler can also optimize access to the environment. Having analyzed the code, the compiler can know in which frame the value of a particular name will be located and access that frame directly, rather than performing the <span class="KeyTerm1">lookup_ symbol_value</span> search. We will discuss how to implement such lexical addressing in section 5.5.6. Until then, however, we will focus on the kind of register and stack optimizations described above. There are many other optimizations that can be performed by a compiler, such as coding primitive operations “in line” instead of using a general <span class="KeyTerm1">apply</span> mechanism (see exercise 5.41); but we will not emphasize these here. Our main goal in this section is to illustrate the compilation process in a simplified (but still interesting) context.</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0080"/><span>5.5.1</span> <a id="c5-title-0081"/>Structure of the Compiler</h3>
<p class="paraaftertitle"><a id="c5-para-1257"/>In section 4.1.7 we modified our original metacircular interpreter to separate analysis from execution. We analyzed each component to produce an execution function that took an environment as argument and performed the required operations. In our compiler, we will do essentially the same analysis. Instead of producing execution functions, however, we will generate sequences of instructions to be run by our register machine.</p>
<p><a id="c5-para-1258"/>The function <span class="KeyTerm1">compile</span> is the top-level dispatch in the compiler. It corresponds to the <span class="KeyTerm1">evaluate</span> function of section 4.1.1, the <span class="KeyTerm1">analyze</span> function of section 4.1.7, and the <span class="KeyTerm1">eval_dispatch</span> entry point of the explicit-control-evaluator in section 5.4.1. The compiler, like the interpreters, uses the component-syntax functions defined in section 4.1.2.<a id="c5-fn-0039a"/><a href="#c5-fn-0039"><sup>39</sup></a> The function <span class="KeyTerm1">compile</span> performs a case analysis on the syntactic type of the component to be compiled. For each type of component, it dispatches to a specialized <i>code generator</i>:</p>
<p class="Sp-text-1"><a id="c5-para-1259"/><b>function</b> compile(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1260"/>    <b>return</b> is_literal(component)</p>
<p class="Sp-text-1"><a id="c5-para-1261"/>           ? compile_literal(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1262"/>           : is_name(component)</p>
<p class="Sp-text-1"><a id="c5-para-1263"/>           ? compile_name(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1264"/>           : is_application(component)</p>
<p class="Sp-text-1"><a id="c5-para-1265"/>           ? compile_application(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1266"/>           : is_operator_combination(component)</p>
<p class="Sp-text-1"><a id="c5-para-1267"/>           ? compile(operator_combination_to_application(component),</p>
<p class="Sp-text-1"><a id="c5-para-1268"/>                     target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1269"/>           : is_conditional(component)</p>
<p class="Sp-text-1"><a id="c5-para-1270"/>           ? compile_conditional(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1271"/>           : is_lambda_expression(component)</p>
<p class="Sp-text-1"><a id="c5-para-1272"/>           ? compile_lambda_expression(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1273"/>           : is_sequence(component)</p>
<p class="Sp-text-1"><a id="c5-para-1274"/>           ? compile_sequence(sequence_statements(component),</p>
<p class="Sp-text-1"><a id="c5-para-1275"/>                              target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1276"/>           : is_block(component)</p>
<p class="Sp-text-1"><a id="c5-para-1277"/>           ? compile_block(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1278"/>           : is_return_statement(component)</p>
<p class="Sp-text-1"><a id="c5-para-1279"/>           ? compile_return_statement(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1280"/>           : is_function_declaration(component)</p>
<p class="Sp-text-1"><a id="c5-para-1281"/>           ? compile(function_decl_to_constant_decl(component),</p>
<p class="Sp-text-1"><a id="c5-para-1282"/>                     target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1283"/>           : is_declaration(component)</p>
<p class="Sp-text-1"><a id="c5-para-1284"/>           ? compile_declaration(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1285"/>           : is_assignment(component)</p>
<p class="Sp-text-1"><a id="c5-para-1286"/>           ? compile_assignment(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1287"/>           : error(component, "unknown component type – compile");</p>
<p class="Sp-text-1"><a id="c5-para-1288"/>}</p>
<section>
<h5><a id="c5-sec-0081"/><a id="c5-title-0082"/>Targets and linkages</h5>
<p class="paraaftertitle"><a id="c5-para-1289"/>The function <span class="KeyTerm1">compile</span> and the code generators that it calls take two arguments in addition to the component to compile. There is a <i>target</i>, which specifies the register in which the compiled code is to return the value of the component. There is also a <i>linkage descriptor</i>, which describes how the code resulting from the compilation of the component should proceed when it has finished its execution. The linkage descriptor can require the code to do one of the following three things:</p>
<ul style="list-style-type:disc">
<li>proceed to the next instruction in sequence (this is specified by the linkage descriptor <span class="KeyTerm1">"next"</span>),</li>
<li>jump to the current value of the <span class="KeyTerm1">continue</span> register as part of returning from a function call (this is specified by the linkage descriptor <span class="KeyTerm1">"return"</span>), or</li>
<li>jump to a named entry point (this is specified by using the designated label as the linkage descriptor).</li>
</ul>

<p><a id="c5-para-1293"/>For example, compiling the literal <span class="KeyTerm1">5</span> with a target of the <span class="KeyTerm1">val</span> register and a linkage of <span class="KeyTerm1">"next"</span> should produce the instruction</p>
<p class="Sp-text-1"><a id="c5-para-1294"/>assign("val", constant(5))</p>
<p class="paracontinue"><a id="c5-para-1295"/>Compiling the same expression with a linkage of <span class="KeyTerm1">"return"</span> should produce the instructions</p>
<p class="Sp-text-1"><a id="c5-para-1296"/>assign("val", constant(5)),</p>
<p class="Sp-text-1"><a id="c5-para-1297"/>go_to(reg("continue"))</p>
<p class="paracontinue"><a id="c5-para-1298"/>In the first case, execution will continue with the next instruction in the sequence. In the second case, we will jump to whatever entry point is stored in the <span class="KeyTerm1">continue</span> register. In both cases, the value of the expression will be placed into the target <span class="KeyTerm1">val</span> register. Our compiler uses the <span class="KeyTerm1">"return"</span> linkage when compiling the return expression of a return statement. Just as in the explicit-control evaluator, returning from a function call happens in three steps:</p>
<ol class="BS_NumberList1">
<li><a id="c5-li-0033"/><span>1. </span>reverting the stack to the marker and restoring <span class="KeyTerm1">continue</span> (which holds a continuation set up at the beginning of the function call)</li>
<li><a id="c5-li-0034"/><span>2. </span>computing the return value and placing it in <span class="KeyTerm1">val</span></li>
<li><a id="c5-li-0035"/><span>3. </span>jumping to the entry point in <span class="KeyTerm1">continue</span></li>
</ol>

<p class="paracontinue"><a id="c5-para-1302"/>Compilation of a return statement explicitly generates code for reverting the stack and restoring <span class="KeyTerm1">continue</span>. The return expression is compiled with target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"return"</span> so that the generated code for computing the return value places the return value in <span class="KeyTerm1">val</span> and ends by jumping to <span class="KeyTerm1">continue</span>.</p>
</section>
<section>
<h5><a id="c5-sec-0082"/><a id="c5-title-0083"/>Instruction sequences and stack usage</h5>
<p class="paraaftertitle"><a id="c5-para-1303"/>Each code generator returns an <i>instruction sequence</i> containing the object code it has generated for the component. Code generation for a compound component is accomplished by combining the output from simpler code generators for subcomponents, just as evaluation of a compound component is accomplished by evaluating the subcomponents.</p>
<p><a id="c5-para-1304"/>The simplest method for combining instruction sequences is a function called <span class="KeyTerm1">append_instruction_sequences</span>, which takes as arguments two instruction sequences that are to be executed sequentially. It appends them and returns the combined sequence. That is, if <i>seq</i><sub>1</sub> and <i>seq</i><sub>2</sub> are sequences of instructions, then evaluating</p>
<p class="Sp-text-1"><a id="c5-para-1305"/>append_instruction_sequences(<span class="KeyTerm2"><i>seq</i><sub>1</sub></span>, <span class="KeyTerm2"><i>seq</i><sub>2</sub></span>)</p>
<p class="paracontinue"><a id="c5-para-1306"/>produces the sequence</p>
<p class="Sp-text-1"><a id="c5-para-1307"/><span class="KeyTerm2"><i>seq<sub>1</sub></i></span></p>
<p class="Sp-text-1"><a id="c5-para-1308"/><span class="KeyTerm2"><i>seq<sub>2</sub></i></span></p>
<p><a id="c5-para-1309"/>Whenever registers might need to be saved, the compiler's code generators use <span class="KeyTerm1">preserving</span>, which is a more subtle method for combining instruction sequences. The function <span class="KeyTerm1">preserving</span> takes three arguments: a set of registers and two instruction sequences that are to be executed sequentially. It appends the sequences in such a way that the contents of each register in the set is preserved over the execution of the first sequence, if this is needed for the execution of the second sequence. That is, if the first sequence modifies the register and the second sequence actually needs the register's original contents, then <span class="KeyTerm1">preserving</span> wraps a <span class="KeyTerm1">save</span> and a <span class="KeyTerm1">restore</span> of the register around the first sequence before appending the sequences. Otherwise, <span class="KeyTerm1">preserving</span> simply returns the appended instruction sequences. Thus, for example,</p>
<p class="Sp-text-1"><a id="c5-para-1310"/>preserving(list(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, <span class="KeyTerm2"><i>reg</i><sub>2</sub></span>), <span class="KeyTerm2"><i>seq</i><sub>1</sub></span>, <span class="KeyTerm2"><i>seq</i><sub>2</sub></span>)</p>
<p class="paracontinue"><a id="c5-para-1311"/>produces one of the following four sequences of instructions, depending on how <i>seq</i><sub>1</sub> and <i>seq</i><sub>2</sub> use <i>reg</i><sub>1</sub> and <i>reg</i><sub>2</sub>:</p>
<figure><figcaption class="tablecaption"><a id="c5-tbl-0002"/></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td style="border-right:1px solid #000000;"><a id="c5-para-1312"/>seq<sub>1</sub></td>
<td style="border-right:1px solid #000000;"><a id="c5-para-1313"/><span class="KeyTerm1">save</span>(reg<sub>1</sub>),</td>
<td style="border-right:1px solid #000000;"><a id="c5-para-1314"/><span class="KeyTerm1">save</span>(reg<sub>2</sub>),</td>
<td><a id="c5-para-1315"/><span class="KeyTerm1">save</span>(reg<sub>2</sub>),</td></tr>
<tr>
<td style="border-right:1px solid #000000;"><a id="c5-para-1316"/>seq<sub>2</sub></td>
<td style="border-right:1px solid #000000;"><a id="c5-para-1317"/>seq<sub>1</sub></td>
<td style="border-right:1px solid #000000;"><a id="c5-para-1318"/>seq<sub>1</sub></td>
<td><a id="c5-para-1319"/><span class="KeyTerm1">save</span>(reg<sub>1</sub>),</td></tr>
<tr>
<td style="border-right:1px solid #000000;"/>
<td style="border-right:1px solid #000000;"><a id="c5-para-1320"/><span class="KeyTerm1">restore</span>(reg<sub>1</sub>),</td>
<td style="border-right:1px solid #000000;"><a id="c5-para-1321"/><span class="KeyTerm1">restore</span>(reg<sub>2</sub>),</td>
<td><a id="c5-para-1322"/>seq<sub>1</sub></td></tr>
<tr>
<td style="border-right:1px solid #000000;"/>
<td style="border-right:1px solid #000000;"><a id="c5-para-1323"/>seq<sub>2</sub></td>
<td style="border-right:1px solid #000000;"><a id="c5-para-1324"/>seq<sub>2</sub></td>
<td><a id="c5-para-1325"/><span class="KeyTerm1">restore</span>(reg<sub>1</sub>),</td></tr>
<tr>
<td style="border-right:1px solid #000000;"/>
<td style="border-right:1px solid #000000;"/>
<td style="border-right:1px solid #000000;"/>
<td><a id="c5-para-1326"/><span class="KeyTerm1">restore</span>(reg<sub>2</sub>),</td></tr>
<tr>
<td style="border-right:1px solid #000000;"/>
<td style="border-right:1px solid #000000;"/>
<td style="border-right:1px solid #000000;"/>
<td><a id="c5-para-1327"/>seq<sub>2</sub></td></tr></tbody></table></div>
</figure>

<p><a id="c5-para-1328"/>By using <span class="KeyTerm1">preserving</span> to combine instruction sequences the compiler avoids unnecessary stack operations. This also isolates the details of whether or not to generate <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> instructions within the <span class="KeyTerm1">preserving</span> function, separating them from the concerns that arise in writing each of the individual code generators. In fact no <span class="KeyTerm1">save</span> or <span class="KeyTerm1">restore</span> instructions are explicitly produced by the code generators, except that the code for calling a function saves <span class="KeyTerm1">continue</span> and the code for returning from a function restores it: These corresponding <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> instructions are explicitly generated by different calls to <span class="KeyTerm1">compile</span>, not as a matched pair by <span class="KeyTerm1">preserving</span> (as we will see in section 5.5.3).</p>
<p><a id="c5-para-1329"/>In principle, we could represent an instruction sequence simply as a list of instructions. The function <span class="KeyTerm1">append_instruction_sequences</span> could then combine instruction sequences by performing an ordinary list <span class="KeyTerm1">append</span>. However, <span class="KeyTerm1">preserving</span> would then be a complex operation, because it would have to analyze each instruction sequence to determine how the sequence uses its registers. The function <span class="KeyTerm1">preserving</span> would be inefficient as well as complex, because it would have to analyze each of its instruction sequence arguments, even though these sequences might themselves have been constructed by calls to <span class="KeyTerm1">preserving</span>, in which case their parts would have already been analyzed. To avoid such repetitious analysis we will associate with each instruction sequence some information about its register use. When we construct a basic instruction sequence we will provide this information explicitly, and the functions that combine instruction sequences will derive registeruse information for the combined sequence from the information associated with the sequences being combined.</p>
<p><a id="c5-para-1330"/>An instruction sequence will contain three pieces of information:</p>
<ul style="list-style-type:disc">
<li>the set of registers that must be initialized before the instructions in the sequence are executed (these registers are said to be <i>needed</i> by the sequence),</li>
<li>the set of registers whose values are modified by the instructions in the sequence, and</li>
<li>the actual instructions in the sequence.</li>
</ul>

<p class="paracontinue"><a id="c5-para-1334"/>We will represent an instruction sequence as a list of its three parts. The constructor for instruction sequences is thus</p>
<p class="Sp-text-1"><a id="c5-para-1335"/><b>function</b> make_instruction_sequence(needs, modifies, instructions) {</p>
<p class="Sp-text-1"><a id="c5-para-1336"/>    <b>return</b> list(needs, modifies, instructions);</p>
<p class="Sp-text-1"><a id="c5-para-1337"/>}</p>
<p><a id="c5-para-1338"/>For example, the two-instruction sequence that looks up the value of the symbol <span class="KeyTerm1">"x"</span> in the current environment, assigns the result to <span class="KeyTerm1">val</span>, and then proceeds to the continuation, requires registers <span class="KeyTerm1">env</span> and <span class="KeyTerm1">continue</span> to have been initialized, and modifies register <span class="KeyTerm1">val</span>. This sequence would therefore be constructed as</p>
<p class="Sp-text-1"><a id="c5-para-1339"/>make_instruction_sequence</p>
<p class="Sp-text-1"><a id="c5-para-1340"/>    list("env", "continue"), list("val"), list(assign("val",</p>
<p class="Sp-text-1"><a id="c5-para-1341"/>                list(op("lookup_symbol_value"), constant("x"),</p>
<p class="Sp-text-1"><a id="c5-para-1342"/>                     reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1343"/>         go_to(reg("continue"))));</p>
<p><a id="c5-para-1344"/>The functions for combining instruction sequences are shown in section 5.5.4.</p>
</section>
<section>
<h5><a id="c5-sec-0083"/><a id="c5-title-0084"/>Exercise 5.32</h5>
<p class="paraaftertitle"><a id="c5-para-1345"/>In evaluating a function application, the explicit-control evaluator always saves and restores the <span class="KeyTerm1">env</span> register around the evaluation of the function expression, saves and restores <span class="KeyTerm1">env</span> around the evaluation of each argument expression (except the final one), saves and restores <span class="KeyTerm1">argl</span> around the evaluation of each argument expression, and saves and restores <span class="KeyTerm1">fun</span> around the evaluation of the argument-expression sequence. For each of the following applications, say which of these <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> operations are superfluous and thus could be eliminated by the compiler's <span class="KeyTerm1">preserving</span> mechanism:</p>
<p class="Sp-text-1"><a id="c5-para-1346"/>f("x", "y")</p>
<p class="Sp-text-1"><a id="c5-para-1347"/>f()("x", "y")</p>
<p class="Sp-text-1"><a id="c5-para-1348"/>f(g("x"), y)</p>
<p class="Sp-text-1"><a id="c5-para-1349"/>f(g("x"), "y")</p>
</section>
<section>
<h5><a id="c5-sec-0084"/><a id="c5-title-0085"/>Exercise 5.33</h5>
<p class="paraaftertitle"><a id="c5-para-1350"/>Using the <span class="KeyTerm1">preserving</span> mechanism, the compiler will avoid saving and restoring <span class="KeyTerm1">env</span> around the evaluation of the function expression of an application in the case where the function expression is a name. We could also build such optimizations into the evaluator. Indeed, the explicit-control evaluator of section 5.4 already performs a similar optimization, by treating applications with no arguments as a special case.</p>
<ol class="BS_NumberListA">
<li><a id="c5-li-0039"/><span>a. </span>Extend the explicit-control evaluator to recognize as a separate class of components applications whose function expression is a name, and to take advantage of this fact in evaluating such components.</li>
<li><a id="c5-li-0040"/><span>b. </span>Alyssa P. Hacker suggests that by extending the evaluator to recognize more and more special cases we could incorporate all the compiler's optimizations, and that this would eliminate the advantage of compilation altogether. What do you think of this idea?</li>
</ol>
</section>
</section>
<section>
<h3><a id="c5-sec-0085"/><span>5.5.2</span> <a id="c5-title-0086"/>Compiling Components</h3>
<p class="paraaftertitle"><a id="c5-para-1353"/>In this section and the next we implement the code generators to which the <span class="KeyTerm1">compile</span> function dispatches.</p>
<section>
<h5><a id="c5-sec-0086"/><a id="c5-title-0087"/>Compiling linkage code</h5>
<p class="paraaftertitle"><a id="c5-para-1354"/>In general, the output of each code generator will end with instructions—generated by the function <span class="KeyTerm1">compile_linkage</span>—that implement the required linkage. If the linkage is <span class="KeyTerm1">"return"</span> then we must generate the instruction <span class="KeyTerm1">go_to(reg("continue"))</span>. This needs the <span class="KeyTerm1">continue</span> register and does not modify any registers. If the linkage is <span class="KeyTerm1">"next"</span>, then we needn't include any additional instructions. Otherwise, the linkage is a label, and we generate a <span class="KeyTerm1">go_to</span> to that label, an instruction that does not need or modify any registers.</p>
<p class="Sp-text-1"><a id="c5-para-1355"/><b>function</b> compile_linkage(linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1356"/>    <b>return</b> linkage === "return"</p>
<p class="Sp-text-1"><a id="c5-para-1357"/>           ? make_instruction_sequence(list("continue"), <b>null</b>,</p>
<p class="Sp-text-1"><a id="c5-para-1358"/>                                       list(go_to(reg("continue"))))</p>
<p class="Sp-text-1"><a id="c5-para-1359"/>           : linkage === "next"</p>
<p class="Sp-text-1"><a id="c5-para-1360"/>           ? make_instruction_sequence(<b>null</b>, <b>null</b>, <b>null</b>)</p>
<p class="Sp-text-1"><a id="c5-para-1361"/>           : make_instruction_sequence(<b>null</b>, <b>null</b>,</p>
<p class="Sp-text-1"><a id="c5-para-1362"/>                                       list(go_to(label(linkage))));</p>
<p class="Sp-text-1"><a id="c5-para-1363"/>}</p>
<p class="paracontinue"><a id="c5-para-1364"/>The linkage code is appended to an instruction sequence by <span class="KeyTerm1">preserving</span> the <span class="KeyTerm1">continue</span> register, since a <span class="KeyTerm1">"return"</span> linkage will require the <span class="KeyTerm1">continue</span> register: If the given instruction sequence modifies <span class="KeyTerm1">continue</span> and the linkage code needs it, <span class="KeyTerm1">continue</span> will be saved and restored.</p>
<p class="Sp-text-1"><a id="c5-para-1365"/><b>function</b> end_with_linkage(linkage, instruction_sequence) {</p>
<p class="Sp-text-1"><a id="c5-para-1366"/>    <b>return</b> preserving(list("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1367"/>                      instruction_sequence,</p>
<p class="Sp-text-1"><a id="c5-para-1368"/>                      compile_linkage(linkage));</p>
<p class="Sp-text-1"><a id="c5-para-1369"/>}</p>
</section>
<section>
<h5><a id="c5-sec-0087"/><a id="c5-title-0088"/>Compiling simple components</h5>
<p class="paraaftertitle"><a id="c5-para-1370"/>The code generators for literal expressions and names construct instruction sequences that assign the required value to the target register and then proceed as specified by the linkage descriptor.</p>
<p><a id="c5-para-1371"/>The literal value is extracted at compile time from the component being compiled and put into the constant part of the <span class="KeyTerm1">assign</span> instruction. For a name, an instruction is generated to use the <span class="KeyTerm1">lookup_symbol_value</span> operation when the compiled program is run, to look up the value associated with a symbol in the current environment. Like a literal value, the symbol is extracted at compile time from the component being compiled. Thus <span class="KeyTerm1">symbol_of_name(component)</span> is executed only once, when the program is being compiled, and the symbol appears as a constant in the <span class="KeyTerm1">assign</span> instruction.</p>
<p class="Sp-text-1"><a id="c5-para-1372"/><b>function</b> compile_literal(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1373"/>    <b>const</b> literal = literal_value(component);</p>
<p class="Sp-text-1"><a id="c5-para-1374"/>    <b>return</b> end_with_linkage(linkage,</p>
<p class="Sp-text-1"><a id="c5-para-1375"/>               make_instruction_sequence(<b>null</b>, list(target),</p>
<p class="Sp-text-1"><a id="c5-para-1376"/>                   list(assign(target, constant(literal)))));</p>
<p class="Sp-text-1"><a id="c5-para-1377"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1378"/><b>function</b> compile_name(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1379"/>    <b>const</b> symbol = symbol_of_name(component);</p>
<p class="Sp-text-1"><a id="c5-para-1380"/>    <b>return</b> end_with_linkage(linkage,</p>
<p class="Sp-text-1"><a id="c5-para-1381"/>               make_instruction_sequence(list("env"), list(target),</p>
<p class="Sp-text-1"><a id="c5-para-1382"/>                   list(assign(target,</p>
<p class="Sp-text-1"><a id="c5-para-1383"/>                               list(op("lookup_symbol_value"),</p>
<p class="Sp-text-1"><a id="c5-para-1384"/>                                    constant(symbol),</p>
<p class="Sp-text-1"><a id="c5-para-1385"/>                                    reg("env"))))));</p>
<p class="Sp-text-1"><a id="c5-para-1386"/>}</p>
<p class="paracontinue"><a id="c5-para-1387"/>These assignment instructions modify the target register, and the one that looks up a symbol needs the <span class="KeyTerm1">env</span> register.</p>
<p><a id="c5-para-1388"/>Assignments and declarations are handled much as they are in the interpreter. The function <span class="KeyTerm1">compile_assignment_declaration</span> recursively generates code that computes the value to be associated with the symbol and appends to it a twoinstruction sequence that updates the value associated with the symbol in the environment and assigns the value of the whole component (the assigned value for an assignment or <span class="KeyTerm1">undefined</span> for a declaration) to the target register. The recursive compilation has target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"next"</span> so that the code will put its result into <span class="KeyTerm1">val</span> and continue with the code that is appended after it. The appending is done preserving <span class="KeyTerm1">env</span>, since the environment is needed for updating the symbol–value association and the code for computing the value could be the compilation of a complex expression that might modify the registers in arbitrary ways.</p>
<p class="Sp-text-1"><a id="c5-para-1389"/><b>function</b> compile_assignment(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1390"/>    <b>return</b> compile_assignment_declaration(</p>
<p class="Sp-text-1"><a id="c5-para-1391"/>               assignment_symbol(component),</p>
<p class="Sp-text-1"><a id="c5-para-1392"/>               assignment_value_expression(component),</p>
<p class="Sp-text-1"><a id="c5-para-1393"/>               reg("val"),</p>
<p class="Sp-text-1"><a id="c5-para-1394"/>               target, linkage);</p>
<p class="Sp-text-1"><a id="c5-para-1395"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1396"/><b>function</b> compile_declaration(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1397"/>    <b>return</b> compile_assignment_declaration(</p>
<p class="Sp-text-1"><a id="c5-para-1398"/>               declaration_symbol(component),</p>
<p class="Sp-text-1"><a id="c5-para-1399"/>               declaration_value_expression(component),</p>
<p class="Sp-text-1"><a id="c5-para-1400"/>               constant(undefined),</p>
<p class="Sp-text-1"><a id="c5-para-1401"/>               target, linkage);</p>
<p class="Sp-text-1"><a id="c5-para-1402"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1403"/><b>function</b> compile_assignment_declaration(</p>
<p class="Sp-text-1"><a id="c5-para-1404"/>             symbol, value_expression, final_value,</p>
<p class="Sp-text-1"><a id="c5-para-1405"/>             target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1406"/>    <b>const</b> get_value_code = compile(value_expression, "val", "next");</p>
<p class="Sp-text-1"><a id="c5-para-1407"/>    <b>return</b> end_with_linkage(linkage,</p>
<p class="Sp-text-1"><a id="c5-para-1408"/>               preserving(list("env"),</p>
<p class="Sp-text-1"><a id="c5-para-1409"/>                   get_value_code,</p>
<p class="Sp-text-1"><a id="c5-para-1410"/>                   make_instruction_sequence(list("env", "val"),</p>
<p class="Sp-text-1"><a id="c5-para-1411"/>                                             list(target),</p>
<p class="Sp-text-1"><a id="c5-para-1412"/>                        list(perform(list(op("assign_symbol_value"),</p>
<p class="Sp-text-1"><a id="c5-para-1413"/>                                          constant(symbol),</p>
<p class="Sp-text-1"><a id="c5-para-1414"/>                                          reg("val"),</p>
<p class="Sp-text-1"><a id="c5-para-1415"/>                                          reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1416"/>                             assign(target, final_value)))));</p>
<p class="Sp-text-1"><a id="c5-para-1417"/>}</p>
<p class="paracontinue"><a id="c5-para-1418"/>The appended two-instruction sequence requires <span class="KeyTerm1">env</span> and <span class="KeyTerm1">val</span> and modifies the target. Note that although we preserve <span class="KeyTerm1">env</span> for this sequence, we do not preserve <span class="KeyTerm1">val</span>, because the <span class="KeyTerm1">get_value_code</span> is designed to explicitly place its result in <span class="KeyTerm1">val</span> for use by this sequence. (In fact, if we did preserve <span class="KeyTerm1">val</span>, we would have a bug, because this would cause the previous contents of <span class="KeyTerm1">val</span> to be restored right after the <span class="KeyTerm1">get_value_code</span> is run.)</p>
</section>
<section>
<h5><a id="c5-sec-0088"/><a id="c5-title-0089"/>Compiling conditionals</h5>
<p class="paraaftertitle"><a id="c5-para-1419"/>The code for a conditional compiled with a given target and linkage has the form</p>
<p class="Sp-text-1"><a id="c5-para-1420"/>〈<span class="KeyTerm2"><i>compilation of predicate</i>, <i>target</i></span> val, <span class="KeyTerm2"><i>linkage</i></span> "next"〉</p>
<p class="Sp-text-1"><a id="c5-para-1421"/>  test(list(op("is_falsy"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-1422"/>  branch(label("false_branch")),</p>
<p class="Sp-text-1"><a id="c5-para-1423"/>"true_branch",</p>
<p class="Sp-text-1"><a id="c5-para-1424"/>  〈<span class="KeyTerm2"><i>compilation of consequent with given target and given linkage or</i></span> after_cond〉</p>
<p class="Sp-text-1"><a id="c5-para-1425"/>"false_branch",</p>
<p class="Sp-text-1"><a id="c5-para-1426"/>  〈<span class="KeyTerm2"><i>compilation of alternative with given target and linkage</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1427"/>"after_cond"</p>
<p><a id="c5-para-1428"/>To generate this code, we compile the predicate, consequent, and alternative, and combine the resulting code with instructions to test the predicate result and with newly generated labels to mark the true and false branches and the end of the conditional.<a id="c5-fn-0040a"/><a href="#c5-fn-0040"><sup>40</sup></a> In this arrangement of code, we must branch around the true branch if the test is false. The only slight complication is in how the linkage for the true branch should be handled. If the linkage for the conditional is <span class="KeyTerm1">"return"</span> or a label, then the true and false branches will both use this same linkage. If the linkage is <span class="KeyTerm1">"next"</span>, the true branch ends with a jump around the code for the false branch to the label at the end of the conditional.</p>
<p class="Sp-text-1"><a id="c5-para-1429"/><b>function</b> compile_conditional(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1430"/>    <b>const</b> t_branch = make_label("true_branch");</p>
<p class="Sp-text-1"><a id="c5-para-1431"/>    <b>const</b> f_branch = make_label("false_branch");</p>
<p class="Sp-text-1"><a id="c5-para-1432"/>    <b>const</b> after_cond = make_label("after_cond");</p>
<p class="Sp-text-1"><a id="c5-para-1433"/>    <b>const</b> consequent_linkage =</p>
<p class="Sp-text-1"><a id="c5-para-1434"/>            linkage === "next" ? after_cond : linkage;</p>
<p class="Sp-text-1"><a id="c5-para-1435"/>    <b>const</b> p_code = compile(conditional_predicate(component),</p>
<p class="Sp-text-1"><a id="c5-para-1436"/>                           "val", "next");</p>
<p class="Sp-text-1"><a id="c5-para-1437"/>    <b>const</b> c_code = compile(conditional_consequent(component),</p>
<p class="Sp-text-1"><a id="c5-para-1438"/>                           target, consequent_linkage);</p>
<p class="Sp-text-1"><a id="c5-para-1439"/>    <b>const</b> a_code = compile(conditional_alternative(component),</p>
<p class="Sp-text-1"><a id="c5-para-1440"/>                           target, linkage);</p>
<p class="Sp-text-1"><a id="c5-para-1441"/>    <b>return</b> preserving(list("env", "continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1442"/>             p_code,</p>
<p class="Sp-text-1"><a id="c5-para-1443"/>             append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1444"/>               make_instruction_sequence(list("val"), <b>null</b>,</p>
<p class="Sp-text-1"><a id="c5-para-1445"/>                 list(test(list(op("is_falsy"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-1446"/>                      branch(label(f_branch)))),</p>
<p class="Sp-text-1"><a id="c5-para-1447"/>               append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1448"/>                 parallel_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1449"/>                   append_instruction_sequences(t_branch, c_code),</p>
<p class="Sp-text-1"><a id="c5-para-1450"/>                   append_instruction_sequences(f_branch, a_code)),</p>
<p class="Sp-text-1"><a id="c5-para-1451"/>                 after_cond)));</p>
<p class="Sp-text-1"><a id="c5-para-1452"/>}</p>
<p class="paracontinue"><a id="c5-para-1462"/>The <span class="KeyTerm1">env</span> register is preserved around the predicate code because it could be needed by the true and false branches, and <span class="KeyTerm1">continue</span> is preserved because it could be needed by the linkage code in those branches. The code for the true and false branches (which are not executed sequentially) is appended using a special combiner <span class="KeyTerm1">parallel_instruction_sequences</span> described in section 5.5.4.</p>
</section>
<section>
<h5><a id="c5-sec-0089"/><a id="c5-title-0090"/>Compiling sequences</h5>
<p class="paraaftertitle"><a id="c5-para-1463"/>The compilation of statement sequences parallels their evaluation in the explicitcontrol evaluator with one exception: If a return statement appears anywhere in a sequence, we treat it as if it were the last statement. Each statement of the sequence is compiled—the last statement (or a return statement) with the linkage specified for the sequence, and the other statements with linkage <span class="KeyTerm1">"next"</span> (to execute the rest of the sequence). The instruction sequences for the individual statements are appended to form a single instruction sequence, such that <span class="KeyTerm1">env</span> (needed for the rest of the sequence) and <span class="KeyTerm1">continue</span> (possibly needed for the linkage at the end of the sequence) are preserved.<a id="c5-fn-0041a"/><a href="#c5-fn-0041"><sup>41</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-1464"/><b>function</b> compile_sequence(seq, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1465"/>    <b>return</b> is_empty_sequence(seq)</p>
<p class="Sp-text-1"><a id="c5-para-1466"/>           ? compile_literal(make_literal(undefined), target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1467"/>           : is_last_statement(seq) ||</p>
<p class="Sp-text-1"><a id="c5-para-1468"/>                 is_return_statement(first_statement(seq))</p>
<p class="Sp-text-1"><a id="c5-para-1469"/>           ? compile(first_statement(seq), target, linkage)</p>
<p class="Sp-text-1"><a id="c5-para-1470"/>           : preserving(list("env", "continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1471"/>                 compile(first_statement(seq), target, "next"),</p>
<p class="Sp-text-1"><a id="c5-para-1472"/>                 compile_sequence(rest_statements(seq),</p>
<p class="Sp-text-1"><a id="c5-para-1473"/>                                  target, linkage));</p>
<p class="Sp-text-1"><a id="c5-para-1474"/>}</p>
<p class="paracontinue"><a id="c5-para-1475"/>Treating a return statement as if it were the last statement in a sequence avoids compiling any “dead code” after the return statement that can never be executed. Removing the <span class="KeyTerm1">is_return_statement</span> check does not change the behavior of the object program; however, there are many reasons not to compile dead code, which are beyond the scope of this book (security, compilation time, size of the object code, etc.), and many compilers give warnings for dead code.<a id="c5-fn-0042a"/><a href="#c5-fn-0042"><sup>42</sup></a></p>
</section>
<section>
<h5><a id="c5-sec-0090"/><a id="c5-title-0091"/>Compiling blocks</h5>
<p class="paraaftertitle"><a id="c5-para-1476"/>A block is compiled by prepending an <span class="KeyTerm1">assign</span> instruction to the compiled body of the block. The assignment extends the current environment by a frame that binds the names declared in the block to the value <span class="KeyTerm1">"*unassigned*"</span>. This operation both needs and modifies the <span class="KeyTerm1">env</span> register.</p>
<p class="Sp-text-1"><a id="c5-para-1477"/><b>function</b> compile_block(stmt, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1478"/>    <b>const</b> body = block_body(stmt);</p>
<p class="Sp-text-1"><a id="c5-para-1479"/>    <b>const</b> locals = scan_out_declarations(body);</p>
<p class="Sp-text-1"><a id="c5-para-1480"/>    <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c5-para-1481"/>    <b>return</b> append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1482"/>               make_instruction_sequence(list("env"), list("env"),</p>
<p class="Sp-text-1"><a id="c5-para-1483"/>                   list(assign("env", list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c5-para-1484"/>                                           constant(locals),</p>
<p class="Sp-text-1"><a id="c5-para-1485"/>                                           constant(unassigneds),</p>
<p class="Sp-text-1"><a id="c5-para-1486"/>                                           reg("env"))))),</p>
<p class="Sp-text-1"><a id="c5-para-1487"/>               compile(body, target, linkage));</p>
<p class="Sp-text-1"><a id="c5-para-1488"/>}</p>
</section>
<section>
<h5><a id="c5-sec-0091"/><a id="c5-title-0092"/>Compiling lambda expressions</h5>
<p class="paraaftertitle"><a id="c5-para-1489"/>Lambda expressions construct functions. The object code for a lambda expression must have the form</p>
<p class="Sp-text-1"><a id="c5-para-1490"/>〈<span class="KeyTerm2"><i>construct function object and assign it to target register</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1491"/>〈<span class="KeyTerm2"><i>linkage</i></span>〉</p>
<p class="paracontinue"><a id="c5-para-1492"/>When we compile the lambda expression, we also generate the code for the function body. Although the body won't be executed at the time of function construction, it is convenient to insert it into the object code right after the code for the lambda expression. If the linkage for the lambda expression is a label or <span class="KeyTerm1">"return"</span>, this is fine. But if the linkage is <span class="KeyTerm1">"next"</span>, we will need to skip around the code for the function body by using a linkage that jumps to a label that is inserted after the body. The object code thus has the form</p>
<p class="Sp-text-1"><a id="c5-para-1493"/>〈<span class="KeyTerm2"><i>construct function object and assign it to target register</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1494"/>〈<span class="KeyTerm2"><i>code for given linkage</i></span>〉 <span class="KeyTerm2"><i>or</i></span> go_to(label("after_lambda"))</p>
<p class="Sp-text-1"><a id="c5-para-1495"/>〈<span class="KeyTerm2"><i>compilation of function body</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1496"/>"after_lambda"</p>
<p><a id="c5-para-1497"/>The function <span class="KeyTerm1">compile_lambda_expression</span> generates the code for constructing the function object followed by the code for the function body. The function object will be constructed at run time by combining the current environment (the environment at the point of declaration) with the entry point to the compiled function body (a newly generated label).<a id="c5-fn-0043a"/><a href="#c5-fn-0043"><sup>43</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-1511"/><b>function</b> compile_lambda_expression(exp, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1512"/>    <b>const</b> fun_entry = make_label("entry");</p>
<p class="Sp-text-1"><a id="c5-para-1513"/>    <b>const</b> after_lambda = make_label("after_lambda");</p>
<p class="Sp-text-1"><a id="c5-para-1514"/>    <b>const</b> lambda_linkage =</p>
<p class="Sp-text-1"><a id="c5-para-1515"/>            linkage === "next" ? after_lambda : linkage;</p>
<p class="Sp-text-1"><a id="c5-para-1516"/>    <b>return</b> append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1517"/>               tack_on_instruction_sequence(</p>
<p class="Sp-text-1"><a id="c5-para-1518"/>                   end_with_linkage(lambda_linkage,</p>
<p class="Sp-text-1"><a id="c5-para-1519"/>                       make_instruction_sequence(list("env"),</p>
<p class="Sp-text-1"><a id="c5-para-1520"/>                                                 list(target),</p>
<p class="Sp-text-1"><a id="c5-para-1521"/>                           list(assign(target,</p>
<p class="Sp-text-1"><a id="c5-para-1522"/>                                    list(op("make_compiled_function"),</p>
<p class="Sp-text-1"><a id="c5-para-1523"/>                                         label(fun_entry),</p>
<p class="Sp-text-1"><a id="c5-para-1524"/>                                         reg("env")))))),</p>
<p class="Sp-text-1"><a id="c5-para-1525"/>                   compile_lambda_body(exp, fun_entry)),</p>
<p class="Sp-text-1"><a id="c5-para-1526"/>               after_lambda);</p>
<p class="Sp-text-1"><a id="c5-para-1527"/>}</p>
<p class="paracontinue"><a id="c5-para-1528"/>The function <span class="KeyTerm1">compile_lambda_expression</span> uses the special combiner <span class="KeyTerm1">tack_on_ instruction_sequence</span> (from section 5.5.4) rather than <span class="KeyTerm1">append_instruction_ sequences</span> to append the function body to the lambda expression code, because the body is not part of the sequence of instructions that will be executed when the combined sequence is entered; rather, it is in the sequence only because that was a convenient place to put it.</p>
<p><a id="c5-para-1529"/>The function <span class="KeyTerm1">compile_lambda_body</span> constructs the code for the body of the function. This code begins with a label for the entry point. Next come instructions that will cause the runtime evaluation environment to switch to the correct environment for evaluating the function body—namely, the environment of the function, extended to include the bindings of the parameters to the arguments with which the function is called. After this comes the code for the function body, augmented to ensure that it ends with a return statement. The augmented body is compiled with target <span class="KeyTerm1">val</span> so that its return value will be placed in <span class="KeyTerm1">val</span>. The linkage descriptor passed to this compilation is irrelevant, as it will be ignored.<a id="c5-fn-0044a"/><a href="#c5-fn-0044"><sup>44</sup></a> Since a linkage argument is required, we arbitrarily pick <span class="KeyTerm1">"next"</span>.</p>
<p class="Sp-text-1"><a id="c5-para-1530"/><b>function</b> compile_lambda_body(exp, fun_entry) {</p>
<p class="Sp-text-1"><a id="c5-para-1531"/>    <b>const</b> params  = lambda_parameter_symbols(exp);</p>
<p class="Sp-text-1"><a id="c5-para-1532"/>    <b>return</b> append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1533"/>        make_instruction_sequence(list("env", "fun", "argl"),</p>
<p class="Sp-text-1"><a id="c5-para-1534"/>                                  list("env"),</p>
<p class="Sp-text-1"><a id="c5-para-1535"/>            list(fun_entry,</p>
<p class="Sp-text-1"><a id="c5-para-1536"/>                 assign("env",</p>
<p class="Sp-text-1"><a id="c5-para-1537"/>                        list(op("compiled_function_env"),</p>
<p class="Sp-text-1"><a id="c5-para-1538"/>                             reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1539"/>                 assign("env",</p>
<p class="Sp-text-1"><a id="c5-para-1540"/>                        list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c5-para-1541"/>                             constant(params),</p>
<p class="Sp-text-1"><a id="c5-para-1542"/>                             reg("argl"),</p>
<p class="Sp-text-1"><a id="c5-para-1543"/>                             reg("env"))))),</p>
<p class="Sp-text-1"><a id="c5-para-1544"/>        compile(append_return_undefined(lambda_body(exp)),</p>
<p class="Sp-text-1"><a id="c5-para-1545"/>                "val", "next"));</p>
<p class="Sp-text-1"><a id="c5-para-1546"/>}</p>
<p><a id="c5-para-1547"/>To ensure that all functions end by executing a return statement, <span class="KeyTerm1">compile_</span> <span class="KeyTerm1">lambda_body</span> appends to the lambda body a return statement whose return expression is the literal <span class="KeyTerm1">undefined</span>. To do so, it uses the function <span class="KeyTerm1">append_return_ undefined</span>, which constructs the parser's tagged-list representation (from section 4.1.2) of a sequence consisting of the body and a <span class="KeyTerm1"><b>return</b> undefined;</span> statement.</p>
<p class="Sp-text-1"><a id="c5-para-1548"/><b>function</b> append_return_undefined(body) {</p>
<p class="Sp-text-1"><a id="c5-para-1549"/>    <b>return</b> list("sequence", list(body,</p>
<p class="Sp-text-1"><a id="c5-para-1550"/>                                 list("return_statement",</p>
<p class="Sp-text-1"><a id="c5-para-1551"/>                                      list("literal", undefined))));</p>
<p class="Sp-text-1"><a id="c5-para-1552"/>}</p>
<p class="paracontinue"><a id="c5-para-1553"/>This simple transformation of lambda bodies is a third way to ensure that a function that does not return explicitly has the return value <span class="KeyTerm1">undefined</span>. In the metacircular evaluator, we used a return-value object, which also played a role in stopping a sequence evaluation. In the explicit-control evaluator, functions that did not return explicitly continued to an entry point that stored <span class="KeyTerm1">undefined</span> in <span class="KeyTerm1">val</span>. See exercise 5.35 for a more elegant way to handle insertion of return statements.</p>
</section>
<section>
<h5><a id="c5-sec-0092"/><a id="c5-title-0093"/>Exercise 5.34</h5>
<p class="paraaftertitle"><a id="c5-para-1554"/>Footnote 42 pointed out that the compiler does not identify all instances of dead code. What would be required of a compiler to detect all instances of dead code?</p>
<p><a id="c5-para-1555"/>Hint: The answer depends on how we define dead code. One possible (and useful) definition is “code following a return statement in a sequence”—but what about code in the consequent branch of <span class="KeyTerm1"><b>if</b> (<b>false</b>)</span> <span class="KeyTerm1"><i>. . .</i></span> or code following a call to <span class="KeyTerm1">run_forever()</span> in exercise 4.15?</p>
</section>
<section>
<h5><a id="c5-sec-0093"/><a id="c5-title-0094"/>Exercise 5.35</h5>
<p class="paraaftertitle"><a id="c5-para-1556"/>The current design of <span class="KeyTerm1">append_return_undefined</span> is a bit crude: It always appends a <span class="KeyTerm1"><b>return</b> undefined;</span> to a lambda body, even if there is already a return statement in every execution path of the body. Rewrite <span class="KeyTerm1">append_return_undefined</span> so that it inserts <span class="KeyTerm1"><b>return</b> undefined;</span> at the end of only those paths that do not contain a return statement. Test your solution on the functions below, substituting any expressions for <i>e</i><sub>1</sub> and <i>e</i><sub>2</sub> and any (non-return) statements for <i>s</i><sub>1</sub> and <i>s</i><sub>2</sub>. In <span class="KeyTerm1">t</span>, a return statement should be added either at both <span class="KeyTerm1">(*)</span>'s or just at <span class="KeyTerm1">(**)</span>. In <span class="KeyTerm1">w</span> and <span class="KeyTerm1">h</span>, a return statement should be added at one of the <span class="KeyTerm1">(*)</span>'s. In <span class="KeyTerm1">m</span>, no return statement should be added.</p>
<p><a id="c5-para-1557"/></p>
<figure id="c5-fig-0017"><img alt="c5-fig-5001.jpg" src="../images/c5-fig-5001.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
</section>
</section>
<section>
<h3><a id="c5-sec-0094"/><span>5.5.3</span> <a id="c5-title-0095"/>Compiling Applications and Return Statements</h3>
<p class="paraaftertitle"><a id="c5-para-1558"/>The essence of the compilation process is the compilation of function applications. The code for an application compiled with a given target and linkage has the form</p>
<p class="Sp-text-1"><a id="c5-para-1559"/>〈<span class="KeyTerm2"><i>compilation of function expression</i>, <i>target</i></span> fun, <span class="KeyTerm2"><i>linkage</i></span> "next"〉</p>
<p class="Sp-text-1"><a id="c5-para-1560"/>〈<span class="KeyTerm2"><i>evaluate argument expressions and construct argument list in</i></span> argl〉</p>
<p class="Sp-text-1"><a id="c5-para-1561"/>〈<span class="KeyTerm2"><i>compilation of function call with given target and linkage</i></span>〉</p>
<p class="paracontinue"><a id="c5-para-1562"/>The registers <span class="KeyTerm1">env</span>, <span class="KeyTerm1">fun</span>, and <span class="KeyTerm1">argl</span> may have to be saved and restored during evaluation of the function and argument expressions. Note that this is the only place in the compiler where a target other than <span class="KeyTerm1">val</span> is specified.</p>
<p><a id="c5-para-1563"/>The required code is generated by <span class="KeyTerm1">compile_application</span>. This recursively compiles the function expression, to produce code that puts the function to be applied into <span class="KeyTerm1">fun</span>, and compiles the argument expressions, to produce code that evaluates the individual argument expressions of the application. The instruction sequences for the argument expressions are combined (by <span class="KeyTerm1">construct_arglist</span>) with code that constructs the list of arguments in <span class="KeyTerm1">argl</span>, and the resulting argumentlist code is combined with the function code and the code that performs the function call (produced by <span class="KeyTerm1">compile_function_call</span>). In appending the code sequences, the <span class="KeyTerm1">env</span> register must be preserved around the evaluation of the function expression (since evaluating the function expression might modify <span class="KeyTerm1">env</span>, which will be needed to evaluate the argument expressions), and the <span class="KeyTerm1">fun</span> register must be preserved around the construction of the argument list (since evaluating the argument expressions might modify <span class="KeyTerm1">fun</span>, which will be needed for the actual function application). The <span class="KeyTerm1">continue</span> register must also be preserved throughout, since it is needed for the linkage in the function call.</p>
<p class="Sp-text-1"><a id="c5-para-1564"/><b>function</b> compile_application(exp, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1565"/>    <b>const</b> fun_code = compile(function_expression(exp), "fun", "next");</p>
<p class="Sp-text-1"><a id="c5-para-1566"/>    <b>const</b> argument_codes = map(arg =&gt; compile(arg, "val", "next"),</p>
<p class="Sp-text-1"><a id="c5-para-1567"/>                               arg_expressions(exp));</p>
<p class="Sp-text-1"><a id="c5-para-1568"/>    <b>return</b> preserving(list("env", "continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1569"/>                      fun_code,</p>
<p class="Sp-text-1"><a id="c5-para-1570"/>                      preserving(list("fun", "continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1571"/>                          construct_arglist(argument_codes),</p>
<p class="Sp-text-1"><a id="c5-para-1572"/>                          compile_function_call(target, linkage)));</p>
<p class="Sp-text-1"><a id="c5-para-1573"/>}</p>
<p><a id="c5-para-1574"/>The code to construct the argument list will evaluate each argument expression into <span class="KeyTerm1">val</span> and then combine that value with the argument list being accumulated in <span class="KeyTerm1">argl</span> using <span class="KeyTerm1">pair</span>. Since we adjoin the arguments to the front of <span class="KeyTerm1">argl</span> in sequence, we must start with the last argument and end with the first, so that the arguments will appear in order from first to last in the resulting list. Rather than waste an instruction by initializing <span class="KeyTerm1">argl</span> to the empty list to set up for this sequence of evaluations, we make the first code sequence construct the initial <span class="KeyTerm1">argl</span>. The general form of the argument-list construction is thus as follows:</p>
<p class="Sp-text-1"><a id="c5-para-1575"/>〈<span class="KeyTerm2"><i>compilation of last argument</i>, <i>targeted to</i></span> val〉</p>
<p class="Sp-text-1"><a id="c5-para-1576"/>〈assign("argl", list(op("list"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-1577"/>〈<span class="KeyTerm2"><i>compilation of next argument</i>, <i>targeted to</i></span> val〉</p>
<p class="Sp-text-1"><a id="c5-para-1578"/>〈assign("argl", list(op("pair"), reg("val"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c5-para-1579"/><i>. . .</i></p>
<p class="Sp-text-1"><a id="c5-para-1580"/>〈<span class="KeyTerm2"><i>compilation of first argument</i>, <i>targeted to</i></span> val〉</p>
<p class="Sp-text-1"><a id="c5-para-1581"/>assign("argl", list(op("pair"), reg("val"), reg("argl"))),</p>
<p class="paracontinue"><a id="c5-para-1582"/>The <span class="KeyTerm1">argl</span> register must be preserved around each argument evaluation except the first (so that arguments accumulated so far won't be lost), and <span class="KeyTerm1">env</span> must be preserved around each argument evaluation except the last (for use by subsequent argument evaluations).</p>
<p><a id="c5-para-1583"/>Compiling this argument code is a bit tricky, because of the special treatment of the first argument expression to be evaluated and the need to preserve <span class="KeyTerm1">argl</span> and <span class="KeyTerm1">env</span> in different places. The <span class="KeyTerm1">construct_arglist</span> function takes as arguments the code that evaluates the individual argument expressions. If there are no argument expressions at all, it simply emits the instruction</p>
<p class="Sp-text-1"><a id="c5-para-1584"/>assign(argl, constant(<b>null</b>))</p>
<p class="paracontinue"><a id="c5-para-1585"/>Otherwise, <span class="KeyTerm1">construct_arglist</span> creates code that initializes <span class="KeyTerm1">argl</span> with the last argument, and appends code that evaluates the rest of the arguments and adjoins them to <span class="KeyTerm1">argl</span> in succession. In order to process the arguments from last to first, we must reverse the list of argument code sequences from the order supplied by <span class="KeyTerm1">compile_application</span>.</p>
<p class="Sp-text-1"><a id="c5-para-1586"/><b>function</b> construct_arglist(arg_codes) {</p>
<p class="Sp-text-1"><a id="c5-para-1587"/>    <b>if</b> (is_null(arg_codes)) {</p>
<p class="Sp-text-1"><a id="c5-para-1588"/>        <b>return</b> make_instruction_sequence(<b>null</b>, list("argl"),</p>
<p class="Sp-text-1"><a id="c5-para-1589"/>                   list(assign("argl", constant(<b>null</b>))));</p>
<p class="Sp-text-1"><a id="c5-para-1590"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c5-para-1591"/>        <b>const</b> rev_arg_codes = reverse(arg_codes);</p>
<p class="Sp-text-1"><a id="c5-para-1592"/>        <b>const</b> code_to_get_last_arg =</p>
<p class="Sp-text-1"><a id="c5-para-1593"/>            append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1594"/>                head(rev_arg_codes),</p>
<p class="Sp-text-1"><a id="c5-para-1595"/>                make_instruction_sequence(list("val"), list("argl"),</p>
<p class="Sp-text-1"><a id="c5-para-1596"/>                    list(assign("argl",</p>
<p class="Sp-text-1"><a id="c5-para-1597"/>                                list(op("list"), reg("val"))))));</p>
<p class="Sp-text-1"><a id="c5-para-1598"/>        <b>return</b> is_null(tail(rev_arg_codes))</p>
<p class="Sp-text-1"><a id="c5-para-1599"/>               ? code_to_get_last_arg</p>
<p class="Sp-text-1"><a id="c5-para-1600"/>               : preserving(list("env"),</p>
<p class="Sp-text-1"><a id="c5-para-1601"/>                     code_to_get_last_arg,</p>
<p class="Sp-text-1"><a id="c5-para-1602"/>                     code_to_get_rest_args(tail(rev_arg_codes)));</p>
<p class="Sp-text-1"><a id="c5-para-1603"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-1604"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1605"/><b>function</b> code_to_get_rest_args(arg_codes) {</p>
<p class="Sp-text-1"><a id="c5-para-1606"/>    <b>const</b> code_for_next_arg =</p>
<p class="Sp-text-1"><a id="c5-para-1607"/>        preserving(list("argl"),</p>
<p class="Sp-text-1"><a id="c5-para-1608"/>            head(arg_codes),</p>
<p class="Sp-text-1"><a id="c5-para-1609"/>            make_instruction_sequence(list("val", "argl"), list("argl"),</p>
<p class="Sp-text-1"><a id="c5-para-1610"/>                list(assign("argl", list(op("pair"),</p>
<p class="Sp-text-1"><a id="c5-para-1611"/>                                         reg("val"), reg("argl"))))));</p>
<p class="Sp-text-1"><a id="c5-para-1612"/>    <b>return</b> is_null(tail(arg_codes))</p>
<p class="Sp-text-1"><a id="c5-para-1613"/>           ? code_for_next_arg</p>
<p class="Sp-text-1"><a id="c5-para-1614"/>           : preserving(list("env"),</p>
<p class="Sp-text-1"><a id="c5-para-1615"/>                        code_for_next_arg,</p>
<p class="Sp-text-1"><a id="c5-para-1616"/>                        code_to_get_rest_args(tail(arg_codes)));</p>
<p class="Sp-text-1"><a id="c5-para-1617"/>}</p>
<section>
<h5><a id="c5-sec-0095"/><a id="c5-title-0096"/>Applying functions</h5>
<p class="paraaftertitle"><a id="c5-para-1618"/>After evaluating the elements of a function application, the compiled code must apply the function in <span class="KeyTerm1">fun</span> to the arguments in <span class="KeyTerm1">argl</span>. The code performs essentially the same dispatch as the <span class="KeyTerm1">apply</span> function in the metacircular evaluator of section 4.1.1 or the <span class="KeyTerm1">apply_dispatch</span> entry point in the explicit-control evaluator of section 5.4.2. It checks whether the function to be applied is a primitive function or a compiled function. For a primitive function, it uses <span class="KeyTerm1">apply_primitive_function</span>; we will see shortly how it handles compiled functions. The function-application code has the following form:</p>
<p class="Sp-text-1"><a id="c5-para-1619"/>  test(list(op("primitive_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1620"/>  branch(label("primitive_branch")),</p>
<p class="Sp-text-1"><a id="c5-para-1621"/>"compiled_branch",</p>
<p class="Sp-text-1"><a id="c5-para-1622"/> 〈<span class="KeyTerm2"><i>code to apply compiled function with given target and appropriate linkage</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1623"/>"primitive_branch",</p>
<p class="Sp-text-1"><a id="c5-para-1624"/>  assign(<i>target</i>,</p>
<p class="Sp-text-1"><a id="c5-para-1625"/>         list(op("apply_primitive_function"), reg("fun"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c5-para-1626"/> 〈<span class="KeyTerm2"><i>linkage</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1627"/>"after_call"</p>
<p class="paracontinue"><a id="c5-para-1628"/>Observe that the compiled branch must skip around the primitive branch. Therefore, if the linkage for the original function call was <span class="KeyTerm1">"next"</span>, the compound branch must use a linkage that jumps to a label that is inserted after the primitive branch. (This is similar to the linkage used for the true branch in <span class="KeyTerm1">compile_conditional</span>.)</p>
<p class="Sp-text-1"><a id="c5-para-1629"/><b>function</b> compile_function_call(target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1630"/>    <b>const</b> primitive_branch = make_label("primitive_branch");</p>
<p class="Sp-text-1"><a id="c5-para-1631"/>    <b>const</b> compiled_branch = make_label("compiled_branch");</p>
<p class="Sp-text-1"><a id="c5-para-1632"/>    <b>const</b> after_call = make_label("after_call");</p>
<p class="Sp-text-1"><a id="c5-para-1633"/>    <b>const</b> compiled_linkage = linkage === "next" ? after_call : linkage;</p>
<p class="Sp-text-1"><a id="c5-para-1634"/>    <b>return</b> append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1635"/>        make_instruction_sequence(list("fun"), <b>null</b>,</p>
<p class="Sp-text-1"><a id="c5-para-1636"/>            list(test(list(op("is_primitive_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1637"/>                 branch(label(primitive_branch)))),</p>
<p class="Sp-text-1"><a id="c5-para-1638"/>            append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1639"/>                parallel_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1640"/>                    append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1641"/>                        compiled_branch,</p>
<p class="Sp-text-1"><a id="c5-para-1642"/>                        compile_fun_appl(target, compiled_linkage)),</p>
<p class="Sp-text-1"><a id="c5-para-1643"/>                    append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1644"/>                        primitive_branch,</p>
<p class="Sp-text-1"><a id="c5-para-1645"/>                        end_with_linkage(linkage,</p>
<p class="Sp-text-1"><a id="c5-para-1646"/>                            make_instruction_sequence(list("fun", "argl"),</p>
<p class="Sp-text-1"><a id="c5-para-1647"/>                                                      list(target),</p>
<p class="Sp-text-1"><a id="c5-para-1648"/>                                list(assign(</p>
<p class="Sp-text-1"><a id="c5-para-1649"/>                                       target,</p>
<p class="Sp-text-1"><a id="c5-para-1650"/>                                       list(op("apply_primitive_function"),</p>
<p class="Sp-text-1"><a id="c5-para-1651"/>                                            reg("fun"), reg("argl")))))))),</p>
<p class="Sp-text-1"><a id="c5-para-1652"/>            after_call));</p>
<p class="Sp-text-1"><a id="c5-para-1653"/>}</p>
<p class="paracontinue"><a id="c5-para-1654"/>The primitive and compound branches, like the true and false branches in <span class="KeyTerm1">compile_ conditional</span>, are appended using <span class="KeyTerm1">parallel_instruction_sequences</span> rather than the ordinary <span class="KeyTerm1">append_instruction_sequences</span>, because they will not be executed sequentially.</p>
</section>
<section>
<h5><a id="c5-sec-0096"/><a id="c5-title-0097"/>Applying compiled functions</h5>
<p class="paraaftertitle"><a id="c5-para-1655"/>The handling of function application and return is the most subtle part of the compiler. A compiled function (as constructed by <span class="KeyTerm1">compile_lambda_expression</span>) has an entry point, which is a label that designates where the code for the function starts. The code at this entry point computes a result in <span class="KeyTerm1">val</span> and ends by executing the instructions from a compiled return statement.</p>
<p><a id="c5-para-1656"/>The code for a compiled-function application uses the stack in the same way as the explicit-control evaluator (section 5.4.2): before jumping to the compiled function's entry point, it saves the continuation of the function call to the stack, followed by a mark that allows reverting the stack to the state right before the call with the continuation on top.</p>
<p class="Sp-text-1"><a id="c5-para-1657"/>  <i>//</i> <span class="KeyTerm2"><i>set up for return from function</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1658"/>  save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1659"/>  push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c5-para-1660"/>  <i>//</i> <span class="KeyTerm2"><i>jump to the function's entry point</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1661"/>  assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1662"/>  go_to(reg("val")),</p>
<p class="paracontinue"><a id="c5-para-1663"/>Compiling a return statement (with <span class="KeyTerm1">compile_return_statement</span>) generates corresponding code for reverting the stack and restoring and jumping to <span class="KeyTerm1">continue</span>.</p>
<p class="Sp-text-1"><a id="c5-para-1664"/>  revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c5-para-1665"/>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1666"/>  〈<span class="KeyTerm2"><i>evaluate the return expression and store the result in</i></span> val〉</p>
<p class="Sp-text-1"><a id="c5-para-1667"/>  go_to(reg("continue")), <i>//</i> "return"<i>-</i><span class="KeyTerm2"><i>linkage code</i></span></p>
<p class="paracontinue"><a id="c5-para-1668"/>Unless a function enters an infinite loop, it will end by executing the above return code, resulting from either a return statement in the program or one inserted by <span class="KeyTerm1">compile_lambda_body</span> to return <span class="KeyTerm1">undefined</span>.<a id="c5-fn-0045a"/><a href="#c5-fn-0045"><sup>45</sup></a></p>
<p><a id="c5-para-1669"/>Straightforward code for a compiled-function application with a given target and linkage would set up <span class="KeyTerm1">continue</span> to make the function return to a local label instead of to the final linkage, to copy the function value from <span class="KeyTerm1">val</span> to the target register if necessary. It would look like this if the linkage is a label:</p>
<p class="Sp-text-1"><a id="c5-para-1670"/>  assign("continue", label("fun_return")), <i>//</i> <span class="KeyTerm2"><i>where function should return to</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1671"/>  save("continue"),       <i>//</i> <span class="KeyTerm2"><i>will be restored by the function</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1672"/>  push_marker_to_stack(), <i>//</i> <span class="KeyTerm2"><i>allows the function to revert stack to find</i></span> fun_return</p>
<p class="Sp-text-1"><a id="c5-para-1673"/>  assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1674"/>  go_to(reg("val")),    <i>//</i> <span class="KeyTerm2"><i>eventually reverts stack, restores and jumps to</i></span> continue</p>
<p class="Sp-text-1"><a id="c5-para-1675"/>"fun_return",             <i>//</i> <span class="KeyTerm2"><i>the function returns to here</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1676"/>  assign(<span class="KeyTerm2"><i>target</i></span>, reg("val")), <i>//</i> <span class="KeyTerm2"><i>included if target is not</i></span> val</p>
<p class="Sp-text-1"><a id="c5-para-1677"/>  go_to(label(<span class="KeyTerm2"><i>linkage</i></span>)),   <i>//</i> <span class="KeyTerm2"><i>linkage code</i></span></p>
<p class="paracontinue"><a id="c5-para-1678"/>or like this—saving the caller's continuation at the start in order to restore and go to it at the end—if the linkage is <span class="KeyTerm1">"return"</span> (that is, if the application is in a return statement and its value is the result to be returned):</p>
<p class="Sp-text-1"><a id="c5-para-1679"/>  save("continue"), <i>//</i> <span class="KeyTerm2"><i>save the caller's continuation</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1680"/>  assign("continue", label("fun_return")), <i>//</i> <span class="KeyTerm2"><i>where function should return to</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1681"/>  save("continue"), <i>//</i> <span class="KeyTerm2"><i>will be restored by the function</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1682"/>push_marker_to_stack(), <i>//</i> <span class="KeyTerm2"><i>allows the function to revert stack to find</i></span> fun_return</p>
<p class="Sp-text-1"><a id="c5-para-1683"/>  assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1684"/>  go_to(reg("val")), <i>//</i> <span class="KeyTerm2"><i>eventually reverts stack, restores and jumps to</i></span> continue</p>
<p class="Sp-text-1"><a id="c5-para-1685"/>"fun_return", <i>//</i> <span class="KeyTerm2"><i>the function returns to here</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1686"/>  assign(<span class="KeyTerm2"><i>target</i></span>, reg("val")), <i>//</i> <span class="KeyTerm2"><i>included if target is not</i></span> val</p>
<p class="Sp-text-1"><a id="c5-para-1687"/>  restore("continue"), <i>//</i> <span class="KeyTerm2"><i>restore the caller's continuation</i></span></p>
<p class="Sp-text-1"><a id="c5-para-1688"/>  go_to(reg("continue")), <i>//</i> <span class="KeyTerm2"><i>linkage code</i></span></p>
<p class="paracontinue"><a id="c5-para-1689"/>This code sets up <span class="KeyTerm1">continue</span> so that the function will return to a label <span class="KeyTerm1">fun_return</span> and jumps to the function's entry point. The code at <span class="KeyTerm1">fun_return</span> transfers the function's result from <span class="KeyTerm1">val</span> to the target register (if necessary) and then jumps to the location specified by the linkage. (The linkage is always <span class="KeyTerm1">"return"</span> or a label, because <span class="KeyTerm1">compile_function_call</span> replaces a <span class="KeyTerm1">"next"</span> linkage for the compound-function branch by an <span class="KeyTerm1">after_call</span> label.) Before jumping to the function's entry point, we save <span class="KeyTerm1">continue</span> and execute <span class="KeyTerm1">push_marker_to_stack()</span> to enable the function to return to the intended location in the program with the expected stack. Matching <span class="KeyTerm1">revert_stack_to_marker()</span> and <span class="KeyTerm1">restore("continue")</span> instructions are generated by <span class="KeyTerm1">compile_return_statement</span> for each return statement in the body of the function.<a id="c5-fn-0046a"/><a href="#c5-fn-0046"><sup>46</sup></a></p>
<p><a id="c5-para-1690"/>In fact, if the target is not <span class="KeyTerm1">val</span>, the above is exactly the code our compiler will generate.<a id="c5-fn-0047a"/><a href="#c5-fn-0047"><sup>47</sup></a> Usually, however, the target is <span class="KeyTerm1">val</span> (the only time the compiler specifies a different register is when targeting the evaluation of a function expression to <span class="KeyTerm1">fun</span>), so the function result is put directly into the target register and there is no need to jump to a special location that copies it. Instead we simplify the code by setting up <span class="KeyTerm1">continue</span> so that the called function will “return” directly to the place specified by the caller's linkage:</p>
<p class="Sp-text-1"><a id="c5-para-1691"/>〈<span class="KeyTerm2"><i>set up continue for linkage and push the marker</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1692"/>assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1693"/>go_to(reg("val")),</p>
<p class="paracontinue"><a id="c5-para-1694"/>If the linkage is a label, we set up <span class="KeyTerm1">continue</span> so that the function will continue at that label. (That is, the <span class="KeyTerm1">go_to(reg("continue"))</span> the called function ends with becomes equivalent to the <span class="KeyTerm1">go_to(label(</span><i>linkage</i><span class="KeyTerm1">))</span> at <span class="KeyTerm1">fun_return</span> above.)</p>
<p class="Sp-text-1"><a id="c5-para-1695"/>assign("continue", label(<span class="KeyTerm2"><i>linkage</i></span>)),</p>
<p class="Sp-text-1"><a id="c5-para-1696"/>save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1697"/>push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c5-para-1698"/>assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1699"/>go_to(reg("val")),</p>
<p class="paracontinue"><a id="c5-para-1700"/>If the linkage is <span class="KeyTerm1">"return"</span>, we don't need to assign <span class="KeyTerm1">continue</span>: It already holds the desired location. (That is, the <span class="KeyTerm1">go_to(reg("continue"))</span> the called function ends with goes directly to the place where the <span class="KeyTerm1">go_to(reg("continue"))</span> at <span class="KeyTerm1">fun_ return</span> would have gone.)</p>
<p class="Sp-text-1"><a id="c5-para-1701"/>save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1702"/>push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c5-para-1703"/>assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1704"/>go_to(reg("val")),</p>
<p class="paracontinue"><a id="c5-para-1705"/>With this implementation of the <span class="KeyTerm1">"return"</span> linkage, the compiler generates tailrecursive code. A function call in a return statement whose value is the result to be returned does a direct transfer, without saving unnecessary information on the stack.</p>
<p><a id="c5-para-1706"/>Suppose instead that we had handled the case of a function call with a linkage of <span class="KeyTerm1">"return"</span> and a target of <span class="KeyTerm1">val</span> in the same way as for a non-<span class="KeyTerm1">val</span> target. This would destroy tail recursion. Our system would still return the same value for any function call. But each time we called a function, we would save <span class="KeyTerm1">continue</span> and return after the call to undo the (useless) save. These extra saves would accumulate during a nest of function calls.<a id="c5-fn-0048a"/><a href="#c5-fn-0048"><sup>48</sup></a></p>
<p><a id="c5-para-1707"/>The function <span class="KeyTerm1">compile_fun_appl</span> generates the above function-application code by considering four cases, depending on whether the target for the call is <span class="KeyTerm1">val</span> and whether the linkage is <span class="KeyTerm1">"return"</span>. Observe that the instruction sequences are declared to modify all the registers, since executing the function body can change the registers in arbitrary ways.<a id="c5-fn-0049a"/><a href="#c5-fn-0049"><sup>49</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-1708"/><b>function</b> compile_fun_appl(target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1709"/>    <b>const</b> fun_return = make_label("fun_return");</p>
<p class="Sp-text-1"><a id="c5-para-1710"/>    <b>return</b> target === "val" &amp;&amp; linkage !== "return"</p>
<p class="Sp-text-1"><a id="c5-para-1711"/>           ? make_instruction_sequence(list("fun"), all_regs,</p>
<p class="Sp-text-1"><a id="c5-para-1712"/>                 list(assign("continue", label(linkage)),</p>
<p class="Sp-text-1"><a id="c5-para-1713"/>                      save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1714"/>                      push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c5-para-1715"/>                      assign("val", list(op("compiled_function_entry"),</p>
<p class="Sp-text-1"><a id="c5-para-1716"/>                                         reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1717"/>                      go_to(reg("val"))))</p>
<p class="Sp-text-1"><a id="c5-para-1718"/>           : target !== "val" &amp;&amp; linkage !== "return"</p>
<p class="Sp-text-1"><a id="c5-para-1719"/>           ? make_instruction_sequence(list("fun"), all_regs,</p>
<p class="Sp-text-1"><a id="c5-para-1720"/>                 list(assign("continue", label(fun_return)),</p>
<p class="Sp-text-1"><a id="c5-para-1721"/>                      save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1722"/>                      push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c5-para-1723"/>                      assign("val", list(op("compiled_function_entry"),</p>
<p class="Sp-text-1"><a id="c5-para-1724"/>                                         reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1725"/>                      go_to(reg("val")),</p>
<p class="Sp-text-1"><a id="c5-para-1726"/>                      fun_return,</p>
<p class="Sp-text-1"><a id="c5-para-1727"/>                      assign(target, reg("val")),</p>
<p class="Sp-text-1"><a id="c5-para-1728"/>                      go_to(label(linkage))))</p>
<p class="Sp-text-1"><a id="c5-para-1729"/>           : target === "val" &amp;&amp; linkage === "return"</p>
<p class="Sp-text-1"><a id="c5-para-1730"/>           ? make_instruction_sequence(list("fun", "continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1731"/>                                       all_regs,</p>
<p class="Sp-text-1"><a id="c5-para-1732"/>                 list(save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1733"/>                      push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c5-para-1734"/>                      assign("val", list(op("compiled_function_entry"),</p>
<p class="Sp-text-1"><a id="c5-para-1735"/>                                         reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1736"/>                      go_to(reg("val"))))</p>
<p class="Sp-text-1"><a id="c5-para-1737"/>           : <i>//</i> target !== "val" &amp;&amp; linkage === "return"</p>
<p class="Sp-text-1"><a id="c5-para-1738"/>             error(target, "return linkage, target not val – compile");</p>
<p class="Sp-text-1"><a id="c5-para-1739"/>}</p>
<p><a id="c5-para-1740"/>We have shown how to generate tail-recursive linkage code for a function application when the linkage is <span class="KeyTerm1">"return"</span>—that is, when the application is in a return statement and its value is the result to be returned. Similarly, as explained in section 5.4.2, the stack-marker mechanism used here (and in the explicit-control evaluator) for the call and return produces tail-recursive behavior only in that situation. These two aspects of the code generated for function application combine to ensure that when a function ends by returning the value of a function call, no stack accumulates.</p>
</section>
<section>
<h5><a id="c5-sec-0097"/><a id="c5-title-0098"/>Compiling return statements</h5>
<p class="paraaftertitle"><a id="c5-para-1742"/>The code for a return statement takes the following form, regardless of the given linkage and target:</p>
<p class="Sp-text-1"><a id="c5-para-1743"/>revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c5-para-1744"/>restore("continue"),   <i>//</i> <span class="KeyTerm2"><i>saved by</i></span> compile_fun_appl</p>
<p class="Sp-text-1"><a id="c5-para-1745"/>〈<span class="KeyTerm2"><i>evaluate the return expression and store the result in</i></span> val〉</p>
<p class="Sp-text-1"><a id="c5-para-1746"/>go_to(reg("continue")) <i>//</i> "return"<i>-</i><span class="KeyTerm2"><i>linkage code</i></span></p>
<p class="paracontinue"><a id="c5-para-1747"/>The instructions to revert the stack using the marker and then restore <span class="KeyTerm1">continue</span> correspond to the instructions generated by <span class="KeyTerm1">compile_fun_appl</span> to save <span class="KeyTerm1">continue</span> and mark the stack. The final jump to <span class="KeyTerm1">continue</span> is generated by the use of the <span class="KeyTerm1">"return"</span> linkage when compiling the return expression. The function <span class="KeyTerm1">compile_ return_statement</span> is different from all other code generators in that it ignores the target and linkage arguments—it always compiles the return expression with target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"return"</span>.</p>
<p class="Sp-text-1"><a id="c5-para-1748"/><b>function</b> compile_return_statement(stmt, target, linkage) {</p>
<p class="Sp-text-1"><a id="c5-para-1749"/>    <b>return</b> append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c5-para-1750"/>               make_instruction_sequence(<b>null</b>, list("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1751"/>                   list(revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c5-para-1752"/>                        restore("continue"))),</p>
<p class="Sp-text-1"><a id="c5-para-1753"/>               compile(return_expression(stmt), "val", "return"));</p>
<p class="Sp-text-1"><a id="c5-para-1754"/>}</p>
</section>
</section>
<section>
<h3><a id="c5-sec-0098"/><span>5.5.4</span> <a id="c5-title-0099"/>Combining Instruction Sequences</h3>
<p class="paraaftertitle"><a id="c5-para-1755"/>This section describes the details on how instruction sequences are represented and combined. Recall from section 5.5.1 that an instruction sequence is represented as a list of the registers needed, the registers modified, and the actual instructions. We will also consider a label (string) to be a degenerate case of an instruction sequence, which doesn't need or modify any registers. So to determine the registers needed and modified by instruction sequences we use the selectors</p>
<p class="Sp-text-1"><a id="c5-para-1756"/><b>function</b> registers_needed(s) {</p>
<p class="Sp-text-1"><a id="c5-para-1757"/>    <b>return</b> is_string(s) ? <b>null</b> : head(s);</p>
<p class="Sp-text-1"><a id="c5-para-1758"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1759"/><b>function</b> registers_modified(s) {</p>
<p class="Sp-text-1"><a id="c5-para-1760"/>    <b>return</b> is_string(s) ? <b>null</b> : head(tail(s));</p>
<p class="Sp-text-1"><a id="c5-para-1761"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1762"/><b>function</b> instructions(s) {</p>
<p class="Sp-text-1"><a id="c5-para-1763"/>    <b>return</b> is_string(s) ? list(s) : head(tail(tail(s)));</p>
<p class="Sp-text-1"><a id="c5-para-1764"/>}</p>
<p class="paracontinue"><a id="c5-para-1765"/>and to determine whether a given sequence needs or modifies a given register we use the predicates</p>
<p class="Sp-text-1"><a id="c5-para-1766"/><b>function</b> needs_register(seq, reg) {</p>
<p class="Sp-text-1"><a id="c5-para-1767"/>    <b>return</b> ! is_null(member(reg, registers_needed(seq)));</p>
<p class="Sp-text-1"><a id="c5-para-1768"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1769"/><b>function</b> modifies_register(seq, reg) {</p>
<p class="Sp-text-1"><a id="c5-para-1770"/>    <b>return</b> ! is_null(member(reg, registers_modified(seq)));</p>
<p class="Sp-text-1"><a id="c5-para-1771"/>}</p>
<p class="paracontinue"><a id="c5-para-1772"/>In terms of these predicates and selectors, we can implement the various instruction sequence combiners used throughout the compiler.</p>
<p><a id="c5-para-1773"/>The basic combiner is <span class="KeyTerm1">append_instruction_sequences</span>. This takes as arguments two instruction sequences that are to be executed sequentially and returns an instruction sequence whose statements are the statements of the two sequences appended together. The subtle point is to determine the registers that are needed and modified by the resulting sequence. It modifies those registers that are modified by either sequence; it needs those registers that must be initialized before the first sequence can be run (the registers needed by the first sequence), together with those registers needed by the second sequence that are not initialized (modified) by the first sequence.</p>
<p><a id="c5-para-1774"/>The function <span class="KeyTerm1">append_instruction_sequences</span> is given two instruction sequences <span class="KeyTerm1">seq1</span> and <span class="KeyTerm1">seq2</span> and returns the instruction sequence whose instructions are the instructions of <span class="KeyTerm1">seq1</span> followed by the instructions of <span class="KeyTerm1">seq2</span>, whose modified registers are those registers that are modified by either <span class="KeyTerm1">seq1</span> or <span class="KeyTerm1">seq2</span>, and whose needed registers are the registers needed by <span class="KeyTerm1">seq1</span> together with those registers needed by <span class="KeyTerm1">seq2</span> that are not modified by <span class="KeyTerm1">seq1</span>. (In terms of set operations, the new set of needed registers is the union of the set of registers needed by <span class="KeyTerm1">seq1</span> with the set difference of the registers needed by <span class="KeyTerm1">seq2</span> and the registers modified by <span class="KeyTerm1">seq1</span>.) Thus, <span class="KeyTerm1">append_instruction_sequences</span> is implemented as follows:</p>
<p class="Sp-text-1"><a id="c5-para-1775"/><b>function</b> append_instruction_sequences(seq1, seq2) {</p>
<p class="Sp-text-1"><a id="c5-para-1776"/>    <b>return</b> make_instruction_sequence(</p>
<p class="Sp-text-1"><a id="c5-para-1777"/>               list_union(registers_needed(seq1),</p>
<p class="Sp-text-1"><a id="c5-para-1778"/>                          list_difference(registers_needed(seq2),</p>
<p class="Sp-text-1"><a id="c5-para-1779"/>                                         registers_modified(seq1))),</p>
<p class="Sp-text-1"><a id="c5-para-1780"/>               list_union(registers_modified(seq1),</p>
<p class="Sp-text-1"><a id="c5-para-1781"/>                          registers_modified(seq2)),</p>
<p class="Sp-text-1"><a id="c5-para-1782"/>               append(instructions(seq1), instructions(seq2)));</p>
<p class="Sp-text-1"><a id="c5-para-1783"/>}</p>
<p><a id="c5-para-1784"/>This function uses some simple operations for manipulating sets represented as lists, similar to the (unordered) set representation described in section 2.3.3:</p>
<p class="Sp-text-1"><a id="c5-para-1785"/><b>function</b> list_union(s1, s2) {</p>
<p class="Sp-text-1"><a id="c5-para-1786"/>    <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c5-para-1787"/>           ? s2</p>
<p class="Sp-text-1"><a id="c5-para-1788"/>           : is_null(member(head(s1), s2))</p>
<p class="Sp-text-1"><a id="c5-para-1789"/>           ? pair(head(s1), list_union(tail(s1), s2))</p>
<p class="Sp-text-1"><a id="c5-para-1790"/>           : list_union(tail(s1), s2);</p>
<p class="Sp-text-1"><a id="c5-para-1791"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1792"/><b>function</b> list_difference(s1, s2) {</p>
<p class="Sp-text-1"><a id="c5-para-1793"/>    <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c5-para-1794"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c5-para-1795"/>           : is_null(member(head(s1), s2))</p>
<p class="Sp-text-1"><a id="c5-para-1796"/>           ? pair(head(s1), list_difference(tail(s1), s2))</p>
<p class="Sp-text-1"><a id="c5-para-1797"/>           : list_difference(tail(s1), s2);</p>
<p class="Sp-text-1"><a id="c5-para-1798"/>}</p>
<p><a id="c5-para-1799"/>The function <span class="KeyTerm1">preserving</span>, the second major instruction sequence combiner, takes a list of registers <span class="KeyTerm1">regs</span> and two instruction sequences <span class="KeyTerm1">seq1</span> and <span class="KeyTerm1">seq2</span> that are to be executed sequentially. It returns an instruction sequence whose instructions are the instructions of <span class="KeyTerm1">seq1</span> followed by the instructions of <span class="KeyTerm1">seq2</span>, with appropriate <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> instructions around <span class="KeyTerm1">seq1</span> to protect the registers in <span class="KeyTerm1">regs</span> that are modified by <span class="KeyTerm1">seq1</span> but needed by <span class="KeyTerm1">seq2</span>. To accomplish this, <span class="KeyTerm1">preserving</span> first creates a sequence that has the required <span class="KeyTerm1">save</span>s followed by the instructions of <span class="KeyTerm1">seq1</span> followed by the required <span class="KeyTerm1">restore</span>s. This sequence needs the registers being saved and restored in addition to the registers needed by <span class="KeyTerm1">seq1</span>, and modifies the registers modified by <span class="KeyTerm1">seq1</span> except for the ones being saved and restored. This augmented sequence and <span class="KeyTerm1">seq2</span> are then appended in the usual way. The following function implements this strategy recursively, walking down the list of registers to be preserved:</p>
<p class="Sp-text-1"><a id="c5-para-1800"/><b>function</b> preserving(regs, seq1, seq2) {</p>
<p class="Sp-text-1"><a id="c5-para-1801"/>    <b>if</b> (is_null(regs)) {</p>
<p class="Sp-text-1"><a id="c5-para-1802"/>        <b>return</b> append_instruction_sequences(seq1, seq2);</p>
<p class="Sp-text-1"><a id="c5-para-1803"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c5-para-1804"/>        <b>const</b> first_reg = head(regs);</p>
<p class="Sp-text-1"><a id="c5-para-1805"/>        <b>return</b> needs_register(seq2, first_reg) &amp;&amp;</p>
<p class="Sp-text-1"><a id="c5-para-1806"/>               modifies_register(seq1, first_reg)</p>
<p class="Sp-text-1"><a id="c5-para-1807"/>               ? preserving(tail(regs),</p>
<p class="Sp-text-1"><a id="c5-para-1808"/>                     make_instruction_sequence(</p>
<p class="Sp-text-1"><a id="c5-para-1809"/>                         list_union(list(first_reg),</p>
<p class="Sp-text-1"><a id="c5-para-1810"/>                                    registers_needed(seq1)),</p>
<p class="Sp-text-1"><a id="c5-para-1811"/>                         list_difference(registers_modified(seq1),</p>
<p class="Sp-text-1"><a id="c5-para-1812"/>                                         list(first_reg)),</p>
<p class="Sp-text-1"><a id="c5-para-1813"/>                         append(list(save(first_reg)),</p>
<p class="Sp-text-1"><a id="c5-para-1814"/>                                append(instructions(seq1),</p>
<p class="Sp-text-1"><a id="c5-para-1815"/>                                       list(restore(first_reg))))),</p>
<p class="Sp-text-1"><a id="c5-para-1816"/>                     seq2)</p>
<p class="Sp-text-1"><a id="c5-para-1817"/>               : preserving(tail(regs), seq1, seq2);</p>
<p class="Sp-text-1"><a id="c5-para-1818"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-1819"/>}</p>
<p><a id="c5-para-1820"/>Another sequence combiner, <span class="KeyTerm1">tack_on_instruction_sequence</span>, is used by <span class="KeyTerm1">compile_lambda_expression</span> to append a function body to another sequence. Because the function body is not “in line” to be executed as part of the combined sequence, its register use has no impact on the register use of the sequence in which it is embedded. We thus ignore the function body's sets of needed and modified registers when we tack it onto the other sequence.</p>
<p class="Sp-text-1"><a id="c5-para-1821"/><b>function</b> tack_on_instruction_sequence(seq, body_seq) {</p>
<p class="Sp-text-1"><a id="c5-para-1822"/>    <b>return</b> make_instruction_sequence(</p>
<p class="Sp-text-1"><a id="c5-para-1823"/>               registers_needed(seq),</p>
<p class="Sp-text-1"><a id="c5-para-1824"/>               registers_modified(seq),</p>
<p class="Sp-text-1"><a id="c5-para-1825"/>               append(instructions(seq), instructions(body_seq)));</p>
<p class="Sp-text-1"><a id="c5-para-1826"/>}</p>
<p><a id="c5-para-1827"/>The functions <span class="KeyTerm1">compile_conditional</span> and <span class="KeyTerm1">compile_function_call</span> use a special combiner called <span class="KeyTerm1">parallel_instruction_sequences</span> to append the two alternative branches that follow a test. The two branches will never be executed sequentially; for any particular evaluation of the test, one branch or the other will be entered. Because of this, the registers needed by the second branch are still needed by the combined sequence, even if these are modified by the first branch.</p>
<p class="Sp-text-1"><a id="c5-para-1828"/><b>function</b> parallel_instruction_sequences(seq1, seq2) {</p>
<p class="Sp-text-1"><a id="c5-para-1829"/>    <b>return</b> make_instruction_sequence(</p>
<p class="Sp-text-1"><a id="c5-para-1830"/>               list_union(registers_needed(seq1),</p>
<p class="Sp-text-1"><a id="c5-para-1831"/>                          registers_needed(seq2)),</p>
<p class="Sp-text-1"><a id="c5-para-1832"/>               list_union(registers_modified(seq1),</p>
<p class="Sp-text-1"><a id="c5-para-1833"/>                          registers_modified(seq2)),</p>
<p class="Sp-text-1"><a id="c5-para-1834"/>               append(instructions(seq1), instructions(seq2)));</p>
<p class="Sp-text-1"><a id="c5-para-1835"/>}</p>
</section>
<section>
<h3><a id="c5-sec-0099"/><span>5.5.5</span> <a id="c5-title-0100"/>An Example of Compiled Code</h3>
<p class="paraaftertitle"><a id="c5-para-1836"/>Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the declaration of a recursive <span class="KeyTerm1">factorial</span> function by passing as first argument to <span class="KeyTerm1">compile</span> the result of applying <span class="KeyTerm1">parse</span> to a string representation of the program (here using back quotes <span class="KeyTerm1">ˋ<i>. . .</i>ˋ</span>, which work like single and double quotation marks but allow the string to span multiple lines):</p>
<p class="Sp-text-1"><a id="c5-para-1838"/>compile(parse(ˋ</p>
<p class="Sp-text-1"><a id="c5-para-1839"/>function factorial(n) {</p>
<p class="Sp-text-1"><a id="c5-para-1840"/>    return n === 1</p>
<p class="Sp-text-1"><a id="c5-para-1841"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-1842"/>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c5-para-1843"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1844"/>              ˋ),</p>
<p class="Sp-text-1"><a id="c5-para-1845"/>        "val",</p>
<p class="Sp-text-1"><a id="c5-para-1846"/>        "next");</p>
<p class="paracontinue"><a id="c5-para-1847"/>We have specified that the value of the declaration should be placed in the <span class="KeyTerm1">val</span> register. We don't care what the compiled code does after executing the declaration, so our choice of <span class="KeyTerm1">"next"</span> as the linkage descriptor is arbitrary.</p>
<p><a id="c5-para-1848"/>The function <span class="KeyTerm1">compile</span> determines that it was given a function declaration, so it transforms it to a constant declaration and then calls <span class="KeyTerm1">compile_declaration</span>. This compiles code to compute the value to be assigned (targeted to <span class="KeyTerm1">val</span>), followed by code to install the declaration, followed by code to put the value of the declaration (which is the value <span class="KeyTerm1">undefined</span>) into the target register, followed finally by the linkage code. The <span class="KeyTerm1">env</span> register is preserved around the computation of the value, because it is needed in order to install the declaration. Because the linkage is <span class="KeyTerm1">"next"</span>, there is no linkage code in this case. The skeleton of the compiled code is thus</p>
<p class="Sp-text-1"><a id="c5-para-1849"/>〈<span class="KeyTerm2"><i>save</i></span> env <span class="KeyTerm2"><i>if modified by code to compute value</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1850"/>〈<span class="KeyTerm2"><i>compilation of declaration value</i>, <i>target</i></span> val, <span class="KeyTerm2"><i>linkage</i></span> "next"〉</p>
<p class="Sp-text-1"><a id="c5-para-1851"/>〈<span class="KeyTerm2"><i>restore</i></span> env <span class="KeyTerm2"><i>if saved above</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1852"/>perform(list(op("assign_symbol_value"),</p>
<p class="Sp-text-1"><a id="c5-para-1853"/>             constant("factorial"),</p>
<p class="Sp-text-1"><a id="c5-para-1854"/>             reg("val"),</p>
<p class="Sp-text-1"><a id="c5-para-1855"/>             reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1856"/>assign("val", constant(undefined))</p>
<p><a id="c5-para-1857"/>The expression that is compiled to produce the value for the name <span class="KeyTerm1">factorial</span> is a lambda expression whose value is the function that computes factorials. The function <span class="KeyTerm1">compile</span> handles this by calling <span class="KeyTerm1">compile_lambda_expression</span>, which compiles the function body, labels it as a new entry point, and generates the instruction that will combine the function body at the new entry point with the runtime environment and assign the result to <span class="KeyTerm1">val</span>. The sequence then skips around the compiled function code, which is inserted at this point. The function code itself begins by extending the function's declaration environment by a frame that binds the parameter <span class="KeyTerm1">n</span> to the function argument. Then comes the actual function body. Since this code for the value of the name doesn't modify the <span class="KeyTerm1">env</span> register, the optional <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> shown above aren't generated. (The function code at <span class="KeyTerm1">entry1</span> isn't executed at this point, so its use of <span class="KeyTerm1">env</span> is irrelevant.) Therefore, the skeleton for the compiled code becomes</p>
<p class="Sp-text-1"><a id="c5-para-1858"/>  assign("val", list(op("make_compiled_function"),</p>
<p class="Sp-text-1"><a id="c5-para-1859"/>                     label("entry1"),</p>
<p class="Sp-text-1"><a id="c5-para-1860"/>                     reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1861"/>  go_to(label("after_lambda2")),</p>
<p class="Sp-text-1"><a id="c5-para-1862"/>"entry1",</p>
<p class="Sp-text-1"><a id="c5-para-1863"/>  assign("env", list(op("compiled_function_env"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1864"/>  assign("env", list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c5-para-1865"/>                     constant(list("n")),</p>
<p class="Sp-text-1"><a id="c5-para-1866"/>                     reg("argl"),</p>
<p class="Sp-text-1"><a id="c5-para-1867"/>                     reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1868"/>  〈<span class="KeyTerm2"><i>compilation of function body</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1869"/>"after_lambda2",</p>
<p class="Sp-text-1"><a id="c5-para-1870"/>  perform(list(op("assign_symbol_value"),</p>
<p class="Sp-text-1"><a id="c5-para-1871"/>               constant("factorial"),</p>
<p class="Sp-text-1"><a id="c5-para-1872"/>               reg("val"),</p>
<p class="Sp-text-1"><a id="c5-para-1873"/>               reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1874"/>  assign("val", constant(undefined))</p>
<p><a id="c5-para-1875"/>A function body is always compiled (by <span class="KeyTerm1">compile_lambda_body</span>) with target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"next"</span>. The body in this case consists of a single return statement:<a id="c5-fn-0050a"/><a href="#c5-fn-0050"><sup>50</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-1876"/><b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c5-para-1877"/>       ? 1</p>
<p class="Sp-text-1"><a id="c5-para-1878"/>       : factorial(n - 1) * n;</p>
<p class="paracontinue"><a id="c5-para-1879"/>The function <span class="KeyTerm1">compile_return_statement</span> generates code to revert the stack using the marker and to restore the <span class="KeyTerm1">continue</span> register, and then compiles the return expression with target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"return"</span>, because its value is to be returned from the function. The return expression is a conditional expression, for which <span class="KeyTerm1">compile_conditional</span> generates code that first computes the predicate (targeted to <span class="KeyTerm1">val</span>), then checks the result and branches around the true branch if the predicate is false. Registers <span class="KeyTerm1">env</span> and <span class="KeyTerm1">continue</span> are preserved around the predicate code, since they may be needed for the rest of the conditional expression. The true and false branches are both compiled with target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"return"</span>. (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the function.)</p>
<p class="Sp-text-1"><a id="c5-para-1880"/>  revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c5-para-1881"/>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1882"/>  〈<span class="KeyTerm2"><i>save</i></span> continue, env <span class="KeyTerm2"><i>if modified by predicate and needed by branches</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1883"/>  〈<span class="KeyTerm2"><i>compilation of predicate</i>, <i>target</i></span> val, <span class="KeyTerm2"><i>linkage</i></span> "next"〉</p>
<p class="Sp-text-1"><a id="c5-para-1884"/>  〈<span class="KeyTerm2"><i>restore</i></span> continue, env <span class="KeyTerm2"><i>if saved above</i></span>〉</p>
<p class="Sp-text-1"><a id="c5-para-1885"/>  test(list(op("is_falsy"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-1886"/>  branch(label("false_branch4")),</p>
<p class="Sp-text-1"><a id="c5-para-1887"/>"true_branch3",</p>
<p class="Sp-text-1"><a id="c5-para-1888"/>  〈<span class="KeyTerm2"><i>compilation of true branch</i>, <i>target</i></span> val, <span class="KeyTerm2"><i>linkage</i></span> "return"〉</p>
<p class="Sp-text-1"><a id="c5-para-1889"/>"false_branch4",</p>
<p class="Sp-text-1"><a id="c5-para-1890"/>  〈<span class="KeyTerm2"><i>compilation of false branch</i>, <i>target</i></span> val, <span class="KeyTerm2"><i>linkage</i></span> "return"〉</p>
<p class="Sp-text-1"><a id="c5-para-1891"/>"after_cond5",</p>
<p><a id="c5-para-1892"/>The predicate <span class="KeyTerm1">n === 1</span> is a function application (after transformation of the operator combination). This looks up the function expression (the symbol <span class="KeyTerm1">"==="</span>) and places this value in <span class="KeyTerm1">fun</span>. It then assembles the arguments <span class="KeyTerm1">1</span> and the value of <span class="KeyTerm1">n</span> into <span class="KeyTerm1">argl</span>. Then it tests whether <span class="KeyTerm1">fun</span> contains a primitive or a compound function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the <span class="KeyTerm1">after_call</span> label. The compound branch must set up <span class="KeyTerm1">continue</span> to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the function and argument expressions don't result in any saving of registers, because in this case those evaluations don't modify the registers in question.</p>
<p class="Sp-text-1"><a id="c5-para-1893"/>  assign("fun", list(op("lookup_symbol_value"),</p>
<p class="Sp-text-1"><a id="c5-para-1894"/>                     constant("==="), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1895"/>  assign("val", constant(1)),</p>
<p class="Sp-text-1"><a id="c5-para-1896"/>  assign("argl", list(op("list"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c5-para-1897"/>  assign("val", list(op("lookup_symbol_value"),</p>
<p class="Sp-text-1"><a id="c5-para-1898"/>                     constant("n"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1899"/>  assign("argl", list(op("pair"), reg("val"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c5-para-1900"/>  test(list(op("is_primitive_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1901"/>  branch(label("primitive_branch6")),</p>
<p class="Sp-text-1"><a id="c5-para-1902"/>"compiled_branch7",</p>
<p class="Sp-text-1"><a id="c5-para-1903"/>  assign("continue", label("after_call8")),</p>
<p class="Sp-text-1"><a id="c5-para-1904"/>  save("continue"),</p>
<p class="Sp-text-1"><a id="c5-para-1905"/>  push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c5-para-1906"/>  assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-1907"/>  go_to(reg("val")),</p>
<p class="Sp-text-1"><a id="c5-para-1908"/>"primitive_branch6",</p>
<p class="Sp-text-1"><a id="c5-para-1909"/>  assign("val", list(op("apply_primitive_function"),</p>
<p class="Sp-text-1"><a id="c5-para-1910"/>                     reg("fun"),</p>
<p class="Sp-text-1"><a id="c5-para-1911"/>                     reg("argl"))),</p>
<p class="Sp-text-1"><a id="c5-para-1912"/>"after_call8",</p>
<p><a id="c5-para-1913"/>The true branch, which is the constant 1, compiles (with target val and linkage "<span class="KeyTerm1">return</span>") to</p>
<p class="Sp-text-1"><a id="c5-para-1914"/>  assign("val", constant(1)),</p>
<p class="Sp-text-1"><a id="c5-para-1915"/>  go_to(reg("continue")),</p>
<p class="paracontinue"><a id="c5-para-1916"/>The code for the false branch is another function call, where the function is the value of the symbol <span class="KeyTerm1">"*"</span>, and the arguments are <span class="KeyTerm1">n</span> and the result of another function call (a call to <span class="KeyTerm1">factorial</span>). Each of these calls sets up <span class="KeyTerm1">fun</span> and <span class="KeyTerm1">argl</span> and its own primitive and compound branches. <a id="c5-fig-0018a"/><a href="#c5-fig-0018">Figure 5.17</a> shows the complete compilation of the declaration of the <span class="KeyTerm1">factorial</span> function. Notice that the possible <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> of <span class="KeyTerm1">continue</span> and <span class="KeyTerm1">env</span> around the predicate, shown above, are in fact generated, because these registers are modified by the function call in the predicate and needed for the function call and the <span class="KeyTerm1">"return"</span> linkage in the branches.</p>
<figure id="c5-fig-0018"><img alt="c5-fig-0017a.jpg" src="../images/c5-fig-0017a.jpg"/><br/><img alt="c5-fig-0017b.jpg" src="../images/c5-fig-0017b.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0018a">Figure 5.17</a></span> <a id="c5-para-1917"/>Compilation of the declaration of the <span class="KeyTerm1">factorial</span> function.</p></figcaption></figure>
<section>
<h5><a id="c5-sec-0100"/><a id="c5-title-0101"/>Exercise 5.36</h5>
<p class="paraaftertitle"><a id="c5-para-1920"/>Consider the following declaration of a factorial function, which is slightly different from the one given above:</p>
<p class="Sp-text-1"><a id="c5-para-1921"/><b>function</b> factorial_alt(n) {</p>
<p class="Sp-text-1"><a id="c5-para-1922"/>    <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c5-para-1923"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-1924"/>           : n * factorial_alt(n - 1);</p>
<p class="Sp-text-1"><a id="c5-para-1925"/>}</p>
<p><a id="c5-para-1926"/>Compile this function and compare the resulting code with that produced for <span class="KeyTerm1">factorial</span>. Explain any differences you find. Does either program execute more efficiently than the other?</p>
</section>
<section>
<h5><a id="c5-sec-0101"/><a id="c5-title-0102"/>Exercise 5.37</h5>
<p class="paraaftertitle"><a id="c5-para-1927"/>Compile the iterative factorial function</p>
<p class="Sp-text-1"><a id="c5-para-1928"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c5-para-1929"/>    <b>function</b> iter(product, counter) {</p>
<p class="Sp-text-1"><a id="c5-para-1930"/>        <b>return</b> counter &gt; n</p>
<p class="Sp-text-1"><a id="c5-para-1931"/>               ? product</p>
<p class="Sp-text-1"><a id="c5-para-1932"/>               : iter(product * counter, counter + 1);</p>
<p class="Sp-text-1"><a id="c5-para-1933"/>    }</p>
<p class="Sp-text-1"><a id="c5-para-1934"/>    <b>return</b> iter(1, 1);</p>
<p class="Sp-text-1"><a id="c5-para-1935"/>}</p>
<p class="paracontinue"><a id="c5-para-1936"/>Annotate the resulting code, showing the essential difference between the code for iterative and recursive versions of <span class="KeyTerm1">factorial</span> that makes one process build up stack space and the other run in constant stack space.</p>
</section>
<section>
<h5><a id="c5-sec-0102"/><a id="c5-title-0103"/>Exercise 5.38</h5>
<p class="paraaftertitle"><a id="c5-para-1937"/>What program was compiled to produce the code shown in <a id="c5-fig-0021a"/><a href="#c5-fig-0021">figure 5.18</a>?</p>
<figure id="c5-fig-0021"><img alt="c5-fig-0018a.jpg" src="../images/c5-fig-0018a.jpg"/><br/><img alt="c5-fig-0018b.jpg" src="../images/c5-fig-0018b.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0021a">Figure 5.18</a></span> <a id="c5-para-1938"/>An example of compiler output. See exercise 5.38.</p></figcaption></figure>
</section>
<section>
<h5><a id="c5-sec-0103"/><a id="c5-title-0104"/>Exercise 5.39</h5>
<p class="paraaftertitle"><a id="c5-para-1941"/>What order of evaluation does our compiler produce for arguments of an application? Is it left-to-right (as mandated by the ECMAScript specification), right-to-left, or some other order? Where in the compiler is this order determined? Modify the compiler so that it produces some other order of evaluation. (See the discussion of order of evaluation for the explicit-control evaluator in section 5.4.1.) How does changing the order of argument evaluation affect the efficiency of the code that constructs the argument list?</p>
</section>
<section>
<h5><a id="c5-sec-0104"/><a id="c5-title-0105"/>Exercise 5.40</h5>
<p class="paraaftertitle"><a id="c5-para-1942"/>One way to understand the compiler's <span class="KeyTerm1">preserving</span> mechanism for optimizing stack usage is to see what extra operations would be generated if we did not use this idea. Modify <span class="KeyTerm1">preserving</span> so that it always generates the <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> operations. Compile some simple expressions and identify the unnecessary stack operations that are generated. Compare the code to that generated with the <span class="KeyTerm1">preserving</span> mechanism intact.</p>
</section>
<section>
<h5><a id="c5-sec-0105"/><a id="c5-title-0106"/>Exercise 5.41</h5>
<p class="paraaftertitle"><a id="c5-para-1943"/>Our compiler is clever about avoiding unnecessary stack operations, but it is not clever at all when it comes to compiling calls to the primitive functions of the language in terms of the primitive operations supplied by the machine. For example, consider how much code is compiled to compute <span class="KeyTerm1">a + 1</span>: The code sets up an argument list in <span class="KeyTerm1">argl</span>, puts the primitive addition function (which it finds by looking up the symbol <span class="KeyTerm1">"+"</span> in the environment) into <span class="KeyTerm1">fun</span>, and tests whether the function is primitive or compound. The compiler always generates code to perform the test, as well as code for primitive and compound branches (only one of which will be executed). We have not shown the part of the controller that implements primitives, but we presume that these instructions make use of primitive arithmetic operations in the machine's data paths. Consider how much less code would be generated if the compiler could <i>open-code</i> primitives—that is, if it could generate code to directly use these primitive machine operations. The expression <span class="KeyTerm1">a + 1</span> might be compiled into something as simple as<a id="c5-fn-0051a"/><a href="#c5-fn-0051"><sup>51</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-1944"/>assign("val", list(op("lookup_symbol_value"), constant("a"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c5-para-1945"/>assign("val", list(op("+"), reg("val"), constant(1)))</p>
<p class="paracontinue"><a id="c5-para-1946"/>In this exercise we will extend our compiler to support open coding of selected primitives. Special-purpose code will be generated for calls to these primitive functions instead of the general function-application code. In order to support this, we will augment our machine with special argument registers <span class="KeyTerm1">arg1</span> and <span class="KeyTerm1">arg2</span>. The primitive arithmetic operations of the machine will take their inputs from <span class="KeyTerm1">arg1</span> and <span class="KeyTerm1">arg2</span>. The results may be put into <span class="KeyTerm1">val</span>, <span class="KeyTerm1">arg1</span>, or <span class="KeyTerm1">arg2</span>.</p>
<p><a id="c5-para-1947"/>The compiler must be able to recognize the application of an open-coded primitive in the source program. We will augment the dispatch in the <span class="KeyTerm1">compile</span> function to recognize the names of these primitives in addition to the syntactic forms it currently recognizes. For each syntactic form our compiler has a code generator. In this exercise we will construct a family of code generators for the open-coded primitives.</p>
<ol class="BS_NumberListA">
<li><a id="c5-li-0041"/><span>a. </span>The open-coded primitives, unlike the syntactic forms, all need their argument expressions evaluated. Write a code generator <span class="KeyTerm1">spread_arguments</span> for use by all the open-coding code generators. The function <span class="KeyTerm1">spread_arguments</span> should take a list of argument expressions and compile the given argument expressions targeted to successive argument registers. Note that an argument expression may contain a call to an open-coded primitive, so argument registers will have to be preserved during argument-expression evaluation.</li>
<li><a id="c5-li-0042"/><span>b. </span>The JavaScript operators <span class="KeyTerm1">===</span>, <span class="KeyTerm1">*</span>, <span class="KeyTerm1">-</span>, and <span class="KeyTerm1">+</span>, among others, are implemented in the register machine as primitive functions and are referred to in the global environment with the symbols <span class="KeyTerm1">"==="</span>, <span class="KeyTerm1">"*"</span>, <span class="KeyTerm1">"-"</span>, and <span class="KeyTerm1">"+"</span>. In JavaScript, it is not possible to redeclare these names, because they do not meet the syntactic restrictions for names. This means it is safe to open-code them. For each of the primitive functions <span class="KeyTerm1">===</span>, <span class="KeyTerm1">*</span>, <span class="KeyTerm1">-</span>, and <span class="KeyTerm1">+</span>, write a code generator that takes an application with a function expression that names that function, together with a target and a linkage descriptor, and produces code to spread the arguments into the registers and then perform the operation targeted to the given target with the given linkage. Make <span class="KeyTerm1">compile</span> dispatch to these code generators.</li>
<li><a id="c5-li-0043"/><span>c. </span>Try your new compiler on the <span class="KeyTerm1">factorial</span> example. Compare the resulting code with the result produced without open coding.</li>
</ol>
</section>
</section>
<section>
<h3><a id="c5-sec-0106"/><span>5.5.6</span> <a id="c5-title-0107"/>Lexical Addressing</h3>
<p class="paraaftertitle"><a id="c5-para-1951"/>One of the most common optimizations performed by compilers is the optimization of name lookup. Our compiler, as we have implemented it so far, generates code that uses the <span class="KeyTerm1">lookup_symbol_value</span> operation of the evaluator machine. This searches for a name by comparing it with each name that is currently bound, working frame by frame outward through the runtime environment. This search can be expensive if the frames are deeply nested or if there are many names. For example, consider the problem of looking up the value of <span class="KeyTerm1">x</span> while evaluating the expression <span class="KeyTerm1">x * y * z</span> in an application of the function of five arguments that is returned by</p>
<p class="Sp-text-1"><a id="c5-para-1952"/>((x, y) =&gt;</p>
<p class="Sp-text-1"><a id="c5-para-1953"/>   (a, b, c, d, e) =&gt;</p>
<p class="Sp-text-1"><a id="c5-para-1954"/>     ((y, z) =&gt; x * y * z)(a * b * x, c + d + x))(3, 4)</p>
<p class="paracontinue"><a id="c5-para-1955"/>Each time <span class="KeyTerm1">lookup_symbol_value</span> searches for <span class="KeyTerm1">x</span>, it must determine that the symbol <span class="KeyTerm1">"x"</span> is not equal to <span class="KeyTerm1">"y"</span> or <span class="KeyTerm1">"z"</span> (in the first frame), nor to <span class="KeyTerm1">"a"</span>, <span class="KeyTerm1">"b"</span>, <span class="KeyTerm1">"c"</span>, <span class="KeyTerm1">"d"</span>, or <span class="KeyTerm1">"e"</span> (in the second frame). Because our language is lexically scoped, the runtime environment for any component will have a structure that parallels the lexical structure of the program in which the component appears. Thus, the compiler can know, when it analyzes the above expression, that each time the function is applied the binding for <span class="KeyTerm1">x</span> in <span class="KeyTerm1">x * y * z</span> will be found two frames out from the current frame and will be the first binding in that frame.</p>
<p><a id="c5-para-1956"/>We can exploit this fact by inventing a new kind of name-lookup operation, <span class="KeyTerm1">lexical_address_lookup</span>, that takes as arguments an environment and a <i>lexi-cal address</i> that consists of two numbers: a <i>frame number</i>, which specifies how many frames to pass over, and a <i>displacement number</i>, which specifies how many bindings to pass over in that frame. The operation <span class="KeyTerm1">lexical_address_lookup</span> will produce the value of the name stored at that lexical address relative to the current environment. If we add the <span class="KeyTerm1">lexical_address_lookup</span> operation to our machine, we can make the compiler generate code that references names using this operation, rather than <span class="KeyTerm1">lookup_symbol_value</span>. Similarly, our compiled code can use a new <span class="KeyTerm1">lexical_address_assign</span> operation instead of <span class="KeyTerm1">assign_symbol_value</span>. With lexical addressing, there is no need to include any symbolic references to names in the object code, and frames do not need to include symbols at run time.</p>
<p><a id="c5-para-1957"/>In order to generate such code, the compiler must be able to determine the lexical address of a name it is about to compile a reference to. The lexical address of a name in a program depends on where one is in the code. For example, in the following program, the address of <span class="KeyTerm1">x</span> in expression <i>e</i><sub>1</sub> is (2,0)—two frames back and the first name in the frame. At that point <span class="KeyTerm1">y</span> is at address (0,0) and <span class="KeyTerm1">c</span> is at address (1,2). In expression <i>e</i><sub>2</sub>, <span class="KeyTerm1">x</span> is at (1,0), <span class="KeyTerm1">y</span> is at (1,1), and <span class="KeyTerm1">c</span> is at (0,2).</p>
<p class="Sp-text-1"><a id="c5-para-1958"/>((x, y) =&gt;</p>
<p class="Sp-text-1"><a id="c5-para-1959"/>   (a, b, c, d, e) =&gt;</p>
<p class="Sp-text-1"><a id="c5-para-1960"/>     ((y, z) =&gt; <i>e</i><sub>1</sub>)(<i>e</i><sub>2</sub>, c + d + x))(3, 4);</p>
<p><a id="c5-para-1961"/>One way for the compiler to produce code that uses lexical addressing is to maintain a data structure called a <i>compile-time environment</i>. This keeps track of which bindings will be at which positions in which frames in the runtime environment when a particular name-access operation is executed. The compile-time environment is a list of frames, each containing a list of symbols. There will be no values associated with the symbols, since values are not computed at compile time. (Exercise 5.47 will change this, as an optimization for constants.) The compile-time environment becomes an additional argument to <span class="KeyTerm1">compile</span> and is passed along to each code generator. The top-level call to <span class="KeyTerm1">compile</span> uses a compile-time-environment that includes the names of all primitive functions and primitive values. When the body of a lambda expression is compiled, <span class="KeyTerm1">compile_lambda_body</span> extends the compiletime environment by a frame containing the function's parameters, so that the body is compiled with that extended environment. Similarly, when the body of a block is compiled, <span class="KeyTerm1">compile_block</span> extends the compile-time environment by a frame containing the scanned-out local names of the body. At each point in the compilation, <span class="KeyTerm1">compile_name</span> and <span class="KeyTerm1">compile_assignment_declaration</span> use the compile-time environment in order to generate the appropriate lexical addresses.</p>
<p><a id="c5-para-1962"/>Exercises 5.42 through 5.45 describe how to complete this sketch of the lexical-addressing strategy in order to incorporate lexical lookup into the compiler. Exercises 5.46 and 5.47 describe other uses for the compile-time environment.</p>
<section>
<h5><a id="c5-sec-0107"/><a id="c5-title-0108"/>Exercise 5.42</h5>
<p class="paraaftertitle"><a id="c5-para-1963"/>Write a function <span class="KeyTerm1">lexical_address_lookup</span> that implements the new lookup operation. It should take two arguments—a lexical address and a runtime environment—and return the value of the name stored at the specified lexical address. The function <span class="KeyTerm1">lexical_address_ lookup</span> should signal an error if the value of the name is the string <span class="KeyTerm1">"*unassigned*"</span>. Also write a function <span class="KeyTerm1">lexical_address_assign</span> that implements the operation that changes the value of the name at a specified lexical address.</p>
</section>
<section>
<h5><a id="c5-sec-0108"/><a id="c5-title-0109"/>Exercise 5.43</h5>
<p class="paraaftertitle"><a id="c5-para-1964"/>Modify the compiler to maintain the compile-time environment as described above. That is, add a compile-time-environment argument to <span class="KeyTerm1">compile</span> and the various code generators, and extend it in <span class="KeyTerm1">compile_lambda_body</span> and <span class="KeyTerm1">compile_block</span>.</p>
</section>
<section>
<h5><a id="c5-sec-0109"/><a id="c5-title-0110"/>Exercise 5.44</h5>
<p class="paraaftertitle"><a id="c5-para-1965"/>Write a function <span class="KeyTerm1">find_symbol</span> that takes as arguments a symbol and a compile-time environment and returns the lexical address of the symbol with respect to that environment. For example, in the program fragment that is shown above, the compile-time environment during the compilation of expression <i>e</i><sub>1</sub> is</p>
<p class="Sp-text-1"><a id="c5-para-1966"/>list(list("y", "z"),</p>
<p class="Sp-text-1"><a id="c5-para-1967"/>     list("a", "b", "c", "d", "e"),</p>
<p class="Sp-text-1"><a id="c5-para-5967"/>     list("x", "y"))</p>
<p class="paracontinue"><a id="c5-para-1968"/>The function <span class="KeyTerm1">find_symbol</span> should produce</p>
<p class="Sp-text-1"><a id="c5-para-1969"/>find_symbol("c", list(list("y", "z"),</p>
<p class="Sp-text-1"><a id="c5-para-1970"/>                      list("a", "b", "c", "d", "e"),</p>
<p class="Sp-text-1"><a id="c5-para-1971"/>                      list("x", "y")));</p>
<p class="Sp-text-1"><a id="c5-para-1972"/><i>list(1, 2)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-1973"/>find_symbol("x", list(list("y", "z"),</p>
<p class="Sp-text-1"><a id="c5-para-1974"/>                      list("a", "b", "c", "d", "e"),</p>
<p class="Sp-text-1"><a id="c5-para-1975"/>                      list("x", "y")));</p>
<p class="Sp-text-1"><a id="c5-para-1976"/><i>list(2, 0)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-1977"/>find_symbol("w", list(list("y", "z"),</p>
<p class="Sp-text-1"><a id="c5-para-1978"/>                      list("a", "b", "c", "d", "e"),</p>
<p class="Sp-text-1"><a id="c5-para-1979"/>                      list("x", "y")));</p>
<p class="Sp-text-1"><a id="c5-para-1980"/><i>"not found"</i></p>
</section>
<section>
<h5><a id="c5-sec-0110"/><a id="c5-title-0111"/>Exercise 5.45</h5>
<p class="paraaftertitle"><a id="c5-para-1981"/>Using <span class="KeyTerm1">find_symbol</span> from exercise 5.44, rewrite <span class="KeyTerm1">compile_assignment_declaration</span> and <span class="KeyTerm1">compile_name</span> to output lexical-address instructions. In cases where <span class="KeyTerm1">find_symbol</span> returns <span class="KeyTerm1">"not found"</span> (that is, where the name is not in the compile-time environment), you should report a compile-time error. Test the modified compiler on a few simple cases, such as the nested lambda combination at the beginning of this section.</p>
</section>
<section>
<h5><a id="c5-sec-0111"/><a id="c5-title-0112"/>Exercise 5.46</h5>
<p class="paraaftertitle"><a id="c5-para-1982"/>In JavaScript, an attempt to assign a new value to a name that is declared as a constant leads to an error. Exercise 4.11 shows how to detect such errors at run time. With the techniques presented in this section, we can detect attempts to assign a new value to a constant <i>at compile time</i>. For this purpose, extend the functions <span class="KeyTerm1">compile_lambda_body</span> and <span class="KeyTerm1">compile_block</span> to record in the compile-time environment whether a name is declared as a variable (using <span class="KeyTerm1"><b>let</b></span> or as a parameter), or as a constant (using <span class="KeyTerm1"><b>const</b></span> or <span class="KeyTerm1"><b>function</b></span>). Modify <span class="KeyTerm1">compile_assignment</span> to report an appropriate error when it detects an assignment to a constant.</p>
</section>
<section>
<h5><a id="c5-sec-0112"/><a id="c5-title-0113"/>Exercise 5.47</h5>
<p class="paraaftertitle"><a id="c5-para-1983"/>Knowledge about constants at compile time opens the door to many optimizations that allow us to generate more efficient object code. In addition to the extension of the compiletime environment in exercise 5.46 to indicate names declared as constants, we may store the value of a constant if it is known at compile time, or other information that can help us optimize the code.</p>
<ol class="BS_NumberListA">
<li><a id="c5-li-0044"/><span>a. </span>A constant declaration such as <span class="KeyTerm1"><b>const</b></span> <i>name</i> <span class="KeyTerm1">=</span> <i>literal</i><span class="KeyTerm1">;</span> allows us to replace all occurrences of <i>name</i> within the scope of the declaration by <i>literal</i> so that <i>name</i> doesn't have to be looked up in the runtime environment. This optimization is called <i>constant propagation</i>. Use an extended compile-time environment to store literal constants, and modify <span class="KeyTerm1">compile_name</span> to use the stored constant in the generated <span class="KeyTerm1">assign</span> instruction instead of the <span class="KeyTerm1">lookup_symbol_value</span> operation.</li>
<li><a id="c5-li-0045"/><span>b. </span>Function declaration is a derived component that expands to constant declaration. Let us assume that the names of primitive functions in the global environment are also considered constants. If we further extend our compile-time environment to keep track of which names refer to compiled functions and which ones to primitive functions, we can move the test that checks whether a function is compiled or primitive from run time to compile time. This makes the object code more efficient because it replaces a test that must be performed once per function application in the generated code by one that is performed by the compiler. Using such an extended compile-time environment, modify <span class="KeyTerm1">compile_function_call</span> so that if it can be determined at compile time whether the called function is compiled or primitive, only the instructions in the <span class="KeyTerm1">compiled_branch</span> or the <span class="KeyTerm1">primitive_branch</span> are generated.</li>
<li><a id="c5-li-0046"/><span>c. </span>Replacing constant names with their literal values as in part (a) paves the way for another optimization, namely replacing applications of primitive functions to literal values with the compile-time computed result. This optimization, called <i>constant folding</i>, replaces expressions such as <span class="KeyTerm1">40 + 2</span> by <span class="KeyTerm1">42</span> by performing the addition in the compiler. Extend the compiler to perform constant folding for arithmetic operations on numbers and for string concatenation.</li>
</ol>
</section>
</section>
<section>
<h3><a id="c5-sec-0113"/><span>5.5.7</span> <a id="c5-title-0114"/>Interfacing Compiled Code to the Evaluator</h3>
<p class="paraaftertitle"><a id="c5-para-1987"/>We have not yet explained how to load compiled code into the evaluator machine or how to run it. We will assume that the explicit-control-evaluator machine has been defined as in section 5.4.4, with the additional operations specified in footnote 43 (section 5.5.2). We will implement a function <span class="KeyTerm1">compile_and_go</span> that compiles a JavaScript program, loads the resulting object code into the evaluator machine, and causes the machine to run the code in the evaluator global environment, print the result, and enter the evaluator's driver loop. We will also modify the evaluator so that interpreted components can call compiled functions as well as interpreted ones. We can then put a compiled function into the machine and use the evaluator to call it:</p>
<p class="Sp-text-1"><a id="c5-para-1988"/>compile_and_go(parse(ˋ</p>
<p class="Sp-text-1"><a id="c5-para-1989"/>function factorial(n) { </p>
<p class="Sp-text-1"><a id="c5-para-1990"/>    return n === 1</p>
<p class="Sp-text-1"><a id="c5-para-1991"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-1992"/>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c5-para-1993"/>}</p>
<p class="Sp-text-1"><a id="c5-para-1994"/>                     ˋ));</p>
<p class="Sp-text-3"><a id="c5-para-1995"/><i>EC-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c5-para-1996"/><i>undefined</i></p>
<p class="Sp-text-3"><a id="c5-para-1997"/><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c5-para-1998"/>factorial(5);</p>
<p class="Sp-text-3"><a id="c5-para-1999"/><i>EC-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c5-para-2000"/><i>120</i></p>
<p><a id="c5-para-2001"/>To allow the evaluator to handle compiled functions (for example, to evaluate the call to <span class="KeyTerm1">factorial</span> above), we need to change the code at <span class="KeyTerm1">apply_dispatch</span> (section 5.4.2) so that it recognizes compiled functions (as distinct from compound or primitive functions) and transfers control directly to the entry point of the compiled code:<a id="c5-fn-0052a"/><a href="#c5-fn-0052"><sup>52</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-2002"/>"apply_dispatch",</p>
<p class="Sp-text-1"><a id="c5-para-2003"/>  test(list(op("is_primitive_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-2004"/>  branch(label("primitive_apply")),</p>
<p class="Sp-text-1"><a id="c5-para-2005"/>  test(list(op("is_compound_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-2006"/>  branch(label("compound_apply")),</p>
<p class="Sp-text-1"><a id="c5-para-2007"/>  test(list(op("is_compiled_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-2008"/>  branch(label("compiled_apply")),</p>
<p class="Sp-text-1"><a id="c5-para-2009"/>  go_to(label("unknown_function_type")),</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c5-para-2011"/>"compiled_apply",</p>
<p class="Sp-text-1"><a id="c5-para-2012"/>  push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c5-para-2013"/>  assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c5-para-2014"/>  go_to(reg("val")),</p>
<p class="paracontinue"><a id="c5-para-2015"/>At <span class="KeyTerm1">compiled_apply</span>, as at <span class="KeyTerm1">compound_apply</span>, we push a marker to the stack so that a return statement in the compiled function can revert the stack to this state. Note that there is no save of <span class="KeyTerm1">continue</span> at <span class="KeyTerm1">compiled_apply</span> before the marking of the stack, because the evaluator was arranged so that at <span class="KeyTerm1">apply_dispatch</span>, the continuation would be at the top of the stack.</p>
<p><a id="c5-para-2016"/>To enable us to run some compiled code when we start the evaluator machine, we add a <span class="KeyTerm1">branch</span> instruction at the beginning of the evaluator machine, which causes the machine to go to a new entry point if the <span class="KeyTerm1">flag</span> register is set.<a id="c5-fn-0053a"/><a href="#c5-fn-0053"><sup>53</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-2017"/>  branch(label("external_entry")), <i>//</i> <span class="KeyTerm2"><i>branches if flag is set</i></span></p>
<p class="Sp-text-1"><a id="c5-para-2018"/>"read_evaluate_print_loop",</p>
<p class="Sp-text-1"><a id="c5-para-2019"/>  perform(list(op("initialize_stack"))),</p>
<p class="Sp-text-1"><a id="c5-para-2020"/>  <i>. . .</i></p>
<p class="paracontinue"><a id="c5-para-2021"/>The code at <span class="KeyTerm1">external_entry</span> assumes that the machine is started with <span class="KeyTerm1">val</span> containing the location of an instruction sequence that puts a result into <span class="KeyTerm1">val</span> and ends with <span class="KeyTerm1">go_to(reg("continue"))</span>. Starting at this entry point jumps to the location designated by <span class="KeyTerm1">val</span>, but first assigns <span class="KeyTerm1">continue</span> so that execution will return to <span class="KeyTerm1">print_result</span>, which prints the value in <span class="KeyTerm1">val</span> and then goes to the beginning of the evaluator's read-evaluate-print loop.<a id="c5-fn-0054a"/><a href="#c5-fn-0054"><sup>54</sup></a></p>
<p class="Sp-text-1"><a id="c5-para-2022"/>"external_entry",</p>
<p class="Sp-text-1"><a id="c5-para-2023"/>  perform(list(op("initialize_stack"))),</p>
<p class="Sp-text-1"><a id="c5-para-2024"/>  assign("env", list(op("get_current_environment"))),</p>
<p class="Sp-text-1"><a id="c5-para-2025"/>  assign("continue", label("print_result")),</p>
<p class="Sp-text-1"><a id="c5-para-2026"/>  go_to(reg("val")),</p>
<p><a id="c5-para-2027"/>Now we can use the following function to compile a function declaration, execute the compiled code, and run the read-evaluate-print loop so we can try the function. Because we want the compiled code to proceed to the location in <span class="KeyTerm1">continue</span> with its result in <span class="KeyTerm1">val</span>, we compile the program with a target of <span class="KeyTerm1">val</span> and a linkage of <span class="KeyTerm1">"return"</span>. In order to transform the object code produced by the compiler into executable instructions for the evaluator register machine, we use the function <span class="KeyTerm1">assemble</span> from the register-machine simulator (section 5.2.2). For the interpreted program to refer to the names that are declared at top level in the compiled program, we scan out the top-level names and extend the global environment by binding these names to <span class="KeyTerm1">"*unassigned*"</span>, knowing that the compiled code will assign them the correct values. We then initialize the <span class="KeyTerm1">val</span> register to point to the list of instructions, set the <span class="KeyTerm1">flag</span> so that the evaluator will go to <span class="KeyTerm1">external_entry</span>, and start the evaluator.</p>
<p class="Sp-text-1"><a id="c5-para-2049"/><b>function</b> compile_and_go(program) {</p>
<p class="Sp-text-1"><a id="c5-para-2050"/>    <b>const</b> instrs = assemble(instructions(compile(program,</p>
<p class="Sp-text-1"><a id="c5-para-2051"/>                                                 "val", "return")),</p>
<p class="Sp-text-1"><a id="c5-para-2052"/>                            eceval);</p>
<p class="Sp-text-1"><a id="c5-para-2053"/>    <b>const</b> toplevel_names = scan_out_declarations(program);</p>
<p class="Sp-text-1"><a id="c5-para-2054"/>    <b>const</b> unassigneds = list_of_unassigned(toplevel_names);</p>
<p class="Sp-text-1"><a id="c5-para-2055"/>    set_current_environment(extend_environment(</p>
<p class="Sp-text-1"><a id="c5-para-2056"/>                               toplevel_names,</p>
<p class="Sp-text-1"><a id="c5-para-2057"/>                               unassigneds,</p>
<p class="Sp-text-1"><a id="c5-para-2058"/>                               the_global_environment));</p>
<p class="Sp-text-1"><a id="c5-para-2059"/>    set_register_contents(eceval, "val", instrs);</p>
<p class="Sp-text-1"><a id="c5-para-2060"/>    set_register_contents(eceval, "flag", <b>true</b>);</p>
<p class="Sp-text-1"><a id="c5-para-2061"/>    <b>return</b> start(eceval);</p>
<p class="Sp-text-1"><a id="c5-para-2062"/>}</p>
<p><a id="c5-para-2063"/>If we have set up stack monitoring, as at the end of section 5.4.4, we can examine the stack usage of compiled code:</p>
<p class="Sp-text-1"><a id="c5-para-2064"/>compile_and_go(parse(ˋ</p>
<p class="Sp-text-1"><a id="c5-para-2065"/>function factorial(n) { </p>
<p class="Sp-text-1"><a id="c5-para-2066"/>    return n === 1</p>
<p class="Sp-text-1"><a id="c5-para-2067"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-2068"/>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c5-para-2069"/>}</p>
<p class="Sp-text-1"><a id="c5-para-2070"/>                     ˋ));</p>
<p class="Sp-text-3"><a id="c5-para-2071"/><i>total pushes = 0</i></p>
<p class="Sp-text-3"><a id="c5-para-2072"/><i>maximum depth = 0</i></p>
<p class="Sp-text-3"><a id="c5-para-2073"/><i>EC-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c5-para-2074"/><i>undefined</i></p>
<p class="Sp-text-3"><a id="c5-para-2075"/><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c5-para-2076"/>factorial(5);</p>
<p class="Sp-text-3"><a id="c5-para-2077"/><i>total pushes = 36</i></p>
<p class="Sp-text-3"><a id="c5-para-2078"/><i>maximum depth = 14</i></p>
<p class="Sp-text-3"><a id="c5-para-2079"/><i>EC-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c5-para-2080"/><i>120</i></p>
<p class="paracontinue"><a id="c5-para-2081"/>Compare this example with the evaluation of <span class="KeyTerm1">factorial(5)</span> using the interpreted version of the same function, shown at the end of section 5.4.4. The interpreted version required 151 pushes and a maximum stack depth of 28. This illustrates the optimization that results from our compilation strategy.</p>
<section>
<h5><a id="c5-sec-0114"/><a id="c5-title-0115"/>Interpretation and compilation</h5>
<p class="paraaftertitle"><a id="c5-para-2082"/>With the programs in this section, we can now experiment with the alternative execution strategies of interpretation and compilation.<a id="c5-fn-0055a"/><a href="#c5-fn-0055"><sup>55</sup></a> An interpreter raises the machine to the level of the user program; a compiler lowers the user program to the level of the machine language. We can regard the JavaScript language (or any programming language) as a coherent family of abstractions erected on the machine language. Interpreters are good for interactive program development and debugging because the steps of program execution are organized in terms of these abstractions, and are therefore more intelligible to the programmer. Compiled code can execute faster, because the steps of program execution are organized in terms of the machine language, and the compiler is free to make optimizations that cut across the higher-level abstractions.<a id="c5-fn-0056a"/><a href="#c5-fn-0056"><sup>56</sup></a></p>
<p><a id="c5-para-2083"/>The alternatives of interpretation and compilation also lead to different strategies for porting languages to new computers. Suppose that we wish to implement JavaScript for a new machine. One strategy is to begin with the explicit-control evaluator of section 5.4 and translate its instructions to instructions for the new machine. A different strategy is to begin with the compiler and change the code generators so that they generate code for the new machine. The second strategy allows us to run any JavaScript program on the new machine by first compiling it with the compiler running on our original JavaScript system, and linking it with a compiled version of the runtime library.<a id="c5-fn-0057a"/><a href="#c5-fn-0057"><sup>57</sup></a> Better yet, we can compile the compiler itself, and run this on the new machine to compile other JavaScript programs.<a id="c5-fn-0058a"/><a href="#c5-fn-0058"><sup>58</sup></a> Or we can compile one of the interpreters of section 4.1 to produce an interpreter that runs on the new machine.</p>
</section>
<section>
<h5><a id="c5-sec-0115"/><a id="c5-title-0116"/>Exercise 5.48</h5>
<p class="paraaftertitle"><a id="c5-para-2084"/>By comparing the stack operations used by compiled code to the stack operations used by the evaluator for the same computation, we can determine the extent to which the compiler optimizes use of the stack, both in speed (reducing the total number of stack operations) and in space (reducing the maximum stack depth). Comparing this optimized stack use to the performance of a special-purpose machine for the same computation gives some indication of the quality of the compiler.</p>
<ol class="BS_NumberListA">
<li><a id="c5-li-0047"/><span>a. </span>Exercise 5.28 asked you to determine, as a function of <i>n</i>, the number of pushes and the maximum stack depth needed by the evaluator to compute <i>n</i>! using the recursive factorial function given above. Exercise 5.13 asked you to do the same measurements for the special-purpose factorial machine shown in <a href="#c5-fig-0011">figure 5.11</a>. Now perform the same analysis using the compiled <span class="KeyTerm1">factorial</span> function.
<p><a id="c5-para-2086"/>Take the ratio of the number of pushes in the compiled version to the number of pushes in the interpreted version, and do the same for the maximum stack depth. Since the number of operations and the stack depth used to compute <i>n</i>! are linear in <i>n</i>, these ratios should approach constants as <i>n</i> becomes large. What are these constants? Similarly, find the ratios of the stack usage in the special-purpose machine to the usage in the interpreted version.</p>
<p><a id="c5-para-2087"/>Compare the ratios for special-purpose versus interpreted code to the ratios for compiled versus interpreted code. You should find that the special-purpose machine is much more efficient than the compiled code, since the hand-tailored controller code should be much better than what is produced by our rudimentary general-purpose compiler.</p></li>
<li><a id="c5-li-0048"/><span>b. </span>Can you suggest improvements to the compiler that would help it generate code that would come closer in performance to the hand-tailored version?</li>
</ol>
</section>
<section>
<h5><a id="c5-sec-0116"/><a id="c5-title-0117"/>Exercise 5.49</h5>
<p class="paraaftertitle"><a id="c5-para-2089"/>Carry out an analysis like the one in exercise 5.48 to determine the effectiveness of compiling the tree-recursive Fibonacci function</p>
<p class="Sp-text-1"><a id="c5-para-2090"/><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c5-para-2091"/>    <b>return</b> n &lt; 2 ? n : fib(n - 1) + fib(n - 2);</p>
<p class="Sp-text-1"><a id="c5-para-2092"/>}</p>
<p class="paracontinue"><a id="c5-para-2093"/>compared to the effectiveness of using the special-purpose Fibonacci machine of <a href="#c5-fig-0012">figure 5.12</a>. (For measurement of the interpreted performance, see exercise 5.30.) For Fibonacci, the time resource used is not linear in <i>n</i>; hence the ratios of stack operations will not approach a limiting value that is independent of <i>n</i>.</p>
</section>
<section>
<h5><a id="c5-sec-0117"/><a id="c5-title-0118"/>Exercise 5.50</h5>
<p class="paraaftertitle"><a id="c5-para-2094"/>This section described how to modify the explicit-control evaluator so that interpreted code can call compiled functions. Show how to modify the compiler so that compiled functions can call not only primitive functions and compiled functions, but interpreted functions as well. This requires modifying <span class="KeyTerm1">compile_function_call</span> to handle the case of compound (interpreted) functions. Be sure to handle all the same <span class="KeyTerm1">target</span> and <span class="KeyTerm1">linkage</span> combinations as in <span class="KeyTerm1">compile_fun_appl</span>. To do the actual function application, the code needs to jump to the evaluator's <span class="KeyTerm1">compound_apply</span> entry point. This label cannot be directly referenced in object code (since the assembler requires that all labels referenced by the code it is assembling be defined there), so we will add a register called <span class="KeyTerm1">compapp</span> to the evaluator machine to hold this entry point, and add an instruction to initialize it:</p>
<p class="Sp-text-1"><a id="c5-para-2095"/>  assign("compapp", label("compound_apply")),</p>
<p class="Sp-text-1"><a id="c5-para-2096"/>  branch(label("external_entry")),     <i>//</i> <span class="KeyTerm2"><i>branches if flag is set</i></span></p>
<p class="Sp-text-1"><a id="c5-para-2097"/>"read_evaluate_print_loop",</p>
<p class="Sp-text-1"><a id="c5-para-2098"/>  <i>. . .</i></p>
<p class="paracontinue"><a id="c5-para-2099"/>To test your code, start by declaring a function <span class="KeyTerm1">f</span> that calls a function <span class="KeyTerm1">g</span>. Use <span class="KeyTerm1">compile_ and_go</span> to compile the declaration of <span class="KeyTerm1">f</span> and start the evaluator. Now, typing at the evaluator, declare <span class="KeyTerm1">g</span> and try to call <span class="KeyTerm1">f</span>.</p>
</section>
<section>
<h5><a id="c5-sec-0118"/><a id="c5-title-0119"/>Exercise 5.51</h5>
<p class="paraaftertitle"><a id="c5-para-2100"/>The <span class="KeyTerm1">compile_and_go</span> interface implemented in this section is awkward, since the compiler can be called only once (when the evaluator machine is started). Augment the compiler– interpreter interface by providing a <span class="KeyTerm1">compile_and_run</span> primitive that can be called from within the explicit-control evaluator as follows:</p>
<p class="Sp-text-3"><a id="c5-para-2101"/><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c5-para-2102"/>compile_and_run(parse(ˋ</p>
<p class="Sp-text-1"><a id="c5-para-2103"/>function factorial(n) {</p>
<p class="Sp-text-1"><a id="c5-para-2104"/>    return n === 1</p>
<p class="Sp-text-1"><a id="c5-para-2105"/>           ? 1</p>
<p class="Sp-text-1"><a id="c5-para-2106"/>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c5-para-2107"/>}</p>
<p class="Sp-text-1"><a id="c5-para-2108"/>                      ˋ));</p>
<p class="Sp-text-3"><a id="c5-para-2109"/><i>EC-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c5-para-2110"/><i>undefined</i></p>
<p class="Sp-text-3"><a id="c5-para-2111"/><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c5-para-2112"/>factorial(5)</p>
<p class="Sp-text-3"><a id="c5-para-2113"/><i>EC-Eval value:</i></p>
<p class="Sp-text-3"><a id="c5-para-2114"/><i>120</i></p>
</section>
<section>
<h5><a id="c5-sec-0119"/><a id="c5-title-0120"/>Exercise 5.52</h5>
<p class="paraaftertitle"><a id="c5-para-2115"/>As an alternative to using the explicit-control evaluator's read-evaluate-print loop, design a register machine that performs a read-compile-execute-print loop. That is, the machine should run a loop that reads a program, compiles it, assembles and executes the resulting code, and prints the result. This is easy to run in our simulated setup, since we can arrange to call the functions <span class="KeyTerm1">compile</span> and <span class="KeyTerm1">assemble</span> as “register-machine operations.”</p>
</section>
<section>
<h5><a id="c5-sec-0120"/><a id="c5-title-0121"/>Exercise 5.53</h5>
<p class="paraaftertitle"><a id="c5-para-2116"/>Use the compiler to compile the metacircular evaluator of section 4.1 and run this program using the register-machine simulator. Because the parser takes a string as input, you will need to convert the program into a string. The simplest way to do this is to use the back quotes (<span class="KeyTerm1">-</span>), as we have done for the example inputs to <span class="KeyTerm1">compile_and_go</span> and <span class="KeyTerm1">compile_and_run</span>. The resulting interpreter will run very slowly because of the multiple levels of interpretation, but getting all the details to work is an instructive exercise.</p>
</section>
<section>
<h5><a id="c5-sec-0121"/><a id="c5-title-0122"/>Exercise 5.54</h5>
<p class="paraaftertitle"><a id="c5-para-2117"/>Develop a rudimentary implementation of JavaScript in C (or some other low-level language of your choice) by translating the explicit-control evaluator of section 5.4 into C. In order to run this code you will need to also provide appropriate storage-allocation routines and other runtime support.</p>
</section>
<section>
<h5><a id="c5-sec-0122"/><a id="c5-title-0123"/>Exercise 5.55</h5>
<p class="paraaftertitle"><a id="c5-para-2118"/>As a counterpoint to exercise 5.54, modify the compiler so that it compiles JavaScript functions into sequences of C instructions. Compile the metacircular evaluator of section 4.1 to produce a JavaScript interpreter written in C.</p>
</section>
</section>
</section>
</section>
<section class="BS_enoteSec">
<aside class="noteEntry"><a id="c5-fn-0001"/><a href="#c5-fn-0001a">1</a> With our metacircular evaluator, a recursive function always gives rise to a recursive process, even when the process should be iterative according to the distinction of section 1.2.1. See footnote 6 in section 4.1.1.</aside>
<aside class="noteEntry"><a id="c5-fn-0002"/><a href="#c5-fn-0002a">2</a> This assumption glosses over a great deal of complexity. Implementation of reading and printing requires significant effort, for example to handle character encodings for different languages.</aside>
<aside class="noteEntry"><a id="c5-fn-0003"/><a href="#c5-fn-0003a">3</a> One might argue that we don't need to save the old <span class="KeyTerm1">n</span>; after we decrement it and solve the subproblem, we could simply increment it to recover the old value. Although this strategy works for factorial, it cannot work in general, since the old value of a register cannot always be computed from the new one.</aside>
<aside class="noteEntry"><a id="c5-fn-0004"/><a href="#c5-fn-0004a">4</a> In section 5.3 we will see how to implement a stack in terms of more primitive operations.</aside>
<aside class="noteEntry"><a id="c5-fn-0005"/><a href="#c5-fn-0005a">5</a> Using the <span class="KeyTerm1">receive</span> function here is a way to get <span class="KeyTerm1">extract_labels</span> to effectively return two values—<span class="KeyTerm1">labels</span> and <span class="KeyTerm1">insts</span>—without explicitly making a compound data structure to hold them. An alternative implementation, which returns an explicit pair of values, is
<br/><span class="BS_Sp-text-1_FN"><b>function</b> extract_labels(controller) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>if</b> (is_null(controller)) {</span>
<br/><span class="BS_Sp-text-1_FN">        <b>return</b> pair(<b>null</b>, <b>null</b>);</span>
<br/><span class="BS_Sp-text-1_FN">    } <b>else</b> {</span>
<br/><span class="BS_Sp-text-1_FN">        <b>const</b> result = extract_labels(tail(controller));</span>
<br/><span class="BS_Sp-text-1_FN">        <b>const</b> insts = head(result);</span>
<br/><span class="BS_Sp-text-1_FN">        <b>const</b> labels = tail(result);</span>
<br/><span class="BS_Sp-text-1_FN">        <b>const</b> next_element = head(controller);</span>
<br/><span class="BS_Sp-text-1_FN">        <b>return</b> is_string(next_element)</span>
<br/><span class="BS_Sp-text-1_FN">               ? pair(insts,</span>
<br/><span class="BS_Sp-text-1_FN">                      pair(make_label_entry(next_element, insts), labels))</span>
<br/><span class="BS_Sp-text-1_FN">               : pair(pair(make_inst(next_element), insts),</span>
<br/><span class="BS_Sp-text-1_FN">                      labels);</span>
<br/><span class="BS_Sp-text-1_FN">    }</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>which would be called by <span class="KeyTerm1">assemble</span> as follows:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> assemble(controller, machine) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>const</b> result = extract_labels(controller);</span>
<br/><span class="BS_Sp-text-1_FN">    <b>const</b> insts = head(result);</span>
<br/><span class="BS_Sp-text-1_FN">    <b>const</b> labels = tail(result);</span>
<br/><span class="BS_Sp-text-1_FN">    update_insts(insts, labels, machine);</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> insts;</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>You can consider our use of <span class="KeyTerm1">receive</span> as demonstrating an elegant way to return multiple values, or simply an excuse to show off a programming trick. An argument like <span class="KeyTerm1">receive</span> that is the next function to be invoked is called a “continuation.” Recall that we also used continuations to implement the backtracking control structure in the <span class="KeyTerm1">amb</span> evaluator in section 4.3.3.</aside>
<aside class="noteEntry"><a id="c5-fn-0006"/><a href="#c5-fn-0006a">6</a> We could represent memory as lists of items. However, the access time would then not be independent of the index, since accessing the <i>n</i>th element of a list requires <i>n</i> – 1 <span class="KeyTerm1">tail</span> operations.</aside>
<aside class="noteEntry"><a id="c5-fn-0007"/><a href="#c5-fn-0007a">7</a> As mentioned in section 4.1.4 (footnote 18), JavaScript supports vectors as data structures and calls them “arrays.” We use the term <i>vector</i> in this book, as it is the more common terminology. The vector functions above are easily implemented using JavaScript's primitive array support.</aside>
<aside class="noteEntry"><a id="c5-fn-0008"/><a href="#c5-fn-0008a">8</a> For completeness, we should specify a <span class="KeyTerm1">make_vector</span> operation that constructs vectors. However, in the present application we will use vectors only to model fixed divisions of the computer memory.</aside>
<aside class="noteEntry"><a id="c5-fn-0009"/><a href="#c5-fn-0009a">9</a> This is precisely the same “tagged data” idea we introduced in chapter 2 for dealing with generic operations. Here, however, the data types are included at the primitive machine level rather than constructed through the use of lists.
<br/>  Type information may be encoded in a variety of ways, depending on the details of the machine on which the JavaScript system is to be implemented. The execution efficiency of JavaScript programs will be strongly dependent on how cleverly this choice is made, but it is difficult to formulate general design rules for good choices. The most straightforward way to implement typed pointers is to allocate a fixed set of bits in each pointer to be a <i>type field</i> that encodes the data type. Important questions to be addressed in designing such a representation include the following: How many type bits are required? How large must the vector indices be? How efficiently can the primitive machine instructions be used to manipulate the type fields of pointers? Machines that include special hardware for the efficient handling of type fields are said to have <i>tagged architectures</i>.</aside>
<aside class="noteEntry"><a id="c5-fn-0010"/><a href="#c5-fn-0010a">10</a> This decision on the representation of numbers determines whether <span class="KeyTerm1">===</span>, which tests equality of pointers, can be used to test for equality of numbers. If the pointer contains the number itself, then equal numbers will have the same pointer. But if the pointer contains the index of a location where the number is stored, equal numbers will be guaranteed to have equal pointers only if we are careful never to store the same number in more than one location.</aside>
<aside class="noteEntry"><a id="c5-fn-0011"/><a href="#c5-fn-0011a">11</a> This is just like writing a number as a sequence of digits, except that each “digit” is a number between 0 and the largest number that can be stored in a single pointer.</aside>
<aside class="noteEntry"><a id="c5-fn-0012"/><a href="#c5-fn-0012a">12</a> There are other ways of finding free storage. For example, we could link together all the unused pairs into a <i>free list</i>. Our free locations are consecutive (and hence can be accessed by incrementing a pointer) because we are using a compacting garbage collector, as we will see in section 5.3.2.</aside>
<aside class="noteEntry"><a id="c5-fn-0013"/><a href="#c5-fn-0013a">13</a> This is essentially the implementation of <span class="KeyTerm1">pair</span> in terms of <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span>, as described in section 3.3.1. The operation <span class="KeyTerm1">get_new_pair</span> used in that implementation is realized here by the <span class="KeyTerm1">free</span> pointer.</aside>
<aside class="noteEntry"><a id="c5-fn-0014"/><a href="#c5-fn-0014a">14</a> This may not be true eventually, because memories may get large enough so that it would be impossible to run out of free memory in the lifetime of the computer. For example, there are about 3 10<sup>16</sup> nanoseconds in a year, so if we were to <span class="KeyTerm1">pair</span> once per nanosecond we would need about 10<sup>18</sup> cells of memory to build a machine that could operate for 30 years without running out of memory. That much memory seems absurdly large by today's standards, but it is not physically impossible. On the other hand, processors are getting faster and modern computers have increasingly large numbers of processors operating in parallel on a single memory, so it may be possible to use up memory much faster than we have postulated.</aside>
<aside class="noteEntry"><a id="c5-fn-0015"/><a href="#c5-fn-0015a">15</a> We assume here that the stack is represented as a list as described in section 5.3.1, so that items on the stack are accessible via the pointer in the stack register.</aside>
<aside class="noteEntry"><a id="c5-fn-0016"/><a href="#c5-fn-0016a">16</a> This idea was invented and first implemented by Minsky, as part of the implementation of Lisp for the PDP-1 at the MIT Research Laboratory of Electronics. It was further developed by Fenichel and Yochelson (1969) for use in the Lisp implementation for the Multics timesharing system. Later, Baker (1978) developed a “real-time” version of the method, which does not require the computation to stop during garbage collection. Baker's idea was extended by Hewitt, Lieberman, and Moon (see Lieberman and Hewitt 1983) to take advantage of the fact that some structure is more volatile and other structure is more permanent.
<br/>  An alternative commonly used garbage-collection technique is the <i>mark-sweep</i> method. This consists of tracing all the structure accessible from the machine registers and marking each pair we reach. We then scan all of memory, and any location that is unmarked is “swept up” as garbage and made available for reuse. A full discussion of the mark-sweep method can be found in Allen 1978.
<br/>  The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in use for largememory systems because it examines only the useful part of memory. This is in contrast to mark-sweep, in which the sweep phase must check all of memory. A second advantage of stop-and-copy is that it is a <i>compacting</i> garbage collector. That is, at the end of the garbagecollection phase the useful data will have been moved to consecutive memory locations, with all garbage pairs compressed out. This can be an extremely important performance consideration in machines with virtual memory, in which accesses to widely separated memory addresses may require extra paging operations.</aside>
<aside class="noteEntry"><a id="c5-fn-0017"/><a href="#c5-fn-0017a">17</a> This list of registers does not include the registers used by the storage-allocation system: <span class="KeyTerm1">root</span>, <span class="KeyTerm1">the_heads</span>, <span class="KeyTerm1">the_tails</span>, and the other registers that will be introduced in this section.</aside>
<aside class="noteEntry"><a id="c5-fn-0018"/><a href="#c5-fn-0018a">18</a> The term <i>broken heart</i> was coined by David Cressey, who wrote a garbage collector for MDL, a dialect of Lisp developed at MIT during the early 1970s.</aside>
<aside class="noteEntry"><a id="c5-fn-0019"/><a href="#c5-fn-0019a">19</a> The garbage collector uses the low-level predicate <span class="KeyTerm1">is_pointer_to_pair</span> instead of the liststructure <span class="KeyTerm1">is_pair</span> operation because in a real system there might be various things that are treated as pairs for garbage-collection purposes. For example, a function object may be implemented as a special kind of “pair” that doesn't satisfy the <span class="KeyTerm1">is_pair</span> predicate. For simulation purposes, <span class="KeyTerm1">is_pointer_to_pair</span> can be implemented as <span class="KeyTerm1">is_pair</span>.</aside>
<aside class="noteEntry"><a id="c5-fn-0020"/><a href="#c5-fn-0020a">20</a> See Batali et al. 1982 for more information on the chip and the method by which it was designed.</aside>
<aside class="noteEntry"><a id="c5-fn-0021"/><a href="#c5-fn-0021a">21</a> In our controller, the dispatch is written as a sequence of <span class="KeyTerm1">test</span> and <span class="KeyTerm1">branch</span> instructions. Alternatively, it could have been written in a data-directed style, which avoids the need to perform sequential tests and facilitates the definition of new component types.</aside>
<aside class="noteEntry"><a id="c5-fn-0022"/><a href="#c5-fn-0022a">22</a> In this chapter, we will use the function <span class="KeyTerm1">is_falsy</span> to test the value of the predicate. This allows us to write the consequent and alternative branches in the same order as in a conditional, and simply fall through to the consequent branch when the predicate holds. The function <span class="KeyTerm1">is_falsy</span> is declared as the opposite of the <span class="KeyTerm1">is_truthy</span> function used to test predicates of conditionals in section 4.1.1.</aside>
<aside class="noteEntry"><a id="c5-fn-0023"/><a href="#c5-fn-0023a">23</a> This is an important but subtle point in translating algorithms from a procedural language, such as JavaScript, to a register-machine language. As an alternative to saving only what is needed, we could save all the registers (except <span class="KeyTerm1">val</span>) before each recursive call. This is called a <i>framed-stack</i> discipline. This would work but might save more registers than necessary; this could be an important consideration in a system where stack operations are expensive. Saving registers whose contents will not be needed later may also hold on to useless data that could otherwise be garbage-collected, freeing space to be reused.</aside>
<aside class="noteEntry"><a id="c5-fn-0024"/><a href="#c5-fn-0024a">24</a> We assume that the syntax transformer <span class="KeyTerm1">operator_combination_to_application</span> is available as a machine operation. In an actual implementation built from scratch, we would use our explicit-control evaluator to interpret a JavaScript program that performs source-level transformations like this one and <span class="KeyTerm1">function_decl_to_constant_decl</span> in a syntax phase that runs before execution.</aside>
<aside class="noteEntry"><a id="c5-fn-0025"/><a href="#c5-fn-0025a">25</a> We add to the evaluator data-structure functions in section 4.1.3 the following two functions for manipulating argument lists:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> empty_arglist() { <b>return null</b>; }</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> adjoin_arg(arg, arglist) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> append(arglist, list(arg));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>We also make use of an additional syntax function to test for the last argument expression in an application:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> is_last_argument_expression(arg_expression) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> is_null(tail(arg_expression));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c5-fn-0026"/><a href="#c5-fn-0026a">26</a> The optimization of treating the last argument expression specially is known as <i>evlis tail recursion</i> (see Wand 1980). We could be somewhat more efficient in the argument evaluation loop if we made evaluation of the first argument expression a special case too. This would permit us to postpone initializing <span class="KeyTerm1">argl</span> until after evaluating the first argument expression, so as to avoid saving <span class="KeyTerm1">argl</span> in this case. The compiler in section 5.5 performs this optimization. (Compare the <span class="KeyTerm1">construct_arglist</span> function of section 5.5.3.)</aside>
<aside class="noteEntry"><a id="c5-fn-0027"/><a href="#c5-fn-0027a">27</a> The order of argument-expression evaluation by the function <span class="KeyTerm1">list_of_values</span> in the metacircular evaluator is determined by the order of evaluation of the arguments to <span class="KeyTerm1">pair</span>, which is used to construct the argument list. The version of <span class="KeyTerm1">list_of_values</span> in footnote 7 of section 4.1 calls <span class="KeyTerm1">pair</span> directly; the version in the text uses <span class="KeyTerm1">map</span>, which calls <span class="KeyTerm1">pair</span>. (See exercise 4.1.)</aside>
<aside class="noteEntry"><a id="c5-fn-0028"/><a href="#c5-fn-0028a">28</a> The special instructions <span class="KeyTerm1">push_marker_to_stack</span> and <span class="KeyTerm1">revert_stack_to_marker</span> are not strictly necessary and could be implemented by explicitly pushing and popping a marker value onto and off the stack. Anything that could not be confused with a value in the program can be used as a marker. See exercise 5.23.</aside>
<aside class="noteEntry"><a id="c5-fn-0029"/><a href="#c5-fn-0029a">29</a> We saw in section 5.1 how to implement such a process with a register machine that had no stack; the state of the process was stored in a fixed set of registers.</aside>
<aside class="noteEntry"><a id="c5-fn-0030"/><a href="#c5-fn-0030a">30</a> This implementation of tail recursion is one variety of a well-known optimization technique used by many compilers. In compiling a function that ends with a function call, one can replace the call by a jump to the called function's entry point. Building this strategy into the interpreter, as we have done in this section, provides the optimization uniformly throughout the language.</aside>
<aside class="noteEntry"><a id="c5-fn-0031"/><a href="#c5-fn-0031a">31</a> Footnote 24 suggests that an actual implementation would perform syntax transformations before program execution. In the same vein, names declared in blocks should be scanned out in a preprocessing step rather than each time a block is evaluated.</aside>
<aside class="noteEntry"><a id="c5-fn-0032"/><a href="#c5-fn-0032a">32</a> We assume here that <span class="KeyTerm1">user_read</span>, <span class="KeyTerm1">parse</span>, and the various printing operations are available as primitive machine operations, which is useful for our simulation, but completely unrealistic in practice. These are actually extremely complex operations. In practice, reading and printing would be implemented using low-level input-output operations such as transferring single characters to and from a device.</aside>
<aside class="noteEntry"><a id="c5-fn-0033"/><a href="#c5-fn-0033a">33</a> There are other errors that we would like the interpreter to handle, but these are not so simple. See exercise 5.31.</aside>
<aside class="noteEntry"><a id="c5-fn-0034"/><a href="#c5-fn-0034a">34</a> We could perform the stack initialization only after errors, but doing it in the driver loop will be convenient for monitoring the evaluator's performance, as described below.</aside>
<aside class="noteEntry"><a id="c5-fn-0035"/><a href="#c5-fn-0035a">35</a> This manifests itself as, for example, a “kernel panic” or a “blue screen of death” or even a reboot. Automatic rebooting is an approach typically used on phones and tablets. Most modern operating systems do a decent job of preventing user programs from causing an entire machine to crash.</aside>
<aside class="noteEntry"><a id="c5-fn-0036"/><a href="#c5-fn-0036a">36</a> This is a theoretical statement. We are not claiming that the evaluator's data paths are a particularly convenient or efficient set of data paths for a general-purpose computer. For example, they are not very good for implementing high-performance floating-point calculations or calculations that intensively manipulate bit vectors.</aside>
<aside class="noteEntry"><a id="c5-fn-0037"/><a href="#c5-fn-0037a">37</a> Actually, the machine that runs compiled code can be simpler than the interpreter machine, because we won't use the <span class="KeyTerm1">comp</span> and <span class="KeyTerm1">unev</span> registers. The interpreter used these to hold pieces of unevaluated components. With the compiler, however, these components get built into the compiled code that the register machine will run. For the same reason, we don't need the machine operations that deal with component syntax. But compiled code will use a few additional machine operations (to represent compiled function objects) that didn't appear in the explicit-control evaluator machine.</aside>
<aside class="noteEntry"><a id="c5-fn-0038"/><a href="#c5-fn-0038a">38</a> Language implementations often delay the compilation of program parts even when they are assumed to be debugged, until there is enough evidence that compiling them would lead to an overall efficiency advantage. The evidence is obtained at run time by monitoring the number of times the program parts are being interpreted. This technique is called <i>just-in-time compilation</i>.</aside>
<aside class="noteEntry"><a id="c5-fn-0039"/><a href="#c5-fn-0039a">39</a> Notice, however, that our compiler is a JavaScript program, and the syntax functions that it uses to manipulate expressions are the actual JavaScript functions used with the metacircular evaluator. For the explicit-control evaluator, in contrast, we assumed that equivalent syntax operations were available as operations for the register machine. (Of course, when we simulated the register machine in JavaScript, we used the actual JavaScript functions in our register machine simulation.)</aside>
<aside class="noteEntry"><a id="c5-fn-0040"/><a href="#c5-fn-0040a">40</a> We can't just use the labels <span class="KeyTerm1">true_branch</span>, <span class="KeyTerm1">false_branch</span>, and <span class="KeyTerm1">after_cond</span> as shown above, because there might be more than one conditional in the program. The compiler uses the function <span class="KeyTerm1">make_label</span> to generate labels. The function <span class="KeyTerm1">make_label</span> takes a string as argument and returns a new string that begins with the given string. For example, successive calls to <span class="KeyTerm1">make_label("a")</span> would return <span class="KeyTerm1">"a1"</span>, <span class="KeyTerm1">"a2"</span>, and so on. The function <span class="KeyTerm1">make_label</span> can be implemented similarly to the generation of unique variable names in the query language, as follows
<br/><span class="BS_Sp-text-1_FN"><b>let</b> label_counter = 0;</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> new_label_number() {</span>
<br/><span class="BS_Sp-text-1_FN">    label_counter = label_counter + 1;</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> label_counter;</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> make_label(string) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> string + stringify(new_label_number());</span>
<br/><span class="BS_Sp-text-1_FN">}:</span>
</aside>
<aside class="noteEntry"><a id="c5-fn-0041"/><a href="#c5-fn-0041a">41</a> The <span class="KeyTerm1">continue</span> register would be needed for a <span class="KeyTerm1">"return"</span> linkage, which can result from a compilation by <span class="KeyTerm1">compile_and_go</span> (section 5.5.7).</aside>
<aside class="noteEntry"><a id="c5-fn-0042"/><a href="#c5-fn-0042a">42</a> Our compiler does not detect all dead code. For example, a conditional statement whose consequent and alternative branches both end in a return statement will not stop subsequent statements from being compiled. See exercises 5.34 and 5.35.</aside>
<aside class="noteEntry"><a id="c5-fn-0043"/><a href="#c5-fn-0043a">43</a> We need machine operations to implement a data structure for representing compiled functions, analogous to the structure for compound functions described in section 4.1.3:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> make_compiled_function(entry, env) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> list("compiled_function", entry, env);</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> is_compiled_function(fun) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> is_tagged_list(fun, "compiled_function");</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> compiled_function_entry(c_fun) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> head(tail(c_fun));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> compiled_function_env(c_fun) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> head(tail(tail(c_fun)));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c5-fn-0044"/><a href="#c5-fn-0044a">44</a> The augmented function body is a sequence ending with a return statement. Compilation of a sequence of statements uses the linkage <span class="KeyTerm1">"next"</span> for all its component statements except the last, for which it uses the given linkage. In this case, the last statement is a return statement, and as we will see in section 5.5.3, a return statement always uses the <span class="KeyTerm1">"return"</span> linkage descriptor for its return expression. Thus all function bodies will end with a <span class="KeyTerm1">"return"</span> linkage, not the <span class="KeyTerm1">"next"</span> we pass as the linkage argument to <span class="KeyTerm1">compile</span> in <span class="KeyTerm1">compile_lambda_body</span>.</aside>
<aside class="noteEntry"><a id="c5-fn-0045"/><a href="#c5-fn-0045a">45</a> Because the execution of a function body always ends with a return, there is no need here for a mechanism like the <span class="KeyTerm1">return_undefined</span> entry point from section 5.4.2.</aside>
<aside class="noteEntry"><a id="c5-fn-0046"/><a href="#c5-fn-0046a">46</a> Elsewhere in the compiler, all saves and restores of registers are generated by <span class="KeyTerm1">preserving</span> to preserve a register's value across a sequence of instructions by saving it before those instructions and restoring it after—for example over the evaluation of the predicate of a conditional. But this mechanism cannot generate instructions to save and restore <span class="KeyTerm1">continue</span> for a function application and the corresponding return, because these are compiled separately and are not contiguous. Instead, these saves and restores must be explicitly generated by <span class="KeyTerm1">compile_fun_appl</span> and <span class="KeyTerm1">compile_return_statement</span>.</aside>
<aside class="noteEntry"><a id="c5-fn-0047"/><a href="#c5-fn-0047a">47</a> Actually, we signal an error when the target is not <span class="KeyTerm1">val</span> and the linkage is <span class="KeyTerm1">"return"</span>, since the only place we request a <span class="KeyTerm1">"return"</span> linkage is in compiling return expressions, and our convention is that functions return their values in <span class="KeyTerm1">val</span>.</aside>
<aside class="noteEntry"><a id="c5-fn-0048"/><a href="#c5-fn-0048a">48</a> Making a compiler generate tail-recursive code is desirable, especially in the functional paradigm. However, compilers for common languages, including C and C++, do not always do this, and therefore these languages cannot represent iterative processes in terms of function call alone. The difficulty with tail recursion in these languages is that their implementations use the stack to store function arguments and local names as well as return addresses. The JavaScript implementations described in this book store arguments and names in memory to be garbage-collected. The reason for using the stack for names and arguments is that it avoids the need for garbage collection in languages that would not otherwise require it, and is generally believed to be more efficient. Sophisticated compilers can, in fact, use the stack for arguments without destroying tail recursion. (See Hanson 1990 for a description.) There is also some debate about whether stack allocation is actually more efficient than garbage collection in the first place, but the details seem to hinge on fine points of computer architecture. (See Appel 1987 and Miller and Rozas 1994 for opposing views on this issue.)</aside>
<aside class="noteEntry"><a id="c5-fn-0049"/><a href="#c5-fn-0049a">49</a> The constant <span class="KeyTerm1">all_regs</span> is bound to the list of names of all the registers:
<br/><span class="BS_Sp-text-1_FN"><b>const</b> all_regs = list("env", "fun", "val", "argl", "continue");</span>
</aside>
<aside class="noteEntry"><a id="c5-fn-0050"/><a href="#c5-fn-0050a">50</a> Because of the <span class="KeyTerm1">append_return_undefined</span> in <span class="KeyTerm1">compile_lambda_body</span>, the body actually consists of a sequence with two return statements. However, the dead-code check in <span class="KeyTerm1">compile_ sequence</span> will stop after the compilation of the first return statement, so the body effectively consists of only a single return statement.</aside>
<aside class="noteEntry"><a id="c5-fn-0051"/><a href="#c5-fn-0051a">51</a> We have used the same symbol <span class="KeyTerm1">+</span> here to denote both the source-language function and the machine operation. In general there will not be a one-to-one correspondence between primitives of the source language and primitives of the machine.</aside>
<aside class="noteEntry"><a id="c5-fn-0052"/><a href="#c5-fn-0052a">52</a> Of course, compiled functions as well as interpreted functions are compound (nonprimitive). For compatibility with the terminology used in the explicit-control evaluator, in this section we will use “compound” to mean interpreted (as opposed to compiled).</aside>
<aside class="noteEntry"><a id="c5-fn-0053"/><a href="#c5-fn-0053a">53</a> Now that the evaluator machine starts with a <span class="KeyTerm1">branch</span>, we must always initialize the <span class="KeyTerm1">flag</span> register before starting the evaluator machine. To start the machine at its ordinary read-evaluate-print loop, we could use
<br/><span class="BS_Sp-text-1_FN"><b>function</b> start_eceval() {</span>
<br/><span class="BS_Sp-text-1_FN">    set_register_contents(eceval, "flag", <b>false</b>);</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> start(eceval);</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c5-fn-0054"/><a href="#c5-fn-0054a">54</a> Since a compiled function is an object that the system may try to print, we also modify the system print operation <span class="KeyTerm1">user_print</span> (from section 4.1.4) so that it will not attempt to print the components of a compiled function:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> user_print(string, object) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>function</b> prepare(object) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> is_compound_function(object)</span>
<br/><span class="BS_Sp-text-1_FN">           ? "&lt; compound function &gt;"</span>
<br/><span class="BS_Sp-text-1_FN">           : is_primitive_function(object)</span>
<br/><span class="BS_Sp-text-1_FN">           ? "&lt; primitive function &gt;"</span>
<br/><span class="BS_Sp-text-1_FN">           : is_compiled_function(object)</span>
<br/><span class="BS_Sp-text-1_FN">           ? "&lt; compiled function &gt;"</span>
<br/><span class="BS_Sp-text-1_FN">           : is_pair(object)</span>
<br/><span class="BS_Sp-text-1_FN">           ? pair(prepare(head(object)),</span>
<br/><span class="BS_Sp-text-1_FN">                  prepare(tail(object)))</span>
<br/><span class="BS_Sp-text-1_FN">           : object;</span>
<br/><span class="BS_Sp-text-1_FN">    }</span>
<br/><span class="BS_Sp-text-1_FN">    display(string + " " + stringify(prepare(object)));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c5-fn-0055"/><a href="#c5-fn-0055a">55</a> We can do even better by extending the compiler to allow compiled code to call interpreted functions. See exercise 5.50.</aside>
<aside class="noteEntry"><a id="c5-fn-0056"/><a href="#c5-fn-0056a">56</a> Independent of the strategy of execution, we incur significant overhead if we insist that errors encountered in execution of a user program be detected and signaled, rather than being allowed to kill the system or produce wrong answers. For example, an out-of-bounds array reference can be detected by checking the validity of the reference before performing it. The overhead of checking, however, can be many times the cost of the array reference itself, and a programmer should weigh speed against safety in determining whether such a check is desirable. A good compiler should be able to produce code with such checks, should avoid redundant checks, and should allow programmers to control the extent and type of error checking in the compiled code.
<br/>  Compilers for popular languages, such as C and C++, put hardly any error-checking operations into running code, so as to make things run as fast as possible. As a result, it falls to programmers to explicitly provide error checking. Unfortunately, people often neglect to do this, even in critical applications where speed is not a constraint. Their programs lead fast and dangerous lives. For example, the notorious “Worm” that paralyzed the Internet in 1988 exploited the UNIX<sup>TM</sup> operating system's failure to check whether the input buffer has overflowed in the finger daemon. (See Spafford 1989.)</aside>
<aside class="noteEntry"><a id="c5-fn-0057"/><a href="#c5-fn-0057a">57</a> Of course, with either the interpretation or the compilation strategy we must also implement for the new machine storage allocation, input and output, and all the various operations that we took as “primitive” in our discussion of the evaluator and compiler. One strategy for minimizing work here is to write as many of these operations as possible in JavaScript and then compile them for the new machine. Ultimately, everything reduces to a small kernel (such as garbage collection and the mechanism for applying actual machine primitives) that is hand-coded for the new machine.</aside>
<aside class="noteEntry"><a id="c5-fn-0058"/><a href="#c5-fn-0058a">58</a> This strategy leads to amusing tests of correctness of the compiler, such as checking whether the compilation of a program on the new machine, using the compiled compiler, is identical with the compilation of the program on the original JavaScript system. Tracking down the source of differences is fun but often frustrating, because the results are extremely sensitive to minuscule details.</aside>
</section>
</section>
</body>
</html>