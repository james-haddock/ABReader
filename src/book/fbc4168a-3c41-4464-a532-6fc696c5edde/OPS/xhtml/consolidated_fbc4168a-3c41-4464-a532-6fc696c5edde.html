<html><head><link href="../styles/MIT_index.css" rel="stylesheet"/><link href="../styles/MIT_style.css" rel="stylesheet"/></head><body><body epub:type="cover"><section style="margin-top:0px; margin-left:0px; margin-right:0px; margin-bottom:0px; text-align:center;"><div id="cover_cover"><img alt="image" src="../images/9780262543231_FC.jpg" style="max-height:100%; max-width:100%; text-align:center;"/></div></section></body><body epub:type="frontmatter">
<section>
<header><a id="c000_1_d2e43"></a>
</header>
<section>
<p class="BS_bookHalftitle">Structure and Interpretation of Computer Programs</p>
<p class="BS_bookEdition">JavaScript Edition</p>
</section>
</section>
</body><body epub:type="frontmatter">
<section>
<header><a id="c000_2_d2e43"></a>
</header>
<section>
<p class="BS_bookTitle">Structure and Interpretation of Computer Programs</p>
<p class="BS_bookEdition">JavaScript Edition</p>
<p class="BS_bookAuthor1">Harold Abelson and Gerald Jay Sussman</p>
<p class="BS_bookAuthor2">adapted to JavaScript by Martin Henz and Tobias Wrigstad <br/>with Julie Sussman</p>
<p class="BS_bookImprint1">The MIT Press</p>
<p class="BS_bookImprint2">Cambridge, Massachusetts</p>
<p class="BS_bookImprint2">London, England</p>
</section>
</section>
</body><body epub:type="frontmatter">
<section>
<header><a id="c000_3_d2e43"></a>
</header>
<section>
<div class="BS_copyrightSec">
<p class="BS_copyright">© 2022 Massachusetts Institute of Technology</p>
</div>
<div class="BS_copyrightSec">
<p class="BS_copyright">This book is published by The MIT Press under a Creative Commons</p>
<p class="BS_copyright">Attribution-NonCommercial-ShareAlike 4.0 International License (CC BY-NC-SA). To view a copy of this license, visit <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">http://creativecommons.org/licenses/by-nc-sa/4.0/</a>.</p>
<p class="BS_copyright3"><img alt="f1-fig-5001.jpg" src="../images/f1-fig-5001.jpg"/></p>
</div>
<div class="BS_copyrightSec">
<p class="BS_copyright">The text of this book is derived from the book <i>Structure and Interpretation of Computer Programs, Second Edition</i>, 1996, (SICP) and is subject to a Creative Commons</p>
<p class="BS_copyright">Attribution-ShareAlike 4.0 International License (CC BY-SA). A comparison edition available at <a href="http://sicp.sourceacademy.org">http://sicp.sourceacademy.org</a> indicates the changes that were made to the text. The figures are derived from figures created by Andres Raba in 2015 and are also subject to CC BY-SA. To view a copy of this license, visit <a href="http://creativecommons.org/licenses/by-sa/4.0/">http://creativecommons.org/licenses/by-sa/4.0/</a>.</p>
<p class="BS_copyright3"><img alt="f1-fig-5002.jpg" src="../images/f1-fig-5002.jpg"/></p>
</div>
<div class="BS_copyrightSec">
<p class="BS_copyright">The JavaScript programs in this book are derived from the Scheme programs in SICP and are subject to the GNU General Public License v3.0. To view a copy of this license, visit <a href="https://www.gnu.org/licenses/gpl-3.0.html">https://www.gnu.org/licenses/gpl-3.0.html</a>.</p>
<p class="BS_copyright3"><img alt="f1-fig-5003.jpg" src="../images/f1-fig-5003.jpg"/></p>
</div>
<div class="BS_copyrightSec">
<p class="BS_copyright">The original image of MIT founder William Barton Rogers in section 2.2.4 is courtesy MIT Museum.</p>
</div>
<div class="BS_copyrightSec">
<p class="BS_copyright">The cover image is adapted from <i>Le Moyen Age et la Renaissance</i>, Paris, 1848–1851.</p>
</div>
<div class="BS_copyrightSec">
<p class="BS_copyright">This book was set in Times by the authors using the <img alt="f1-fig-5004.jpg" src="../images/f1-fig-5004.jpg"/> typesetting system and ancillary scripts (see <a href="https://github.com/source-academy/sicp">https://github.com/source-academy/sicp</a>)<!--, and was printed and bound in the United States of America-->.</p>
</div>
<div class="BS_copyrightSec">
<p class="BS_copyright">Library of Congress Cataloging-in-Publication Data</p>
</div>
<div class="BS_copyrightSec">
<p class="BS_copyright2">Names: Abelson, Harold, author. | Sussman, Gerald Jay, author. | Henz, Martin, adapter. | Wrigstad, Tobias, adapter. | Sussman, Julie, other.</p>
<p class="BS_copyright2">Title: Structure and interpretation of computer programs / Harold Abelson and Gerald Jay Sussman; adapted to JavaScript by Martin Henz and Tobias Wrigstad; with Julie Sussman.</p>
<p class="BS_copyright2">Description: Javascript edition. | Cambridge : The MIT Press, [2022] | Series: MIT electrical engineering and computer science series | Includes bibliographical references and index.</p>
<p class="BS_copyright2">Identifiers: LCCN 2021047249 | ISBN 9780262543231 (paperback)</p>
<p class="BS_copyright2">Subjects: LCSH: Computer programming. | JavaScript (Computer program language) </p>
<p class="BS_copyright2">Classification: LCC QA76.6 .A255 2022 | DDC 005.13–dc23</p>
<p class="BS_copyright2">LC record available at <a href="https://lccn.loc.gov/2021047249">https://lccn.loc.gov/2021047249</a> </p>
</div>
<div class="BS_copyrightSec">
<p class="BS_copyright">10 9 8 7 6 5 4 3 2 1</p>
</div>
</section>
</section>
<p id="c000_3_release_identifier_line" style="font-size: .9em; margin: 1.5em 0 0 0; text-align: center;">d_r0</p></body><body epub:type="frontmatter">
<section>
<header><a id="c000_4_d2e43"></a>
</header>
<section>
<p class="BS_dedication">This book is dedicated, in respect and admiration, <br/>to the spirit that lives in the computer.</p>
</section>
</section>
</body><body epub:type="frontmatter">
<section>
<header><a id="c000_5_d2e43"></a>
</header>
<section>
<blockquote class="quote-BookEpigraph">
<p class="quote-BookEpigraphparafirst">“I think it's extraordinarily important that we in computer science keep fun in computing. When it started out, it was an awful lot of fun. Of course, the paying customers got shafted every now and then, and after a while we began to take their complaints seriously. We began to feel as though we really were responsible for the successful, error-free, perfect use of these machines. I don't think we are. I think we're responsible for stretching them, setting them off in new directions, and keeping fun in the house. Fun comes in many ways. Fun comes in making a discovery, proving a theorem, writing a program, breaking a code. Whatever form or sense it comes in I hope the field of computer science never loses its sense of fun. Above all, I hope we don't become missionaries. What you know about computing other people will learn. Don't feel as though the key to successful computing is only in your hands. What's in your hands, I think and hope, is intelligence: the ability to see the machine as more than when you were first led up to it, that you can make it more.”</p>
<p class="quote-BookEpigraphsource">—Alan J. Perlis (April 1, 1922–February 7, 1990)</p></blockquote>
</section>
</section>
</body><body><a id="contents_contents"></a>
<nav epub:type="toc" id="contents_toc">
<h1 class="title">Contents</h1>
<ol>
<li class="contentsH1"><a href="#cover_cover">Cover</a></li>
<li class="contentsH1"><a href="#c000a_f2-title-0001">Foreword</a></li>
<li class="contentsH1"><a href="#c000b_f3-title-0001">Foreword to Structure and Interpretation of Computer Programs, 1984</a></li>
<li class="contentsH1"><a href="#c000c_f4-title-0001">Preface</a></li>
<li class="contentsH1"><a href="#c000d_f5-title-0001">Prefaces to Structure and Interpretation of Computer Programs, 1996 &amp; 1984</a></li>
<li class="contentsH1"><a href="#c000e_f6-title-0001">Acknowledgments</a></li>
<li class="contentsH1"><a href="#c001_c1-title-0001">1: Building Abstractions with Functions</a></li>
<li class="contentsH1"><a href="#c002_c2-title-0001">2: Building Abstractions with Data</a></li>
<li class="contentsH1"><a href="#c003_c3-title-0001">3: Modularity, Objects, and State</a></li>
<li class="contentsH1"><a href="#c004_c4-title-0001">4: Metalinguistic Abstraction</a></li>
<li class="contentsH1"><a href="#c005_c5-title-0001">5: Computing with Register Machines</a></li>
<li class="contentsH1"><a href="#c444_b1-title-0001">References</a></li>
<li class="contentsH1"><a href="#c555_b2-title-0001">Index</a></li>
<li class="contentsH1"><a href="#c800_b2-title-0001">List of Exercises</a></li>
</ol>
</nav>
<nav epub:type="loi" id="contents_figurelist">
<h2>List of figures</h2>
<ol>
<li class="contentsH1"><span>Chapter 1</span>
<ol>
<li class="contentsH1"><a href="#c001_c1-fig-0001">Figure 1.1 Tree representation, showing the value of each subexpression.</a></li>
<li class="contentsH1"><a href="#c001_c1-fig-0008">Figure 1.2 Functional decomposition of the sqrt program.</a></li>
<li class="contentsH1"><a href="#c001_c1-fig-0009">Figure 1.3 A linear recursive process for computing 6!.</a></li>
<li class="contentsH1"><a href="#c001_c1-fig-0010">Figure 1.4 A linear iterative process for computing 6!.</a></li>
<li class="contentsH1"><a href="#c001_c1-fig-0012">Figure 1.5 The tree-recursive process generated in computing fib(5).</a></li>
</ol></li>
<li class="contentsH1"><span>Chapter 2</span>
<ol>
<li class="contentsH1"><a href="#c002_c2-fig-0002">Figure 2.1 Data-abstraction barriers in the rational-number package.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0007">Figure 2.2 Box-and-pointer representation of pair(1, 2).</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0008">Figure 2.3 Two ways to combine 1, 2, 3, and 4 using pairs.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0009">Figure 2.4 The sequence 1, 2, 3, 4 represented as a chain of pairs.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0010">Figure 2.5 Structure formed by pair(list(1, 2), list(3, 4)).</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0011">Figure 2.6 The list structure in figure 2.5 viewed as a tree.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0012">Figure 2.7 The signal-flow plans for the functions sum_odd_squares (top) and ev…</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0015">Figure 2.8 A solution to the eight-queens puzzle.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0016">Figure 2.9 Designs generated with the picture language.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0017">Figure 2.10 Images produced by the wave painter, with respect to four different…</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0018">Figure 2.11 Images of William Barton Rogers, founder and first president of MIT…</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0019">Figure 2.12 Creating a complex figure, starting from the wave painter of figure…</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0020">Figure 2.13 Recursive plans for right_split and corner_split.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0021">Figure 2.14 The recursive operation right_split applied to the painters wave an…</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0022">Figure 2.15 A frame is described by three vectors—an origin and two edges.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0026">Figure 2.16 Various binary trees that represent the set {1, 3, 5, 7, 9, 11}.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0027">Figure 2.17 Unbalanced tree produced by adjoining 1 through 7 in sequence.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0028">Figure 2.18 A Huffman encoding tree.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0029">Figure 2.19 Data-abstraction barriers in the complex-number system.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0030">Figure 2.20 Complex numbers as points in the plane.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0031">Figure 2.21 Structure of the generic complex-arithmetic system.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0032">Figure 2.22 Table of operations for the complex-number system.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0033">Figure 2.23 Generic arithmetic system.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0034">Figure 2.24 Representation of 3 + 4i in rectangular form.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0035">Figure 2.25 A tower of types.</a></li>
<li class="contentsH1"><a href="#c002_c2-fig-0036">Figure 2.26 Relations among types of geometric figures.</a></li>
</ol></li>
<li class="contentsH1"><span>Chapter 3</span>
<ol>
<li class="contentsH1"><a href="#c003_c3-fig-0001">Figure 3.1 A simple environment structure.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0002">Figure 3.2 Environment structure produced by evaluating function square(x) { re…</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0003">Figure 3.3 Environment created by evaluating square(5) in the program environme…</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0004">Figure 3.4 Function objects in the program frame.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0005">Figure 3.5 Environments created by evaluating f(5) using the functions in figur…</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0006">Figure 3.6 Result of defining make_withdraw in the program environment.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0007">Figure 3.7 Result of evaluating const W1 = make_withdraw(100);.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0008">Figure 3.8 Environments created by applying the function object W1.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0009">Figure 3.9 Environments after the call to W1.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0010">Figure 3.10 Using const W2 = make_withdraw(100); to create a second object.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0011">Figure 3.11 The sqrt function with internal declarations.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0012">Figure 3.12 Lists x: list(list("a", "b"), "c", "d") and y: list("e", "f").</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0013">Figure 3.13 Effect of set_head(x, y) on the lists in figure 3.12.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0014">Figure 3.14 Effect of const z = pair(y, tail(x)); on the lists in figure 3.12.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0015">Figure 3.15 Effect of set_tail(x, y) on the lists in figure 3.12.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0016">Figure 3.16 The list z1 formed by pair(x, x).</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0017">Figure 3.17 The list z2 formed by pair(list("a", "b"), list("a", "b")).</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0018">Figure 3.18 Queue operations.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0019">Figure 3.19 Implementation of a queue as a list with front and rear pointers.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0020">Figure 3.20 Result of using insert_queue(q, "d") on the queue of figure 3.19.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0021">Figure 3.21 Result of using delete_queue(q) on the queue of figure 3.20.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0022">Figure 3.22 A table represented as a headed list.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0023">Figure 3.23 A two-dimensional table.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0024">Figure 3.24 Primitive functions in the digital logic simulator.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0025">Figure 3.25 A half-adder circuit.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0026">Figure 3.26 A full-adder circuit.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0027">Figure 3.27 A ripple-carry adder for n-bit numbers.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0028">Figure 3.28 The relation 9C = 5(F – 32) expressed as a constraint network.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0029">Figure 3.29 Timing diagram showing how interleaving the order of events in two …</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0030">Figure 3.30 Concurrent deposits and withdrawals from a joint account in Bank1 a…</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0031">Figure 3.31 The prime sieve viewed as a signal-processing system. Each solid li…</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0036">Figure 3.32 The integral function viewed as a signal-processing system.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0037">Figure 3.33 An RC circuit and the associated signal-flow diagram.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0039">Figure 3.34 An “analog computer circuit” that solves the equation dy/dt = f (y)…</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0040">Figure 3.35 Signal-flow diagram for the solution to a second-order linear diffe…</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0041">Figure 3.36 A series RLC circuit.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0042">Figure 3.37 A signal-flow diagram for the solution to a series RLC circuit.</a></li>
<li class="contentsH1"><a href="#c003_c3-fig-0043">Figure 3.38 A joint bank account, modeled by merging two streams of transaction…</a></li>
</ol></li>
<li class="contentsH1"><span>Chapter 4</span>
<ol>
<li class="contentsH1"><a href="#c004_c4-fig-0001">Figure 4.1 The evaluate–apply cycle exposes the essence of a computer language.</a></li>
<li class="contentsH1"><a href="#c004_c4-fig-0002">Figure 4.2 Syntax abstraction in the evaluator.</a></li>
<li class="contentsH1"><a href="#c004_c4-fig-0003">Figure 4.3 The factorial program, viewed as an abstract machine.</a></li>
<li class="contentsH1"><a href="#c004_c4-fig-0004">Figure 4.4 The evaluator emulating a factorial machine.</a></li>
<li class="contentsH1"><a href="#c004_c4-fig-0005">Figure 4.5 A query processes a stream of frames.</a></li>
<li class="contentsH1"><a href="#c004_c4-fig-0006">Figure 4.6 The and combination of two queries is produced by operating on the s…</a></li>
<li class="contentsH1"><a href="#c004_c4-fig-0007">Figure 4.7 The or combination of two queries is produced by operating on the st…</a></li>
<li class="contentsH1"><a href="#c004_c4-fig-0008">Figure 4.8 Syntax abstraction in the query system.</a></li>
</ol></li>
<li class="contentsH1"><span>Chapter 5</span>
<ol>
<li class="contentsH1"><a href="#c005_c5-fig-0001">Figure 5.1 Data paths for a GCD machine.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0002">Figure 5.2 Controller for a GCD machine.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0003">Figure 5.3 A specification of the GCD machine.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0004">Figure 5.4 A GCD machine that reads inputs and prints results.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0005">Figure 5.5 Data paths and controller for the elaborated GCD machine.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0006">Figure 5.6 Controller instruction sequence for the GCD machine in figure 5.5.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0007">Figure 5.7 Portions of the data paths and controller sequence for a machine wit…</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0008">Figure 5.8 Portions of the controller sequence for a machine that uses the same…</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0009">Figure 5.9 Using a continue register to avoid the duplicate controller sequence…</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0010">Figure 5.10 Assigning labels to the continue register simplifies and generalize…</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0011">Figure 5.11 A recursive factorial machine.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0012">Figure 5.12 Controller for a machine to compute Fibonacci numbers.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0013">Figure 5.13 The make_new_machine function implements the basic machine model.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0014">Figure 5.14 Box-and-pointer and memory-vector representations of the list list(…</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0015">Figure 5.15 Reconfiguration of memory by the garbage-collection process.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0016">Figure 5.16 A silicon-chip implementation of an evaluator for Scheme.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0018">Figure 5.17 Compilation of the declaration of the factorial function.</a></li>
<li class="contentsH1"><a href="#c005_c5-fig-0021">Figure 5.18 An example of compiler output. See exercis…</a></li>
</ol></li>
</ol>
</nav>
<nav class="guideList" epub:type="landmarks">
<h2>Guide</h2>
<ol>
<li class="contentsH1"><a epub:type="cover" href="#cover_">Cover</a></li>
<li class="contentsH1"><a epub:type="toc" href="#contents_">Table of Contents</a></li>
</ol>
</nav>
</body><body>
<section>
<header>
<h1><a id="c000a_f2-title-0001"></a><span class="chapterTitle">Foreword</span></h1>
</header>
<p class="paraaftertitle"><a id="c000a_f2-para-0001"></a>I had the pleasure of meeting the amazing Alan Perlis and talking with him a few times, when I was still a student. He and I had in common a deep love and respect for two very different programming languages: Lisp and APL. Following in his footsteps is a daunting task, even though he blazed an excellent trail. Still, I would like to reexamine one comment he made in the original foreword to this book (and, please, I suggest that you read <i>his</i> foreword, which immediately follows this one, before you finish this one). Is it really true that it is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures?</p>
<p><a id="c000a_f2-para-0002"></a>To answer that question carefully, we first need to ask whether that one data structure is “universal”: can it conveniently fulfill the roles of those 10 more specialized data structures?</p>
<p><a id="c000a_f2-para-0003"></a>For that matter, we can also ask: do we really need 100 functions? Is there a single universal function that can fulfill the roles of all those other functions?</p>
<p><a id="c000a_f2-para-0004"></a>The surprising answer to that last question is “yes”; it is only slightly tricky to construct a function that accepts (1) a data structure that serves as a description of some other function, and (2) a list of arguments, and behaves exactly as that other function would when applied to the given arguments. And it is only slightly tricky to design a data structure capable of describing any computation whatsoever. One such data structure (the tagged-list representation of expressions and statements, paired with environments that associate names with values) and one such universal function (<span class="KeyTerm1">apply</span>) are described in <a href="#c004_">Chapter 4</a> of this book. So maybe we need only one function and one data structure.</p>
<p><a id="c000a_f2-para-0005"></a>That is true in theory. In practice, we find it convenient to draw distinctions that help us, as human beings constructing descriptions of computations, to organize the structure of our code so that we can better understand them. I believe that Perlis was making a remark not about computational capability, but about human abilities and human limitations.</p>
<p><a id="c000a_f2-para-0006"></a>One thing the human mind seems to do well is to name things; we have powerful associative memories. Given a name, we can quickly recall some associated thing to mind. This is why we typically find it easier to work with the lambda calculus than the combinatory calculus; it is much easier for most people to interpret the Lisp expression <span class="KeyTerm1">(lambda (x) (lambda (y) (+ x y)))</span> or the JavaScript expression</p>
<p><a id="c000a_f2-para-0007"></a><span class="KeyTerm1">x =&gt; y =&gt; x + y</span> than the combinatory expression</p>
<p class="Sp-text-2"><a id="c000a_f2-para-0008"></a>((S ((S (K S)) ((S ((S (K S)) ((S (K K)) (K +)))) ((S (K K)) I)))) (K I))</p>
<p class="paracontinue"><a id="c000a_f2-para-0009"></a>even though there is a direct structural correspondence, easily expressed in five lines of Lisp code.</p>
<p><a id="c000a_f2-para-0010"></a>So while in principle we could get by with just one universal function, we prefer to modularize our code, to give names to the various pieces, and to mention the names of function descriptions rather than constantly feeding the descriptions themselves to the universal function.</p>
<p><a id="c000a_f2-para-0011"></a>In my 1998 talk “Growing a Language,” I commented that a good programmer “does not just write programs. A good programmer builds a working vocabulary.” As we design and define more and more parts of our programs, we give names to those parts, and the result is that we have a richer language in which to write the rest.</p>
<p><a id="c000a_f2-para-0012"></a>But we also find it natural to draw distinctions among data structures, and to give them names.</p>
<p><a id="c000a_f2-para-0013"></a>It may be that nested lists are a universal data structure (and it is worth noting that many modern and widely used data structures, such as HTML and XML and JSON, are also parenthetically nested representations, only slightly more elaborate than Lisp's bare parentheses). There are also many functions, such as finding the length of a list or applying a function to every element of a list and getting back a list of the results, that are useful in a wide variety of situations. And yet, when I am thinking about a specific computation, I often say to myself, “This list of two things I expect to be a personal name and a surname, but that list of two things I expect to be the real and imaginary parts of a complex number, and that other list of two things I will regard as the numerator and denominator of a fraction.” In other words, I draw distinctions—and it may be useful to represent those distinctions explicitly in the data structure, in part to prevent mistakes such as accidentally treating a complex number as a fraction. (Again, this is a comment about human abilities and human limitations.)</p>
<p><a id="c000a_f2-para-0014"></a>Since the first edition of this book was written, almost four decades ago, a lot more ways of organizing data have become relatively standard, in particular the “object-oriented” approach, and many languages, including JavaScript, support specialized data structures such as objects and strings and heaps and maps with a variety of built-in mechanisms and libraries. But in doing so, many languages abandoned support for more general, universal notions. Java, for example, originally did not support first-class functions, and has incorporated them only relatively recently, greatly increasing its expressive power.</p>
<p><a id="c000a_f2-para-0015"></a>APL, likewise, originally did not support first-class functions, and moreover its original single data structure—arrays of any number of dimensions—was not so conveniently useful as a universal data structure because arrays could not contain other arrays as elements. More recent versions of APL do support anonymous function values and nested arrays, and these have made APL dramatically more expressive. (The original design of APL did have two very good things going for it: a comprehensive set of functions applicable to that one data structure, and moreover an extremely well chosen set of names for those functions. I'm not talking about the funny symbols and Greek letters, but the spoken words that APL programmers use when mentioning them, words like <span class="KeyTerm1">shape</span>, <span class="KeyTerm1">reshape</span>, <span class="KeyTerm1">compress</span>, <span class="KeyTerm1">expand</span>, and <span class="KeyTerm1">laminate</span>; these are names not for the symbols, but for the functions they represent. Ken Iverson had a real knack for choosing short, memorable, vivid names for functions on arrays.)</p>
<p><a id="c000a_f2-para-0016"></a>While JavaScript, like Java, was originally designed with objects and methods in mind, it also incorporated first-class functions from the beginning, and it is not difficult to use its objects to define a universal data structure. As a result, JavaScript is not as distant from Lisp as you would think, and as this edition of <i>Structure and Interpretation of Computer Programs</i> demonstrates, it is a good alternate framework for presenting the key ideas. <i>SICP</i> was never about a programming language; it presents powerful, general ideas for program organization that ought to be useful in any language.</p>
<p><a id="c000a_f2-para-0017"></a>What do Lisp and JavaScript have in common? The ability to abstract a computation (code plus some associated data) for later execution as a function; the ability to embed references to such functions within data structures; the ability to invoke functions on arguments; the ability to draw a distinction (conditional execution); a convenient universal data structure; completely automatic storage management for that data (which seems like a no-brainer, given everything else, until you realize that many widely used programming languages don't have it); a large set of useful functions for operating on that universal data structure; and standard strategies for using the universal data structure to represent more specialized data structures.</p>
<p><a id="c000a_f2-para-0018"></a>So maybe the truth is somewhere in between the extremes that Perlis so eloquently posited. Maybe the sweet spot is something more like 40 functions general enough to operate usefully on a universal data structure such as lists, but also 10 sets of 6 functions each that are relevant when we take one of 10 specialized views of that universal data structure. This is manageable if we give good names to these functions and specialized views.</p>
<p><a id="c000a_f2-para-0019"></a>As you read this book, please pay attention not only to the programming language constructs and how they are used, but also to the <i>names</i> given to functions and variables and data structures. They are not all as short and vivid as the names Iverson chose for his APL functions, but they have been chosen in a deliberate and systematic way to enhance your understanding of the overall program structure.</p>
<p><a id="c000a_f2-para-0020"></a>Primitives, means of combination, functional abstraction, naming, and conventions for using a universal data structure in specialized ways by drawing distinctions: these are the fundamental building blocks of a good programming language. From there, imagination and good engineering judgment based on experience can do the rest.</p>
<p> </p>
<p class="paraaftertitle"><a id="c000a_f2-para-0021"></a>—Guy L. Steele Jr., Lexington, Massachusetts, 2021</p>
</section>
</body><body>
<section>
<header>
<h1><a id="c000b_f3-title-0001"></a><span class="chapterTitle">Foreword to Structure and Interpretation of Computer Programs, 1984</span></h1>
</header>
<p class="paraaftertitle"><a id="c000b_f3-para-0001"></a>Educators, generals, dieticians, psychologists, and parents program. Armies, students, and some societies are programmed. An assault on large problems employs a succession of programs, most of which spring into existence en route. These programs are rife with issues that appear to be particular to the problem at hand. To appreciate programming as an intellectual activity in its own right you must turn to computer programming; you must read and write computer programs—many of them. It doesn't matter much what the programs are about or what applications they serve. What does matter is how well they perform and how smoothly they fit with other programs in the creation of still greater programs. The programmer must seek both perfection of part and adequacy of collection. In this book the use of “program” is focused on the creation, execution, and study of programs written in a dialect of Lisp for execution on a digital computer. Using Lisp we restrict or limit not what we may program, but only the notation for our program descriptions.</p>
<p><a id="c000b_f3-para-0002"></a>Our traffic with the subject matter of this book involves us with three foci of phenomena: the human mind, collections of computer programs, and the computer. Every computer program is a model, hatched in the mind, of a real or mental process. These processes, arising from human experience and thought, are huge in number, intricate in detail, and at any time only partially understood. They are modeled to our permanent satisfaction rarely by our computer programs. Thus even though our programs are carefully handcrafted discrete collections of symbols, mosaics of interlocking functions, they continually evolve: we change them as our perception of the model deepens, enlarges, generalizes until the model ultimately attains a metastable place within still another model with which we struggle. The source of the exhilaration associated with computer programming is the continual unfolding within the mind and on the computer of mechanisms expressed as programs and the explosion of perception they generate. If art interprets our dreams, the computer executes them in the guise of programs!</p>
<p><a id="c000b_f3-para-0003"></a>For all its power, the computer is a harsh taskmaster. Its programs must be correct, and what we wish to say must be said accurately in every detail. As in every other symbolic activity, we become convinced of program truth through argument. Lisp itself can be assigned a semantics (another model, by the way), and if a program's function can be specified, say, in the predicate calculus, the proof methods of logic can be used to make an acceptable correctness argument. Unfortunately, as programs get large and complicated, as they almost always do, the adequacy, consistency, and correctness of the specifications themselves become open to doubt, so that complete formal arguments of correctness seldom accompany large programs. Since large programs grow from small ones, it is crucial that we develop an arsenal of standard program structures of whose correctness we have become sure—we call them idioms—and learn to combine them into larger structures using organizational techniques of proven value. These techniques are treated at length in this book, and understanding them is essential to participation in the Promethean enterprise called programming. More than anything else, the uncovering and mastery of powerful organizational techniques accelerates our ability to create large, significant programs. Conversely, since writing large programs is very taxing, we are stimulated to invent new methods of reducing the mass of function and detail to be fitted into large programs.</p>
<p><a id="c000b_f3-para-0004"></a>Unlike programs, computers must obey the laws of physics. If they wish to perform rapidly—a few nanoseconds per state change—they must transmit electrons only small distances (at most <img alt="f3-fig-5001.jpg" src="../images/f3-fig-5001.jpg"/> feet). The heat generated by the huge number of devices so concentrated in space has to be removed. An exquisite engineering art has been developed balancing between multiplicity of function and density of devices. In any event, hardware always operates at a level more primitive than that at which we care to program. The processes that transform our Lisp programs to “machine” programs are themselves abstract models which we program. Their study and creation give a great deal of insight into the organizational programs associated with programming arbitrary models. Of course the computer itself can be so modeled. Think of it: the behavior of the smallest physical switching element is modeled by quantum mechanics described by differential equations whose detailed behavior is captured by numerical approximations represented in computer programs executing on computers composed of . . . !</p>
<p><a id="c000b_f3-para-0005"></a>It is not merely a matter of tactical convenience to separately identify the three foci. Even though, as they say, it's all in the head, this logical separation induces an acceleration of symbolic traffic between these foci whose richness, vitality, and potential is exceeded in human experience only by the evolution of life itself. At best, relationships between the foci are metastable. The computers are never large enough or fast enough. Each breakthrough in hardware technology leads to more massive programming enterprises, new organizational principles, and an enrichment of abstract models. Every reader should ask himself periodically “Toward what end, toward what end?”—but do not ask it too often lest you pass up the fun of programming for the constipation of bittersweet philosophy.</p>
<p><a id="c000b_f3-para-0006"></a>Among the programs we write, some (but never enough) perform a precise mathematical function such as sorting or finding the maximum of a sequence of numbers, determining primality, or finding the square root. We call such programs algorithms, and a great deal is known of their optimal behavior, particularly with respect to the two important parameters of execution time and data storage requirements. A programmer should acquire good algorithms and idioms. Even though some programs resist precise specifications, it is the responsibility of the programmer to estimate, and always to attempt to improve, their performance.</p>
<p><a id="c000b_f3-para-0007"></a>Lisp is a survivor, having been in use for about a quarter of a century. Among the active programming languages only Fortran has had a longer life. Both languages have supported the programming needs of important areas of application, Fortran for scientific and engineering computation and Lisp for artificial intelligence. These two areas continue to be important, and their programmers are so devoted to these two languages that Lisp and Fortran may well continue in active use for at least another quarter-century.</p>
<p><a id="c000b_f3-para-0008"></a>Lisp changes. The Scheme dialect used in this text has evolved from the original Lisp and differs from the latter in several important ways, including static scoping for variable binding and permitting functions to yield functions as values. In its semantic structure Scheme is as closely akin to Algol 60 as to early Lisps. Algol 60, never to be an active language again, lives on in the genes of Scheme and Pascal. It would be difficult to find two languages that are the communicating coin of two more different cultures than those gathered around these two languages. Pascal is for building pyramids—imposing, breathtaking, static structures built by armies pushing heavy blocks into place. Lisp is for building organisms—imposing, breathtaking, dynamic structures built by squads fitting fluctuating myriads of simpler organisms into place. The organizing principles used are the same in both cases, except for one extraordinarily important difference: The discretionary exportable functionality entrusted to the individual Lisp programmer is more than an order of magnitude greater than that to be found within Pascal enterprises. Lisp programs inflate libraries with functions whose utility transcends the application that produced them. The list, Lisp's native data structure, is largely responsible for such growth of utility. The simple structure and natural applicability of lists are reflected in functions that are amazingly nonidiosyncratic. In Pascal the plethora of declarable data structures induces a specialization within functions that inhibits and penalizes casual cooperation. It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures. As a result the pyramid must stand unchanged for a millennium; the organism must evolve or perish.</p>
<p><a id="c000b_f3-para-0009"></a>To illustrate this difference, compare the treatment of material and exercises within this book with that in any first-course text using Pascal. Do not labor under the illusion that this is a text digestible at MIT only, peculiar to the breed found there. It is precisely what a serious book on programming Lisp must be, no matter who the student is or where it is used.</p>
<p><a id="c000b_f3-para-0010"></a>Note that this is a text about programming, unlike most Lisp books, which are used as a preparation for work in artificial intelligence. After all, the critical programming concerns of software engineering and artificial intelligence tend to coalesce as the systems under investigation become larger. This explains why there is such growing interest in Lisp outside of artificial intelligence.</p>
<p><a id="c000b_f3-para-0011"></a>As one would expect from its goals, artificial intelligence research generates many significant programming problems. In other programming cultures this spate of problems spawns new languages. Indeed, in any very large programming task a useful organizing principle is to control and isolate traffic within the task modules via the invention of language. These languages tend to become less primitive as one approaches the boundaries of the system where we humans interact most often. As a result, such systems contain complex language-processing functions replicated many times. Lisp has such a simple syntax and semantics that parsing can be treated as an elementary task. Thus parsing technology plays almost no role in Lisp programs, and the construction of language processors is rarely an impediment to the rate of growth and change of large Lisp systems. Finally, it is this very simplicity of syntax and semantics that is responsible for the burden and freedom borne by all Lisp programmers. No Lisp program of any size beyond a few lines can be written without being saturated with discretionary functions. Invent and fit; have fits and reinvent! We toast the Lisp programmer who pens his thoughts within nests of parentheses.</p>
<p> </p>
<p class="paraaftertitle"><a id="c000b_f3-para-0012"></a>—Alan J. Perlis, New Haven, Connecticut</p>
</section>
</body><body epub:type="frontmatter">
<section epub:type="preface" role="doc-preface">
<header>
<h1><a id="c000c_f4-title-0001"></a><span class="chapterTitle">Preface</span></h1>
</header>
<p class="paraaftertitle"><a id="c000c_f4-para-0001"></a>The book <i>Structure and Interpretation of Computer Programs</i> (SICP) introduces the reader to central ideas of computation by establishing a series of mental models for computation. <a href="#c001_">Chapters 1–3</a> cover programming concepts that are common to all modern high-level programming languages. The original first two editions of SICP use the programming language Scheme in their program examples, whose minimalist, expression-oriented syntax allows the book to focus on the underlying ideas rather than the design of the chosen language. <a href="#c004_">Chapters 4</a> and <a href="#c005_">5</a> use Scheme to formulate language processors for Scheme, deepening the readers’ understanding of the mental models and exploring language extensions and alternatives.</p>
<p><a id="c000c_f4-para-0002"></a>Since its publication in 1984 and its second edition in 1996, SICP has been adopted as a textbook by universities and colleges around the world, including the National University of Singapore (NUS), which introduced the SICP-based introductory course CS1101S in 1997. In the mid-1990s, the languages Python, JavaScript, and Ruby emerged, which share central design elements with Scheme, but which employ a more complex, statement-oriented syntax that uses familiar algebraic (infix) notation. Their rise in popularity led instructors to adapt their SICP-based courses, typically by translating the example programs to their language of choice, by adding material specific to that language, and by omitting the material of <a href="#c004_">chapters 4</a> and <a href="#c005_">5</a>.</p>
<section><a id="c000c_f4-title-0002"></a>
<section><a id="c000c_f4-title-0003"></a>
<section><a id="c000c_f4-title-0004"></a>
<section>
<h5><a id="c000c_f4-sec-0004"></a><a id="c000c_f4-title-0005"></a>Adapting SICP to JavaScript</h5>
<p class="paraaftertitle"><a id="c000c_f4-para-0003"></a>The work on adapting the second edition of SICP to JavaScript (SICP JS) started at NUS in 2008, and CS1101S switched to JavaScript in 2012. The language standard ECMAScript 2015 introduced lambda expressions, tail recursion, and block-scoped variables and constants, which enabled the adaptation to become quite close to the original. We made substantial changes to SICP only when we felt they were forced by differences between JavaScript and Scheme. The book covers just a small fraction of JavaScript, so a reader would be ill-advised to use it to learn the language. For example, the notion of a JavaScript object—considered one of its fundamental ingredients by any measure—is not even mentioned!</p>
<p><a id="c000c_f4-para-0004"></a>It was straightforward to translate the programs of <a href="#c001_">chapters 1–3</a> to JavaScript by adding libraries that mirror Scheme primitives—including support for list structure—and adapting the text accordingly. However, the switch to JavaScript forced us to make subtle changes in the interpreters and compiler of <a href="#c004_">chapters 4</a> and <a href="#c005_">5</a> in order to handle return statements. Scheme's expression-oriented syntax doesn't have return statements, which are a prominent feature of statement-oriented languages.</p>
<p><a id="c000c_f4-para-0005"></a>By using JavaScript, <a href="#c001_">chapters 1–3</a> introduce the reader to the syntactic style of most mainstream languages today. However, that same syntactic style gave rise to significant changes in <a href="#c004_">chapter 4</a>, because the direct representation of programs as data structures could no longer be taken for granted. This provided us with an opportunity to introduce the reader to the notion of program parsing in section 4.1, an important component of programming-language processors. In section 4.4, the rigid syntactic structure of JavaScript complicated the implementation of the presented logic programming system and exposed the limitations of JavaScript as a tool for programming language design.</p>
</section>
<section>
<h5><a id="c000c_f4-sec-0005"></a><a id="c000c_f4-title-0006"></a>Resources for using SICP JS</h5>
<p class="paraaftertitle"><a id="c000c_f4-para-0006"></a>The MIT Press web page for SICP JS links to support for users of this book. This provides all programs from the book and extensive instructor resources, including a large collection of additional exercises and recommendations on selecting a subset of SICP JS that can be covered in a typical college semester. The JavaScript programs in the book run in the recommended strict mode in any JavaScript interpreter that complies with the ECMAScript 2020 specification of JavaScript (ECMA 2020). The MIT Press web page includes the JavaScript package <span class="KeyTerm1">sicp</span>, which provides all JavaScript functions that are considered “primitive” in the book.</p>
</section>
<section>
<h5><a id="c000c_f4-sec-0006"></a><a id="c000c_f4-title-0007"></a>To the reader</h5>
<p class="paraaftertitle"><a id="c000c_f4-para-0007"></a>We sincerely hope that if this book is your first encounter with programming you will use your newly gained understanding of the structure and interpretation of computer programs to learn more programming languages, including Scheme and the full JavaScript language. If you have learned JavaScript prior to picking up SICP JS, you might gain new insights into the fundamental concepts that underlie the language and discover how much can be achieved with so little. If you come to SICP JS with a knowledge of the original SICP, you might enjoy seeing familiar ideas presented in a new format—and might appreciate the online comparison edition, available at the book's web page, where SICP JS and SICP can be viewed side by side.</p>
<p> </p>
<p class="paraaftertitle"><a id="c000c_f4-para-0008"></a>—Martin Henz and Tobias Wrigstad</p>
</section>
</section>
</section>
</section>
</section>
</body><body epub:type="frontmatter">
<section epub:type="preface" role="doc-preface">
<header>
<h1><a id="c000d_f5-title-0001"></a><span class="chapterTitle">Prefaces to Structure and Interpretation of Computer Programs, 1996 &amp; 1984</span></h1>
</header>
<section>
<h2><a id="c000d_f5-sec-0001"></a><a id="c000d_f5-title-0002"></a>Preface to the Second Edition of SICP, 1996</h2>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c000d_f5-para-0001"></a>Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to always see it as a soap bubble?</p>
<p class="quote-epigraphsource">—Alan J. Perlis</p></blockquote>
<p class="paraaftertitle"><a id="c000d_f5-para-0002"></a>The material in this book has been the basis of MIT's entry-level computer science subject since 1980. We had been teaching this material for four years when the first edition was published, and twelve more years have elapsed until the appearance of this second edition. We are pleased that our work has been widely adopted and incorporated into other texts. We have seen our students take the ideas and programs in this book and build them in as the core of new computer systems and languages. In literal realization of an ancient Talmudic pun, our students have become our builders. We are lucky to have such capable students and such accomplished builders.</p>
<p><a id="c000d_f5-para-0003"></a>In preparing this edition, we have incorporated hundreds of clarifications suggested by our own teaching experience and the comments of colleagues at MIT and elsewhere. We have redesigned most of the major programming systems in the book, including the generic-arithmetic system, the interpreters, the register-machine simulator, and the compiler; and we have rewritten all the program examples to ensure that any Scheme implementation conforming to the IEEE Scheme standard (IEEE 1990) will be able to run the code.</p>
<p><a id="c000d_f5-para-0004"></a>This edition emphasizes several new themes. The most important of these is the central role played by different approaches to dealing with time in computational models: objects with state, concurrent programming, functional programming, lazy evaluation, and nondeterministic programming. We have included new sections on concurrency and nondeterminism, and we have tried to integrate this theme throughout the book.</p>
<p><a id="c000d_f5-para-0005"></a>The first edition of the book closely followed the syllabus of our MIT onesemester subject. With all the new material in the second edition, it will not be possible to cover everything in a single semester, so the instructor will have to pick and choose. In our own teaching, we sometimes skip the section on logic programming (section 4.4), we have students use the register-machine simulator but we do not cover its implementation (section 5.2), and we give only a cursory overview of the compiler (section 5.5). Even so, this is still an intense course. Some instructors may wish to cover only the first three or four chapters, leaving the other material for subsequent courses.</p>
<p><a id="c000d_f5-para-0006"></a>The World Wide Web site of MIT Press provides support for users of this book. This includes programs from the book, sample programming assignments, supplementary materials, and downloadable implementations of the Scheme dialect of Lisp.</p>
<p> </p>
<p class="paraaftertitle"><a id="c000d_f5-para-0007"></a>—Harold Abelson and Gerald Jay Sussman</p>
</section>
<section>
<h2><a id="c000d_f5-sec-0002"></a><a id="c000d_f5-title-0003"></a>Preface to the First Edition of SICP, 1984</h2>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c000d_f5-para-0008"></a>A computer is like a violin. You can imagine a novice trying first a phonograph and then a violin. The latter, he says, sounds terrible. That is the argument we have heard from our humanists and most of our computer scientists. Computer programs are good, they say, for particular purposes, but they aren't flexible. Neither is a violin, or a typewriter, until you learn how to use it.</p>
<p class="quote-epigraphsource">—Marvin Minsky, “Why Programming Is a Good Medium for Expressing Poorly-Understood and Sloppily-Formulated Ideas”</p></blockquote>
<p class="paraaftertitle"><a id="c000d_f5-para-0009"></a>“The Structure and Interpretation of Computer Programs” is the entry-level subject in computer science at the Massachusetts Institute of Technology. It is required of all students at MIT who major in electrical engineering or in computer science, as one-fourth of the “common core curriculum,” which also includes two subjects on circuits and linear systems and a subject on the design of digital systems. We have been involved in the development of this subject since 1978, and we have taught this material in its present form since the fall of 1980 to between 600 and 700 students each year. Most of these students have had little or no prior formal training in computation, although many have played with computers a bit and a few have had extensive programming or hardware-design experience.</p>
<p><a id="c000d_f5-para-0010"></a>Our design of this introductory computer-science subject reflects two major concerns. First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute. Second, we believe that the essential material to be addressed by a subject at this level is not the syntax of particular programming-language constructs, nor clever algorithms for computing particular functions efficiently, nor even the mathematical analysis of algorithms and the foundations of computing, but rather the techniques used to control the intellectual complexity of large software systems.</p>
<p><a id="c000d_f5-para-0011"></a>Our goal is that students who complete this subject should have a good feel for the elements of style and the aesthetics of programming. They should have command of the major techniques for controlling complexity in a large system. They should be capable of reading a 50-page-long program, if it is written in an exemplary style. They should know what not to read, and what they need not understand at any moment. They should feel secure about modifying a program, retaining the spirit and style of the original author.</p>
<p><a id="c000d_f5-para-0012"></a>These skills are by no means unique to computer programming. The techniques we teach and draw upon are common to all of engineering design. We control complexity by building abstractions that hide details when appropriate. We control complexity by establishing conventional interfaces that enable us to construct systems by combining standard, well-understood pieces in a “mix and match” way. We control complexity by establishing new languages for describing a design, each of which emphasizes particular aspects of the design and deemphasizes others.</p>
<p><a id="c000d_f5-para-0013"></a>Underlying our approach to this subject is our conviction that “computer science” is not a science and that its significance has little to do with computers. The computer revolution is a revolution in the way we think and in the way we express what we think. The essence of this change is the emergence of what might best be called <i>procedural epistemology</i>—the study of the structure of knowledge from an imperative point of view, as opposed to the more declarative point of view taken by classical mathematical subjects. Mathematics provides a framework for dealing precisely with notions of “what is.” Computation provides a framework for dealing precisely with notions of “how to.”</p>
<p><a id="c000d_f5-para-0014"></a>In teaching our material we use a dialect of the programming language Lisp. We never formally teach the language, because we don't have to. We just use it, and students pick it up in a few days. This is one great advantage of Lisp-like languages: They have very few ways of forming compound expressions, and almost no syntactic structure. All of the formal properties can be covered in an hour, like the rules of chess. After a short time we forget about syntactic details of the language (because there are none) and get on with the real issues—figuring out what we want to compute, how we will decompose problems into manageable parts, and how we will work on the parts. Another advantage of Lisp is that it supports (but does not enforce) more of the large-scale strategies for modular decomposition of programs than any other language we know. We can make procedural and data abstractions, we can use higher-order functions to capture common patterns of usage, we can model local state using assignment and data mutation, we can link parts of a program with streams and delayed evaluation, and we can easily implement embedded languages. All of this is embedded in an interactive environment with excellent support for incremental program design, construction, testing, and debugging. We thank all the generations of Lisp wizards, starting with John McCarthy, who have fashioned a fine tool of unprecedented power and elegance.</p>
<p><a id="c000d_f5-para-0015"></a>Scheme, the dialect of Lisp that we use, is an attempt to bring together the power and elegance of Lisp and Algol. From Lisp we take the metalinguistic power that derives from the simple syntax, the uniform representation of programs as data objects, and the garbage-collected heap-allocated data. From Algol we take lexical scoping and block structure, which are gifts from the pioneers of programminglanguage design who were on the Algol committee. We wish to cite John Reynolds and Peter Landin for their insights into the relationship of Church's lambda calculus to the structure of programming languages. We also recognize our debt to the mathematicians who scouted out this territory decades before computers appeared on the scene. These pioneers include Alonzo Church, Barkley Rosser, Stephen Kleene, and Haskell Curry.</p>
<p> </p>
<p class="paraaftertitle"><a id="c000d_f5-para-0016"></a>—Harold Abelson and Gerald Jay Sussman</p>
</section>
</section>
</body><body epub:type="frontmatter">
<section epub:type="acknowledgments" role="doc-acknowledgments">
<header>
<h1><a id="c000e_f6-title-0001"></a><span class="chapterTitle">Acknowledgments</span></h1>
</header>
<p class="paraaftertitle"><a id="c000e_f6-para-0001"></a>The JavaScript adaptation of <i>Structure and Interpretation of Computer Programs</i> (SICP JS) was developed at the National University of Singapore (NUS) for the course CS1101S. The course was co-taught for six years and counting by Low Kok Lim, whose sound pedagogical judgment was crucial for the success of the course and this project. The CS1101S teaching team has included many NUS colleagues and more than 300 undergraduate student assistants. Their continuous feedback over the past nine years allowed us to resolve countless JavaScript-specific issues and remove unnecessary complications and yet retain the essential features of both SICP and JavaScript.</p>
<p><a id="c000e_f6-para-0002"></a>SICP JS is a software project in addition to a book project. We obtained the <img alt="f6-fig-5001.jpg" src="../images/f6-fig-5001.jpg"/> book sources from the original authors in 2008. An early SICP JS tool chain was developed by Liu Hang and refined by Feng Piaopiao. Chan Ger Hean developed the first tools for the print edition, based on which Jolyn Tan developed the tools for the first e-book edition and He Xinyue and Wang Qian repurposed these tools for the current comparison edition. Samuel Fang designed and developed the online edition of SICP JS.</p>
<p><a id="c000e_f6-para-0003"></a>The online edition of SICP JS and CS1101S rely heavily on a software system called <i>Source Academy</i>, and the JavaScript sublanguages it supports are called <i>Source</i>. Many dozens of students have contributed to the Source Academy during the preparation of SICP JS, and the system lists them prominently as “Contributors.” Since 2020, the students of the NUS course CS4215, Programming Language Implementation, contributed several programming language implementations that are used in SICP JS: The concurrent version of Source used in section 3.4 was developed by Zhengqun Koo and Jonathan Chan; the lazy implementation used in section 4.2 was developed by Jellouli Ahmed, Ian Kendall Duncan, Cruz Jomari Evangelista, and Alden Tan; the nondeterministic implementation used in section 4.3 was developed by Arsalan Cheema and Anubhav; and Daryl Tan helped integrate these implementations into the Academy.</p>
<p><a id="c000e_f6-para-0004"></a>We are grateful to STINT, The Swedish Foundation for International Cooperation in Research and Higher Education, whose sabbatical program connected Martin and Tobias and allowed Tobias to work as a co-teacher of CS1101S and join the SICP JS project.</p>
<p><a id="c000e_f6-para-0005"></a>We would like to acknowledge the courageous work of the committee of ECMAScript 2015, led by Allen Wirfs-Brock. SICP JS relies heavily on constant and let declarations and lambda expressions, all of which were added to JavaScript with ECMAScript 2015. Those additions allowed us to stay close to the original in the presentation of the most important ideas of SICP. Guy Lewis Steele Jr., who led the first ECMAScript standardization, provided detailed and useful feedback on some exercises of <a href="#c004_">chapter 4</a>.</p>
<p> </p>
<p class="paraaftertitle"><a id="c000e_f6-para-0006"></a>—Martin Henz and Tobias Wrigstad</p>
<section>
<h2><a id="c000e_f6-sec-0001"></a><a id="c000e_f6-title-0002"></a>Acknowledgments from the Second Edition of SICP, 1996</h2>
<p class="paraaftertitle"><a id="c000e_f6-para-0007"></a>We would like to thank the many people who have helped us develop this book and this curriculum.</p>
<p><a id="c000e_f6-para-0008"></a>Our subject is a clear intellectual descendant of “6.231,” a wonderful subject on programming linguistics and the lambda calculus taught at MIT in the late 1960s by Jack Wozencraft and Arthur Evans, Jr.</p>
<p><a id="c000e_f6-para-0009"></a>We owe a great debt to Robert Fano, who reorganized MIT's introductory curriculum in electrical engineering and computer science to emphasize the principles of engineering design. He led us in starting out on this enterprise and wrote the first set of subject notes from which this book evolved.</p>
<p><a id="c000e_f6-para-0010"></a>Much of the style and aesthetics of programming that we try to teach were developed in conjunction with Guy Lewis Steele Jr., who collaborated with Gerald Jay Sussman in the initial development of the Scheme language. In addition, David Turner, Peter Henderson, Dan Friedman, David Wise, and Will Clinger have taught us many of the techniques of the functional programming community that appear in this book.</p>
<p><a id="c000e_f6-para-0011"></a>Joel Moses taught us about structuring large systems. His experience with the Macsyma system for symbolic computation provided the insight that one should avoid complexities of control and concentrate on organizing the data to reflect the real structure of the world being modeled.</p>
<p><a id="c000e_f6-para-0012"></a>Marvin Minsky and Seymour Papert formed many of our attitudes about programming and its place in our intellectual lives. To them we owe the understanding that computation provides a means of expression for exploring ideas that would otherwise be too complex to deal with precisely. They emphasize that a student's ability to write and modify programs provides a powerful medium in which exploring becomes a natural activity.</p>
<p><a id="c000e_f6-para-0013"></a>We also strongly agree with Alan Perlis that programming is lots of fun and we had better be careful to support the joy of programming. Part of this joy derives from observing great masters at work. We are fortunate to have been apprentice programmers at the feet of Bill Gosper and Richard Greenblatt.</p>
<p><a id="c000e_f6-para-0014"></a>It is difficult to identify all the people who have contributed to the development of our curriculum. We thank all the lecturers, recitation instructors, and tutors who have worked with us over the past fifteen years and put in many extra hours on our subject, especially Bill Siebert, Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn Stein, and Peter Szolovits. We would like to specially acknowledge the outstanding teaching contributions of Franklyn Turbak, now at Wellesley; his work in undergraduate instruction set a standard that we can all aspire to. We are grateful to Jerry Saltzer and Jim Miller for helping us grapple with the mysteries of concurrency, and to Peter Szolovits and David McAllester for their contributions to the exposition of nondeterministic evaluation in <a href="#c004_">chapter 4</a>.</p>
<p><a id="c000e_f6-para-0015"></a>Many people have put in significant effort presenting this material at other universities. Some of the people we have worked closely with are Jacob Katzenelson at the Technion, Hardy Mayer at the University of California at Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue, and Jan Komorowski at the Norwegian University of Science and Technology. We are exceptionally proud of our colleagues who have received major teaching awards for their adaptations of this subject at other universities, including Kenneth Yip at Yale, Brian Harvey at the University of California at Berkeley, and Dan Huttenlocher at Cornell.</p>
<p><a id="c000e_f6-para-0016"></a>Al Moyé arranged for us to teach this material to engineers at Hewlett-Packard, and for the production of videotapes of these lectures. We would like to thank the talented instructors—in particular Jim Miller, Bill Siebert, and Mike Eisenberg—who have designed continuing education courses incorporating these tapes and taught them at universities and industry all over the world.</p>
<p><a id="c000e_f6-para-0017"></a>Many educators in other countries have put in significant work translating the first edition. Michel Briand, Pierre Chamard, and André Pic produced a French edition; Susanne Daniels-Herold produced a German edition; and Fumio Motoyoshi produced a Japanese edition. We do not know who produced the Chinese edition, but we consider it an honor to have been selected as the subject of an “unauthorized” translation.</p>
<p><a id="c000e_f6-para-0018"></a>It is hard to enumerate all the people who have made technical contributions to the development of the Scheme systems we use for instructional purposes. In addition to Guy Steele, principal wizards have included Chris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas, and Stephen Adams. Others who have put in significant time are Richard Stallman, Alan Bawden, Kent Pitman, Jon Taft, Neil Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd Cass, Patrick O’Donnell, Kevin Theobald, Daniel Weise, Kenneth Sinclair, Anthony Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth Shyu.</p>
<p><a id="c000e_f6-para-0019"></a>Beyond the MIT implementation, we would like to thank the many people who worked on the IEEE Scheme standard, including William Clinger and Jonathan Rees, who edited the R<sup>4</sup>RS, and Chris Haynes, David Bartley, Chris Hanson, and Jim Miller, who prepared the IEEE standard.</p>
<p><a id="c000e_f6-para-0020"></a>Dan Friedman has been a long-time leader of the Scheme community. The community's broader work goes beyond issues of language design to encompass significant educational innovations, such as the high-school curriculum based on EdScheme by Schemer's Inc., and the wonderful books by Mike Eisenberg and by Brian Harvey and Matthew Wright.</p>
<p><a id="c000e_f6-para-0021"></a>We appreciate the work of those who contributed to making this a real book, especially Terry Ehling, Larry Cohen, and Paul Bethge at the MIT Press. Ella Mazel found the wonderful cover image. For the second edition we are particularly grateful to Bernard and Ella Mazel for help with the book design, and to David Jones, <img alt="f6-fig-5002.jpg" src="../images/f6-fig-5002.jpg"/> wizard extraordinaire. We also are indebted to those readers who made penetrating comments on the new draft: Jacob Katzenelson, Hardy Mayer, Jim Miller, and especially Brian Harvey, who did unto this book as Julie did unto his book <i>Simply Scheme</i>.</p>
<p><a id="c000e_f6-para-0022"></a>Finally, we would like to acknowledge the support of the organizations that have encouraged this work over the years, including support from Hewlett-Packard, made possible by Ira Goldstein and Joel Birnbaum, and support from DARPA, made possible by Bob Kahn.</p>
<p> </p>
<p class="paraaftertitle"><a id="c000e_f6-para-0023"></a>—Harold Abelson and Gerald Jay Sussman</p>
</section>
</section>
</body><body epub:type="frontmatter">
<section>
<header><a id="c000f_d2e43"></a>
</header>
<section>
<p class="BS_bookHalftitle">Structure and Interpretation of Computer Programs</p>
<p class="BS_bookEdition">JavaScript Edition</p>
</section>
</section>
</body><body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<h1><a id="c001_c1-title-0001"></a><span class="chapterNumber">1</span><br/><span class="chapterTitle">Building Abstractions with Functions</span></h1>
</header>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c001_c1-para-0001"></a>The acts of the mind, wherein it exerts its power over simple ideas, are chiefly these three: 1. Combining several simple ideas into one compound one, and thus all complex ideas are made. 2. The second is bringing two ideas, whether simple or complex, together, and setting them by one another so as to take a view of them at once, without uniting them into one, by which it gets all its ideas of relations. 3. The third is separating them from all other ideas that accompany them in their real existence: this is called abstraction, and thus all its general ideas are made.</p>
<p class="quote-epigraphsource">—John Locke, An Essay Concerning Human Understanding (1690)</p></blockquote>
<p class="paraaftertitle"><a id="c001_c1-para-0002"></a>We are about to study the idea of a <i>computational process</i>. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called <i>data</i>. The evolution of a process is directed by a pattern of rules called a <i>program</i>. People create programs to direct processes. In effect, we conjure the spirits of the computer with our spells.</p>
<p><a id="c001_c1-para-0003"></a>A computational process is indeed much like a sorcerer's idea of a spirit. It cannot be seen or touched. It is not composed of matter at all. However, it is very real. It can perform intellectual work. It can answer questions. It can affect the world by disbursing money at a bank or by controlling a robot arm in a factory. The programs we use to conjure processes are like a sorcerer's spells. They are carefully composed from symbolic expressions in arcane and esoteric <i>programming languages</i> that prescribe the tasks we want our processes to perform.</p>
<p><a id="c001_c1-para-0004"></a>A computational process, in a correctly working computer, executes programs precisely and accurately. Thus, like the sorcerer's apprentice, novice programmers must learn to understand and to anticipate the consequences of their conjuring. Even small errors (usually called <i>bugs</i>) in programs can have complex and unanticipated consequences.</p>
<p><a id="c001_c1-para-0005"></a>Fortunately, learning to program is considerably less dangerous than learning sorcery, because the spirits we deal with are conveniently contained in a secure way. Real-world programming, however, requires care, expertise, and wisdom. A small bug in a computer-aided design program, for example, can lead to the catastrophic collapse of an airplane or a dam or the self-destruction of an industrial robot.</p>
<p><a id="c001_c1-para-0006"></a>Master software engineers have the ability to organize programs so that they can be reasonably sure that the resulting processes will perform the tasks intended. They can visualize the behavior of their systems in advance. They know how to structure programs so that unanticipated problems do not lead to catastrophic consequences, and when problems do arise, they can <i>debug</i> their programs. Well-designed computational systems, like well-designed automobiles or nuclear reactors, are designed in a modular manner, so that the parts can be constructed, replaced, and debugged separately.</p>
<section><a id="c001_c1-title-0002"></a>
<section><a id="c001_c1-title-0003"></a>
<section><a id="c001_c1-title-0004"></a>
<section>
<h5><a id="c001_c1-sec-0004"></a><a id="c001_c1-title-0005"></a>Programming in JavaScript</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0007"></a>We need an appropriate language for describing processes, and we will use for this purpose the programming language JavaScript. Just as our everyday thoughts are usually expressed in our natural language (such as English, Swedish, or Chinese), and descriptions of quantitative phenomena are expressed with mathematical notations, our procedural thoughts will be expressed in JavaScript. JavaScript was developed in 1995 as a programming language for controlling the behavior of World Wide Web browsers through scripts that are embedded in web pages. The language was conceived by Brendan Eich, originally under the name <i>Mocha</i>, which was later renamed to <i>LiveScript</i>, and finally to JavaScript. The name “JavaScript” is a trademark of Oracle Corporation.</p>
<p><a id="c001_c1-para-0008"></a>Despite its inception as a language for scripting the web, JavaScript is a generalpurpose programming language. A JavaScript <i>interpreter</i> is a machine that carries out processes described in the JavaScript language. The first JavaScript interpreter was implemented by Eich at Netscape Communications Corporation for the Netscape Navigator web browser. JavaScript inherited its core features from the Scheme and Self programming languages. Scheme is a dialect of Lisp, and was used as the programming language for the original version of this book. From Scheme, JavaScript inherited its most fundamental design principles, such as lexically scoped first-class functions and dynamic typing.</p>
<p><a id="c001_c1-para-0009"></a>JavaScript bears only superficial resemblance to the language Java, after which it was (eventually) named; both Java and JavaScript use the block structure of the language C. In contrast with Java and C, which usually employ compilation to lowerlevel languages, JavaScript programs were initially <i>interpreted</i> by web browsers. After Netscape Navigator, other web browsers provided interpreters for the language, including Microsoft's Internet Explorer, whose JavaScript version is called <i>JScript</i>. The popularity of JavaScript for controlling web browsers gave rise to a standardization effort, culminating in <i>ECMAScript</i>. The first edition of the ECMAScript standard was led by Guy Lewis Steele Jr. and completed in June 1997 (ECMA 1997). The sixth edition, known as ECMAScript 2015, was led by Allen Wirfs-Brock and adopted by the General Assembly of ECMA in June 2015 (ECMA 2015).</p>
<p><a id="c001_c1-para-0010"></a>The practice of embedding JavaScript programs in web pages encouraged the developers of web browsers to implement JavaScript interpreters. As these programs became more complex, the interpreters became more efficient in executing them, eventually using sophisticated implementation techniques such as Just-In-Time (JIT) compilation. The majority of JavaScript programs as of this writing (2021) are embedded in web pages and interpreted by browsers, but JavaScript is increasingly used as a general-purpose programming language, using systems such as Node.js.</p>
<p><a id="c001_c1-para-0011"></a>ECMAScript 2015 possesses a set of features that make it an excellent medium for studying important programming constructs and data structures and for relating them to the linguistic features that support them. Its lexically scoped first-class functions and their syntactic support through lambda expressions provide direct and concise access to functional abstraction, and dynamic typing allows the adaptation to remain close to the Scheme original throughout the book. Above and beyond these considerations, programming in JavaScript is great fun.</p>
</section>
</section>
</section>
<section>
<h2><a id="c001_c1-sec-0005"></a><span>1.1</span> <a id="c001_c1-title-0006"></a>The Elements of Programming</h2>
<p class="paraaftertitle"><a id="c001_c1-para-0012"></a>A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three mechanisms for accomplishing this:</p>
<ul style="list-style-type:disc">
<li><b>primitive expressions</b>, which represent the simplest entities the language is concerned with,</li>
<li><b>means of combination</b>, by which compound elements are built from simpler ones, and</li>
<li><b>means of abstraction</b>, by which compound elements can be named and manipulated as units.</li>
</ul>
<p><a id="c001_c1-para-0016"></a>In programming, we deal with two kinds of elements: functions and data. (Later we will discover that they are really not so distinct.) Informally, data is “stuff” that we want to manipulate, and functions are descriptions of the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive functions and should have methods for combining and abstracting functions and data.</p>
<p><a id="c001_c1-para-0017"></a>In this chapter we will deal only with simple numerical data so that we can focus on the rules for building functions.<a id="c001_c1-fn-0001a"></a><a href="#c1-fn-0001"><sup>1</sup></a> In later chapters we will see that these same rules allow us to build functions to manipulate compound data as well.</p>
<section>
<h3><a id="c001_c1-sec-0006"></a><span>1.1.1</span> <a id="c001_c1-title-0007"></a>Expressions</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0018"></a>One easy way to get started at programming is to examine some typical interactions with an interpreter for the JavaScript language. You type a <i>statement</i>, and the interpreter responds by displaying the result of its <i>evaluating</i> that statement.</p>
<p><a id="c001_c1-para-0019"></a>One kind of statement you might type is an expression statement, which consists of an <i>expression</i> followed by a semicolon. One kind of primitive expression is a number. (More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present JavaScript with the program</p>
<p class="Sp-text-1"><a id="c001_c1-para-0020"></a>486;</p>
<p class="paracontinue"><a id="c001_c1-para-0021"></a>the interpreter will respond by printing<a id="c001_c1-fn-0002a"></a><a href="#c1-fn-0002"><sup>2</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-0022"></a><i>486</i></p>
<p><a id="c001_c1-para-0023"></a>Expressions representing numbers may be combined with operators (such as <span class="KeyTerm1">+</span> or <span class="KeyTerm1">*</span>) to form a compound expression that represents the application of a corresponding primitive function to those numbers. For example,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0024"></a>137 + 349;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0025"></a><i>486</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0026"></a>1000 - 334;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0027"></a><i>666</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0028"></a>5 * 99;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0029"></a><i>495</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0030"></a>10 / 4;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0031"></a><i>2.5</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0032"></a>2.7 + 10;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0033"></a><i>12.7</i></p>
<p><a id="c001_c1-para-0034"></a>Expressions such as these, which contain other expressions as components, are called <i>combinations</i>. Combinations that are formed by an <i>operator</i> symbol in the middle, and <i>operand</i> expressions to the left and right of it, are called <i>operator combinations</i>. The value of an operator combination is obtained by applying the function specified by the operator to the arguments that are the values of the operands.</p>
<p><a id="c001_c1-para-0035"></a>The convention of placing the operator between the operands is known as <i>infix notation</i>. It follows the mathematical notation that you are most likely familiar with from school and everyday life. As in mathematics, operator combinations can be <i>nested</i>, that is, they can have operands that themselves are operator combinations:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0036"></a>(3 * 5) + (10 - 6);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0037"></a><i>19</i></p>
<p class="paracontinue"><a id="c001_c1-para-0038"></a>As usual, parentheses are used to group operator combinations in order to avoid ambiguities. JavaScript also follows the usual conventions when parentheses are omitted: multiplication and division bind more strongly than addition and subtraction. For example,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0039"></a>3 * 5 + 10 / 2;</p>
<p class="paracontinue"><a id="c001_c1-para-0040"></a>stands for</p>
<p class="Sp-text-1"><a id="c001_c1-para-0041"></a>(3 * 5) + (10 / 2);</p>
<p class="paracontinue"><a id="c001_c1-para-0042"></a>We say that <span class="KeyTerm1">*</span> and <span class="KeyTerm1">/</span> have <i>higher precedence</i> than <span class="KeyTerm1">+</span> and <span class="KeyTerm1">-</span>. Sequences of additions and subtractions are read from left to right, as are sequences of multiplications and divisions. Thus,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0043"></a>1 - 5 / 2 * 4 + 3;</p>
<p class="paracontinue"><a id="c001_c1-para-0044"></a>stands for</p>
<p class="Sp-text-1"><a id="c001_c1-para-0045"></a>(1 - ((5 / 2) * 4)) + 3;</p>
<p class="paracontinue"><a id="c001_c1-para-0046"></a>We say that the operators <span class="KeyTerm1">+</span>, <span class="KeyTerm1">-</span>, <span class="KeyTerm1">*</span> and <span class="KeyTerm1">/</span> are <i>left-associative</i>.</p>
<p><a id="c001_c1-para-0047"></a>There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the JavaScript interpreter can evaluate. It is we humans who might get confused by still relatively simple expressions such as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0048"></a>3 * 2 * (3 - 5 + 4) + 27 / 6 * 10;</p>
<p class="paracontinue"><a id="c001_c1-para-0049"></a>which the interpreter would readily evaluate to be 57. We can help ourselves by writing such an expression in the form</p>
<p class="Sp-text-1"><a id="c001_c1-para-0050"></a>3 * 2 * (3 - 5 + 4)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0051"></a>+</p>
<p class="Sp-text-1"><a id="c001_c1-para-0052"></a>27 / 6 * 10;</p>
<p class="paracontinue"><a id="c001_c1-para-0053"></a>to visually separate the major components of the expression.</p>
<p><a id="c001_c1-para-0054"></a>Even with complex expressions, the interpreter always operates in the same basic cycle: It reads a statement typed by the user, evaluates the statement, and prints the result. This mode of operation is often expressed by saying that the interpreter runs in a <i>read-evaluate-print loop</i>. Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the statement.<a id="c001_c1-fn-0003a"></a><a href="#c1-fn-0003"><sup>3</sup></a></p>
</section>
<section>
<h3><a id="c001_c1-sec-0007"></a><span>1.1.2</span> <a id="c001_c1-title-0008"></a>Naming and the Environment</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0055"></a>A critical aspect of a programming language is the means it provides for using names to refer to computational objects, and our first such means are <i>constants</i>. We say that the name identifies a constant whose <i>value</i> is the object.</p>
<p><a id="c001_c1-para-0056"></a>In JavaScript, we name constants with <i>constant declarations</i>.</p>
<p class="Sp-text-1"><a id="c001_c1-para-0057"></a><b>const</b> size = 2;</p>
<p class="paracontinue"><a id="c001_c1-para-0058"></a>causes the interpreter to associate the value 2 with the name <span class="KeyTerm1">size</span>.<a id="c001_c1-fn-0004a"></a><a href="#c1-fn-0004"><sup>4</sup></a> Once the name <span class="KeyTerm1">size</span> has been associated with the number 2, we can refer to the value 2 by name:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0059"></a>size;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0060"></a><i>2</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0061"></a>5 * size;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0062"></a><i>10</i></p>
<p><a id="c001_c1-para-0063"></a>Here are further examples of the use of <span class="KeyTerm1"><b>const</b></span>:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0064"></a><b>const</b> pi = 3.14159;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0065"></a><b>const</b> radius = 10;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0066"></a>pi * radius * radius;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0067"></a><i>314.159</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0068"></a><b>const</b> circumference = 2 * pi * radius;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-5068"></a>circumference;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0069"></a><i>62.8318</i></p>
<p><a id="c001_c1-para-0070"></a>Constant declaration is our language's simplest means of abstraction, for it allows us to use simple names to refer to the results of compound operations, such as the <span class="KeyTerm1">circumference</span> computed above. In general, computational objects may have very complex structures, and it would be extremely inconvenient to have to remember and repeat their details each time we want to use them. Indeed, complex programs are constructed by building, step by step, computational objects of increasing complexity. The interpreter makes this step-by-step program construction particularly convenient because name-object associations can be created incrementally in successive interactions. This feature encourages the incremental development and testing of programs and is largely responsible for the fact that a JavaScript program usually consists of a large number of relatively simple functions.</p>
<p><a id="c001_c1-para-0071"></a>It should be clear that the possibility of associating values with names and later retrieving them means that the interpreter must maintain some sort of memory that keeps track of the name-object pairs. This memory is called the <i>environment</i> (more precisely the <i>program environment</i>, since we will see later that a computation may involve a number of different environments).<a id="c001_c1-fn-0005a"></a><a href="#c1-fn-0005"><sup>5</sup></a></p>
</section>
<section>
<h3><a id="c001_c1-sec-0008"></a><span>1.1.3</span> <a id="c001_c1-title-0009"></a>Evaluating Operator Combinations</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0072"></a>One of our goals in this chapter is to isolate issues about thinking procedurally. As a case in point, let us consider that, in evaluating operator combinations, the interpreter is itself following a procedure.</p>
<ul style="list-style-type:disc">
<li>To evaluate an operator combination, do the following:<ol class="BS_NumberList1">
<li><a id="c001_c1-li-0005"></a><span>1. </span>Evaluate the operand expressions of the combination.</li>
<li><a id="c001_c1-li-0006"></a><span>2. </span>Apply the function that is denoted by the operator to the arguments that are the values of the operands.</li>
</ol></li>
</ul>
<p class="paracontinue"><a id="c001_c1-para-0076"></a>Even this simple rule illustrates some important points about processes in general. First, observe that the first step dictates that in order to accomplish the evaluation process for a combination we must first perform the evaluation process on each operand of the combination. Thus, the evaluation rule is <i>recursive</i> in nature; that is, it includes, as one of its steps, the need to invoke the rule itself.</p>
<p><a id="c001_c1-para-0077"></a>Notice how succinctly the idea of recursion can be used to express what, in the case of a deeply nested combination, would otherwise be viewed as a rather complicated process. For example, evaluating</p>
<p class="Sp-text-1"><a id="c001_c1-para-0078"></a>(2 + 4 * 6) * (3 + 12);</p>
<p class="paracontinue"><a id="c001_c1-para-0079"></a>requires that the evaluation rule be applied to four different combinations. We can obtain a picture of this process by representing the combination in the form of a tree, as shown in <a id="c001_c1-fig-0001a"></a><a href="#c1-fig-0001">figure 1.1</a>. Each combination is represented by a node with branches corresponding to the operator and the operands of the combination stemming from it. The terminal nodes (that is, nodes with no branches stemming from them) represent either operators or numbers. Viewing evaluation in terms of the tree, we can imagine that the values of the operands percolate upward, starting from the terminal nodes and then combining at higher and higher levels. In general, we shall see that recursion is a very powerful technique for dealing with hierarchical, treelike objects. In fact, the “percolate values upward” form of the evaluation rule is an example of a general kind of process known as <i>tree accumulation</i>.</p>
<figure id="c001_c1-fig-0001"><img alt="c1-fig-0001.jpg" src="../images/c1-fig-0001.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c1-fig-0001a">Figure 1.1</a></span> <a id="c001_c1-para-0080"></a>Tree representation, showing the value of each subexpression.</p></figcaption></figure>
<p><a id="c001_c1-para-0081"></a>Next, observe that the repeated application of the first step brings us to the point where we need to evaluate, not combinations, but primitive expressions such as numerals or names. We take care of the primitive cases by stipulating that</p>
<ul style="list-style-type:disc">
<li>the values of numerals are the numbers that they name, and</li>
<li>the values of names are the objects associated with those names in the environment.</li>
</ul>
<p class="paracontinue"><a id="c001_c1-para-0084"></a>The key point to notice is the role of the environment in determining the meaning of the names in expressions. In an interactive language such as JavaScript, it is meaningless to speak of the value of an expression such as <span class="KeyTerm1">x + 1</span> without specifying any information about the environment that would provide a meaning for the name <span class="KeyTerm1">x</span>. As we shall see in chapter 3, the general notion of the environment as providing a context in which evaluation takes place will play an important role in our understanding of program execution.</p>
<p><a id="c001_c1-para-0085"></a>Notice that the evaluation rule given above does not handle declarations. For instance, evaluating <span class="KeyTerm1"><b>const</b> x = 3;</span> does not apply an equality operator <span class="KeyTerm1">=</span> to two arguments, one of which is the value of the name <span class="KeyTerm1">x</span> and the other of which is 3, since the purpose of the declaration is precisely to associate <span class="KeyTerm1">x</span> with a value. (That is, <span class="KeyTerm1"><b>const</b> x = 3;</span> is not a combination.)</p>
<p><a id="c001_c1-para-0086"></a>The letters in <span class="KeyTerm1"><b>const</b></span> are rendered in bold to indicate that it is a <i>keyword</i> in JavaScript. Keywords carry a particular meaning, and thus cannot be used as names. A keyword or a combination of keywords in a statement instructs the JavaScript interpreter to treat the statement in a special way. Each such <i>syntactic form</i> has its own evaluation rule. The various kinds of statements and expressions (each with its associated evaluation rule) constitute the syntax of the programming language.</p>
</section>
<section>
<h3><a id="c001_c1-sec-0009"></a><span>1.1.4</span> <a id="c001_c1-title-0010"></a>Compound Functions</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0087"></a>We have identified in JavaScript some of the elements that must appear in any powerful programming language:</p>
<ul style="list-style-type:disc">
<li>Numbers and arithmetic operations are primitive data and functions.</li>
<li>Nesting of combinations provides a means of combining operations.</li>
<li>Constant declarations that associate names with values provide a limited means of abstraction.</li>
</ul>
<p class="paracontinue"><a id="c001_c1-para-0091"></a>Now we will learn about <i>function declarations</i>, a much more powerful abstraction technique by which a compound operation can be given a name and then referred to as a unit.</p>
<p><a id="c001_c1-para-0092"></a>We begin by examining how to express the idea of “squaring.” We might say, “To square something, take it times itself.” This is expressed in our language as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0093"></a><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0094"></a> <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0095"></a>}</p>
<p><a id="c001_c1-para-0096"></a>We can understand this in the following way:</p>
<p><a id="c001_c1-para-0097"></a></p>
<figure id="c001_c1-fig-0002"><img alt="c1-fig-5001.jpg" src="../images/c1-fig-5001.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0098"></a>We have here a <i>compound function</i>, which has been given the name <span class="KeyTerm1">square</span>. The function represents the operation of multiplying something by itself. The thing to be multiplied is given a local name, <span class="KeyTerm1">x</span>, which plays the same role that a pronoun plays in natural language. Evaluating the declaration creates this compound function and associates it with the name <span class="KeyTerm1">square</span>.<a id="c001_c1-fn-0006a"></a><a href="#c1-fn-0006"><sup>6</sup></a></p>
<p><a id="c001_c1-para-0099"></a>The simplest form of a function declaration is</p>
<p class="Sp-text-1"><a id="c001_c1-para-0100"></a><b>function</b> <span class="KeyTerm2"><i>name</i></span>(<span class="KeyTerm2"><i>parameters</i></span>) { <b>return</b> <span class="KeyTerm2"><i>expression</i></span>; }</p>
<p class="paracontinue"><a id="c001_c1-para-0101"></a>The <i>name</i> is a symbol to be associated with the function definition in the environment.<a id="c001_c1-fn-0007a"></a><a href="#c1-fn-0007"><sup>7</sup></a> The <i>parameters</i> are the names used within the body of the function to refer to the corresponding arguments of the function. The <i>parameters</i> are grouped within parentheses and separated by commas, as they will be in an application of the function being declared. In the simplest form, the <i>body</i> of a function declaration is a single <i>return statement</i>,<a id="c001_c1-fn-0008a"></a><a href="#c1-fn-0008"><sup>8</sup></a> which consists of the keyword <span class="KeyTerm1"><b>return</b></span> followed by the <i>return expression</i> that will yield the value of the function application, when the parameters are replaced by the actual arguments to which the function is applied. Like constant declarations and expression statements, return statements end with a semicolon.</p>
<p><a id="c001_c1-para-0102"></a>Having declared <span class="KeyTerm1">square</span>, we can now use it in a <i>function application</i> expression, which we turn into a statement using a semicolon:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0103"></a>square(21);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0104"></a><i>441</i></p>
<p class="paracontinue"><a id="c001_c1-para-0105"></a>Function applications are—after operator combinations—the second kind of combination of expressions into larger expressions that we encounter. The general form of a function application is</p>
<p class="Sp-text-1"><a id="c001_c1-para-0106"></a><span class="KeyTerm2"><i>function</i>-<i>expression</i></span>(<span class="KeyTerm2"><i>argument</i>-<i>expressions</i></span>)</p>
<p class="paracontinue"><a id="c001_c1-para-0107"></a>where the <i>function</i>-<i>expression</i> of the application specifies the function to be applied to the comma-separated <i>argument</i>-<i>expressions</i>. To evaluate a function application, the interpreter follows a procedure quite similar to the procedure for operator combinations described in section 1.1.3.</p>
<ul style="list-style-type:disc">
<li>To evaluate a function application, do the following:<ol class="BS_NumberList1">
<li><a id="c001_c1-li-0013"></a><span>1. </span>Evaluate the subexpressions of the application, namely the function expression and the argument expressions.</li>
<li><a id="c001_c1-li-0014"></a><span>2. </span>Apply the function that is the value of the function expression to the values of the argument expressions.</li>
</ol></li>
</ul>
<p class="Sp-text-1"><a id="c001_c1-para-0111"></a>square(2 + 5);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0112"></a><i>49</i></p>
<p class="paracontinue"><a id="c001_c1-para-0113"></a>Here, the argument expression is itself a compound expression, the operator combination <span class="KeyTerm1">2 + 5</span>.</p>
<p class="Sp-text-1"><a id="c001_c1-para-0114"></a>square(square(3));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0115"></a><i>81</i></p>
<p class="paracontinue"><a id="c001_c1-para-0116"></a>Of course function application expressions can also serve as argument expressions.</p>
<p><a id="c001_c1-para-0117"></a>We can also use <span class="KeyTerm1">square</span> as a building block in defining other functions. For example, <i>x</i><sup>2</sup> + <i>y</i><sup>2</sup> can be expressed as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0118"></a>square(x) + square(y)</p>
<p class="paracontinue"><a id="c001_c1-para-0119"></a>We can easily declare a function <span class="KeyTerm1">sum_of_squares</span><a id="c001_c1-fn-0009a"></a><a href="#c1-fn-0009"><sup>9</sup></a> that, given any two numbers as arguments, produces the sum of their squares:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0120"></a><b>function</b> sum_of_squares(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0121"></a> <b>return</b> square(x) + square(y);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0122"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0123"></a>sum_of_squares(3, 4);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0124"></a><i>25</i></p>
<p class="paracontinue"><a id="c001_c1-para-0125"></a>Now we can use <span class="KeyTerm1">sum_of_squares</span> as a building block in constructing further functions:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0126"></a><b>function</b> f(a) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0127"></a> <b>return</b> sum_of_squares(a + 1, a * 2);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0128"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0129"></a>f(5);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0130"></a><i>136</i></p>
<p><a id="c001_c1-para-0131"></a>In addition to compound functions, any JavaScript environment provides primitive functions that are built into the interpreter or loaded from libraries. Besides the primitive functions provided by the operators, the JavaScript environment used in this book includes additional primitive functions such as the function <span class="KeyTerm1">math_log</span>, which computes the natural logarithm of its argument.<a id="c001_c1-fn-0010a"></a><a href="#c1-fn-0010"><sup>10</sup></a> These additional primitive functions are used in exactly the same way as compound functions; evaluating the application <span class="KeyTerm1">math_log(1)</span> results in the number 0. Indeed, one could not tell by looking at the definition of <span class="KeyTerm1">sum_of_squares</span> given above whether <span class="KeyTerm1">square</span> was built into the interpreter, loaded from a library, or defined as a compound function.</p>
</section>
<section>
<h3><a id="c001_c1-sec-0010"></a><span>1.1.5</span> <a id="c001_c1-title-0011"></a>The Substitution Model for Function Application</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0132"></a>To evaluate a function application, the interpreter follows the process described in section 1.1.4. That is, the interpreter evaluates the elements of the application and applies the function (which is the value of the function expression of the application) to the arguments (which are the values of the argument expressions of the application).</p>
<p><a id="c001_c1-para-0133"></a>We can assume that the application of primitive functions is handled by the interpreter or libraries. For compound functions, the application process is as follows:</p>
<ul style="list-style-type:disc">
<li>To apply a compound function to arguments, evaluate the return expression of the function with each parameter replaced by the corresponding argument.<a id="c001_c1-fn-0011a"></a><a href="#c1-fn-0011"><sup>11</sup></a></li>
</ul>
<p class="paracontinue"><a id="c001_c1-para-0135"></a>To illustrate this process, let's evaluate the application</p>
<p class="Sp-text-1"><a id="c001_c1-para-0136"></a>f(5)</p>
<p class="paracontinue"><a id="c001_c1-para-0137"></a>where <span class="KeyTerm1">f</span> is the function declared in section 1.1.4. We begin by retrieving the return expression of <span class="KeyTerm1">f</span>:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0138"></a>sum_of_squares(a + 1, a * 2)</p>
<p class="paracontinue"><a id="c001_c1-para-0139"></a>Then we replace the parameter <span class="KeyTerm1">a</span> by the argument 5:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0140"></a>sum_of_squares(5 + 1, 5 * 2)</p>
<p class="paracontinue"><a id="c001_c1-para-0141"></a>Thus the problem reduces to the evaluation of an application with two arguments and a function expression <span class="KeyTerm1">sum_of_squares</span>. Evaluating this application involves three subproblems. We must evaluate the function expression to get the function to be applied, and we must evaluate the argument expressions to get the arguments. Now <span class="KeyTerm1">5 + 1</span> produces 6 and <span class="KeyTerm1">5 * 2</span> produces 10, so we must apply the <span class="KeyTerm1">sum_of_squares</span> function to 6 and 10. These values are substituted for the parameters <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> in the body of <span class="KeyTerm1">sum_of_squares</span>, reducing the expression to</p>
<p class="Sp-text-1"><a id="c001_c1-para-0142"></a>square(6) + square(10)</p>
<p class="paracontinue"><a id="c001_c1-para-0143"></a>If we use the declaration of <span class="KeyTerm1">square</span>, this reduces to</p>
<p class="Sp-text-1"><a id="c001_c1-para-0144"></a>(6 * 6) + (10 * 10)</p>
<p class="paracontinue"><a id="c001_c1-para-0145"></a>which reduces by multiplication to</p>
<p class="Sp-text-1"><a id="c001_c1-para-0146"></a>36 + 100</p>
<p class="paracontinue"><a id="c001_c1-para-0147"></a>and finally to</p>
<p class="Sp-text-1"><a id="c001_c1-para-0148"></a>136</p>
<p><a id="c001_c1-para-0149"></a>The process we have just described is called the <i>substitution model</i> for function application. It can be taken as a model that determines the “meaning” of function application, insofar as the functions in this chapter are concerned. However, there are two points that should be stressed:</p>
<ul style="list-style-type:disc">
<li>The purpose of the substitution is to help us think about function application, not to provide a description of how the interpreter really works. Typical interpreters do not evaluate function applications by manipulating the text of a function to substitute values for the parameters. In practice, the “substitution” is accomplished by using a local environment for the parameters. We will discuss this more fully in chapters 3 and 4 when we examine the implementation of an interpreter in detail.</li>
<li>Over the course of this book, we will present a sequence of increasingly elaborate models of how interpreters work, culminating with a complete implementation of an interpreter and compiler in chapter 5. The substitution model is only the first of these models—a way to get started thinking formally about the evaluation process. In general, when modeling phenomena in science and engineering, we begin with simplified, incomplete models. As we examine things in greater detail, these simple models become inadequate and must be replaced by more refined models. The substitution model is no exception. In particular, when we address in chapter 3 the use of functions with “mutable data,” we will see that the substitution model breaks down and must be replaced by a more complicated model of function application.<a id="c001_c1-fn-0012a"></a><a href="#c1-fn-0012"><sup>12</sup></a></li>
</ul>
<section>
<h5><a id="c001_c1-sec-0011"></a><a id="c001_c1-title-0012"></a>Applicative order versus normal order</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0152"></a>According to the description of evaluation given in section 1.1.4, the interpreter first evaluates the function and argument expressions and then applies the resulting function to the resulting arguments. This is not the only way to perform evaluation. An alternative evaluation model would not evaluate the arguments until their values were needed. Instead it would first substitute argument expressions for parameters until it obtained an expression involving only operators and primitive functions, and would then perform the evaluation. If we used this method, the evaluation of</p>
<p class="Sp-text-1"><a id="c001_c1-para-0153"></a>f(5)</p>
<p class="paracontinue"><a id="c001_c1-para-0154"></a>would proceed according to the sequence of expansions</p>
<p class="Sp-text-1"><a id="c001_c1-para-0155"></a>sum_of_squares(5 + 1, 5 * 2)</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0156"></a>square(5 + 1)     + square(5 * 2)</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0157"></a>(5 + 1) * (5 + 1) + (5 * 2) * (5 * 2)</p>
<p class="paracontinue"><a id="c001_c1-para-0158"></a>followed by the reductions</p>
<p class="Sp-text-1"><a id="c001_c1-para-0159"></a>6    *    6    +    10    *    10</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0160"></a>    36         +         100</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0161"></a>              136</p>
<p class="paracontinue"><a id="c001_c1-para-0162"></a>This gives the same answer as our previous evaluation model, but the process is different. In particular, the evaluations of <span class="KeyTerm1">5 + 1</span> and <span class="KeyTerm1">5 * 2</span> are each performed twice here, corresponding to the reduction of the expression</p>
<p class="Sp-text-1"><a id="c001_c1-para-0163"></a>x * x</p>
<p class="paracontinue"><a id="c001_c1-para-0164"></a>with <span class="KeyTerm1">x</span> replaced respectively by <span class="KeyTerm1">5 + 1</span> and <span class="KeyTerm1">5 * 2</span>.</p>
<p><a id="c001_c1-para-0165"></a>This alternative “fully expand and then reduce” evaluation method is known as <i>normal-order evaluation</i>, in contrast to the “evaluate the arguments and then apply” method that the interpreter actually uses, which is called <i>applicative-order evaluation</i>. It can be shown that, for function applications that can be modeled using substitution (including all the functions in the first two chapters of this book) and that yield legitimate values, normal-order and applicative-order evaluation produce the same value. (See exercise 1.5 for an instance of an “illegitimate” value where normal-order and applicative-order evaluation do not give the same result.)</p>
<p><a id="c001_c1-para-0166"></a>JavaScript uses applicative-order evaluation, partly because of the additional efficiency obtained from avoiding multiple evaluations of expressions such as those illustrated with <span class="KeyTerm1">5 + 1</span> and <span class="KeyTerm1">5 * 2</span> above and, more significantly, because normalorder evaluation becomes much more complicated to deal with when we leave the realm of functions that can be modeled by substitution. On the other hand, normalorder evaluation can be an extremely valuable tool, and we will investigate some of its implications in chapters 3 and 4.<a id="c001_c1-fn-0013a"></a><a href="#c1-fn-0013"><sup>13</sup></a></p>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0012"></a><span>1.1.6</span> <a id="c001_c1-title-0013"></a>Conditional Expressions and Predicates</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0167"></a>The expressive power of the class of functions that we can define at this point is very limited, because we have no way to make tests and to perform different operations depending on the result of a test. For instance, we cannot declare a function that computes the absolute value of a number by testing whether the number is nonnegative and taking different actions in each case according to the rule</p>
<p><a id="c001_c1-para-0168"></a></p>
<figure id="c001_c1-fig-0003"><img alt="c1-fig-5002.jpg" src="../images/c1-fig-5002.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0169"></a>This construct is a <i>case analysis</i> and can be written in JavaScript using a <i>conditional expression</i> as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0170"></a><b>function</b> abs(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0171"></a> <b>return</b> x &gt;= 0 ? x : - x;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0172"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0173"></a>which could be expressed in English as “If <i>x</i> is greater than or equal to zero, return <i>x</i>; otherwise return –<i>x</i>.” The general form of a conditional expression is</p>
<p class="Sp-text-1"><a id="c001_c1-para-0174"></a><span class="KeyTerm2"><i>predicate</i></span> ? <span class="KeyTerm2"><i>consequent</i>-<i>expression</i></span> : <span class="KeyTerm2"><i>alternative</i>-<i>expression</i></span></p>
<p class="paracontinue"><a id="c001_c1-para-0175"></a>Conditional expressions begin with a <i>predicate</i>—that is, an expression whose value is either <i>true</i> or <i>false</i>, two distinguished <i>boolean</i> values in JavaScript. The primitive boolean expressions <span class="KeyTerm1"><b>true</b></span> and <span class="KeyTerm1"><b>false</b></span> trivially evaluate to the boolean values true and false, respectively. The <i>predicate</i> is followed by a question mark, the <i>consequent</i>-<i>expression</i>, a colon, and finally the <i>alternative</i>-<i>expression</i>.</p>
<p><a id="c001_c1-para-0176"></a>To evaluate a conditional expression, the interpreter starts by evaluating the <i>predicate</i> of the expression. If the <i>predicate</i> evaluates to true, the interpreter evaluates the <i>consequent</i>-<i>expression</i> and returns its value as the value of the conditional. If the <i>predicate</i> evaluates to false, it evaluates the <i>alternative</i>-<i>expression</i> and returns its value as the value of the conditional.<a id="c001_c1-fn-0014a"></a><a href="#c1-fn-0014"><sup>14</sup></a></p>
<p><a id="c001_c1-para-0177"></a>The word <i>predicate</i> is used for operators and functions that return true or false, as well as for expressions that evaluate to true or false. The absolute-value function <span class="KeyTerm1">abs</span> makes use of the primitive predicate <span class="KeyTerm1">&gt;=</span>, an operator that takes two numbers as arguments and tests whether the first number is greater than or equal to the second number, returning true or false accordingly.</p>
<p><a id="c001_c1-para-0178"></a>If we prefer to handle the zero case separately, we can specify the function that computes the absolute value of a number by writing</p>
<p><a id="c001_c1-para-0179"></a></p>
<figure id="c001_c1-fig-0004"><img alt="c1-fig-5003.jpg" src="../images/c1-fig-5003.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0180"></a>In JavaScript, we express a case analysis with multiple cases by nesting conditional expressions as alternative expressions inside other conditional expressions:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0181"></a><b>function</b> abs(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0182"></a> <b>return</b> x &gt; 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0183"></a>           ? x</p>
<p class="Sp-text-1"><a id="c001_c1-para-0184"></a>           : x === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0185"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0186"></a>           : - x;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0187"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0188"></a>Parentheses are not needed around the alternative expression <span class="KeyTerm1">x === 0 ? 0 : - x</span>, because the conditional-expression syntactic form is right-associative. The interpreter ignores spaces and line breaks, here inserted for readability to align the <span class="KeyTerm1">?</span>'s and <span class="KeyTerm1">:</span>'s under the first predicate of the case analysis. The general form of a case analysis is</p>
<p class="Sp-text-1"><a id="c001_c1-para-0189"></a><span class="KeyTerm2"><i>p</i><sub>1</sub></span></p>
<p class="Sp-text-1"><a id="c001_c1-para-0190"></a>? <span class="KeyTerm2"><i>e</i><sub>1</sub></span></p>
<p class="Sp-text-1"><a id="c001_c1-para-0191"></a>: <span class="KeyTerm2"><i>p</i><sub>2</sub></span></p>
<p class="Sp-text-1"><a id="c001_c1-para-0192"></a>? <span class="KeyTerm2"><i>e</i><sub>2</sub></span></p>
<p class="Sp-text-1"><a id="c001_c1-para-0193"></a>⁝</p>
<p class="Sp-text-1"><a id="c001_c1-para-0194"></a>: <span class="KeyTerm2"><i>p<sub>n</sub></i></span></p>
<p class="Sp-text-1"><a id="c001_c1-para-0195"></a>? <span class="KeyTerm2"><i>e<sub>n</sub></i></span></p>
<p class="Sp-text-1"><a id="c001_c1-para-0196"></a>: <span class="KeyTerm2"><i>final</i>-<i>alternative</i>-<i>expression</i></span></p>
<p class="paracontinue"><a id="c001_c1-para-0197"></a>We call a predicate <i>p<sub>i </sub></i>together with its consequent expression <i>e<sub>i </sub></i>a <i>clause</i>. A case analysis can be seen as a sequence of clauses, followed by a final alternative expression. According to the evaluation of conditional expressions, a case analysis is evaluated by first evaluating the predicate <i>p</i><sub>1</sub>. If its value is false, then <i>p</i><sub>2</sub> is evaluated. If <i>p</i><sub>2</sub>'s value is also false, then <i>p</i><sub>3</sub> is evaluated. This process continues until a predicate is found whose value is true, in which case the interpreter returns the value of the corresponding consequent expression <i>e</i> of the clause as the value of the case analysis. If none of the <i>p</i>'s is found to be true, the value of the case analysis is the value of the final alternative expression.</p>
<p><a id="c001_c1-para-0198"></a>In addition to primitive predicates such as <span class="KeyTerm1">&gt;=</span>, <span class="KeyTerm1">&gt;</span>, <span class="KeyTerm1">&lt;</span>, <span class="KeyTerm1">&lt;=</span>, <span class="KeyTerm1">===</span>, and <span class="KeyTerm1">!==</span> that are applied to numbers,<a id="c001_c1-fn-0015a"></a><a href="#c1-fn-0015"><sup>15</sup></a> there are logical composition operations, which enable us to construct compound predicates. The three most frequently used are these:</p>
<ul style="list-style-type:disc">
<li><i>expression</i><sub>1</sub> <span class="KeyTerm1">&amp;&amp;</span> <i>expression</i><sub>2</sub>
<p class="paraaftertitle"><a id="c001_c1-para-0200"></a>This operation expresses <i>logical conjunction</i>, meaning roughly the same as the English word “and.” This syntactic form is syntactic sugar<a id="c001_c1-fn-0016a"></a><a href="#c1-fn-0016"><sup>16</sup></a> for</p>
<p class="paraaftertitle"><a id="c001_c1-para-0201"></a><i>expression</i><sub>1</sub> <span class="KeyTerm1">?</span> <i>expression</i><sub>2</sub> <span class="KeyTerm1">: <b>false</b></span>.</p></li>
<li><i>expression</i><sub>1</sub> <span class="KeyTerm1">||</span> <i>expression</i><sub>2</sub>
<p class="paraaftertitle"><a id="c001_c1-para-0203"></a>This operation expresses <i>logical disjunction</i>, meaning roughly the same as the English word “or.” This syntactic form is syntactic sugar for</p>
<p class="paraaftertitle"><a id="c001_c1-para-0204"></a><i>expression</i><sub>1</sub> <span class="KeyTerm1">? <b>true</b> :</span> <i>expression</i><sub>2</sub>.</p></li>
<li><span class="KeyTerm1">!</span> <i>expression</i>
<p class="paraaftertitle"><a id="c001_c1-para-0206"></a>This operation expresses <i>logical negation</i>, meaning roughly the same as the English word “not.” The value of the expression is true when <i>expression</i> evaluates to false, and false when <i>expression</i> evaluates to true.</p></li>
</ul>
<p class="paracontinue"><a id="c001_c1-para-0207"></a>Notice that <span class="KeyTerm1">&amp;&amp;</span> and <span class="KeyTerm1">||</span> are syntactic forms, not operators; their right-hand expression is not always evaluated. The operator <span class="KeyTerm1">!</span>, on the other hand, follows the evaluation rule of section 1.1.3. It is a <i>unary</i> operator, which means that it takes only one argument, whereas the arithmetic operators and primitive predicates discussed so far are <i>binary</i>, taking two arguments. The operator <span class="KeyTerm1">!</span> precedes its argument; we call it a <i>prefix operator</i>. Another prefix operator is the numeric negation operator, an example of which is the expression <span class="KeyTerm1">- x</span> in the <span class="KeyTerm1">abs</span> functions above.</p>
<p><a id="c001_c1-para-0208"></a>As an example of how these predicates are used, the condition that a number <i>x</i> be in the range 5 &lt; <i>x</i> &lt; 10 may be expressed as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0209"></a>x &gt; 5 &amp;&amp; x &lt; 10</p>
<p class="paracontinue"><a id="c001_c1-para-0210"></a>The syntactic form <span class="KeyTerm1">&amp;&amp;</span> has lower precedence than the comparison operators <span class="KeyTerm1">&gt;</span> and <span class="KeyTerm1">&lt;</span>, and the conditional-expression syntactic form <span class="KeyTerm1">· · · ?· · · :· · ·</span> has lower precedence than any other operator we have encountered so far, a property we used in the <span class="KeyTerm1">abs</span> functions above.</p>
<p><a id="c001_c1-para-0211"></a>As another example, we can declare a predicate to test whether one number is greater than or equal to another as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0212"></a><b>function</b> greater_or_equal(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0213"></a> <b>return</b> x &gt; y || x === y;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0214"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0215"></a>or alternatively as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0216"></a><b>function</b> greater_or_equal(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0217"></a> <b>return</b> ! (x &lt; y);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0218"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0219"></a>The function <span class="KeyTerm1">greater_or_equal</span>, when applied to two numbers, behaves the same as the operator <span class="KeyTerm1">&gt;=</span>. Unary operators have higher precedence than binary operators, which makes the parentheses in this example necessary.</p>
<section>
<h5><a id="c001_c1-sec-0013"></a><a id="c001_c1-title-0014"></a>Exercise 1.1</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0220"></a>Below is a sequence of statements. What is the result printed by the interpreter in response to each statement? Assume that the sequence is to be evaluated in the order in which it is presented.</p>
<p class="Sp-text-1"><a id="c001_c1-para-0221"></a>10;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0222"></a>5 + 3 + 4;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0223"></a>9 - 1;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0224"></a>6 / 2;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0225"></a>2 * 4 + (4 - 6);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0226"></a><b>const</b> a = 3;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0227"></a><b>const</b> b = a + 1;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0228"></a> a + b + a * b;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0229"></a>a === b;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0230"></a>b &gt; a &amp;&amp; b &lt; a * b ? b : a;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0231"></a>a === 4</p>
<p class="Sp-text-1"><a id="c001_c1-para-0232"></a>? 6</p>
<p class="Sp-text-1"><a id="c001_c1-para-0233"></a>: b === 4</p>
<p class="Sp-text-1"><a id="c001_c1-para-0234"></a>? 6 + 7 + a</p>
<p class="Sp-text-1"><a id="c001_c1-para-0235"></a>: 25;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0236"></a>2 + (b &gt; a ? b : a);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0237"></a>(a &gt; b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0238"></a>? a</p>
<p class="Sp-text-1"><a id="c001_c1-para-0239"></a>: a &lt; b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0240"></a>? b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0241"></a>: -1)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0242"></a>*</p>
<p class="Sp-text-1"><a id="c001_c1-para-0243"></a>(a + 1);</p>
<p class="paracontinue"><a id="c001_c1-para-0244"></a>The parentheses around the conditional expressions in the last two statements are necessary because the conditional-expression syntactic form has lower precedence than the arithmetic operators <span class="KeyTerm1">+</span> and <span class="KeyTerm1">*</span>.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0014"></a><a id="c001_c1-title-0015"></a>Exercise 1.2</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0245"></a>Translate the following expression into JavaScript</p>
<p><a id="c001_c1-para-0246"></a></p>
<figure id="c001_c1-fig-0005"><img alt="c1-fig-5004.jpg" src="../images/c1-fig-5004.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
</section>
<section>
<h5><a id="c001_c1-sec-0015"></a><a id="c001_c1-title-0016"></a>Exercise 1.3</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0247"></a>Declare a function that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0016"></a><a id="c001_c1-title-0017"></a>Exercise 1.4</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0248"></a>Observe that our model of evaluation allows for applications whose function expressions are compound expressions. Use this observation to describe the behavior of <span class="KeyTerm1">a_plus_abs_b</span>:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0249"></a><b>function</b> plus(a, b) { <b>return</b> a + b; }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0250"></a><b>function</b> minus(a, b) { <b>return</b> a - b; }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0251"></a><b>function</b> a_plus_abs_b(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0252"></a> <b>return</b> (b &gt;= 0 ? plus : minus)(a, b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0253"></a>}</p>
</section>
<section>
<h5><a id="c001_c1-sec-0017"></a><a id="c001_c1-title-0018"></a>Exercise 1.5</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0254"></a>Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation. He declares the following two functions:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0255"></a><b>function</b> p() { <b>return</b> p(); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0256"></a><b>function</b> test(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0257"></a> <b>return</b> x === 0 ? 0 : y;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0258"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0259"></a>Then he evaluates the statement</p>
<p class="Sp-text-1"><a id="c001_c1-para-0260"></a>test(0, p());</p>
<p class="paracontinue"><a id="c001_c1-para-0261"></a>What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for conditional expressions is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)</p>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0018"></a><span>1.1.7</span> <a id="c001_c1-title-0019"></a>Example: Square Roots by Newton's Method</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0262"></a>Functions, as introduced above, are much like ordinary mathematical functions. They specify a value that is determined by one or more parameters. But there is an important difference between mathematical functions and computer functions. Computer functions must be effective.</p>
<p><a id="c001_c1-para-0263"></a>As a case in point, consider the problem of computing square roots. We can define the square-root function as</p>
<p class="Sp-text-2"><a id="c001_c1-para-0264"></a><img alt="c1-fig-5005.jpg" src="../images/c1-fig-5005.jpg"/> = the <i>y</i> such that <i>y</i> ≥ 0 and <i>y</i><sup>2 </sup>= <i>x</i></p>
<p class="paracontinue"><a id="c001_c1-para-0265"></a>This describes a perfectly legitimate mathematical function. We could use it to recognize whether one number is the square root of another, or to derive facts about square roots in general. On the other hand, the definition does not describe a computer function. Indeed, it tells us almost nothing about how to actually find the square root of a given number. It will not help matters to rephrase this definition in pseudo-JavaScript:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0266"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0267"></a> <b>return</b> the y with y &gt;= 0 &amp;&amp; square(y) === x;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0268"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0269"></a>This only begs the question.</p>
<p><a id="c001_c1-para-0270"></a>The contrast between mathematical function and computer function is a reflection of the general distinction between describing properties of things and describing how to do things, or, as it is sometimes referred to, the distinction between declarative knowledge and imperative knowledge. In mathematics we are usually concerned with declarative (what is) descriptions, whereas in computer science we are usually concerned with imperative (how to) descriptions.<a id="c001_c1-fn-0017a"></a><a href="#c1-fn-0017"><sup>17</sup></a></p>
<p><a id="c001_c1-para-0271"></a>How does one compute square roots? The most common way is to use Newton's method of successive approximations, which says that whenever we have a guess <i>y</i> for the value of the square root of a number <i>x</i>, we can perform a simple manipulation to get a better guess (one closer to the actual square root) by averaging <i>y</i> with <i>x</i>/<i>y</i>.<a id="c001_c1-fn-0018a"></a><a href="#c1-fn-0018"><sup>18</sup></a> For example, we can compute the square root of 2 as follows. Suppose our initial guess is 1:</p>
<p><a id="c001_c1-para-0272"></a></p>
<figure id="c001_c1-fig-0006"><img alt="c1-fig-5006.jpg" src="../images/c1-fig-5006.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0273"></a>Continuing this process, we obtain better and better approximations to the square root.</p>
<p><a id="c001_c1-para-0274"></a>Now let's formalize the process in terms of functions. We start with a value for the radicand (the number whose square root we are trying to compute) and a value for the guess. If the guess is good enough for our purposes, we are done; if not, we must repeat the process with an improved guess. We write this basic strategy as a function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0275"></a><b>function</b> sqrt_iter(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0276"></a> <b>return</b> is_good_enough(guess, x)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0277"></a>           ? guess</p>
<p class="Sp-text-1"><a id="c001_c1-para-0278"></a>           : sqrt_iter(improve(guess, x), x);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0279"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0280"></a>A guess is improved by averaging it with the quotient of the radicand and the old guess:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0281"></a><b>function</b> improve(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0282"></a> <b>return</b> average(guess, x / guess);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0283"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0284"></a>where</p>
<p class="Sp-text-1"><a id="c001_c1-para-0285"></a><b>function</b> average(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0286"></a> <b>return</b> (x + y) / 2;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0287"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0288"></a>We also have to say what we mean by “good enough.” The following will do for illustration, but it is not really a very good test. (See exercise 1.7.) The idea is to improve the answer until it is close enough so that its square differs from the radicand by less than a predetermined tolerance (here 0.001):<a id="c001_c1-fn-0019a"></a><a href="#c1-fn-0019"><sup>19</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-0289"></a><b>function</b> is_good_enough(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0290"></a> <b>return</b> abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0291"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0292"></a>Finally, we need a way to get started. For instance, we can always guess that the square root of any number is 1:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0293"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0294"></a> <b>return</b> sqrt_iter(1, x);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0295"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0296"></a>If we type these declarations to the interpreter, we can use <span class="KeyTerm1">sqrt</span> just as we can use any function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0297"></a>sqrt(9);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0298"></a><i>3.00009155413138</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0299"></a>sqrt(100 + 37);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0300"></a><i>11.704699917758145</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0301"></a>sqrt(sqrt(2) + sqrt(3));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0302"></a><i>1.7739279023207892</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0303"></a>square(sqrt(1000));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0304"></a><i>1000.000369924366</i></p>
<p><a id="c001_c1-para-0305"></a>The <span class="KeyTerm1">sqrt</span> program also illustrates that the simple functional language we have introduced so far is sufficient for writing any purely numerical program that one could write in, say, C or Pascal. This might seem surprising, since we have not included in our language any iterative (looping) constructs that direct the computer to do something over and over again. The function <span class="KeyTerm1">sqrt_iter</span>, on the other hand, demonstrates how iteration can be accomplished using no special construct other than the ordinary ability to call a function.<a id="c001_c1-fn-0020a"></a><a href="#c1-fn-0020"><sup>20</sup></a></p>
<section>
<h5><a id="c001_c1-sec-0019"></a><a id="c001_c1-title-0020"></a>Exercise 1.6</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0306"></a>Alyssa P. Hacker doesn't like the syntax of conditional expressions, involving the characters <span class="KeyTerm1">?</span> and <span class="KeyTerm1">:</span>. “Why can't I just declare an ordinary conditional function whose application works just like conditional expressions?” she asks.<a id="c001_c1-fn-0021a"></a><a href="#c1-fn-0021"><sup>21</sup></a> Alyssa's friend Eva Lu Ator claims this can indeed be done, and she declares a <span class="KeyTerm1">conditional</span> function as follows:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0307"></a><b>function</b> conditional(predicate, then_clause, else_clause) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0308"></a> <b>return</b> predicate ? then_clause : else_clause;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0309"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0310"></a>Eva demonstrates the program for Alyssa:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0311"></a>conditional(2 === 3, 0, 5);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0312"></a><i>5</i></p>
<p class="Sp-text-1"><a id="c001_c1-para-0313"></a>conditional(1 === 1, 0, 5);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0314"></a><i>0</i></p>
<p class="paracontinue"><a id="c001_c1-para-0315"></a>Delighted, Alyssa uses <span class="KeyTerm1">conditional</span> to rewrite the square-root program:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0316"></a><b>function</b> sqrt_iter(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0317"></a> <b>return</b> conditional(is_good_enough(guess, x),</p>
<p class="Sp-text-1"><a id="c001_c1-para-0318"></a>                        guess,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0319"></a>                        sqrt_iter(improve(guess, x),</p>
<p class="Sp-text-1"><a id="c001_c1-para-0320"></a>                                  x));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0321"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0322"></a>What happens when Alyssa attempts to use this to compute square roots? Explain.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0020"></a><a id="c001_c1-title-0021"></a>Exercise 1.7</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0323"></a>The <span class="KeyTerm1">is_good_enough</span> test used in computing square roots will not be very effective for finding the square roots of very small numbers. Also, in real computers, arithmetic operations are almost always performed with limited precision. This makes our test inadequate for very large numbers. Explain these statements, with examples showing how the test fails for small and large numbers. An alternative strategy for implementing <span class="KeyTerm1">is_good_enough</span> is to watch how <span class="KeyTerm1">guess</span> changes from one iteration to the next and to stop when the change is a very small fraction of the guess. Design a square-root function that uses this kind of end test. Does this work better for small and large numbers?</p>
</section>
<section>
<h5><a id="c001_c1-sec-0021"></a><a id="c001_c1-title-0022"></a>Exercise 1.8</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0324"></a>Newton's method for cube roots is based on the fact that if <i>y</i> is an approximation to the cube root of <i>x</i>, then a better approximation is given by the value</p>
<p><a id="c001_c1-para-0325"></a></p>
<figure id="c001_c1-fig-0007"><img alt="c1-fig-5007.jpg" src="../images/c1-fig-5007.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0326"></a>Use this formula to implement a cube-root function analogous to the square-root function. (In section 1.3.4 we will see how to implement Newton's method in general as an abstraction of these square-root and cube-root functions.)</p>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0022"></a><span>1.1.8</span> <a id="c001_c1-title-0023"></a>Functions as Black-Box Abstractions</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0327"></a>The function <span class="KeyTerm1">sqrt</span> is our first example of a process defined by a set of mutually defined functions. Notice that the declaration of <span class="KeyTerm1">sqrt_iter</span> is <i>recursive</i>; that is, the function is defined in terms of itself. The idea of being able to define a function in terms of itself may be disturbing; it may seem unclear how such a “circular” definition could make sense at all, much less specify a well-defined process to be carried out by a computer. This will be addressed more carefully in section 1.2. But first let's consider some other important points illustrated by the <span class="KeyTerm1">sqrt</span> example.</p>
<p><a id="c001_c1-para-0328"></a>Observe that the problem of computing square roots breaks up naturally into a number of subproblems: how to tell whether a guess is good enough, how to improve a guess, and so on. Each of these tasks is accomplished by a separate function. The entire <span class="KeyTerm1">sqrt</span> program can be viewed as a cluster of functions (shown in <a id="c001_c1-fig-0008a"></a><a href="#c1-fig-0008">figure 1.2</a>) that mirrors the decomposition of the problem into subproblems.</p>
<figure id="c001_c1-fig-0008"><img alt="c1-fig-0002.jpg" src="../images/c1-fig-0002.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c1-fig-0008a">Figure 1.2</a></span> <a id="c001_c1-para-0329"></a>Functional decomposition of the <span class="KeyTerm1">sqrt</span> program.</p></figcaption></figure>
<p><a id="c001_c1-para-0330"></a>The importance of this decomposition strategy is not simply that one is dividing the program into parts. After all, we could take any large program and divide it into parts—the first ten lines, the next ten lines, the next ten lines, and so on. Rather, it is crucial that each function accomplishes an identifiable task that can be used as a module in defining other functions. For example, when we define the <span class="KeyTerm1">is_good_enough</span> function in terms of <span class="KeyTerm1">square</span>, we are able to regard the <span class="KeyTerm1">square</span> function as a “black box.” We are not at that moment concerned with <i>how</i> the function computes its result, only with the fact <i>that</i> it computes the square. The details of how the square is computed can be suppressed, to be considered at a later time. Indeed, as far as the <span class="KeyTerm1">is_good_enough</span> function is concerned, <span class="KeyTerm1">square</span> is not quite a function but rather an abstraction of a function, a so-called <i>functional abstraction</i>. At this level of abstraction, any function that computes the square is equally good.</p>
<p><a id="c001_c1-para-0331"></a>Thus, considering only the values they return, the following two functions squaring a number should be indistinguishable. Each takes a numerical argument and produces the square of that number as the value.<a id="c001_c1-fn-0022a"></a><a href="#c1-fn-0022"><sup>22</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-0332"></a><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0333"></a> <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0334"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0335"></a><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0336"></a> <b>return</b> math_exp(double(math_log(x)));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0337"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0338"></a><b>function</b> double(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0339"></a> <b>return</b> x + x;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0340"></a>}</p>
<p><a id="c001_c1-para-0341"></a>So a function should be able to suppress detail. The users of the function may not have written the function themselves, but may have obtained it from another programmer as a black box. A user should not need to know how the function is implemented in order to use it.</p>
<section>
<h5><a id="c001_c1-sec-0023"></a><a id="c001_c1-title-0024"></a>Local names</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0342"></a>One detail of a function's implementation that should not matter to the user of the function is the implementer's choice of names for the function's parameters. Thus, the following functions should not be distinguishable:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0343"></a><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0344"></a> <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0345"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0346"></a><b>function</b> square(y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0347"></a> <b>return</b> y * y;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0348"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0349"></a>This principle—that the meaning of a function should be independent of the parameter names used by its author—seems on the surface to be self-evident, but its consequences are profound. The simplest consequence is that the parameter names of a function must be local to the body of the function. For example, we used <span class="KeyTerm1">square</span> in the declaration of <span class="KeyTerm1">is_good_enough</span> in our square-root function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0350"></a><b>function</b> is_good_enough(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0351"></a> <b>return</b> abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0352"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0353"></a>The intention of the author of <span class="KeyTerm1">is_good_enough</span> is to determine if the square of the first argument is within a given tolerance of the second argument. We see that the author of <span class="KeyTerm1">is_good_enough</span> used the name <span class="KeyTerm1">guess</span> to refer to the first argument and <span class="KeyTerm1">x</span> to refer to the second argument. The argument of <span class="KeyTerm1">square</span> is <span class="KeyTerm1">guess</span>. If the author of <span class="KeyTerm1">square</span> used <span class="KeyTerm1">x</span> (as above) to refer to that argument, we see that the <span class="KeyTerm1">x</span> in <span class="KeyTerm1">is_good_ enough</span> must be a different <span class="KeyTerm1">x</span> than the one in <span class="KeyTerm1">square</span>. Running the function <span class="KeyTerm1">square</span> must not affect the value of <span class="KeyTerm1">x</span> that is used by <span class="KeyTerm1">is_good_enough</span>, because that value of <span class="KeyTerm1">x</span> may be needed by <span class="KeyTerm1">is_good_enough</span> after <span class="KeyTerm1">square</span> is done computing.</p>
<p><a id="c001_c1-para-0354"></a>If the parameters were not local to the bodies of their respective functions, then the parameter <span class="KeyTerm1">x</span> in <span class="KeyTerm1">square</span> could be confused with the parameter <span class="KeyTerm1">x</span> in <span class="KeyTerm1">is_good_ enough</span>, and the behavior of <span class="KeyTerm1">is_good_enough</span> would depend upon which version of <span class="KeyTerm1">square</span> we used. Thus, <span class="KeyTerm1">square</span> would not be the black box we desired.</p>
<p><a id="c001_c1-para-0355"></a>A parameter of a function has a very special role in the function declaration, in that it doesn't matter what name the parameter has. Such a name is called <i>bound</i>, and we say that the function declaration <i>binds</i> its parameters. The meaning of a function declaration is unchanged if a bound name is consistently renamed throughout the declaration.<a id="c001_c1-fn-0023a"></a><a href="#c1-fn-0023"><sup>23</sup></a> If a name is not bound, we say that it is <i>free</i>. The set of statements for which a binding declares a name is called the <i>scope</i> of that name. In a function declaration, the bound names declared as the parameters of the function have the body of the function as their scope.</p>
<p><a id="c001_c1-para-0356"></a>In the declaration of <span class="KeyTerm1">is_good_enough</span> above, <span class="KeyTerm1">guess</span> and <span class="KeyTerm1">x</span> are bound names but <span class="KeyTerm1">abs</span> and <span class="KeyTerm1">square</span> are free. The meaning of <span class="KeyTerm1">is_good_enough</span> should be independent of the names we choose for <span class="KeyTerm1">guess</span> and <span class="KeyTerm1">x</span> so long as they are distinct and different from <span class="KeyTerm1">abs</span> and <span class="KeyTerm1">square</span>. (If we renamed <span class="KeyTerm1">guess</span> to <span class="KeyTerm1">abs</span> we would have introduced a bug by <i>capturing</i> the name <span class="KeyTerm1">abs</span>. It would have changed from free to bound.) The meaning of <span class="KeyTerm1">is_good_enough</span> is not independent of the choice of its free names, however. It surely depends upon the fact (external to this declaration) that the name <span class="KeyTerm1">abs</span> refers to a function for computing the absolute value of a number. The function <span class="KeyTerm1">is_good_enough</span> will compute a different function if we substitute <span class="KeyTerm1">math_cos</span> (the primitive cosine function) for <span class="KeyTerm1">abs</span> in its declaration.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0024"></a><a id="c001_c1-title-0025"></a>Internal declarations and block structure</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0357"></a>We have one kind of name isolation available to us so far: The parameters of a function are local to the body of the function. The square-root program illustrates another way in which we would like to control the use of names. The existing program consists of separate functions:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0358"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0359"></a> <b>return</b> sqrt_iter(1, x);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0360"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0361"></a><b>function</b> sqrt_iter(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0362"></a> <b>return</b> is_good_enough(guess, x)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0363"></a>           ? guess</p>
<p class="Sp-text-1"><a id="c001_c1-para-0364"></a>           : sqrt_iter(improve(guess, x), x);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0365"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0366"></a><b>function</b> is_good_enough(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0367"></a> <b>return</b> abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0368"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0369"></a><b>function</b> improve(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0370"></a> <b>return</b> average(guess, x / guess);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0371"></a>}</p>
<p><a id="c001_c1-para-0372"></a>The problem with this program is that the only function that is important to users of <span class="KeyTerm1">sqrt</span> is <span class="KeyTerm1">sqrt</span>. The other functions (<span class="KeyTerm1">sqrt_iter</span>, <span class="KeyTerm1">is_good_enough</span>, and <span class="KeyTerm1">improve</span>) only clutter up their minds. They may not declare any other function called <span class="KeyTerm1">is_good_enough</span> as part of another program to work together with the square-root program, because <span class="KeyTerm1">sqrt</span> needs it. The problem is especially severe in the construction of large systems by many separate programmers. For example, in the construction of a large library of numerical functions, many numerical functions are computed as successive approximations and thus might have functions named <span class="KeyTerm1">is_good_enough</span> and <span class="KeyTerm1">improve</span> as auxiliary functions. We would like to localize the subfunctions, hiding them inside <span class="KeyTerm1">sqrt</span> so that <span class="KeyTerm1">sqrt</span> could coexist with other successive approximations, each having its own private <span class="KeyTerm1">is_good_enough</span> function.<br/>To make this possible, we allow a function to have internal declarations that are local to that function. For example, in the square-root problem we can write</p>
<p class="Sp-text-1"><a id="c001_c1-para-0373"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0374"></a> <b>function</b> is_good_enough(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0375"></a> <b>return</b> abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0376"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0377"></a> <b>function</b> improve(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0378"></a> <b>return</b> average(guess, x / guess);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0379"></a>        }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0380"></a> <b>function</b> sqrt_iter(guess, x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0381"></a> <b>return</b> is_good_enough(guess, x)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0382"></a>               ? guess</p>
<p class="Sp-text-1"><a id="c001_c1-para-0383"></a>               : sqrt_iter(improve(guess, x), x);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0384"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0385"></a> <b>return</b> sqrt_iter(1, x);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0386"></a>}</p>
<p><a id="c001_c1-para-0387"></a>Any matching pair of braces designates a <i>block</i>, and declarations inside the block are local to the block. Such nesting of declarations, called <i>block structure</i>, is basically the right solution to the simplest name-packaging problem. But there is a better idea lurking here. In addition to internalizing the declarations of the auxiliary functions, we can simplify them. Since <span class="KeyTerm1">x</span> is bound in the declaration of <span class="KeyTerm1">sqrt</span>, the functions <span class="KeyTerm1">is_good_enough</span>, <span class="KeyTerm1">improve</span>, and <span class="KeyTerm1">sqrt_iter</span>, which are declared internally to <span class="KeyTerm1">sqrt</span>, are in the scope of <span class="KeyTerm1">x</span>. Thus, it is not necessary to pass <span class="KeyTerm1">x</span> explicitly to each of these functions. Instead, we allow <span class="KeyTerm1">x</span> to be a free name in the internal declarations, as shown below. Then <span class="KeyTerm1">x</span> gets its value from the argument with which the enclosing function <span class="KeyTerm1">sqrt</span> is called. This discipline is called <i>lexical scoping</i>.<a id="c001_c1-fn-0024a"></a><a href="#c1-fn-0024"><sup>24</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-0388"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0389"></a> <b>function</b> is_good_enough(guess) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0390"></a> <b>return</b> abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0391"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0392"></a> <b>function</b> improve(guess) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0393"></a> <b>return</b> average(guess, x / guess);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0394"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0395"></a> <b>function</b> sqrt_iter(guess) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0396"></a> <b>return</b> is_good_enough(guess)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0397"></a>               ? guess</p>
<p class="Sp-text-1"><a id="c001_c1-para-0398"></a>               : sqrt_iter(improve(guess));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0399"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0400"></a> <b>return</b> sqrt_iter(1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0401"></a>}</p>
<p><a id="c001_c1-para-0402"></a>We will use block structure extensively to help us break up large programs into tractable pieces.<a id="c001_c1-fn-0025a"></a><a href="#c1-fn-0025"><sup>25</sup></a> The idea of block structure originated with the programming language Algol 60. It appears in most advanced programming languages and is an important tool for helping to organize the construction of large programs.</p>
</section>
</section>
</section>
<section>
<h2><a id="c001_c1-sec-0025"></a><span>1.2</span> <a id="c001_c1-title-0026"></a>Functions and the Processes They Generate</h2>
<p class="paraaftertitle"><a id="c001_c1-para-0403"></a>We have now considered the elements of programming: We have used primitive arithmetic operations, we have combined these operations, and we have abstracted these composite operations by declaring them as compound functions. But that is not enough to enable us to say that we know how to program. Our situation is analogous to that of someone who has learned the rules for how the pieces move in chess but knows nothing of typical openings, tactics, or strategy. Like the novice chess player, we don't yet know the common patterns of usage in the domain. We lack the knowledge of which moves are worth making (which functions are worth declaring). We lack the experience to predict the consequences of making a move (executing a function).</p>
<p><a id="c001_c1-para-0404"></a>The ability to visualize the consequences of the actions under consideration is crucial to becoming an expert programmer, just as it is in any synthetic, creative activity. In becoming an expert photographer, for example, one must learn how to look at a scene and know how dark each region will appear on a print for each possible choice of exposure and processing options. Only then can one reason backward, planning framing, lighting, exposure, and processing to obtain the desired effects. So it is with programming, where we are planning the course of action to be taken by a process and where we control the process by means of a program. To become experts, we must learn to visualize the processes generated by various types of functions. Only after we have developed such a skill can we learn to reliably construct programs that exhibit the desired behavior.</p>
<p><a id="c001_c1-para-0405"></a>A function is a pattern for the <i>local evolution</i> of a computational process. It specifies how each stage of the process is built upon the previous stage. We would like to be able to make statements about the overall, or <i>global</i>, behavior of a process whose local evolution has been specified by a function. This is very difficult to do in general, but we can at least try to describe some typical patterns of process evolution.</p>
<p><a id="c001_c1-para-0406"></a>In this section we will examine some common “shapes” for processes generated by simple functions. We will also investigate the rates at which these processes consume the important computational resources of time and space. The functions we will consider are very simple. Their role is like that played by test patterns in photography: as oversimplified prototypical patterns, rather than practical examples in their own right.</p>
<section>
<h3><a id="c001_c1-sec-0026"></a><span>1.2.1</span> <a id="c001_c1-title-0027"></a>Linear Recursion and Iteration</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0407"></a>We begin by considering the factorial function, defined by</p>
<p class="Sp-text-2"><a id="c001_c1-para-0408"></a><i>n</i>! = <i>n</i> <span class="KeyTerm1">·</span> (<i>n</i> – 1) <span class="KeyTerm1"><i>·</i></span> (<i>n</i> – 2) <span class="KeyTerm1">· · ·</span> 3 <span class="KeyTerm1"><i>·</i></span> 2 <span class="KeyTerm1"><i>·</i></span> 1</p>
<p class="paracontinue"><a id="c001_c1-para-0409"></a>There are many ways to compute factorials. One way is to make use of the observation that <i>n</i>! is equal to <i>n</i> times (<i>n</i> – 1)! for any positive integer <i>n</i>:</p>
<p class="Sp-text-2"><a id="c001_c1-para-0410"></a><i>n</i>! = <i>n</i> <span class="KeyTerm1"><i>·</i></span> [(<i>n</i> – 1) <span class="KeyTerm1"><i>·</i></span> (<i>n</i> – 2) <span class="KeyTerm1"><i>· · ·</i></span> 3 <span class="KeyTerm1"><i>·</i></span> 2 <span class="KeyTerm1"><i>·</i></span> 1] = <i>n</i> <span class="KeyTerm1"><i>·</i></span> (<i>n</i> – 1)!</p>
<p class="paracontinue"><a id="c001_c1-para-0411"></a>Thus, we can compute <i>n</i>! by computing (<i>n</i> – 1)! and multiplying the result by <i>n</i>. If we add the stipulation that 1! is equal to 1, this observation translates directly into a computer function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0412"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0413"></a> <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0414"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0415"></a>           : n * factorial(n - 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0416"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0417"></a>We can use the substitution model of section 1.1.5 to watch this function in action computing 6!, as shown in <a id="c001_c1-fig-0009a"></a><a href="#c1-fig-0009">figure 1.3</a>.</p>
<figure id="c001_c1-fig-0009"><img alt="c1-fig-0003.jpg" src="../images/c1-fig-0003.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c1-fig-0009a">Figure 1.3</a></span> <a id="c001_c1-para-0418"></a>A linear recursive process for computing 6!.</p></figcaption></figure>
<p><a id="c001_c1-para-0419"></a>Now let's take a different perspective on computing factorials. We could describe a rule for computing <i>n</i>! by specifying that we first multiply 1 by 2, then multiply the result by 3, then by 4, and so on until we reach <i>n</i>. More formally, we maintain a running product, together with a counter that counts from 1 up to <i>n</i>. We can describe the computation by saying that the counter and the product simultaneously change from one step to the next according to the rule</p>
<p class="Sp-text-2"><a id="c001_c1-para-0420"></a>product <i>←</i> counter <span class="KeyTerm1"><i>·</i></span> product </p>
<p class="Sp-text-2"><a id="c001_c1-para-0421"></a>counter <i>←</i> counter + 1</p>
<p class="paracontinue"><a id="c001_c1-para-0422"></a>and stipulating that <i>n</i>! is the value of the product when the counter exceeds <i>n</i>.</p>
<p><a id="c001_c1-para-0423"></a>Once again, we can recast our description as a function for computing factorials:<a id="c001_c1-fn-0026a"></a><a href="#c1-fn-0026"><sup>26</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-0424"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0425"></a> <b>return</b> fact_iter(1, 1, n);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0426"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0427"></a><b>function</b> fact_iter(product, counter, max_count) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0428"></a> <b>return</b> counter &gt; max_count</p>
<p class="Sp-text-1"><a id="c001_c1-para-0429"></a>           ? product</p>
<p class="Sp-text-1"><a id="c001_c1-para-0430"></a>           : fact_iter(counter * product,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0431"></a>                       counter + 1,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0432"></a>                       max_count);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0433"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0434"></a>As before, we can use the substitution model to visualize the process of computing 6!, as shown in <a id="c001_c1-fig-0010a"></a><a href="#c1-fig-0010">figure 1.4</a>.</p>
<figure id="c001_c1-fig-0010"><img alt="c1-fig-0004.jpg" src="../images/c1-fig-0004.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c1-fig-0010a">Figure 1.4</a></span> <a id="c001_c1-para-0435"></a>A linear iterative process for computing 6!.</p></figcaption></figure>
<p><a id="c001_c1-para-0436"></a>Compare the two processes. From one point of view, they seem hardly different at all. Both compute the same mathematical function on the same domain, and each requires a number of steps proportional to <i>n</i> to compute <i>n</i>!. Indeed, both processes even carry out the same sequence of multiplications, obtaining the same sequence of partial products. On the other hand, when we consider the “shapes” of the two processes, we find that they evolve quite differently.</p>
<p><a id="c001_c1-para-0446"></a>Consider the first process. The substitution model reveals a shape of expansion followed by contraction, indicated by the arrow in <a href="#c1-fig-0009">figure 1.3</a>. The expansion occurs as the process builds up a chain of <i>deferred operations</i> (in this case, a chain of multiplications). The contraction occurs as the operations are actually performed. This type of process, characterized by a chain of deferred operations, is called a <i>recursive process</i>. Carrying out this process requires that the interpreter keep track of the operations to be performed later on. In the computation of <i>n</i>!, the length of the chain of deferred multiplications, and hence the amount of information needed to keep track of it, grows linearly with <i>n</i> (is proportional to <i>n</i>), just like the number of steps. Such a process is called a <i>linear recursive process</i>.</p>
<p><a id="c001_c1-para-0447"></a>By contrast, the second process does not grow and shrink. At each step, all we need to keep track of, for any <i>n</i>, are the current values of the names <span class="KeyTerm1">product</span>, <span class="KeyTerm1">counter</span>, and <span class="KeyTerm1">max_count</span>. We call this an <i>iterative process</i>. In general, an iterative process is one whose state can be summarized by a fixed number of <i>state variables</i>, together with a fixed rule that describes how the state variables should be updated as the process moves from state to state and an (optional) end test that specifies conditions under which the process should terminate. In computing <i>n</i>!, the number of steps required grows linearly with <i>n</i>. Such a process is called a <i>linear iterative process</i>.</p>
<p><a id="c001_c1-para-0448"></a>The contrast between the two processes can be seen in another way. In the iterative case, the state variables provide a complete description of the state of the process at any point. If we stopped the computation between steps, all we would need to do to resume the computation is to supply the interpreter with the values of the three state variables. Not so with the recursive process. In this case there is some additional “hidden” information, maintained by the interpreter and not contained in the state variables, which indicates “where the process is” in negotiating the chain of deferred operations. The longer the chain, the more information must be maintained.<a id="c001_c1-fn-0027a"></a><a href="#c1-fn-0027"><sup>27</sup></a></p>
<p><a id="c001_c1-para-0449"></a>In contrasting iteration and recursion, we must be careful not to confuse the notion of a recursive <i>process</i> with the notion of a recursive <i>function</i>. When we describe a function as recursive, we are referring to the syntactic fact that the function declaration refers (either directly or indirectly) to the function itself. But when we describe a process as following a pattern that is, say, linearly recursive, we are speaking about how the process evolves, not about the syntax of how a function is written. It may seem disturbing that we refer to a recursive function such as <span class="KeyTerm1">fact_iter</span> as generating an iterative process. However, the process really is iterative: Its state is captured completely by its three state variables, and an interpreter need keep track of only three names in order to execute the process.</p>
<p><a id="c001_c1-para-0450"></a>One reason that the distinction between process and function may be confusing is that most implementations of common languages (including C, Java, and Python) are designed in such a way that the interpretation of any recursive function consumes an amount of memory that grows with the number of function calls, even when the process described is, in principle, iterative. As a consequence, these languages can describe iterative processes only by resorting to special-purpose “looping constructs” such as <span class="KeyTerm1">do</span>, <span class="KeyTerm1">repeat</span>, <span class="KeyTerm1">until</span>, <span class="KeyTerm1">for</span>, and <span class="KeyTerm1">while</span>. The implementation of JavaScript we shall consider in chapter 5 does not share this defect. It will execute an iterative process in constant space, even if the iterative process is described by a recursive function. An implementation with this property is called <i>tail-recursive</i>.<a id="c001_c1-fn-0028a"></a><a href="#c1-fn-0028"><sup>28</sup></a> With a tailrecursive implementation, iteration can be expressed using the ordinary function call mechanism, so that special iteration constructs are useful only as syntactic sugar.<a id="c001_c1-fn-0029a"></a><a href="#c1-fn-0029"><sup>29</sup></a></p>
<section>
<h5><a id="c001_c1-sec-0027"></a><a id="c001_c1-title-0028"></a>Exercise 1.9</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0451"></a>Each of the following two functions defines a method for adding two positive integers in terms of the functions <span class="KeyTerm1">inc</span>, which increments its argument by 1, and <span class="KeyTerm1">dec</span>, which decrements its argument by 1.</p>
<p class="Sp-text-1"><a id="c001_c1-para-0452"></a><b>function</b> plus(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0453"></a> <b>return</b> a === 0 ? b : inc(plus(dec(a), b));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0454"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0455"></a><b>function</b> plus(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0456"></a> <b>return</b> a === 0 ? b : plus(dec(a), inc(b));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0457"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0458"></a>Using the substitution model, illustrate the process generated by each function in evaluating <span class="KeyTerm1">plus(4, 5);</span>. Are these processes iterative or recursive?</p>
</section>
<section>
<h5><a id="c001_c1-sec-0028"></a><a id="c001_c1-title-0029"></a>Exercise 1.10</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0459"></a>The following function computes a mathematical function called Ackermann's function.</p>
<p class="Sp-text-1"><a id="c001_c1-para-0460"></a><b>function</b> A(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0461"></a> <b>return</b> y === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0462"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0463"></a>           : x === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0464"></a>           ? 2 * y</p>
<p class="Sp-text-1"><a id="c001_c1-para-0465"></a>           : y === 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0466"></a>           ? 2</p>
<p class="Sp-text-1"><a id="c001_c1-para-0467"></a>           : A(x - 1, A(x, y - 1));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0468"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0469"></a>What are the values of the following statements?</p>
<p class="Sp-text-1"><a id="c001_c1-para-0470"></a>A(1, 10);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0471"></a>A(2, 4);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0472"></a>A(3, 3);</p>
<p class="paracontinue"><a id="c001_c1-para-0473"></a>Consider the following functions, where <span class="KeyTerm1">A</span> is the function declared above:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0474"></a><b>function</b> f(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0475"></a> <b>return</b> A(0, n);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0476"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0477"></a><b>function</b> g(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0478"></a> <b>return</b> A(1, n);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0479"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0480"></a><b>function</b> h(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0481"></a> <b>return</b> A(2, n);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0482"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0483"></a><b>function</b> k(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0484"></a> <b>return</b> 5 * n * n;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0485"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0486"></a>Give concise mathematical definitions for the functions computed by the functions <span class="KeyTerm1">f</span>, <span class="KeyTerm1">g</span>, and <span class="KeyTerm1">h</span> for positive integer values of <i>n</i>. For example, <i>k</i>(<i>n</i>) computes 5<i>n</i><sup>2</sup>.</p>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0029"></a><span>1.2.2</span> <a id="c001_c1-title-0030"></a>Tree Recursion</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0487"></a>Another common pattern of computation is called <i>tree recursion</i>. As an example, consider computing the sequence of Fibonacci numbers, in which each number is the sum of the preceding two:</p>
<p class="Sp-text-2"><a id="c001_c1-para-0488"></a>0, 1, 1, 2, 3, 5, 8, 13, 21, <span class="KeyTerm1"><i>. . .</i></span></p>
<p class="paracontinue"><a id="c001_c1-para-0489"></a>In general, the Fibonacci numbers can be defined by the rule</p>
<p><a id="c001_c1-para-0490"></a></p>
<figure id="c001_c1-fig-0011"><img alt="c1-fig-5008.jpg" src="../images/c1-fig-5008.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0491"></a>We can immediately translate this definition into a recursive function for computing Fibonacci numbers:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0492"></a><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0493"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0494"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0495"></a>           : n === 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0496"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0497"></a>           : fib(n - 1) + fib(n - 2);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0498"></a>}</p>
<p><a id="c001_c1-para-0499"></a>Consider the pattern of this computation. To compute <span class="KeyTerm1">fib(5)</span>, we compute <span class="KeyTerm1">fib(4)</span> and <span class="KeyTerm1">fib(3)</span>. To compute <span class="KeyTerm1">fib(4)</span>, we compute <span class="KeyTerm1">fib(3)</span> and <span class="KeyTerm1">fib(2)</span>. In general, the evolved process looks like a tree, as shown in <a id="c001_c1-fig-0012a"></a><a href="#c1-fig-0012">figure 1.5</a>. Notice that the branches split into two at each level (except at the bottom); this reflects the fact that the <span class="KeyTerm1">fib</span> function calls itself twice each time it is invoked.</p>
<figure id="c001_c1-fig-0012"><img alt="c1-fig-0005.jpg" src="../images/c1-fig-0005.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c1-fig-0012a">Figure 1.5</a></span> <a id="c001_c1-para-0500"></a>The tree-recursive process generated in computing <span class="KeyTerm1">fib(5)</span>.</p></figcaption></figure>
<p><a id="c001_c1-para-0501"></a>This function is instructive as a prototypical tree recursion, but it is a terrible way to compute Fibonacci numbers because it does so much redundant computation. Notice in <a href="#c1-fig-0012">figure 1.5</a> that the entire computation of <span class="KeyTerm1">fib(3)</span>—almost half the work—is duplicated. In fact, it is not hard to show that the number of times the function will compute <span class="KeyTerm1">fib(1)</span> or <span class="KeyTerm1">fib(0)</span> (the number of leaves in the above tree, in general) is precisely Fib(<i>n</i> + 1). To get an idea of how bad this is, one can show that the value of Fib(<i>n</i>) grows exponentially with <i>n</i>. More precisely (see exercise 1.13), Fib(<i>n</i>) is the closest integer to <i>ϕ<sup>n</sup></i>/<img alt="c1-fig-5009.jpg" src="../images/c1-fig-5009.jpg"/>, where</p>
<p class="Sp-text-2"><a id="c001_c1-para-0502"></a><i>ϕ</i> = (1 + <img alt="c1-fig-5009.jpg" src="../images/c1-fig-5009.jpg"/>)/2 <i>≈</i> 1.6180</p>
<p class="paracontinue"><a id="c001_c1-para-0503"></a>is the <i>golden ratio</i>, which satisfies the equation</p>
<p class="Sp-text-2"><a id="c001_c1-para-0504"></a><i>ϕ</i><sup>2</sup> = <i>ϕ</i> + 1</p>
<p class="paracontinue"><a id="c001_c1-para-0505"></a>Thus, the process uses a number of steps that grows exponentially with the input. On the other hand, the space required grows only linearly with the input, because we need keep track only of which nodes are above us in the tree at any point in the computation. In general, the number of steps required by a tree-recursive process will be proportional to the number of nodes in the tree, while the space required will be proportional to the maximum depth of the tree.</p>
<p><a id="c001_c1-para-0506"></a>We can also formulate an iterative process for computing the Fibonacci numbers. The idea is to use a pair of integers <i>a</i> and <i>b</i>, initialized to Fib(1) = 1 and Fib(0) = 0, and to repeatedly apply the simultaneous transformations</p>
<p class="Sp-text-2"><a id="c001_c1-para-0507"></a><i>a</i> <i>←</i> <i>a</i> + <i>b</i></p>
<p class="Sp-text-2"><a id="c001_c1-para-0508"></a><i>b</i> <i>←</i> <i>a</i></p>
<p class="paracontinue"><a id="c001_c1-para-0509"></a>It is not hard to show that, after applying this transformation <i>n</i> times, <i>a</i> and <i>b</i> will be equal, respectively, to Fib(<i>n</i> + 1) and Fib(<i>n</i>). Thus, we can compute Fibonacci numbers iteratively using the function</p>
<p class="Sp-text-1"><a id="c001_c1-para-0510"></a><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0511"></a> <b>return</b> fib_iter(1, 0, n);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0512"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0513"></a><b>function</b> fib_iter(a, b, count) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0514"></a> <b>return</b> count === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0515"></a>           ? b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0516"></a>           : fib_iter(a + b, a, count - 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0517"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0518"></a>This second method for computing Fib(<i>n</i>) is a linear iteration. The difference in number of steps required by the two methods—one linear in <i>n</i>, one growing as fast as Fib(<i>n</i>) itself—is enormous, even for small inputs.</p>
<p><a id="c001_c1-para-0519"></a>One should not conclude from this that tree-recursive processes are useless. When we consider processes that operate on hierarchically structured data rather than numbers, we will find that tree recursion is a natural and powerful tool.<a id="c001_c1-fn-0030a"></a><a href="#c1-fn-0030"><sup>30</sup></a> But even in numerical operations, tree-recursive processes can be useful in helping us to understand and design programs. For instance, although the first <span class="KeyTerm1">fib</span> function is much less efficient than the second one, it is more straightforward, being little more than a translation into JavaScript of the definition of the Fibonacci sequence. To formulate the iterative algorithm required noticing that the computation could be recast as an iteration with three state variables.</p>
<section>
<h5><a id="c001_c1-sec-0030"></a><a id="c001_c1-title-0031"></a>Example: Counting change</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0520"></a>It takes only a bit of cleverness to come up with the iterative Fibonacci algorithm. In contrast, consider the following problem: How many different ways can we make change of $1.00 (100 cents), given half-dollars, quarters, dimes, nickels, and pennies (50 cents, 25 cents, 10 cents, 5 cents, and 1 cent, respectively)? More generally, can we write a function to compute the number of ways to change any given amount of money?</p>
<p><a id="c001_c1-para-0521"></a>This problem has a simple solution as a recursive function. Suppose we think of the types of coins available as arranged in some order. Then the following relation holds:</p>
<p><a id="c001_c1-para-0522"></a>The number of ways to change amount <i>a</i> using <i>n</i> kinds of coins equals</p>
<ul style="list-style-type:disc">
<li>the number of ways to change amount <i>a</i> using all but the first kind of coin, plus</li>
<li>the number of ways to change amount <i>a</i> – <i>d</i> using all <i>n</i> kinds of coins, where <i>d</i> is the denomination of the first kind of coin.</li>
</ul>
<p><a id="c001_c1-para-0525"></a>To see why this is true, observe that the ways to make change can be divided into two groups: those that do not use any of the first kind of coin, and those that do. Therefore, the total number of ways to make change for some amount is equal to the number of ways to make change for the amount without using any of the first kind of coin, plus the number of ways to make change assuming that we do use the first kind of coin. But the latter number is equal to the number of ways to make change for the amount that remains after using a coin of the first kind.</p>
<p><a id="c001_c1-para-0526"></a>Thus, we can recursively reduce the problem of changing a given amount to problems of changing smaller amounts or using fewer kinds of coins. Consider this reduction rule carefully, and convince yourself that we can use it to describe an algorithm if we specify the following degenerate cases:<a id="c001_c1-fn-0031a"></a><a href="#c1-fn-0031"><sup>31</sup></a></p>
<ul style="list-style-type:disc">
<li>If <i>a</i> is exactly 0, we should count that as 1 way to make change.</li>
<li>If <i>a</i> is less than 0, we should count that as 0 ways to make change.</li>
<li>If <i>n</i> is 0, we should count that as 0 ways to make change.</li>
</ul>
<p class="paracontinue"><a id="c001_c1-para-0530"></a>We can easily translate this description into a recursive function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0531"></a><b>function</b> count_change(amount) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0532"></a> <b>return</b> cc(amount, 5);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0533"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0534"></a><b>function</b> cc(amount, kinds_of_coins) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0535"></a> <b>return</b> amount === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0536"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0537"></a>           : amount &lt; 0 || kinds_of_coins === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0538"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0539"></a>           : cc(amount, kinds_of_coins - 1)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0540"></a>             +</p>
<p class="Sp-text-1"><a id="c001_c1-para-0541"></a>             cc(amount - first_denomination(kinds_of_coins), </p>
<p class="Sp-text-1"><a id="c001_c1-para-0542"></a>                kinds_of_coins);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0543"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0544"></a><b>function</b> first_denomination(kinds_of_coins) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0545"></a> <b>return</b> kinds_of_coins === 1 ? 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0546"></a>         : kinds_of_coins === 2 ? 5</p>
<p class="Sp-text-1"><a id="c001_c1-para-0547"></a>         : kinds_of_coins === 3 ? 10</p>
<p class="Sp-text-1"><a id="c001_c1-para-0548"></a>         : kinds_of_coins === 4 ? 25</p>
<p class="Sp-text-1"><a id="c001_c1-para-0549"></a>         : kinds_of_coins === 5 ? 50</p>
<p class="Sp-text-1"><a id="c001_c1-para-0550"></a>         : 0;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0551"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0552"></a>(The <span class="KeyTerm1">first_denomination</span> function takes as input the number of kinds of coins available and returns the denomination of the first kind. Here we are thinking of the coins as arranged in order from largest to smallest, but any order would do as well.) We can now answer our original question about changing a dollar:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0553"></a>count_change(100);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0554"></a><i>292</i></p>
<p><a id="c001_c1-para-0555"></a>The function <span class="KeyTerm1">count_change</span> generates a tree-recursive process with redundancies similar to those in our first implementation of <span class="KeyTerm1">fib</span>. On the other hand, it is not obvious how to design a better algorithm for computing the result, and we leave this problem as a challenge. The observation that a tree-recursive process may be highly inefficient but often easy to specify and understand has led people to propose that one could get the best of both worlds by designing a “smart compiler” that could transform tree-recursive functions into more efficient functions that compute the same result.<a id="c001_c1-fn-0032a"></a><a href="#c1-fn-0032"><sup>32</sup></a></p>
</section>
<section>
<h5><a id="c001_c1-sec-0031"></a><a id="c001_c1-title-0032"></a>Exercise 1.11</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0556"></a>A function <i>f</i> is defined by the rules <i>f</i> (<i>n</i>) = <i>n</i> if <i>n</i> &lt; 3 and <i>f</i> (<i>n</i>) = <i>f</i> (<i>n</i> – 1) + 2<i>f</i> (<i>n</i> – 2) + 3<i>f</i> (<i>n</i> – 3) if <i>n</i> 3. Write a JavaScript function that computes <i>f</i> by means of a recursive process. Write a function that computes <i>f</i> by means of an iterative process.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0032"></a><a id="c001_c1-title-0033"></a>Exercise 1.12</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0557"></a>The following pattern of numbers is called <i>Pascal's triangle</i>.</p>
<p><a id="c001_c1-para-0558"></a></p>
<figure id="c001_c1-fig-0013"><img alt="c1-fig-5010.jpg" src="../images/c1-fig-5010.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0559"></a>The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it.<a id="c001_c1-fn-0033a"></a><a href="#c1-fn-0033"><sup>33</sup></a> Write a function that computes elements of Pascal's triangle by means of a recursive process.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0033"></a><a id="c001_c1-title-0034"></a>Exercise 1.13</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0560"></a>Prove that Fib(<i>n</i>) is the closest integer to <i>ϕ<sup>n</sup></i>/<img alt="c1-fig-5009.jpg" src="../images/c1-fig-5009.jpg"/>, where <i>ϕ</i> = (1 + <img alt="c1-fig-5009.jpg" src="../images/c1-fig-5009.jpg"/>)/2. Hint: Use induction and the definition of the Fibonacci numbers to prove that Fib(<i>n</i>) = (<i>ϕ<sup>n</sup></i> – <i>ψ<sup>n</sup></i>)/<img alt="c1-fig-5009.jpg" src="../images/c1-fig-5009.jpg"/>, where <i>ψ</i> = (1 – <img alt="c1-fig-5009.jpg" src="../images/c1-fig-5009.jpg"/>)/2.</p>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0034"></a><span>1.2.3</span> <a id="c001_c1-title-0035"></a>Orders of Growth</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0561"></a>The previous examples illustrate that processes can differ considerably in the rates at which they consume computational resources. One convenient way to describe this difference is to use the notion of <i>order of growth</i> to obtain a gross measure of the resources required by a process as the inputs become larger.</p>
<p><a id="c001_c1-para-0562"></a>Let <i>n</i> be a parameter that measures the size of the problem, and let <i>R</i>(<i>n</i>) be the amount of resources the process requires for a problem of size <i>n</i>. In our previous examples we took <i>n</i> to be the number for which a given function is to be computed, but there are other possibilities. For instance, if our goal is to compute an approximation to the square root of a number, we might take <i>n</i> to be the number of digits accuracy required. For matrix multiplication we might take <i>n</i> to be the number of rows in the matrices. In general there are a number of properties of the problem with respect to which it will be desirable to analyze a given process. Similarly, <i>R</i>(<i>n</i>) might measure the number of internal storage registers used, the number of elementary machine operations performed, and so on. In computers that do only a fixed number of operations at a time, the time required will be proportional to the number of elementary machine operations performed.</p>
<p><a id="c001_c1-para-0563"></a>We say that <i>R</i>(<i>n</i>) has order of growth Θ(<i>f</i> (<i>n</i>)), written <i>R</i>(<i>n</i>) = Θ(<i>f</i> (<i>n</i>)) (pronounced “theta of <i>f</i> (<i>n</i>)”), if there are positive constants <i>k</i><sub>1</sub> and <i>k</i><sub>2</sub> independent of <i>n</i> such that</p>
<p class="Sp-text-2"><a id="c001_c1-para-0564"></a><i>k</i><sub>1</sub> <i>f</i> (<i>n</i>) <i>≤ R</i>(<i>n</i>) <i>≤ k</i><sub>2</sub> <i>f</i> (<i>n</i>)</p>
<p class="paracontinue"><a id="c001_c1-para-0565"></a>for any sufficiently large value of <i>n</i>. (In other words, for large <i>n</i>, the value <i>R</i>(<i>n</i>) is sandwiched between <i>k</i><sub>1</sub><i>f</i> (<i>n</i>) and <i>k</i><sub>2</sub><i>f</i> (<i>n</i>).)</p>
<p><a id="c001_c1-para-0566"></a>For instance, with the linear recursive process for computing factorial described in section 1.2.1 the number of steps grows proportionally to the input <i>n</i>. Thus, the steps required for this process grows as Θ(<i>n</i>). We also saw that the space required grows as Θ(<i>n</i>). For the iterative factorial, the number of steps is still Θ(<i>n</i>) but the space is Θ(1)—that is, constant.<a id="c001_c1-fn-0034a"></a><a href="#c1-fn-0034"><sup>34</sup></a> The tree-recursive Fibonacci computation requires Θ(<i>ϕ<sup>n</sup></i>) steps and space Θ(<i>n</i>), where <i>ϕ</i> is the golden ratio described in section 1.2.2.</p>
<p><a id="c001_c1-para-0567"></a>Orders of growth provide only a crude description of the behavior of a process. For example, a process requiring <i>n</i><sup>2</sup> steps and a process requiring 1000<i>n</i><sup>2</sup> steps and a process requiring 3<i>n</i><sup>2</sup> + 10<i>n</i> + 17 steps all have Θ(<i>n</i><sup>2</sup>) order of growth. On the other hand, order of growth provides a useful indication of how we may expect the behavior of the process to change as we change the size of the problem. For a Θ(<i>n</i>) (linear) process, doubling the size will roughly double the amount of resources used. For an exponential process, each increment in problem size will multiply the resource utilization by a constant factor. In the remainder of section 1.2 we will examine two algorithms whose order of growth is logarithmic, so that doubling the problem size increases the resource requirement by a constant amount.</p>
<section>
<h5><a id="c001_c1-sec-0035"></a><a id="c001_c1-title-0036"></a>Exercise 1.14</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0568"></a>Draw the tree illustrating the process generated by the <span class="KeyTerm1">count_change</span> function of section 1.2.2 in making change for 11 cents. What are the orders of growth of the space and number of steps used by this process as the amount to be changed increases?</p>
</section>
<section>
<h5><a id="c001_c1-sec-0036"></a><a id="c001_c1-title-0037"></a>Exercise 1.15</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0569"></a>The sine of an angle (specified in radians) can be computed by making use of the approximation sin <i>x ≈ x</i> if <i>x</i> is sufficiently small, and the trigonometric identity</p>
<p><a id="c001_c1-para-0570"></a></p>
<figure id="c001_c1-fig-0014"><img alt="c1-fig-5011.jpg" src="../images/c1-fig-5011.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0571"></a>to reduce the size of the argument of sin. (For purposes of this exercise an angle is considered “sufficiently small” if its magnitude is not greater than 0.1 radians.) These ideas are incorporated in the following functions:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0572"></a><b>function</b> cube(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0573"></a> <b>return</b> x * x * x;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0574"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0575"></a><b>function</b> p(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0576"></a> <b>return</b> 3 * x - 4 * cube(x);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0577"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0578"></a><b>function</b> sine(angle) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0579"></a> <b>return</b> ! (abs(angle) &gt; 0.1)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0580"></a>           ? angle</p>
<p class="Sp-text-1"><a id="c001_c1-para-0581"></a>           : p(sine(angle / 3));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0582"></a>}</p>
<ol class="BS_NumberListA">
<li><a id="c001_c1-li-0026"></a><span>a. </span>How many times is the function <span class="KeyTerm1">p</span> applied when <span class="KeyTerm1">sine(12.15)</span> is evaluated?</li>
<li><a id="c001_c1-li-0027"></a><span>b. </span>What is the order of growth in space and number of steps (as a function of <i>a</i>) used by the process generated by the <span class="KeyTerm1">sine</span> function when <span class="KeyTerm1">sine(a)</span> is evaluated?</li>
</ol>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0037"></a><span>1.2.4</span> <a id="c001_c1-title-0038"></a>Exponentiation</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0585"></a>Consider the problem of computing the exponential of a given number. We would like a function that takes as arguments a base <i>b</i> and a positive integer exponent <i>n</i> and computes <i>b<sup>n</sup></i>. One way to do this is via the recursive definition</p>
<p class="Sp-text-2"><a id="c001_c1-para-0586"></a><i>b<sup>n</sup></i> = <i>b b<sup>n</sup></i><sup>–1</sup></p>
<p class="Sp-text-2"><a id="c001_c1-para-0587"></a><i>b</i><sup>0</sup> = 1</p>
<p class="paracontinue"><a id="c001_c1-para-0588"></a>which translates readily into the function</p>
<p class="Sp-text-1"><a id="c001_c1-para-0589"></a><b>function</b> expt(b, n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0590"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0591"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0592"></a>           : b * expt(b, n - 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0593"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0594"></a>This is a linear recursive process, which requires Θ(<i>n</i>) steps and Θ(<i>n</i>) space. Just as with factorial, we can readily formulate an equivalent linear iteration:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0595"></a><b>function</b> expt(b, n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0596"></a> <b>return</b> expt_iter(b, n, 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0597"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0598"></a><b>function</b> expt_iter(b, counter, product) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0599"></a> <b>return</b> counter === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0600"></a>           ? product</p>
<p class="Sp-text-1"><a id="c001_c1-para-0601"></a>           : expt_iter(b, counter - 1, b * product);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0602"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0603"></a>This version requires Θ(<i>n</i>) steps and Θ(1) space.</p>
<p><a id="c001_c1-para-0604"></a>We can compute exponentials in fewer steps by using successive squaring. For instance, rather than computing <i>b</i><sup>8</sup> as</p>
<p class="Sp-text-2"><a id="c001_c1-para-0605"></a><i>b ·</i> (<i>b ·</i> (<i>b ·</i> (<i>b ·</i> (<i>b ·</i> (<i>b ·</i> (<i>b · b</i>))))))</p>
<p class="paracontinue"><a id="c001_c1-para-0606"></a>we can compute it using three multiplications:</p>
<p class="Sp-text-2"><a id="c001_c1-para-0607"></a><i>b</i><sup>2</sup> = <i>b · b</i></p>
<p class="Sp-text-2"><a id="c001_c1-para-0608"></a><i>b</i><sup>4</sup> = <i>b</i><sup>2 </sup><i>· b</i><sup>2</sup></p>
<p class="Sp-text-2"><a id="c001_c1-para-0609"></a><i>b</i><sup>8</sup> = <i>b</i><sup>4</sup> <i>· b</i><sup>4</sup></p>
<p><a id="c001_c1-para-0610"></a>This method works fine for exponents that are powers of 2. We can also take advantage of successive squaring in computing exponentials in general if we use the rule</p>
<p class="Sp-text-2"><a id="c001_c1-para-0611"></a><i>b<sup>n</sup></i> = (<i>b<sup>n</sup></i><sup>/2</sup>)<sup>2</sup>  if <i>n</i> is even</p>
<p class="Sp-text-2"><a id="c001_c1-para-0612"></a><i>b<sup>n</sup></i> = <i>b · b<sup>n</sup></i><sup>–1</sup>  if <i>n</i> is odd</p>
<p class="paracontinue"><a id="c001_c1-para-5612"></a>We can express this method as a function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0613"></a><b>function</b> fast_expt(b, n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0614"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0615"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0616"></a>           : is_even(n)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0617"></a>           ? square(fast_expt(b, n / 2))</p>
<p class="Sp-text-1"><a id="c001_c1-para-0618"></a>           : b * fast_expt(b, n - 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0619"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0620"></a>where the predicate to test whether an integer is even is defined in terms of the operator <span class="KeyTerm1">%</span>, which computes the remainder after integer division, by</p>
<p class="Sp-text-1"><a id="c001_c1-para-0621"></a><b>function</b> is_even(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0622"></a> <b>return</b> n % 2 === 0;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0623"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0624"></a>The process evolved by <span class="KeyTerm1">fast_expt</span> grows logarithmically with <i>n</i> in both space and number of steps. To see this, observe that computing <i>b</i><sup>2</sup><i><sup>n</sup></i> using <span class="KeyTerm1">fast_expt</span> requires only one more multiplication than computing <i>b<sup>n</sup></i>. The size of the exponent we can compute therefore doubles (approximately) with every new multiplication we are allowed. Thus, the number of multiplications required for an exponent of <i>n</i> grows about as fast as the logarithm of <i>n</i> to the base 2. The process has Θ(log <i>n</i>) growth.<a id="c001_c1-fn-0035a"></a><a href="#c1-fn-0035"><sup>35</sup></a></p>
<p><a id="c001_c1-para-0625"></a>The difference between Θ(log <i>n</i>) growth and Θ(<i>n</i>) growth becomes striking as <i>n</i> becomes large. For example, <span class="KeyTerm1">fast_expt</span> for <i>n</i> = 1000 requires only 14 multiplications.<a id="c001_c1-fn-0036a"></a><a href="#c1-fn-0036"><sup>36</sup></a> It is also possible to use the idea of successive squaring to devise an iterative algorithm that computes exponentials with a logarithmic number of steps (see exercise 1.16), although, as is often the case with iterative algorithms, this is not written down so straightforwardly as the recursive algorithm.<a id="c001_c1-fn-0037a"></a><a href="#c1-fn-0037"><sup>37</sup></a></p>
<section>
<h5><a id="c001_c1-sec-0038"></a><a id="c001_c1-title-0039"></a>Exercise 1.16</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0626"></a>Design a function that evolves an iterative exponentiation process that uses successive squaring and uses a logarithmic number of steps, as does <span class="KeyTerm1">fast_expt</span>. (Hint: Using the observation that (<i>b<sup>n</sup></i><sup>/2</sup>)<sup>2</sup> = (<i>b</i><sup>2</sup>)<i><sup>n</sup></i><sup>/2</sup>, keep, along with the exponent <i>n</i> and the base <i>b</i>, an additional state variable <i>a</i>, and define the state transformation in such a way that the product <i>ab<sup>n</sup></i> is unchanged from state to state. At the beginning of the process <i>a</i> is taken to be 1, and the answer is given by the value of <i>a</i> at the end of the process. In general, the technique of defining an <i>invariant quantity</i> that remains unchanged from state to state is a powerful way to think about the design of iterative algorithms.)</p>
</section>
<section>
<h5><a id="c001_c1-sec-0039"></a><a id="c001_c1-title-0040"></a>Exercise 1.17</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0627"></a>The exponentiation algorithms in this section are based on performing exponentiation by means of repeated multiplication. In a similar way, one can perform integer multiplication by means of repeated addition. The following multiplication function (in which it is assumed that our language can only add, not multiply) is analogous to the <span class="KeyTerm1">expt</span> function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0628"></a><b>function</b> times(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0629"></a> <b>return</b> b === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0630"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0631"></a>           : a + times(a, b - 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0632"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0633"></a>This algorithm takes a number of steps that is linear in <span class="KeyTerm1">b</span>. Now suppose we include, together with addition, the functions <span class="KeyTerm1">double</span>, which doubles an integer, and <span class="KeyTerm1">halve</span>, which divides an (even) integer by 2. Using these, design a multiplication function analogous to <span class="KeyTerm1">fast_expt</span> that uses a logarithmic number of steps.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0040"></a><a id="c001_c1-title-0041"></a>Exercise 1.18</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0634"></a>Using the results of exercises 1.16 and 1.17, devise a function that generates an iterative process for multiplying two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps.<a id="c001_c1-fn-0038a"></a><a href="#c1-fn-0038"><sup>38</sup></a></p>
</section>
<section>
<h5><a id="c001_c1-sec-0041"></a><a id="c001_c1-title-0042"></a>Exercise 1.19</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0635"></a>There is a clever algorithm for computing the Fibonacci numbers in a logarithmic number of steps. Recall the transformation of the state variables <i>a</i> and <i>b</i> in the <span class="KeyTerm1">fib_iter</span> process of section 1.2.2: <i>a a</i> + <i>b</i> and <i>b a</i>. Call this transformation <i>T</i>, and observe that applying <i>T</i> over and over again <i>n</i> times, starting with 1 and 0, produces the pair Fib(<i>n</i> + 1) and Fib(<i>n</i>). In other words, the Fibonacci numbers are produced by applying <i>T<sup>n</sup></i>, the <i>n</i>th power of the transformation <i>T</i>, starting with the pair (1, 0). Now consider <i>T</i> to be the special case of <i>p</i> = 0 and <i>q</i> = 1 in a family of transformations <i>T<sub>pq</sub></i>, where <i>T<sub>pq</sub></i> transforms the pair (<i>a</i>, <i>b</i>) according to <i>a ← bq</i> + <i>aq</i> + <i>ap</i> and <i>b ← bp</i> + <i>aq</i>. Show that if we apply such a transformation <i>T<sub>pq</sub></i> twice, the effect is the same as using a single transformation <i>T<sub>p</sub><sub>′</sub><sub>q</sub><sub>′</sub></i> of the same form, and compute <i>p′</i> and <i>q′</i> in terms of <i>p</i> and <i>q</i>. This gives us an explicit way to square these transformations, and thus we can compute <i>T<sup>n</sup></i> using successive squaring, as in the <span class="KeyTerm1">fast_expt</span> function. Put this all together to complete the following function, which runs in a logarithmic number of steps:<a id="c001_c1-fn-0039a"></a><a href="#c1-fn-0039"><sup>39</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-0637"></a><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0638"></a> <b>return</b> fib_iter(1, 0, 0, 1, n);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0639"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0640"></a><b>function</b> fib_iter(a, b, p, q, count) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0641"></a> <b>return</b> count === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0642"></a>           ? b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0643"></a>           : is_even(count)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0644"></a>           ? fib_iter(a,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0645"></a>                      b,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0646"></a>                      (<span class="KeyTerm2">??</span>),          <span class="KeyTerm2"><i>// compute p′</i></span></p>
<p class="Sp-text-1"><a id="c001_c1-para-0647"></a>                      (<span class="KeyTerm2">??</span>),          <span class="KeyTerm2"><i>// compute q′</i></span></p>
<p class="Sp-text-1"><a id="c001_c1-para-0648"></a>                      count / 2)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0649"></a>           : fib_iter(b * q + a * q + a * p,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0650"></a>                      b * p + a * q,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0651"></a>                      p,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0652"></a>                      q,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0653"></a>                      count - 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0654"></a>}</p>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0042"></a><span>1.2.5</span> <a id="c001_c1-title-0043"></a>Greatest Common Divisors</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0655"></a>The greatest common divisor (GCD) of two integers <i>a</i> and <i>b</i> is defined to be the largest integer that divides both <i>a</i> and <i>b</i> with no remainder. For example, the GCD of 16 and 28 is 4. In chapter 2, when we investigate how to implement rationalnumber arithmetic, we will need to be able to compute GCDs in order to reduce rational numbers to lowest terms. (To reduce a rational number to lowest terms, we must divide both the numerator and the denominator by their GCD. For example, 16/28 reduces to 4/7.) One way to find the GCD of two integers is to factor them and search for common factors, but there is a famous algorithm that is much more efficient.</p>
<p><a id="c001_c1-para-0656"></a>The idea of the algorithm is based on the observation that, if <i>r</i> is the remainder when <i>a</i> is divided by <i>b</i>, then the common divisors of <i>a</i> and <i>b</i> are precisely the same as the common divisors of <i>b</i> and <i>r</i>. Thus, we can use the equation</p>
<p class="Sp-text-2"><a id="c001_c1-para-0657"></a>GCD(<i>a</i>, <i>b</i>) = GCD(<i>b</i>, <i>r</i>)</p>
<p class="paracontinue"><a id="c001_c1-para-0658"></a>to successively reduce the problem of computing a GCD to the problem of computing the GCD of smaller and smaller pairs of integers. For example,</p>
<p class="Sp-text-2"><a id="c001_c1-para-0659"></a>GCD(206, 40) = GCD(40, 6)</p>
<p class="Sp-text-2"><a id="c001_c1-para-0660"></a>       = GCD(6, 4)</p>
<p class="Sp-text-2"><a id="c001_c1-para-0661"></a>       = GCD(4, 2)</p>
<p class="Sp-text-2"><a id="c001_c1-para-0662"></a>       = GCD(2, 0)</p>
<p class="Sp-text-2"><a id="c001_c1-para-0663"></a>       = 2</p>
<p class="paracontinue"><a id="c001_c1-para-0664"></a>reduces GCD(206, 40) to GCD(2, 0), which is 2. It is possible to show that starting with any two positive integers and performing repeated reductions will always eventually produce a pair where the second number is 0. Then the GCD is the other number in the pair. This method for computing the GCD is known as <i>Euclid's Algorithm</i>.<a id="c001_c1-fn-0040a"></a><a href="#c1-fn-0040"><sup>40</sup></a></p>
<p><a id="c001_c1-para-0665"></a>It is easy to express Euclid's Algorithm as a function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0666"></a><b>function</b> gcd(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0667"></a> <b>return</b> b === 0 ? a : gcd(b, a % b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0668"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0669"></a>This generates an iterative process, whose number of steps grows as the logarithm of the numbers involved.</p>
<p><a id="c001_c1-para-0670"></a>The fact that the number of steps required by Euclid's Algorithm has logarithmic growth bears an interesting relation to the Fibonacci numbers:</p>
<div class="top"><hr/></div>
<section class="other1"><a id="c001_c1-feafxd-0001"></a>
<p class="paraaftertitle"><a id="c001_c1-para-0671"></a><b>Lamé's Theorem:</b> If Euclid's Algorithm requires <i>k</i> steps to compute the GCD of some pair, then the smaller number in the pair must be greater than or equal to the <i>k</i>th Fibonacci number.<a id="c001_c1-fn-0041a"></a><a href="#c1-fn-0041"><sup>41</sup></a></p>
<div class="bottom"><hr/></div>
</section>
<p><a id="c001_c1-para-0672"></a>We can use this theorem to get an order-of-growth estimate for Euclid's Algorithm. Let <i>n</i> be the smaller of the two inputs to the function. If the process takes <i>k</i> steps, then we must have <i>n</i> ≥ Fib(<i>k</i>) ≈ <i>ϕ<sup>k</sup></i>/<img alt="c1-fig-5009.jpg" src="../images/c1-fig-5009.jpg"/>. Therefore the number of steps <i>k</i> grows as the logarithm (to the base <i>ϕ</i>) of <i>n</i>. Hence, the order of growth is Θ(log <i>n</i>).</p>
<section>
<h5><a id="c001_c1-sec-0043"></a><a id="c001_c1-title-0044"></a>Exercise 1.20</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0673"></a>The process that a function generates is of course dependent on the rules used by the interpreter. As an example, consider the iterative <span class="KeyTerm1">gcd</span> function given above. Suppose we were to interpret this function using normal-order evaluation, as discussed in section 1.1.5. (The normal-order-evaluation rule for conditional expressions is described in exercise 1.5.) Using the substitution method (for normal order), illustrate the process generated in evaluating <span class="KeyTerm1">gcd(206, 40)</span> and indicate the <span class="KeyTerm1">remainder</span> operations that are actually performed. How many <span class="KeyTerm1">remainder</span> operations are actually performed in the normal-order evaluation of <span class="KeyTerm1">gcd(206, 40)</span>? In the applicative-order evaluation?</p>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0044"></a><span>1.2.6</span> <a id="c001_c1-title-0045"></a>Example: Testing for Primality</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0674"></a>This section describes two methods for checking the primality of an integer <i>n</i>, one with order of growth Θ(<img alt="c1-fig-5012.jpg" src="../images/c1-fig-5012.jpg"/>), and a “probabilistic” algorithm with order of growth Θ(log <i>n</i>). The exercises at the end of this section suggest programming projects based on these algorithms.</p>
<section>
<h5><a id="c001_c1-sec-0045"></a><a id="c001_c1-title-0046"></a>Searching for divisors</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0675"></a>Since ancient times, mathematicians have been fascinated by problems concerning prime numbers, and many people have worked on the problem of determining ways to test if numbers are prime. One way to test if a number is prime is to find the number's divisors. The following program finds the smallest integral divisor (greater than 1) of a given number <i>n</i>. It does this in a straightforward way, by testing <i>n</i> for divisibility by successive integers starting with 2.</p>
<p class="Sp-text-1"><a id="c001_c1-para-0676"></a><b>function</b> smallest_divisor(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0677"></a> <b>return</b> find_divisor(n, 2);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0678"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0679"></a><b>function</b> find_divisor(n, test_divisor) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0680"></a> <b>return</b> square(test_divisor) &gt; n</p>
<p class="Sp-text-1"><a id="c001_c1-para-0681"></a>           ? n</p>
<p class="Sp-text-1"><a id="c001_c1-para-0682"></a>           : divides(test_divisor, n)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0683"></a>           ? test_divisor</p>
<p class="Sp-text-1"><a id="c001_c1-para-0684"></a>           : find_divisor(n, test_divisor + 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0685"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0686"></a><b>function</b> divides(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0687"></a> <b>return</b> b % a === 0;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0688"></a>}</p>
<p><a id="c001_c1-para-0689"></a>We can test whether a number is prime as follows: <i>n</i> is prime if and only if <i>n</i> is its own smallest divisor.</p>
<p class="Sp-text-1"><a id="c001_c1-para-0690"></a><b>function</b> is_prime(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0691"></a> <b>return</b> n === smallest_divisor(n);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0692"></a>}</p>
<p><a id="c001_c1-para-0693"></a>The end test for <span class="KeyTerm1">find_divisor</span> is based on the fact that if <i>n</i> is not prime it must have a divisor less than or equal to <img alt="c1-fig-5012.jpg" src="../images/c1-fig-5012.jpg"/>.<a id="c001_c1-fn-0042a"></a><a href="#c1-fn-0042"><sup>42</sup></a> This means that the algorithm need only test divisors between 1 and <img alt="c1-fig-5012.jpg" src="../images/c1-fig-5012.jpg"/>. Consequently, the number of steps required to identify <i>n</i> as prime will have order of growth Θ(<img alt="c1-fig-5012.jpg" src="../images/c1-fig-5012.jpg"/>).</p>
</section>
<section>
<h5><a id="c001_c1-sec-0046"></a><a id="c001_c1-title-0047"></a>The Fermat test</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0694"></a>The Θ(log <i>n</i>) primality test is based on a result from number theory known as Fermat's Little Theorem.<a id="c001_c1-fn-0043a"></a><a href="#c1-fn-0043"><sup>43</sup></a></p>
<div class="top"><hr/></div>
<section class="other2"><a id="c001_c1-feafxd-0002"></a>
<p class="paraaftertitle"><a id="c001_c1-para-0695"></a><b>Fermat's Little Theorem:</b> If <i>n</i> is a prime number and <i>a</i> is any positive integer less than <i>n</i>, then <i>a</i> raised to the <i>n</i>th power is congruent to <i>a</i> modulo <i>n</i>.</p>
<div class="bottom"><hr/></div>
</section>
<p class="paracontinue"><a id="c001_c1-para-0696"></a>(Two numbers are said to be <i>congruent modulo n</i> if they both have the same remainder when divided by <i>n</i>. The remainder of a number <i>a</i> when divided by <i>n</i> is also referred to as the <i>remainder of a modulo n</i>, or simply as <i>a modulo n</i>.)</p>
<p><a id="c001_c1-para-0697"></a>If <i>n</i> is not prime, then, in general, most of the numbers <i>a</i> &lt; <i>n</i> will not satisfy the above relation. This leads to the following algorithm for testing primality: Given a number <i>n</i>, pick a random number <i>a</i> &lt; <i>n</i> and compute the remainder of <i>a<sup>n</sup></i> modulo <i>n</i>. If the result is not equal to <i>a</i>, then <i>n</i> is certainly not prime. If it is <i>a</i>, then chances are good that <i>n</i> is prime. Now pick another random number <i>a</i> and test it with the same method. If it also satisfies the equation, then we can be even more confident that <i>n</i> is prime. By trying more and more values of <i>a</i>, we can increase our confidence in the result. This algorithm is known as the Fermat test.</p>
<p><a id="c001_c1-para-0698"></a>To implement the Fermat test, we need a function that computes the exponential of a number modulo another number:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0699"></a><b>function</b> expmod(base, exp, m) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0700"></a> <b>return</b> exp === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0701"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0702"></a>           : is_even(exp)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0703"></a>           ? square(expmod(base, exp / 2, m)) % m</p>
<p class="Sp-text-1"><a id="c001_c1-para-0704"></a>           : (base * expmod(base, exp - 1, m)) % m;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0705"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0706"></a>This is very similar to the <span class="KeyTerm1">fast_expt</span> function of section 1.2.4. It uses successive squaring, so that the number of steps grows logarithmically with the exponent.<a id="c001_c1-fn-0044a"></a><a href="#c1-fn-0044"><sup>44</sup></a></p>
<p><a id="c001_c1-para-0707"></a>The Fermat test is performed by choosing at random a number <i>a</i> between 1 and <i>n</i> – 1 inclusive and checking whether the remainder modulo <i>n</i> of the <i>n</i>th power of <i>a</i> is equal to <i>a</i>. The random number <i>a</i> is chosen using the primitive function <span class="KeyTerm1">math_random</span>, which returns a nonnegative number less than 1. Hence, to obtain a random number between 1 and <i>n</i> – 1, we multiply the return value of <span class="KeyTerm1">math_random</span> by <i>n</i> – 1, round down the result with the primitive function <span class="KeyTerm1">math_floor</span>, and add 1:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0708"></a><b>function</b> fermat_test(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0709"></a> <b>function</b> try_it(a) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0710"></a> <b>return</b> expmod(a, n, n) === a;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0711"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0712"></a> <b>return</b> try_it(1 + math_floor(math_random() * (n - 1)));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0713"></a>}</p>
<p><a id="c001_c1-para-0714"></a>The following function runs the test a given number of times, as specified by a parameter. Its value is true if the test succeeds every time, and false otherwise.</p>
<p class="Sp-text-1"><a id="c001_c1-para-0715"></a><b>function</b> fast_is_prime(n, times) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0716"></a> <b>return</b> times === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0717"></a>           ? <b>true</b></p>
<p class="Sp-text-1"><a id="c001_c1-para-0718"></a>           : fermat_test(n)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0719"></a>           ? fast_is_prime(n, times - 1)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0720"></a>           : <b>false</b>;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0721"></a>}</p>
</section>
<section>
<h5><a id="c001_c1-sec-0047"></a><a id="c001_c1-title-0048"></a>Probabilistic methods</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0722"></a>The Fermat test differs in character from most familiar algorithms, in which one computes an answer that is guaranteed to be correct. Here, the answer obtained is only probably correct. More precisely, if <i>n</i> ever fails the Fermat test, we can be certain that <i>n</i> is not prime. But the fact that <i>n</i> passes the test, while an extremely strong indication, is still not a guarantee that <i>n</i> is prime. What we would like to say is that for any number <i>n</i>, if we perform the test enough times and find that <i>n</i> always passes the test, then the probability of error in our primality test can be made as small as we like.</p>
<p><a id="c001_c1-para-0723"></a>Unfortunately, this assertion is not quite correct. There do exist numbers that fool the Fermat test: numbers <i>n</i> that are not prime and yet have the property that <i>a<sup>n</sup></i> is congruent to <i>a</i> modulo <i>n</i> for all integers <i>a</i> &lt; <i>n</i>. Such numbers are extremely rare, so the Fermat test is quite reliable in practice.<a id="c001_c1-fn-0045a"></a><a href="#c1-fn-0045"><sup>45</sup></a> There are variations of the Fermat test that cannot be fooled. In these tests, as with the Fermat method, one tests the primality of an integer <i>n</i> by choosing a random integer <i>a</i> &lt; <i>n</i> and checking some condition that depends upon <i>n</i> and <i>a</i>. (See exercise 1.28 for an example of such a test.) On the other hand, in contrast to the Fermat test, one can prove that, for any <i>n</i>, the condition does not hold for most of the integers <i>a</i> &lt; <i>n</i> unless <i>n</i> is prime. Thus, if <i>n</i> passes the test for some random choice of <i>a</i>, the chances are better than even that <i>n</i> is prime. If <i>n</i> passes the test for two random choices of <i>a</i>, the chances are better than 3 out of 4 that <i>n</i> is prime. By running the test with more and more randomly chosen values of <i>a</i> we can make the probability of error as small as we like.</p>
<p><a id="c001_c1-para-0724"></a>The existence of tests for which one can prove that the chance of error becomes arbitrarily small has sparked interest in algorithms of this type, which have come to be known as <i>probabilistic algorithms</i>. There is a great deal of research activity in this area, and probabilistic algorithms have been fruitfully applied to many fields.<a id="c001_c1-fn-0046a"></a><a href="#c1-fn-0046"><sup>46</sup></a></p>
</section>
<section>
<h5><a id="c001_c1-sec-0048"></a><a id="c001_c1-title-0049"></a>Exercise 1.21</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0725"></a>Use the <span class="KeyTerm1">smallest_divisor</span> function to find the smallest divisor of each of the following numbers: 199, 1999, 19999.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0049"></a><a id="c001_c1-title-0050"></a>Exercise 1.22</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0726"></a>Assume a primitive function <span class="KeyTerm1">get_time</span> of no arguments that returns the number of milliseconds that have passed since 00:00:00 UTC on Thursday, 1 January, 1970.<a id="c001_c1-fn-0047a"></a><a href="#c1-fn-0047"><sup>47</sup></a> The following <span class="KeyTerm1">timed_prime_test</span> function, when called with an integer <i>n</i>, prints <i>n</i> and checks to see if <i>n</i> is prime. If <i>n</i> is prime, the function prints three asterisks<a id="c001_c1-fn-0048a"></a><a href="#c1-fn-0048"><sup>48</sup></a> followed by the amount of time used in performing the test.</p>
<p class="Sp-text-1"><a id="c001_c1-para-0727"></a><b>function</b> timed_prime_test(n) { </p>
<p class="Sp-text-1"><a id="c001_c1-para-0728"></a>    display(n);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0729"></a> <b>return</b> start_prime_test(n, get_time());</p>
<p class="Sp-text-1"><a id="c001_c1-para-0730"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0731"></a><b>function</b> start_prime_test(n, start_time) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0732"></a> <b>return</b> is_prime(n)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0733"></a>           ? report_prime(get_time() - start_time)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0734"></a>           : <b>true</b>;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0735"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0736"></a><b>function</b> report_prime(elapsed_time) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0737"></a>    display(" *** ");</p>
<p class="Sp-text-1"><a id="c001_c1-para-0738"></a>    display(elapsed_time);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0739"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0740"></a>Using this function, write a function <span class="KeyTerm1">search_for_primes</span> that checks the primality of consecutive odd integers in a specified range. Use your function to find the three smallest primes larger than 1000; larger than 10,000; larger than 100,000; larger than 1,000,000. Note the time needed to test each prime. Since the testing algorithm has order of growth of Θ(<img alt="c1-fig-5012.jpg" src="../images/c1-fig-5012.jpg"/>), you should expect that testing for primes around 10,000 should take about <img alt="c1-fig-5013.jpg" src="../images/c1-fig-5013.jpg"/> times as long as testing for primes around 1000. Do your timing data bear this out? How well do the data for 100,000 and 1,000,000 support the <img alt="c1-fig-5012.jpg" src="../images/c1-fig-5012.jpg"/> prediction? Is your result compatible with the notion that programs on your machine run in time proportional to the number of steps required for the computation?</p>
</section>
<section>
<h5><a id="c001_c1-sec-0050"></a><a id="c001_c1-title-0051"></a>Exercise 1.23</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0741"></a>The <span class="KeyTerm1">smallest_divisor</span> function shown at the start of this section does lots of needless testing: After it checks to see if the number is divisible by 2 there is no point in checking to see if it is divisible by any larger even numbers. This suggests that the values used for <span class="KeyTerm1">test_divisor</span> should not be 2, 3, 4, 5, 6, . . . but rather 2, 3, 5, 7, 9, To implement this change, declare a function <span class="KeyTerm1">next</span> that returns 3 if its input is equal to 2 and otherwise returns its input plus 2. Modify the <span class="KeyTerm1">smallest_divisor</span> function to use <span class="KeyTerm1">next(test_divisor)</span> instead of <span class="KeyTerm1">test_divisor + 1</span>. With <span class="KeyTerm1">timed_prime_test</span> incorporating this modified version of <span class="KeyTerm1">smallest_divisor</span>, run the test for each of the 12 primes found in exercise 1.22. Since this modification halves the number of test steps, you should expect it to run about twice as fast. Is this expectation confirmed? If not, what is the observed ratio of the speeds of the two algorithms, and how do you explain the fact that it is different from 2?</p>
</section>
<section>
<h5><a id="c001_c1-sec-0051"></a><a id="c001_c1-title-0052"></a>Exercise 1.24</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0742"></a>Modify the <span class="KeyTerm1">timed_prime_test</span> function of exercise 1.22 to use <span class="KeyTerm1">fast_is_prime</span> (the Fermat method), and test each of the 12 primes you found in that exercise. Since the Fermat test has Θ(log <i>n</i>) growth, how would you expect the time to test primes near 1,000,000 to compare with the time needed to test primes near 1000? Do your data bear this out? Can you explain any discrepancy you find?</p>
</section>
<section>
<h5><a id="c001_c1-sec-0052"></a><a id="c001_c1-title-0053"></a>Exercise 1.25</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0743"></a>Alyssa P. Hacker complains that we went to a lot of extra work in writing <span class="KeyTerm1">expmod</span>. After all, she says, since we already know how to compute exponentials, we could have simply written</p>
<p class="Sp-text-1"><a id="c001_c1-para-0744"></a><b>function</b> expmod(base, exp, m) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0745"></a> <b>return</b> fast_expt(base, exp) % m;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0746"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0747"></a>Is she correct? Would this function serve as well for our fast prime tester? Explain.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0053"></a><a id="c001_c1-title-0054"></a>Exercise 1.26</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0748"></a>Louis Reasoner is having great difficulty doing exercise 1.24. His <span class="KeyTerm1">fast_is_prime</span> test seems to run more slowly than his <span class="KeyTerm1">is_prime</span> test. Louis calls his friend Eva Lu Ator over to help. When they examine Louis's code, they find that he has rewritten the <span class="KeyTerm1">expmod</span> function to use an explicit multiplication, rather than calling <span class="KeyTerm1">square</span>:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0749"></a><b>function</b> expmod(base, exp, m) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0750"></a> <b>return</b> exp === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0751"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0752"></a>           : is_even(exp)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0753"></a>           ? (  expmod(base, exp / 2, m)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0754"></a>              * expmod(base, exp / 2, m)) % m</p>
<p class="Sp-text-1"><a id="c001_c1-para-0755"></a>           : (base * expmod(base, exp - 1, m)) % m;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0756"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0757"></a>“I don't see what difference that could make,” says Louis. “I do.” says Eva. “By writing the function like that, you have transformed the Θ(log <i>n</i>) process into a Θ(<i>n</i>) process.” Explain.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0054"></a><a id="c001_c1-title-0055"></a>Exercise 1.27</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0758"></a>Demonstrate that the Carmichael numbers listed in footnote 45 really do fool the Fermat test. That is, write a function that takes an integer <i>n</i> and tests whether <i>a<sup>n</sup></i> is congruent to <i>a</i> modulo <i>n</i> for every <i>a</i> &lt; <i>n</i>, and try your function on the given Carmichael numbers.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0055"></a><a id="c001_c1-title-0056"></a>Exercise 1.28</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0759"></a>One variant of the Fermat test that cannot be fooled is called the <i>Miller–Rabin test</i> (Miller 1976; Rabin 1980). This starts from an alternate form of Fermat's Little Theorem, which states that if <i>n</i> is a prime number and <i>a</i> is any positive integer less than <i>n</i>, then <i>a</i> raised to the (<i>n</i> – 1)st power is congruent to 1 modulo <i>n</i>. To test the primality of a number <i>n</i> by the Miller–Rabin test, we pick a random number <i>a</i> &lt; <i>n</i> and raise <i>a</i> to the (<i>n</i> – 1)st power modulo <i>n</i> using the <span class="KeyTerm1">expmod</span> function. However, whenever we perform the squaring step in <span class="KeyTerm1">expmod</span>, we check to see if we have discovered a “nontrivial square root of 1 modulo <i>n</i>,” that is, a number not equal to 1 or <i>n</i> – 1 whose square is equal to 1 modulo <i>n</i>. It is possible to prove that if such a nontrivial square root of 1 exists, then <i>n</i> is not prime. It is also possible to prove that if <i>n</i> is an odd number that is not prime, then, for at least half the numbers <i>a</i> &lt; <i>n</i>, computing <i>a<sup>n</sup></i><sup>–1</sup> in this way will reveal a nontrivial square root of 1 modulo <i>n</i>. (This is why the Miller–Rabin test cannot be fooled.) Modify the <span class="KeyTerm1">expmod</span> function to signal if it discovers a nontrivial square root of 1, and use this to implement the Miller–Rabin test with a function analogous to <span class="KeyTerm1">fermat_test</span>. Check your function by testing various known primes and non-primes. Hint: One convenient way to make <span class="KeyTerm1">expmod</span> signal is to have it return 0.</p>
</section>
</section>
</section>
<section>
<h2><a id="c001_c1-sec-0056"></a><span>1.3</span> <a id="c001_c1-title-0057"></a>Formulating Abstractions with Higher-Order Functions</h2>
<p class="paraaftertitle"><a id="c001_c1-para-0760"></a>We have seen that functions are, in effect, abstractions that describe compound operations on numbers independent of the particular numbers. For example, when we declare</p>
<p class="Sp-text-1"><a id="c001_c1-para-0761"></a><b>function</b> cube(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0762"></a> <b>return</b> x * x * x;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0763"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0764"></a>we are not talking about the cube of a particular number, but rather about a method for obtaining the cube of any number. Of course we could get along without ever declaring this function, by always writing expressions such as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0765"></a>3 * 3 * 3</p>
<p class="Sp-text-1"><a id="c001_c1-para-0766"></a>x * x * x</p>
<p class="Sp-text-1"><a id="c001_c1-para-0767"></a>y * y * y</p>
<p class="paracontinue"><a id="c001_c1-para-0768"></a>and never mentioning <span class="KeyTerm1">cube</span> explicitly. This would place us at a serious disadvantage, forcing us to work always at the level of the particular operations that happen to be primitives in the language (multiplication, in this case) rather than in terms of higher-level operations. Our programs would be able to compute cubes, but our language would lack the ability to express the concept of cubing. One of the things we should demand from a powerful programming language is the ability to build abstractions by assigning names to common patterns and then to work in terms of the abstractions directly. Functions provide this ability. This is why all but the most primitive programming languages include mechanisms for declaring functions.</p>
<p><a id="c001_c1-para-0769"></a>Yet even in numerical processing we will be severely limited in our ability to create abstractions if we are restricted to functions whose parameters must be numbers. Often the same programming pattern will be used with a number of different functions. To express such patterns as concepts, we will need to construct functions that can accept functions as arguments or return functions as values. Functions that manipulate functions are called <i>higher-order functions.</i> This section shows how higher-order functions can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language.</p>
<section>
<h3><a id="c001_c1-sec-0057"></a><span>1.3.1</span> <a id="c001_c1-title-0058"></a>Functions as Arguments</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0770"></a>Consider the following three functions. The first computes the sum of the integers from <span class="KeyTerm1">a</span> through <span class="KeyTerm1">b</span>:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0771"></a><b>function</b> sum_integers(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0772"></a> <b>return</b> a &gt; b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0773"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0774"></a>           : a + sum_integers(a + 1, b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0775"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0776"></a>The second computes the sum of the cubes of the integers in the given range:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0777"></a><b>function</b> sum_cubes(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0778"></a> <b>return</b> a &gt; b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0779"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0780"></a>           : cube(a) + sum_cubes(a + 1, b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0781"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0782"></a>The third computes the sum of a sequence of terms in the series</p>
<p><a id="c001_c1-para-0783"></a></p>
<figure id="c001_c1-fig-0015"><img alt="c1-fig-5014.jpg" src="../images/c1-fig-5014.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0784"></a>which converges to <i>π</i>/8 (very slowly):<a id="c001_c1-fn-0049a"></a><a href="#c1-fn-0049"><sup>49</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-0785"></a><b>function</b> pi_sum(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0786"></a> <b>return</b> a &gt; b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0787"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0788"></a>           : 1 / (a * (a + 2)) + pi_sum(a + 4, b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0789"></a>}</p>
<p><a id="c001_c1-para-0790"></a>These three functions clearly share a common underlying pattern. They are for the most part identical, differing only in the name of the function, the function of <span class="KeyTerm1">a</span> used to compute the term to be added, and the function that provides the next value of <span class="KeyTerm1">a</span>. We could generate each of the functions by filling in slots in the same template:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0791"></a><b>function</b> <span class="KeyTerm2"><i>name</i></span>(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0792"></a> <b>return</b> a &gt; b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0793"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0794"></a>           : <span class="KeyTerm2"><i>term</i></span>(a) + <span class="KeyTerm2"><i>name</i></span>(<span class="KeyTerm2"><i>next</i></span>(a), b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0795"></a>}</p>
<p><a id="c001_c1-para-0796"></a>The presence of such a common pattern is strong evidence that there is a useful abstraction waiting to be brought to the surface. Indeed, mathematicians long ago identified the abstraction of <i>summation of a series</i> and invented “sigma notation,” for example</p>
<p><a id="c001_c1-para-0797"></a></p>
<figure id="c001_c1-fig-0016"><img alt="c1-fig-5016.jpg" src="../images/c1-fig-5016.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0798"></a>to express this concept. The power of sigma notation is that it allows mathematicians to deal with the concept of summation itself rather than only with particular sums—for example, to formulate general results about sums that are independent of the particular series being summed.</p>
<p><a id="c001_c1-para-0799"></a>Similarly, as program designers, we would like our language to be powerful enough so that we can write a function that expresses the concept of summation itself rather than only functions that compute particular sums. We can do so readily in our functional language by taking the common template shown above and transforming the “slots” into parameters:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0800"></a><b>function</b> sum(term, a, next, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0801"></a> <b>return</b> a &gt; b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0802"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0803"></a>           : term(a) + sum(term, next(a), next, b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0804"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0805"></a>Notice that <span class="KeyTerm1">sum</span> takes as its arguments the lower and upper bounds <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> together with the functions <span class="KeyTerm1">term</span> and <span class="KeyTerm1">next</span>. We can use <span class="KeyTerm1">sum</span> just as we would any function. For example, we can use it (along with a function <span class="KeyTerm1">inc</span> that increments its argument by 1) to define <span class="KeyTerm1">sum_cubes</span>:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0806"></a><b>function</b> inc(n) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0807"></a> <b>return</b> n + 1;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0808"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-0809"></a><b>function</b> sum_cubes(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0810"></a> <b>return</b> sum(cube, a, inc, b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0811"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0812"></a>Using this, we can compute the sum of the cubes of the integers from 1 to 10:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0813"></a>sum_cubes(1, 10);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0814"></a><i>3025</i></p>
<p class="paracontinue"><a id="c001_c1-para-0815"></a>With the aid of an identity function to compute the term, we can define <span class="KeyTerm1">sum_ integers</span> in terms of <span class="KeyTerm1">sum</span>:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0816"></a><b>function</b> identity(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0817"></a> <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0818"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0819"></a><b>function</b> sum_integers(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0820"></a> <b>return</b> sum(identity, a, inc, b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0821"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0822"></a>Then we can add up the integers from 1 to 10:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0823"></a>sum_integers(1, 10);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0824"></a><i>55</i></p>
<p class="paracontinue"><a id="c001_c1-para-0825"></a>We can also define <span class="KeyTerm1">pi_sum</span> in the same way:<a id="c001_c1-fn-0050a"></a><a href="#c1-fn-0050"><sup>50</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-0826"></a><b>function</b> pi_sum(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0827"></a> <b>function</b> pi_term(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0828"></a> <b>return</b> 1 / (x * (x + 2));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0829"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0830"></a> <b>function</b> pi_next(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0831"></a> <b>return</b> x + 4;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0832"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0833"></a> <b>return</b> sum(pi_term, a, pi_next, b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0834"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0835"></a>Using these functions, we can compute an approximation to <i>π</i>:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0836"></a>8 * pi_sum(1, 1000);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0837"></a><i>3.139592655589783</i></p>
<p><a id="c001_c1-para-0838"></a>Once we have <span class="KeyTerm1">sum</span>, we can use it as a building block in formulating further concepts. For instance, the definite integral of a function <i>f</i> between the limits <i>a</i> and <i>b</i> can be approximated numerically using the formula</p>
<p><a id="c001_c1-para-0839"></a></p>
<figure id="c001_c1-fig-0017"><img alt="c1-fig-5017.jpg" src="../images/c1-fig-5017.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0840"></a>for small values of <i>dx</i>. We can express this directly as a function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0841"></a><b>function</b> integral(f, a, b, dx) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0842"></a> <b>function</b> add_dx(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0843"></a> <b>return</b> x + dx;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0844"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0845"></a> <b>return</b> sum(f, a + dx / 2, add_dx, b) * dx;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0846"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0847"></a>integral(cube, 0, 1, 0.01);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0848"></a><i>0.24998750000000042</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0849"></a>integral(cube, 0, 1, 0.001);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0850"></a><i>0.249999875000001</i></p>
<p class="paracontinue"><a id="c001_c1-para-0851"></a>(The exact value of the integral of <span class="KeyTerm1">cube</span> between 0 and 1 is 1/4.)</p>
<section>
<h5><a id="c001_c1-sec-0058"></a><a id="c001_c1-title-0059"></a>Exercise 1.29</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0852"></a>Simpson's Rule is a more accurate method of numerical integration than the method illustrated above. Using Simpson's Rule, the integral of a function <i>f</i> between <i>a</i> and <i>b</i> is approximated as</p>
<p><a id="c001_c1-para-0853"></a></p>
<figure id="c001_c1-fig-0018"><img alt="c1-fig-5018.jpg" src="../images/c1-fig-5018.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-0854"></a>where <i>h</i> = (<i>b</i> – <i>a</i>)/<i>n</i>, for some even integer <i>n</i>, and <i>y<sub>k</sub></i> = <i>f</i> (<i>a</i> + <i>kh</i>). (Increasing <i>n</i> increases the accuracy of the approximation.) Declare a function that takes as arguments <i>f, a</i>, <i>b</i>, and <i>n</i> and returns the value of the integral, computed using Simpson's Rule. Use your function to integrate <span class="KeyTerm1">cube</span> between 0 and 1 (with <i>n</i> = 100 and <i>n</i> = 1000), and compare the results to those of the <span class="KeyTerm1">integral</span> function shown above.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0059"></a><a id="c001_c1-title-0060"></a>Exercise 1.30</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0855"></a>The <span class="KeyTerm1">sum</span> function above generates a linear recursion. The function can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following declaration:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0856"></a><b>function</b> sum(term, a, next, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0857"></a> <b>function</b> iter(a, result) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0858"></a> <b>return</b> 〈??〉</p>
<p class="Sp-text-1"><a id="c001_c1-para-0859"></a>               ? 〈??〉</p>
<p class="Sp-text-1"><a id="c001_c1-para-0860"></a>               : iter(〈??〉, 〈??〉);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0861"></a> <sub>}</sub></p>
<p class="Sp-text-1"><a id="c001_c1-para-0862"></a> <b>return</b> iter(〈??〉, 〈??〉);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0863"></a>}</p>
</section>
<section>
<h5><a id="c001_c1-sec-0060"></a><a id="c001_c1-title-0061"></a>Exercise 1.31</h5>
<ol class="BS_NumberListA">
<li><a id="c001_c1-li-0028"></a><span>a. </span>The <span class="KeyTerm1">sum</span> function is only the simplest of a vast number of similar abstractions that can be captured as higher-order functions.<a id="c001_c1-fn-0051a"></a><a href="#c1-fn-0051"><sup>51</sup></a> Write an analogous function called <span class="KeyTerm1">product</span> that returns the product of the values of a function at points over a given range. Show how to define <span class="KeyTerm1">factorial</span> in terms of <span class="KeyTerm1">product</span>. Also use <span class="KeyTerm1">product</span> to compute approximations to <i>π</i> using the formula<a id="c001_c1-fn-0052a"></a><a href="#c1-fn-0052"><sup>52</sup></a>
<figure id="c001_c1-fig-0019"><img alt="c1-fig-5019.jpg" src="../images/c1-fig-5019.jpg"/><figcaption class="figurecaption">
</figcaption></figure></li>
<li><a id="c001_c1-li-0029"></a><span>b. </span>If your <span class="KeyTerm1">product</span> function generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</li>
</ol>
</section>
<section>
<h5><a id="c001_c1-sec-0061"></a><a id="c001_c1-title-0062"></a>Exercise 1.32</h5>
<ol class="BS_NumberListA">
<li><a id="c001_c1-li-0030"></a><span>a. </span>Show that <span class="KeyTerm1">sum</span> and <span class="KeyTerm1">product</span> (exercise 1.31) are both special cases of a still more general notion called <span class="KeyTerm1">accumulate</span> that combines a collection of terms, using some general accumulation function:
<p class="Sp-text-1"><a id="c001_c1-para-0867"></a>accumulate(combiner, null_value, term, a, next, b);</p>
<p class="paracontinue"><a id="c001_c1-para-0868"></a>The function <span class="KeyTerm1">accumulate</span> takes as arguments the same term and range specifications as <span class="KeyTerm1">sum</span> and <span class="KeyTerm1">product</span>, together with a <span class="KeyTerm1">combiner</span> function (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a <span class="KeyTerm1">null_value</span> that specifies what base value to use when the terms run out. Write <span class="KeyTerm1">accumulate</span> and show how <span class="KeyTerm1">sum</span> and <span class="KeyTerm1">product</span> can both be declared as simple calls to <span class="KeyTerm1">accumulate</span>.</p>
<p class="paracontinue"><a id="c001_c1-para-0869"></a>b. If your <span class="KeyTerm1">accumulate</span> function generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p></li>
</ol>
</section>
<section>
<h5><a id="c001_c1-sec-0062"></a><a id="c001_c1-title-0063"></a>Exercise 1.33</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0870"></a>You can obtain an even more general version of <span class="KeyTerm1">accumulate</span> (exercise 1.32) by introducing the notion of a <i>filter</i> on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting <span class="KeyTerm1">filtered_ accumulate</span> abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter. Write <span class="KeyTerm1">filtered_accumulate</span> as a function. Show how to express the following using <span class="KeyTerm1">filtered_accumulate</span>:</p>
<ol class="BS_NumberListA">
<li><a id="c001_c1-li-0031"></a><span>a. </span>the sum of the squares of the prime numbers in the interval <i>a</i> to <i>b</i> (assuming that you have an <span class="KeyTerm1">is_prime</span> predicate already written)</li>
<li><a id="c001_c1-li-0032"></a><span>b. </span>the product of all the positive integers less than <i>n</i> that are relatively prime to <i>n</i> (i.e., all positive integers <i>i</i> &lt; <i>n</i> such that GCD(<i>i</i>, <i>n</i>) = 1).</li>
</ol>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0063"></a><span>1.3.2</span> <a id="c001_c1-title-0064"></a>Constructing Functions using Lambda Expressions</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0873"></a>In using <span class="KeyTerm1">sum</span> as in section 1.3.1, it seems terribly awkward to have to declare trivial functions such as <span class="KeyTerm1">pi_term</span> and <span class="KeyTerm1">pi_next</span> just so we can use them as arguments to our higher-order function. Rather than declare <span class="KeyTerm1">pi_next</span> and <span class="KeyTerm1">pi_term</span>, it would be more convenient to have a way to directly specify “the function that returns its input incremented by 4” and “the function that returns the reciprocal of its input times its input plus 2.” We can do this by introducing the <i>lambda expression</i> as a syntactic form for creating functions. Using lambda expressions, we can describe what we want as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0874"></a>x =&gt; x + 4</p>
<p class="paracontinue"><a id="c001_c1-para-0875"></a>and</p>
<p class="Sp-text-1"><a id="c001_c1-para-0876"></a>x =&gt; 1 / (x * (x + 2))</p>
<p class="paracontinue"><a id="c001_c1-para-0877"></a>Then we can express our <span class="KeyTerm1">pi_sum</span> function without declaring any auxiliary functions:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0878"></a><b>function</b> pi_sum(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0879"></a> <b>return</b> sum(x =&gt; 1 / (x * (x + 2)),</p>
<p class="Sp-text-1"><a id="c001_c1-para-0880"></a>               a,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0881"></a>               x =&gt; x + 4,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0882"></a>               b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0883"></a>}</p>
<p><a id="c001_c1-para-0884"></a>Again using a lambda expression, we can write the <span class="KeyTerm1">integral</span> function without having to declare the auxiliary function <span class="KeyTerm1">add_dx</span>:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0885"></a><b>function</b> integral(f, a, b, dx) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0886"></a> <b>return</b> sum(f,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0887"></a>               a + dx / 2,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0888"></a>               x =&gt; x + dx,</p>
<p class="Sp-text-1"><a id="c001_c1-para-0889"></a>               b)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0890"></a>           * </p>
<p class="Sp-text-1"><a id="c001_c1-para-0891"></a>           dx;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0892"></a>}</p>
<p><a id="c001_c1-para-0893"></a>In general, lambda expressions are used to create functions in the same way as function declarations, except that no name is specified for the function and the <span class="KeyTerm1"><b>return</b></span> keyword and braces are omitted (if there is only one parameter, the parentheses around the parameter list can also be omitted, as in the examples we have seen).<a id="c001_c1-fn-0053a"></a><a href="#c1-fn-0053"><sup>53</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-0894"></a>(<span class="KeyTerm2"><i>parameters</i></span>) =&gt; <span class="KeyTerm2"><i>expression</i></span></p>
<p class="paracontinue"><a id="c001_c1-para-0895"></a>The resulting function is just as much a function as one that is created using a function declaration statement. The only difference is that it has not been associated with any name in the environment. We consider</p>
<p class="Sp-text-1"><a id="c001_c1-para-0896"></a><b>function</b> plus4(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0897"></a> <b>return</b> x + 4;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0898"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0899"></a>to be equivalent to<a id="c001_c1-fn-0054a"></a><a href="#c1-fn-0054"><sup>54</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-0900"></a><b>const</b> plus4 = x =&gt; x + 4;</p>
<p class="paracontinue"><a id="c001_c1-para-0901"></a>We can read a lambda expression as follows:</p>
<p><a id="c001_c1-para-0902"></a></p>
<figure id="c001_c1-fig-0020"><img alt="c1-fig-5020.jpg" src="../images/c1-fig-5020.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p><a id="c001_c1-para-0903"></a>Like any expression that has a function as its value, a lambda expression can be used as the function expression in an application such as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0904"></a>((x, y, z) =&gt; x + y + square(z))(1, 2, 3);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0905"></a><i>12</i></p>
<p class="paracontinue"><a id="c001_c1-para-0906"></a>or, more generally, in any context where we would normally use a function name.<a id="c001_c1-fn-0055a"></a><a href="#c1-fn-0055"><sup>55</sup></a> Note that <span class="KeyTerm1">=&gt;</span> has lower precedence than function application and thus the parentheses around the lambda expression are necessary here.</p>
<section>
<h5><a id="c001_c1-sec-0064"></a><a id="c001_c1-title-0065"></a>Using <span class="KeyTerm1">const</span> to create local names</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0907"></a>Another use of lambda expressions is in creating local names. We often need local names in our functions other than those that have been bound as parameters. For example, suppose we wish to compute the function</p>
<p class="Sp-text-2"><a id="c001_c1-para-0908"></a><i>f</i> (<i>x</i>, <i>y</i>) = <i>x</i>(1 + <i>xy</i>)<sup>2</sup> + <i>y</i>(1 – <i>y</i>) + (1 + <i>xy</i>)(1 – <i>y</i>) </p>
<p class="paracontinue"><a id="c001_c1-para-0909"></a>which we could also express as</p>
<p class="Sp-text-2"><a id="c001_c1-para-0910"></a>   <i>a</i> = 1 + <i>xy</i></p>
<p class="Sp-text-2"><a id="c001_c1-para-0911"></a>   <i>b</i> = 1 – <i>y</i></p>
<p class="Sp-text-2"><a id="c001_c1-para-0912"></a><i>f</i> (<i>x</i>, <i>y</i>) = <i>xa</i><sup>2</sup> + <i>yb</i> + <i>ab</i></p>
<p class="paracontinue"><a id="c001_c1-para-0913"></a>In writing a function to compute <i>f,</i> we would like to include as local names not only <i>x</i> and <i>y</i> but also the names of intermediate quantities like <i>a</i> and <i>b</i>. One way to accomplish this is to use an auxiliary function to bind the local names:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0914"></a><b>function</b> f(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0915"></a> <b>function</b> f_helper(a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0916"></a> <b>return</b> x * square(a) + y * b + a * b;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0917"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0918"></a> <b>return</b> f_helper(1 + x * y, 1 - y);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0919"></a>}</p>
<p><a id="c001_c1-para-0920"></a>Of course, we could use a lambda expression to specify an anonymous function for binding our local names. The function body then becomes a single call to that function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0921"></a><b>function</b> f_2(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0922"></a> <b>return</b> ( (a, b) =&gt; x * square(a) + y * b + a * b</p>
<p class="Sp-text-1"><a id="c001_c1-para-0923"></a>           )(1 + x * y, 1 - y);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0924"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0925"></a>A more convenient way to declare local names is by using constant declarations within the body of the function. Using <span class="KeyTerm1"><b>const</b></span>, the function can be written as</p>
<p class="Sp-text-1"><a id="c001_c1-para-0926"></a><b>function</b> f_3(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0927"></a> <b>const</b> a = 1 + x * y; </p>
<p class="Sp-text-1"><a id="c001_c1-para-0928"></a> <b>const</b> b = 1 - y;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0929"></a> <b>return</b> x * square(a) + y * b + a * b;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0930"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0931"></a>Names that are declared with <span class="KeyTerm1"><b>const</b></span> inside a block have the body of the immediately surrounding block as their scope.<a id="c001_c1-fn-0056a"></a><a href="#c1-fn-0056"><sup>56</sup></a><sup>,</sup><a id="c001_c1-fn-0057a"></a><a href="#c1-fn-0057"><sup>57</sup></a></p>
</section>
<section>
<h5><a id="c001_c1-sec-0065"></a><a id="c001_c1-title-0066"></a>Conditional statements</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0932"></a>We have seen that it is often useful to declare names that are local to function declarations. When functions become big, we should keep the scope of the names as narrow as possible. Consider for example <span class="KeyTerm1">expmod</span> in exercise 1.26.</p>
<p class="Sp-text-1"><a id="c001_c1-para-0933"></a><b>function</b> expmod(base, exp, m) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0934"></a> <b>return</b> exp === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0935"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0936"></a>           : is_even(exp)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0937"></a>           ? ( expmod(base, exp / 2, m)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0938"></a>              * expmod(base, exp / 2, m)) % m</p>
<p class="Sp-text-1"><a id="c001_c1-para-0939"></a>           : (base * expmod(base, exp - 1, m)) % m;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0940"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0941"></a>This function is unnecessarily inefficient, because it contains two identical calls:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0942"></a>expmod(base, exp / 2, m);</p>
<p class="paracontinue"><a id="c001_c1-para-0950"></a>While this can be easily fixed in this example using the <span class="KeyTerm1">square</span> function, this is not so easy in general. Without using <span class="KeyTerm1">square</span>, we would be tempted to introduce a local name for the expression as follows:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0951"></a><b>function</b> expmod(base, exp, m) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0952"></a> <b>const</b> half_exp = expmod(base, exp / 2, m);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0953"></a> <b>return</b> exp === 0</p>
<p class="Sp-text-1"><a id="c001_c1-para-0954"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c001_c1-para-0955"></a>           : is_even(exp)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0956"></a>           ? (half_exp * half_exp) % m</p>
<p class="Sp-text-1"><a id="c001_c1-para-0957"></a>           : (base * expmod(base, exp - 1, m)) % m;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0958"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0959"></a>This would make the function not just inefficient, but actually nonterminating! The problem is that the constant declaration appears outside the conditional expression, which means that it is executed even when the base case <span class="KeyTerm1">exp === 0</span> is met. To avoid this situation, we provide for <i>conditional statements</i>, and allow return statements to appear in the branches of the statement. Using a conditional statement, we can write the function <span class="KeyTerm1">expmod</span> as follows:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0960"></a><b>function</b> expmod(base, exp, m) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0961"></a> <b>if</b> (exp === 0) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0962"></a> <b>return</b> 1;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0963"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0964"></a> <b>if</b> (is_even(exp)) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0965"></a> <b>const</b> half_exp = expmod(base, exp / 2, m);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0966"></a> <b>return</b> (half_exp * half_exp) % m;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0967"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0968"></a> <b>return</b> (base * expmod(base, exp - 1, m)) % m;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0969"></a>        }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0970"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0971"></a>}</p>
<p><a id="c001_c1-para-0972"></a>The general form of a conditional statement is</p>
<p class="Sp-text-1"><a id="c001_c1-para-0973"></a><b>if</b> (<span class="KeyTerm2"><i>predicate</i></span>) { <span class="KeyTerm2"><i>consequent</i>-<i>statements</i></span> } <b>else</b> { <span class="KeyTerm2"><i>alternative</i>-<i>statements</i></span> }</p>
<p class="paracontinue"><a id="c001_c1-para-0974"></a>As for a conditional expression, the interpreter first evaluates the <i>predicate</i>. If it evaluates to true, the interpreter evaluates the <i>consequent</i>-<i>statements</i> in sequence, and if it evaluates to false, the interpreter evaluates the <i>alternative</i>-<i>statements</i> in sequence. Evaluation of a return statement returns from the surrounding function, ignoring any statements in the sequence after the return statement and any statements after the conditional statement. Note that any constant declarations occurring in either part are local to that part, because each part is enclosed in braces and thus forms its own block.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0066"></a><a id="c001_c1-title-0067"></a>Exercise 1.34</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0975"></a>Suppose we declare</p>
<p class="Sp-text-1"><a id="c001_c1-para-0976"></a><b>function</b> f(g) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0977"></a> <b>return</b> g(2);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0978"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-0979"></a>Then we have</p>
<p class="Sp-text-1"><a id="c001_c1-para-0980"></a>f(square);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0981"></a><i>4</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-0982"></a>f(z =&gt; z * (z + 1));</p>
<p class="Sp-text-1"><a id="c001_c1-para-0983"></a><i>6</i></p>
<p class="paracontinue"><a id="c001_c1-para-0984"></a>What happens if we (perversely) ask the interpreter to evaluate the application <span class="KeyTerm1">f(f)</span>? Explain.</p>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0067"></a><span>1.3.3</span> <a id="c001_c1-title-0068"></a>Functions as General Methods</h3>
<p class="paraaftertitle"><a id="c001_c1-para-0985"></a>We introduced compound functions in section 1.1.4 as a mechanism for abstracting patterns of numerical operations so as to make them independent of the particular numbers involved. With higher-order functions, such as the <span class="KeyTerm1">integral</span> function of section 1.3.1, we began to see a more powerful kind of abstraction: functions used to express general methods of computation, independent of the particular functions involved. In this section we discuss two more elaborate examples—general methods for finding zeros and fixed points of functions—and show how these methods can be expressed directly as functions.</p>
<section>
<h5><a id="c001_c1-sec-0068"></a><a id="c001_c1-title-0069"></a>Finding roots of equations by the half-interval method</h5>
<p class="paraaftertitle"><a id="c001_c1-para-0986"></a>The <i>half-interval method</i> is a simple but powerful technique for finding roots of an equation <i>f</i> (<i>x</i>) = 0, where <i>f</i> is a continuous function. The idea is that, if we are given points <i>a</i> and <i>b</i> such that <i>f</i> (<i>a</i>) &lt; 0 &lt; <i>f</i> (<i>b</i>), then <i>f</i> must have at least one zero between <i>a</i> and <i>b</i>. To locate a zero, let <i>x</i> be the average of <i>a</i> and <i>b</i> and compute <i>f</i> (<i>x</i>). If <i>f</i> (<i>x</i>) &gt; 0, then <i>f</i> must have a zero between <i>a</i> and <i>x</i>. If <i>f</i> (<i>x</i>) &lt; 0, then <i>f</i> must have a zero between <i>x</i> and <i>b</i>. Continuing in this way, we can identify smaller and smaller intervals on which <i>f</i> must have a zero. When we reach a point where the interval is small enough, the process stops. Since the interval of uncertainty is reduced by half at each step of the process, the maximal number of steps required grows as Θ(log(<i>L</i>/<i>T</i>)), where <i>L</i> is the length of the original interval and <i>T</i> is the error tolerance (that is, the size of the interval we will consider “small enough”). Here is a function that implements this strategy:</p>
<p class="Sp-text-1"><a id="c001_c1-para-0987"></a><b>function</b> search(f, neg_point, pos_point) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0988"></a> <b>const</b> midpoint = average(neg_point, pos_point);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0989"></a> <b>if</b> (close_enough(neg_point, pos_point)) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0990"></a> <b>return</b> midpoint;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0991"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c001_c1-para-0992"></a> <b>const</b> test_value = f(midpoint);</p>
<p class="Sp-text-1"><a id="c001_c1-para-0993"></a> <b>return</b> positive(test_value)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0994"></a>               ? search(f, neg_point, midpoint)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0995"></a>               : negative(test_value)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0996"></a>               ? search(f, midpoint, pos_point)</p>
<p class="Sp-text-1"><a id="c001_c1-para-0997"></a>               : midpoint;</p>
<p class="Sp-text-1"><a id="c001_c1-para-0998"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-0999"></a>}</p>
<p><a id="c001_c1-para-1000"></a>We assume that we are initially given the function <i>f</i> together with points at which its values are negative and positive. We first compute the midpoint of the two given points. Next we check to see if the given interval is small enough, and if so we simply return the midpoint as our answer. Otherwise, we compute as a test value the value of <i>f</i> at the midpoint. If the test value is positive, then we continue the process with a new interval running from the original negative point to the midpoint. If the test value is negative, we continue with the interval from the midpoint to the positive point. Finally, there is the possibility that the test value is 0, in which case the midpoint is itself the root we are searching for. To test whether the endpoints are “close enough” we can use a function similar to the one used in section 1.1.7 for computing square roots:<a id="c001_c1-fn-0058a"></a><a href="#c1-fn-0058"><sup>58</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-1001"></a><b>function</b> close_enough(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1002"></a> <b>return</b> abs(x - y) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c001_c1-para-1003"></a>}</p>
<p><a id="c001_c1-para-1004"></a>The function <span class="KeyTerm1">search</span> is awkward to use directly, because we can accidentally give it points at which <i>f</i> 's values do not have the required sign, in which case we get a wrong answer. Instead we will use <span class="KeyTerm1">search</span> via the following function, which checks to see which of the endpoints has a negative function value and which has a positive value, and calls the <span class="KeyTerm1">search</span> function accordingly. If the function has the same sign on the two given points, the half-interval method cannot be used, in which case the function signals an error.<a id="c001_c1-fn-0059a"></a><a href="#c1-fn-0059"><sup>59</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-1005"></a><b>function</b> half_interval_method(f, a, b) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1006"></a> <b>const</b> a_value = f(a);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1007"></a> <b>const</b> b_value = f(b);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1008"></a> <b>return</b> negative(a_value) &amp;&amp; positive(b_value)</p>
<p class="Sp-text-1"><a id="c001_c1-para-1009"></a>           ? search(f, a, b)</p>
<p class="Sp-text-1"><a id="c001_c1-para-1010"></a>           : negative(b_value) &amp;&amp; positive(a_value)</p>
<p class="Sp-text-1"><a id="c001_c1-para-1011"></a>           ? search(f, b, a)</p>
<p class="Sp-text-1"><a id="c001_c1-para-1012"></a>           : error("values are not of opposite sign");</p>
<p class="Sp-text-1"><a id="c001_c1-para-1013"></a>}</p>
<p><a id="c001_c1-para-1014"></a>The following example uses the half-interval method to approximate <i>π</i> as the root between 2 and 4 of sin <i>x</i> = 0:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1015"></a>half_interval_method(math_sin, 2, 4);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1016"></a><i>3.14111328125</i></p>
<p><a id="c001_c1-para-1017"></a>Here is another example, using the half-interval method to search for a root of the equation <i>x</i><sup>3</sup> – 2<i>x</i> – 3 = 0 between 1 and 2:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1018"></a>half_interval_method(x =&gt; x * x * x - 2 * x - 3, 1, 2);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1019"></a><i>1.89306640625</i></p>
</section>
<section>
<h5><a id="c001_c1-sec-0069"></a><a id="c001_c1-title-0070"></a>Finding fixed points of functions</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1020"></a>A number <i>x</i> is called a <i>fixed point</i> of a function <i>f</i> if <i>x</i> satisfies the equation <i>f</i> (<i>x</i>) = <i>x</i>. For some functions <i>f</i> we can locate a fixed point by beginning with an initial guess and applying <i>f</i> repeatedly,</p>
<p class="Sp-text-2"><a id="c001_c1-para-1021"></a><i>f</i> (<i>x</i>), <i>f</i> (<i>f</i> (<i>x</i>)), <i>f</i> (<i>f</i> (<i>f</i> (<i>x</i>))), <span class="KeyTerm1"><i>. . .</i></span></p>
<p class="paracontinue"><a id="c001_c1-para-1022"></a>until the value does not change very much. Using this idea, we can devise a function <span class="KeyTerm1">fixed_point</span> that takes as inputs a function and an initial guess and produces an approximation to a fixed point of the function. We apply the function repeatedly until we find two successive values whose difference is less than some prescribed tolerance:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1023"></a><b>const</b> tolerance = 0.00001;</p>
<p class="Sp-text-1"><a id="c001_c1-para-1024"></a><b>function</b> fixed_point(f, first_guess) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1025"></a> <b>function</b> close_enough(x, y) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1026"></a> <b>return</b> abs(x - y) &lt; tolerance;</p>
<p class="Sp-text-1"><a id="c001_c1-para-1027"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-1028"></a> <b>function</b> try_with(guess) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1029"></a> <b>const</b> next = f(guess);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1030"></a> <b>return</b> close_enough(guess, next)</p>
<p class="Sp-text-1"><a id="c001_c1-para-1031"></a>               ? next</p>
<p class="Sp-text-1"><a id="c001_c1-para-1032"></a>               : try_with(next);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1033"></a>    }</p>
<p class="Sp-text-1"><a id="c001_c1-para-1034"></a> <b>return</b> try_with(first_guess);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1035"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-1036"></a>For example, we can use this method to approximate the fixed point of the cosine function, starting with 1 as an initial approximation:<a id="c001_c1-fn-0060a"></a><a href="#c1-fn-0060"><sup>60</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-1037"></a>fixed_point(math_cos, 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1038"></a><i>0.7390822985224023</i></p>
<p class="paracontinue"><a id="c001_c1-para-1039"></a>Similarly, we can find a solution to the equation <i>y</i> = sin <i>y</i> + cos <i>y</i>:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1040"></a>fixed_point(y =&gt; math_sin(y) + math_cos(y), 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1041"></a><i>1.2587315962971173</i></p>
<p><a id="c001_c1-para-1042"></a>The fixed-point process is reminiscent of the process we used for finding square roots in section 1.1.7. Both are based on the idea of repeatedly improving a guess until the result satisfies some criterion. In fact, we can readily formulate the squareroot computation as a fixed-point search. Computing the square root of some number <i>x</i> requires finding a <i>y</i> such that <i>y</i><sup>2</sup> = <i>x</i>. Putting this equation into the equivalent form <i>y</i> = <i>x</i>/<i>y</i>, we recognize that we are looking for a fixed point of the function<a id="c001_c1-fn-0061a"></a><a href="#c1-fn-0061"><sup>61</sup></a> <i>y x</i>/<i>y</i>, and we can therefore try to compute square roots as</p>
<p class="Sp-text-1"><a id="c001_c1-para-1043"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1044"></a> <b>return</b> fixed_point(y =&gt; x / y, 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1045"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-1046"></a>Unfortunately, this fixed-point search does not converge. Consider an initial guess <i>y</i><sub>1</sub>. The next guess is <i>y</i><sub>2 </sub>= <i>x</i>/<i>y</i><sub>1</sub> and the next guess is <i>y</i><sub>3 </sub>= <i>x</i>/<i>y</i><sub>2 </sub>= <i>x</i>/(<i>x</i>/<i>y</i><sub>1</sub>) = <i>y</i><sub>1</sub>. This results in an infinite loop in which the two guesses <i>y</i><sub>1</sub> and <i>y</i><sub>2</sub> repeat over and over, oscillating about the answer.</p>
<p><a id="c001_c1-para-1047"></a>One way to control such oscillations is to prevent the guesses from changing so much. Since the answer is always between our guess <i>y</i> and <i>x</i>/<i>y</i>, we can make a new guess that is not as far from <i>y</i> as <i>x</i>/<i>y</i> by averaging <i>y</i> with <i>x</i>/<i>y</i>, so that the next guess after <i>y</i> is <img alt="c1-fig-5021.jpg" src="../images/c1-fig-5021.jpg"/> (<i>y</i> + <i>x</i>/<i>y</i>) instead of <i>x</i>/<i>y</i>. The process of making such a sequence of guesses is simply the process of looking for a fixed point of <i>y</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <img alt="c1-fig-5021.jpg" src="../images/c1-fig-5021.jpg"/> (<i>y</i> + <i>x</i>/<i>y</i>):</p>
<p class="Sp-text-1"><a id="c001_c1-para-1048"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1049"></a> <b>return</b> fixed_point(y =&gt; average(y, x / y), 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1050"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-1051"></a>(Note that <i>y</i> = <img alt="c1-fig-5021.jpg" src="../images/c1-fig-5021.jpg"/> (<i>y</i> + <i>x</i>/<i>y</i>) is a simple transformation of the equation <i>y</i> = <i>x</i>/<i>y</i>; to derive it, add <i>y</i> to both sides of the equation and divide by 2.)</p>
<p><a id="c001_c1-para-1052"></a>With this modification, the square-root function works. In fact, if we unravel the definitions, we can see that the sequence of approximations to the square root generated here is precisely the same as the one generated by our original square-root function of section 1.1.7. This approach of averaging successive approximations to a solution, a technique we call <i>average damping</i>, often aids the convergence of fixed-point searches.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0070"></a><a id="c001_c1-title-0071"></a>Exercise 1.35</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1053"></a>Show that the golden ratio <i>ϕ</i> (section 1.2.2) is a fixed point of the transformation <i>x</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> 1 + 1/<i>x</i>, and use this fact to compute <i>ϕ</i> by means of the <span class="KeyTerm1">fixed_point</span> function.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0071"></a><a id="c001_c1-title-0072"></a>Exercise 1.36</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1054"></a>Modify <span class="KeyTerm1">fixed_point</span> so that it prints the sequence of approximations it generates, using the primitive function <span class="KeyTerm1">display</span> shown in exercise 1.22. Then find a solution to <i>x<sup>x</sup></i> = 1000 by finding a fixed point of <i>x</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> log(1000)/ log(<i>x</i>). (Use the primitive function <span class="KeyTerm1">math_log</span>, which computes natural logarithms.) Compare the number of steps this takes with and without average damping. (Note that you cannot start <span class="KeyTerm1">fixed_point</span> with a guess of 1, as this would cause division by log(1) = 0.)</p>
</section>
<section>
<h5><a id="c001_c1-sec-0072"></a><a id="c001_c1-title-0073"></a>Exercise 1.37</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1055"></a>An infinite <i>continued fraction</i> is an expression of the form</p>
<p><a id="c001_c1-para-1056"></a></p>
<figure id="c001_c1-fig-0021"><img alt="c1-fig-5023.jpg" src="../images/c1-fig-5023.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-1057"></a>As an example, one can show that the infinite continued fraction expansion with the <i>N<sub>i</sub></i> and the <i>D<sub>i</sub></i> all equal to 1 produces 1/<i>ϕ</i>, where <i>ϕ</i> is the golden ratio (described in section 1.2.2). One way to approximate an infinite continued fraction is to truncate the expansion after a given number of terms. Such a truncation—a so-called <i>k-term finite continued fraction</i>—has the form</p>
<p><a id="c001_c1-para-1058"></a></p>
<figure id="c001_c1-fig-0022"><img alt="c1-fig-5024.jpg" src="../images/c1-fig-5024.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<ol class="BS_NumberListA">
<li><a id="c001_c1-li-0033"></a><span>a. </span>Suppose that <span class="KeyTerm1">n</span> and <span class="KeyTerm1">d</span> are functions of one argument (the term index <i>i</i>) that return the <i>N<sub>i</sub></i> and <i>D<sub>i</sub></i> of the terms of the continued fraction. Declare a function <span class="KeyTerm1">cont_frac</span> such that evaluating <span class="KeyTerm1">cont_frac(n, d, k)</span> computes the value of the <i>k</i>-term finite continued fraction. Check your function by approximating 1<i>ϕ</i> using
<p class="Sp-text-1"><a id="c001_c1-para-1060"></a>cont_frac(i =&gt; 1, i =&gt; 1, k);</p>
<p class="paracontinue"><a id="c001_c1-para-1061"></a>for successive values of <span class="KeyTerm1">k</span>. How large must you make <span class="KeyTerm1">k</span> in order to get an approximation that is accurate to 4 decimal places?</p></li>
<li><a id="c001_c1-li-0034"></a><span>b. </span>If your <span class="KeyTerm1">cont_frac</span> function generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</li>
</ol>
</section>
<section>
<h5><a id="c001_c1-sec-0073"></a><a id="c001_c1-title-0074"></a>Exercise 1.38</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1063"></a>In 1737, the Swiss mathematician Leonhard Euler published a memoir <i>De Fractionibus Continuis</i>, which included a continued fraction expansion for <i>e</i> – 2, where <i>e</i> is the base of the natural logarithms. In this fraction, the <i>N<sub>i</sub></i> are all 1, and the <i>D<sub>i</sub></i> are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, Write a program that uses your <span class="KeyTerm1">cont_frac</span> function from exercise 1.37 to approximate <i>e</i>, based on Euler's expansion.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0074"></a><a id="c001_c1-title-0075"></a>Exercise 1.39</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1064"></a>A continued fraction representation of the tangent function was published in 1770 by the German mathematician J.H. Lambert:</p>
<p><a id="c001_c1-para-1065"></a></p>
<figure id="c001_c1-fig-0023"><img alt="c1-fig-5025.jpg" src="../images/c1-fig-5025.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-1066"></a>where <i>x</i> is in radians. Declare a function <span class="KeyTerm1">tan_cf(x, k)</span> that computes an approximation to the tangent function based on Lambert's formula. As in exercise 1.37, <span class="KeyTerm1">k</span> specifies the number of terms to compute.</p>
</section>
</section>
<section>
<h3><a id="c001_c1-sec-0075"></a><span>1.3.4</span> <a id="c001_c1-title-0076"></a>Functions as Returned Values</h3>
<p class="paraaftertitle"><a id="c001_c1-para-1067"></a>The above examples demonstrate how the ability to pass functions as arguments significantly enhances the expressive power of our programming language. We can achieve even more expressive power by creating functions whose returned values are themselves functions.</p>
<p><a id="c001_c1-para-1068"></a>We can illustrate this idea by looking again at the fixed-point example described at the end of section 1.3.3. We formulated a new version of the square-root function as a fixed-point search, starting with the observation that <img alt="c1-fig-5005.jpg" src="../images/c1-fig-5005.jpg"/> is a fixed-point of the function <i>y</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i>/<i>y</i>. Then we used average damping to make the approximations converge. Average damping is a useful general technique in itself. Namely, given a function <i>f,</i> we consider the function whose value at <i>x</i> is equal to the average of <i>x</i> and <i>f</i> (<i>x</i>).</p>
<p><a id="c001_c1-para-1069"></a>We can express the idea of average damping by means of the following function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1070"></a><b>function</b> average_damp(f) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1071"></a> <b>return</b> x =&gt; average(x, f(x));</p>
<p class="Sp-text-1"><a id="c001_c1-para-1072"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-1073"></a>The function <span class="KeyTerm1">average_damp</span> takes as its argument a function <span class="KeyTerm1">f</span> and returns as its value a function (produced by the lambda expression) that, when applied to a number <span class="KeyTerm1">x</span>, produces the average of <span class="KeyTerm1">x</span> and <span class="KeyTerm1">f(x)</span>. For example, applying <span class="KeyTerm1">average_damp</span> to the <span class="KeyTerm1">square</span> function produces a function whose value at some number <i>x</i> is the average of <i>x</i> and <i>x</i><sup>2</sup>. Applying this resulting function to 10 returns the average of 10 and 100, or 55:<a id="c001_c1-fn-0062a"></a><a href="#c1-fn-0062"><sup>62</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-1074"></a>average_damp(square)(10);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1075"></a><i>55</i></p>
<p><a id="c001_c1-para-1076"></a>Using <span class="KeyTerm1">average_damp</span>, we can reformulate the square-root function as follows:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1077"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1078"></a> <b>return</b> fixed_point(average_damp(y =&gt; x / y), 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1079"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-1080"></a>Notice how this formulation makes explicit the three ideas in the method: fixedpoint search, average damping, and the function <i>y x</i>/<i>y</i>. It is instructive to compare this formulation of the square-root method with the original version given in section 1.1.7. Bear in mind that these functions express the same process, and notice how much clearer the idea becomes when we express the process in terms of these abstractions. In general, there are many ways to formulate a process as a function. Experienced programmers know how to choose process formulations that are particularly perspicuous, and where useful elements of the process are exposed as separate entities that can be reused in other applications. As a simple example of reuse, notice that the cube root of <i>x</i> is a fixed point of the function <i>y x</i>/<i>y</i><sup>2</sup>, so we can immediately generalize our square-root function to one that extracts cube roots:<a id="c001_c1-fn-0063a"></a><a href="#c1-fn-0063"><sup>63</sup></a></p>
<p class="Sp-text-1"><a id="c001_c1-para-1081"></a><b>function</b> cube_root(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1082"></a> <b>return</b> fixed_point(average_damp(y =&gt; x / square(y)), 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1083"></a>}</p>
<section>
<h5><a id="c001_c1-sec-0076"></a><a id="c001_c1-title-0077"></a>Newton's method</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1084"></a>When we first introduced the square-root function, in section 1.1.7, we mentioned that this was a special case of <i>Newton's method</i>. If <i>x</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>g</i>(<i>x</i>) is a differentiable function, then a solution of the equation <i>g</i>(<i>x</i>) = 0 is a fixed point of the function <i>x</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>f</i> (<i>x</i>) where</p>
<p><a id="c001_c1-para-1085"></a></p>
<figure id="c001_c1-fig-0024"><img alt="c1-fig-5026.jpg" src="../images/c1-fig-5026.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-1086"></a>and <i>Dg</i>(<i>x</i>) is the derivative of <i>g</i> evaluated at <i>x</i>. Newton's method is the use of the fixed-point method we saw above to approximate a solution of the equation by finding a fixed point of the function <i>f</i> .<a id="c001_c1-fn-0064a"></a><a href="#c1-fn-0064"><sup>64</sup></a> For many functions <i>g</i> and for sufficiently good initial guesses for <i>x</i>, Newton's method converges very rapidly to a solution of <i>g</i>(<i>x</i>) = 0.<a id="c001_c1-fn-0065a"></a><a href="#c1-fn-0065"><sup>65</sup></a></p>
<p><a id="c001_c1-para-1087"></a>In order to implement Newton's method as a function, we must first express the idea of derivative. Note that “derivative,” like average damping, is something that transforms a function into another function. For instance, the derivative of the function <i>x</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i><sup>3</sup> is the function <i>x</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> 3<i>x</i><sup>2</sup>. In general, if <i>g</i> is a function and <i>dx</i> is a small number, then the derivative <i>Dg</i> of <i>g</i> is the function whose value at any number <i>x</i> is given (in the limit of small <i>dx</i>) by</p>
<p><a id="c001_c1-para-1088"></a></p>
<figure id="c001_c1-fig-0025"><img alt="c1-fig-5027.jpg" src="../images/c1-fig-5027.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c001_c1-para-1089"></a>Thus, we can express the idea of derivative (taking <i>dx</i> to be, say, 0.00001) as the function</p>
<p class="Sp-text-1"><a id="c001_c1-para-1090"></a><b>function</b> deriv(g) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1091"></a> <b>return</b> x =&gt; (g(x + dx) - g(x)) / dx;</p>
<p class="Sp-text-1"><a id="c001_c1-para-1092"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-1093"></a>along with the declaration</p>
<p class="Sp-text-1"><a id="c001_c1-para-1094"></a><b>const</b> dx = 0.00001;</p>
<p><a id="c001_c1-para-1095"></a>Like <span class="KeyTerm1">average_damp</span>, <span class="KeyTerm1">deriv</span> is a function that takes a function as argument and returns a function as value. For example, to approximate the derivative of <i>x</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i><sup>3</sup> at 5 (whose exact value is 75) we can evaluate</p>
<p class="Sp-text-1"><a id="c001_c1-para-1096"></a><b>function</b> cube(x) { <b>return</b> x * x * x; }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c001_c1-para-1097"></a>deriv(cube)(5);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1098"></a><i>75.00014999664018</i></p>
<p><a id="c001_c1-para-1099"></a>With the aid of <span class="KeyTerm1">deriv</span>, we can express Newton's method as a fixed-point process:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1100"></a><b>function</b> newton_transform(g) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1101"></a> <b>return</b> x =&gt; x - g(x) / deriv(g)(x);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1102"></a>}</p>
<p class="Sp-text-1"><a id="c001_c1-para-1103"></a><b>function</b> newtons_method(g, guess) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1104"></a> <b>return</b> fixed_point(newton_transform(g), guess);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1105"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-1106"></a>The <span class="KeyTerm1">newton_transform</span> function expresses the formula at the beginning of this section, and <span class="KeyTerm1">newtons_method</span> is readily defined in terms of this. It takes as arguments a function that computes the function for which we want to find a zero, together with an initial guess. For instance, to find the square root of <i>x</i>, we can use Newton's method to find a zero of the function <i>y</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>y</i><sup>2</sup> – <i>x</i> starting with an initial guess of 1.<a id="c001_c1-fn-0066a"></a><a href="#c1-fn-0066"><sup>66</sup></a> This provides yet another form of the square-root function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1107"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1108"></a> <b>return</b> newtons_method(y =&gt; square(y) - x, 1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1109"></a>}</p>
</section>
<section>
<h5><a id="c001_c1-sec-0077"></a><a id="c001_c1-title-0078"></a>Abstractions and first-class functions</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1110"></a>We've seen two ways to express the square-root computation as an instance of a more general method, once as a fixed-point search and once using Newton's method. Since Newton's method was itself expressed as a fixed-point process, we actually saw two ways to compute square roots as fixed points. Each method begins with a function and finds a fixed point of some transformation of the function. We can express this general idea itself as a function:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1111"></a><b>function</b> fixed_point_of_transform(g, transform, guess) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1112"></a> <b>return</b> fixed_point(transform(g), guess);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1113"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-1114"></a>This very general function takes as its arguments a function <span class="KeyTerm1">g</span> that computes some function, a function that transforms <span class="KeyTerm1">g</span>, and an initial guess. The returned result is a fixed point of the transformed function.</p>
<p><a id="c001_c1-para-1115"></a>Using this abstraction, we can recast the first square-root computation from this section (where we look for a fixed point of the average-damped version of <i>y</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i>/<i>y</i>) as an instance of this general method:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1116"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1117"></a> <b>return</b> fixed_point_of_transform(</p>
<p class="Sp-text-1"><a id="c001_c1-para-1118"></a>               y =&gt; x / y,</p>
<p class="Sp-text-1"><a id="c001_c1-para-1119"></a>               average_damp,</p>
<p class="Sp-text-1"><a id="c001_c1-para-1120"></a>               1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1121"></a>}</p>
<p class="paracontinue"><a id="c001_c1-para-1122"></a>Similarly, we can express the second square-root computation from this section (an instance of Newton's method that finds a fixed point of the Newton transform of <i>y</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>y</i><sup>2</sup> – <i>x</i>) as</p>
<p class="Sp-text-1"><a id="c001_c1-para-1123"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c001_c1-para-1124"></a> <b>return</b> fixed_point_of_transform(</p>
<p class="Sp-text-1"><a id="c001_c1-para-1125"></a>               y =&gt; square(y) - x,</p>
<p class="Sp-text-1"><a id="c001_c1-para-1126"></a>               newton_transform,</p>
<p class="Sp-text-1"><a id="c001_c1-para-1127"></a>               1);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1128"></a>}</p>
<p><a id="c001_c1-para-1129"></a>We began section 1.3 with the observation that compound functions are a crucial abstraction mechanism, because they permit us to express general methods of computing as explicit elements in our programming language. Now we've seen how higher-order functions permit us to manipulate these general methods to create further abstractions.</p>
<p><a id="c001_c1-para-1130"></a>As programmers, we should be alert to opportunities to identify the underlying abstractions in our programs and to build upon them and generalize them to create more powerful abstractions. This is not to say that one should always write programs in the most abstract way possible; expert programmers know how to choose the level of abstraction appropriate to their task. But it is important to be able to think in terms of these abstractions, so that we can be ready to apply them in new contexts. The significance of higher-order functions is that they enable us to represent these abstractions explicitly as elements in our programming language, so that they can be handled just like other computational elements.</p>
<p><a id="c001_c1-para-1131"></a>In general, programming languages impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have <i>first-class</i> status. Some of the “rights and privileges” of first-class elements are:<a id="c001_c1-fn-0067a"></a><a href="#c1-fn-0067"><sup>67</sup></a></p>
<ul style="list-style-type:disc">
<li>They may be referred to using names.</li>
<li>They may be passed as arguments to functions.</li>
<li>They may be returned as the results of functions.</li>
<li>They may be included in data structures.<a id="c001_c1-fn-0068a"></a><a href="#c1-fn-0068"><sup>68</sup></a></li>
</ul>
<p class="paracontinue"><a id="c001_c1-para-1136"></a>JavaScript, like other high-level programming languages, awards functions full firstclass status. This poses challenges for efficient implementation, but the resulting gain in expressive power is enormous.<a id="c001_c1-fn-0069a"></a><a href="#c1-fn-0069"><sup>69</sup></a></p>
</section>
<section>
<h5><a id="c001_c1-sec-0078"></a><a id="c001_c1-title-0079"></a>Exercise 1.40</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1137"></a>Declare a function <span class="KeyTerm1">cubic</span> that can be used together with the <span class="KeyTerm1">newtons_method</span> function in expressions of the form</p>
<p class="Sp-text-1"><a id="c001_c1-para-1138"></a>newtons_method(cubic(a, b, c), 1)</p>
<p class="paracontinue"><a id="c001_c1-para-1139"></a>to approximate zeros of the cubic <i>x</i><sup>3</sup> + <i>ax</i><sup>2</sup> + <i>bx</i> + <i>c</i>.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0079"></a><a id="c001_c1-title-0080"></a>Exercise 1.41</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1140"></a>Declare a function <span class="KeyTerm1">double</span> that takes a function of one argument as argument and returns a function that applies the original function twice. For example, if <span class="KeyTerm1">inc</span> is a function that adds 1 to its argument, then <span class="KeyTerm1">double(inc)</span> should be a function that adds 2. What value is returned by</p>
<p class="Sp-text-1"><a id="c001_c1-para-1141"></a>double(double(double))(inc)(5);</p>
</section>
<section>
<h5><a id="c001_c1-sec-0080"></a><a id="c001_c1-title-0081"></a>Exercise 1.42</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1142"></a>Let <i>f</i> and <i>g</i> be two one-argument functions. The <i>composition f</i> after <i>g</i> is defined to be the function <i>x</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>f</i> (<i>g</i>(<i>x</i>)). Declare a function <span class="KeyTerm1">compose</span> that implements composition. For example, if <span class="KeyTerm1">inc</span> is a function that adds 1 to its argument,</p>
<p class="Sp-text-1"><a id="c001_c1-para-1143"></a>compose(square, inc)(6);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1144"></a><i>49</i></p>
</section>
<section>
<h5><a id="c001_c1-sec-0081"></a><a id="c001_c1-title-0082"></a>Exercise 1.43</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1145"></a>If <i>f</i> is a numerical function and <i>n</i> is a positive integer, then we can form the <i>n</i>th repeated application of <i>f,</i> which is defined to be the function whose value at <i>x</i> is <i>f</i> (<i>f</i> (<i>. . .</i> (<i>f</i> (<i>x</i>)) <i>. . .</i>)). For example, if <i>f</i> is the function <i>x</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i> + 1, then the <i>n</i>th repeated application of <i>f</i> is the function <i>x</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i> + <i>n</i>. If <i>f</i> is the operation of squaring a number, then the <i>n</i>th repeated application of <i>f</i> is the function that raises its argument to the 2<i><sup>n</sup></i>th power. Write a function that takes as inputs a function that computes <i>f</i> and a positive integer <i>n</i> and returns the function that computes the <i>n</i>th repeated application of <i>f</i> . Your function should be able to be used as follows:</p>
<p class="Sp-text-1"><a id="c001_c1-para-1146"></a>repeated(square, 2)(5);</p>
<p class="Sp-text-1"><a id="c001_c1-para-1147"></a><i>625</i></p>
<p class="paracontinue"><a id="c001_c1-para-1148"></a>Hint: You may find it convenient to use <span class="KeyTerm1">compose</span> from exercise 1.42.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0082"></a><a id="c001_c1-title-0083"></a>Exercise 1.44</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1149"></a>The idea of <i>smoothing</i> a function is an important concept in signal processing. If <i>f</i> is a function and <i>dx</i> is some small number, then the smoothed version of <i>f</i> is the function whose value at a point <i>x</i> is the average of <i>f</i> (<i>x</i> – <i>dx</i>), <i>f</i> (<i>x</i>), and <i>f</i> (<i>x</i> + <i>dx</i>). Write a function <span class="KeyTerm1">smooth</span> that takes as input a function that computes <i>f</i> and returns a function that computes the smoothed <i>f</i> . It is sometimes valuable to repeatedly smooth a function (that is, smooth the smoothed function, and so on) to obtained the <i>n-fold smoothed function</i>. Show how to generate the <i>n</i>-fold smoothed function of any given function using <span class="KeyTerm1">smooth</span> and <span class="KeyTerm1">repeated</span> from exercise 1.43.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0083"></a><a id="c001_c1-title-0084"></a>Exercise 1.45</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1150"></a>We saw in section 1.3.3 that attempting to compute square roots by naively finding a fixed point of <i>y</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i>/<i>y</i> does not converge, and that this can be fixed by average damping. The same method works for finding cube roots as fixed points of the average-damped <i>y</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i>/<i>y</i><sup>2</sup>. Unfortunately, the process does not work for fourth roots—a single average damp is not enough to make a fixed-point search for <i>y</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i>/<i>y</i><sup>3</sup> converge. On the other hand, if we average-damp twice (i.e., use the average damp of the average damp of <i>y</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i>/<i>y</i><sup>3</sup>) the fixedpoint search does converge. Do some experiments to determine how many average damps are required to compute <i>n</i>th roots as a fixed-point search based upon repeated average damping of <i>y</i> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> <i>x</i>/<i>y<sup>n</sup></i><sup>–1</sup>. Use this to implement a simple function for computing <i>n</i>th roots using <span class="KeyTerm1">fixed_point</span>, <span class="KeyTerm1">average_damp</span>, and the <span class="KeyTerm1">repeated</span> function of exercise 1.43. Assume that any arithmetic operations you need are available as primitives.</p>
</section>
<section>
<h5><a id="c001_c1-sec-0084"></a><a id="c001_c1-title-0085"></a>Exercise 1.46</h5>
<p class="paraaftertitle"><a id="c001_c1-para-1151"></a>Several of the numerical methods described in this chapter are instances of an extremely general computational strategy known as <i>iterative improvement</i>. Iterative improvement says that, to compute something, we start with an initial guess for the answer, test if the guess is good enough, and otherwise improve the guess and continue the process using the improved guess as the new guess. Write a function <span class="KeyTerm1">iterative_improve</span> that takes two functions as arguments: a method for telling whether a guess is good enough and a method for improving a guess. The function <span class="KeyTerm1">iterative_improve</span> should return as its value a function that takes a guess as argument and keeps improving the guess until it is good enough. Rewrite the <span class="KeyTerm1">sqrt</span> function of section 1.1.7 and the <span class="KeyTerm1">fixed_point</span> function of section 1.3.3 in terms of <span class="KeyTerm1">iterative_improve</span>.</p>
</section>
</section>
</section>
</section>
<section class="BS_enoteSec">
<aside class="noteEntry"><a id="c001_c1-fn-0001"></a><a href="#c1-fn-0001a">1</a> The characterization of numbers as “simple data” is a barefaced bluff. In fact, the treatment of numbers is one of the trickiest and most confusing aspects of any programming language. Some typical issues involved are these: Some computer systems distinguish <i>integers</i>, such as 2, from <i>real numbers</i>, such as 2.71. Is the real number 2.00 different from the integer 2? Are the arithmetic operations used for integers the same as the operations used for real numbers? Does 6 divided by 2 produce 3, or 3.0? How large a number can we represent? How many decimal places of accuracy can we represent? Is the range of integers the same as the range of real numbers? Above and beyond these questions, of course, lies a collection of issues concerning roundoff and truncation errors—the entire science of numerical analysis. Since our focus in this book is on large-scale program design rather than on numerical techniques, we are going to ignore these problems. The numerical examples in this chapter will exhibit the usual roundoff behavior that one observes when using arithmetic operations that preserve a limited number of decimal places of accuracy in noninteger operations.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0002"></a><a href="#c1-fn-0002a">2</a> Throughout this book, we distinguish between the input typed by the user and any text printed by the interpreter by showing the latter in slanted characters.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0003"></a><a href="#c1-fn-0003a">3</a> JavaScript obeys the convention that every statement has a value (see exercise 4.8). This convention, together with the reputation of JavaScript programmers as not caring about efficiency, leads us to paraphrase a quip on Lisp programmers by Alan Perlis (who was himself paraphrasing Oscar Wilde): <i>JavaScript programmers know the value of everything but the cost of nothing.</i></aside>
<aside class="noteEntry"><a id="c001_c1-fn-0004"></a><a href="#c1-fn-0004a">4</a> In this book, we do not show the interpreter's response to evaluating programs that end with declarations, since this might depend on previous statements. See exercise 4.8 for details.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0005"></a><a href="#c1-fn-0005a">5</a> Chapter 3 will show that this notion of environment is crucial for understanding how the interpreter works. Chapter 4 will use environments for implementing interpreters.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0006"></a><a href="#c1-fn-0006a">6</a> Observe that there are two different operations being combined here: we are creating the function, and we are giving it the name <span class="KeyTerm1">square</span>. It is possible, indeed important, to be able to separate these two notions—to create functions without naming them, and to give names to functions that have already been created. We will see how to do this in section 1.3.2.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0007"></a><a href="#c1-fn-0007a">7</a> Throughout this book, we will describe the general syntax of expressions by using italic symbols—e.g., <i>name</i>—to denote the “slots” in the expression to be filled in when such an expression is actually used.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0008"></a><a href="#c1-fn-0008a">8</a> More generally, the body of the function can be a sequence of statements. In this case, the interpreter evaluates each statement in the sequence in turn until a return statement determines the value of the function application.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0009"></a><a href="#c1-fn-0009a">9</a> The way multi-part names such as <span class="KeyTerm1">sum_of_squares</span> are written affects the readability of programs, and programming communities differ on this. According to the common JavaScript convention, called <i>camel case</i>, the name would be <span class="KeyTerm1">sumOfSquares</span>. The convention used in this book is called <i>snake case</i>, and was chosen for its closer resemblance to the convention used in the Scheme version of this book, where hyphens play the role of our underscores.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0010"></a><a href="#c1-fn-0010a">10</a> Our JavaScript environment includes all functions and constants of ECMAScript's Math object, under the names <span class="KeyTerm1">math_<i>. . .</i></span>. For example, ECMAScript's <span class="KeyTerm1">Math.log</span> is available as <span class="KeyTerm1">math_log</span>. The MIT Press web page for this book includes the JavaScript package <span class="KeyTerm1">sicp</span> that provides these and all other JavaScript functions that are considered primitive in the book.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0011"></a><a href="#c1-fn-0011a">11</a> If the body of the function is a sequence of statements, the body is evaluated with the parameters replaced, and the value of the application is the value of the return expression of the first return statement encountered.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0012"></a><a href="#c1-fn-0012a">12</a> Despite the simplicity of the substitution idea, it turns out to be surprisingly complicated to give a rigorous mathematical definition of the substitution process. The problem arises from the possibility of confusion between the names used for the parameters of a function and the (possibly identical) names used in the expressions to which the function may be applied. Indeed, there is a long history of erroneous definitions of <i>substitution</i> in the literature of logic and programming semantics. See Stoy 1977 for a careful discussion of substitution.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0013"></a><a href="#c1-fn-0013a">13</a> In chapter 3 we will introduce <i>stream processing</i>, which is a way of handling apparently “infinite” data structures by incorporating a limited form of normal-order evaluation. In section 4.2 we will modify the JavaScript interpreter to produce a normal-order variant of JavaScript.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0014"></a><a href="#c1-fn-0014a">14</a> Conditionals in full JavaScript accept any value, not just a boolean, as the result of evaluating the <i>predicate</i> expression (see footnote 14 in section 4.1.3 for details). The programs in this book use only boolean values as predicates of conditionals.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0015"></a><a href="#c1-fn-0015a">15</a> For now, we restrict these operators to number arguments. In sections 2.3.1 and 3.3.1, we shall generalize the equality and inequality predicates <span class="KeyTerm1">===</span> and <span class="KeyTerm1">!==</span>.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0016"></a><a href="#c1-fn-0016a">16</a> Syntactic forms that are simply convenient alternative surface structures for things that can be written in more uniform ways are sometimes called <i>syntactic sugar</i>, to use a phrase coined by Peter Landin.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0017"></a><a href="#c1-fn-0017a">17</a> Declarative and imperative descriptions are intimately related, as indeed are mathematics and computer science. For instance, to say that the answer produced by a program is “correct” is to make a declarative statement about the program. There is a large amount of research aimed at establishing techniques for proving that programs are correct, and much of the technical difficulty of this subject has to do with negotiating the transition between imperative statements (from which programs are constructed) and declarative statements (which can be used to deduce things). In a related vein, programming language designers have explored so-called very highlevel languages, in which one actually programs in terms of declarative statements. The idea is to make interpreters sophisticated enough so that, given “what is” knowledge specified by the programmer, they can generate “how to” knowledge automatically. This cannot be done in general, but there are important areas where progress has been made. We shall revisit this idea in chapter 4.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0018"></a><a href="#c1-fn-0018a">18</a> This square-root algorithm is actually a special case of Newton's method, which is a general technique for finding roots of equations. The square-root algorithm itself was developed by Heron of Alexandria in the first century CE. We will see how to express the general Newton's method as a JavaScript function in section 1.3.4.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0019"></a><a href="#c1-fn-0019a">19</a> We will usually give predicates names starting with <span class="KeyTerm1">is_</span>, to help us remember that they are predicates.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0020"></a><a href="#c1-fn-0020a">20</a> Readers who are worried about the efficiency issues involved in using function calls to implement iteration should note the remarks on “tail recursion” in section 1.2.1.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0021"></a><a href="#c1-fn-0021a">21</a> As a Lisp hacker from the original <i>Structure and Interpretation of Computer Programs</i>, Alyssa prefers a simpler, more uniform syntax.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0022"></a><a href="#c1-fn-0022a">22</a> It is not even clear which of these functions is a more efficient implementation. This depends upon the hardware available. There are machines for which the “obvious” implementation is the less efficient one. Consider a machine that has extensive tables of logarithms and antilogarithms stored in a very efficient manner.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0023"></a><a href="#c1-fn-0023a">23</a> The concept of consistent renaming is actually subtle and difficult to define formally. Famous logicians have made embarrassing errors here.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0024"></a><a href="#c1-fn-0024a">24</a> Lexical scoping dictates that free names in a function are taken to refer to bindings made by enclosing function declarations; that is, they are looked up in the environment in which the function was declared. We will see how this works in detail in chapter 3 when we study environments and the detailed behavior of the interpreter.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0025"></a><a href="#c1-fn-0025a">25</a> Embedded declarations must come first in a function body. The management is not responsible for the consequences of running programs that intertwine declaration and use; see also footnotes 54 and 56 in section 1.3.2.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0026"></a><a href="#c1-fn-0026a">26</a> In a real program we would probably use the block structure introduced in the last section to hide the declaration of <span class="KeyTerm1">fact_iter</span>:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> factorial(n) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>function</b> iter(product, counter) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> counter &gt; n</span>
<br/><span class="BS_Sp-text-1_FN">               ? product</span>
<br/><span class="BS_Sp-text-1_FN">               : iter(counter * product,</span>
<br/><span class="BS_Sp-text-1_FN">                      counter + 1);</span>
<br/><span class="BS_Sp-text-1_FN">    }</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> iter(1, 1);</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>We avoided doing this here so as to minimize the number of things to think about at once.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0027"></a><a href="#c1-fn-0027a">27</a> When we discuss the implementation of functions on register machines in chapter 5, we will see that any iterative process can be realized “in hardware” as a machine that has a fixed set of registers and no auxiliary memory. In contrast, realizing a recursive process requires a machine that uses an auxiliary data structure known as a <i>stack</i>.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0028"></a><a href="#c1-fn-0028a">28</a> Tail recursion has long been known as a compiler optimization trick. A coherent semantic basis for tail recursion was provided by Carl Hewitt (1977), who explained it in terms of the “message-passing” model of computation that we shall discuss in chapter 3. Inspired by this, Gerald Jay Sussman and Guy Lewis Steele Jr. (see Steele 1975) constructed a tail-recursive interpreter for Scheme. Steele later showed how tail recursion is a consequence of the natural way to compile function calls (Steele 1977). The IEEE standard for Scheme requires that Scheme implementations be tail-recursive. The ECMA standard for JavaScript eventually followed suit with ECMAScript 2015 (ECMA 2015). Note, however, that as of this writing (2021), most implementations of JavaScript do not comply with this standard with respect to tail recursion.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0029"></a><a href="#c1-fn-0029a">29</a> Exercise 4.7 explores JavaScript's while loops as syntactic sugar for functions that give rise to iterative processes. The full language JavaScript, like other conventional languages, features a plethora of syntactic forms, all of which can be expressed more uniformly in the language Lisp. This, together with the fact that these constructs typically involve semicolons whose placement rules are sometimes not obvious, led Alan Perlis to quip: “Syntactic sugar causes cancer of the semicolon.”</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0030"></a><a href="#c1-fn-0030a">30</a> An example of this was hinted at in section 1.1.3: The interpreter itself evaluates expressions using a tree-recursive process.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0031"></a><a href="#c1-fn-0031a">31</a> For example, work through in detail how the reduction rule applies to the problem of making change for 10 cents using pennies and nickels.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0032"></a><a href="#c1-fn-0032a">32</a> One approach to coping with redundant computations is to arrange matters so that we automatically construct a table of values as they are computed. Each time we are asked to apply the function to some argument, we first look to see if the value is already stored in the table, in which case we avoid performing the redundant computation. This strategy, known as <i>tabulation</i> or <i>memoization</i>, can be implemented in a straightforward way. Tabulation can sometimes be used to transform processes that require an exponential number of steps (such as <span class="KeyTerm1">count_change</span>) into processes whose space and time requirements grow linearly with the input. See exercise 3.27.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0033"></a><a href="#c1-fn-0033a">33</a> The elements of Pascal's triangle are called the <i>binomial coefficients</i>, because the <i>n</i>th row consists of the coefficients of the terms in the expansion of (<i>x</i> + <i>y</i>)<i><sup>n</sup></i>. This pattern for computing the coefficients appeared in Blaise Pascal's 1653 seminal work on probability theory, <i>Traité du triangle arithmétique</i>. According to Edwards (2019), the same pattern appears in the works of the eleventh-century Persian mathematician Al-Karaji, in the works of the twelfthcentury Hindu mathematician Bhaskara, and in the works of the thirteenth-century Chinese mathematician Yang Hui.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0034"></a><a href="#c1-fn-0034a">34</a> These statements mask a great deal of oversimplification. For instance, if we count process steps as “machine operations” we are making the assumption that the number of machine operations needed to perform, say, a multiplication is independent of the size of the numbers to be multiplied, which is false if the numbers are sufficiently large. Similar remarks hold for the estimates of space. Like the design and description of a process, the analysis of a process can be carried out at various levels of abstraction.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0035"></a><a href="#c1-fn-0035a">35</a> More precisely, the number of multiplications required is equal to 1 less than the log base 2 of <i>n</i>, plus the number of ones in the binary representation of <i>n</i>. This total is always less than twice the log base 2 of <i>n</i>. The arbitrary constants <i>k</i><sub>1</sub> and <i>k</i><sub>2</sub> in the definition of order notation imply that, for a logarithmic process, the base to which logarithms are taken does not matter, so all such processes are described as Θ(log <i>n</i>).</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0036"></a><a href="#c1-fn-0036a">36</a> You may wonder why anyone would care about raising numbers to the 1000th power. See section 1.2.6.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0037"></a><a href="#c1-fn-0037a">37</a> This iterative algorithm is ancient. It appears in the <i>Chandah-sutra</i> by Áchárya, written before 200 BCE. See Knuth 1997b, section 4.6.3, for a full discussion and analysis of this and other methods of exponentiation.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0038"></a><a href="#c1-fn-0038a">38</a> This algorithm, which is sometimes known as the “Russian peasant method” of multiplication, is ancient. Examples of its use are found in the Rhind Papyrus, one of the two oldest mathematical documents in existence, written about 1700 BCE (and copied from an even older document) by an Egyptian scribe named A’h-mose.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0039"></a><a href="#c1-fn-0039a">39</a> This exercise was suggested by Joe Stoy, based on an example in Kaldewaij 1990.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0040"></a><a href="#c1-fn-0040a">40</a> Euclid's Algorithm is so called because it appears in Euclid's <i>Elements</i> (Book 7, ca. 300 BCE). According to Knuth (1997a), it can be considered the oldest known nontrivial algorithm. The ancient Egyptian method of multiplication (exercise 1.18) is surely older, but, as Knuth explains, Euclid's Algorithm is the oldest known to have been presented as a general algorithm, rather than as a set of illustrative examples.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0041"></a><a href="#c1-fn-0041a">41</a> This theorem was proved in 1845 by Gabriel Lamé, a French mathematician and engineer known chiefly for his contributions to mathematical physics. To prove the theorem, we consider pairs (<i>a<sub>k</sub></i>, <i>b<sub>k</sub></i>), where <i>a<sub>k</sub> b<sub>k</sub></i>, for which Euclid's Algorithm terminates in <i>k</i> steps. The proof is based on the claim that, if (<i>a<sub>k</sub></i><sub>+1</sub>, <i>b<sub>k</sub></i><sub>+1</sub>) (<i>a<sub>k</sub></i>, <i>b<sub>k</sub></i>) (<i>a<sub>k</sub></i><sub>–1</sub>, <i>b<sub>k</sub></i><sub>–1</sub>) are three successive pairs in the reduction process, then we must have <i>b<sub>k</sub></i><sub>+1</sub> <i>b<sub>k</sub></i> + <i>b<sub>k</sub></i><sub>–1</sub>. To verify the claim, consider that a reduction step is defined by applying the transformation <i>a<sub>k</sub></i><sub>–1</sub> = <i>b<sub>k</sub></i>, <i>b<sub>k</sub></i><sub>–1</sub> = remainder of <i>a<sub>k</sub></i> divided by <i>b<sub>k</sub></i>. The second equation means that <i>a<sub>k</sub></i> = <i>qb<sub>k</sub></i> + <i>b<sub>k</sub></i><sub>–1</sub> for some positive integer <i>q</i>. And since <i>q</i> must be at least 1 we have <i>a<sub>k</sub></i> = <i>qb<sub>k</sub></i> + <i>b<sub>k</sub></i><sub>–1</sub> <i>b<sub>k</sub></i> + <i>b<sub>k</sub></i><sub>–1</sub>. But in the previous reduction step we have <i>b<sub>k</sub></i><sub>+1</sub> = <i>a<sub>k</sub></i>. Therefore, <i>b<sub>k</sub></i><sub>+1</sub> = <i>a<sub>k</sub> b<sub>k</sub></i> + <i>b<sub>k</sub></i><sub>–1</sub>. This verifies the claim. Now we can prove the theorem by induction on <i>k</i>, the number of steps that the algorithm requires to terminate. The result is true for <i>k</i> = 1, since this merely requires that <i>b</i> be at least as large as Fib(1) = 1. Now, assume that the result is true for all integers less than or equal to <i>k</i> and establish the result for <i>k</i> + 1. Let (<i>a<sub>k</sub></i><sub>+1</sub>, <i>b<sub>k</sub></i><sub>+1</sub>) (<i>a<sub>k</sub></i>, <i>b<sub>k</sub></i>) (<i>a<sub>k</sub></i><sub>–1</sub>, <i>b<sub>k</sub></i><sub>–1</sub>) be successive pairs in the reduction process. By our induction hypotheses, we have <i>b<sub>k</sub></i><sub>–1</sub> Fib(<i>k</i> – 1) and <i>b<sub>k</sub></i> Fib(<i>k</i>). Thus, applying the claim we just proved together with the definition of the Fibonacci numbers gives <i>b<sub>k</sub></i><sub>+1</sub> <i>b<sub>k</sub></i> + <i>b<sub>k</sub></i><sub>–1</sub> Fib(<i>k</i>) + Fib(<i>k</i> – 1) = Fib(<i>k</i> + 1), which completes the proof of Lamé's Theorem.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0042"></a><a href="#c1-fn-0042a">42</a> If <i>d</i> is a divisor of <i>n</i>, then so is <i>n</i>/<i>d</i>. But <i>d</i> and <i>n</i>/<i>d</i> cannot both be greater than <img alt="c1-fig-5012.jpg" src="../images/c1-fig-5012.jpg"/>.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0043"></a><a href="#c1-fn-0043a">43</a> Pierre de Fermat (1601–1665) is considered to be the founder of modern number theory. He obtained many important number-theoretic results, but he usually announced just the results, without providing his proofs. Fermat's Little Theorem was stated in a letter he wrote in 1640. The first published proof was given by Euler in 1736 (and an earlier, identical proof was discovered in the unpublished manuscripts of Leibniz). The most famous of Fermat's results—known as Fermat's Last Theorem—was jotted down in 1637 in his copy of the book <i>Arithmetic</i> (by the third-century Greek mathematician Diophantus) with the remark “I have discovered a truly remarkable proof, but this margin is too small to contain it.” Finding a proof of Fermat's Last Theorem became one of the most famous challenges in number theory. A complete solution was finally given in 1995 by Andrew Wiles of Princeton University.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0044"></a><a href="#c1-fn-0044a">44</a> The reduction steps in the cases where the exponent <i>e</i> is greater than 1 are based on the fact that, for any integers <i>x</i>, <i>y</i>, and <i>m</i>, we can find the remainder of <i>x</i> times <i>y</i> modulo <i>m</i> by computing separately the remainders of <i>x</i> modulo <i>m</i> and <i>y</i> modulo <i>m</i>, multiplying these, and then taking the remainder of the result modulo <i>m</i>. For instance, in the case where <i>e</i> is even, we compute the remainder of <i>b<sup>e</sup></i><sup>/2</sup> modulo <i>m</i>, square this, and take the remainder modulo <i>m</i>. This technique is useful because it means we can perform our computation without ever having to deal with numbers much larger than <i>m</i>. (Compare exercise 1.25.)</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0045"></a><a href="#c1-fn-0045a">45</a> Numbers that fool the Fermat test are called <i>Carmichael numbers</i>, and little is known about them other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000. The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the computer to make an error in carrying out a “correct” algorithm. Considering an algorithm to be inadequate for the first reason but not for the second illustrates the difference between mathematics and engineering.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0046"></a><a href="#c1-fn-0046a">46</a> One of the most striking applications of probabilistic prime testing has been to the field of cryptography. Although it is computationally infeasible to factor an arbitrary 300-digit number as of this writing (2021), the primality of such a number can be checked in a few seconds with the Fermat test. This fact forms the basis of a technique for constructing “unbreakable codes” suggested by Rivest, Shamir, and Adleman (1977). The resulting <i>RSA algorithm</i> has become a widely used technique for enhancing the security of electronic communications. Because of this and related developments, the study of prime numbers, once considered the epitome of a topic in “pure” mathematics to be studied only for its own sake, now turns out to have important practical applications to cryptography, electronic funds transfer, and information retrieval.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0047"></a><a href="#c1-fn-0047a">47</a> This date is called the <i>UNIX epoch</i> and is part of the specification of functions that deal with time in the UNIX<sup>TM</sup> operating system.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0048"></a><a href="#c1-fn-0048a">48</a> The primitive function <span class="KeyTerm1">display</span> returns its argument, but also prints it. Here <span class="KeyTerm1">" *** "</span> is a <i>string</i>, a sequence of characters that we pass as argument to the <span class="KeyTerm1">display</span> function. Section 2.3.1 introduces strings more thoroughly.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0049"></a><a href="#c1-fn-0049a">49</a> This series, usually written in the equivalent form <img alt="c1-fig-5015.jpg" src="../images/c1-fig-5015.jpg"/>, is due to Leibniz. We'll see how to use this as the basis for some fancy numerical tricks in section 3.5.3.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0050"></a><a href="#c1-fn-0050a">50</a> Notice that we have used block structure (section 1.1.8) to embed the declarations of <span class="KeyTerm1">pi_next</span> and <span class="KeyTerm1">pi_term</span> within <span class="KeyTerm1">pi_sum</span>, since these functions are unlikely to be useful for any other purpose. We will see how to get rid of them altogether in section 1.3.2.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0051"></a><a href="#c1-fn-0051a">51</a> The intent of exercises 1.31–1.33 is to demonstrate the expressive power that is attained by using an appropriate abstraction to consolidate many seemingly disparate operations. However, though accumulation and filtering are elegant ideas, our hands are somewhat tied in using them at this point since we do not yet have data structures to provide suitable means of combination for these abstractions. We will return to these ideas in section 2.2.3 when we show how to use <i>sequences</i> as interfaces for combining filters and accumulators to build even more powerful abstractions. We will see there how these methods really come into their own as a powerful and elegant approach to designing programs.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0052"></a><a href="#c1-fn-0052a">52</a> This formula was discovered by the seventeenth-century English mathematician John Wallis.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0053"></a><a href="#c1-fn-0053a">53</a> In section 2.2.4, we will extend the syntax of lambda expressions to allow a block as the body rather than just an expression, as in function declaration statements.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0054"></a><a href="#c1-fn-0054a">54</a> In JavaScript, there are subtle differences between the two versions: A function declaration statement is automatically “hoisted” (moved) to the beginning of the surrounding block or to the beginning of the program if it occurs outside of any block, whereas a constant declaration is not moved. Names declared with function declaration can be reassigned using assignment (section 3.1.1), whereas names declared with constant declarations can't. In this book, we avoid these features and treat a function declaration as equivalent to the corresponding constant declaration.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0055"></a><a href="#c1-fn-0055a">55</a> It would be clearer and less intimidating to people learning JavaScript if a term more obvious than <i>lambda expression</i>, such as <i>function definition</i>, were used. But the convention is very firmly entrenched, not just for Lisp and Scheme but also for JavaScript, Java and other languages, no doubt partly due to the influence of the Scheme editions of this book. The notation is adopted from the <i>λ</i> calculus, a mathematical formalism introduced by the mathematical logician Alonzo Church (1941). Church developed the <i>λ</i> calculus to provide a rigorous foundation for studying the notions of function and function application. The <i>λ</i> calculus has become a basic tool for mathematical investigations of the semantics of programming languages.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0056"></a><a href="#c1-fn-0056a">56</a> Note that a name declared in a block cannot be used before the declaration is fully evaluated, regardless of whether the same name is declared outside the block. Thus in the program below, the attempt to use the <span class="KeyTerm1">a</span> declared at the top level to provide a value for the calculation of the <span class="KeyTerm1">b</span> declared in <span class="KeyTerm1">f</span> cannot work.
<br/><span class="BS_Sp-text-1_FN"><b>const</b> a = 1;</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> f(x) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>const</b> b = a + x;</span>
<br/><span class="BS_Sp-text-1_FN"> <b>const</b> a = 5;</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> a + b;</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/><span class="BS_Sp-text-1_FN">f(10);</span>
<br/>The program leads to an error, because the <span class="KeyTerm1">a</span> in <span class="KeyTerm1">a + x</span> is used before its declaration is evaluated. We will return to this program in section 4.1.6 (exercise 4.19), after we learn more about evaluation.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0057"></a><a href="#c1-fn-0057a">57</a> The substitution model can be expanded to say that for a constant declaration, the value of the expression after <span class="KeyTerm1">=</span> is substituted for the name before <span class="KeyTerm1">=</span> in the rest of the block body (after the declaration), similar to the substitution of arguments for parameters in the evaluation of a function application.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0058"></a><a href="#c1-fn-0058a">58</a> We have used 0.001 as a representative “small” number to indicate a tolerance for the acceptable error in a calculation. The appropriate tolerance for a real calculation depends upon the problem to be solved and the limitations of the computer and the algorithm. This is often a very subtle consideration, requiring help from a numerical analyst or some other kind of magician.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0059"></a><a href="#c1-fn-0059a">59</a> This can be accomplished using <span class="KeyTerm1">error</span>, which takes as argument a string that is printed as error message along with the number of the program line that gave rise to the call of <span class="KeyTerm1">error</span>.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0060"></a><a href="#c1-fn-0060a">60</a> To obtain a fixed point of cosine on a calculator, set it to radians mode and then repeatedly press the cos button until the value does not change any longer.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0061"></a><a href="#c1-fn-0061a">61</a> <img alt="c1-fig-5022.jpg" src="../images/c1-fig-5022.jpg"/> (pronounced “maps to”) is the mathematician's way of writing lambda expressions. <i>y x</i>/<i>y</i> means <span class="KeyTerm1">y =&gt; x / y</span>, that is, the function whose value at <i>y</i> is <i>x</i>/<i>y</i>.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0062"></a><a href="#c1-fn-0062a">62</a> Observe that this is an application whose function expression is itself an application. Exercise 1.4 already demonstrated the ability to form such applications, but that was only a toy example. Here we begin to see the real need for such applications—when applying a function that is obtained as the value returned by a higher-order function.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0063"></a><a href="#c1-fn-0063a">63</a> See exercise 1.45 for a further generalization.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0064"></a><a href="#c1-fn-0064a">64</a> Elementary calculus books usually describe Newton's method in terms of the sequence of approximations <i>x<sub>n</sub></i><sub>+1</sub> = <i>x<sub>n</sub></i> – <i>g</i>(<i>x<sub>n</sub></i>)/<i>Dg</i>(<i>x<sub>n</sub></i>). Having language for talking about processes and using the idea of fixed points simplifies the description of the method.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0065"></a><a href="#c1-fn-0065a">65</a> Newton's method does not always converge to an answer, but it can be shown that in favorable cases each iteration doubles the number-of-digits accuracy of the approximation to the solution. In such cases, Newton's method will converge much more rapidly than the half-interval method.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0066"></a><a href="#c1-fn-0066a">66</a> For finding square roots, Newton's method converges rapidly to the correct solution from any starting point.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0067"></a><a href="#c1-fn-0067a">67</a> The notion of first-class status of programming-language elements is due to the British computer scientist Christopher Strachey (1916–1975).</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0068"></a><a href="#c1-fn-0068a">68</a> We'll see examples of this after we introduce data structures in chapter 2.</aside>
<aside class="noteEntry"><a id="c001_c1-fn-0069"></a><a href="#c1-fn-0069a">69</a> The major implementation cost of first-class functions is that allowing functions to be returned as values requires reserving storage for a function's free names even while the function is not executing. In the JavaScript implementation we will study in section 4.1, these names are stored in the function's environment.</aside>
</section>
</section>
</body><body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<h1><a id="c002_c2-title-0001"></a><span class="chapterNumber">2</span><br/><span class="chapterTitle">Building Abstractions with Data</span></h1>
</header>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c002_c2-para-0001"></a>We now come to the decisive step of mathematical abstraction: we forget about what the symbols stand for. . . .[The mathematician] need not be idle; there are many operations which he may carry out with these symbols, without ever having to look at the things they stand for.</p>
<p class="quote-epigraphsource">—Hermann Weyl, <i>The Mathematical Way of Thinking</i></p></blockquote>
<p class="paraaftertitle"><a id="c002_c2-para-0002"></a>We concentrated in chapter 1 on computational processes and on the role of functions in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine functions to form compound functions through composition, conditionals, and the use of parameters, and how to abstract processes by using function declarations. We saw that a function can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in functions. We also saw that higher-order functions enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming.</p>
<p><a id="c002_c2-para-0003"></a>In this chapter we are going to look at more complex data. All the functions in chapter 1 operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining functions to form compound functions, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form <i>compound data</i>.</p>
<p><a id="c002_c2-para-0004"></a>Why do we want compound data in a programming language? For the same reasons that we want compound functions: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to declare functions enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language.</p>
<p><a id="c002_c2-para-0005"></a>Consider the task of designing a system to perform arithmetic with rational numbers. We could imagine an operation <span class="KeyTerm1">add_rat</span> that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where <span class="KeyTerm1">add_rat</span> would be implemented by two functions (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could “glue together” a numerator and denominator to form a pair—a <i>compound data object</i>—that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit.</p>
<p><a id="c002_c2-para-0006"></a>The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called <i>data abstraction</i>. We will see how data abstraction makes programs much easier to design, maintain, and modify.</p>
<p><a id="c002_c2-para-0007"></a>The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a “linear combination” <i>ax</i> + <i>by</i>. We might like to write a function that would accept <i>a</i>, <i>b</i>, <i>x</i>, and <i>y</i> as arguments and return the value of <i>ax</i> + <i>by</i>. This presents no difficulty if the arguments are to be numbers, because we can readily declare the function</p>
<p class="Sp-text-1"><a id="c002_c2-para-0008"></a><b>function</b> linear_combination(a, b, x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0009"></a> <b>return</b> a * x + b * y;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0010"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0011"></a>But suppose we are not concerned only with numbers. Suppose we would like to describe a process that forms linear combinations whenever addition and multiplication are defined—for rational numbers, complex numbers, polynomials, or whatever. We could express this as a function of the form</p>
<p class="Sp-text-1"><a id="c002_c2-para-0013"></a><b>function</b> linear_combination(a, b, x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0014"></a> <b>return</b> add(mul(a, x), mul(b, y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0015"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0016"></a>where <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span> are not the primitive functions <span class="KeyTerm1">+</span> and <span class="KeyTerm1">*</span> but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments <span class="KeyTerm1">a</span>, <span class="KeyTerm1">b</span>, <span class="KeyTerm1">x</span>, and <span class="KeyTerm1">y</span>. The key point is that the only thing <span class="KeyTerm1">linear_combination</span> should need to know about <span class="KeyTerm1">a</span>, <span class="KeyTerm1">b</span>, <span class="KeyTerm1">x</span>, and <span class="KeyTerm1">y</span> is that the functions <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span> will perform the appropriate manipulations. From the perspective of the function <span class="KeyTerm1">linear_combination</span>, it is irrelevant what <span class="KeyTerm1">a</span>, <span class="KeyTerm1">b</span>, <span class="KeyTerm1">x</span>, and <span class="KeyTerm1">y</span> are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a function such as <span class="KeyTerm1">linear_combination</span> to pass its arguments along to <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span> without having to know their detailed structure.<a id="c002_c2-fn-0001a"></a><a href="#c2-fn-0001"><sup>1</sup></a></p>
<p><a id="c002_c2-para-0017"></a>We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound functions, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable <i>abstraction barriers</i> between different parts of a program.</p>
<p><a id="c002_c2-para-0018"></a>We will see that the key to forming compound data is that a programming language should provide some kind of “glue” so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special “data” operations at all, only functions. This will further blur the distinction between “function” and “data,” which was already becoming tenuous toward the end of chapter 1. We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of <i>closure</i>—that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as <i>conventional interfaces</i> for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure.</p>
<p><a id="c002_c2-para-0019"></a>We will then augment the representational power of our language by introducing <i>symbolic expressions</i>—data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information. Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement <i>generic operations</i>, which must handle many different types of data. Maintaining modularity in the presence of generic operations requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce <i>data-directed programming</i> as a technique that allows individual data representations to be designed in isolation and then combined <i>additively</i> (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials.</p>
<section><a id="c002_c2-title-0002"></a>
<section>
<h2><a id="c002_c2-sec-0002"></a><span>2.1</span> <a id="c002_c2-title-0003"></a>Introduction to Data Abstraction</h2>
<p class="paraaftertitle"><a id="c002_c2-para-0020"></a>In section 1.1.8, we noted that a function used as an element in creating a more complex function could be regarded not only as a collection of particular operations but also as a functional abstraction. That is, the details of how the function was implemented could be suppressed, and the particular function itself could be replaced by any other function with the same overall behavior. In other words, we could make an abstraction that would separate the way the function would be used from the details of how the function would be implemented in terms of more primitive functions. The analogous notion for compound data is called <i>data abstraction</i>. Data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed from more primitive data objects.</p>
<p><a id="c002_c2-para-0021"></a>The basic idea of data abstraction is to structure the programs that are to use compound data objects so that they operate on “abstract data.” That is, our programs should use data in such a way as to make no assumptions about the data that are not strictly necessary for performing the task at hand. At the same time, a “concrete” data representation is defined independent of the programs that use the data. The interface between these two parts of our system will be a set of functions, called <i>selectors</i> and <i>constructors</i>, that implement the abstract data in terms of the concrete representation. To illustrate this technique, we will consider how to design a set of functions for manipulating rational numbers.</p>
<section>
<h3><a id="c002_c2-sec-0003"></a><span>2.1.1</span> <a id="c002_c2-title-0004"></a>Example: Arithmetic Operations for Rational Numbers</h3>
<p class="paraaftertitle"><a id="c002_c2-para-0022"></a>Suppose we want to do arithmetic with rational numbers. We want to be able to add, subtract, multiply, and divide them and to test whether two rational numbers are equal.</p>
<p><a id="c002_c2-para-0023"></a>Let us begin by assuming that we already have a way of constructing a rational number from a numerator and a denominator. We also assume that, given a rational number, we have a way of extracting (or selecting) its numerator and its denominator. Let us further assume that the constructor and selectors are available as functions:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">make_rat(</span><i>n</i><span class="KeyTerm1">,</span> <i>d</i><span class="KeyTerm1">)</span> returns the rational number whose numerator is the integer <i>n</i> and whose denominator is the integer <i>d</i>.</li>
<li><span class="KeyTerm1">numer(</span><i>x</i><span class="KeyTerm1">)</span> returns the numerator of the rational number <i>x</i>.</li>
<li><span class="KeyTerm1">denom(</span><i>x</i><span class="KeyTerm1">)</span> returns the denominator of the rational number <i>x</i>.</li>
</ul>
<p><a id="c002_c2-para-0027"></a>We are using here a powerful strategy of synthesis: <i>wishful thinking</i>. We haven't yet said how a rational number is represented, or how the functions <span class="KeyTerm1">numer</span>, <span class="KeyTerm1">denom</span>, and <span class="KeyTerm1">make_rat</span> should be implemented. Even so, if we did have these three functions, we could then add, subtract, multiply, divide, and test equality by using the following relations:</p>
<p><a id="c002_c2-para-0028"></a></p>
<figure id="c002_c2-fig-0001"><img alt="c2-fig-5001.jpg" src="../images/c2-fig-5001.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p><a id="c002_c2-para-0029"></a>We can express these rules as functions:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0030"></a><b>function</b> add_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0031"></a> <b>return</b> make_rat(numer(x) * denom(y) + numer(y) * denom(x),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0032"></a>                    denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0033"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0034"></a><b>function</b> sub_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0035"></a> <b>return</b> make_rat(numer(x) * denom(y) - numer(y) * denom(x),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0036"></a>                    denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0037"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0038"></a><b>function</b> mul_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0039"></a> <b>return</b> make_rat(numer(x) * numer(y),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0040"></a>                    denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0041"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0042"></a><b>function</b> div_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0043"></a> <b>return</b> make_rat(numer(x) * denom(y),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0044"></a>                    denom(x) * numer(y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0045"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0046"></a><b>function</b> equal_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0047"></a> <b>return</b> numer(x) * denom(y) === numer(y) * denom(x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0048"></a>}</p>
<p><a id="c002_c2-para-0049"></a>Now we have the operations on rational numbers defined in terms of the selector</p>
<p class="paracontinue"><a id="c002_c2-para-0050"></a>and constructor functions <span class="KeyTerm1">numer</span>, <span class="KeyTerm1">denom</span>, and <span class="KeyTerm1">make_rat</span>. But we haven't yet defined these. What we need is some way to glue together a numerator and a denominator to form a rational number.</p>
<section>
<h5><a id="c002_c2-sec-0004"></a><a id="c002_c2-title-0005"></a>Pairs</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0051"></a>To enable us to implement the concrete level of our data abstraction, our JavaScript environment provides a compound structure called a <i>pair</i>, which can be constructed with the primitive function <span class="KeyTerm1">pair</span>. This function takes two arguments and returns a compound data object that contains the two arguments as parts. Given a pair, we can extract the parts using the primitive functions <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span>. Thus, we can use <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> as follows:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0052"></a><b>const</b> x = pair(1, 2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0053"></a>head(x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0054"></a><i>1</i></p>
<p class="Sp-text-1"><a id="c002_c2-para-0055"></a>tail(x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0056"></a><i>2</i></p>
<p><a id="c002_c2-para-0057"></a>Notice that a pair is a data object that can be given a name and manipulated, just like a primitive data object. Moreover, <span class="KeyTerm1">pair</span> can be used to form pairs whose elements are pairs, and so on:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0058"></a><b>const</b> x = pair(1, 2);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0059"></a><b>const</b> y = pair(3, 4);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0060"></a><b>const</b> z = pair(x, y);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0061"></a>head(head(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0062"></a><i>1</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0063"></a>head(tail(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0064"></a><i>3</i></p>
<p class="paracontinue"><a id="c002_c2-para-0065"></a>In section 2.2 we will see how this ability to combine pairs means that pairs can be used as general-purpose building blocks to create all sorts of complex data structures. The single compound-data primitive <i>pair</i>, implemented by the functions <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>, is the only glue we need. Data objects constructed from pairs are called <i>list-structured</i> data.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0005"></a><a id="c002_c2-title-0006"></a>Representing rational numbers</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0066"></a>Pairs offer a natural way to complete the rational-number system. Simply represent a rational number as a pair of two integers: a numerator and a denominator. Then <span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, and <span class="KeyTerm1">denom</span> are readily implemented as follows:<a id="c002_c2-fn-0002a"></a><a href="#c2-fn-0002"><sup>2</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0067"></a><b>function</b> make_rat(n, d) { <b>return</b> pair(n, d); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0068"></a><b>function</b> numer(x) { <b>return</b> head(x); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0069"></a><b>function</b> denom(x) { <b>return</b> tail(x); }</p>
<p class="paracontinue"><a id="c002_c2-para-0073"></a>Also, in order to display the results of our computations, we can print rational numbers by printing the numerator, a slash, and the denominator. We use the primitive function <span class="KeyTerm1">stringify</span> to turn any value (here a number) into a string. The operator <span class="KeyTerm1">+</span> in JavaScript is <i>overloaded</i>; it can be applied to two numbers or to two strings, and in the latter case it returns the result of <i>concatenating</i> the two strings.<a id="c002_c2-fn-0003a"></a><a href="#c2-fn-0003"><sup>3</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0074"></a><b>function</b> print_rat(x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0075"></a> <b>return</b> display(stringify(numer(x)) + " / " + stringify(denom(x)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0076"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0077"></a>Now we can try our rational-number functions:<a id="c002_c2-fn-0004a"></a><a href="#c2-fn-0004"><sup>4</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0078"></a><b>const</b> one_half = make_rat(1, 2);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0079"></a>print_rat(one_half);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0080"></a><i>"1 / 2"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0081"></a><b>const</b> one_third = make_rat(1, 3);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0082"></a>print_rat(add_rat(one_half, one_third));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0083"></a><i>"5 / 6"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0084"></a>print_rat(mul_rat(one_half, one_third));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0085"></a><i>"1 / 6"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0086"></a>print_rat(add_rat(one_third, one_third));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0087"></a><i>"6 / 9"</i></p>
<p><a id="c002_c2-para-0088"></a>As the final example shows, our rational-number implementation does not reduce rational numbers to lowest terms. We can remedy this by changing <span class="KeyTerm1">make_rat</span>. If we have a <span class="KeyTerm1">gcd</span> function like the one in section 1.2.5 that produces the greatest common divisor of two integers, we can use <span class="KeyTerm1">gcd</span> to reduce the numerator and the denominator to lowest terms before constructing the pair:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0089"></a><b>function</b> make_rat(n, d) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0090"></a> <b>const</b> g = gcd(n, d);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0091"></a> <b>return</b> pair(n / g, d / g);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0092"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0093"></a>Now we have</p>
<p class="Sp-text-1"><a id="c002_c2-para-0094"></a>print_rat(add_rat(one_third, one_third));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0095"></a><i>"2 / 3"</i></p>
<p class="paracontinue"><a id="c002_c2-para-0096"></a>as desired. This modification was accomplished by changing the constructor <span class="KeyTerm1">make_ rat</span> without changing any of the functions (such as <span class="KeyTerm1">add_rat</span> and <span class="KeyTerm1">mul_rat</span>) that implement the actual operations.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0006"></a><a id="c002_c2-title-0007"></a>Exercise 2.1</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0097"></a>Define a better version of <span class="KeyTerm1">make_rat</span> that handles both positive and negative arguments. The function <span class="KeyTerm1">make_rat</span> should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.</p>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0007"></a><span>2.1.2</span> <a id="c002_c2-title-0008"></a>Abstraction Barriers</h3>
<p class="paraaftertitle"><a id="c002_c2-para-0098"></a>Before continuing with more examples of compound data and data abstraction, let us consider some of the issues raised by the rational-number example. We defined the rational-number operations in terms of a constructor <span class="KeyTerm1">make_rat</span> and selectors <span class="KeyTerm1">numer</span> and <span class="KeyTerm1">denom</span>. In general, the underlying idea of data abstraction is to identify for each type of data object a basic set of operations in terms of which all manipulations of data objects of that type will be expressed, and then to use only those operations in manipulating the data.</p>
<p><a id="c002_c2-para-0099"></a>We can envision the structure of the rational-number system as shown in <a id="c002_c2-fig-0002a"></a><a href="#c2-fig-0002">figure 2.1</a>. The horizontal lines represent <i>abstraction barriers</i> that isolate different “levels” of the system. At each level, the barrier separates the programs (above) that use the data abstraction from the programs (below) that implement the data abstraction. Programs that use rational numbers manipulate them solely in terms of the functions supplied “for public use” by the rational-number package: <span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">sub_rat</span>, <span class="KeyTerm1">mul_rat</span>, <span class="KeyTerm1">div_rat</span>, and <span class="KeyTerm1">equal_rat</span>. These, in turn, are implemented solely in terms of the constructor and selectors <span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, and <span class="KeyTerm1">denom</span>, which themselves are implemented in terms of pairs. The details of how pairs are implemented are irrelevant to the rest of the rational-number package so long as pairs can be manipulated by the use of <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>. In effect, functions at each level are the interfaces that define the abstraction barriers and connect the different levels. This simple idea has many advantages. One advantage is that it makes programs much easier to maintain and to modify. Any complex data structure can be represented in a variety of ways with the primitive data structures provided by a programming language. Of course, the choice of representation influences the programs that operate on it; thus, if the representation were to be changed at some later time, all such programs might have to be modified accordingly. This task could be time-consuming and expensive in the case of large programs unless the dependence on the representation were to be confined by design to a very few program modules.</p>
<figure id="c002_c2-fig-0002"><img alt="c2-fig-0001.jpg" src="../images/c2-fig-0001.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0002a">Figure 2.1</a></span> <a id="c002_c2-para-0100"></a>Data-abstraction barriers in the rational-number package.</p></figcaption></figure>
<p><a id="c002_c2-para-0101"></a>For example, an alternate way to address the problem of reducing rational numbers to lowest terms is to perform the reduction whenever we access the parts of a rational number, rather than when we construct it. This leads to different constructor and selector functions:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0102"></a><b>function</b> make_rat(n, d) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0103"></a> <b>return</b> pair(n, d);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0104"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0105"></a><b>function</b> numer(x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0106"></a> <b>const</b> g = gcd(head(x), tail(x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0107"></a> <b>return</b> head(x) / g;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0108"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0109"></a><b>function</b> denom(x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0110"></a> <b>const</b> g = gcd(head(x), tail(x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0111"></a> <b>return</b> tail(x) / g;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0112"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0113"></a>The difference between this implementation and the previous one lies in when we compute the <span class="KeyTerm1">gcd</span>. If in our typical use of rational numbers we access the numerators and denominators of the same rational numbers many times, it would be preferable to compute the <span class="KeyTerm1">gcd</span> when the rational numbers are constructed. If not, we may be better off waiting until access time to compute the <span class="KeyTerm1">gcd</span>. In any case, when we change from one representation to the other, the functions <span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">sub_rat</span>, and so on do not have to be modified at all.</p>
<p><a id="c002_c2-para-0114"></a>Constraining the dependence on the representation to a few interface functions helps us design programs as well as modify them, because it allows us to maintain the flexibility to consider alternate implementations. To continue with our simple example, suppose we are designing a rational-number package and we can't decide initially whether to perform the <span class="KeyTerm1">gcd</span> at construction time or at selection time. The data-abstraction methodology gives us a way to defer that decision without losing the ability to make progress on the rest of the system.</p>
<section>
<h5><a id="c002_c2-sec-0008"></a><a id="c002_c2-title-0009"></a>Exercise 2.2</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0115"></a>Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Declare a constructor <span class="KeyTerm1">make_segment</span> and selectors <span class="KeyTerm1">start_segment</span> and <span class="KeyTerm1">end_segment</span> that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the <i>x</i> coordinate and the <i>y</i> coordinate. Accordingly, specify a constructor <span class="KeyTerm1">make_point</span> and selectors <span class="KeyTerm1">x_point</span> and <span class="KeyTerm1">y_point</span> that define this representation. Finally, using your selectors and constructors, declare a function <span class="KeyTerm1">midpoint_segment</span> that takes a line segment as argument and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your functions, you'll need a way to print points:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0116"></a><b>function</b> print_point(p) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0117"></a> <b>return</b> display("(" + stringify(x_point(p)) + ", "</p>
<p class="Sp-text-1"><a id="c002_c2-para-0118"></a>                       + stringify(y_point(p)) + ")");</p>
<p class="Sp-text-1"><a id="c002_c2-para-0119"></a>}</p>
</section>
<section>
<h5><a id="c002_c2-sec-0009"></a><a id="c002_c2-title-0010"></a>Exercise 2.3</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0120"></a>Implement a representation for rectangles in a plane. (Hint: You may want to make use of exercise 2.2.) In terms of your constructors and selectors, create functions that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area functions will work using either representation?</p>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0010"></a><span>2.1.3</span> <a id="c002_c2-title-0011"></a>What Is Meant by Data?</h3>
<p class="paraaftertitle"><a id="c002_c2-para-0121"></a>We began the rational-number implementation in section 2.1.1 by implementing the rational-number operations <span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">sub_rat</span>, and so on in terms of three unspecified functions: <span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, and <span class="KeyTerm1">denom</span>. At that point, we could think of the operations as being defined in terms of data objects—numerators, denominators, and rational numbers—whose behavior was specified by the latter three functions.</p>
<p><a id="c002_c2-para-0122"></a>But exactly what is meant by <i>data</i>? It is not enough to say “whatever is implemented by the given selectors and constructors.” Clearly, not every arbitrary set of three functions can serve as an appropriate basis for the rational-number implementation. We need to guarantee that, if we construct a rational number <span class="KeyTerm1">x</span> from a pair of integers <span class="KeyTerm1">n</span> and <span class="KeyTerm1">d</span>, then extracting the <span class="KeyTerm1">numer</span> and the <span class="KeyTerm1">denom</span> of <span class="KeyTerm1">x</span> and dividing them should yield the same result as dividing <span class="KeyTerm1">n</span> by <span class="KeyTerm1">d</span>. In other words, <span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, and <span class="KeyTerm1">denom</span> must satisfy the condition that, for any integer <span class="KeyTerm1">n</span> and any nonzero integer <span class="KeyTerm1">d</span>, if <span class="KeyTerm1">x</span> is <span class="KeyTerm1">make_rat(n, d)</span>, then</p>
<p><a id="c002_c2-para-0123"></a></p>
<figure id="c002_c2-fig-0003"><img alt="c2-fig-5002.jpg" src="../images/c2-fig-5002.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-0124"></a>In fact, this is the only condition <span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, and <span class="KeyTerm1">denom</span> must fulfill in order to form a suitable basis for a rational-number representation. In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these functions must fulfill in order to be a valid representation.<a id="c002_c2-fn-0005a"></a><a href="#c2-fn-0005"><sup>5</sup></a></p>
<p><a id="c002_c2-para-0125"></a>This point of view can serve to define not only “high-level” data objects, such as rational numbers, but lower-level objects as well. Consider the notion of a pair, which we used in order to define our rational numbers. We never actually said what a pair was, only that the language supplied functions <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> for operating on pairs. But the only thing we need to know about these three operations is that if we glue two objects together using <span class="KeyTerm1">pair</span> we can retrieve the objects using <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span>. That is, the operations satisfy the condition that, for any objects <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span>, if <span class="KeyTerm1">z</span> is <span class="KeyTerm1">pair(x, y)</span> then <span class="KeyTerm1">head(z)</span> is <span class="KeyTerm1">x</span> and <span class="KeyTerm1">tail(z)</span> is <span class="KeyTerm1">y</span>. Indeed, we mentioned that these three functions are included as primitives in our language. However, any triple of functions that satisfies the above condition can be used as the basis for implementing pairs. This point is illustrated strikingly by the fact that we could implement <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> without using any data structures at all but only using functions. Here are the definitions:<a id="c002_c2-fn-0006a"></a><a href="#c2-fn-0006"><sup>6</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0126"></a><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0127"></a> <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0128"></a> <b>return</b> m === 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-0129"></a>               ? x</p>
<p class="Sp-text-1"><a id="c002_c2-para-0130"></a>               : m === 1</p>
<p class="Sp-text-1"><a id="c002_c2-para-0131"></a>               ? y</p>
<p class="Sp-text-1"><a id="c002_c2-para-0132"></a>               : error(m, "argument not 0 or 1 – pair");</p>
<p class="Sp-text-1"><a id="c002_c2-para-0133"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0134"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0135"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0136"></a><b>function</b> head(z) { <b>return</b> z(0); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0137"></a><b>function</b> tail(z) { <b>return</b> z(1); }</p>
<p class="paracontinue"><a id="c002_c2-para-0138"></a>This use of functions corresponds to nothing like our intuitive notion of what data should be. Nevertheless, all we need to do to show that this is a valid way to represent pairs is to verify that these functions satisfy the condition given above.</p>
<p><a id="c002_c2-para-0139"></a>The subtle point to notice is that the value returned by <span class="KeyTerm1">pair(x, y)</span> is a function—namely the internally defined function <span class="KeyTerm1">dispatch</span>, which takes one argument and returns either <span class="KeyTerm1">x</span> or <span class="KeyTerm1">y</span> depending on whether the argument is 0 or 1. Correspondingly, <span class="KeyTerm1">head(z)</span> is defined to apply <span class="KeyTerm1">z</span> to 0. Hence, if <span class="KeyTerm1">z</span> is the function formed by <span class="KeyTerm1">pair(x, y)</span>, then <span class="KeyTerm1">z</span> applied to 0 will yield <span class="KeyTerm1">x</span>. Thus, we have shown that <span class="KeyTerm1">head(pair(x, y))</span> yields <span class="KeyTerm1">x</span>, as desired. Similarly, <span class="KeyTerm1">tail(pair(x, y))</span> applies the function returned by <span class="KeyTerm1">pair(x, y)</span> to 1, which returns <span class="KeyTerm1">y</span>. Therefore, this functional implementation of pairs is a valid implementation, and if we access pairs using only <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> we cannot distinguish this implementation from one that uses “real” data structures.</p>
<p><a id="c002_c2-para-0141"></a>The point of exhibiting the functional representation of pairs is not that our language works this way (an efficient implementation of pairs might use JavaScript's primitive <i>vector</i> data structure) but that it could work this way. The functional representation, although obscure, is a perfectly adequate way to represent pairs, since it fulfills the only conditions that pairs need to fulfill. This example also demonstrates that the ability to manipulate functions as objects automatically provides the ability to represent compound data. This may seem a curiosity now, but functional representations of data will play a central role in our programming repertoire. This style of programming is often called <i>message passing</i>, and we will be using it as a basic tool in chapter 3 when we address the issues of modeling and simulation.</p>
<section>
<h5><a id="c002_c2-sec-0011"></a><a id="c002_c2-title-0012"></a>Exercise 2.4</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0142"></a>Here is an alternative functional representation of pairs. For this representation, verify that <span class="KeyTerm1">head(pair(x, y))</span> yields <span class="KeyTerm1">x</span> for any objects <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span>.</p>
<p class="Sp-text-1"><a id="c002_c2-para-0143"></a><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0144"></a> <b>return</b> m =&gt; m(x, y);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0145"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0146"></a><b>function</b> head(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0147"></a> <b>return</b> z((p, q) =&gt; p);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0148"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0149"></a>What is the corresponding definition of <span class="KeyTerm1">tail</span>? (Hint: To verify that this works, make use of the substitution model of section 1.1.5.)</p>
</section>
<section>
<h5><a id="c002_c2-sec-0012"></a><a id="c002_c2-title-0013"></a>Exercise 2.5</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0150"></a>Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair <i>a</i> and <i>b</i> as the integer that is the product 2<i><sup>a</sup></i>3<i><sup>b</sup></i>. Give the corresponding definitions of the functions <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0013"></a><a id="c002_c2-title-0014"></a>Exercise 2.6</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0151"></a>In case representing pairs as functions (exercise 2.4) wasn't mind-boggling enough, consider that, in a language that can manipulate functions, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as</p>
<p class="Sp-text-1"><a id="c002_c2-para-0152"></a><b>const</b> zero = f =&gt; x =&gt; x;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0153"></a><b>function</b> add_1(n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0154"></a> <b>return</b> f =&gt; x =&gt; f(n(f)(x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0155"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0156"></a>This representation is known as <i>Church numerals</i>, after its inventor, Alonzo Church, the logician who invented the <i>λ</i> calculus.</p>
<p><a id="c002_c2-para-0157"></a>Define <span class="KeyTerm1">one</span> and <span class="KeyTerm1">two</span> directly (not in terms of <span class="KeyTerm1">zero</span> and <span class="KeyTerm1">add_1</span>). (Hint: Use substitution to evaluate <span class="KeyTerm1">add_1(zero)</span>). Give a direct definition of the addition function <span class="KeyTerm1">plus</span> (not in terms of repeated application of <span class="KeyTerm1">add_1</span>).</p>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0014"></a><span>2.1.4</span> <a id="c002_c2-title-0015"></a>Extended Exercise: Interval Arithmetic</h3>
<p class="paraaftertitle"><a id="c002_c2-para-0158"></a>Alyssa P. Hacker is designing a system to help people solve engineering problems. One feature she wants to provide in her system is the ability to manipulate inexact quantities (such as measured parameters of physical devices) with known precision, so that when computations are done with such approximate quantities the results will be numbers of known precision.</p>
<p><a id="c002_c2-para-0159"></a>Electrical engineers will be using Alyssa's system to compute electrical quantities. It is sometimes necessary for them to compute the value of a parallel equivalent resistance <i>R<sub>p</sub></i> of two resistors <i>R</i><sub>1</sub> and <i>R</i><sub>2</sub> using the formula</p>
<p><a id="c002_c2-para-0160"></a></p>
<figure id="c002_c2-fig-0004"><img alt="c2-fig-5003.jpg" src="../images/c2-fig-5003.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-0161"></a>Resistance values are usually known only up to some tolerance guaranteed by the manufacturer of the resistor. For example, if you buy a resistor labeled “6.8 ohms with 10% tolerance” you can only be sure that the resistor has a resistance between 6.8 – 0.68 = 6.12 and 6.8 + 0.68 = 7.48 ohms. Thus, if you have a 6.8-ohm 10% resistor in parallel with a 4.7-ohm 5% resistor, the resistance of the combination can range from about 2.58 ohms (if the two resistors are at the lower bounds) to about 2.97 ohms (if the two resistors are at the upper bounds).</p>
<p><a id="c002_c2-para-0162"></a>Alyssa's idea is to implement “interval arithmetic” as a set of arithmetic operations for combining “intervals” (objects that represent the range of possible values of an inexact quantity). The result of adding, subtracting, multiplying, or dividing two intervals is itself an interval, representing the range of the result.</p>
<p><a id="c002_c2-para-0163"></a>Alyssa postulates the existence of an abstract object called an “interval” that has two endpoints: a lower bound and an upper bound. She also presumes that, given the endpoints of an interval, she can construct the interval using the data constructor <span class="KeyTerm1">make_interval</span>. Alyssa first writes a function for adding two intervals. She reasons that the minimum value the sum could be is the sum of the two lower bounds and the maximum value it could be is the sum of the two upper bounds:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0164"></a><b>function</b> add_interval(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0165"></a> <b>return</b> make_interval(lower_bound(x) + lower_bound(y),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0166"></a>                         upper_bound(x) + upper_bound(y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0167"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0168"></a>Alyssa also works out the product of two intervals by finding the minimum and the maximum of the products of the bounds and using them as the bounds of the resulting interval. (The functions <span class="KeyTerm1">math_min</span> and <span class="KeyTerm1">math_max</span> are primitives that find the minimum or maximum of any number of arguments.)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0169"></a><b>function</b> mul_interval(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0170"></a> <b>const</b> p1 = lower_bound(x) * lower_bound(y); </p>
<p class="Sp-text-1"><a id="c002_c2-para-0171"></a> <b>const</b> p2 = lower_bound(x) * upper_bound(y);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0172"></a> <b>const</b> p3 = upper_bound(x) * lower_bound(y);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0173"></a> <b>const</b> p4 = upper_bound(x) * upper_bound(y);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0174"></a> <b>return</b> make_interval(math_min(p1, p2, p3, p4),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0175"></a>                         math_max(p1, p2, p3, p4));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0176"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0177"></a>To divide two intervals, Alyssa multiplies the first by the reciprocal of the second. Note that the bounds of the reciprocal interval are the reciprocal of the upper bound and the reciprocal of the lower bound, in that order.</p>
<p class="Sp-text-1"><a id="c002_c2-para-0178"></a><b>function</b> div_interval(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0179"></a> <b>return</b> mul_interval(x, make_interval(1 / upper_bound(y),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0180"></a>                                         1 / lower_bound(y)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0181"></a>}</p>
<section>
<h5><a id="c002_c2-sec-0015"></a><a id="c002_c2-title-0016"></a>Exercise 2.7</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0182"></a>Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0183"></a><b>function</b> make_interval(x, y) { <b>return</b> pair(x, y); }</p>
<p class="paracontinue"><a id="c002_c2-para-0184"></a>Define selectors <span class="KeyTerm1">upper_bound</span> and <span class="KeyTerm1">lower_bound</span> to complete the implementation.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0016"></a><a id="c002_c2-title-0017"></a>Exercise 2.8</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0185"></a>Using reasoning analogous to Alyssa's, describe how the difference of two intervals may be computed. Define a corresponding subtraction function, called <span class="KeyTerm1">sub_interval</span>.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0017"></a><a id="c002_c2-title-0018"></a>Exercise 2.9</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0186"></a>The <i>width</i> of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0018"></a><a id="c002_c2-title-0019"></a>Exercise 2.10</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0187"></a>Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Modify Alyssa's program to check for this condition and to signal an error if it occurs.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0019"></a><a id="c002_c2-title-0020"></a>Exercise 2.11</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0188"></a>In passing, Ben also cryptically comments: “By testing the signs of the endpoints of the intervals, it is possible to break <span class="KeyTerm1">mul_interval</span> into nine cases, only one of which requires more than two multiplications.” Rewrite this function using Ben's suggestion.</p>
<p><a id="c002_c2-para-0189"></a>After debugging her program, Alyssa shows it to a potential user, who complains that her program solves the wrong problem. He wants a program that can deal with numbers represented as a center value and an additive tolerance; for example, he wants to work with intervals such as 3.5 ± 0.15 rather than [3.35, 3.65]. Alyssa returns to her desk and fixes this problem by supplying an alternate constructor and alternate selectors:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0190"></a><b>function</b> make_center_width(c, w) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0191"></a> <b>return</b> make_interval(c - w, c + w);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0192"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0193"></a><b>function</b> center(i) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0194"></a> <b>return</b> (lower_bound(i) + upper_bound(i)) / 2;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0195"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0196"></a><b>function</b> width(i) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0197"></a> <b>return</b> (upper_bound(i) - lower_bound(i)) / 2;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0198"></a>}</p>
<p><a id="c002_c2-para-0199"></a>Unfortunately, most of Alyssa's users are engineers. Real engineering situations usually involve measurements with only a small uncertainty, measured as the ratio of the width of the interval to the midpoint of the interval. Engineers usually specify percentage tolerances on the parameters of devices, as in the resistor specifications given earlier.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0020"></a><a id="c002_c2-title-0021"></a>Exercise 2.12</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0200"></a>Define a constructor <span class="KeyTerm1">make_center_percent</span> that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector <span class="KeyTerm1">percent</span> that produces the percentage tolerance for a given interval. The <span class="KeyTerm1">center</span> selector is the same as the one shown above.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0021"></a><a id="c002_c2-title-0022"></a>Exercise 2.13</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0201"></a>Show that under the assumption of small percentage tolerances there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.</p>
<p><a id="c002_c2-para-0202"></a>After considerable work, Alyssa P. Hacker delivers her finished system. Several years later, after she has forgotten all about it, she gets a frenzied call from an irate user, Lem E. Tweakit. It seems that Lem has noticed that the formula for parallel resistors can be written in two algebraically equivalent ways:</p>
<p><a id="c002_c2-para-0203"></a></p>
<figure id="c002_c2-fig-0005"><img alt="c2-fig-5004.jpg" src="../images/c2-fig-5004.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-0204"></a>and</p>
<p><a id="c002_c2-para-0205"></a></p>
<figure id="c002_c2-fig-0006"><img alt="c2-fig-5005.jpg" src="../images/c2-fig-5005.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-0206"></a>He has written the following two programs, each of which computes the parallelresistors formula differently:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0207"></a><b>function</b> par1(r1, r2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0208"></a> <b>return</b> div_interval(mul_interval(r1, r2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0209"></a>                        add_interval(r1, r2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0210"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0211"></a><b>function</b> par2(r1, r2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0212"></a> <b>const</b> one = make_interval(1, 1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0213"></a> <b>return</b> div_interval(one,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0214"></a>                        add_interval(div_interval(one, r1),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0215"></a>                                     div_interval(one, r2)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0216"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0217"></a>Lem complains that Alyssa's program gives different answers for the two ways of computing. This is a serious complaint.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0022"></a><a id="c002_c2-title-0023"></a>Exercise 2.14</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0218"></a>Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals <i>A</i> and <i>B</i>, and use them in computing the expressions <i>A</i>/<i>A</i> and <i>A</i>/<i>B</i>. You will get the most insight by using intervals whose width is a small percentage of the center value. Examine the results of the computation in center-percent form (see exercise 2.12).</p>
</section>
<section>
<h5><a id="c002_c2-sec-0023"></a><a id="c002_c2-title-0024"></a>Exercise 2.15</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0219"></a>Eva Lu Ator, another user, has also noticed the different intervals computed by different but algebraically equivalent expressions. She says that a formula to compute with intervals using Alyssa's system will produce tighter error bounds if it can be written in such a form that no name that represents an uncertain number is repeated. Thus, she says, <span class="KeyTerm1">par2</span> is a “better” program for parallel resistances than <span class="KeyTerm1">par1</span>. Is she right? Why?</p>
</section>
<section>
<h5><a id="c002_c2-sec-0024"></a><a id="c002_c2-title-0025"></a>Exercise 2.16</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0220"></a>Explain, in general, why equivalent algebraic expressions may lead to different answers. Can you devise an interval-arithmetic package that does not have this shortcoming, or is this task impossible? (Warning: This problem is very difficult.)</p>
</section>
</section>
</section>
<section>
<h2><a id="c002_c2-sec-0025"></a><span>2.2</span> <a id="c002_c2-title-0026"></a>Hierarchical Data and the Closure Property</h2>
<p class="paraaftertitle"><a id="c002_c2-para-0221"></a>As we have seen, pairs provide a primitive “glue” that we can use to construct compound data objects. <a id="c002_c2-fig-0007a"></a><a href="#c2-fig-0007">Figure 2.2</a> shows a standard way to visualize a pair—in this case, the pair formed by <span class="KeyTerm1">pair(1, 2)</span>. In this representation, which is called <i>box-and-pointer notation</i>, each compound object is shown as a <i>pointer</i> to a box. The box for a pair has two parts, the left part containing the head of the pair and the right part containing the tail.</p>
<figure id="c002_c2-fig-0007"><img alt="c2-fig-0002.jpg" src="../images/c2-fig-0002.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0007a">Figure 2.2</a></span> <a id="c002_c2-para-0222"></a>Box-and-pointer representation of <span class="KeyTerm1">pair(1, 2)</span>.</p></figcaption></figure>
<p><a id="c002_c2-para-0223"></a>We have already seen that <span class="KeyTerm1">pair</span> can be used to combine not only numbers but pairs as well. (You made use of this fact, or should have, in doing exercises 2.2 and 2.3.) As a consequence, pairs provide a universal building block from which we can construct all sorts of data structures. <a id="c002_c2-fig-0008a"></a><a href="#c2-fig-0008">Figure 2.3</a> shows two ways to use pairs to combine the numbers 1, 2, 3, and 4.</p>
<figure id="c002_c2-fig-0008"><img alt="c2-fig-0003.jpg" src="../images/c2-fig-0003.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0008a">Figure 2.3</a></span> <a id="c002_c2-para-0224"></a>Two ways to combine 1, 2, 3, and 4 using pairs.</p></figcaption></figure>
<p><a id="c002_c2-para-0225"></a>The ability to create pairs whose elements are pairs is the essence of list structure's importance as a representational tool. We refer to this ability as the <i>closure property</i> of <span class="KeyTerm1">pair</span>. In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.<a id="c002_c2-fn-0007a"></a><a href="#c2-fn-0007"><sup>7</sup></a> Closure is the key to power in any means of combination because it permits us to create <i>hierarchical</i> structures—structures made up of parts, which themselves are made up of parts, and so on.</p>
<p><a id="c002_c2-para-0226"></a>From the outset of chapter 1, we've made essential use of closure in dealing with functions, because all but the very simplest programs rely on the fact that the elements of a combination can themselves be combinations. In this section, we take up the consequences of closure for compound data. We describe some conventional techniques for using pairs to represent sequences and trees, and we exhibit a graphics language that illustrates closure in a vivid way.</p>
<section>
<h3><a id="c002_c2-sec-0026"></a><span>2.2.1</span> <a id="c002_c2-title-0027"></a>Representing Sequences</h3>
<p class="paraaftertitle"><a id="c002_c2-para-0227"></a>One of the useful structures we can build with pairs is a <i>sequence</i>—an ordered collection of data objects. There are, of course, many ways to represent sequences in terms of pairs. One particularly straightforward representation is illustrated in <a id="c002_c2-fig-0009a"></a><a href="#c2-fig-0009">figure 2.4</a>, where the sequence 1, 2, 3, 4 is represented as a chain of pairs. The <span class="KeyTerm1">head</span> of each pair is the corresponding item in the chain, and the <span class="KeyTerm1">tail</span> of the pair is the next pair in the chain. The <span class="KeyTerm1">tail</span> of the final pair signals the end of the sequence, represented in box-and-pointer diagrams as a diagonal line and in programs as JavaScript's primitive value <span class="KeyTerm1"><b>null</b></span>. The entire sequence is constructed by nested <span class="KeyTerm1">pair</span> operations:</p>
<figure id="c002_c2-fig-0009"><img alt="c2-fig-0004.jpg" src="../images/c2-fig-0004.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0009a">Figure 2.4</a></span> <a id="c002_c2-para-0228"></a>The sequence 1, 2, 3, 4 represented as a chain of pairs.</p></figcaption></figure>
<p class="Sp-text-1"><a id="c002_c2-para-0229"></a>pair(1,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0230"></a>     pair(2,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0231"></a>          pair(3,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0232"></a>               pair(4, <b>null</b>))));</p>
<p><a id="c002_c2-para-0233"></a>Such a sequence of pairs, formed by nested <span class="KeyTerm1">pair</span> applications, is called a <i>list</i>, and our JavaScript environment provides a primitive called <span class="KeyTerm1">list</span> to help in constructing lists.<a id="c002_c2-fn-0008a"></a><a href="#c2-fn-0008"><sup>8</sup></a> The above sequence could be produced by <span class="KeyTerm1">list(1, 2, 3, 4)</span>. In general,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0234"></a>list(<span class="KeyTerm2"><i>a</i><sub>1</sub></span>, <span class="KeyTerm2"><i>a</i><sub>2</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>a<sub>n</sub></i></span>)</p>
<p class="paracontinue"><a id="c002_c2-para-0235"></a>is equivalent to</p>
<p class="Sp-text-1"><a id="c002_c2-para-0236"></a>pair(<span class="KeyTerm2"><i>a</i><sub>1</sub></span>, pair(<span class="KeyTerm2"><i>a</i><sub>2</sub></span>, pair(<i>. . .</i>, pair(<span class="KeyTerm2"><i>a<sub>n</sub></i></span>, <b>null</b>)<i>. . .</i>)))</p>
<p class="paracontinue"><a id="c002_c2-para-0237"></a>Our interpreter prints pairs using a textual representation of box-and-pointer diagrams that we call <i>box notation</i>. The result of <span class="KeyTerm1">pair(1, 2)</span> is printed as <span class="KeyTerm1">[1, 2]</span>, and the data object in <a href="#c2-fig-0009">figure 2.4</a> is printed as <span class="KeyTerm1">[1, [2, [3, [4, <b>null</b>]]]]</span>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0238"></a><b>const</b> one_through_four = list(1, 2, 3, 4);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0239"></a>one_through_four;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0240"></a><i>[1, [2, [3, [4, null]]]]</i></p>
<p><a id="c002_c2-para-0241"></a>We can think of <span class="KeyTerm1">head</span> as selecting the first item in the list, and of <span class="KeyTerm1">tail</span> as selecting the sublist consisting of all but the first item. Nested applications of <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> can be used to extract the second, third, and subsequent items in the list. The constructor <span class="KeyTerm1">pair</span> makes a list like the original one, but with an additional item at the beginning.</p>
<p class="Sp-text-1"><a id="c002_c2-para-0242"></a>head(one_through_four);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0243"></a><i>1</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0244"></a>tail(one_through_four);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0245"></a><i>[2, [3, [4, null]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0246"></a>head(tail(one_through_four));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0247"></a><i>2</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0248"></a>pair(10, one_through_four);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0249"></a><i>[10, [1, [2, [3, [4, null]]]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0250"></a>pair(5, one_through_four);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0251"></a><i>[5, [1, [2, [3, [4, null]]]]]</i></p>
<p class="paracontinue"><a id="c002_c2-para-0252"></a>The value <span class="KeyTerm1"><b>null</b></span>, used to terminate the chain of pairs, can be thought of as a sequence of no elements, the <i>empty list</i>.<a id="c002_c2-fn-0009a"></a><a href="#c2-fn-0009"><sup>9</sup></a></p>
<p><a id="c002_c2-para-0253"></a>Box notation is sometimes difficult to read. In this book, when we want to indicate the list nature of a data structure, we will employ the alternative <i>list notation</i>: Whenever possible, list notation uses applications of <span class="KeyTerm1">list</span> whose evaluation would result in the desired structure. For example, instead of the box notation</p>
<p class="Sp-text-1"><a id="c002_c2-para-0254"></a><i>[1, [[2, 3], [[4, [5, null]], [6, null]]]]</i></p>
<p class="paracontinue"><a id="c002_c2-para-0255"></a>we write</p>
<p class="Sp-text-1"><a id="c002_c2-para-0256"></a><i>list(1, [2, 3], list(4, 5), 6)</i></p>
<p class="paracontinue"><a id="c002_c2-para-0257"></a>in list notation.<a id="c002_c2-fn-0010a"></a><a href="#c2-fn-0010"><sup>10</sup></a></p>
<section>
<h5><a id="c002_c2-sec-0027"></a><a id="c002_c2-title-0028"></a>List operations</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0258"></a>The use of pairs to represent sequences of elements as lists is accompanied by conventional programming techniques for manipulating lists by successively using <span class="KeyTerm1">tail</span> to walk down the lists. For example, the function <span class="KeyTerm1">list_ref</span> takes as arguments a list and a number <i>n</i> and returns the <i>n</i>th item of the list. It is customary to number the elements of the list beginning with 0. The method for computing <span class="KeyTerm1">list_ref</span> is the following:</p>
<ul style="list-style-type:disc">
<li>For <i>n</i> = 0, <span class="KeyTerm1">list_ref</span> should return the <span class="KeyTerm1">head</span> of the list.</li>
<li>Otherwise, <span class="KeyTerm1">list_ref</span> should return the (<i>n</i> – 1)st item of the <span class="KeyTerm1">tail</span> of the list.</li>
</ul>
<p class="Sp-text-1"><a id="c002_c2-para-0261"></a><b>function</b> list_ref(items, n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0262"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-0263"></a>           ? head(items)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0264"></a>           : list_ref(tail(items), n - 1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0265"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0266"></a><b>const</b> squares = list(1, 4, 9, 16, 25);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0267"></a>list_ref(squares, 3);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0268"></a><i>16</i></p>
<p><a id="c002_c2-para-0269"></a>Often we walk down the whole list. To aid in this, our JavaScript environment includes a primitive predicate <span class="KeyTerm1">is_null</span>, which tests whether its argument is the empty list. The function <span class="KeyTerm1">length</span>, which returns the number of items in a list, illustrates this typical pattern of use:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0270"></a><b>function</b> length(items) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0271"></a> <b>return</b> is_null(items)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0272"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-0273"></a>           : 1 + length(tail(items));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0274"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0275"></a><b>const</b> odds = list(1, 3, 5, 7);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0276"></a>length(odds);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0277"></a><i>4</i></p>
<p class="paracontinue"><a id="c002_c2-para-0278"></a>The <span class="KeyTerm1">length</span> function implements a simple recursive plan. The reduction step is:</p>
<ul style="list-style-type:disc">
<li>The <span class="KeyTerm1">length</span> of any list is 1 plus the <span class="KeyTerm1">length</span> of the <span class="KeyTerm1">tail</span> of the list.</li>
</ul>
<p class="paracontinue"><a id="c002_c2-para-0280"></a>This is applied successively until we reach the base case:</p>
<ul style="list-style-type:disc">
<li>The <span class="KeyTerm1">length</span> of the empty list is 0.</li>
</ul>
<p class="paracontinue"><a id="c002_c2-para-0282"></a>We could also compute <span class="KeyTerm1">length</span> in an iterative style:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0283"></a><b>function</b> length(items) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0284"></a> <b>function</b> length_iter(a, count) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0285"></a> <b>return</b> is_null(a)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0286"></a>               ? count</p>
<p class="Sp-text-1"><a id="c002_c2-para-0287"></a>               : length_iter(tail(a), count + 1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0288"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0289"></a> <b>return</b> length_iter(items, 0);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0290"></a>}</p>
<p><a id="c002_c2-para-0291"></a>Another conventional programming technique is to construct an answer list by adjoining elements to the front of the list with <span class="KeyTerm1">pair</span> while walking down a list using <span class="KeyTerm1">tail</span>, as in the function <span class="KeyTerm1">append</span>, which takes two lists as arguments and combines their elements to make a new list:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0292"></a>append(squares, odds);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0293"></a><i>list(1, 4, 9, 16, 25, 1, 3, 5, 7)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0294"></a>append(odds, squares);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0295"></a><i>list(1, 3, 5, 7, 1, 4, 9, 16, 25)</i></p>
<p class="paracontinue"><a id="c002_c2-para-0296"></a>The function <span class="KeyTerm1">append</span> is also implemented using a recursive plan. To <span class="KeyTerm1">append</span> lists <span class="KeyTerm1">list1</span> and <span class="KeyTerm1">list2</span>, do the following:</p>
<ul style="list-style-type:disc">
<li>If <span class="KeyTerm1">list1</span> is the empty list, then the result is just <span class="KeyTerm1">list2</span>.</li>
<li>Otherwise, <span class="KeyTerm1">append</span> the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">list1</span> and <span class="KeyTerm1">list2</span>, and adjoin the <span class="KeyTerm1">head</span> of <span class="KeyTerm1">list1</span> to the result:</li>
</ul>
<p class="Sp-text-1"><a id="c002_c2-para-0299"></a><b>function</b> append(list1, list2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0300"></a> <b>return</b> is_null(list1)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0301"></a>           ? list2</p>
<p class="Sp-text-1"><a id="c002_c2-para-0302"></a>           : pair(head(list1), append(tail(list1), list2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0303"></a>}</p>
</section>
<section>
<h5><a id="c002_c2-sec-0028"></a><a id="c002_c2-title-0029"></a>Exercise 2.17</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0304"></a>Define a function <span class="KeyTerm1">last_pair</span> that returns the list that contains only the last element of a given (nonempty) list:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0305"></a>last_pair(list(23, 72, 149, 34));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0306"></a><i>list(34)</i></p>
</section>
<section>
<h5><a id="c002_c2-sec-0029"></a><a id="c002_c2-title-0030"></a>Exercise 2.18</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0307"></a>Define a function <span class="KeyTerm1">reverse</span> that takes a list as argument and returns a list of the same elements in reverse order:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0308"></a>reverse(list(1, 4, 9, 16, 25));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0309"></a><i>list(25, 16, 9, 4, 1)</i></p>
</section>
<section>
<h5><a id="c002_c2-sec-0030"></a><a id="c002_c2-title-0031"></a>Exercise 2.19</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0310"></a>Consider the change-counting program of section 1.2.2. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways to change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the function <span class="KeyTerm1">first_denomination</span> and partly into the function <span class="KeyTerm1">count_change</span> (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.</p>
<p><a id="c002_c2-para-0311"></a>We want to rewrite the function <span class="KeyTerm1">cc</span> so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0312"></a><b>const</b> us_coins = list(50, 25, 10, 5, 1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0313"></a><b>const</b> uk_coins = list(100, 50, 20, 10, 5, 2, 1);</p>
<p class="paracontinue"><a id="c002_c2-para-0314"></a>We could then call <span class="KeyTerm1">cc</span> as follows:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0315"></a>cc(100, us_coins);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0316"></a><i>292</i></p>
<p class="paracontinue"><a id="c002_c2-para-0317"></a>To do this will require changing the program <span class="KeyTerm1">cc</span> somewhat. It will still have the same form, but it will access its second argument differently, as follows:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0318"></a><b>function</b> cc(amount, coin_values) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0319"></a> <b>return</b> amount === 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-0320"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c002_c2-para-0321"></a>           : amount &lt; 0 || no_more(coin_values)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0322"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-0323"></a>           : cc(amount, except_first_denomination(coin_values)) +</p>
<p class="Sp-text-1"><a id="c002_c2-para-0324"></a>             cc(amount - first_denomination(coin_values), coin_values);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0325"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0326"></a>Define the functions <span class="KeyTerm1">first_denomination</span>, <span class="KeyTerm1">except_first_denomination</span>, and <span class="KeyTerm1">no_more</span> in terms of primitive operations on list structures. Does the order of the list <span class="KeyTerm1">coin_values</span> affect the answer produced by <span class="KeyTerm1">cc</span>? Why or why not?</p>
</section>
<section>
<h5><a id="c002_c2-sec-0031"></a><a id="c002_c2-title-0032"></a>Exercise 2.20</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0327"></a>In the presence of higher-order functions, it is not strictly necessary for functions to have multiple parameters; one would suffice. If we have a function such as <span class="KeyTerm1">plus</span> that naturally requires two arguments, we could write a variant of the function to which we pass the arguments one at at time. An application of the variant to the first argument could return a function that we can then apply to the second argument, and so on. This practice—called <i>currying</i> and named after the American mathematician and logician Haskell Brooks Curry—is quite common in programming languages such as Haskell and OCaml. In JavaScript, a curried version of <span class="KeyTerm1">plus</span> looks as follows.</p>
<p class="Sp-text-1"><a id="c002_c2-para-0328"></a><b>function</b> plus_curried(x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0329"></a> <b>return</b> y =&gt; x + y;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0330"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0331"></a>Write a function <span class="KeyTerm1">brooks</span> that takes a curried function as first argument and as second argument a list of arguments to which the curried function is then applied, one by one, in the given order. For example, the following application of <span class="KeyTerm1">brooks</span> should have the same effect as <span class="KeyTerm1">plus_curried(3)(4)</span>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0332"></a>brooks(plus_curried, list(3, 4));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0333"></a><i>7</i></p>
<p class="paracontinue"><a id="c002_c2-para-0334"></a>While we are at it, we might as well curry the function <span class="KeyTerm1">brooks</span>! Write a function <span class="KeyTerm1">brooks_curried</span> that can be applied as follows:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0335"></a>brooks_curried(list(plus_curried, 3, 4));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0336"></a><i>7</i></p>
<p class="paracontinue"><a id="c002_c2-para-0337"></a>With this function <span class="KeyTerm1">brooks_curried</span>, what are the results of evaluating the following two statements?</p>
<p class="Sp-text-1"><a id="c002_c2-para-0338"></a>brooks_curried(list(brooks_curried,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0339"></a>                    list(plus_curried, 3, 4)));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0340"></a>brooks_curried(list(brooks_curried,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0341"></a>                    list(brooks_curried,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0342"></a>                         list(plus_curried, 3, 4))));</p>
</section>
<section>
<h5><a id="c002_c2-sec-0032"></a><a id="c002_c2-title-0033"></a>Mapping over lists</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0343"></a>One extremely useful operation is to apply some transformation to each element in a list and generate the list of results. For instance, the following function scales each number in a list by a given factor:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0344"></a><b>function</b> scale_list(items, factor) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0345"></a> <b>return</b> is_null(items)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0346"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-0347"></a>           : pair(head(items) * factor,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0348"></a>                  scale_list(tail(items), factor));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0349"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0350"></a>scale_list(list(1, 2, 3, 4, 5), 10);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0351"></a><i>[10, [20, [30, [40, [50, null]]]]]</i></p>
<p><a id="c002_c2-para-0352"></a>We can abstract this general idea and capture it as a common pattern expressed as a higher-order function, just as in section 1.3. The higher-order function here is called <span class="KeyTerm1">map</span>. The function <span class="KeyTerm1">map</span> takes as arguments a function of one argument and a list, and returns a list of the results produced by applying the function to each element in the list:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0353"></a><b>function</b> map(fun, items) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0354"></a> <b>return</b> is_null(items)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0355"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-0356"></a>           : pair(fun(head(items)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0357"></a>                  map(fun, tail(items)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0358"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0359"></a>map(abs, list(-10, 2.5, -11.6, 17));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0360"></a><i>[10, [2.5, [11.6, [17, null]]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0361"></a>map(x =&gt; x * x, list(1, 2, 3, 4));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0362"></a><i>[1, [4, [9, [16, null]]]]</i></p>
<p class="paracontinue"><a id="c002_c2-para-0363"></a>Now we can give a new definition of <span class="KeyTerm1">scale_list</span> in terms of <span class="KeyTerm1">map</span>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0364"></a><b>function</b> scale_list(items, factor) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0365"></a> <b>return</b> map(x =&gt; x * factor, items);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0366"></a>}</p>
<p><a id="c002_c2-para-0367"></a>The function <span class="KeyTerm1">map</span> is an important construct, not only because it captures a common pattern, but because it establishes a higher level of abstraction in dealing with lists. In the original definition of <span class="KeyTerm1">scale_list</span>, the recursive structure of the program draws attention to the element-by-element processing of the list. Defining <span class="KeyTerm1">scale_list</span> in terms of <span class="KeyTerm1">map</span> suppresses that level of detail and emphasizes that scaling transforms a list of elements to a list of results. The difference between the two definitions is not that the computer is performing a different process (it isn't) but that we think about the process differently. In effect, <span class="KeyTerm1">map</span> helps establish an abstraction barrier that isolates the implementation of functions that transform lists from the details of how the elements of the list are extracted and combined. Like the barriers shown in <a href="#c2-fig-0002">figure 2.1</a>, this abstraction gives us the flexibility to change the low-level details of how sequences are implemented, while preserving the conceptual framework of operations that transform sequences to sequences. Section 2.2.3 expands on this use of sequences as a framework for organizing programs.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0033"></a><a id="c002_c2-title-0034"></a>Exercise 2.21</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0368"></a>The function <span class="KeyTerm1">square_list</span> takes a list of numbers as argument and returns a list of the squares of those numbers.</p>
<p class="Sp-text-1"><a id="c002_c2-para-0369"></a>square_list(list(1, 2, 3, 4));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0370"></a><i>[1, [4, [9, [16, null]]]]</i></p>
<p class="paracontinue"><a id="c002_c2-para-0371"></a>Here are two different definitions of <span class="KeyTerm1">square_list</span>. Complete both of them by filling in the missing expressions:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0372"></a><b>function</b> square_list(items) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0373"></a> <b>return</b> is_null(items)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0374"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-0375"></a>           : pair(〈??〉, 〈??〉);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0376"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0377"></a><b>function</b> square_list(items) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0378"></a> <b>return</b> map(〈??〉, 〈??〉);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0379"></a><sub>}</sub></p>
</section>
<section>
<h5><a id="c002_c2-sec-0034"></a><a id="c002_c2-title-0035"></a>Exercise 2.22</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0380"></a>Louis Reasoner tries to rewrite the first <span class="KeyTerm1">square_list</span> function of exercise 2.21 so that it evolves an iterative process:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0381"></a><b>function</b> square_list(items) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0382"></a> <b>function</b> iter(things, answer) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0383"></a> <b>return</b> is_null(things)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0384"></a>               ? answer</p>
<p class="Sp-text-1"><a id="c002_c2-para-0385"></a>               : iter(tail(things),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0386"></a>                      pair(square(head(things)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0387"></a>                           answer));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0388"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0389"></a> <b>return</b> iter(items, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0390"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0391"></a>Unfortunately, defining <span class="KeyTerm1">square_list</span> this way produces the answer list in the reverse order of the one desired. Why?</p>
<p><a id="c002_c2-para-0392"></a>Louis then tries to fix his bug by interchanging the arguments to <span class="KeyTerm1">pair</span>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0393"></a><b>function</b> square_list(items) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0394"></a> <b>function</b> iter(things, answer) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0395"></a> <b>return</b> is_null(things)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0396"></a>               ? answer</p>
<p class="Sp-text-1"><a id="c002_c2-para-0397"></a>               : iter(tail(things),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0398"></a>                      pair(answer,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0399"></a>                           square(head(things))));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0400"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0401"></a> <b>return</b> iter(items, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0402"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0403"></a>This doesn't work either. Explain.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0035"></a><a id="c002_c2-title-0036"></a>Exercise 2.23</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0404"></a>The function <span class="KeyTerm1">for_each</span> is similar to <span class="KeyTerm1">map</span>. It takes as arguments a function and a list of elements. However, rather than forming a list of the results, <span class="KeyTerm1">for_each</span> just applies the function to each of the elements in turn, from left to right. The values returned by applying the function to the elements are not used at all—<span class="KeyTerm1">for_each</span> is used with functions that perform an action, such as printing. For example,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0405"></a>for_each(x =&gt; display(x), list(57, 321, 88));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0406"></a><i>57</i></p>
<p class="Sp-text-1"><a id="c002_c2-para-0407"></a><i>321</i></p>
<p class="Sp-text-1"><a id="c002_c2-para-0408"></a><i>88</i></p>
<p class="paracontinue"><a id="c002_c2-para-0409"></a>The value returned by the call to <span class="KeyTerm1">for_each</span> (not illustrated above) can be something arbitrary, such as true. Give an implementation of <span class="KeyTerm1">for_each</span>.</p>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0036"></a><span>2.2.2</span> <a id="c002_c2-title-0037"></a>Hierarchical Structures</h3>
<p class="paraaftertitle"><a id="c002_c2-para-0410"></a>The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object <span class="KeyTerm1">[[1, [2, <b>null</b>]], [3, [4, <b>null</b>]]]</span> constructed by</p>
<p class="Sp-text-1"><a id="c002_c2-para-0411"></a>pair(list(1, 2), list(3, 4));</p>
<p class="paracontinue"><a id="c002_c2-para-0412"></a>as a list of three items, the first of which is itself a list, <span class="KeyTerm1">[1, [2, <b>null</b>]]</span>. <a id="c002_c2-fig-0010a"></a><a href="#c2-fig-0010">Figure 2.5</a> shows the representation of this structure in terms of pairs.</p>
<figure id="c002_c2-fig-0010"><img alt="c2-fig-0005.jpg" src="../images/c2-fig-0005.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0010a">Figure 2.5</a></span> <a id="c002_c2-para-0413"></a>Structure formed by <span class="KeyTerm1">pair(list(1, 2), list(3, 4))</span>.</p></figcaption></figure>
<p><a id="c002_c2-para-0414"></a>Another way to think of sequences whose elements are sequences is as <i>trees</i>. The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. <a id="c002_c2-fig-0011a"></a><a href="#c2-fig-0011">Figure 2.6</a> shows the structure in <a href="#c2-fig-0010">figure 2.5</a> viewed as a tree.</p>
<figure id="c002_c2-fig-0011"><img alt="c2-fig-0006.jpg" src="../images/c2-fig-0006.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0011a">Figure 2.6</a></span> <a id="c002_c2-para-0415"></a>The list structure in <a href="#c2-fig-0010">figure 2.5</a> viewed as a tree.</p></figcaption></figure>
<p><a id="c002_c2-para-0416"></a>Recursion is a natural tool for dealing with tree structures, since we can often reduce operations on trees to operations on their branches, which reduce in turn to operations on the branches of the branches, and so on, until we reach the leaves of the tree. As an example, compare the <span class="KeyTerm1">length</span> function of section 2.2.1 with the <span class="KeyTerm1">count_leaves</span> function, which returns the total number of leaves of a tree:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0417"></a><b>const</b> x = pair(list(1, 2), list(3, 4));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0418"></a>length(x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0419"></a><i>3</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0420"></a>count_leaves(x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0421"></a><i>4</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0422"></a>list(x, x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0423"></a><i>list(list(list(1, 2), 3, 4), list(list(1, 2), 3, 4))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0424"></a>length(list(x, x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0425"></a><i>2</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0426"></a>count_leaves(list(x, x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0427"></a><i>8</i></p>
<p><a id="c002_c2-para-0428"></a>To implement <span class="KeyTerm1">count_leaves</span>, recall the recursive plan for computing <span class="KeyTerm1">length</span>:</p>
<ul style="list-style-type:disc">
<li>The <span class="KeyTerm1">length</span> of a list <span class="KeyTerm1">x</span> is 1 plus the <span class="KeyTerm1">length</span> of the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">x</span>.</li>
<li>The <span class="KeyTerm1">length</span> of the empty list is 0.</li>
</ul>
<p class="paracontinue"><a id="c002_c2-para-0431"></a>The function <span class="KeyTerm1">count_leaves</span> is similar. The value for the empty list is the same:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">count_leaves</span> of the empty list is 0.</li>
</ul>
<p class="paracontinue"><a id="c002_c2-para-0433"></a>But in the reduction step, where we strip off the <span class="KeyTerm1">head</span> of the list, we must take into account that the <span class="KeyTerm1">head</span> may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">count_leaves</span> of a tree <span class="KeyTerm1">x</span> is <span class="KeyTerm1">count_leaves</span> of the <span class="KeyTerm1">head</span> of <span class="KeyTerm1">x</span> plus <span class="KeyTerm1">count_leaves</span> of the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">x</span>.</li>
</ul>
<p class="paracontinue"><a id="c002_c2-para-0435"></a>Finally, by taking <span class="KeyTerm1">head</span>s we reach actual leaves, so we need another base case:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">count_leaves</span> of a leaf is 1.</li>
</ul>
<p class="paracontinue"><a id="c002_c2-para-0437"></a>To aid in writing recursive functions on trees, our JavaScript environment provides the primitive predicate <span class="KeyTerm1">is_pair</span>, which tests whether its argument is a pair. Here is the complete function:<a id="c002_c2-fn-0011a"></a><a href="#c2-fn-0011"><sup>11</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0438"></a><b>function</b> count_leaves(x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0439"></a> <b>return</b> is_null(x)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0440"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-0441"></a>           : ! is_pair(x)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0442"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c002_c2-para-0443"></a>           : count_leaves(head(x)) + count_leaves(tail(x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0444"></a>}</p>
<section>
<h5><a id="c002_c2-sec-0037"></a><a id="c002_c2-title-0038"></a>Exercise 2.24</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0445"></a>Suppose we evaluate the expression <span class="KeyTerm1">list(1, list(2, list(3, 4)))</span>. Give the result printed by the interpreter, the corresponding box-and-pointer structure, and the interpretation of this as a tree (as in <a href="#c2-fig-0011">figure 2.6</a>).</p>
</section>
<section>
<h5><a id="c002_c2-sec-0038"></a><a id="c002_c2-title-0039"></a>Exercise 2.25</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0446"></a>Give combinations of <span class="KeyTerm1">head</span>s and <span class="KeyTerm1">tail</span>s that will pick 7 from each of the following lists, given in list notation:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0447"></a>list(1, 3, list(5, 7), 9)</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0448"></a>list(list(7))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0449"></a>list(1, list(2, list(3, list(4, list(5, list(6, 7))))))</p>
</section>
<section>
<h5><a id="c002_c2-sec-0039"></a><a id="c002_c2-title-0040"></a>Exercise 2.26</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0450"></a>Suppose we define <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> to be two lists:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0451"></a><b>const</b> x = list(1, 2, 3);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0452"></a><b>const</b> y = list(4, 5, 6);</p>
<p class="paracontinue"><a id="c002_c2-para-0453"></a>What is the result of evaluating each of the following expressions, in box notation and list notation?</p>
<p class="Sp-text-1"><a id="c002_c2-para-0454"></a>append(x, y)</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0455"></a>pair(x, y)</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0456"></a>list(x, y)</p>
</section>
<section>
<h5><a id="c002_c2-sec-0040"></a><a id="c002_c2-title-0041"></a>Exercise 2.27</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0457"></a>Modify your <span class="KeyTerm1">reverse</span> function of exercise 2.18 to produce a <span class="KeyTerm1">deep_reverse</span> function that takes a list as argument and returns as its value the list with its elements reversed and with all sublists deep-reversed as well. For example,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0458"></a><b>const</b> x = list(list(1, 2), list(3, 4));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0459"></a>x;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0460"></a><i>list(list(1, 2), list(3, 4))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0461"></a>reverse(x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0462"></a><i>list(list(3, 4), list(1, 2))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0463"></a>deep_reverse(x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0464"></a><i>list(list(4, 3), list(2, 1))</i></p>
</section>
<section>
<h5><a id="c002_c2-sec-0041"></a><a id="c002_c2-title-0042"></a>Exercise 2.28</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0465"></a>Write a function <span class="KeyTerm1">fringe</span> that takes as argument a tree (represented as a list) and returns a list whose elements are all the leaves of the tree arranged in left-to-right order. For example,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0466"></a><b>const</b> x = list(list(1, 2), list(3, 4));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0467"></a>fringe(x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0468"></a><i>list(1, 2, 3, 4)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0469"></a>fringe(list(x, x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0470"></a><i>list(1, 2, 3, 4, 1, 2, 3, 4)</i></p>
</section>
<section>
<h5><a id="c002_c2-sec-0042"></a><a id="c002_c2-title-0043"></a>Exercise 2.29</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0471"></a>A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile using compound data by constructing it from two branches (for example, using <span class="KeyTerm1">list</span>):</p>
<p class="Sp-text-1"><a id="c002_c2-para-0472"></a><b>function</b> make_mobile(left, right) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0473"></a> <b>return</b> list(left, right);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0474"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0475"></a>A branch is constructed from a <span class="KeyTerm1">length</span> (which must be a number) together with a <span class="KeyTerm1">structure</span>, which may be either a number (representing a simple weight) or another mobile:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0476"></a><b>function</b> make_branch(length, structure) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0477"></a> <b>return</b> list(length, structure);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0478"></a>}</p>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0014"></a><span>a. </span>Write the corresponding selectors <span class="KeyTerm1">left_branch</span> and <span class="KeyTerm1">right_branch</span>, which return the branches of a mobile, and <span class="KeyTerm1">branch_length</span> and <span class="KeyTerm1">branch_structure</span>, which return the components of a branch.</li>
<li><a id="c002_c2-li-0015"></a><span>b. </span>Using your selectors, define a function <span class="KeyTerm1">total_weight</span> that returns the total weight of a mobile.</li>
<li><a id="c002_c2-li-0016"></a><span>c. </span>A mobile is said to be <i>balanced</i> if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and if each of the submobiles hanging off its branches is balanced. Design a predicate that tests whether a binary mobile is balanced.</li>
<li><a id="c002_c2-li-0017"></a><span>d. </span>Suppose we change the representation of mobiles so that the constructors are
<p class="Sp-text-1"><a id="c002_c2-para-0483"></a><b>function</b> make_mobile(left, right) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0484"></a> <b>return</b> pair(left, right);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0485"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-0486"></a><b>function</b> make_branch(length, structure) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0487"></a> <b>return</b> pair(length, structure);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0488"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0489"></a>How much do you need to change your programs to convert to the new representation?</p></li>
</ol>
</section>
<section>
<h5><a id="c002_c2-sec-0043"></a><a id="c002_c2-title-0044"></a>Mapping over trees</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0490"></a>Just as <span class="KeyTerm1">map</span> is a powerful abstraction for dealing with sequences, <span class="KeyTerm1">map</span> together with recursion is a powerful abstraction for dealing with trees. For instance, the <span class="KeyTerm1">scale_tree</span> function, analogous to <span class="KeyTerm1">scale_list</span> of section 2.2.1, takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for <span class="KeyTerm1">scale_tree</span> is similar to the one for <span class="KeyTerm1">count_leaves</span>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0491"></a><b>function</b> scale_tree(tree, factor) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0492"></a> <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0493"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-0494"></a>           : ! is_pair(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0495"></a>           ? tree * factor</p>
<p class="Sp-text-1"><a id="c002_c2-para-0496"></a>           : pair(scale_tree(head(tree), factor),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0497"></a>                  scale_tree(tail(tree), factor));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0498"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0499"></a>scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0500"></a>           10);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0501"></a><i>list(10, list(20, list(30, 40), 50), list(60, 70))</i></p>
<p><a id="c002_c2-para-0502"></a>Another way to implement <span class="KeyTerm1">scale_tree</span> is to regard the tree as a sequence of sub-trees and use <span class="KeyTerm1">map</span>. We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0503"></a><b>function</b> scale_tree(tree, factor) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0504"></a> <b>return</b> map(sub_tree =&gt; is_pair(sub_tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0505"></a>                           ? scale_tree(sub_tree, factor)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0506"></a>                           : sub_tree * factor,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0507"></a>               tree);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0508"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0509"></a>Many tree operations can be implemented by similar combinations of sequence operations and recursion.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0044"></a><a id="c002_c2-title-0045"></a>Exercise 2.30</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0510"></a>Declare a function <span class="KeyTerm1">square_tree</span> analogous to the <span class="KeyTerm1">square_list</span> function of exercise 2.21. That is, <span class="KeyTerm1">square_tree</span> should behave as follows:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0511"></a>square_tree(list(1,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0512"></a>                 list(2, list(3, 4), 5),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0513"></a>                 list(6, 7)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0514"></a><i>list(1, list(4, list(9, 16), 25), list(36, 49)))</i></p>
<p class="paracontinue"><a id="c002_c2-para-0515"></a>Declare <span class="KeyTerm1">square_tree</span> both directly (i.e., without using any higher-order functions) and also by using <span class="KeyTerm1">map</span> and recursion.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0045"></a><a id="c002_c2-title-0046"></a>Exercise 2.31</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0516"></a>Abstract your answer to exercise 2.30 to produce a function <span class="KeyTerm1">tree_map</span> with the property that <span class="KeyTerm1">square_tree</span> could be declared as</p>
<p class="Sp-text-1"><a id="c002_c2-para-0517"></a><b>function</b> square_tree(tree) { <b>return</b> tree_map(square, tree); }</p>
</section>
<section>
<h5><a id="c002_c2-sec-0046"></a><a id="c002_c2-title-0047"></a>Exercise 2.32</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0518"></a>We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is <span class="KeyTerm1">list(1, 2, 3)</span>, then the set of all subsets is</p>
<p class="Sp-text-1"><a id="c002_c2-para-0519"></a>list(<b>null</b>, list(3), list(2), list(2, 3),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0520"></a>     list(1), list(1, 3), list(1, 2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0521"></a>     list(1, 2, 3))</p>
<p class="paracontinue"><a id="c002_c2-para-0522"></a>Complete the following declaration of a function that generates the set of subsets of a set and give a clear explanation of why it works:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0523"></a><b>function</b> subsets(s) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0524"></a> <b>if</b> (is_null(s)) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0525"></a> <b>return</b> list(<b>null</b>);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0526"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0527"></a> <b>const</b> rest = subsets(tail(s));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0528"></a> <b>return</b> append(rest, map( ?? , rest));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0529"></a> <sub>}</sub></p>
<p class="Sp-text-1"><a id="c002_c2-para-0530"></a>}</p>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0047"></a><span>2.2.3</span> <a id="c002_c2-title-0048"></a>Sequences as Conventional Interfaces</h3>
<p class="paraaftertitle"><a id="c002_c2-para-0531"></a>In working with compound data, we've stressed how data abstraction permits us to design programs without becoming enmeshed in the details of data representations, and how abstraction preserves for us the flexibility to experiment with alternative representations. In this section, we introduce another powerful design principle for working with data structures—the use of <i>conventional interfaces</i>.</p>
<p><a id="c002_c2-para-0532"></a>In section 1.3 we saw how program abstractions, implemented as higher-order functions, can capture common patterns in programs that deal with numerical data. Our ability to formulate analogous operations for working with compound data depends crucially on the style in which we manipulate our data structures. Consider, for example, the following function, analogous to the <span class="KeyTerm1">count_leaves</span> function of section 2.2.2, which takes a tree as argument and computes the sum of the squares of the leaves that are odd:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0533"></a><b>function</b> sum_odd_squares(tree) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0534"></a> <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0535"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-0536"></a>           : ! is_pair(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0537"></a>           ? is_odd(tree) ? square(tree) : 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-0538"></a>           : sum_odd_squares(head(tree)) +</p>
<p class="Sp-text-1"><a id="c002_c2-para-0539"></a>             sum_odd_squares(tail(tree));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0540"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0541"></a>On the surface, this function is very different from the following one, which constructs a list of all the even Fibonacci numbers Fib(<i>k</i>), where <i>k</i> is less than or equal to a given integer <i>n</i>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0542"></a><b>function</b> even_fibs(n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0543"></a> <b>function</b> next(k) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0544"></a> <b>if</b> (k &gt; n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0545"></a> <b>return null</b>;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0546"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0547"></a> <b>const</b> f = fib(k);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0548"></a> <b>return</b> is_even(f)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0549"></a>                   ? pair(f, next(k + 1))</p>
<p class="Sp-text-1"><a id="c002_c2-para-0550"></a>                   : next(k + 1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0551"></a>        }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0552"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0553"></a> <b>return</b> next(0);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0554"></a>}</p>
<p><a id="c002_c2-para-0555"></a>Despite the fact that these two functions are structurally very different, a more abstract description of the two computations reveals a great deal of similarity. The first program</p>
<ul style="list-style-type:disc">
<li>enumerates the leaves of a tree;</li>
<li>filters them, selecting the odd ones;</li>
<li>squares each of the selected ones; and</li>
<li>accumulates the results using <span class="KeyTerm1">+</span>, starting with 0.</li>
</ul>
<p class="paracontinue"><a id="c002_c2-para-0560"></a>The second program</p>
<ul style="list-style-type:disc">
<li>enumerates the integers from 0 to <i>n</i>;</li>
<li>computes the Fibonacci number for each integer;</li>
<li>filters them, selecting the even ones; and</li>
<li>accumulates the results using <span class="KeyTerm1">pair</span>, starting with the empty list.</li>
</ul>
<p><a id="c002_c2-para-0565"></a>A signal-processing engineer would find it natural to conceptualize these processes in terms of signals flowing through a cascade of stages, each of which implements part of the program plan, as shown in <a id="c002_c2-fig-0012a"></a><a href="#c2-fig-0012">figure 2.7</a>. In <span class="KeyTerm1">sum_odd_squares</span>, we begin with an <i>enumerator</i>, which generates a “signal” consisting of the leaves of a given tree. This signal is passed through a <i>filter</i>, which eliminates all but the odd elements. The resulting signal is in turn passed through a <i>map</i>, which is a “transducer” that applies the <span class="KeyTerm1">square</span> function to each element. The output of the map is then fed to an <i>accumulator</i>, which combines the elements using <span class="KeyTerm1">+</span>, starting from an initial 0. The plan for <span class="KeyTerm1">even_fibs</span> is analogous.</p>
<figure id="c002_c2-fig-0012"><img alt="c2-fig-0007.jpg" src="../images/c2-fig-0007.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0012a">Figure 2.7</a></span> <a id="c002_c2-para-0566"></a>The signal-flow plans for the functions <span class="KeyTerm1">sum_odd_squares</span> (top) and <span class="KeyTerm1">even_fibs</span> (bottom) reveal the commonality between the two programs.</p></figcaption></figure>
<p><a id="c002_c2-para-0567"></a>Unfortunately, the two function declarations above fail to exhibit this signal-flow structure. For instance, if we examine the <span class="KeyTerm1">sum_odd_squares</span> function, we find that the enumeration is implemented partly by the <span class="KeyTerm1">is_null</span> and <span class="KeyTerm1">is_pair</span> tests and partly by the tree-recursive structure of the function. Similarly, the accumulation is found partly in the tests and partly in the addition used in the recursion. In general, there are no distinct parts of either function that correspond to the elements in the signalflow description. Our two functions decompose the computations in a different way, spreading the enumeration over the program and mingling it with the map, the filter, and the accumulation. If we could organize our programs to make the signal-flow structure manifest in the functions we write, this would increase the conceptual clarity of the resulting program.</p>
<section>
<h5><a id="c002_c2-sec-0048"></a><a id="c002_c2-title-0049"></a>Sequence Operations</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0568"></a>The key to organizing programs so as to more clearly reflect the signal-flow structure is to concentrate on the “signals” that flow from one stage in the process to the next. If we represent these signals as lists, then we can use list operations to implement the processing at each of the stages. For instance, we can implement the mapping stages of the signal-flow diagrams using the <span class="KeyTerm1">map</span> function from section 2.2.1:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0569"></a>map(square, list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0570"></a><i>list(1, 4, 9, 16, 25)</i></p>
<p><a id="c002_c2-para-0571"></a>Filtering a sequence to select only those elements that satisfy a given predicate is accomplished by</p>
<p class="Sp-text-1"><a id="c002_c2-para-0572"></a><b>function</b> filter(predicate, sequence) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0573"></a> <b>return</b> is_null(sequence)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0574"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-0575"></a>           : predicate(head(sequence))</p>
<p class="Sp-text-1"><a id="c002_c2-para-0576"></a>           ? pair(head(sequence),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0577"></a>                  filter(predicate, tail(sequence)))</p>
<p class="Sp-text-1"><a id="c002_c2-para-0578"></a>           : filter(predicate, tail(sequence));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0579"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0580"></a>For example,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0581"></a>filter(is_odd, list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0582"></a><i>list(1, 3, 5)</i></p>
<p><a id="c002_c2-para-0583"></a>Accumulations can be implemented by</p>
<p class="Sp-text-1"><a id="c002_c2-para-0584"></a><b>function</b> accumulate(op, initial, sequence) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0585"></a> <b>return</b> is_null(sequence)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0586"></a>           ? initial</p>
<p class="Sp-text-1"><a id="c002_c2-para-0587"></a>           : op(head(sequence),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0588"></a>                accumulate(op, initial, tail(sequence)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0589"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0590"></a>accumulate(plus, 0, list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0591"></a><i>15</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0592"></a>accumulate(times, 1, list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0593"></a><i>120</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0594"></a>accumulate(pair, <b>null</b>, list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0595"></a><i>list(1, 2, 3, 4, 5)</i></p>
<p><a id="c002_c2-para-0596"></a>All that remains to implement signal-flow diagrams is to enumerate the sequence of elements to be processed. For <span class="KeyTerm1">even_fibs</span>, we need to generate the sequence of integers in a given range, which we can do as follows:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0597"></a><b>function</b> enumerate_interval(low, high) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0598"></a> <b>return</b> low &gt; high</p>
<p class="Sp-text-1"><a id="c002_c2-para-0599"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-0600"></a>           : pair(low,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0601"></a>                  enumerate_interval(low + 1, high));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0602"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0603"></a>enumerate_interval(2, 7);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0604"></a><i>list(2, 3, 4, 5, 6, 7)</i></p>
<p class="paracontinue"><a id="c002_c2-para-0605"></a>To enumerate the leaves of a tree, we can use<a id="c002_c2-fn-0012a"></a><a href="#c2-fn-0012"><sup>12</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0606"></a><b>function</b> enumerate_tree(tree) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0607"></a> <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0608"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-0609"></a>           : ! is_pair(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0610"></a>           ? list(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0611"></a>           : append(enumerate_tree(head(tree)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0612"></a>                    enumerate_tree(tail(tree)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0613"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0614"></a>enumerate_tree(list(1, list(2, list(3, 4)), 5));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0615"></a><i>list(1, 2, 3, 4, 5)</i></p>
<p><a id="c002_c2-para-0616"></a>Now we can reformulate <span class="KeyTerm1">sum_odd_squares</span> and <span class="KeyTerm1">even_fibs</span> as in the signalflow diagrams. For <span class="KeyTerm1">sum_odd_squares</span>, we enumerate the sequence of leaves of the tree, filter this to keep only the odd numbers in the sequence, square each element, and sum the results:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0617"></a><b>function</b> sum_odd_squares(tree) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0618"></a> <b>return</b> accumulate(plus,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0619"></a>                      0,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0620"></a>                      map(square,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0621"></a>                          filter(is_odd,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0622"></a>                                 enumerate_tree(tree))));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0623"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0624"></a>For <span class="KeyTerm1">even_fibs</span>, we enumerate the integers from 0 to <i>n</i>, generate the Fibonacci number for each of these integers, filter the resulting sequence to keep only the even elements, and accumulate the results into a list:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0625"></a><b>function</b> even_fibs(n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0626"></a> <b>return</b> accumulate(pair,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0627"></a> <b>null</b>,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0628"></a>                      filter(is_even,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0629"></a>                             map(fib,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0630"></a>                                 enumerate_interval(0, n))));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0631"></a>}</p>
<p><a id="c002_c2-para-0632"></a>The value of expressing programs as sequence operations is that this helps us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces. We can encourage modular design by providing a library of standard components together with a conventional interface for connecting the components in flexible ways.</p>
<p><a id="c002_c2-para-0633"></a>Modular construction is a powerful strategy for controlling complexity in engineering design. In real signal-processing applications, for example, designers regularly build systems by cascading elements selected from standardized families of filters and transducers. Similarly, sequence operations provide a library of standard program elements that we can mix and match. For instance, we can reuse pieces from the <span class="KeyTerm1">sum_odd_squares</span> and <span class="KeyTerm1">even_fibs</span> functions in a program that constructs a list of the squares of the first <i>n</i> + 1 Fibonacci numbers:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0634"></a><b>function</b> list_fib_squares(n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0635"></a> <b>return</b> accumulate(pair,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0636"></a> <b>null</b>,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0637"></a>                      map(square,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0638"></a>                          map(fib,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0639"></a>                              enumerate_interval(0, n))));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0640"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0641"></a>list_fib_squares(10);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0642"></a><i>list(0, 1, 1, 4, 9, 25, 64, 169, 441, 1156, 3025)</i></p>
<p class="paracontinue"><a id="c002_c2-para-0643"></a>We can rearrange the pieces and use them in computing the product of the squares of the odd integers in a sequence:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0644"></a><b>function</b> product_of_squares_of_odd_elements(sequence) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0645"></a> <b>return</b> accumulate(times,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0646"></a>                      1,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0647"></a>                      map(square,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0648"></a>                          filter(is_odd, sequence)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0649"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0650"></a>product_of_squares_of_odd_elements(list(1, 2, 3, 4, 5));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0651"></a><i>225</i></p>
<p><a id="c002_c2-para-0652"></a>We can also formulate conventional data-processing applications in terms of sequence operations. Suppose we have a sequence of personnel records and we want to find the salary of the highest-paid programmer. Assume that we have a selector <span class="KeyTerm1">salary</span> that returns the salary of a record, and a predicate <span class="KeyTerm1">is_programmer</span> that tests if a record is for a programmer. Then we can write</p>
<p class="Sp-text-1"><a id="c002_c2-para-0653"></a><b>function</b> salary_of_highest_paid_programmer(records) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0654"></a> <b>return</b> accumulate(math_max,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0655"></a>                      0,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0656"></a>                      map(salary,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0657"></a>                          filter(is_programmer, records)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0658"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0659"></a>These examples give just a hint of the vast range of operations that can be expressed as sequence operations.<a id="c002_c2-fn-0013a"></a><a href="#c2-fn-0013"><sup>13</sup></a></p>
<p><a id="c002_c2-para-0660"></a>Sequences, implemented here as lists, serve as a conventional interface that permits us to combine processing modules. Additionally, when we uniformly represent structures as sequences, we have localized the data-structure dependencies in our programs to a small number of sequence operations. By changing these, we can experiment with alternative representations of sequences, while leaving the overall design of our programs intact. We will exploit this capability in section 3.5, when we generalize the sequence-processing paradigm to admit infinite sequences.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0049"></a><a id="c002_c2-title-0050"></a>Exercise 2.33</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0661"></a>Fill in the missing expressions to complete the following definitions of some basic listmanipulation operations as accumulations:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0662"></a><b>function</b> map(f, sequence) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0663"></a> <b>return</b> accumulate((x, y) =&gt; 〈??〉,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0664"></a> <b>null</b>, sequence);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0665"></a><sub>}</sub></p>
<p class="Sp-text-1"><a id="c002_c2-para-0666"></a><b>function</b> append(seq1, seq2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0667"></a> <b>return</b> accumulate(pair, 〈??〉, 〈??〉);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0668"></a><sub>}</sub></p>
<p class="Sp-text-1"><a id="c002_c2-para-0669"></a><b>function</b> length(sequence) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0670"></a> <b>return</b> accumulate( 〈??〉, 0, sequence);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0671"></a><sub>}</sub></p>
</section>
<section>
<h5><a id="c002_c2-sec-0050"></a><a id="c002_c2-title-0051"></a>Exercise 2.34</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0672"></a>Evaluating a polynomial in <i>x</i> at a given value of <i>x</i> can be formulated as an accumulation. We evaluate the polynomial</p>
<p class="Sp-text-2"><a id="c002_c2-para-0673"></a><i>a<sub>n</sub>x<sup>n</sup></i> + <i>a<sub>n</sub></i><sub>–1</sub><i>x<sup>n</sup></i><sup>–1</sup> + · · · + <i>a</i><sub>1</sub><i>x</i> + <i>a</i><sub>0</sub></p>
<p class="paracontinue"><a id="c002_c2-para-0674"></a>using a well-known algorithm called <i>Horner's rule</i>, which structures the computation as </p>
<p class="Sp-text-2"><a id="c002_c2-para-0675"></a>(· · · (a<sub>n</sub>x + a<sub>n–1</sub>)x + · · · + a<sub>1</sub>) x + a<sub>0</sub></p>
<p class="paracontinue"><a id="c002_c2-para-0676"></a>In other words, we start with <i>a<sub>n</sub></i>, multiply by <i>x</i>, add <i>a<sub>n</sub></i><sub>–1</sub>, multiply by <i>x</i>, and so on, until we reach <i>a</i><sub>0</sub>.<a id="c002_c2-fn-0014a"></a><a href="#c2-fn-0014"><sup>14</sup></a> Fill in the following template to produce a function that evaluates a polynomial using Horner's rule. Assume that the coefficients of the polynomial are arranged in a sequence, from <i>a</i><sub>0</sub> through <i>a<sub>n</sub></i>.</p>
<p class="Sp-text-1"><a id="c002_c2-para-0677"></a><b>function</b> horner_eval(x, coefficient_sequence) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0678"></a> <b>return</b> accumulate((this_coeff, higher_terms) =&gt; ?? ,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0679"></a>                      0,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0680"></a>                      coefficient_sequence);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0681"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0682"></a>For example, to compute 1 + 3<i>x</i> + 5<i>x</i><sup>3</sup> + <i>x</i><sup>5</sup> at <i>x</i> = 2 you would evaluate</p>
<p class="Sp-text-1"><a id="c002_c2-para-0683"></a>horner_eval(2, list(1, 3, 0, 5, 0, 1));</p>
</section>
<section>
<h5><a id="c002_c2-sec-0051"></a><a id="c002_c2-title-0052"></a>Exercise 2.35</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0684"></a>Redefine <span class="KeyTerm1">count_leaves</span> from section 2.2.2 as an accumulation:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0685"></a><b>function</b> count_leaves(t) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0686"></a> <b>return</b> accumulate( ?? , ?? , map( ?? , ?? ));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0687"></a><sub>}</sub></p>
</section>
<section>
<h5><a id="c002_c2-sec-0052"></a><a id="c002_c2-title-0053"></a>Exercise 2.36</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0688"></a>The function <span class="KeyTerm1">accumulate_n</span> is similar to <span class="KeyTerm1">accumulate</span> except that it takes as its third argument a sequence of sequences, which are all assumed to have the same number of elements. It applies the designated accumulation function to combine all the first elements of the sequences, all the second elements of the sequences, and so on, and returns a sequence of the results. For instance, if <span class="KeyTerm1">s</span> is a sequence containing four sequences</p>
<p class="Sp-text-1"><a id="c002_c2-para-0689"></a>list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9), list(10, 11, 12))</p>
<p class="paracontinue"><a id="c002_c2-para-0690"></a>then the value of <span class="KeyTerm1">accumulate_n(plus, 0, s)</span> should be the sequence <span class="KeyTerm1">list(22, 26, 30)</span>. Fill in the missing expressions in the following definition of <span class="KeyTerm1">accumulate_n</span>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0691"></a><b>function</b> accumulate_n(op, init, seqs) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0692"></a> <b>return</b> is_null(head(seqs))</p>
<p class="Sp-text-1"><a id="c002_c2-para-0693"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-0694"></a>           : pair(accumulate(op, init, 〈??〉),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0695"></a>                  accumulate_n(op, init, 〈??〉));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0696"></a><sub>}</sub></p>
</section>
<section>
<h5><a id="c002_c2-sec-0053"></a><a id="c002_c2-title-0054"></a>Exercise 2.37</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0697"></a>Suppose we represent vectors <i>v</i> = (<i>v<sub>i</sub></i>) as sequences of numbers, and matrices <i>m</i> = (<i>m<sub>ij</sub></i>) as sequences of vectors (the rows of the matrix). For example, the matrix</p>
<p><a id="c002_c2-para-0698"></a></p>
<figure id="c002_c2-fig-0013"><img alt="c2-fig-5006.jpg" src="../images/c2-fig-5006.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-0699"></a>is represented as the following sequence:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0700"></a>list(list(1, 2, 3, 4),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0701"></a>     list(4, 5, 6, 6),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0702"></a>     list(6, 7, 8, 9))</p>
<p class="paracontinue"><a id="c002_c2-para-0703"></a>With this representation, we can use sequence operations to concisely express the basic matrix and vector operations. These operations (which are described in any book on matrix algebra) are the following:</p>
<p><a id="c002_c2-para-0704"></a></p>
<figure id="c002_c2-fig-0014"><img alt="c2-fig-5007.jpg" src="../images/c2-fig-5007.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-0705"></a>We can define the dot product as<a id="c002_c2-fn-0015a"></a><a href="#c2-fn-0015"><sup>15</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0706"></a><b>function</b> dot_product(v, w) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0707"></a> <b>return</b> accumulate(plus, 0, accumulate_n(times, 1, list(v, w)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0708"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0709"></a>Fill in the missing expressions in the following functions for computing the other matrix operations. (The function <span class="KeyTerm1">accumulate_n</span> is declared in exercise 2.36.)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0710"></a><b>function</b> matrix_times_vector(m, v) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0711"></a> <b>return</b> map( ?? , m);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0712"></a><sub>}</sub></p>
<p class="Sp-text-1"><a id="c002_c2-para-0713"></a><b>function</b> transpose(mat) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0714"></a> <b>return</b> accumulate_n( ?? , ?? , mat);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0715"></a><sub>}</sub></p>
<p class="Sp-text-1"><a id="c002_c2-para-0716"></a><b>function</b> matrix_times_matrix(n, m) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0717"></a> <b>const</b> cols = transpose(n);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0718"></a> <b>return</b> map( ?? , m);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0719"></a><sub>}</sub></p>
</section>
<section>
<h5><a id="c002_c2-sec-0054"></a><a id="c002_c2-title-0055"></a>Exercise 2.38</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0720"></a>The <span class="KeyTerm1">accumulate</span> function is also known as <span class="KeyTerm1">fold_right</span>, because it combines the first element of the sequence with the result of combining all the elements to the right. There is also a <span class="KeyTerm1">fold_left</span>, which is similar to <span class="KeyTerm1">fold_right</span>, except that it combines elements working in the opposite direction:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0721"></a><b>function</b> fold_left(op, initial, sequence) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0722"></a> <b>function</b> iter(result, rest) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0723"></a> <b>return</b> is_null(rest)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0724"></a>               ? result</p>
<p class="Sp-text-1"><a id="c002_c2-para-0725"></a>               : iter(op(result, head(rest)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0726"></a>                      tail(rest));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0727"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0728"></a> <b>return</b> iter(initial, sequence);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0729"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0730"></a>What are the values of</p>
<p class="Sp-text-1"><a id="c002_c2-para-0731"></a>fold_right(divide, 1, list(1, 2, 3));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0732"></a>fold_left(divide, 1, list(1, 2, 3));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0733"></a>fold_right(list, <b>null</b>, list(1, 2, 3));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0734"></a>fold_left(list, <b>null</b>, list(1, 2, 3));</p>
<p class="paracontinue"><a id="c002_c2-para-0735"></a>Give a property that <span class="KeyTerm1">op</span> should satisfy to guarantee that <span class="KeyTerm1">fold_right</span> and <span class="KeyTerm1">fold_left</span> will produce the same values for any sequence.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0055"></a><a id="c002_c2-title-0056"></a>Exercise 2.39</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0736"></a>Complete the following definitions of <span class="KeyTerm1">reverse</span> (exercise 2.18) in terms of <span class="KeyTerm1">fold_right</span> and <span class="KeyTerm1">fold_left</span> from exercise 2.38:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0737"></a><b>function</b> reverse(sequence) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0738"></a> <b>return</b> fold_right((x, y) =&gt; ?? , <b>null</b>, sequence);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0739"></a><sub>}</sub></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0740"></a><b>function</b> reverse(sequence) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0741"></a> <b>return</b> fold_left((x, y) =&gt; ?? , <b>null</b>, sequence);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0742"></a><sub>}</sub></p>
</section>
<section>
<h5><a id="c002_c2-sec-0056"></a><a id="c002_c2-title-0057"></a>Nested Mappings</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0743"></a>We can extend the sequence paradigm to include many computations that are commonly expressed using nested loops.<a id="c002_c2-fn-0016a"></a><a href="#c2-fn-0016"><sup>16</sup></a> Consider this problem: Given a positive integer <i>n</i>, find all ordered pairs of distinct positive integers <i>i</i> and <i>j</i>, where 1 <i>j</i> &lt; <i>i n</i>, such that <i>i</i> + <i>j</i> is prime. For example, if <i>n</i> is 6, then the pairs are the following:</p>
<figure><figcaption class="tablecaption"><a id="c002_c2-tbl-0001"></a></figcaption>
<div class="big_device">
<table border="1"><tbody>
<tr>
<td><a id="c002_c2-para-0744"></a><i>i</i></td>
<td><a id="c002_c2-para-0745"></a>2</td>
<td><a id="c002_c2-para-0746"></a>3</td>
<td><a id="c002_c2-para-0747"></a>4</td>
<td><a id="c002_c2-para-0748"></a>4</td>
<td><a id="c002_c2-para-0749"></a>5</td>
<td><a id="c002_c2-para-0750"></a>6</td>
<td><a id="c002_c2-para-0751"></a>6</td></tr>
<tr>
<td><a id="c002_c2-para-0752"></a><i>j</i></td>
<td><a id="c002_c2-para-0753"></a>1</td>
<td><a id="c002_c2-para-0754"></a>2</td>
<td><a id="c002_c2-para-0755"></a>1</td>
<td><a id="c002_c2-para-0756"></a>3</td>
<td><a id="c002_c2-para-0757"></a>2</td>
<td><a id="c002_c2-para-0758"></a>1</td>
<td><a id="c002_c2-para-0759"></a>5</td></tr>
<tr>
<td><a id="c002_c2-para-0760"></a><i>i</i> + <i>j</i></td>
<td><a id="c002_c2-para-0761"></a>3</td>
<td><a id="c002_c2-para-0762"></a>5</td>
<td><a id="c002_c2-para-0763"></a>5</td>
<td><a id="c002_c2-para-0764"></a>7</td>
<td><a id="c002_c2-para-0765"></a>7</td>
<td><a id="c002_c2-para-0766"></a>7</td>
<td><a id="c002_c2-para-0767"></a>11</td></tr></tbody></table></div>
</figure>
<p class="paracontinue"><a id="c002_c2-para-0768"></a>A natural way to organize this computation is to generate the sequence of all ordered pairs of positive integers less than or equal to <i>n</i>, filter to select those pairs whose sum is prime, and then, for each pair (<i>i</i>, <i>j</i>) that passes through the filter, produce the triple (<i>i</i>, <i>j</i>, <i>i</i> + <i>j</i>).</p>
<p><a id="c002_c2-para-0769"></a>Here is a way to generate the sequence of pairs: For each integer <i>i n</i>, enumerate the integers <i>j</i> &lt; <i>i</i>, and for each such <i>i</i> and <i>j</i> generate the pair (<i>i</i>, <i>j</i>). In terms of sequence operations, we map along the sequence <span class="KeyTerm1">enumerate_interval(1, n)</span>. For each <i>i</i> in this sequence, we map along the sequence <span class="KeyTerm1">enumerate_interval(1, i - 1)</span>. For each <i>j</i> in this latter sequence, we generate the pair <span class="KeyTerm1">list(i, j)</span>. This gives us a sequence of pairs for each <i>i</i>. Combining all the sequences for all the <i>i</i> (by accumulating with <span class="KeyTerm1">append</span>) produces the required sequence of pairs:<a id="c002_c2-fn-0017a"></a><a href="#c2-fn-0017"><sup>17</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0770"></a>accumulate(append,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0771"></a> <b>null</b>,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0772"></a>           map(i =&gt; map(j =&gt; list(i, j),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0773"></a>                        enumerate_interval(1, i - 1)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0774"></a>               enumerate_interval(1, n)));</p>
<p class="paracontinue"><a id="c002_c2-para-0775"></a>The combination of mapping and accumulating with <span class="KeyTerm1">append</span> is so common in this sort of program that we will isolate it as a separate function:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0776"></a><b>function</b> flatmap(f, seq) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0777"></a> <b>return</b> accumulate(append, <b>null</b>, map(f, seq));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0778"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0779"></a>Now filter this sequence of pairs to find those whose sum is prime. The filter predicate is called for each element of the sequence; its argument is a pair and it must extract the integers from the pair. Thus, the predicate to apply to each element in the sequence is</p>
<p class="Sp-text-1"><a id="c002_c2-para-0780"></a><b>function</b> is_prime_sum(pair) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0781"></a> <b>return</b> is_prime(head(pair) + head(tail(pair)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0782"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0783"></a>Finally, generate the sequence of results by mapping over the filtered pairs using the following function, which constructs a triple consisting of the two elements of the pair along with their sum:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0784"></a><b>function</b> make_pair_sum(pair) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0785"></a> <b>return</b> list(head(pair), head(tail(pair)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0786"></a>                head(pair) + head(tail(pair)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0787"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0788"></a>Combining all these steps yields the complete function:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0789"></a><b>function</b> prime_sum_pairs(n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0790"></a> <b>return</b> map(make_pair_sum,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0791"></a>               filter(is_prime_sum,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0792"></a>                      flatmap(i =&gt; map(j =&gt; list(i, j),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0793"></a>                                       enumerate_interval(1, i - 1)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0794"></a>                              enumerate_interval(1, n))));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0795"></a>}</p>
<p><a id="c002_c2-para-0796"></a>Nested mappings are also useful for sequences other than those that enumerate intervals. Suppose we wish to generate all the permutations of a set <i>S</i>; that is, all the ways of ordering the items in the set. For instance, the permutations of {1, 2, 3} are {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, and {3, 2, 1}. Here is a plan for generating the permutations of <i>S</i>: For each item <i>x</i> in <i>S</i>, recursively generate the sequence of permutations of <i>S</i> – <i>x</i>,<a id="c002_c2-fn-0018a"></a><a href="#c2-fn-0018"><sup>18</sup></a> and adjoin <i>x</i> to the front of each one. This yields, for each <i>x</i> in <i>S</i>, the sequence of permutations of <i>S</i> that begin with <i>x</i>. Combining these sequences for all <i>x</i> gives all the permutations of <i>S</i>:<a id="c002_c2-fn-0019a"></a><a href="#c2-fn-0019"><sup>19</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0797"></a><b>function</b> permutations(s) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0798"></a> <b>return</b> is_null(s) <span class="KeyTerm2"><i>// empty set?</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-0799"></a>           ? list(<b>null</b>) <span class="KeyTerm2"><i>// sequence containing empty set</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-0800"></a>           : flatmap(x =&gt; map(p =&gt; pair(x, p),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0801"></a>                              permutations(remove(x, s))),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0802"></a>                     s);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0803"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0804"></a>Notice how this strategy reduces the problem of generating permutations of <i>S</i> to the problem of generating the permutations of sets with fewer elements than <i>S</i>. In the terminal case, we work our way down to the empty list, which represents a set of no elements. For this, we generate <span class="KeyTerm1">list(<b>null</b>)</span>, which is a sequence with one item, namely the set with no elements. The <span class="KeyTerm1">remove</span> function used in <span class="KeyTerm1">permutations</span> returns all the items in a given sequence except for a given item. This can be expressed as a simple filter:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0805"></a><b>function</b> remove(item, sequence) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0806"></a> <b>return</b> filter(x =&gt; ! (x === item),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0807"></a>                  sequence);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0808"></a>}</p>
</section>
<section>
<h5><a id="c002_c2-sec-0057"></a><a id="c002_c2-title-0058"></a>Exercise 2.40</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0809"></a>Write a function <span class="KeyTerm1">unique_pairs</span> that, given an integer <i>n</i>, generates the sequence of pairs (<i>i</i>, <i>j</i>) with 1 <i>j</i> &lt; <i>i n</i>. Use <span class="KeyTerm1">unique_pairs</span> to simplify the definition of <span class="KeyTerm1">prime_sum_pairs</span> given above.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0058"></a><a id="c002_c2-title-0059"></a>Exercise 2.41</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0810"></a>Write a function to find all ordered triples of distinct positive integers <i>i</i>, <i>j</i>, and <i>k</i> less than or equal to a given integer <i>n</i> that sum to a given integer <i>s</i>.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0059"></a><a id="c002_c2-title-0060"></a>Exercise 2.42</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0811"></a>The “eight-queens puzzle” asks how to place eight queens on a chessboard so that no queen is in check from any other (i.e., no two queens are in the same row, column, or diagonal). One possible solution is shown in <a id="c002_c2-fig-0015a"></a><a href="#c2-fig-0015">figure 2.8</a>. One way to solve the puzzle is to work across the board, placing a queen in each column. Once we have placed <i>k</i> – 1 queens, we must place the <i>k</i>th queen in a position where it does not check any of the queens already on the board. We can formulate this approach recursively: Assume that we have already generated the sequence of all possible ways to place <i>k</i> – 1 queens in the first <i>k</i> – 1 columns of the board. For each of these ways, generate an extended set of positions by placing a queen in each row of the <i>k</i>th column. Now filter these, keeping only the positions for which the queen in the <i>k</i>th column is safe with respect to the other queens. This produces the sequence of all ways to place <i>k</i> queens in the first <i>k</i> columns. By continuing this process, we will produce not only one solution, but all solutions to the puzzle.</p>
<figure id="c002_c2-fig-0015"><img alt="c2-fig-0008.jpg" src="../images/c2-fig-0008.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0015a">Figure 2.8</a></span> <a id="c002_c2-para-0812"></a>A solution to the eight-queens puzzle.</p></figcaption></figure>
<p><a id="c002_c2-para-0813"></a>We implement this solution as a function <span class="KeyTerm1">queens</span>, which returns a sequence of all solutions to the problem of placing <i>n</i> queens on an <i>n n</i> chessboard. The function <span class="KeyTerm1">queens</span> has an internal function <span class="KeyTerm1">queens_cols</span> that returns the sequence of all ways to place queens in the first <i>k</i> columns of the board.</p>
<p class="Sp-text-1"><a id="c002_c2-para-0814"></a><b>function</b> queens(board_size) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0815"></a> <b>function</b> queen_cols(k) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0816"></a> <b>return</b> k === 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-0817"></a>               ? list(empty_board)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0818"></a>               : filter(positions =&gt; is_safe(k, positions),</p>
<p class="Sp-text-1"><a id="c002_c2-para-5818"></a>                        flatmap(rest_of_queens =&gt;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0819"></a>                                  map(new_row =&gt;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0820"></a>                                        adjoin_position(new_row, k,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0821"></a>                                                        rest_of_queens),</p>
<p class="Sp-text-1"><a id="c002_c2-para-5821"></a>                                      enumerate_interval(1, board_size)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0822"></a>                                queen_cols(k - 1)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0823"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0824"></a> <b>return</b> queen_cols(board_size);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0825"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0826"></a>In this function <span class="KeyTerm1">rest_of_queens</span> is a way to place <i>k</i> – 1 queens in the first <i>k</i> – 1 columns, and <span class="KeyTerm1">new_row</span> is a proposed row in which to place the queen for the <i>k</i>th column. Complete the program by implementing the representation for sets of board positions, including the function <span class="KeyTerm1">adjoin_position</span>, which adjoins a new row-column position to a set of positions, and <span class="KeyTerm1">empty_board</span>, which represents an empty set of positions. You must also write the function <span class="KeyTerm1">is_safe</span>, which determines for a set of positions whether the queen in the <i>k</i>th column is safe with respect to the others. (Note that we need only check whether the new queen is safe—the other queens are already guaranteed safe with respect to each other.)</p>
</section>
<section>
<h5><a id="c002_c2-sec-0060"></a><a id="c002_c2-title-0061"></a>Exercise 2.43</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0827"></a>Louis Reasoner is having a terrible time doing exercise 2.42. His <span class="KeyTerm1">queens</span> function seems to work, but it runs extremely slowly. (Louis never does manage to wait long enough for it to solve even the 6 6 case.) When Louis asks Eva Lu Ator for help, she points out that he has interchanged the order of the nested mappings in the <span class="KeyTerm1">flatmap</span>, writing it as</p>
<p class="Sp-text-1"><a id="c002_c2-para-0828"></a>flatmap(new_row =&gt;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0829"></a>          map(rest_of_queens =&gt;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0830"></a>                adjoin_position(new_row, k, rest_of_queens),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0831"></a>              queen_cols(k - 1)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0832"></a>        enumerate_interval(1, board_size));</p>
<p class="paracontinue"><a id="c002_c2-para-0833"></a>Explain why this interchange makes the program run slowly. Estimate how long it will take Louis's program to solve the eight-queens puzzle, assuming that the program in exercise 2.42 solves the puzzle in time <i>T</i>.</p>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0061"></a><span>2.2.4</span> <a id="c002_c2-title-0062"></a>Example: A Picture Language</h3>
<p class="paraaftertitle"><a id="c002_c2-para-0834"></a>This section presents a simple language for drawing pictures that illustrates the power of data abstraction and closure, and also exploits higher-order functions in an essential way. The language is designed to make it easy to experiment with patterns such as the ones in <a id="c002_c2-fig-0016a"></a><a href="#c2-fig-0016">figure 2.9</a>, which are composed of repeated elements that are shifted and scaled.<a id="c002_c2-fn-0020a"></a><a href="#c2-fn-0020"><sup>20</sup></a> In this language, the data objects being combined are represented as functions rather than as list structure. Just as <span class="KeyTerm1">pair</span>, which satisfies the closure property, allowed us to easily build arbitrarily complicated list structure, the operations in this language, which also satisfy the closure property, allow us to easily build arbitrarily complicated patterns.</p>
<figure id="c002_c2-fig-0016"><img alt="c2-fig-0009.jpg" src="../images/c2-fig-0009.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0016a">Figure 2.9</a></span> <a id="c002_c2-para-0835"></a>Designs generated with the picture language.</p></figcaption></figure>
<section>
<h5><a id="c002_c2-sec-0062"></a><a id="c002_c2-title-0063"></a>The picture language</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0836"></a>When we began our study of programming in section 1.1, we emphasized the importance of describing a language by focusing on the language's primitives, its means of combination, and its means of abstraction. We'll follow that framework here.</p>
<p><a id="c002_c2-para-0837"></a>Part of the elegance of this picture language is that there is only one kind of element, called a <i>painter</i>. A painter draws an image that is shifted and scaled to fit within a designated parallelogram-shaped frame. For example, there's a primitive painter we'll call <span class="KeyTerm1">wave</span> that makes a crude line drawing, as shown in <a id="c002_c2-fig-0017a"></a><a href="#c2-fig-0017">figure 2.10</a>. The actual shape of the drawing depends on the frame—all four images in <a href="#c2-fig-0017">figure 2.10</a> are produced by the same <span class="KeyTerm1">wave</span> painter, but with respect to four different frames. Painters can be more elaborate than this: The primitive painter called <span class="KeyTerm1">rogers</span> paints a picture of MIT's founder, William Barton Rogers, as shown in <a id="c002_c2-fig-0018a"></a><a href="#c2-fig-0018">figure 2.11</a>.<a id="c002_c2-fn-0021a"></a><a href="#c2-fn-0021"><sup>21</sup></a> The four images in <a href="#c2-fig-0018">figure 2.11</a> are drawn with respect to the same four frames as the <span class="KeyTerm1">wave</span> images in <a href="#c2-fig-0017">figure 2.10</a>.</p>
<figure id="c002_c2-fig-0017"><img alt="c2-fig-0010.jpg" src="../images/c2-fig-0010.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0017a">Figure 2.10</a></span> <a id="c002_c2-para-0838"></a>Images produced by the <span class="KeyTerm1">wave</span> painter, with respect to four different frames. The frames, shown with dashed lines, are not part of the images.</p></figcaption></figure>
<figure id="c002_c2-fig-0018"><img alt="c2-fig-0011.jpg" src="../images/c2-fig-0011.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0018a">Figure 2.11</a></span> <a id="c002_c2-para-0839"></a>Images of William Barton Rogers, founder and first president of MIT, painted with respect to the same four frames as in <a href="#c2-fig-0017">figure 2.10</a> (original image courtesy MIT Museum).</p></figcaption></figure>
<p><a id="c002_c2-para-0840"></a>To combine images, we use various operations that construct new painters from given painters. For example, the <span class="KeyTerm1">beside</span> operation takes two painters and produces a new, compound painter that draws the first painter's image in the left half of the frame and the second painter's image in the right half of the frame. Similarly, <span class="KeyTerm1">below</span> takes two painters and produces a compound painter that draws the first painter's image below the second painter's image. Some operations transform a single painter to produce a new painter. For example, <span class="KeyTerm1">flip_vert</span> takes a painter and produces a painter that draws its image upside-down, and <span class="KeyTerm1">flip_horiz</span> produces a painter that draws the original painter's image left-to-right reversed.</p>
<p><a id="c002_c2-para-0848"></a><a id="c002_c2-fig-0019a"></a><a href="#c2-fig-0019">Figure 2.12</a> shows the drawing of a painter called <span class="KeyTerm1">wave4</span> that is built up in two stages starting from <span class="KeyTerm1">wave</span>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0850"></a><b>const</b> wave2 = beside(wave, flip_vert(wave));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0851"></a><b>const</b> wave4 = below(wave2, wave2);</p>
<p class="paracontinue"><a id="c002_c2-para-0852"></a>In building up a complex image in this manner we are exploiting the fact that painters are closed under the language's means of combination. The <span class="KeyTerm1">beside</span> or <span class="KeyTerm1">below</span> of two painters is itself a painter; therefore, we can use it as an element in making more complex painters. As with building up list structure using <span class="KeyTerm1">pair</span>, the closure of our data under the means of combination is crucial to the ability to create complex structures while using only a few operations.</p>
<figure id="c002_c2-fig-0019"><img alt="c2-fig-0012.jpg" src="../images/c2-fig-0012.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0019a">Figure 2.12</a></span> <a id="c002_c2-para-0849"></a>Creating a complex figure, starting from the <span class="KeyTerm1">wave</span> painter of <a href="#c2-fig-0017">figure 2.10</a>.</p></figcaption></figure>
<p><a id="c002_c2-para-0853"></a>Once we can combine painters, we would like to be able to abstract typical patterns of combining painters. We will implement the painter operations as JavaScript functions. This means that we don't need a special abstraction mechanism in the picture language: Since the means of combination are ordinary JavaScript functions, we automatically have the capability to do anything with painter operations that we can do with functions. For example, we can abstract the pattern in <span class="KeyTerm1">wave4</span> as</p>
<p class="Sp-text-1"><a id="c002_c2-para-0854"></a><b>function</b> flipped_pairs(painter) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0855"></a> <b>const</b> painter2 = beside(painter, flip_vert(painter));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0856"></a> <b>return</b> below(painter2, painter2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0857"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0858"></a>and declare <span class="KeyTerm1">wave4</span> as an instance of this pattern:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0859"></a><b>const</b> wave4 = flipped_pairs(wave);</p>
<p><a id="c002_c2-para-0860"></a>We can also define recursive operations. Here's one that makes painters split and branch towards the right as shown in <a id="c002_c2-fig-0020a"></a><a id="c002_c2-fig-0021a"></a><a href="#c2-fig-0020">figures 2.13 and 2.14</a>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0863"></a><b>function</b> right_split(painter, n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0864"></a> <b>if</b> (n === 0) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0865"></a> <b>return</b> painter;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0866"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0867"></a> <b>const</b> smaller = right_split(painter, n - 1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0868"></a> <b>return</b> beside(painter, below(smaller, smaller));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0869"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0870"></a>}</p>
<figure id="c002_c2-fig-0020"><img alt="c2-fig-0013.jpg" src="../images/c2-fig-0013.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0020a">Figure 2.13</a></span> <a id="c002_c2-para-0861"></a>Recursive plans for <span class="KeyTerm1">right_split</span> and <span class="KeyTerm1">corner_split</span>.</p></figcaption></figure>
<figure id="c002_c2-fig-0021"><img alt="c2-fig-0014.jpg" src="../images/c2-fig-0014.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0021a">Figure 2.14</a></span> <a id="c002_c2-para-0862"></a>The recursive operation <span class="KeyTerm1">right_split</span> applied to the painters <span class="KeyTerm1">wave</span> and <span class="KeyTerm1">rogers</span>. Combining four <span class="KeyTerm1">corner_split</span> figures produces symmetric <span class="KeyTerm1">square_limit</span> as shown in <a href="#c2-fig-0016">figure 2.9</a>.</p></figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-0871"></a>We can produce balanced patterns by branching upwards as well as towards the right (see exercise 2.44 and <a href="#c2-fig-0020">figures 2.13 and 2.14</a>):</p>
<p class="Sp-text-1"><a id="c002_c2-para-0872"></a><b>function</b> corner_split(painter, n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0873"></a> <b>if</b> (n === 0) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0874"></a> <b>return</b> painter;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0875"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0876"></a> <b>const</b> up = up_split(painter, n - 1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0877"></a> <b>const</b> right = right_split(painter, n - 1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0878"></a> <b>const</b> top_left = beside(up, up);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0879"></a> <b>const</b> bottom_right = below(right, right);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0880"></a> <b>const</b> corner = corner_split(painter, n - 1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0881"></a> <b>return</b> beside(below(painter, top_left),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0882"></a>                      below(bottom_right, corner));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0883"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-0884"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0885"></a>By placing four copies of a <span class="KeyTerm1">corner_split</span> appropriately, we obtain a pattern called <span class="KeyTerm1">square_limit</span>, whose application to <span class="KeyTerm1">wave</span> and <span class="KeyTerm1">rogers</span> is shown in <a href="#c2-fig-0016">figure 2.9</a>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0886"></a><b>function</b> square_limit(painter, n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0887"></a> <b>const</b> quarter = corner_split(painter, n);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0888"></a> <b>const</b> half = beside(flip_horiz(quarter), quarter);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0889"></a> <b>return</b> below(flip_vert(half), half);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0890"></a>}</p>
</section>
<section>
<h5><a id="c002_c2-sec-0063"></a><a id="c002_c2-title-0064"></a>Exercise 2.44</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0891"></a>Declare the function <span class="KeyTerm1">up_split</span> used by <span class="KeyTerm1">corner_split</span>. It is similar to <span class="KeyTerm1">right_split</span>, except that it switches the roles of <span class="KeyTerm1">below</span> and <span class="KeyTerm1">beside</span>.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0064"></a><a id="c002_c2-title-0065"></a>Higher-order operations</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0892"></a>In addition to abstracting patterns of combining painters, we can work at a higher level, abstracting patterns of combining painter operations. That is, we can view the painter operations as elements to manipulate and can write means of combination for these elements—functions that take painter operations as arguments and create new painter operations.</p>
<p><a id="c002_c2-para-0893"></a>For example, <span class="KeyTerm1">flipped_pairs</span> and <span class="KeyTerm1">square_limit</span> each arrange four copies of a painter's image in a square pattern; they differ only in how they orient the copies. One way to abstract this pattern of painter combination is with the following function, which takes four one-argument painter operations and produces a painter operation that transforms a given painter with those four operations and arranges the results in a square.<a id="c002_c2-fn-0022a"></a><a href="#c2-fn-0022"><sup>22</sup></a> The functions <span class="KeyTerm1">tl</span>, <span class="KeyTerm1">tr</span>, <span class="KeyTerm1">bl</span>, and <span class="KeyTerm1">br</span> are the transformations to apply to the top left copy, the top right copy, the bottom left copy, and the bottom right copy, respectively.</p>
<p class="Sp-text-1"><a id="c002_c2-para-0894"></a><b>function</b> square_of_four(tl, tr, bl, br) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0895"></a> <b>return</b> painter =&gt; {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0896"></a> <b>const</b> top = beside(tl(painter), tr(painter));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0897"></a> <b>const</b> bottom = beside(bl(painter), br(painter));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0898"></a> <b>return</b> below(bottom, top);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0899"></a>    };</p>
<p class="Sp-text-1"><a id="c002_c2-para-0900"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0901"></a>Then <span class="KeyTerm1">flipped_pairs</span> can be defined in terms of <span class="KeyTerm1">square_of_four</span> as follows:<a id="c002_c2-fn-0023a"></a><a href="#c2-fn-0023"><sup>23</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0902"></a><b>function</b> flipped_pairs(painter) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0903"></a> <b>const</b> combine4 = square_of_four(identity, flip_vert,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0904"></a>                                    identity, flip_vert);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0905"></a> <b>return</b> combine4(painter);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0906"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0907"></a>and <span class="KeyTerm1">square_limit</span> can be expressed as<a id="c002_c2-fn-0024a"></a><a href="#c2-fn-0024"><sup>24</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0908"></a><b>function</b> square_limit(painter, n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0909"></a> <b>const</b> combine4 = square_of_four(flip_horiz, identity,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0910"></a>                                    rotate180, flip_vert);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0911"></a> <b>return</b> combine4(corner_split(painter, n));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0912"></a>}</p>
</section>
<section>
<h5><a id="c002_c2-sec-0065"></a><a id="c002_c2-title-0066"></a>Exercise 2.45</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0913"></a>The functions <span class="KeyTerm1">right_split</span> and <span class="KeyTerm1">up_split</span> can be expressed as instances of a general splitting operation. Declare a function <span class="KeyTerm1">split</span> with the property that evaluating</p>
<p class="Sp-text-1"><a id="c002_c2-para-0914"></a><b>const</b> right_split = split(beside, below);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0915"></a><b>const</b> up_split = split(below, beside);</p>
<p class="paracontinue"><a id="c002_c2-para-0916"></a>produces functions <span class="KeyTerm1">right_split</span> and <span class="KeyTerm1">up_split</span> with the same behaviors as the ones already declared.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0066"></a><a id="c002_c2-title-0067"></a>Frames</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0917"></a>Before we can show how to implement painters and their means of combination, we must first consider frames. A frame can be described by three vectors—an origin vector and two edge vectors. The origin vector specifies the offset of the frame's origin from some absolute origin in the plane, and the edge vectors specify the offsets of the frame's corners from its origin. If the edges are perpendicular, the frame will be rectangular. Otherwise the frame will be a more general parallelogram.</p>
<p><a id="c002_c2-para-0918"></a><a id="c002_c2-fig-0022a"></a><a href="#c2-fig-0022">Figure 2.15</a> shows a frame and its associated vectors. In accordance with data abstraction, we need not be specific yet about how frames are represented, other than to say that there is a constructor <span class="KeyTerm1">make_frame</span>, which takes three vectors and produces a frame, and three corresponding selectors <span class="KeyTerm1">origin_frame</span>, <span class="KeyTerm1">edge1_frame</span>, and <span class="KeyTerm1">edge2_frame</span> (see exercise 2.47).</p>
<figure id="c002_c2-fig-0022"><img alt="c2-fig-0015.jpg" src="../images/c2-fig-0015.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0022a">Figure 2.15</a></span> <a id="c002_c2-para-0919"></a>A frame is described by three vectors—an origin and two edges.</p></figcaption></figure>
<p><a id="c002_c2-para-0920"></a>We will use coordinates in the unit square (0 ≤ <i>x</i>, <i>y</i> ≤ 1) to specify images. With each frame, we associate a <i>frame coordinate map</i>, which will be used to shift and scale images to fit the frame. The map transforms the unit square into the frame by mapping the vector <b>v</b> = (<i>x</i>, <i>y</i>) to the vector sum</p>
<p class="Sp-text-2"><a id="c002_c2-para-0921"></a>Origin(Frame) + <i>x</i> · Edge<sub>1</sub> (Frame) + <i>y ·</i> Edge<sub>2</sub> (Frame)</p>
<p class="paracontinue"><a id="c002_c2-para-0924"></a>For example, (0, 0) is mapped to the origin of the frame, (1, 1) to the vertex diagonally opposite the origin, and (0.5, 0.5) to the center of the frame. We can create a frame's coordinate map with the following function:<a id="c002_c2-fn-0025a"></a><a href="#c2-fn-0025"><sup>25</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0925"></a><b>function</b> frame_coord_map(frame) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0926"></a> <b>return</b> v =&gt; add_vect(origin_frame(frame),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0927"></a>                         add_vect(scale_vect(xcor_vect(v),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0928"></a>                                             edge1_frame(frame)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0929"></a>                                  scale_vect(ycor_vect(v),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0930"></a>                                             edge2_frame(frame))));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0931"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0932"></a>Observe that applying <span class="KeyTerm1">frame_coord_map</span> to a frame returns a function that, given a vector, returns a vector. If the argument vector is in the unit square, the result vector will be in the frame. For example,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0933"></a>frame_coord_map(a_frame)(make_vect(0, 0)); </p>
<p class="paracontinue"><a id="c002_c2-para-0934"></a>returns the same vector as</p>
<p class="Sp-text-1"><a id="c002_c2-para-0935"></a>origin_frame(a_frame);</p>
</section>
<section>
<h5><a id="c002_c2-sec-0067"></a><a id="c002_c2-title-0068"></a>Exercise 2.46</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0936"></a>A two-dimensional vector <i>v</i> running from the origin to a point can be represented as a pair consisting of an <i>x</i>-coordinate and a <i>y</i>-coordinate. Implement a data abstraction for vectors by giving a constructor <span class="KeyTerm1">make_vect</span> and corresponding selectors <span class="KeyTerm1">xcor_vect</span> and <span class="KeyTerm1">ycor_vect</span>. In terms of your selectors and constructor, implement functions <span class="KeyTerm1">add_vect</span>, <span class="KeyTerm1">sub_vect</span>, and <span class="KeyTerm1">scale_vect</span> that perform the operations vector addition, vector subtraction, and multiplying a vector by a scalar:</p>
<figure><figcaption class="tablecaption"><a id="c002_c2-tbl-0002"></a></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c002_c2-para-0937"></a>(<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>) + (<i>x</i><sub>2</sub>, <i>y</i><sub>2</sub>)</td>
<td><a id="c002_c2-para-0938"></a>=</td>
<td><a id="c002_c2-para-0939"></a>(<i>x</i><sub>1</sub> + <i>x</i><sub>2</sub>, <i>y</i><sub>1</sub> + <i>y</i><sub>2</sub>)</td></tr>
<tr>
<td><a id="c002_c2-para-0940"></a>(<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>) – (<i>x</i><sub>2</sub>, <i>y</i><sub>2</sub>)</td>
<td><a id="c002_c2-para-0941"></a>=</td>
<td><a id="c002_c2-para-0942"></a>(<i>x</i><sub>1</sub> – <i>x</i><sub>2</sub>, <i>y</i><sub>1</sub> – <i>y</i><sub>2</sub>)</td></tr>
<tr>
<td><a id="c002_c2-para-0943"></a><i>s ·</i> (<i>x</i>, <i>y</i>)</td>
<td><a id="c002_c2-para-0944"></a>=</td>
<td><a id="c002_c2-para-0945"></a>(<i>sx</i>, <i>sy</i>)</td></tr></tbody></table></div></figure>
</section>
<section>
<h5><a id="c002_c2-sec-0068"></a><a id="c002_c2-title-0069"></a>Exercise 2.47</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0946"></a>Here are two possible constructors for frames:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0947"></a><b>function</b> make_frame(origin, edge1, edge2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0948"></a> <b>return</b> list(origin, edge1, edge2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0949"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-0950"></a><b>function</b> make_frame(origin, edge1, edge2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0951"></a> <b>return</b> pair(origin, pair(edge1, edge2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0952"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0953"></a>For each constructor supply the appropriate selectors to produce an implementation for frames.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0069"></a><a id="c002_c2-title-0070"></a>Painters</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0954"></a>A painter is represented as a function that, given a frame as argument, draws a particular image shifted and scaled to fit the frame. That is to say, if <span class="KeyTerm1">p</span> is a painter and <span class="KeyTerm1">f</span> is a frame, then we produce <span class="KeyTerm1">p</span>'s image in <span class="KeyTerm1">f</span> by calling <span class="KeyTerm1">p</span> with <span class="KeyTerm1">f</span> as argument.</p>
<p><a id="c002_c2-para-0955"></a>The details of how primitive painters are implemented depend on the particular characteristics of the graphics system and the type of image to be drawn. For instance, suppose we have a function <span class="KeyTerm1">draw_line</span> that draws a line on the screen between two specified points. Then we can create painters for line drawings, such as the <span class="KeyTerm1">wave</span> painter in <a href="#c2-fig-0017">figure 2.10</a>, from lists of line segments as follows:<a id="c002_c2-fn-0026a"></a><a href="#c2-fn-0026"><sup>26</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-0956"></a><b>function</b> segments_to_painter(segment_list) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0957"></a> <b>return</b> frame =&gt;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0958"></a>             for_each(segment =&gt;</p>
<p class="Sp-text-1"><a id="c002_c2-para-0959"></a>                        draw_line(</p>
<p class="Sp-text-1"><a id="c002_c2-para-0960"></a>                            frame_coord_map(frame)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0961"></a>                                (start_segment(segment)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0962"></a>                            frame_coord_map(frame)</p>
<p class="Sp-text-1"><a id="c002_c2-para-0963"></a>                                (end_segment(segment))),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0964"></a>                      segment_list);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0965"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0966"></a>The segments are given using coordinates with respect to the unit square. For each segment in the list, the painter transforms the segment endpoints with the frame coordinate map and draws a line between the transformed points.</p>
<p><a id="c002_c2-para-0967"></a>Representing painters as functions erects a powerful abstraction barrier in the picture language. We can create and intermix all sorts of primitive painters, based on a variety of graphics capabilities. The details of their implementation do not matter. Any function can serve as a painter, provided that it takes a frame as argument and draws something scaled to fit the frame.<a id="c002_c2-fn-0027a"></a><a href="#c2-fn-0027"><sup>27</sup></a></p>
</section>
<section>
<h5><a id="c002_c2-sec-0070"></a><a id="c002_c2-title-0071"></a>Exercise 2.48</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0968"></a>A directed line segment in the plane can be represented as a pair of vectors—the vector running from the origin to the start-point of the segment, and the vector running from the origin to the end-point of the segment. Use your vector representation from exercise 2.46 to define a representation for segments with a constructor <span class="KeyTerm1">make_segment</span> and selectors <span class="KeyTerm1">start_segment</span> and <span class="KeyTerm1">end_segment</span>.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0071"></a><a id="c002_c2-title-0072"></a>Exercise 2.49</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0969"></a>Use <span class="KeyTerm1">segments_to_painter</span> to define the following primitive painters:</p>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0026"></a><span>a. </span>The painter that draws the outline of the designated frame.</li>
<li><a id="c002_c2-li-0027"></a><span>b. </span>The painter that draws an “X” by connecting opposite corners of the frame.</li>
<li><a id="c002_c2-li-0028"></a><span>c. </span>The painter that draws a diamond shape by connecting the midpoints of the sides of the frame.</li>
<li><a id="c002_c2-li-0029"></a><span>d. </span>The <span class="KeyTerm1">wave</span> painter.</li>
</ol>
</section>
<section>
<h5><a id="c002_c2-sec-0072"></a><a id="c002_c2-title-0073"></a>Transforming and combining painters</h5>
<p class="paraaftertitle"><a id="c002_c2-para-0974"></a>An operation on painters (such as <span class="KeyTerm1">flip_vert</span> or <span class="KeyTerm1">beside</span>) works by creating a painter that invokes the original painters with respect to frames derived from the argument frame. Thus, for example, <span class="KeyTerm1">flip_vert</span> doesn't have to know how a painter works in order to flip it—it just has to know how to turn a frame upside down: The flipped painter just uses the original painter, but in the inverted frame.</p>
<p><a id="c002_c2-para-0975"></a>Painter operations are based on the function <span class="KeyTerm1">transform_painter</span>, which takes as arguments a painter and information on how to transform a frame and produces a new painter. The transformed painter, when called on a frame, transforms the frame and calls the original painter on the transformed frame. The arguments to <span class="KeyTerm1">transform_painter</span> are points (represented as vectors) that specify the corners of the new frame: When mapped into the frame, the first point specifies the new frame's origin and the other two specify the ends of its edge vectors. Thus, arguments within the unit square specify a frame contained within the original frame.</p>
<p class="Sp-text-1"><a id="c002_c2-para-0976"></a><b>function</b> transform_painter(painter, origin, corner1, corner2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0977"></a> <b>return</b> frame =&gt; {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0978"></a> <b>const</b> m = frame_coord_map(frame);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0979"></a> <b>const</b> new_origin = m(origin);</p>
<p class="Sp-text-1"><a id="c002_c2-para-0980"></a> <b>return</b> painter(make_frame(</p>
<p class="Sp-text-1"><a id="c002_c2-para-0981"></a>                                new_origin,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0982"></a>                                sub_vect(m(corner1), new_origin),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0983"></a>                                sub_vect(m(corner2), new_origin)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0984"></a>           };</p>
<p class="Sp-text-1"><a id="c002_c2-para-0985"></a>}</p>
<p><a id="c002_c2-para-0986"></a>Here's how to flip painter images vertically:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0987"></a><b>function</b> flip_vert(painter) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0988"></a> <b>return</b> transform_painter(painter,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0989"></a>                             make_vect(0, 1),  <span class="KeyTerm2"><i>// new origin</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-0990"></a>                             make_vect(1, 1),  <span class="KeyTerm2"><i>// new end of edge1</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-0991"></a>                             make_vect(0, 0)); <span class="KeyTerm2"><i>// new end of edge2</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-0992"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-0993"></a>Using <span class="KeyTerm1">transform_painter</span>, we can easily define new transformations. For example, we can declare a painter that shrinks its image to the upper-right quarter of the frame it is given:</p>
<p class="Sp-text-1"><a id="c002_c2-para-0994"></a><b>function</b> shrink_to_upper_right(painter) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-0995"></a> <b>return</b> transform_painter(painter,</p>
<p class="Sp-text-1"><a id="c002_c2-para-0996"></a>                             make_vect(0.5, 0.5),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0997"></a>                             make_vect(1, 0.5),</p>
<p class="Sp-text-1"><a id="c002_c2-para-0998"></a>                             make_vect(0.5, 1));</p>
<p class="Sp-text-1"><a id="c002_c2-para-0999"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1000"></a>Other transformations rotate images counterclockwise by 90 degrees<a id="c002_c2-fn-0028a"></a><a href="#c2-fn-0028"><sup>28</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-1001"></a><b>function</b> rotate90(painter) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1002"></a> <b>return</b> transform_painter(painter,</p>
<p class="Sp-text-1"><a id="c002_c2-para-1003"></a>                             make_vect(1, 0),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1004"></a>                             make_vect(1, 1),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1005"></a>                             make_vect(0, 0));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1006"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1007"></a>or squash images towards the center of the frame:<a id="c002_c2-fn-0029a"></a><a href="#c2-fn-0029"><sup>29</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-1008"></a><b>function</b> squash_inwards(painter) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1009"></a> <b>return</b> transform_painter(painter,</p>
<p class="Sp-text-1"><a id="c002_c2-para-1010"></a>                             make_vect(0, 0),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1011"></a>                             make_vect(0.65, 0.35),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1012"></a>                             make_vect(0.35, 0.65));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1013"></a>}</p>
<p><a id="c002_c2-para-1014"></a>Frame transformation is also the key to defining means of combining two or more painters. The <span class="KeyTerm1">beside</span> function, for example, takes two painters, transforms them to paint in the left and right halves of an argument frame respectively, and produces a new, compound painter. When the compound painter is given a frame, it calls the first transformed painter to paint in the left half of the frame and calls the second transformed painter to paint in the right half of the frame:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1015"></a><b>function</b> beside(painter1, painter2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1016"></a> <b>const</b> split_point = make_vect(0.5, 0);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1017"></a> <b>const</b> paint_left = transform_painter(painter1,</p>
<p class="Sp-text-1"><a id="c002_c2-para-1018"></a>                                         make_vect(0, 0),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1019"></a>                                         split_point,</p>
<p class="Sp-text-1"><a id="c002_c2-para-1020"></a>                                         make_vect(0, 1));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1021"></a> <b>const</b> paint_right = transform_painter(painter2,</p>
<p class="Sp-text-1"><a id="c002_c2-para-1022"></a>                                         split_point,</p>
<p class="Sp-text-1"><a id="c002_c2-para-1023"></a>                                         make_vect(1, 0),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1024"></a>                                         make_vect(0.5, 1));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1025"></a> <b>return</b> frame =&gt; {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1026"></a>               paint_left(frame);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1027"></a>               paint_right(frame);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1028"></a>           };</p>
<p class="Sp-text-1"><a id="c002_c2-para-1029"></a>}</p>
<p><a id="c002_c2-para-1030"></a>Observe how the painter data abstraction, and in particular the representation of painters as functions, makes <span class="KeyTerm1">beside</span> easy to implement. The <span class="KeyTerm1">beside</span> function need not know anything about the details of the component painters other than that each painter will draw something in its designated frame.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0073"></a><a id="c002_c2-title-0074"></a>Exercise 2.50</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1031"></a>Declare the transformation <span class="KeyTerm1">flip_horiz</span>, which flips painters horizontally, and transformations that rotate painters counterclockwise by 180 degrees and 270 degrees.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0074"></a><a id="c002_c2-title-0075"></a>Exercise 2.51</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1032"></a>Declare the <span class="KeyTerm1">below</span> operation for painters. The function <span class="KeyTerm1">below</span> takes two painters as arguments. The resulting painter, given a frame, draws with the first painter in the bottom of the frame and with the second painter in the top. Define <span class="KeyTerm1">below</span> in two different ways—first by writing a function that is analogous to the <span class="KeyTerm1">beside</span> function given above, and again in terms of <span class="KeyTerm1">beside</span> and suitable rotation operations (from exercise 2.50).</p>
</section>
<section>
<h5><a id="c002_c2-sec-0075"></a><a id="c002_c2-title-0076"></a>Levels of language for robust design</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1033"></a>The picture language exploits some of the critical ideas we've introduced about abstraction with functions and data. The fundamental data abstractions, painters, are implemented using functional representations, which enables the language to handle different basic drawing capabilities in a uniform way. The means of combination satisfy the closure property, which permits us to easily build up complex designs. Finally, all the tools for abstracting functions are available to us for abstracting means of combination for painters.</p>
<p><a id="c002_c2-para-1034"></a>We have also obtained a glimpse of another crucial idea about languages and program design. This is the approach of <i>stratified design</i>, the notion that a complex system should be structured as a sequence of levels that are described using a sequence of languages. Each level is constructed by combining parts that are regarded as primitive at that level, and the parts constructed at each level are used as primitives at the next level. The language used at each level of a stratified design has primitives, means of combination, and means of abstraction appropriate to that level of detail.</p>
<p><a id="c002_c2-para-1035"></a>Stratified design pervades the engineering of complex systems. For example, in computer engineering, resistors and transistors are combined (and described using a language of analog circuits) to produce parts such as and-gates and or-gates, which form the primitives of a language for digital-circuit design.<a id="c002_c2-fn-0030a"></a><a href="#c2-fn-0030"><sup>30</sup></a> These parts are combined to build processors, bus structures, and memory systems, which are in turn combined to form computers, using languages appropriate to computer architecture. Computers are combined to form distributed systems, using languages appropriate for describing network interconnections, and so on.</p>
<p><a id="c002_c2-para-1036"></a>As a tiny example of stratification, our picture language uses primitive elements (primitive painters) that specify points and lines to provide the shapes of a painter like <span class="KeyTerm1">rogers</span>. The bulk of our description of the picture language focused on combining these primitives, using geometric combiners such as <span class="KeyTerm1">beside</span> and <span class="KeyTerm1">below</span>. We also worked at a higher level, regarding <span class="KeyTerm1">beside</span> and <span class="KeyTerm1">below</span> as primitives to be manipulated in a language whose operations, such as <span class="KeyTerm1">square_of_four</span>, capture common patterns of combining geometric combiners.</p>
<p><a id="c002_c2-para-1037"></a>Stratified design helps make programs <i>robust</i>, that is, it makes it likely that small changes in a specification will require correspondingly small changes in the program. For instance, suppose we wanted to change the image based on <span class="KeyTerm1">wave</span> shown in <a href="#c2-fig-0016">figure 2.9</a>. We could work at the lowest level to change the detailed appearance of the <span class="KeyTerm1">wave</span> element; we could work at the middle level to change the way <span class="KeyTerm1">corner_split</span> replicates the <span class="KeyTerm1">wave</span>; we could work at the highest level to change how <span class="KeyTerm1">square_limit</span> arranges the four copies of the corner. In general, each level of a stratified design provides a different vocabulary for expressing the characteristics of the system, and a different kind of ability to change it.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0076"></a><a id="c002_c2-title-0077"></a>Exercise 2.52</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1038"></a>Make changes to the square limit of <span class="KeyTerm1">wave</span> shown in <a href="#c2-fig-0016">figure 2.9</a> by working at each of the levels described above. In particular:</p>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0030"></a><span>a. </span>Add some segments to the primitive <span class="KeyTerm1">wave</span> painter of exercise 2.49 (to add a smile, for example).</li>
<li><a id="c002_c2-li-0031"></a><span>b. </span>Change the pattern constructed by <span class="KeyTerm1">corner_split</span> (for example, by using only one copy of the <span class="KeyTerm1">up_split</span> and <span class="KeyTerm1">right_split</span> images instead of two).</li>
<li><a id="c002_c2-li-0032"></a><span>c. </span>Modify the version of <span class="KeyTerm1">square_limit</span> that uses <span class="KeyTerm1">square_of_four</span> so as to assemble the corners in a different pattern. (For example, you might make the big Mr. Rogers look outward from each corner of the square.)</li>
</ol>
</section>
</section>
</section>
<section>
<h2><a id="c002_c2-sec-0077"></a><span>2.3</span> <a id="c002_c2-title-0078"></a>Symbolic Data</h2>
<p class="paraaftertitle"><a id="c002_c2-para-1042"></a>All the compound data objects we have used so far were constructed ultimately from numbers. In this section we extend the representational capability of our language by introducing the ability to work with strings of characters as data.</p>
<section>
<h3><a id="c002_c2-sec-0078"></a><span>2.3.1</span> <a id="c002_c2-title-0079"></a>Strings</h3>
<p class="paraaftertitle"><a id="c002_c2-para-1043"></a>So far, we have used strings in order to display messages, using the functions <span class="KeyTerm1">display</span> and <span class="KeyTerm1">error</span> (as for example in exercise 1.22). We can form compound data using strings and have lists such as</p>
<p class="Sp-text-1"><a id="c002_c2-para-1044"></a>list("a", "b", "c", "d")</p>
<p class="Sp-text-1"><a id="c002_c2-para-1045"></a>list(23, 45, 17)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1046"></a>list(list("Jakob", 27), list("Lova", 9), list("Luisa", 24))</p>
<p class="paracontinue"><a id="c002_c2-para-1047"></a>In order to distinguish strings from names, we surround them with double quotation marks. For example, the JavaScript expression <span class="KeyTerm1">z</span> denotes the value of the name <span class="KeyTerm1">z</span>, whereas the JavaScript expression <span class="KeyTerm1">"z"</span> denotes a string that consists of a single character, namely the last letter in the English alphabet in lower case.</p>
<p><a id="c002_c2-para-1048"></a>Via quotation marks, we can distinguish between strings and names:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1049"></a><b>const</b> a = 1;</p>
<p class="Sp-text-1"><a id="c002_c2-para-1050"></a><b>const</b> b = 2;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1051"></a>list(a, b);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1052"></a><i>[1, [2, null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1053"></a>list("a", "b");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1054"></a><i>["a", ["b", null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1055"></a>list("a", b);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1056"></a><i>["a", [2, null]]</i></p>
<p><a id="c002_c2-para-1057"></a>In section 1.1.6, we introduced <span class="KeyTerm1">===</span> and <span class="KeyTerm1">!==</span> as primitive predicates on numbers. From now on, we shall allow two strings as operands of <span class="KeyTerm1">===</span> and <span class="KeyTerm1">!==</span>. The predicate <span class="KeyTerm1">===</span> returns true if and only if the two strings are the same, and <span class="KeyTerm1">!==</span> returns true if and only if the two strings are not the same.<a id="c002_c2-fn-0031a"></a><a href="#c2-fn-0031"><sup>31</sup></a> Using <span class="KeyTerm1">===</span>, we can implement a useful function called <span class="KeyTerm1">member</span>. This takes two arguments: a string and a list of strings or a number and a list of numbers. If the first argument is not contained in the list (i.e., is not <span class="KeyTerm1">===</span> to any item in the list), then <span class="KeyTerm1">member</span> returns <span class="KeyTerm1"><b>null</b></span>. Otherwise, it returns the sublist of the list beginning with the first occurrence of the string or number:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1058"></a><b>function</b> member(item, x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1059"></a> <b>return</b> is_null(x)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1060"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1061"></a>           : item === head(x)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1062"></a>           ? x</p>
<p class="Sp-text-1"><a id="c002_c2-para-1063"></a>           : member(item, tail(x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1064"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1065"></a>For example, the value of</p>
<p class="Sp-text-1"><a id="c002_c2-para-1066"></a>member("apple", list("pear", "banana", "prune"))</p>
<p class="paracontinue"><a id="c002_c2-para-1067"></a>is <span class="KeyTerm1"><b>null</b></span>, whereas the value of</p>
<p class="Sp-text-1"><a id="c002_c2-para-1068"></a>member("apple", list("x", "y", "apple", "pear"))</p>
<p class="paracontinue"><a id="c002_c2-para-1069"></a>is <span class="KeyTerm1">list("apple", "pear")</span>.</p>
<section>
<h5><a id="c002_c2-sec-0079"></a><a id="c002_c2-title-0080"></a>Exercise 2.53</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1070"></a>What is the result of evaluating each of the following expressions, in box notation and list notation?</p>
<p class="Sp-text-1"><a id="c002_c2-para-1071"></a>list("a", "b", "c")</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-5071"></a>list(list("george"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1072"></a>tail(list(list("x1", "x2"), list("y1", "y2")))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1073"></a>tail(head(list(list("x1", "x2"), list("y1", "y2"))))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1074"></a>member("red", list("blue", "shoes", "yellow", "socks"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1075"></a>member("red", list("red", "shoes", "blue", "socks"))</p>
</section>
<section>
<h5><a id="c002_c2-sec-0080"></a><a id="c002_c2-title-0081"></a>Exercise 2.54</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1076"></a>Two lists are said to be <span class="KeyTerm1">equal</span> if they contain equal elements arranged in the same order. For example,</p>
<p class="Sp-text-1"><a id="c002_c2-para-1077"></a>equal(list("this", "is", "a", "list"), list("this", "is", "a", "list"))</p>
<p class="paracontinue"><a id="c002_c2-para-1078"></a>is true, but</p>
<p class="Sp-text-1"><a id="c002_c2-para-1079"></a>equal(list("this", "is", "a", "list"), list("this", list("is", "a"), "list"))</p>
<p class="paracontinue"><a id="c002_c2-para-1080"></a>is false. To be more precise, we can define <span class="KeyTerm1">equal</span> recursively in terms of the basic <span class="KeyTerm1">===</span> equality of numbers and strings by saying that <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> are <span class="KeyTerm1">equal</span> if they are both strings or both numbers and they are <span class="KeyTerm1">===</span>, or if they are both pairs such that <span class="KeyTerm1">head(a)</span> is <span class="KeyTerm1">equal</span> to <span class="KeyTerm1">head(b)</span> and <span class="KeyTerm1">tail(a)</span> is <span class="KeyTerm1">equal</span> to <span class="KeyTerm1">tail(b)</span>. Using this idea, implement <span class="KeyTerm1">equal</span> as a function.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0081"></a><a id="c002_c2-title-0082"></a>Exercise 2.55</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1081"></a>The JavaScript interpreter reads the characters after a double quotation mark <span class="KeyTerm1">"</span> until it finds another double quotation mark. All characters between the two are part of the string, excluding the double quotation marks themselves. But what if we want a string to contain double quotation marks? For this purpose, JavaScript also allows <i>single</i> quotation marks to delimit strings, as for example in <span class="KeyTerm1">'say your name aloud'</span>. Within singly-quoted strings, we can use double quotation marks, and vice versa, so <span class="KeyTerm1">'say "your name" aloud'</span> and <span class="KeyTerm1">"say 'your name' aloud"</span> are valid strings that have different characters at positions 4 and 14, if we start counting at 0. Depending on the font in use, two single quotation marks might not be easily distinguishable from a double quotation mark. Can you spot which is which and work out the value of the following expression?</p>
<p class="Sp-text-1"><a id="c002_c2-para-1082"></a>' " ' === " "</p>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0082"></a><span>2.3.2</span> <a id="c002_c2-title-0083"></a>Example: Symbolic Differentiation</h3>
<p class="paraaftertitle"><a id="c002_c2-para-1083"></a>As an illustration of symbol manipulation and a further illustration of data abstraction, consider the design of a function that performs symbolic differentiation of algebraic expressions. We would like the function to take as arguments an algebraic expression and a variable and to return the derivative of the expression with respect to the variable. For example, if the arguments to the function are <i>ax</i><sup>2</sup> + <i>bx</i> + <i>c</i> and <i>x</i>, the function should return 2<i>ax</i> + <i>b</i>. Symbolic differentiation is of special historical significance in the programming language Lisp.<a id="c002_c2-fn-0032a"></a><a href="#c2-fn-0032"><sup>32</sup></a> It was one of the motivating examples behind the development of a computer language for symbol manipulation. Furthermore, it marked the beginning of the line of research that led to the development of powerful systems for symbolic mathematical work, which are today routinely used by applied mathematicians and physicists.</p>
<p><a id="c002_c2-para-1084"></a>In developing the symbolic-differentiation program, we will follow the same strategy of data abstraction that we followed in developing the rational-number system of section 2.1.1. That is, we will first define a differentiation algorithm that operates on abstract objects such as “sums,” “products,” and “variables” without worrying about how these are to be represented. Only afterward will we address the representation problem.</p>
<section>
<h5><a id="c002_c2-sec-0083"></a><a id="c002_c2-title-0084"></a>The differentiation program with abstract data</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1085"></a>To keep things simple, we will consider a very simple symbolic-differentiation program that handles expressions that are built up using only the operations of addition and multiplication with two arguments. Differentiation of any such expression can be carried out by applying the following reduction rules:</p>
<p><a id="c002_c2-para-1086"></a></p>
<figure id="c002_c2-fig-0023"><img alt="c2-fig-5008.jpg" src="../images/c2-fig-5008.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p><a id="c002_c2-para-1087"></a>Observe that the latter two rules are recursive in nature. That is, to obtain the derivative of a sum we first find the derivatives of the terms and add them. Each of the terms may in turn be an expression that needs to be decomposed. Decomposing into smaller and smaller pieces will eventually produce pieces that are either constants or variables, whose derivatives will be either 0 or 1.</p>
<p><a id="c002_c2-para-1088"></a>To embody these rules in a function we indulge in a little wishful thinking, as we did in designing the rational-number implementation. If we had a means for representing algebraic expressions, we should be able to tell whether an expression is a sum, a product, a constant, or a variable. We should be able to extract the parts of an expression. For a sum, for example, we want to be able to extract the addend (first term) and the augend (second term). We should also be able to construct expressions from parts. Let us assume that we already have functions to implement the following selectors, constructors, and predicates:</p>
<figure><figcaption class="tablecaption"><a id="c002_c2-tbl-0003"></a></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c002_c2-para-1089"></a><span class="KeyTerm1">is_variable(e)</span></td>
<td><a id="c002_c2-para-1090"></a>Is <span class="KeyTerm1">e</span> a variable?</td></tr>
<tr>
<td><a id="c002_c2-para-1091"></a><span class="KeyTerm1">is_same_variable(v1, v2)</span></td>
<td><a id="c002_c2-para-1092"></a>Are <span class="KeyTerm1">v1</span> and <span class="KeyTerm1">v2</span> the same variable?</td></tr>
<tr>
<td><a id="c002_c2-para-1093"></a><span class="KeyTerm1">is_sum(e)</span></td>
<td><a id="c002_c2-para-1094"></a>Is <span class="KeyTerm1">e</span> a sum?</td></tr>
<tr>
<td><a id="c002_c2-para-1095"></a><span class="KeyTerm1">addend(e)</span></td>
<td><a id="c002_c2-para-1096"></a>Addend of the sum <span class="KeyTerm1">e</span>.</td></tr>
<tr>
<td><a id="c002_c2-para-1097"></a><span class="KeyTerm1">augend(e)</span></td>
<td><a id="c002_c2-para-1098"></a>Augend of the sum <span class="KeyTerm1">e</span>.</td></tr>
<tr>
<td><a id="c002_c2-para-1099"></a><span class="KeyTerm1">make_sum(a1, a2)</span></td>
<td><a id="c002_c2-para-1100"></a>Construct the sum of <span class="KeyTerm1">a1</span> and <span class="KeyTerm1">a2</span>.</td></tr>
<tr>
<td><a id="c002_c2-para-1101"></a><span class="KeyTerm1">is_product(e)</span></td>
<td><a id="c002_c2-para-1102"></a>Is <span class="KeyTerm1">e</span> a product?</td></tr>
<tr>
<td><a id="c002_c2-para-1103"></a><span class="KeyTerm1">multiplier(e)</span></td>
<td><a id="c002_c2-para-1104"></a>Multiplier of the product <span class="KeyTerm1">e</span>.</td></tr>
<tr>
<td><a id="c002_c2-para-1105"></a><span class="KeyTerm1">multiplicand(e)</span></td>
<td><a id="c002_c2-para-1106"></a>Multiplicand of the product <span class="KeyTerm1">e</span>.</td></tr>
<tr>
<td><a id="c002_c2-para-1107"></a><span class="KeyTerm1">make_product(m1, m2)</span></td>
<td><a id="c002_c2-para-1108"></a>Construct the product of <span class="KeyTerm1">m1</span> and <span class="KeyTerm1">m2</span>.</td></tr></tbody></table></div></figure>
<p class="paracontinue"><a id="c002_c2-para-1109"></a>Using these, and the primitive predicate <span class="KeyTerm1">is_number</span>, which identifies numbers, we can express the differentiation rules as the following function:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1110"></a><b>function</b> deriv(exp, variable) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1111"></a> <b>return</b> is_number(exp)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1112"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-1113"></a>           : is_variable(exp)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1114"></a>           ? is_same_variable(exp, variable) ? 1 : 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-1115"></a>           : is_sum(exp)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1116"></a>           ? make_sum(deriv(addend(exp), variable),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1117"></a>                      deriv(augend(exp), variable))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1118"></a>           : is_product(exp)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1119"></a>           ? make_sum(make_product(multiplier(exp),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1120"></a>                                   deriv(multiplicand(exp),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1121"></a>                                         variable)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1122"></a>                     make_product(deriv(multiplier(exp),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1123"></a>                                         variable),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1124"></a>                                  multiplicand(exp)))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1125"></a>           : error(exp, "unknown expression type – deriv");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1126"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1127"></a>This <span class="KeyTerm1">deriv</span> function incorporates the complete differentiation algorithm. Since it is expressed in terms of abstract data, it will work no matter how we choose to represent algebraic expressions, as long as we design a proper set of selectors and constructors. This is the issue we must address next.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0084"></a><a id="c002_c2-title-0085"></a>Representing algebraic expressions</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1128"></a>We can imagine many ways to use list structure to represent algebraic expressions. For example, we could use lists of symbols that mirror the usual algebraic notation, representing <i>ax</i> + <i>b</i> as <span class="KeyTerm1">list("a", "*", "x", "+", "b")</span>. However, it will be more convenient if we reflect the mathematical structure of the expression in the JavaScript value representing it; that is, to represent <i>ax</i> + <i>b</i> as <span class="KeyTerm1">list("+", list("*", "a", "x"), "b")</span>. Placing a binary operator in front of its operands is called <i>prefix notation</i>, in contrast with the infix notation introduced in section 1.1.1. With prefix notation, our data representation for the differentiation problem is as follows:</p>
<ul style="list-style-type:disc">
<li>The variables are just strings. They are identified by the primitive predicate <span class="KeyTerm1">is_string</span>:
<p class="Sp-text-1"><a id="c002_c2-para-1130"></a> <b>function</b> is_variable(x) { <b>return</b> is_string(x); }</p></li>
<li>Two variables are the same if the strings representing them are equal:
<p class="Sp-text-1"><a id="c002_c2-para-1132"></a> <b>function</b> is_same_variable(v1, v2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1133"></a> <b>return</b> is_variable(v1) &amp;&amp; is_variable(v2) &amp;&amp; v1 === v2;</p>
<p class="Sp-text-1"><a id="c002_c2-para-1134"></a>    }</p></li>
<li>Sums and products are constructed as lists:
<p class="Sp-text-1"><a id="c002_c2-para-1136"></a> <b>function</b> make_sum(a1, a2) { <b>return</b> list("+", a1, a2); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1137"></a> <b>function</b> make_product(m1, m2) { <b>return</b> list("*", m1, m2); }</p></li>
<li>A sum is a list whose first element is the string <span class="KeyTerm1">"+"</span>:
<p class="Sp-text-1"><a id="c002_c2-para-1139"></a> <b>function</b> is_sum(x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1140"></a> <b>return</b> is_pair(x) &amp;&amp; head(x) === "+";</p>
<p class="Sp-text-1"><a id="c002_c2-para-1141"></a>    }</p></li>
<li>The addend is the second item of the sum list:
<p class="Sp-text-1"><a id="c002_c2-para-1143"></a> <b>function</b> addend(s) { <b>return</b> head(tail(s)); }</p></li>
<li>The augend is the third item of the sum list:
<p class="Sp-text-1"><a id="c002_c2-para-1145"></a> <b>function</b> augend(s) { <b>return</b> head(tail(tail(s))); }</p></li>
<li>A product is a list whose first element is the string <span class="KeyTerm1">"*"</span>:
<p class="Sp-text-1"><a id="c002_c2-para-1147"></a> <b>function</b> is_product(x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1148"></a> <b>return</b> is_pair(x) &amp;&amp; head(x) === "*";</p>
<p class="Sp-text-1"><a id="c002_c2-para-1149"></a>    }</p></li>
<li>The multiplier is the second item of the product list:
<p class="Sp-text-1"><a id="c002_c2-para-1151"></a> <b>function</b> multiplier(s) { <b>return</b> head(tail(s)); }</p></li>
<li>The multiplicand is the third item of the product list:
<p class="Sp-text-1"><a id="c002_c2-para-1153"></a> <b>function</b> multiplicand(s) { <b>return</b> head(tail(tail(s))); }</p></li>
</ul>
<p class="paracontinue"><a id="c002_c2-para-1154"></a>Thus, we need only combine these with the algorithm as embodied by <span class="KeyTerm1">deriv</span> in order to have a working symbolic-differentiation program. Let us look at some examples of its behavior:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1155"></a>deriv(list("+", "x", 3), "x");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1156"></a><i>list("+", 1, 0)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1157"></a>deriv(list("*", "x", "y"), "x");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1158"></a><i>list("+", list("*", "x", 0), list("*", 1, "y"))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1159"></a>deriv(list("*", list("*", "x", "y"), list("+", "x", 3)), "x");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1160"></a><i>list("+", list("*", list("*", "x", "y"), list("+", 1, 0)),</i></p>
<p class="Sp-text-1"><a id="c002_c2-para-1161"></a> <i>list("*", list("+", list("*", "x", 0), list("*", 1, "y")),</i> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1162"></a> <i>list("+", "x", 3)))</i></p>
<p class="paracontinue"><a id="c002_c2-para-1163"></a>The program produces answers that are correct; however, they are unsimplified. It is true that</p>
<p><a id="c002_c2-para-1164"></a></p>
<figure id="c002_c2-fig-0024"><img alt="c2-fig-5009.jpg" src="../images/c2-fig-5009.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-1165"></a>but we would like the program to know that <i>x ·</i> 0 = 0, 1 <i>· y</i> = <i>y</i>, and 0 + <i>y</i> = <i>y</i>. The answer for the second example should have been simply <span class="KeyTerm1">y</span>. As the third example shows, this becomes a serious issue when the expressions are complex.</p>
<p><a id="c002_c2-para-1166"></a>Our difficulty is much like the one we encountered with the rational-number implementation: we haven't reduced answers to simplest form. To accomplish the rational-number reduction, we needed to change only the constructors and the selectors of the implementation. We can adopt a similar strategy here. We won't change <span class="KeyTerm1">deriv</span> at all. Instead, we will change <span class="KeyTerm1">make_sum</span> so that if both summands are numbers, <span class="KeyTerm1">make_sum</span> will add them and return their sum. Also, if one of the summands is 0, then <span class="KeyTerm1">make_sum</span> will return the other summand.</p>
<p class="Sp-text-1"><a id="c002_c2-para-1167"></a><b>function</b> make_sum(a1, a2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1168"></a> <b>return</b> number_equal(a1, 0)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1169"></a>           ? a2</p>
<p class="Sp-text-1"><a id="c002_c2-para-1170"></a>           : number_equal(a2, 0)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1171"></a>           ? a1</p>
<p class="Sp-text-1"><a id="c002_c2-para-1172"></a>           : is_number(a1) &amp;&amp; is_number(a2)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1173"></a>           ? a1 + a2</p>
<p class="Sp-text-1"><a id="c002_c2-para-1174"></a>           : list("+", a1, a2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1175"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1176"></a>This uses the function <span class="KeyTerm1">number_equal</span>, which checks whether an expression is equal to a given number:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1177"></a><b>function</b> number_equal(exp, num) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1178"></a> <b>return</b> is_number(exp) &amp;&amp; exp === num;</p>
<p class="Sp-text-1"><a id="c002_c2-para-1179"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1180"></a>Similarly, we will change <span class="KeyTerm1">make_product</span> to build in the rules that 0 times anything is 0 and 1 times anything is the thing itself:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1181"></a><b>function</b> make_product(m1, m2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1182"></a> <b>return</b> number_equal(m1, 0) || number_equal(m2, 0)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1183"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-1184"></a>           : number_equal(m1, 1)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1185"></a>           ? m2</p>
<p class="Sp-text-1"><a id="c002_c2-para-1186"></a>           : number_equal(m2, 1)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1187"></a>           ? m1</p>
<p class="Sp-text-1"><a id="c002_c2-para-1188"></a>           : is_number(m1) &amp;&amp; is_number(m2)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1189"></a>           ? m1 * m2</p>
<p class="Sp-text-1"><a id="c002_c2-para-1190"></a>           : list("*", m1, m2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1191"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1192"></a>Here is how this version works on our three examples:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1193"></a>deriv(list("+", "x", 3), "x");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1194"></a><i>1</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1195"></a>deriv(list("*", "x", "y"), "x");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1196"></a><i>"y"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1197"></a>deriv(list("*", list("*", "x", "y"), list("+", "x", 3)), "x");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1198"></a><i>list("+", list("*", "x", "y"), list("*", "y", list("+", "x", 3)))</i></p>
<p class="paracontinue"><a id="c002_c2-para-1199"></a>Although this is quite an improvement, the third example shows that there is still a long way to go before we get a program that puts expressions into a form that we might agree is “simplest.” The problem of algebraic simplification is complex because, among other reasons, a form that may be simplest for one purpose may not be for another.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0085"></a><a id="c002_c2-title-0086"></a>Exercise 2.56</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1200"></a>Show how to extend the basic differentiator to handle more kinds of expressions. For instance, implement the differentiation rule</p>
<p><a id="c002_c2-para-1201"></a></p>
<figure id="c002_c2-fig-0025"><img alt="c2-fig-5010.jpg" src="../images/c2-fig-5010.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-1202"></a>by adding a new clause to the <span class="KeyTerm1">deriv</span> program and defining appropriate functions <span class="KeyTerm1">is_exp</span>, <span class="KeyTerm1">base</span>, <span class="KeyTerm1">exponent</span>, and <span class="KeyTerm1">make_exp</span>. (You may use the string <span class="KeyTerm1">"**"</span> to denote exponentiation.) Build in the rules that anything raised to the power 0 is 1 and anything raised to the power 1 is the thing itself.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0086"></a><a id="c002_c2-title-0087"></a>Exercise 2.57</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1203"></a>Extend the differentiation program to handle sums and products of arbitrary numbers of (two or more) terms. Then the last example above could be expressed as</p>
<p class="Sp-text-1"><a id="c002_c2-para-1204"></a>deriv(list("*", "x", "y", list("+", "x", 3)), "x");</p>
<p class="paracontinue"><a id="c002_c2-para-1205"></a>Try to do this by changing only the representation for sums and products, without changing the <span class="KeyTerm1">deriv</span> function at all. For example, the <span class="KeyTerm1">addend</span> of a sum would be the first term, and the <span class="KeyTerm1">augend</span> would be the sum of the rest of the terms.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0087"></a><a id="c002_c2-title-0088"></a>Exercise 2.58</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1206"></a>Suppose we want to modify the differentiation program so that it works with ordinary mathematical notation, in which <span class="KeyTerm1">"+"</span> and <span class="KeyTerm1">"*"</span> are infix rather than prefix operators. Since the differentiation program is defined in terms of abstract data, we can modify it to work with different representations of expressions solely by changing the predicates, selectors, and constructors that define the representation of the algebraic expressions on which the differentiator is to operate.</p>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0042"></a><span>a. </span>Show how to do this in order to differentiate algebraic expressions presented in infix form, as in this example:
<p class="Sp-text-1"><a id="c002_c2-para-1208"></a>list("x", "+", list(3, "*", list("x", "+", list("y", "+", 2))))</p>
<p class="paracontinue"><a id="c002_c2-para-1209"></a>To simplify the task, assume that <span class="KeyTerm1">"+"</span> and <span class="KeyTerm1">"*"</span> always take two arguments and that expressions are fully parenthesized.</p></li>
<li><a id="c002_c2-li-0043"></a><span>b. </span>The problem becomes substantially harder if we allow a notation closer to ordinary infix notation, which omits unnecessary parentheses and assumes that multiplication has higher precedence than addition, as in this example:
<p class="Sp-text-1"><a id="c002_c2-para-1211"></a>list("x", "+", "3", "*", list("x", "+", "y", "+", 2))</p>
<p class="paracontinue"><a id="c002_c2-para-1212"></a>Can you design appropriate predicates, selectors, and constructors for this notation such that our derivative program still works?</p></li>
</ol>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0088"></a><span>2.3.3</span> <a id="c002_c2-title-0089"></a>Example: Representing Sets</h3>
<p class="paraaftertitle"><a id="c002_c2-para-1213"></a>In the previous examples we built representations for two kinds of compound data objects: rational numbers and algebraic expressions. In one of these examples we had the choice of simplifying (reducing) the expressions at either construction time or selection time, but other than that the choice of a representation for these structures in terms of lists was straightforward. When we turn to the representation of sets, the choice of a representation is not so obvious. Indeed, there are a number of possible representations, and they differ significantly from one another in several ways.</p>
<p><a id="c002_c2-para-1214"></a>Informally, a set is simply a collection of distinct objects. To give a more precise definition we can employ the method of data abstraction. That is, we define “set” by specifying the operations that are to be used on sets. These are <span class="KeyTerm1">union_set</span>, <span class="KeyTerm1">intersection_set</span>, <span class="KeyTerm1">is_element_of_set</span>, and <span class="KeyTerm1">adjoin_set</span>. The function <span class="KeyTerm1">is_ element_of_set</span> is a predicate that determines whether a given element is a member of a set. The function <span class="KeyTerm1">adjoin_set</span> takes an object and a set as arguments and returns a set that contains the elements of the original set and also the adjoined element. The function <span class="KeyTerm1">union_set</span> computes the union of two sets, which is the set containing each element that appears in either argument. The function <span class="KeyTerm1">intersection_set</span> computes the intersection of two sets, which is the set containing only elements that appear in both arguments. From the viewpoint of data abstraction, we are free to design any representation that implements these operations in a way consistent with the interpretations given above.<a id="c002_c2-fn-0033a"></a><a href="#c2-fn-0033"><sup>33</sup></a></p>
<section>
<h5><a id="c002_c2-sec-0089"></a><a id="c002_c2-title-0090"></a>Sets as unordered lists</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1215"></a>One way to represent a set is as a list of its elements in which no element appears more than once. The empty set is represented by the empty list. In this representation, <span class="KeyTerm1">is_element_of_set</span> is similar to the function <span class="KeyTerm1">member</span> of section 2.3.1. It uses <span class="KeyTerm1">equal</span> instead of <span class="KeyTerm1">===</span> so that the set elements need not be just numbers or strings:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1216"></a><b>function</b> is_element_of_set(x, set) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1217"></a> <b>return</b> is_null(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1218"></a>           ? <b>false</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1219"></a>           : equal(x, head(set))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1220"></a>           ? <b>true</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1221"></a>           : is_element_of_set(x, tail(set));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1222"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1223"></a>Using this, we can write <span class="KeyTerm1">adjoin_set</span>. If the object to be adjoined is already in the set, we just return the set. Otherwise, we use <span class="KeyTerm1">pair</span> to add the object to the list that represents the set:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1224"></a><b>function</b> adjoin_set(x, set) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1225"></a> <b>return</b> is_element_of_set(x, set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1226"></a>           ? set</p>
<p class="Sp-text-1"><a id="c002_c2-para-1227"></a>           : pair(x, set);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1228"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1229"></a>For <span class="KeyTerm1">intersection_set</span> we can use a recursive strategy. If we know how to form the intersection of <span class="KeyTerm1">set2</span> and the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">set1</span>, we only need to decide whether to include the <span class="KeyTerm1">head</span> of <span class="KeyTerm1">set1</span> in this. But this depends on whether <span class="KeyTerm1">head(set1)</span> is also in <span class="KeyTerm1">set2</span>. Here is the resulting function:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1230"></a><b>function</b> intersection_set(set1, set2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1231"></a> <b>return</b> is_null(set1) || is_null(set2)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1232"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1233"></a>           : is_element_of_set(head(set1), set2)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1234"></a>           ? pair(head(set1), intersection_set(tail(set1), set2))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1235"></a>           : intersection_set(tail(set1), set2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1236"></a>}</p>
<p><a id="c002_c2-para-1237"></a>In designing a representation, one of the issues we should be concerned with is efficiency. Consider the number of steps required by our set operations. Since they all use <span class="KeyTerm1">is_element_of_set</span>, the speed of this operation has a major impact on the efficiency of the set implementation as a whole. Now, in order to check whether an object is a member of a set, <span class="KeyTerm1">is_element_of_set</span> may have to scan the entire set. (In the worst case, the object turns out not to be in the set.) Hence, if the set has <i>n</i> elements, <span class="KeyTerm1">is_element_of_set</span> might take up to <i>n</i> steps. Thus, the number of steps required grows as Θ(<i>n</i>). The number of steps required by <span class="KeyTerm1">adjoin_set</span>, which uses this operation, also grows as Θ(<i>n</i>). For <span class="KeyTerm1">intersection_set</span>, which does an <span class="KeyTerm1">is_element_of_set</span> check for each element of <span class="KeyTerm1">set1</span>, the number of steps required grows as the product of the sizes of the sets involved, or Θ(<i>n</i><sup>2</sup>) for two sets of size <i>n</i>. The same will be true of <span class="KeyTerm1">union_set</span>.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0090"></a><a id="c002_c2-title-0091"></a>Exercise 2.59</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1238"></a>Implement the <span class="KeyTerm1">union_set</span> operation for the unordered-list representation of sets.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0091"></a><a id="c002_c2-title-0092"></a>Exercise 2.60</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1239"></a>We specified that a set would be represented as a list with no duplicates. Now suppose we allow duplicates. For instance, the set {1, 2, 3} could be represented as the list <span class="KeyTerm1">list(2, 3, 2, 1, 3, 2, 2)</span>. Design functions <span class="KeyTerm1">is_element_of_set</span>, <span class="KeyTerm1">adjoin_set</span>, <span class="KeyTerm1">union_set</span>, and <span class="KeyTerm1">intersection_set</span> that operate on this representation. How does the efficiency of each compare with the corresponding function for the non-duplicate represen-tation? Are there applications for which you would use this representation in preference to the non-duplicate one?</p>
</section>
<section>
<h5><a id="c002_c2-sec-0092"></a><a id="c002_c2-title-0093"></a>Sets as ordered lists</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1240"></a>One way to speed up our set operations is to change the representation so that the set elements are listed in increasing order. To do this, we need some way to compare two objects so that we can say which is bigger. For example, we could compare strings lexicographically, or we could agree on some method for assigning a unique number to an object and then compare the elements by comparing the corresponding numbers. To keep our discussion simple, we will consider only the case where the set elements are numbers, so that we can compare elements using <span class="KeyTerm1">&gt;</span> and <span class="KeyTerm1">&lt;</span>. We will represent a set of numbers by listing its elements in increasing order. Whereas our first representation above allowed us to represent the set {1, 3, 6, 10} by listing the elements in any order, our new representation allows only the list <span class="KeyTerm1">list(1, 3, 6, 10)</span>.</p>
<p><a id="c002_c2-para-1241"></a>One advantage of ordering shows up in <span class="KeyTerm1">is_element_of_set</span>: In checking for the presence of an item, we no longer have to scan the entire set. If we reach a set element that is larger than the item we are looking for, then we know that the item is not in the set:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1242"></a><b>function</b> is_element_of_set(x, set) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1243"></a> <b>return</b> is_null(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1244"></a>           ? <b>false</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1245"></a>           : x === head(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1246"></a>           ? <b>true</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1247"></a>           : x &lt; head(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1248"></a>           ? <b>false</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1249"></a>           : <i>//</i> x &gt; head(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1250"></a>             is_element_of_set(x, tail(set));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1251"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1252"></a>How many steps does this save? In the worst case, the item we are looking for may be the largest one in the set, so the number of steps is the same as for the unordered representation. On the other hand, if we search for items of many different sizes we can expect that sometimes we will be able to stop searching at a point near the beginning of the list and that other times we will still need to examine most of the list. On the average we should expect to have to examine about half of the items in the set. Thus, the average number of steps required will be about <i>n</i>/2. This is still Θ(<i>n</i>) growth, but it does save us, on the average, a factor of 2 in number of steps over the previous implementation.</p>
<p><a id="c002_c2-para-1253"></a>We obtain a more impressive speedup with <span class="KeyTerm1">intersection_set</span>. In the unordered representation this operation required Θ(<i>n</i><sup>2</sup>) steps, because we performed a complete scan of <span class="KeyTerm1">set2</span> for each element of <span class="KeyTerm1">set1</span>. But with the ordered representation, we can use a more clever method. Begin by comparing the initial elements, <span class="KeyTerm1">x1</span> and <span class="KeyTerm1">x2</span>, of the two sets. If <span class="KeyTerm1">x1</span> equals <span class="KeyTerm1">x2</span>, then that gives an element of the intersection, and the rest of the intersection is the intersection of the <span class="KeyTerm1">tail</span>s of the two sets. Suppose, however, that <span class="KeyTerm1">x1</span> is less than <span class="KeyTerm1">x2</span>. Since <span class="KeyTerm1">x2</span> is the smallest element in <span class="KeyTerm1">set2</span>, we can immediately conclude that <span class="KeyTerm1">x1</span> cannot appear anywhere in <span class="KeyTerm1">set2</span> and hence is not in the intersection. Hence, the intersection is equal to the intersection of <span class="KeyTerm1">set2</span> with the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">set1</span>. Similarly, if <span class="KeyTerm1">x2</span> is less than <span class="KeyTerm1">x1</span>, then the intersection is given by the intersection of <span class="KeyTerm1">set1</span> with the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">set2</span>. Here is the function:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1254"></a><b>function</b> intersection_set(set1, set2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1255"></a> <b>if</b> (is_null(set1) || is_null(set2)) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1256"></a> <b>return null</b>;</p>
<p class="Sp-text-1"><a id="c002_c2-para-1257"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1258"></a> <b>const</b> x1 = head(set1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1259"></a> <b>const</b> x2 = head(set2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1260"></a> <b>return</b> x1 === x2</p>
<p class="Sp-text-1"><a id="c002_c2-para-1261"></a>               ? pair(x1, intersection_set(tail(set1), tail(set2)))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1262"></a>               : x1 &lt; x2</p>
<p class="Sp-text-1"><a id="c002_c2-para-1263"></a>               ? intersection_set(tail(set1), set2)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1264"></a>               : <i>//</i> x2 &lt; x1</p>
<p class="Sp-text-1"><a id="c002_c2-para-1265"></a>                 intersection_set(set1, tail(set2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1266"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1267"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1268"></a>To estimate the number of steps required by this process, observe that at each step we reduce the intersection problem to computing intersections of smaller sets—removing the first element from <span class="KeyTerm1">set1</span> or <span class="KeyTerm1">set2</span> or both. Thus, the number of steps required is at most the sum of the sizes of <span class="KeyTerm1">set1</span> and <span class="KeyTerm1">set2</span>, rather than the product of the sizes as with the unordered representation. This is Θ(<i>n</i>) growth rather than Θ(<i>n</i><sup>2</sup>)—a considerable speedup, even for sets of moderate size.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0093"></a><a id="c002_c2-title-0094"></a>Exercise 2.61</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1269"></a>Give an implementation of <span class="KeyTerm1">adjoin_set</span> using the ordered representation. By analogy with <span class="KeyTerm1">is_element_of_set</span> show how to take advantage of the ordering to produce a function that requires on the average about half as many steps as with the unordered representation.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0094"></a><a id="c002_c2-title-0095"></a>Exercise 2.62</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1270"></a>Give a Θ(<i>n</i>) implementation of <span class="KeyTerm1">union_set</span> for sets represented as ordered lists.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0095"></a><a id="c002_c2-title-0096"></a>Sets as binary trees</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1271"></a>We can do better than the ordered-list representation by arranging the set elements in the form of a tree. Each node of the tree holds one element of the set, called the “entry” at that node, and a link to each of two other (possibly empty) nodes. The “left” link points to elements smaller than the one at the node, and the “right” link to elements greater than the one at the node. <a id="c002_c2-fig-0026a"></a><a href="#c2-fig-0026">Figure 2.16</a> shows some trees that represent the set {1, 3, 5, 7, 9, 11}. The same set may be represented by a tree in a number of different ways. The only thing we require for a valid representation is that all elements in the left subtree be smaller than the node entry and that all elements in the right subtree be larger.</p>
<figure id="c002_c2-fig-0026"><img alt="c2-fig-0016.jpg" src="../images/c2-fig-0016.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0026a">Figure 2.16</a></span> <a id="c002_c2-para-1272"></a>Various binary trees that represent the set {1, 3, 5, 7, 9, 11}.</p></figcaption></figure>
<p><a id="c002_c2-para-1273"></a>The advantage of the tree representation is this: Suppose we want to check whether a number <i>x</i> is contained in a set. We begin by comparing <i>x</i> with the entry in the top node. If <i>x</i> is less than this, we know that we need only search the left subtree; if <i>x</i> is greater, we need only search the right subtree. Now, if the tree is “balanced,” each of these subtrees will be about half the size of the original. Thus, in one step we have reduced the problem of searching a tree of size <i>n</i> to searching a tree of size <i>n</i>/2. Since the size of the tree is halved at each step, we should expect that the number of steps needed to search a tree of size <i>n</i> grows as Θ(log <i>n</i>).<a id="c002_c2-fn-0034a"></a><a href="#c2-fn-0034"><sup>34</sup></a> For large sets, this will be a significant speedup over the previous representations.</p>
<p><a id="c002_c2-para-1274"></a>We can represent trees by using lists. Each node will be a list of three items: the entry at the node, the left subtree, and the right subtree. A left or a right subtree of the empty list will indicate that there is no subtree connected there. We can describe this representation by the following functions:<a id="c002_c2-fn-0035a"></a><a href="#c2-fn-0035"><sup>35</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-1275"></a><b>function</b> entry(tree) { <b>return</b> head(tree); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1276"></a><b>function</b> left_branch(tree) { <b>return</b> head(tail(tree)); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1277"></a><b>function</b> right_branch(tree) { <b>return</b> head(tail(tail(tree))); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1278"></a><b>function</b> make_tree(entry, left, right) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1279"></a> <b>return</b> list(entry, left, right);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1280"></a>}</p>
<p><a id="c002_c2-para-1281"></a>Now we can write <span class="KeyTerm1">is_element_of_set</span> using the strategy described above:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1282"></a><b>function</b> is_element_of_set(x, set) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1283"></a> <b>return</b> is_null(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1284"></a>           ? <b>false</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1285"></a>           : x === entry(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1286"></a>           ? <b>true</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1287"></a>           : x &lt; entry(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1288"></a>           ? is_element_of_set(x, left_branch(set))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1289"></a>           : <i>//</i> x &gt; entry(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1290"></a>             is_element_of_set(x, right_branch(set));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1291"></a>}</p>
<p><a id="c002_c2-para-1292"></a>Adjoining an item to a set is implemented similarly and also requires Θ(log <i>n</i>) steps. To adjoin an item <span class="KeyTerm1">x</span>, we compare <span class="KeyTerm1">x</span> with the node entry to determine whether <span class="KeyTerm1">x</span> should be added to the right or to the left branch, and having adjoined <span class="KeyTerm1">x</span> to the appropriate branch we piece this newly constructed branch together with the original entry and the other branch. If <span class="KeyTerm1">x</span> is equal to the entry, we just return the node. If we are asked to adjoin <span class="KeyTerm1">x</span> to an empty tree, we generate a tree that has <span class="KeyTerm1">x</span> as the entry and empty right and left branches. Here is the function:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1293"></a><b>function</b> adjoin_set(x, set) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1294"></a> <b>return</b> is_null(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1295"></a>           ? make_tree(x, <b>null</b>, <b>null</b>)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1296"></a>           : x === entry(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1297"></a>           ? set</p>
<p class="Sp-text-1"><a id="c002_c2-para-1298"></a>           : x &lt; entry(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1299"></a>           ? make_tree(entry(set),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1300"></a>                       adjoin_set(x, left_branch(set)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1301"></a>                       right_branch(set))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1302"></a>           : <i>//</i> x &gt; entry(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1303"></a>             make_tree(entry(set),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1304"></a>                       left_branch(set),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1305"></a>                       adjoin_set(x, right_branch(set)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1306"></a>}</p>
<p><a id="c002_c2-para-1307"></a>The above claim that searching the tree can be performed in a logarithmic number of steps rests on the assumption that the tree is “balanced,” i.e., that the left and the right subtree of every tree have approximately the same number of elements, so that each subtree contains about half the elements of its parent. But how can we be certain that the trees we construct will be balanced? Even if we start with a balanced tree, adding elements with <span class="KeyTerm1">adjoin_set</span> may produce an unbalanced result. Since the position of a newly adjoined element depends on how the element compares with the items already in the set, we can expect that if we add elements “randomly” the tree will tend to be balanced on the average. But this is not a guarantee. For example, if we start with an empty set and adjoin the numbers 1 through 7 in sequence we end up with the highly unbalanced tree shown in <a id="c002_c2-fig-0027a"></a><a href="#c2-fig-0027">figure 2.17</a>. In this tree all the left subtrees are empty, so it has no advantage over a simple ordered list. One way to solve this problem is to define an operation that transforms an arbitrary tree into a balanced tree with the same elements. Then we can perform this transformation after every few <span class="KeyTerm1">adjoin_set</span> operations to keep our set in balance. There are also other ways to solve this problem, most of which involve designing new data structures for which searching and insertion both can be done in Θ(log <i>n</i>) steps.<a id="c002_c2-fn-0036a"></a><a href="#c2-fn-0036"><sup>36</sup></a></p>
<figure id="c002_c2-fig-0027"><img alt="c2-fig-0017.jpg" src="../images/c2-fig-0017.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0027a">Figure 2.17</a></span> <a id="c002_c2-para-1308"></a>Unbalanced tree produced by adjoining 1 through 7 in sequence.</p></figcaption></figure>
</section>
<section>
<h5><a id="c002_c2-sec-0096"></a><a id="c002_c2-title-0097"></a>Exercise 2.63</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1309"></a>Each of the following two functions converts a binary tree to a list.</p>
<p class="Sp-text-1"><a id="c002_c2-para-1310"></a><b>function</b> tree_to_list_1(tree) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1311"></a> <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1312"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1313"></a>           : append(tree_to_list_1(left_branch(tree)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1314"></a>                    pair(entry(tree),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1315"></a>                         tree_to_list_1(right_branch(tree))));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1316"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1317"></a><b>function</b> tree_to_list_2(tree) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1318"></a> <b>function</b> copy_to_list(tree, result_list) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1319"></a> <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1320"></a>               ? result_list</p>
<p class="Sp-text-1"><a id="c002_c2-para-1321"></a>               : copy_to_list(left_branch(tree),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1322"></a>                              pair(entry(tree),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1323"></a>                                   copy_to_list(right_branch(tree),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1324"></a>                                                result_list)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1325"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1326"></a> <b>return</b> copy_to_list(tree, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1327"></a>}</p>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0044"></a><span>a. </span>Do the two functions produce the same result for every tree? If not, how do the results differ? What lists do the two functions produce for the trees in <a href="#c2-fig-0026">figure 2.16</a>?</li>
<li><a id="c002_c2-li-0045"></a><span>b. </span>Do the two functions have the same order of growth in the number of steps required to convert a balanced tree with <i>n</i> elements to a list? If not, which one grows more slowly?</li>
</ol>
</section>
<section>
<h5><a id="c002_c2-sec-0097"></a><a id="c002_c2-title-0098"></a>Exercise 2.64</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1330"></a>The following function <span class="KeyTerm1">list_to_tree</span> converts an ordered list to a balanced binary tree. The helper function <span class="KeyTerm1">partial_tree</span> takes as arguments an integer <i>n</i> and list of at least <i>n</i> elements and constructs a balanced tree containing the first <i>n</i> elements of the list. The result returned by <span class="KeyTerm1">partial_tree</span> is a pair (formed with <span class="KeyTerm1">pair</span>) whose <span class="KeyTerm1">head</span> is the constructed tree and whose <span class="KeyTerm1">tail</span> is the list of elements not included in the tree.</p>
<p class="Sp-text-1"><a id="c002_c2-para-1331"></a><b>function</b> list_to_tree(elements) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1332"></a> <b>return</b> head(partial_tree(elements, length(elements)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1333"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1334"></a><b>function</b> partial_tree(elts, n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1335"></a> <b>if</b> (n === 0) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1336"></a> <b>return</b> pair(<b>null</b>, elts);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1337"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1338"></a> <b>const</b> left_size = math_floor((n - 1) / 2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1339"></a> <b>const</b> left_result = partial_tree(elts, left_size);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1340"></a> <b>const</b> left_tree = head(left_result);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1341"></a> <b>const</b> non_left_elts = tail(left_result);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1342"></a> <b>const</b> right_size = n - (left_size + 1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1343"></a> <b>const</b> this_entry = head(non_left_elts);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1344"></a> <b>const</b> right_result = partial_tree(tail(non_left_elts), right_size);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1345"></a> <b>const</b> right_tree = head(right_result);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1346"></a> <b>const</b> remaining_elts = tail(right_result);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1347"></a> <b>return</b> pair(make_tree(this_entry, left_tree, right_tree),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1348"></a>                    remaining_elts);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1349"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1350"></a>}</p>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0046"></a><span>a. </span>Write a short paragraph explaining as clearly as you can how <span class="KeyTerm1">partial_tree</span> works. Draw the tree produced by <span class="KeyTerm1">list_to_tree</span> for the list <span class="KeyTerm1">list(1, 3, 5, 7, 9, 11)</span>.</li>
<li><a id="c002_c2-li-0047"></a><span>b. </span>What is the order of growth in the number of steps required by <span class="KeyTerm1">list_to_tree</span> to convert a list of <i>n</i> elements?</li>
</ol>
</section>
<section>
<h5><a id="c002_c2-sec-0098"></a><a id="c002_c2-title-0099"></a>Exercise 2.65</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1353"></a>Use the results of exercises 2.63 and 2.64 to give Θ(<i>n</i>) implementations of <span class="KeyTerm1">union_set</span> and <span class="KeyTerm1">intersection_set</span> for sets implemented as (balanced) binary trees.<a id="c002_c2-fn-0037a"></a><a href="#c2-fn-0037"><sup>37</sup></a></p>
</section>
<section>
<h5><a id="c002_c2-sec-0099"></a><a id="c002_c2-title-0100"></a>Sets and information retrieval</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1354"></a>We have examined options for using lists to represent sets and have seen how the choice of representation for a data object can have a large impact on the performance of the programs that use the data. Another reason for concentrating on sets is that the techniques discussed here appear again and again in applications involving information retrieval.</p>
<p><a id="c002_c2-para-1355"></a>Consider a data base containing a large number of individual records, such as the personnel files for a company or the transactions in an accounting system. A typical data-management system spends a large amount of time accessing or modifying the data in the records and therefore requires an efficient method for accessing records. This is done by identifying a part of each record to serve as an identifying <i>key</i>. A key can be anything that uniquely identifies the record. For a personnel file, it might be an employee's ID number. For an accounting system, it might be a transaction number. Whatever the key is, when we define the record as a data structure we should include a <span class="KeyTerm1">key</span> selector function that retrieves the key associated with a given record.</p>
<p><a id="c002_c2-para-1356"></a>Now we represent the data base as a set of records. To locate the record with a given key we use a function <span class="KeyTerm1">lookup</span>, which takes as arguments a key and a data base and which returns the record that has that key, or false if there is no such record. The function <span class="KeyTerm1">lookup</span> is implemented in almost the same way as <span class="KeyTerm1">is_element_of_set</span>. For example, if the set of records is implemented as an unordered list, we could use</p>
<p class="Sp-text-1"><a id="c002_c2-para-1357"></a><b>function</b> lookup(given_key, set_of_records) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1358"></a> <b>return</b> is_null(set_of_records)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1359"></a>           ? <b>false</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1360"></a>           : equal(given_key, key(head(set_of_records)))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1361"></a>           ? head(set_of_records)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1362"></a>           : lookup(given_key, tail(set_of_records));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1363"></a>}</p>
<p><a id="c002_c2-para-1364"></a>Of course, there are better ways to represent large sets than as unordered lists. Information-retrieval systems in which records have to be “randomly accessed” are typically implemented by a tree-based method, such as the binary-tree representation discussed previously. In designing such a system the methodology of data abstraction can be a great help. The designer can create an initial implementation using a simple, straightforward representation such as unordered lists. This will be unsuitable for the eventual system, but it can be useful in providing a “quick and dirty” data base with which to test the rest of the system. Later on, the data representation can be modified to be more sophisticated. If the data base is accessed in terms of abstract selectors and constructors, this change in representation will not require any changes to the rest of the system.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0100"></a><a id="c002_c2-title-0101"></a>Exercise 2.66</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1365"></a>Implement the <span class="KeyTerm1">lookup</span> function for the case where the set of records is structured as a binary tree, ordered by the numerical values of the keys.</p>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0101"></a><span>2.3.4</span> <a id="c002_c2-title-0102"></a>Example: Huffman Encoding Trees</h3>
<p class="paraaftertitle"><a id="c002_c2-para-1366"></a>This section provides practice in the use of list structure and data abstraction to manipulate sets and trees. The application is to methods for representing data as sequences of ones and zeros (bits). For example, the ASCII standard code used to represent text in computers encodes each character as a sequence of seven bits. Using seven bits allows us to distinguish 2<sup>7</sup>, or 128, possible different characters. In general, if we want to distinguish <i>n</i> different symbols, we will need to use log<sub>2</sub> <i>n</i> bits per symbol. If all our messages are made up of the eight symbols A, B, C, D, E, F, G, and H, we can choose a code with three bits per character, for example</p>
<figure><figcaption class="tablecaption"><a id="c002_c2-tbl-0004"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c002_c2-para-1367"></a>A</td>
<td><a id="c002_c2-para-1368"></a>000</td>
<td><a id="c002_c2-para-1369"></a>C</td>
<td><a id="c002_c2-para-1370"></a>010</td>
<td><a id="c002_c2-para-1371"></a>E</td>
<td><a id="c002_c2-para-1372"></a>100</td>
<td><a id="c002_c2-para-1373"></a>G</td>
<td><a id="c002_c2-para-1374"></a>110</td></tr>
<tr>
<td><a id="c002_c2-para-1375"></a>B</td>
<td><a id="c002_c2-para-1376"></a>001</td>
<td><a id="c002_c2-para-1377"></a>D</td>
<td><a id="c002_c2-para-1378"></a>011</td>
<td><a id="c002_c2-para-1379"></a>F</td>
<td><a id="c002_c2-para-1380"></a>101</td>
<td><a id="c002_c2-para-1381"></a>H</td>
<td><a id="c002_c2-para-1382"></a>111</td></tr></tbody></table></div>
</figure>
<p class="paracontinue"><a id="c002_c2-para-1383"></a>With this code, the message</p>
<p class="Sp-text-2"><a id="c002_c2-para-1384"></a>BACADAEAFABBAAAGAH</p>
<p class="paracontinue"><a id="c002_c2-para-1385"></a>is encoded as the string of 54 bits</p>
<p class="Sp-text-2"><a id="c002_c2-para-1386"></a>001000010000011000100000101000001001000000000110000111</p>
<p><a id="c002_c2-para-1387"></a>Codes such as ASCII and the A-through-H code above are known as <i>fixed-length</i> codes, because they represent each symbol in the message with the same number of bits. It is sometimes advantageous to use <i>variable-length</i> codes, in which different symbols may be represented by different numbers of bits. For example, Morse code does not use the same number of dots and dashes for each letter of the alphabet. In particular, E, the most frequent letter, is represented by a single dot. In general, if our messages are such that some symbols appear very frequently and some very rarely, we can encode data more efficiently (i.e., using fewer bits per message) if we assign shorter codes to the frequent symbols. Consider the following alternative code for the letters A through H:</p>
<figure><figcaption class="tablecaption"><a id="c002_c2-tbl-0005"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c002_c2-para-1388"></a>A</td>
<td><a id="c002_c2-para-1389"></a>0</td>
<td><a id="c002_c2-para-1390"></a>C</td>
<td><a id="c002_c2-para-1391"></a>1010</td>
<td><a id="c002_c2-para-1392"></a>E</td>
<td><a id="c002_c2-para-1393"></a>1100</td>
<td><a id="c002_c2-para-1394"></a>G</td>
<td><a id="c002_c2-para-1395"></a>1110</td></tr>
<tr>
<td><a id="c002_c2-para-1396"></a>B</td>
<td><a id="c002_c2-para-1397"></a>100</td>
<td><a id="c002_c2-para-1398"></a>D</td>
<td><a id="c002_c2-para-1399"></a>1011</td>
<td><a id="c002_c2-para-1400"></a>F</td>
<td><a id="c002_c2-para-1401"></a>1101</td>
<td><a id="c002_c2-para-1402"></a>H</td>
<td><a id="c002_c2-para-1403"></a>1111</td></tr></tbody></table></div>
</figure>
<p class="paracontinue"><a id="c002_c2-para-1404"></a>With this code, the same message as above is encoded as the string</p>
<p class="Sp-text-2"><a id="c002_c2-para-1405"></a>100010100101101100011010100100000111001111</p>
<p class="paracontinue"><a id="c002_c2-para-1406"></a>This string contains 42 bits, so it saves more than 20% in space in comparison with the fixed-length code shown above.</p>
<p><a id="c002_c2-para-1407"></a>One of the difficulties of using a variable-length code is knowing when you have reached the end of a symbol in reading a sequence of zeros and ones. Morse code solves this problem by using a special <i>separator code</i> (in this case, a pause) after the sequence of dots and dashes for each letter. Another solution is to design the code in such a way that no complete code for any symbol is the beginning (or <i>prefix</i>) of the code for another symbol. Such a code is called a <i>prefix code</i>. In the example above, A is encoded by 0 and B is encoded by 100, so no other symbol can have a code that begins with 0 or with 100.</p>
<p><a id="c002_c2-para-1408"></a>In general, we can attain significant savings if we use variable-length prefix codes that take advantage of the relative frequencies of the symbols in the messages to be encoded. One particular scheme for doing this is called the Huffman encoding method, after its discoverer, David Huffman. A Huffman code can be represented as a binary tree whose leaves are the symbols that are encoded. At each non-leaf node of the tree there is a set containing all the symbols in the leaves that lie below the node. In addition, each symbol at a leaf is assigned a weight (which is its relative frequency), and each non-leaf node contains a weight that is the sum of all the weights of the leaves lying below it. The weights are not used in the encoding or the decoding process. We will see below how they are used to help construct the tree.</p>
<p><a id="c002_c2-para-1409"></a><a id="c002_c2-fig-0028a"></a><a href="#c2-fig-0028">Figure 2.18</a> shows the Huffman tree for the A-through-H code given above. The weights at the leaves indicate that the tree was designed for messages in which A appears with relative frequency 8, B with relative frequency 3, and the other letters each with relative frequency 1.</p>
<figure id="c002_c2-fig-0028"><img alt="c2-fig-0018.jpg" src="../images/c2-fig-0018.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0028a">Figure 2.18</a></span> <a id="c002_c2-para-1410"></a>A Huffman encoding tree.</p></figcaption></figure>
<p><a id="c002_c2-para-1411"></a>Given a Huffman tree, we can find the encoding of any symbol by starting at the root and moving down until we reach the leaf that holds the symbol. Each time we move down a left branch we add a 0 to the code, and each time we move down a right branch we add a 1. (We decide which branch to follow by testing to see which branch either is the leaf node for the symbol or contains the symbol in its set.) For example, starting from the root of the tree in <a href="#c2-fig-0028">figure 2.18</a>, we arrive at the leaf for D by following a right branch, then a left branch, then a right branch, then a right branch; hence, the code for D is 1011.</p>
<p><a id="c002_c2-para-1412"></a>To decode a bit sequence using a Huffman tree, we begin at the root and use the successive zeros and ones of the bit sequence to determine whether to move down the left or the right branch. Each time we come to a leaf, we have generated a new symbol in the message, at which point we start over from the root of the tree to find the next symbol. For example, suppose we are given the tree above and the sequence 10001010. Starting at the root, we move down the right branch (since the first bit of the string is 1), then down the left branch (since the second bit is 0), then down the left branch (since the third bit is also 0). This brings us to the leaf for B, so the first symbol of the decoded message is B. Now we start again at the root, and we make a left move because the next bit in the string is 0. This brings us to the leaf for A. Then we start again at the root with the rest of the string 1010, so we move right, left, right, left and reach C. Thus, the entire message is BAC.</p>
<section>
<h5><a id="c002_c2-sec-0102"></a><a id="c002_c2-title-0103"></a>Generating Huffman trees</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1413"></a>Given an “alphabet” of symbols and their relative frequencies, how do we construct the “best” code? (In other words, which tree will encode messages with the fewest bits?) Huffman gave an algorithm for doing this and showed that the resulting code is indeed the best variable-length code for messages where the relative frequency of the symbols matches the frequencies with which the code was constructed. We will not prove this optimality of Huffman codes here, but we will show how Huffman trees are constructed.<a id="c002_c2-fn-0038a"></a><a href="#c2-fn-0038"><sup>38</sup></a></p>
<p><a id="c002_c2-para-1414"></a>The algorithm for generating a Huffman tree is very simple. The idea is to arrange the tree so that the symbols with the lowest frequency appear farthest away from the root. Begin with the set of leaf nodes, containing symbols and their frequencies, as determined by the initial data from which the code is to be constructed. Now find two leaves with the lowest weights and merge them to produce a node that has these two nodes as its left and right branches. The weight of the new node is the sum of the two weights. Remove the two leaves from the original set and replace them by this new node. Now continue this process. At each step, merge two nodes with the smallest weights, removing them from the set and replacing them with a node that has these two as its left and right branches. The process stops when there is only one node left, which is the root of the entire tree. Here is how the Huffman tree of <a href="#c2-fig-0028">figure 2.18</a> was generated:</p>
<figure><figcaption class="tablecaption"><a id="c002_c2-tbl-0006"></a></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c002_c2-para-1415"></a>Initial leaves</td>
<td><a id="c002_c2-para-1416"></a>{(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}</td></tr>
<tr>
<td><a id="c002_c2-para-1417"></a>Merge</td>
<td><a id="c002_c2-para-1418"></a>{(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}</td></tr>
<tr>
<td><a id="c002_c2-para-1419"></a>Merge</td>
<td><a id="c002_c2-para-1420"></a>{(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}</td></tr>
<tr>
<td><a id="c002_c2-para-1421"></a>Merge</td>
<td><a id="c002_c2-para-1422"></a>{(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}</td></tr>
<tr>
<td><a id="c002_c2-para-1423"></a>Merge</td>
<td><a id="c002_c2-para-1424"></a>{(A 8) (B 3) ({C D} 2) ({E F G H} 4)}</td></tr>
<tr>
<td><a id="c002_c2-para-1425"></a>Merge</td>
<td><a id="c002_c2-para-1426"></a>{(A 8) ({B C D} 5) ({E F G H} 4)}</td></tr>
<tr>
<td><a id="c002_c2-para-1427"></a>Merge</td>
<td><a id="c002_c2-para-1428"></a>{(A 8) ({B C D E F G H} 9)}</td></tr>
<tr>
<td><a id="c002_c2-para-1429"></a>Final merge</td>
<td><a id="c002_c2-para-1430"></a>{({A B C D E F G H} 17)}</td></tr></tbody></table></div></figure>
<p class="paracontinue"><a id="c002_c2-para-1431"></a>The algorithm does not always specify a unique tree, because there may not be unique smallest-weight nodes at each step. Also, the choice of the order in which the two nodes are merged (i.e., which will be the right branch and which will be the left branch) is arbitrary.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0103"></a><a id="c002_c2-title-0104"></a>Representing Huffman trees</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1432"></a>In the exercises below we will work with a system that uses Huffman trees to encode and decode messages and generates Huffman trees according to the algorithm outlined above. We will begin by discussing how trees are represented.</p>
<p><a id="c002_c2-para-1433"></a>Leaves of the tree are represented by a list consisting of the string <span class="KeyTerm1">"leaf"</span>, the symbol at the leaf, and the weight:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1434"></a><b>function</b> make_leaf(symbol, weight) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1435"></a> <b>return</b> list("leaf", symbol, weight);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1436"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1437"></a><b>function</b> is_leaf(object) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1438"></a> <b>return</b> head(object) === "leaf";</p>
<p class="Sp-text-1"><a id="c002_c2-para-1439"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1440"></a><b>function</b> symbol_leaf(x) { <b>return</b> head(tail(x)); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1441"></a><b>function</b> weight_leaf(x) { <b>return</b> head(tail(tail(x))); }</p>
<p class="paracontinue"><a id="c002_c2-para-1442"></a>A general tree will be a list of a string <span class="KeyTerm1">"code_tree"</span>, a left branch, a right branch, a set of symbols, and a weight. The set of symbols will be simply a list of the symbols, rather than some more sophisticated set representation. When we make a tree by merging two nodes, we obtain the weight of the tree as the sum of the weights of the nodes, and the set of symbols as the union of the sets of symbols for the nodes. Since our symbol sets are represented as lists, we can form the union by using the <span class="KeyTerm1">append</span> function we defined in section 2.2.1:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1443"></a><b>function</b> make_code_tree(left, right) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1444"></a> <b>return</b> list("code_tree", left, right,</p>
<p class="Sp-text-1"><a id="c002_c2-para-1445"></a>                append(symbols(left), symbols(right)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1446"></a>                weight(left) + weight(right));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1447"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1448"></a>If we make a tree in this way, we have the following selectors:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1449"></a><b>function</b> left_branch(tree) { <b>return</b> head(tail(tree)); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1450"></a><b>function</b> right_branch(tree) { <b>return</b> head(tail(tail(tree))); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1451"></a><b>function</b> symbols(tree) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1452"></a> <b>return</b> is_leaf(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1453"></a>           ? list(symbol_leaf(tree))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1454"></a>           : head(tail(tail(tail(tree))));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1455"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1456"></a><b>function</b> weight(tree) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1457"></a> <b>return</b> is_leaf(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1458"></a>           ? weight_leaf(tree)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1459"></a>           : head(tail(tail(tail(tail(tree)))));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1460"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1461"></a>The functions <span class="KeyTerm1">symbols</span> and <span class="KeyTerm1">weight</span> must do something slightly different depending on whether they are called with a leaf or a general tree. These are simple examples of <i>generic functions</i> (functions that can handle more than one kind of data), which we will have much more to say about in sections 2.4 and 2.5.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0104"></a><a id="c002_c2-title-0105"></a>The decoding function</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1462"></a>The following function implements the decoding algorithm. It takes as arguments a list of zeros and ones, together with a Huffman tree.</p>
<p class="Sp-text-1"><a id="c002_c2-para-1463"></a><b>function</b> decode(bits, tree) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1464"></a> <b>function</b> decode_1(bits, current_branch) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1465"></a> <b>if</b> (is_null(bits)) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1466"></a> <b>return null</b>;</p>
<p class="Sp-text-1"><a id="c002_c2-para-1467"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1468"></a> <b>const</b> next_branch = choose_branch(head(bits),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1469"></a>                                              current_branch);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1470"></a> <b>return</b> is_leaf(next_branch)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1471"></a>                   ? pair(symbol_leaf(next_branch),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1472"></a>                          decode_1(tail(bits), tree))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1473"></a>                   : decode_1(tail(bits), next_branch);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1474"></a>        }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1475"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1476"></a> <b>return</b> decode_1(bits, tree);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1477"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1478"></a><b>function</b> choose_branch(bit, branch) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1479"></a> <b>return</b> bit === 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-1480"></a>           ? left_branch(branch)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1481"></a>           : bit === 1</p>
<p class="Sp-text-1"><a id="c002_c2-para-1482"></a>           ? right_branch(branch)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1483"></a>           : error(bit, "bad bit – choose_branch");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1484"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1485"></a>The function <span class="KeyTerm1">decode_1</span> takes two arguments: the list of remaining bits and the current position in the tree. It keeps moving “down” the tree, choosing a left or a right branch according to whether the next bit in the list is a zero or a one. (This is done with the function <span class="KeyTerm1">choose_branch</span>.) When it reaches a leaf, it returns the symbol at that leaf as the next symbol in the message by adjoining it to the result of decoding the rest of the message, starting at the root of the tree. Note the error check in the final clause of <span class="KeyTerm1">choose_branch</span>, which complains if the function finds something other than a zero or a one in the input data.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0105"></a><a id="c002_c2-title-0106"></a>Sets of weighted elements</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1486"></a>In our representation of trees, each non-leaf node contains a set of symbols, which we have represented as a simple list. However, the tree-generating algorithm discussed above requires that we also work with sets of leaves and trees, successively merging the two smallest items. Since we will be required to repeatedly find the smallest item in a set, it is convenient to use an ordered representation for this kind of set.</p>
<p><a id="c002_c2-para-1487"></a>We will represent a set of leaves and trees as a list of elements, arranged in increasing order of weight. The following <span class="KeyTerm1">adjoin_set</span> function for constructing sets is similar to the one described in exercise 2.61; however, items are compared by their weights, and the element being added to the set is never already in it.</p>
<p class="Sp-text-1"><a id="c002_c2-para-1488"></a><b>function</b> adjoin_set(x, set) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1489"></a> <b>return</b> is_null(set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1490"></a>           ? list(x)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1491"></a>           : weight(x) &lt; weight(head(set))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1492"></a>           ? pair(x, set)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1493"></a>           : pair(head(set), adjoin_set(x, tail(set)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1494"></a>}</p>
<p><a id="c002_c2-para-1495"></a>The following function takes a list of symbol-frequency pairs such as</p>
<p class="Sp-text-1"><a id="c002_c2-para-1496"></a>list(list("A", 4), list("B", 2), list("C", 1), list("D", 1))</p>
<p class="paracontinue"><a id="c002_c2-para-1497"></a>and constructs an initial ordered set of leaves, ready to be merged according to the Huffman algorithm:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1498"></a><b>function</b> make_leaf_set(pairs) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1499"></a> <b>if</b> (is_null(pairs)) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1500"></a> <b>return null</b>;</p>
<p class="Sp-text-1"><a id="c002_c2-para-1501"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1502"></a> <b>const</b> first_pair = head(pairs);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1503"></a> <b>return</b> adjoin_set(</p>
<p class="Sp-text-1"><a id="c002_c2-para-1504"></a>                   make_leaf(head(first_pair),        <span class="KeyTerm2"><i>// symbol</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1505"></a>                             head(tail(first_pair))), <span class="KeyTerm2"><i>// frequency</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1506"></a>                   make_leaf_set(tail(pairs)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1507"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1508"></a>}</p>
</section>
<section>
<h5><a id="c002_c2-sec-0106"></a><a id="c002_c2-title-0107"></a>Exercise 2.67</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1509"></a>Declare an encoding tree and a sample message:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1510"></a><b>const</b> sample_tree = make_code_tree(make_leaf("A", 4),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1511"></a>                                   make_code_tree(make_leaf("B", 2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1512"></a>                                                  make_code_tree(</p>
<p class="Sp-text-1"><a id="c002_c2-para-1513"></a>                                                      make_leaf("D", 1),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1514"></a>                                                      make_leaf("C", 1))));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1515"></a><b>const</b> sample_message = list(0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0);</p>
<p class="paracontinue"><a id="c002_c2-para-1516"></a>Use the <span class="KeyTerm1">decode</span> function to decode the message, and give the result.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0107"></a><a id="c002_c2-title-0108"></a>Exercise 2.68</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1517"></a>The <span class="KeyTerm1">encode</span> function takes as arguments a message and a tree and produces the list of bits that gives the encoded message.</p>
<p class="Sp-text-1"><a id="c002_c2-para-1518"></a><b>function</b> encode(message, tree) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1519"></a> <b>return</b> is_null(message)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1520"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c002_c2-para-1521"></a>           : append(encode_symbol(head(message), tree),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1522"></a>                    encode(tail(message), tree));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1523"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1524"></a>The function <span class="KeyTerm1">encode_symbol</span>, which you must write, returns the list of bits that encodes a given symbol according to a given tree. You should design <span class="KeyTerm1">encode_symbol</span> so that it signals an error if the symbol is not in the tree at all. Test your function by encoding the result you obtained in exercise 2.67 with the sample tree and seeing whether it is the same as the original sample message.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0108"></a><a id="c002_c2-title-0109"></a>Exercise 2.69</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1525"></a>The following function takes as its argument a list of symbol-frequency pairs (where no symbol appears in more than one pair) and generates a Huffman encoding tree according to the Huffman algorithm.</p>
<p class="Sp-text-1"><a id="c002_c2-para-1526"></a><b>function</b> generate_huffman_tree(pairs) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1527"></a> <b>return</b> successive_merge(make_leaf_set(pairs));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1528"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1529"></a>The function <span class="KeyTerm1">make_leaf_set</span> that transforms the list of pairs into an ordered set of leaves is given above. Write the function <span class="KeyTerm1">successive_merge</span> using <span class="KeyTerm1">make_code_tree</span> to successively merge the smallest-weight elements of the set until there is only one element left, which is the desired Huffman tree. (This function is slightly tricky, but not really complicated. If you find yourself designing a complex function, then you are almost certainly doing something wrong. You can take significant advantage of the fact that we are using an ordered set representation.)</p>
</section>
<section>
<h5><a id="c002_c2-sec-0109"></a><a id="c002_c2-title-0110"></a>Exercise 2.70</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1530"></a>The following eight-symbol alphabet with associated relative frequencies was designed to efficiently encode the lyrics of 1950s rock songs. (Note that the “symbols” of an “alphabet” need not be individual letters.)</p>
<figure><figcaption class="tablecaption"><a id="c002_c2-tbl-0007"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c002_c2-para-1531"></a>A</td>
<td><a id="c002_c2-para-1532"></a>2</td>
<td><a id="c002_c2-para-1533"></a>NA</td>
<td><a id="c002_c2-para-1534"></a>16</td></tr>
<tr>
<td><a id="c002_c2-para-1535"></a>BOOM</td>
<td><a id="c002_c2-para-1536"></a>1</td>
<td><a id="c002_c2-para-1537"></a>SHA</td>
<td><a id="c002_c2-para-1538"></a>3</td></tr>
<tr>
<td><a id="c002_c2-para-1539"></a>GET</td>
<td><a id="c002_c2-para-1540"></a>2</td>
<td><a id="c002_c2-para-1541"></a>YIP</td>
<td><a id="c002_c2-para-1542"></a>9</td></tr>
<tr>
<td><a id="c002_c2-para-1543"></a>JOB</td>
<td><a id="c002_c2-para-1544"></a>2</td>
<td><a id="c002_c2-para-1545"></a>WAH</td>
<td><a id="c002_c2-para-1546"></a>1</td></tr></tbody></table></div>
</figure>
<p class="paracontinue"><a id="c002_c2-para-1547"></a>Use <span class="KeyTerm1">generate_huffman_tree</span> (exercise 2.69) to generate a corresponding Huffman tree, and use <span class="KeyTerm1">encode</span> (exercise 2.68) to encode the following message:</p>
<p class="Sp-text-2"><a id="c002_c2-para-1548"></a>Get a job</p>
<p class="Sp-text-2"><a id="c002_c2-para-1549"></a>Sha na na na na na na na na</p>
<p class="Sp-text-2"><a id="c002_c2-para-1550"></a>Get a job</p>
<p class="Sp-text-2"><a id="c002_c2-para-1551"></a>Sha na na na na na na na na</p>
<p class="Sp-text-2"><a id="c002_c2-para-1552"></a>Wah yip yip yip yip yip yip yip yip yip</p>
<p class="Sp-text-2"><a id="c002_c2-para-1553"></a>Sha boom</p>
<p class="paracontinue"><a id="c002_c2-para-1554"></a>How many bits are required for the encoding? What is the smallest number of bits that would be needed to encode this song if we used a fixed-length code for the eight-symbol alphabet?</p>
</section>
<section>
<h5><a id="c002_c2-sec-0110"></a><a id="c002_c2-title-0111"></a>Exercise 2.71</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1555"></a>Suppose we have a Huffman tree for an alphabet of <i>n</i> symbols, and that the relative frequencies of the symbols are 1, 2, 4, . . ., 2<i><sup>n</sup></i><sup>–1</sup>. Sketch the tree for <i>n</i>=5; for <i>n</i>=10. In such a tree (for general <i>n</i>) how may bits are required to encode the most frequent symbol? the least frequent symbol?</p>
</section>
<section>
<h5><a id="c002_c2-sec-0111"></a><a id="c002_c2-title-0112"></a>Exercise 2.72</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1556"></a>Consider the encoding function that you designed in exercise 2.68. What is the order of growth in the number of steps needed to encode a symbol? Be sure to include the number of steps needed to search the symbol list at each node encountered. To answer this question in general is difficult. Consider the special case where the relative frequencies of the <i>n</i> symbols are as described in exercise 2.71, and give the order of growth (as a function of <i>n</i>) of the number of steps needed to encode the most frequent and least frequent symbols in the alphabet.</p>
</section>
</section>
</section>
<section>
<h2><a id="c002_c2-sec-0112"></a><span>2.4</span> <a id="c002_c2-title-0113"></a>Multiple Representations for Abstract Data</h2>
<p class="paraaftertitle"><a id="c002_c2-para-1557"></a>We have introduced data abstraction, a methodology for structuring systems in such a way that much of a program can be specified independent of the choices involved in implementing the data objects that the program manipulates. For example, we saw in section 2.1.1 how to separate the task of designing a program that uses rational numbers from the task of implementing rational numbers in terms of the computer language's primitive mechanisms for constructing compound data. The key idea was to erect an abstraction barrier—in this case, the selectors and constructors for rational numbers (<span class="KeyTerm1">make_rat</span>, <span class="KeyTerm1">numer</span>, <span class="KeyTerm1">denom</span>)—that isolates the way rational numbers are used from their underlying representation in terms of list structure. A similar abstraction barrier isolates the details of the functions that perform rational arithmetic (<span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">sub_rat</span>, <span class="KeyTerm1">mul_rat</span>, and <span class="KeyTerm1">div_rat</span>) from the “higher-level” functions that use rational numbers. The resulting program has the structure shown in <a href="#c2-fig-0002">figure 2.1</a>.</p>
<p><a id="c002_c2-para-1558"></a>These data-abstraction barriers are powerful tools for controlling complexity. By isolating the underlying representations of data objects, we can divide the task of designing a large program into smaller tasks that can be performed separately. But this kind of data abstraction is not yet powerful enough, because it may not always make sense to speak of “the underlying representation” for a data object.</p>
<p><a id="c002_c2-para-1559"></a>For one thing, there might be more than one useful representation for a data object, and we might like to design systems that can deal with multiple representations. To take a simple example, complex numbers may be represented in two almost equivalent ways: in rectangular form (real and imaginary parts) and in polar form (magnitude and angle). Sometimes rectangular form is more appropriate and sometimes polar form is more appropriate. Indeed, it is perfectly plausible to imagine a system in which complex numbers are represented in both ways, and in which the functions for manipulating complex numbers work with either representation.</p>
<p><a id="c002_c2-para-1560"></a>More importantly, programming systems are often designed by many people working over extended periods of time, subject to requirements that change over time. In such an environment, it is simply not possible for everyone to agree in advance on choices of data representation. So in addition to the data-abstraction barriers that isolate representation from use, we need abstraction barriers that isolate different design choices from each other and permit different choices to coexist in a single program. Furthermore, since large programs are often created by combining preexisting modules that were designed in isolation, we need conventions that permit programmers to incorporate modules into larger systems <i>additively</i>, that is, without having to redesign or reimplement these modules.</p>
<p><a id="c002_c2-para-1561"></a>In this section, we will learn how to cope with data that may be represented in different ways by different parts of a program. This requires constructing <i>generic functions</i>—functions that can operate on data that may be represented in more than one way. Our main technique for building generic functions will be to work in terms of data objects that have <i>type tags</i>, that is, data objects that include explicit information about how they are to be processed. We will also discuss <i>data-directed</i> programming, a powerful and convenient implementation strategy for additively assembling systems with generic operations.</p>
<p><a id="c002_c2-para-1562"></a>We begin with the simple complex-number example. We will see how type tags and data-directed style enable us to design separate rectangular and polar representations for complex numbers while maintaining the notion of an abstract “complex-number” data object. We will accomplish this by defining arithmetic functions for complex numbers (<span class="KeyTerm1">add_complex</span>, <span class="KeyTerm1">sub_complex</span>, <span class="KeyTerm1">mul_complex</span>, and <span class="KeyTerm1">div_complex</span>) in terms of generic selectors that access parts of a complex number independent of how the number is represented. The resulting complex-number system, as shown in <a id="c002_c2-fig-0029a"></a><a href="#c2-fig-0029">figure 2.19</a>, contains two different kinds of abstraction barriers. The “horizontal” abstraction barriers play the same role as the ones in <a href="#c2-fig-0002">figure 2.1</a>. They isolate “higher-level” operations from “lower-level” representations. In addition, there is a “vertical” barrier that gives us the ability to separately design and install alternative representations.</p>
<figure id="c002_c2-fig-0029"><img alt="c2-fig-0019.jpg" src="../images/c2-fig-0019.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0029a">Figure 2.19</a></span> <a id="c002_c2-para-1563"></a>Data-abstraction barriers in the complex-number system.</p></figcaption></figure>
<p><a id="c002_c2-para-1564"></a>In section 2.5 we will show how to use type tags and data-directed style to develop a generic arithmetic package. This provides functions (<span class="KeyTerm1">add</span>, <span class="KeyTerm1">mul</span>, and so on) that can be used to manipulate all sorts of “numbers” and can be easily extended when a new kind of number is needed. In section 2.5.3, we'll show how to use generic arithmetic in a system that performs symbolic algebra.</p>
<section>
<h3><a id="c002_c2-sec-0113"></a><span>2.4.1</span> <a id="c002_c2-title-0114"></a>Representations for Complex Numbers</h3>
<p class="paraaftertitle"><a id="c002_c2-para-1565"></a>We will develop a system that performs arithmetic operations on complex numbers as a simple but unrealistic example of a program that uses generic operations. We begin by discussing two plausible representations for complex numbers as ordered pairs: rectangular form (real part and imaginary part) and polar form (magnitude and angle).<a id="c002_c2-fn-0039a"></a><a href="#c2-fn-0039"><sup>39</sup></a> Section 2.4.2 will show how both representations can be made to coexist in a single system through the use of type tags and generic operations.</p>
<p><a id="c002_c2-para-1566"></a>Like rational numbers, complex numbers are naturally represented as ordered pairs. The set of complex numbers can be thought of as a two-dimensional space with two orthogonal axes, the “real” axis and the “imaginary” axis. (See <a id="c002_c2-fig-0030a"></a><a href="#c2-fig-0030">figure 2.20</a>.) From this point of view, the complex number <i>z</i> = <i>x</i> + <i>iy</i> (where <i>i</i><sup>2</sup> = –1) can be thought of as the point in the plane whose real coordinate is <i>x</i> and whose imaginary coordinate is <i>y</i>. Addition of complex numbers reduces in this representation to addition of coordinates:</p>
<figure><figcaption class="tablecaption"><a id="c002_c2-tbl-0008"></a></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c002_c2-para-1568"></a>Real-part(<i>z</i><sub>1</sub> + <i>z</i><sub>2</sub>)</td>
<td><a id="c002_c2-para-1569"></a>=</td>
<td><a id="c002_c2-para-1570"></a>Real-part(<i>z</i><sub>1</sub>) + Real-part(<i>z</i><sub>2</sub>)</td></tr>
<tr>
<td><a id="c002_c2-para-1571"></a>Imaginary-part(<i>z</i><sub>1</sub> + <i>z</i><sub>2</sub>)</td>
<td><a id="c002_c2-para-1572"></a>=</td>
<td><a id="c002_c2-para-1573"></a>Imaginary-part(<i>z</i><sub>1</sub>) + Imaginary-part(<i>z</i><sub>2</sub>)</td></tr></tbody></table></div></figure>
<figure id="c002_c2-fig-0030"><img alt="c2-fig-0020.jpg" src="../images/c2-fig-0020.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0030a">Figure 2.20</a></span> <a id="c002_c2-para-1567"></a>Complex numbers as points in the plane.</p></figcaption></figure>
<p><a id="c002_c2-para-1574"></a>When multiplying complex numbers, it is more natural to think in terms of representing a complex number in polar form, as a magnitude and an angle (<i>r</i> and <i>A</i> in <a href="#c2-fig-0030">figure 2.20</a>). The product of two complex numbers is the vector obtained by stretching one complex number by the length of the other and then rotating it through the angle of the other:</p>
<figure><figcaption class="tablecaption"><a id="c002_c2-tbl-0009"></a></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c002_c2-para-1575"></a>Magnitude(<i>z</i><sub>1</sub> <i>· z</i><sub>2</sub>)</td>
<td><a id="c002_c2-para-1576"></a>=</td>
<td><a id="c002_c2-para-1577"></a>Magnitude(<i>z</i><sub>1</sub>) <i>·</i> Magnitude(<i>z</i><sub>2</sub>)</td></tr>
<tr>
<td><a id="c002_c2-para-1578"></a>Angle(<i>z</i><sub>1</sub> <i>· z</i><sub>2</sub>)</td>
<td><a id="c002_c2-para-1579"></a>=</td>
<td><a id="c002_c2-para-1580"></a>Angle(<i>z</i><sub>1</sub>) + Angle(<i>z</i><sub>2</sub>)</td></tr></tbody></table></div></figure>
<p><a id="c002_c2-para-1581"></a>Thus, there are two different representations for complex numbers, which are appropriate for different operations. Yet, from the viewpoint of someone writing a program that uses complex numbers, the principle of data abstraction suggests that all the operations for manipulating complex numbers should be available regardless of which representation is used by the computer. For example, it is often useful to be able to find the magnitude of a complex number that is specified by rectangular coordinates. Similarly, it is often useful to be able to determine the real part of a complex number that is specified by polar coordinates.</p>
<p><a id="c002_c2-para-1582"></a>To design such a system, we can follow the same data-abstraction strategy we followed in designing the rational-number package in section 2.1.1. Assume that the operations on complex numbers are implemented in terms of four selectors: <span class="KeyTerm1">real_part</span>, <span class="KeyTerm1">imag_part</span>, <span class="KeyTerm1">magnitude</span>, and <span class="KeyTerm1">angle</span>. Also assume that we have two functions for constructing complex numbers: <span class="KeyTerm1">make_from_real_imag</span> returns a complex number with specified real and imaginary parts, and <span class="KeyTerm1">make_from_mag_ang</span> returns a complex number with specified magnitude and angle. These functions have the property that, for any complex number <span class="KeyTerm1">z</span>, both</p>
<p class="Sp-text-1"><a id="c002_c2-para-1583"></a>make_from_real_imag(real_part(z), imag_part(z));</p>
<p class="paracontinue"><a id="c002_c2-para-1584"></a>and</p>
<p class="Sp-text-1"><a id="c002_c2-para-1585"></a>make_from_mag_ang(magnitude(z), angle(z));</p>
<p class="paracontinue"><a id="c002_c2-para-1586"></a>produce complex numbers that are equal to <span class="KeyTerm1">z</span>.</p>
<p><a id="c002_c2-para-1587"></a>Using these constructors and selectors, we can implement arithmetic on complex numbers using the “abstract data” specified by the constructors and selectors, just as we did for rational numbers in section 2.1.1. As shown in the formulas above, we can add and subtract complex numbers in terms of real and imaginary parts while multiplying and dividing complex numbers in terms of magnitudes and angles:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1588"></a><b>function</b> add_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1589"></a> <b>return</b> make_from_real_imag(real_part(z1) + real_part(z2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1590"></a>                               imag_part(z1) + imag_part(z2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1591"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1592"></a><b>function</b> sub_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1593"></a> <b>return</b> make_from_real_imag(real_part(z1) - real_part(z2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1594"></a>                               imag_part(z1) - imag_part(z2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1595"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1596"></a><b>function</b> mul_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1597"></a> <b>return</b> make_from_mag_ang(magnitude(z1) * magnitude(z2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1598"></a>                             angle(z1) + angle(z2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1599"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1600"></a><b>function</b> div_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1601"></a> <b>return</b> make_from_mag_ang(magnitude(z1) / magnitude(z2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1602"></a>                             angle(z1) - angle(z2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1603"></a>}</p>
<p><a id="c002_c2-para-1604"></a>To complete the complex-number package, we must choose a representation and we must implement the constructors and selectors in terms of primitive numbers and primitive list structure. There are two obvious ways to do this: We can represent a complex number in “rectangular form” as a pair (real part, imaginary part) or in “polar form” as a pair (magnitude, angle). Which shall we choose?</p>
<p><a id="c002_c2-para-1605"></a>In order to make the different choices concrete, imagine that there are two programmers, Ben Bitdiddle and Alyssa P. Hacker, who are independently designing representations for the complex-number system. Ben chooses to represent complex numbers in rectangular form. With this choice, selecting the real and imaginary parts of a complex number is straightforward, as is constructing a complex number with given real and imaginary parts. To find the magnitude and the angle, or to construct a complex number with a given magnitude and angle, he uses the trigonometric relations</p>
<figure><figcaption class="tablecaption"><a id="c002_c2-tbl-0010"></a></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c002_c2-para-1606"></a><i>x</i> = <i>r</i> cos <i>A</i></td>
<td><a id="c002_c2-para-1607"></a><i>r</i> = <img alt="c2-fig-5011.jpg" src="../images/c2-fig-5011.jpg"/></td></tr>
<tr>
<td><a id="c002_c2-para-1608"></a><i>y</i> = <i>r</i> sin <i>A</i></td>
<td><a id="c002_c2-para-1609"></a><i>A</i> = arctan(<i>y</i>, <i>x</i>)</td></tr></tbody></table></div></figure>
<p class="paracontinue"><a id="c002_c2-para-1610"></a>which relate the real and imaginary parts (<i>x</i>, <i>y</i>) to the magnitude and the angle (<i>r</i>, <i>A</i>).<a id="c002_c2-fn-0040a"></a><a href="#c2-fn-0040"><sup>40</sup></a> Ben's representation is therefore given by the following selectors and constructors:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1611"></a><b>function</b> real_part(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1612"></a><b>function</b> imag_part(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1613"></a><b>function</b> magnitude(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1614"></a> <b>return</b> math_sqrt(square(real_part(z)) + square(imag_part(z)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1615"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1616"></a><b>function</b> angle(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1617"></a> <b>return</b> math_atan2(imag_part(z), real_part(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1618"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1619"></a><b>function</b> make_from_real_imag(x, y) { <b>return</b> pair(x, y); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1620"></a><b>function</b> make_from_mag_ang(r, a) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1621"></a> <b>return</b> pair(r * math_cos(a), r * math_sin(a));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1622"></a>}</p>
<p><a id="c002_c2-para-1623"></a>Alyssa, in contrast, chooses to represent complex numbers in polar form. For her, selecting the magnitude and angle is straightforward, but she has to use the trigonometric relations to obtain the real and imaginary parts. Alyssa's representation is:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1624"></a><b>function</b> real_part(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1625"></a> <b>return</b> magnitude(z) * math_cos(angle(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1626"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1627"></a><b>function</b> imag_part(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1628"></a> <b>return</b> magnitude(z) * math_sin(angle(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1629"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1630"></a><b>function</b> magnitude(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1631"></a><b>function</b> angle(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1632"></a><b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1633"></a> <b>return</b> pair(math_sqrt(square(x) + square(y)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1634"></a>                math_atan2(y, x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1635"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1636"></a><b>function</b> make_from_mag_ang(r, a) { <b>return</b> pair(r, a); }</p>
<p><a id="c002_c2-para-1637"></a>The discipline of data abstraction ensures that the same implementation of <span class="KeyTerm1">add_ complex</span>, <span class="KeyTerm1">sub_complex</span>, <span class="KeyTerm1">mul_complex</span>, and <span class="KeyTerm1">div_complex</span> will work with either Ben's representation or Alyssa's representation.</p>
</section>
<section>
<h3><a id="c002_c2-sec-0114"></a><span>2.4.2</span> <a id="c002_c2-title-0115"></a>Tagged data</h3>
<p class="paraaftertitle"><a id="c002_c2-para-1638"></a>One way to view data abstraction is as an application of the “principle of least commitment.” In implementing the complex-number system in section 2.4.1, we can use either Ben's rectangular representation or Alyssa's polar representation. The abstraction barrier formed by the selectors and constructors permits us to defer to the last possible moment the choice of a concrete representation for our data objects and thus retain maximum flexibility in our system design.</p>
<p><a id="c002_c2-para-1639"></a>The principle of least commitment can be carried to even further extremes. If we desire, we can maintain the ambiguity of representation even <i>after</i> we have designed the selectors and constructors, and elect to use both Ben's representation <i>and</i> Alyssa's representation. If both representations are included in a single system, however, we will need some way to distinguish data in polar form from data in rectangular form. Otherwise, if we were asked, for instance, to find the <span class="KeyTerm1">magnitude</span> of the pair (3, 4), we wouldn't know whether to answer 5 (interpreting the number in rectangular form) or 3 (interpreting the number in polar form). A straightforward way to accomplish this distinction is to include a <i>type tag</i>—the string <span class="KeyTerm1">"rectangular"</span> or <span class="KeyTerm1">"polar"</span>—as part of each complex number. Then when we need to manipulate a complex number we can use the tag to decide which selector to apply.</p>
<p><a id="c002_c2-para-1640"></a>In order to manipulate tagged data, we will assume that we have functions <span class="KeyTerm1">type_tag</span> and <span class="KeyTerm1">contents</span> that extract from a data object the tag and the actual contents (the polar or rectangular coordinates, in the case of a complex number). We will also postulate a function <span class="KeyTerm1">attach_tag</span> that takes a tag and contents and produces a tagged data object. A straightforward way to implement this is to use ordinary list structure:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1641"></a><b>function</b> attach_tag(type_tag, contents) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1642"></a> <b>return</b> pair(type_tag, contents);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1643"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1644"></a><b>function</b> type_tag(datum) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1645"></a> <b>return</b> is_pair(datum)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1646"></a>           ? head(datum)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1647"></a>           : error(datum, "bad tagged datum – type_tag");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1648"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1649"></a><b>function</b> contents(datum) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1650"></a> <b>return</b> is_pair(datum)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1651"></a>           ? tail(datum)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1652"></a>           : error(datum, "bad tagged datum – contents");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1653"></a>}</p>
<p><a id="c002_c2-para-1654"></a>Using <span class="KeyTerm1">type_tag</span>, we can define predicates <span class="KeyTerm1">is_rectangular</span> and <span class="KeyTerm1">is_polar</span>, which recognize rectangular and polar numbers, respectively:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1655"></a><b>function</b> is_rectangular(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1656"></a> <b>return</b> type_tag(z) === "rectangular";</p>
<p class="Sp-text-1"><a id="c002_c2-para-1657"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1658"></a><b>function</b> is_polar(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1659"></a> <b>return</b> type_tag(z) === "polar";</p>
<p class="Sp-text-1"><a id="c002_c2-para-1660"></a>}</p>
<p><a id="c002_c2-para-1661"></a>With type tags, Ben and Alyssa can now modify their code so that their two different representations can coexist in the same system. Whenever Ben constructs a complex number, he tags it as rectangular. Whenever Alyssa constructs a complex number, she tags it as polar. In addition, Ben and Alyssa must make sure that the names of their functions do not conflict. One way to do this is for Ben to append the suffix <span class="KeyTerm1">rectangular</span> to the name of each of his representation functions and for Alyssa to append <span class="KeyTerm1">polar</span> to the names of hers. Here is Ben's revised rectangular representation from section 2.4.1:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1662"></a><b>function</b> real_part_rectangular(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1663"></a><b>function</b> imag_part_rectangular(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1664"></a><b>function</b> magnitude_rectangular(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1665"></a> <b>return</b> math_sqrt(square(real_part_rectangular(z)) +</p>
<p class="Sp-text-1"><a id="c002_c2-para-1666"></a>                     square(imag_part_rectangular(z)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1667"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1668"></a><b>function</b> angle_rectangular(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1669"></a> <b>return</b> math_atan(imag_part_rectangular(z),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1670"></a>                     real_part_rectangular(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1671"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1672"></a><b>function</b> make_from_real_imag_rectangular(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1673"></a> <b>return</b> attach_tag("rectangular", pair(x, y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1674"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1675"></a><b>function</b> make_from_mag_ang_rectangular(r, a) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1676"></a> <b>return</b> attach_tag("rectangular",</p>
<p class="Sp-text-1"><a id="c002_c2-para-1677"></a>                      pair(r * math_cos(a), r * math_sin(a)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1678"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1679"></a>and here is Alyssa's revised polar representation:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1680"></a><b>function</b> real_part_polar(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1681"></a> <b>return</b> magnitude_polar(z) * math_cos(angle_polar(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1682"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1683"></a><b>function</b> imag_part_polar(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1684"></a> <b>return</b> magnitude_polar(z) * math_sin(angle_polar(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1685"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1686"></a><b>function</b> magnitude_polar(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1687"></a><b>function</b> angle_polar(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1688"></a><b>function</b> make_from_real_imag_polar(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1689"></a> <b>return</b> attach_tag("polar",</p>
<p class="Sp-text-1"><a id="c002_c2-para-1690"></a>                      pair(math_sqrt(square(x) + square(y)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1691"></a>                           math_atan(y, x)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1692"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1693"></a><b>function</b> make_from_mag_ang_polar(r, a) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1694"></a> <b>return</b> attach_tag("polar", pair(r, a));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1695"></a>}</p>
<p><a id="c002_c2-para-1696"></a>Each generic selector is implemented as a function that checks the tag of its argument and calls the appropriate function for handling data of that type. For example, to obtain the real part of a complex number, <span class="KeyTerm1">real_part</span> examines the tag to determine whether to use Ben's <span class="KeyTerm1">real_part_rectangular</span> or Alyssa's <span class="KeyTerm1">real_ part_polar</span>. In either case, we use <span class="KeyTerm1">contents</span> to extract the bare, untagged datum and send this to the rectangular or polar function as required:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1697"></a><b>function</b> real_part(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1698"></a> <b>return</b> is_rectangular(z)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1699"></a>           ? real_part_rectangular(contents(z))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1700"></a>           : is_polar(z)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1701"></a>           ? real_part_polar(contents(z))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1702"></a>           : error(z, "unknown type – real_part");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1703"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1704"></a><b>function</b> imag_part(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1705"></a> <b>return</b> is_rectangular(z)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1706"></a>           ? imag_part_rectangular(contents(z))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1707"></a>           : is_polar(z)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1708"></a>           ? imag_part_polar(contents(z))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1709"></a>           : error(z, "unknown type – imag_part");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1710"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1711"></a><b>function</b> magnitude(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1712"></a> <b>return</b> is_rectangular(z)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1713"></a>           ? magnitude_rectangular(contents(z))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1714"></a>           : is_polar(z)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1715"></a>           ? magnitude_polar(contents(z))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1716"></a>           : error(z, "unknown type – magnitude");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1717"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1718"></a><b>function</b> angle(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1719"></a> <b>return</b> is_rectangular(z)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1720"></a>           ? angle_rectangular(contents(z))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1721"></a>           : is_polar(z)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1722"></a>           ? angle_polar(contents(z))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1723"></a>           : error(z, "unknown type – angle");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1724"></a>}</p>
<p><a id="c002_c2-para-1725"></a>To implement the complex-number arithmetic operations, we can use the same functions <span class="KeyTerm1">add_complex</span>, <span class="KeyTerm1">sub_complex</span>, <span class="KeyTerm1">mul_complex</span>, and <span class="KeyTerm1">div_complex</span> from section 2.4.1, because the selectors they call are generic, and so will work with either representation. For example, the function <span class="KeyTerm1">add_complex</span> is still</p>
<p class="Sp-text-1"><a id="c002_c2-para-1726"></a><b>function</b> add_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1727"></a> <b>return</b> make_from_real_imag(real_part(z1) + real_part(z2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1728"></a>                               imag_part(z1) + imag_part(z2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1729"></a>}</p>
<p><a id="c002_c2-para-1730"></a>Finally, we must choose whether to construct complex numbers using Ben's representation or Alyssa's representation. One reasonable choice is to construct rectangular numbers whenever we have real and imaginary parts and to construct polar numbers whenever we have magnitudes and angles:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1731"></a><b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1732"></a> <b>return</b> make_from_real_imag_rectangular(x, y);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1733"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1734"></a><b>function</b> make_from_mag_ang(r, a) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1735"></a> <b>return</b> make_from_mag_ang_polar(r, a);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1736"></a>}</p>
<p><a id="c002_c2-para-1737"></a>The resulting complex-number system has the structure shown in <a id="c002_c2-fig-0031a"></a><a href="#c2-fig-0031">figure 2.21</a>. The system has been decomposed into three relatively independent parts: the complexnumber-arithmetic operations, Alyssa's polar implementation, and Ben's rectangular implementation. The polar and rectangular implementations could have been written by Ben and Alyssa working separately, and both of these can be used as underlying representations by a third programmer implementing the complexarithmetic functions in terms of the abstract constructor/selector interface.</p>
<figure id="c002_c2-fig-0031"><img alt="c2-fig-0021.jpg" src="../images/c2-fig-0021.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0031a">Figure 2.21</a></span> <a id="c002_c2-para-1738"></a>Structure of the generic complex-arithmetic system.</p></figcaption></figure>
<p><a id="c002_c2-para-1739"></a>Since each data object is tagged with its type, the selectors operate on the data in a generic manner. That is, each selector is defined to have a behavior that depends upon the particular type of data it is applied to. Notice the general mechanism for interfacing the separate representations: Within a given representation implementation (say, Alyssa's polar package) a complex number is an untyped pair (magnitude, angle). When a generic selector operates on a number of <span class="KeyTerm1">polar</span> type, it strips off the tag and passes the contents on to Alyssa's code. Conversely, when Alyssa constructs a number for general use, she tags it with a type so that it can be appropriately recognized by the higher-level functions. This discipline of stripping off and attaching tags as data objects are passed from level to level can be an important organizational strategy, as we shall see in section 2.5.</p>
</section>
<section>
<h3><a id="c002_c2-sec-0115"></a><span>2.4.3</span> <a id="c002_c2-title-0116"></a>Data-Directed Programming and Additivity</h3>
<p class="paraaftertitle"><a id="c002_c2-para-1740"></a>The general strategy of checking the type of a datum and calling an appropriate function is called <i>dispatching on type</i>. This is a powerful strategy for obtaining modularity in system design. On the other hand, implementing the dispatch as in section 2.4.2 has two significant weaknesses. One weakness is that the generic interface functions (<span class="KeyTerm1">real_part</span>, <span class="KeyTerm1">imag_part</span>, <span class="KeyTerm1">magnitude</span>, and <span class="KeyTerm1">angle</span>) must know about all the different representations. For instance, suppose we wanted to incorporate a new representation for complex numbers into our complex-number system. We would need to identify this new representation with a type, and then add a clause to each of the generic interface functions to check for the new type and apply the appropriate selector for that representation.</p>
<p><a id="c002_c2-para-1741"></a>Another weakness of the technique is that even though the individual representations can be designed separately, we must guarantee that no two functions in the entire system have the same name. This is why Ben and Alyssa had to change the names of their original functions from section 2.4.1.</p>
<p><a id="c002_c2-para-1742"></a>The issue underlying both of these weaknesses is that the technique for implementing generic interfaces is not <i>additive</i>. The person implementing the generic selector functions must modify those functions each time a new representation is installed, and the people interfacing the individual representations must modify their code to avoid name conflicts. In each of these cases, the changes that must be made to the code are straightforward, but they must be made nonetheless, and this is a source of inconvenience and error. This is not much of a problem for the complexnumber system as it stands, but suppose there were not two but hundreds of different representations for complex numbers. And suppose that there were many generic selectors to be maintained in the abstract-data interface. Suppose, in fact, that no one programmer knew all the interface functions or all the representations. The problem is real and must be addressed in such programs as large-scale data-base-management systems.</p>
<p><a id="c002_c2-para-1743"></a>What we need is a means for modularizing the system design even further. This is provided by the programming technique known as <i>data-directed programming</i>. To understand how data-directed programming works, begin with the observation that whenever we deal with a set of generic operations that are common to a set of different types we are, in effect, dealing with a two-dimensional table that contains the possible operations on one axis and the possible types on the other axis. The entries in the table are the functions that implement each operation for each type of argument presented. In the complex-number system developed in the previous section, the correspondence between operation name, data type, and actual function was spread out among the various conditional clauses in the generic interface functions. But the same information could have been organized in a table, as shown in <a id="c002_c2-fig-0032a"></a><a href="#c2-fig-0032">figure 2.22</a>.</p>
<figure id="c002_c2-fig-0032"><img alt="c2-fig-0022.jpg" src="../images/c2-fig-0022.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0032a">Figure 2.22</a></span> <a id="c002_c2-para-1744"></a>Table of operations for the complex-number system.</p></figcaption></figure>
<p><a id="c002_c2-para-1745"></a>Data-directed programming is the technique of designing programs to work with such a table directly. Previously, we implemented the mechanism that interfaces the complex-arithmetic code with the two representation packages as a set of functions that each perform an explicit dispatch on type. Here we will implement the interface as a single function that looks up the combination of the operation name and argument type in the table to find the correct function to apply, and then applies it to the contents of the argument. If we do this, then to add a new representation package to the system we need not change any existing functions; we need only add new entries to the table.</p>
<p><a id="c002_c2-para-1746"></a>To implement this plan, assume that we have two functions, <span class="KeyTerm1">put</span> and <span class="KeyTerm1">get</span>, for manipulating the operation-and-type table:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">put(</span><i>op</i><span class="KeyTerm1">,</span> <i>type</i><span class="KeyTerm1">,</span> <i>item</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c002_c2-para-1748"></a>installs the <i>item</i> in the table, indexed by the <i>op</i> and the <i>type</i>.</p></li>
<li><span class="KeyTerm1">get(</span><i>op</i><span class="KeyTerm1">,</span> <i>type</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c002_c2-para-1750"></a>looks up the <i>op</i>, <i>type</i> entry in the table and returns the item found there. If no item is found, <span class="KeyTerm1">get</span> returns a unique primitive value that is referred to by the name <span class="KeyTerm1">undefined</span> and recognized by the primitive predicate <span class="KeyTerm1">is_undefined</span>.<a id="c002_c2-fn-0041a"></a><a href="#c2-fn-0041"><sup>41</sup></a></p></li>
</ul>
<p class="paracontinue"><a id="c002_c2-para-1751"></a>For now, we can assume that <span class="KeyTerm1">put</span> and <span class="KeyTerm1">get</span> are included in our language. In chapter 3 (section 3.3.3) we will see how to implement these and other operations for manipulating tables.</p>
<p><a id="c002_c2-para-1752"></a>Here is how data-directed programming can be used in the complex-number system. Ben, who developed the rectangular representation, implements his code just as he did originally. He defines a collection of functions or a <i>package</i>, and interfaces these to the rest of the system by adding entries to the table that tell the system how to operate on rectangular numbers. This is accomplished by calling the following function:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1753"></a><b>function</b> install_rectangular_package() {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1754"></a> <span class="KeyTerm2"><i>// internal functions</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1755"></a> <b>function</b> real_part(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1756"></a> <b>function</b> imag_part(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1757"></a> <b>function</b> make_from_real_imag(x, y) { <b>return</b> pair(x, y); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1758"></a> <b>function</b> magnitude(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1759"></a> <b>return</b> math_sqrt(square(real_part(z)) + square(imag_part(z)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1760"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1761"></a> <b>function</b> angle(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1762"></a> <b>return</b> math_atan(imag_part(z), real_part(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1763"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1764"></a> <b>function</b> make_from_mag_ang(r, a) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1765"></a> <b>return</b> pair(r * math_cos(a), r * math_sin(a));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1766"></a>    }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1767"></a> <span class="KeyTerm2"><i>// interface to the rest of the system</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1768"></a> <b>function</b> tag(x) { <b>return</b> attach_tag("rectangular", x); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1769"></a>    put("real_part", list("rectangular"), real_part);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1770"></a>    put("imag_part", list("rectangular"), imag_part);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1771"></a>    put("magnitude", list("rectangular"), magnitude);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1772"></a>    put("angle", list("rectangular"), angle);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1773"></a>    put("make_from_real_imag", "rectangular",</p>
<p class="Sp-text-1"><a id="c002_c2-para-1774"></a>        (x, y) =&gt; tag(make_from_real_imag(x, y)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1775"></a>    put("make_from_mag_ang", "rectangular",</p>
<p class="Sp-text-1"><a id="c002_c2-para-1776"></a>        (r, a) =&gt; tag(make_from_mag_ang(r, a)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1777"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c002_c2-para-1778"></a>}</p>
<p><a id="c002_c2-para-1779"></a>Notice that the internal functions here are the same functions from section 2.4.1 that Ben wrote when he was working in isolation. No changes are necessary in order to interface them to the rest of the system. Moreover, since these function declarations are internal to the installation function, Ben needn't worry about name conflicts with other functions outside the rectangular package. To interface these to the rest of the system, Ben installs his <span class="KeyTerm1">real_part</span> function under the operation name <span class="KeyTerm1">real_part</span> and the type <span class="KeyTerm1">list("rectangular")</span>, and similarly for the other selectors.<a id="c002_c2-fn-0042a"></a><a href="#c2-fn-0042"><sup>42</sup></a> The interface also defines the constructors to be used by the external system.<a id="c002_c2-fn-0043a"></a><a href="#c2-fn-0043"><sup>43</sup></a> These are identical to Ben's internally defined constructors, except that they attach the tag.</p>
<p><a id="c002_c2-para-1780"></a>Alyssa's polar package is analogous:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1781"></a><b>function</b> install_polar_package() {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1782"></a> <span class="KeyTerm2"><i>// internal functions</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1783"></a> <b>function</b> magnitude(z) { <b>return</b> head(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1784"></a> <b>function</b> angle(z) { <b>return</b> tail(z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1785"></a> <b>function</b> make_from_mag_ang(r, a) { <b>return</b> pair(r, a); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1786"></a> <b>function</b> real_part(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1787"></a> <b>return</b> magnitude(z) * math_cos(angle(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1788"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1789"></a> <b>function</b> imag_part(z) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1790"></a> <b>return</b> magnitude(z) * math_sin(angle(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1791"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1792"></a> <b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1793"></a> <b>return</b> pair(math_sqrt(square(x) + square(y)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1794"></a>                    math_atan(y, x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1795"></a>    }    </p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1796"></a> <span class="KeyTerm2"><i>// interface to the rest of the system</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1797"></a> <b>function</b> tag(x) { <b>return</b> attach_tag("polar", x); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1798"></a>    put("real_part", list("polar"), real_part);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1799"></a>    put("imag_part", list("polar"), imag_part);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1800"></a>    put("magnitude", list("polar"), magnitude);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1801"></a>    put("angle", list("polar"), angle);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1802"></a>    put("make_from_real_imag", "polar",</p>
<p class="Sp-text-1"><a id="c002_c2-para-1803"></a>        (x, y) =&gt; tag(make_from_real_imag(x, y)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1804"></a>    put("make_from_mag_ang", "polar",</p>
<p class="Sp-text-1"><a id="c002_c2-para-1805"></a>        (r, a) =&gt; tag(make_from_mag_ang(r, a)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1806"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c002_c2-para-1807"></a>}</p>
<p><a id="c002_c2-para-1808"></a>Even though Ben and Alyssa both still use their original functions defined with the same names as each other's (e.g., <span class="KeyTerm1">real_part</span>), these declarations are now internal to different functions (see section 1.1.8), so there is no name conflict.</p>
<p><a id="c002_c2-para-1809"></a>The complex-arithmetic selectors access the table by means of a general “operation” function called <span class="KeyTerm1">apply_generic</span>, which applies a generic operation to some arguments. The function <span class="KeyTerm1">apply_generic</span> looks in the table under the name of the operation and the types of the arguments and applies the resulting function if one is present:<a id="c002_c2-fn-0044a"></a><a href="#c2-fn-0044"><sup>44</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-1812"></a><b>function</b> apply_generic(op, args) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1813"></a> <b>const</b> type_tags = map(type_tag, args);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1814"></a> <b>const</b> fun = get(op, type_tags);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1815"></a> <b>return</b> ! is_undefined(fun)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1816"></a>           ? apply_in_underlying_javascript(fun, map(contents, args))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1817"></a>           : error(list(op, type_tags),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1818"></a>                   "no method for these types – apply_generic");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1819"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1820"></a>Using <span class="KeyTerm1">apply_generic</span>, we can define our generic selectors as follows:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1821"></a><b>function</b> real_part(z) { <b>return</b> apply_generic("real_part", list(z)); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1822"></a><b>function</b> imag_part(z) { <b>return</b> apply_generic("imag_part", list(z)); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1823"></a><b>function</b> magnitude(z) { <b>return</b> apply_generic("magnitude", list(z)); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1824"></a><b>function</b> angle(z)     { <b>return</b> apply_generic("angle", list(z));     }</p>
<p class="paracontinue"><a id="c002_c2-para-1825"></a>Observe that these do not change at all if a new representation is added to the system.</p>
<p><a id="c002_c2-para-1826"></a>We can also extract from the table the constructors to be used by the programs external to the packages in making complex numbers from real and imaginary parts and from magnitudes and angles. As in section 2.4.2, we construct rectangular numbers whenever we have real and imaginary parts, and polar numbers whenever we have magnitudes and angles:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1827"></a><b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1828"></a> <b>return</b> get("make_from_real_imag", "rectangular")(x, y);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1829"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1830"></a><b>function</b> make_from_mag_ang(r, a) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1831"></a> <b>return</b> get("make_from_mag_ang", "polar")(r, a);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1832"></a>}</p>
<section>
<h5><a id="c002_c2-sec-0116"></a><a id="c002_c2-title-0117"></a>Exercise 2.73</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1833"></a>Section 2.3.2 described a program that performs symbolic differentiation:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1834"></a><b>function</b> deriv(exp, variable) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1835"></a> <b>return</b> is_number(exp)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1836"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-1837"></a>           : is_variable(exp)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1838"></a>           ? is_same_variable(exp, variable) ? 1 : 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-1839"></a>           : is_sum(exp)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1840"></a>           ? make_sum(deriv(addend(exp), variable),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1841"></a>                      deriv(augend(exp), variable))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1842"></a>           : is_product(exp)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1843"></a>           ? make_sum(make_product(multiplier(exp),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1844"></a>                                   deriv(multiplicand(exp), variable)),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1845"></a>                      make_product(deriv(multiplier(exp), variable),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1846"></a>                                   multiplicand(exp)))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1847"></a> <span class="KeyTerm2"><i>// more rules can be added here</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1848"></a>           : error(exp, "unknown expression type – deriv");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1849"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1850"></a>deriv(list("*", list("*", "x", "y"), list("+", "x", 4)), "x");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1851"></a><i>list("+", list("*", list("*", x, y), list("+", 1, 0)),</i></p>
<p class="Sp-text-1"><a id="c002_c2-para-1852"></a> <i>list("*", list("+", list("*", x, 0), list("*", 1, y)),</i></p>
<p class="Sp-text-1"><a id="c002_c2-para-1853"></a> <i>list("+", x, 4)))</i></p>
<p class="paracontinue"><a id="c002_c2-para-1854"></a>We can regard this program as performing a dispatch on the type of the expression to be differentiated. In this situation the “type tag” of the datum is the algebraic operator symbol (such as "+") and the operation being performed is <span class="KeyTerm1">deriv</span>. We can transform this program into data-directed style by rewriting the basic derivative function as</p>
<p class="Sp-text-1"><a id="c002_c2-para-1855"></a><b>function</b> deriv(exp, variable) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1856"></a> <b>return</b> is_number(exp)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1857"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-1858"></a>           : is_variable(exp)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1859"></a>           ? is_same_variable(exp, variable) ? 1 : 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-1860"></a>           : get("deriv", operator(exp))(operands(exp), variable);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1861"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-1862"></a><b>function</b> operator(exp) { <b>return</b> head(exp); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1863"></a><b>function</b> operands(exp) { <b>return</b> tail(exp); }</p>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0050"></a><span>a. </span>Explain what was done above. Why can't we assimilate the predicates <span class="KeyTerm1">is_number</span> and <span class="KeyTerm1">is_variable</span> into the data-directed dispatch?</li>
<li><a id="c002_c2-li-0051"></a><span>b. </span>Write the functions for derivatives of sums and products, and the auxiliary code required to install them in the table used by the program above.</li>
<li><a id="c002_c2-li-0052"></a><span>c. </span>Choose any additional differentiation rule that you like, such as the one for exponents (exercise 2.56), and install it in this data-directed system.</li>
<li><a id="c002_c2-li-0053"></a><span>d. </span>In this simple algebraic manipulator the type of an expression is the algebraic operator that binds it together. Suppose, however, we indexed the functions in the opposite way, so that the dispatch line in <span class="KeyTerm1">deriv</span> looked like
<p class="Sp-text-1"><a id="c002_c2-para-1868"></a>get(operator(exp), "deriv")(operands(exp), variable);</p>
<p class="paracontinue"><a id="c002_c2-para-1869"></a>What corresponding changes to the derivative system are required?</p></li>
</ol>
</section>
<section>
<h5><a id="c002_c2-sec-0117"></a><a id="c002_c2-title-0118"></a>Exercise 2.74</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1870"></a>Insatiable Enterprises, Inc., is a highly decentralized conglomerate company consisting of a large number of independent divisions located all over the world. The company's computer facilities have just been interconnected by means of a clever network-interfacing scheme that makes the entire network appear to any user to be a single computer. Insatiable's president, in her first attempt to exploit the ability of the network to extract administrative information from division files, is dismayed to discover that, although all the division files have been implemented as data structures in JavaScript, the particular data structure used varies from division to division. A meeting of division managers is hastily called to search for a strategy to integrate the files that will satisfy headquarters’ needs while preserving the existing autonomy of the divisions.</p>
<p><a id="c002_c2-para-1871"></a>Show how such a strategy can be implemented with data-directed programming. As an example, suppose that each division's personnel records consist of a single file, which contains a set of records keyed on employees’ names. The structure of the set varies from division to division. Furthermore, each employee's record is itself a set (structured differently from division to division) that contains information keyed under identifiers such as <span class="KeyTerm1">address</span> and <span class="KeyTerm1">salary</span>. In particular:</p>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0054"></a><span>a. </span>Implement for headquarters a <span class="KeyTerm1">get_record</span> function that retrieves a specified employee's record from a specified personnel file. The function should be applicable to any division's file. Explain how the individual divisions’ files should be structured. In particular, what type information must be supplied?</li>
<li><a id="c002_c2-li-0055"></a><span>b. </span>Implement for headquarters a <span class="KeyTerm1">get_salary</span> function that returns the salary information from a given employee's record from any division's personnel file. How should the record be structured in order to make this operation work?</li>
<li><a id="c002_c2-li-0056"></a><span>c. </span>Implement for headquarters a <span class="KeyTerm1">find_employee_record</span> function. This should search all the divisions’ files for the record of a given employee and return the record. Assume that this function takes as arguments an employee's name and a list of all the divisions’ files.</li>
<li><a id="c002_c2-li-0057"></a><span>d. </span>When Insatiable takes over a new company, what changes must be made in order to incorporate the new personnel information into the central system?</li>
</ol>
</section>
<section>
<h5><a id="c002_c2-sec-0118"></a><a id="c002_c2-title-0119"></a>Message passing</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1876"></a>The key idea of data-directed programming is to handle generic operations in programs by dealing explicitly with operation-and-type tables, such as the table in <a href="#c2-fig-0032">figure 2.22</a>. The style of programming we used in section 2.4.2 organized the required dispatching on type by having each operation take care of its own dispatching. In effect, this decomposes the operation-and-type table into rows, with each generic operation function representing a row of the table.</p>
<p><a id="c002_c2-para-1877"></a>An alternative implementation strategy is to decompose the table into columns and, instead of using “intelligent operations” that dispatch on data types, to work with “intelligent data objects” that dispatch on operation names. We can do this by arranging things so that a data object, such as a rectangular number, is represented as a function that takes as input the required operation name and performs the operation indicated. In such a discipline, <span class="KeyTerm1">make_from_real_imag</span> could be written as</p>
<p class="Sp-text-1"><a id="c002_c2-para-1878"></a><b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1879"></a> <b>function</b> dispatch(op) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1880"></a> <b>return</b> op === "real_part"</p>
<p class="Sp-text-1"><a id="c002_c2-para-1881"></a>               ? x</p>
<p class="Sp-text-1"><a id="c002_c2-para-1882"></a>               : op === "imag_part"</p>
<p class="Sp-text-1"><a id="c002_c2-para-1883"></a>               ? y</p>
<p class="Sp-text-1"><a id="c002_c2-para-1884"></a>               : op === "magnitude"</p>
<p class="Sp-text-1"><a id="c002_c2-para-1885"></a>               ? math_sqrt(square(x) + square(y))</p>
<p class="Sp-text-1"><a id="c002_c2-para-1886"></a>               : op === "angle"</p>
<p class="Sp-text-1"><a id="c002_c2-para-1887"></a>               ? math_atan(y, x)</p>
<p class="Sp-text-1"><a id="c002_c2-para-1888"></a>               : error(op, "unknown op – make_from_real_imag");</p>
<p class="Sp-text-1"><a id="c002_c2-para-1889"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1890"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c002_c2-para-1891"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-1892"></a>The corresponding <span class="KeyTerm1">apply_generic</span> function, which applies a generic operation to an argument, now simply feeds the operation's name to the data object and lets the object do the work:<a id="c002_c2-fn-0045a"></a><a href="#c2-fn-0045"><sup>45</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-1893"></a><b>function</b> apply_generic(op, arg) { <b>return</b> head(arg)(op); }</p>
<p class="paracontinue"><a id="c002_c2-para-1894"></a>Note that the value returned by <span class="KeyTerm1">make_from_real_imag</span> is a function—the internal <span class="KeyTerm1">dispatch</span> function. This is the function that is invoked when <span class="KeyTerm1">apply_generic</span> requests an operation to be performed.</p>
<p><a id="c002_c2-para-1895"></a>This style of programming is called <i>message passing</i>. The name comes from the image that a data object is an entity that receives the requested operation name as a “message.” We have already seen an example of message passing in section 2.1.3, where we saw how <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> could be defined with no data objects but only functions. Here we see that message passing is not a mathematical trick but a useful technique for organizing systems with generic operations. In the remainder of this chapter we will continue to use data-directed programming, rather than message passing, to discuss generic arithmetic operations. In chapter 3 we will return to message passing, and we will see that it can be a powerful tool for structuring simulation programs.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0119"></a><a id="c002_c2-title-0120"></a>Exercise 2.75</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1896"></a>Implement the constructor <span class="KeyTerm1">make_from_mag_ang</span> in message-passing style. This function should be analogous to the <span class="KeyTerm1">make_from_real_imag</span> function given above.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0120"></a><a id="c002_c2-title-0121"></a>Exercise 2.76</h5>
<p class="paraaftertitle"><a id="c002_c2-para-1897"></a>As a large system with generic operations evolves, new types of data objects or new operations may be needed. For each of the three strategies—generic operations with explicit dispatch, data-directed style, and message-passing-style—describe the changes that must be made to a system in order to add new types or new operations. Which organization would be most appropriate for a system in which new types must often be added? Which would be most appropriate for a system in which new operations must often be added?</p>
</section>
</section>
</section>
<section>
<h2><a id="c002_c2-sec-0121"></a><span>2.5</span> <a id="c002_c2-title-0122"></a>Systems with Generic Operations</h2>
<p class="paraaftertitle"><a id="c002_c2-para-1898"></a>In the previous section, we saw how to design systems in which data objects can be represented in more than one way. The key idea is to link the code that specifies the data operations to the several representations by means of generic interface functions. Now we will see how to use this same idea not only to define operations that are generic over different representations but also to define operations that are generic over different kinds of arguments. We have already seen several different packages of arithmetic operations: the primitive arithmetic (<span class="KeyTerm1">+</span>, <span class="KeyTerm1">-</span>, <span class="KeyTerm1">*</span>, <span class="KeyTerm1">/</span>) built into our language, the rational-number arithmetic (<span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">sub_rat</span>, <span class="KeyTerm1">mul_rat</span>, <span class="KeyTerm1">div_rat</span>) of section 2.1.1, and the complex-number arithmetic that we implemented in section 2.4.3. We will now use data-directed techniques to construct a package of arithmetic operations that incorporates all the arithmetic packages we have already constructed.</p>
<p><a id="c002_c2-para-1899"></a><a id="c002_c2-fig-0033a"></a><a href="#c2-fig-0033">Figure 2.23</a> shows the structure of the system we shall build. Notice the abstraction barriers. From the perspective of someone using “numbers,” there is a single function <span class="KeyTerm1">add</span> that operates on whatever numbers are supplied. The function <span class="KeyTerm1">add</span> is part of a generic interface that allows the separate ordinary-arithmetic, rationalarithmetic, and complex-arithmetic packages to be accessed uniformly by programs that use numbers. Any individual arithmetic package (such as the complex package) may itself be accessed through generic functions (such as <span class="KeyTerm1">add_complex</span>) that combine packages designed for different representations (such as rectangular and polar). Moreover, the structure of the system is additive, so that one can design the individual arithmetic packages separately and combine them to produce a generic arithmetic system.</p>
<figure id="c002_c2-fig-0033"><img alt="c2-fig-0023.jpg" src="../images/c2-fig-0023.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0033a">Figure 2.23</a></span> <a id="c002_c2-para-1900"></a>Generic arithmetic system.</p></figcaption></figure>
<section>
<h3><a id="c002_c2-sec-0122"></a><span>2.5.1</span> <a id="c002_c2-title-0123"></a>Generic Arithmetic Operations</h3>
<p class="paraaftertitle"><a id="c002_c2-para-1901"></a>The task of designing generic arithmetic operations is analogous to that of designing the generic complex-number operations. We would like, for instance, to have a generic addition function <span class="KeyTerm1">add</span> that acts like ordinary primitive addition <span class="KeyTerm1">+</span> on ordinary numbers, like <span class="KeyTerm1">add_rat</span> on rational numbers, and like <span class="KeyTerm1">add_complex</span> on complex numbers. We can implement <span class="KeyTerm1">add</span>, and the other generic arithmetic operations, by following the same strategy we used in section 2.4.3 to implement the generic selectors for complex numbers. We will attach a type tag to each kind of number and cause the generic function to dispatch to an appropriate package according to the data type of its arguments.</p>
<p><a id="c002_c2-para-1902"></a>The generic arithmetic functions are defined as follows:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1903"></a><b>function</b> add(x, y) { <b>return</b> apply_generic("add", list(x, y)); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1904"></a><b>function</b> sub(x, y) { <b>return</b> apply_generic("sub", list(x, y)); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1905"></a><b>function</b> mul(x, y) { <b>return</b> apply_generic("mul", list(x, y)); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1906"></a><b>function</b> div(x, y) { <b>return</b> apply_generic("div", list(x, y)); }</p>
<p><a id="c002_c2-para-1907"></a>We begin by installing a package for handling <i>ordinary</i> numbers, that is, the primitive numbers of our language. We tag these with the string <span class="KeyTerm1">"javascript_number"</span>. The arithmetic operations in this package are the primitive arithmetic functions (so there is no need to define extra functions to handle the untagged numbers). Since these operations each take two arguments, they are installed in the table keyed by the list <span class="KeyTerm1">list("javascript_number", "javascript_number")</span>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1908"></a><b>function</b> install_javascript_number_package() {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1909"></a> <b>function</b> tag(x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1910"></a> <b>return</b> attach_tag("javascript_number", x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1911"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1912"></a>    put("add", list("javascript_number", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1913"></a>        (x, y) =&gt; tag(x + y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1914"></a>    put("sub", list("javascript_number", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1915"></a>        (x, y) =&gt; tag(x - y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1916"></a>    put("mul", list("javascript_number", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1917"></a>        (x, y) =&gt; tag(x * y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1918"></a>    put("div", list("javascript_number", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1919"></a>        (x, y) =&gt; tag(x / y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1920"></a>    put("make", "javascript_number",</p>
<p class="Sp-text-1"><a id="c002_c2-para-1921"></a>        x =&gt; tag(x));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1922"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c002_c2-para-1923"></a>}</p>
<p><a id="c002_c2-para-1924"></a>Users of the JavaScript-number package will create (tagged) ordinary numbers by means of the function:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1925"></a><b>function</b> make_javascript_number(n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1926"></a> <b>return</b> get("make", "javascript_number")(n);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1927"></a>}</p>
<p><a id="c002_c2-para-1928"></a>Now that the framework of the generic arithmetic system is in place, we can readily include new kinds of numbers. Here is a package that performs rational arithmetic. Notice that, as a benefit of additivity, we can use without modification the rational-number code from section 2.1.1 as the internal functions in the package:</p>
<p class="Sp-text-1"><a id="c002_c2-para-1929"></a><b>function</b> install_rational_package() {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1930"></a> <span class="KeyTerm2"><i>// internal functions</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1931"></a> <b>function</b> numer(x) { <b>return</b> head(x); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1932"></a> <b>function</b> denom(x) { <b>return</b> tail(x); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1933"></a> <b>function</b> make_rat(n, d) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1934"></a> <b>const</b> g = gcd(n, d);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1935"></a> <b>return</b> pair(n / g, d / g);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1936"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1937"></a> <b>function</b> add_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1938"></a> <b>return</b> make_rat(numer(x) * denom(y) + numer(y) * denom(x),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1939"></a>                        denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1940"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1941"></a> <b>function</b> sub_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1942"></a> <b>return</b> make_rat(numer(x) * denom(y) - numer(y) * denom(x),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1943"></a>                        denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1944"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1945"></a> <b>function</b> mul_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1946"></a> <b>return</b> make_rat(numer(x) * numer(y),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1947"></a>                        denom(x) * denom(y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1948"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1949"></a> <b>function</b> div_rat(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1950"></a> <b>return</b> make_rat(numer(x) * denom(y),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1951"></a>                        denom(x) * numer(y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1952"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1953"></a> <span class="KeyTerm2"><i>// interface to rest of the system</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1954"></a> <b>function</b> tag(x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1955"></a> <b>return</b> attach_tag("rational", x);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1956"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1957"></a>    put("add", list("rational", "rational"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1958"></a>        (x, y) =&gt; tag(add_rat(x, y)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1959"></a>    put("sub", list("rational", "rational"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1960"></a>        (x, y) =&gt; tag(sub_rat(x, y)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1961"></a>    put("mul", list("rational", "rational"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1962"></a>        (x, y) =&gt; tag(mul_rat(x, y)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1963"></a>    put("div", list("rational", "rational"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1964"></a>        (x, y) =&gt; tag(div_rat(x, y)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1965"></a>    put("make", "rational",</p>
<p class="Sp-text-1"><a id="c002_c2-para-1966"></a>        (n, d) =&gt; tag(make_rat(n, d)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1967"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c002_c2-para-1968"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-1969"></a><b>function</b> make_rational(n, d) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1970"></a> <b>return</b> get("make", "rational")(n, d);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1971"></a>}</p>
<p><a id="c002_c2-para-1972"></a>We can install a similar package to handle complex numbers, using the tag <span class="KeyTerm1">"complex"</span>. In creating the package, we extract from the table the operations <span class="KeyTerm1">make_from_real_imag</span> and <span class="KeyTerm1">make_from_mag_ang</span> that were defined by the rectangular and polar packages. Additivity permits us to use, as the internal operations, the same <span class="KeyTerm1">add_complex</span>, <span class="KeyTerm1">sub_complex</span>, <span class="KeyTerm1">mul_complex</span>, and <span class="KeyTerm1">div_complex</span> functions from section 2.4.1.</p>
<p class="Sp-text-1"><a id="c002_c2-para-1973"></a><b>function</b> install_complex_package() {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1974"></a> <span class="KeyTerm2"><i>// imported functions from rectangular and polar packages</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1975"></a> <b>function</b> make_from_real_imag(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1976"></a> <b>return</b> get("make_from_real_imag", "rectangular")(x, y);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1977"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1978"></a> <b>function</b> make_from_mag_ang(r, a) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1979"></a> <b>return</b> get("make_from_mag_ang", "polar")(r, a);</p>
<p class="Sp-text-1"><a id="c002_c2-para-1980"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1981"></a> <span class="KeyTerm2"><i>// internal functions</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1982"></a> <b>function</b> add_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1983"></a> <b>return</b> make_from_real_imag(real_part(z1) + real_part(z2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1984"></a>                                   imag_part(z1) + imag_part(z2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1985"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1986"></a> <b>function</b> sub_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1987"></a> <b>return</b> make_from_real_imag(real_part(z1) - real_part(z2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1988"></a>                                   imag_part(z1) - imag_part(z2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1989"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1990"></a> <b>function</b> mul_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1991"></a> <b>return</b> make_from_mag_ang(magnitude(z1) * magnitude(z2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1992"></a>                                 angle(z1) + angle(z2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1993"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1994"></a><b>function</b> div_complex(z1, z2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-1995"></a> <b>return</b> make_from_mag_ang(magnitude(z1) / magnitude(z2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-1996"></a>                                 angle(z1) - angle(z2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-1997"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-1998"></a> <span class="KeyTerm2"><i>// interface to rest of the system</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-1999"></a> <b>function</b> tag(z) { <b>return</b> attach_tag("complex", z); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2000"></a>    put("add", list("complex", "complex"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2001"></a>        (z1, z2) =&gt; tag(add_complex(z1, z2)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2002"></a>    put("sub", list("complex", "complex"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2003"></a>        (z1, z2) =&gt; tag(sub_complex(z1, z2)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2004"></a>    put("mul", list("complex", "complex"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2005"></a>        (z1, z2) =&gt; tag(mul_complex(z1, z2)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2006"></a>    put("div", list("complex", "complex"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2007"></a>        (z1, z2) =&gt; tag(div_complex(z1, z2)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2008"></a>    put("make_from_real_imag", "complex",</p>
<p class="Sp-text-1"><a id="c002_c2-para-2009"></a>        (x, y) =&gt; tag(make_from_real_imag(x, y)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2010"></a>    put("make_from_mag_ang", "complex",</p>
<p class="Sp-text-1"><a id="c002_c2-para-2011"></a>        (r, a) =&gt; tag(make_from_mag_ang(r, a)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2012"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c002_c2-para-2013"></a>}</p>
<p><a id="c002_c2-para-2014"></a>Programs outside the complex-number package can construct complex numbers either from real and imaginary parts or from magnitudes and angles. Notice how the underlying functions, originally defined in the rectangular and polar packages, are exported to the complex package, and exported from there to the outside world.</p>
<p class="Sp-text-1"><a id="c002_c2-para-2015"></a><b>function</b> make_complex_from_real_imag(x, y){</p>
<p class="Sp-text-1"><a id="c002_c2-para-2016"></a> <b>return</b> get("make_from_real_imag", "complex")(x, y);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2017"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-2018"></a><b>function</b> make_complex_from_mag_ang(r, a){</p>
<p class="Sp-text-1"><a id="c002_c2-para-2019"></a> <b>return</b> get("make_from_mag_ang", "complex")(r, a);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2020"></a>}</p>
<p><a id="c002_c2-para-2021"></a>What we have here is a two-level tag system. A typical complex number, such as 3 + 4<i>i</i> in rectangular form, would be represented as shown in <a id="c002_c2-fig-0034a"></a><a href="#c2-fig-0034">figure 2.24</a>. The outer tag (<span class="KeyTerm1">"complex"</span>) is used to direct the number to the complex package. Once within the complex package, the next tag (<span class="KeyTerm1">"rectangular"</span>) is used to direct the number to the rectangular package. In a large and complicated system there might be many levels, each interfaced with the next by means of generic operations. As a data object is passed “downward,” the outer tag that is used to direct it to the appropriate package is stripped off (by applying <span class="KeyTerm1">contents</span>) and the next level of tag (if any) becomes visible to be used for further dispatching.</p>
<figure id="c002_c2-fig-0034"><img alt="c2-fig-0024.jpg" src="../images/c2-fig-0024.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0034a">Figure 2.24</a></span> <a id="c002_c2-para-2022"></a>Representation of 3 + 4i in rectangular form.</p></figcaption></figure>
<p><a id="c002_c2-para-2023"></a>In the above packages, we used <span class="KeyTerm1">add_rat</span>, <span class="KeyTerm1">add_complex</span>, and the other arithmetic functions exactly as originally written. Once these declarations are internal to different installation functions, however, they no longer need names that are distinct from each other: we could simply name them <span class="KeyTerm1">add</span>, <span class="KeyTerm1">sub</span>, <span class="KeyTerm1">mul</span>, and <span class="KeyTerm1">div</span> in both packages.</p>
<section>
<h5><a id="c002_c2-sec-0123"></a><a id="c002_c2-title-0124"></a>Exercise 2.77</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2024"></a>Louis Reasoner tries to evaluate the expression <span class="KeyTerm1">magnitude(z)</span> where <span class="KeyTerm1">z</span> is the object shown in <a href="#c2-fig-0034">figure 2.24</a>. To his surprise, instead of the answer 5 he gets an error message from <span class="KeyTerm1">apply_generic</span>, saying there is no method for the operation <span class="KeyTerm1">magnitude</span> on the types <span class="KeyTerm1">list("complex")</span>. He shows this interaction to Alyssa P. Hacker, who says “The problem is that the complex-number selectors were never defined for <span class="KeyTerm1">"complex"</span> numbers, just for <span class="KeyTerm1">"polar"</span> and <span class="KeyTerm1">"rectangular"</span> numbers. All you have to do to make this work is add the following to the <span class="KeyTerm1">complex</span> package:”</p>
<p class="Sp-text-1"><a id="c002_c2-para-2025"></a>put("real_part", list("complex"), real_part);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2026"></a>put("imag_part", list("complex"), imag_part);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2027"></a>put("magnitude", list("complex"), magnitude);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2028"></a>put("angle",      list("complex"), angle);</p>
<p class="paracontinue"><a id="c002_c2-para-2029"></a>Describe in detail why this works. As an example, trace through all the functions called in evaluating the expression <span class="KeyTerm1">magnitude(z)</span> where <span class="KeyTerm1">z</span> is the object shown in <a href="#c2-fig-0034">figure 2.24</a>. In particular, how many times is <span class="KeyTerm1">apply_generic</span> invoked? What function is dispatched to in each case?</p>
</section>
<section>
<h5><a id="c002_c2-sec-0124"></a><a id="c002_c2-title-0125"></a>Exercise 2.78</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2030"></a>The internal functions in the <span class="KeyTerm1">javascript_number</span> package are essentially nothing more than calls to the primitive functions <span class="KeyTerm1">+</span>, <span class="KeyTerm1">-</span>, etc. It was not possible to use the primitives of the language directly because our type-tag system requires that each data object have a type attached to it. In fact, however, all JavaScript implementations do have a type system, which they use internally. Primitive predicates such as <span class="KeyTerm1">is_string</span> and <span class="KeyTerm1">is_number</span> determine whether data objects have particular types. Modify the definitions of <span class="KeyTerm1">type_tag</span>, <span class="KeyTerm1">contents</span>, and <span class="KeyTerm1">attach_tag</span> from section 2.4.2 so that our generic system takes advantage of JavaScript's internal type system. That is to say, the system should work as before except that ordinary numbers should be represented simply as JavaScript numbers rather than as pairs whose <span class="KeyTerm1">head</span> is the string <span class="KeyTerm1">"javascript_number"</span>.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0125"></a><a id="c002_c2-title-0126"></a>Exercise 2.79</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2031"></a>Define a generic equality predicate <span class="KeyTerm1">is_equal</span> that tests the equality of two numbers, and install it in the generic arithmetic package. This operation should work for ordinary numbers, rational numbers, and complex numbers.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0126"></a><a id="c002_c2-title-0127"></a>Exercise 2.80</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2032"></a>Define a generic predicate <span class="KeyTerm1">is_equal_to_zero</span> that tests if its argument is zero, and install it in the generic arithmetic package. This operation should work for ordinary numbers, rational numbers, and complex numbers.</p>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0127"></a><span>2.5.2</span> <a id="c002_c2-title-0128"></a>Combining Data of Different Types</h3>
<p class="paraaftertitle"><a id="c002_c2-para-2033"></a>We have seen how to define a unified arithmetic system that encompasses ordinary numbers, complex numbers, rational numbers, and any other type of number we might decide to invent, but we have ignored an important issue. The operations we have defined so far treat the different data types as being completely independent. Thus, there are separate packages for adding, say, two ordinary numbers, or two complex numbers. What we have not yet considered is the fact that it is meaningful to define operations that cross the type boundaries, such as the addition of a complex number to an ordinary number. We have gone to great pains to introduce barriers between parts of our programs so that they can be developed and understood separately. We would like to introduce the cross-type operations in some carefully controlled way, so that we can support them without seriously violating our module boundaries.</p>
<p><a id="c002_c2-para-2034"></a>One way to handle cross-type operations is to design a different function for each possible combination of types for which the operation is valid. For example, we could extend the complex-number package so that it provides a function for adding complex numbers to ordinary numbers and installs this in the table using the tag <span class="KeyTerm1">list("complex", "javascript_number")</span>:<a id="c002_c2-fn-0046a"></a><a href="#c2-fn-0046"><sup>46</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-2035"></a><span class="KeyTerm2"><span class="KeyTerm2"><i>// to be included in the complex package</i></span></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-2036"></a><b>function</b> add_complex_to_javascript_num(z, x) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2037"></a> <b>return</b> make_complex_from_real_imag(real_part(z) + x, imag_part(z));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2038"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-2039"></a>put("add", list("complex", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2040"></a>    (z, x) =&gt; tag(add_complex_to_javascript_num(z, x)));</p>
<p><a id="c002_c2-para-2041"></a>This technique works, but it is cumbersome. With such a system, the cost of introducing a new type is not just the construction of the package of functions for that type but also the construction and installation of the functions that implement the cross-type operations. This can easily be much more code than is needed to define the operations on the type itself. The method also undermines our ability to combine separate packages additively, or least to limit the extent to which the implementors of the individual packages need to take account of other packages. For instance, in the example above, it seems reasonable that handling mixed operations on complex numbers and ordinary numbers should be the responsibility of the complex-number package. Combining rational numbers and complex numbers, however, might be done by the complex package, by the rational package, or by some third package that uses operations extracted from these two packages. Formulating coherent policies on the division of responsibility among packages can be an overwhelming task in designing systems with many packages and many cross-type operations.</p>
<section>
<h5><a id="c002_c2-sec-0128"></a><a id="c002_c2-title-0129"></a>Coercion</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2043"></a>In the general situation of completely unrelated operations acting on completely unrelated types, implementing explicit cross-type operations, cumbersome though it may be, is the best that one can hope for. Fortunately, we can usually do better by taking advantage of additional structure that may be latent in our type system. Often the different data types are not completely independent, and there may be ways by which objects of one type may be viewed as being of another type. This process is called <i>coercion</i>. For example, if we are asked to arithmetically combine an ordinary number with a complex number, we can view the ordinary number as a complex number whose imaginary part is zero. This transforms the problem to that of combining two complex numbers, which can be handled in the ordinary way by the complex-arithmetic package.</p>
<p><a id="c002_c2-para-2044"></a>In general, we can implement this idea by designing coercion functions that transform an object of one type into an equivalent object of another type. Here is a typical coercion function, which transforms a given ordinary number to a complex number with that real part and zero imaginary part:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2045"></a><b>function</b> javascript_number_to_complex(n) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2046"></a> <b>return</b> make_complex_from_real_imag(contents(n), 0);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2047"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-2048"></a>We install these coercion functions in a special coercion table, indexed under the names of the two types:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2049"></a>put_coercion("javascript_number", "complex",</p>
<p class="Sp-text-1"><a id="c002_c2-para-2050"></a>             javascript_number_to_complex);</p>
<p class="paracontinue"><a id="c002_c2-para-2051"></a>(We assume that there are <span class="KeyTerm1">put_coercion</span> and <span class="KeyTerm1">get_coercion</span> functions available for manipulating this table.) Generally some of the slots in the table will be empty, because it is not generally possible to coerce an arbitrary data object of each type into all other types. For example, there is no way to coerce an arbitrary complex number to an ordinary number, so there will be no general <span class="KeyTerm1">complex_to_javascript_number</span> function included in the table.</p>
<p><a id="c002_c2-para-2052"></a>Once the coercion table has been set up, we can handle coercion in a uniform manner by modifying the <span class="KeyTerm1">apply_generic</span> function of section 2.4.3. When asked to apply an operation, we first check whether the operation is defined for the arguments’ types, just as before. If so, we dispatch to the function found in the operation-andtype table. Otherwise, we try coercion. For simplicity, we consider only the case where there are two arguments.<a id="c002_c2-fn-0047a"></a><a href="#c2-fn-0047"><sup>47</sup></a> We check the coercion table to see if objects of the first type can be coerced to the second type. If so, we coerce the first argument and try the operation again. If objects of the first type cannot in general be coerced to the second type, we try the coercion the other way around to see if there is a way to coerce the second argument to the type of the first argument. Finally, if there is no known way to coerce either type to the other type, we give up. Here is the function:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2053"></a><b>function</b> apply_generic(op, args) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2054"></a> <b>const</b> type_tags = map(type_tag, args);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2055"></a> <b>const</b> fun = get(op, type_tags);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2056"></a> <b>if</b> (! is_undefined(fun)) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2057"></a> <b>return</b> apply(fun, map(contents, args));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2058"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2059"></a> <b>if</b> (length(args) === 2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2060"></a> <b>const</b> type1 = head(type_tags);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2061"></a> <b>const</b> type2 = head(tail(type_tags));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2062"></a> <b>const</b> a1 = head(args);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2063"></a> <b>const</b> a2 = head(tail(args));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2064"></a> <b>const</b> t1_to_t2 = get_coercion(type1, type2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2065"></a> <b>const</b> t2_to_t1 = get_coercion(type2, type1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2066"></a> <b>return</b> ! is_undefined(t1_to_t2)</p>
<p class="Sp-text-1"><a id="c002_c2-para-2067"></a>                   ? apply_generic(op, list(t1_to_t2(a1), a2))</p>
<p class="Sp-text-1"><a id="c002_c2-para-2068"></a>                   : ! is_undefined(t2_to_t1)</p>
<p class="Sp-text-1"><a id="c002_c2-para-2069"></a>                   ? apply_generic(op, list(a1, t2_to_t1(a2)))</p>
<p class="Sp-text-1"><a id="c002_c2-para-2070"></a>                   : error(list(op, type_tags),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2071"></a>                           "no method for these types");</p>
<p class="Sp-text-1"><a id="c002_c2-para-2072"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2073"></a> <b>return</b> error(list(op, type_tags),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2074"></a>                         "no method for these types");</p>
<p class="Sp-text-1"><a id="c002_c2-para-2075"></a>        }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2076"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2077"></a>}</p>
<p><a id="c002_c2-para-2078"></a>This coercion scheme has many advantages over the method of defining explicit cross-type operations, as outlined above. Although we still need to write coercion functions to relate the types (possibly <i>n</i><sup>2</sup> functions for a system with <i>n</i> types), we need to write only one function for each pair of types rather than a different function for each collection of types and each generic operation.<a id="c002_c2-fn-0048a"></a><a href="#c2-fn-0048"><sup>48</sup></a> What we are counting on here is the fact that the appropriate transformation between types depends only on the types themselves, not on the operation to be applied.</p>
<p><a id="c002_c2-para-2079"></a>On the other hand, there may be applications for which our coercion scheme is not general enough. Even when neither of the objects to be combined can be converted to the type of the other it may still be possible to perform the operation by converting both objects to a third type. In order to deal with such complexity and still preserve modularity in our programs, it is usually necessary to build systems that take advantage of still further structure in the relations among types, as we discuss next.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0129"></a><a id="c002_c2-title-0130"></a>Hierarchies of types</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2080"></a>The coercion scheme presented above relied on the existence of natural relations between pairs of types. Often there is more “global” structure in how the different types relate to each other. For instance, suppose we are building a generic arithmetic system to handle integers, rational numbers, real numbers, and complex numbers. In such a system, it is quite natural to regard an integer as a special kind of rational number, which is in turn a special kind of real number, which is in turn a special kind of complex number. What we actually have is a so-called <i>hierarchy of types</i>, in which, for example, integers are a <i>subtype</i> of rational numbers (i.e., any operation that can be applied to a rational number can automatically be applied to an integer). Conversely, we say that rational numbers form a <i>supertype</i> of integers. The particular hierarchy we have here is of a very simple kind, in which each type has at most one supertype and at most one subtype. Such a structure, called a <i>tower</i>, is illustrated in <a id="c002_c2-fig-0035a"></a><a href="#c2-fig-0035">figure 2.25</a>.</p>
<figure id="c002_c2-fig-0035"><img alt="c2-fig-0025.jpg" src="../images/c2-fig-0025.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0035a">Figure 2.25</a></span> <a id="c002_c2-para-2081"></a>A tower of types.</p></figcaption></figure>
<p><a id="c002_c2-para-2082"></a>If we have a tower structure, then we can greatly simplify the problem of adding a new type to the hierarchy, for we need only specify how the new type is embedded in the next supertype above it and how it is the supertype of the type below it. For example, if we want to add an integer to a complex number, we need not explicitly define a special coercion function <span class="KeyTerm1">integer_to_complex</span>. Instead, we define how an integer can be transformed into a rational number, how a rational number is transformed into a real number, and how a real number is transformed into a complex number. We then allow the system to transform the integer into a complex number through these steps and then add the two complex numbers.</p>
<p><a id="c002_c2-para-2083"></a>We can redesign our <span class="KeyTerm1">apply_generic</span> function in the following way: For each type, we need to supply a <span class="KeyTerm1">raise</span> function, which “raises” objects of that type one level in the tower. Then when the system is required to operate on objects of different types it can successively raise the lower types until all the objects are at the same level in the tower. (Exercises 2.83 and 2.84 concern the details of implementing such a strategy.)</p>
<p><a id="c002_c2-para-2084"></a>Another advantage of a tower is that we can easily implement the notion that every type “inherits” all operations defined on a supertype. For instance, if we do not supply a special function for finding the real part of an integer, we should nevertheless expect that <span class="KeyTerm1">real_part</span> will be defined for integers by virtue of the fact that integers are a subtype of complex numbers. In a tower, we can arrange for this to happen in a uniform way by modifying <span class="KeyTerm1">apply_generic</span>. If the required operation is not directly defined for the type of the object given, we raise the object to its supertype and try again. We thus crawl up the tower, transforming our argument as we go, until we either find a level at which the desired operation can be performed or hit the top (in which case we give up).</p>
<p><a id="c002_c2-para-2085"></a>Yet another advantage of a tower over a more general hierarchy is that it gives us a simple way to “lower” a data object to the simplest representation. For example, if we add 2 + 3<i>i</i> to 4 – 3<i>i</i>, it would be nice to obtain the answer as the integer 6 rather than as the complex number 6 + 0<i>i</i>. Exercise 2.85 discusses a way to implement such a lowering operation. (The trick is that we need a general way to distinguish those objects that can be lowered, such as 6 + 0<i>i</i>, from those that cannot, such as 6 + 2<i>i</i>.)</p>
</section>
<section>
<h5><a id="c002_c2-sec-0130"></a><a id="c002_c2-title-0131"></a>Inadequacies of hierarchies</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2086"></a>If the data types in our system can be naturally arranged in a tower, this greatly simplifies the problems of dealing with generic operations on different types, as we have seen. Unfortunately, this is usually not the case. <a id="c002_c2-fig-0036a"></a><a href="#c2-fig-0036">Figure 2.26</a> illustrates a more complex arrangement of mixed types, this one showing relations among different types of geometric figures. We see that, in general, a type may have more than one subtype. Triangles and quadrilaterals, for instance, are both subtypes of polygons. In addition, a type may have more than one supertype. For example, an isosceles right triangle may be regarded either as an isosceles triangle or as a right triangle. This multiple-supertypes issue is particularly thorny, since it means that there is no unique way to “raise” a type in the hierarchy. Finding the “correct” supertype in which to apply an operation to an object may involve considerable searching through the entire type network on the part of a function such as <span class="KeyTerm1">apply_generic</span>. Since there generally are multiple subtypes for a type, there is a similar problem in coercing a value “down” the type hierarchy. Dealing with large numbers of interrelated types while still preserving modularity in the design of large systems is very difficult, and is an area of much current research.<a id="c002_c2-fn-0049a"></a><a href="#c2-fn-0049"><sup>49</sup></a></p>
<figure id="c002_c2-fig-0036"><img alt="c2-fig-0026.jpg" src="../images/c2-fig-0026.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c2-fig-0036a">Figure 2.26</a></span> <a id="c002_c2-para-2087"></a>Relations among types of geometric figures.</p></figcaption></figure>
</section>
<section>
<h5><a id="c002_c2-sec-0131"></a><a id="c002_c2-title-0132"></a>Exercise 2.81</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2088"></a>Louis Reasoner has noticed that <span class="KeyTerm1">apply_generic</span> may try to coerce the arguments to each other's type even if they already have the same type. Therefore, he reasons, we need to put functions in the coercion table to “coerce” arguments of each type to their own type. For example, in addition to the <span class="KeyTerm1">javascript_number_to_complex</span> coercion shown above, he would do:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2089"></a><b>function</b> javascript_number_to_javascript_number(n) { <b>return</b> n; }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2090"></a><b>function</b> complex_to_complex(n) { <b>return</b> n; }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2091"></a>put_coercion("javascript_number", "javascript_number",</p>
<p class="Sp-text-1"><a id="c002_c2-para-2092"></a>             javascript_number_to_javascript_number);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2093"></a>put_coercion("complex", "complex", complex_to_complex);</p>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0058"></a><span>a. </span>With Louis's coercion functions installed, what happens if <span class="KeyTerm1">apply_generic</span> is called with two arguments of type <span class="KeyTerm1">"complex"</span> or two arguments of type <span class="KeyTerm1">"javascript_ number"</span> for an operation that is not found in the table for those types? For example, assume that we've defined a generic exponentiation operation:
<p class="Sp-text-1"><a id="c002_c2-para-2095"></a><b>function</b> exp(x, y) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2096"></a> <b>return</b> apply_generic("exp", list(x, y));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2097"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-2098"></a>and have put a function for exponentiation in the JavaScript-number package but not in any other package:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2099"></a><span class="KeyTerm2"><i>// following added to JavaScript-number package</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-2100"></a>put("exp", list("javascript_number", "javascript_number"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2101"></a>    (x, y) =&gt; tag(math_exp(x, y))); <span class="KeyTerm2">// using primitive</span> math_exp</p>
<p class="paracontinue"><a id="c002_c2-para-2102"></a>What happens if we call <span class="KeyTerm1">exp</span> with two complex numbers as arguments?</p></li>
<li><a id="c002_c2-li-0059"></a><span>b. </span>Is Louis correct that something had to be done about coercion with arguments of the same type, or does <span class="KeyTerm1">apply_generic</span> work correctly as is?</li>
<li><a id="c002_c2-li-0060"></a><span>c. </span>Modify <span class="KeyTerm1">apply_generic</span> so that it doesn't try coercion if the two arguments have the same type.</li>
</ol>
</section>
<section>
<h5><a id="c002_c2-sec-0132"></a><a id="c002_c2-title-0133"></a>Exercise 2.82</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2105"></a>Show how to generalize <span class="KeyTerm1">apply_generic</span> to handle coercion in the general case of multiple arguments. One strategy is to attempt to coerce all the arguments to the type of the first argument, then to the type of the second argument, and so on. Give an example of a situation where this strategy (and likewise the two-argument version given above) is not sufficiently general. (Hint: Consider the case where there are some suitable mixed-type operations present in the table that will not be tried.)</p>
</section>
<section>
<h5><a id="c002_c2-sec-0133"></a><a id="c002_c2-title-0134"></a>Exercise 2.83</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2106"></a>Suppose you are designing a generic arithmetic system for dealing with the tower of types shown in <a href="#c2-fig-0035">figure 2.25</a>: integer, rational, real, complex. For each type (except complex), design a function that raises objects of that type one level in the tower. Show how to install a generic <span class="KeyTerm1">raise</span> operation that will work for each type (except complex).</p>
</section>
<section>
<h5><a id="c002_c2-sec-0134"></a><a id="c002_c2-title-0135"></a>Exercise 2.84</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2107"></a>Using the <span class="KeyTerm1">raise</span> operation of exercise 2.83, modify the <span class="KeyTerm1">apply_generic</span> function so that it coerces its arguments to have the same type by the method of successive raising, as discussed in this section. You will need to devise a way to test which of two types is higher in the tower. Do this in a manner that is “compatible” with the rest of the system and will not lead to problems in adding new levels to the tower.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0135"></a><a id="c002_c2-title-0136"></a>Exercise 2.85</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2108"></a>This section mentioned a method for “simplifying” a data object by lowering it in the tower of types as far as possible. Design a function <span class="KeyTerm1">drop</span> that accomplishes this for the tower described in exercise 2.83. The key is to decide, in some general way, whether an object can be lowered. For example, the complex number 1.5 + 0<i>i</i> can be lowered as far as <span class="KeyTerm1">"real"</span>, the complex number 1 + 0<i>i</i> can be lowered as far as <span class="KeyTerm1">"integer"</span>, and the complex number 2 + 3<i>i</i> cannot be lowered at all. Here is a plan for determining whether an object can be lowered: Begin by defining a generic operation <span class="KeyTerm1">project</span> that “pushes” an object down in the tower. For example, projecting a complex number would involve throwing away the imaginary part. Then a number can be dropped if, when we <span class="KeyTerm1">project</span> it and <span class="KeyTerm1">raise</span> the result back to the type we started with, we end up with something equal to what we started with. Show how to implement this idea in detail, by writing a <span class="KeyTerm1">drop</span> function that drops an object as far as possible. You will need to design the various projection operations<a id="c002_c2-fn-0050a"></a><a href="#c2-fn-0050"><sup>50</sup></a> and install <span class="KeyTerm1">project</span> as a generic operation in the system. You will also need to make use of a generic equality predicate, such as described in exercise 2.79. Finally, use <span class="KeyTerm1">drop</span> to rewrite <span class="KeyTerm1">apply_generic</span> from exercise 2.84 so that it “simplifies” its answers.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0136"></a><a id="c002_c2-title-0137"></a>Exercise 2.86</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2109"></a>Suppose we want to handle complex numbers whose real parts, imaginary parts, magnitudes, and angles can be either ordinary numbers, rational numbers, or other numbers we might wish to add to the system. Describe and implement the changes to the system needed to accommodate this. You will have to define operations such as <span class="KeyTerm1">sine</span> and <span class="KeyTerm1">cosine</span> that are generic over ordinary numbers and rational numbers.</p>
</section>
</section>
<section>
<h3><a id="c002_c2-sec-0137"></a><span>2.5.3</span> <a id="c002_c2-title-0138"></a>Example: Symbolic Algebra</h3>
<p class="paraaftertitle"><a id="c002_c2-para-2110"></a>The manipulation of symbolic algebraic expressions is a complex process that illustrates many of the hardest problems that occur in the design of large-scale systems. An algebraic expression, in general, can be viewed as a hierarchical structure, a tree of operators applied to operands. We can construct algebraic expressions by starting with a set of primitive objects, such as constants and variables, and combining these by means of algebraic operators, such as addition and multiplication. As in other languages, we form abstractions that enable us to refer to compound objects in simple terms. Typical abstractions in symbolic algebra are ideas such as linear combination, polynomial, rational function, or trigonometric function. We can regard these as compound “types,” which are often useful for directing the processing of expressions. For example, we could describe the expression</p>
<p class="Sp-text-2"><a id="c002_c2-para-2111"></a><i>x</i><sup>2</sup> sin(<i>y</i><sup>2</sup> + 1) + <i>x</i> cos 2<i>y</i> + cos(<i>y</i><sup>3</sup> – 2<i>y</i><sup>2</sup>)</p>
<p class="paracontinue"><a id="c002_c2-para-2112"></a>as a polynomial in <i>x</i> with coefficients that are trigonometric functions of polynomials in <i>y</i> whose coefficients are integers.</p>
<p><a id="c002_c2-para-2113"></a>We will not attempt to develop a complete algebraic-manipulation system here. Such systems are exceedingly complex programs, embodying deep algebraic knowledge and elegant algorithms. What we will do is look at a simple but important part of algebraic manipulation: the arithmetic of polynomials. We will illustrate the kinds of decisions the designer of such a system faces, and how to apply the ideas of abstract data and generic operations to help organize this effort.</p>
<section>
<h5><a id="c002_c2-sec-0138"></a><a id="c002_c2-title-0139"></a>Arithmetic on polynomials</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2114"></a>Our first task in designing a system for performing arithmetic on polynomials is to decide just what a polynomial is. Polynomials are normally defined relative to certain variables (the <i>indeterminates</i> of the polynomial). For simplicity, we will restrict ourselves to polynomials having just one indeterminate <i>(univariate polynomials</i>).<a id="c002_c2-fn-0051a"></a><a href="#c2-fn-0051"><sup>51</sup></a> We will define a polynomial to be a sum of terms, each of which is either a coefficient, a power of the indeterminate, or a product of a coefficient and a power of the indeterminate. A coefficient is defined as an algebraic expression that is not dependent upon the indeterminate of the polynomial. For example,</p>
<p class="Sp-text-2"><a id="c002_c2-para-2115"></a>5<i>x</i><sup>2</sup> + 3<i>x</i> + 7</p>
<p class="paracontinue"><a id="c002_c2-para-2116"></a>is a simple polynomial in <i>x</i>, and </p>
<p class="Sp-text-2"><a id="c002_c2-para-2117"></a>(<i>y</i><sup>2</sup> + 1)<i>x</i><sup>3</sup> + (2<i>y</i>)<i>x</i> + 1</p>
<p class="paracontinue"><a id="c002_c2-para-2118"></a>is a polynomial in <i>x</i> whose coefficients are polynomials in <i>y</i>.</p>
<p><a id="c002_c2-para-2119"></a>Already we are skirting some thorny issues. Is the first of these polynomials the same as the polynomial 5<i>y</i><sup>2</sup> + 3<i>y</i> + 7, or not? A reasonable answer might be “yes, if we are considering a polynomial purely as a mathematical function, but no, if we are considering a polynomial to be a syntactic form.” The second polynomial is algebraically equivalent to a polynomial in <i>y</i> whose coefficients are polynomials in <i>x</i>. Should our system recognize this, or not? Furthermore, there are other ways to represent a polynomial—for example, as a product of factors, or (for a univariate polynomial) as the set of roots, or as a listing of the values of the polynomial at a specified set of points.<a id="c002_c2-fn-0052a"></a><a href="#c2-fn-0052"><sup>52</sup></a> We can finesse these questions by deciding that in our algebraic-manipulation system a “polynomial” will be a particular syntactic form, not its underlying mathematical meaning.</p>
<p><a id="c002_c2-para-2120"></a>Now we must consider how to go about doing arithmetic on polynomials. In this simple system, we will consider only addition and multiplication. Moreover, we will insist that two polynomials to be combined must have the same indeterminate.</p>
<p><a id="c002_c2-para-2121"></a>We will approach the design of our system by following the familiar discipline of data abstraction. We will represent polynomials using a data structure called a <i>poly</i>, which consists of a variable and a collection of terms. We assume that we have selectors <span class="KeyTerm1">variable</span> and <span class="KeyTerm1">term_list</span> that extract those parts from a poly and a constructor <span class="KeyTerm1">make_poly</span> that assembles a poly from a given variable and a term list. A variable will be just a string, so we can use the <span class="KeyTerm1">is_same_variable</span> function of section 2.3.2 to compare variables. The following functions define addition and multiplication of polys:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2122"></a><b>function</b> add_poly(p1, p2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2123"></a> <b>return</b> is_same_variable(variable(p1), variable(p2))</p>
<p class="Sp-text-1"><a id="c002_c2-para-2124"></a>           ? make_poly(variable(p1),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2125"></a>                       add_terms(term_list(p1), term_list(p2)))</p>
<p class="Sp-text-1"><a id="c002_c2-para-2126"></a>           : error(list(p1, p2), "polys not in same var – add_poly");</p>
<p class="Sp-text-1"><a id="c002_c2-para-2127"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-2128"></a><b>function</b> mul_poly(p1, p2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2129"></a> <b>return</b> is_same_variable(variable(p1), variable(p2))</p>
<p class="Sp-text-1"><a id="c002_c2-para-2130"></a>           ? make_poly(variable(p1),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2131"></a>                       mul_terms(term_list(p1), term_list(p2)))</p>
<p class="Sp-text-1"><a id="c002_c2-para-2132"></a>           : error(list(p1, p2), "polys not in same var – mul_poly");</p>
<p class="Sp-text-1"><a id="c002_c2-para-2133"></a>}</p>
<p><a id="c002_c2-para-2134"></a>To incorporate polynomials into our generic arithmetic system, we need to supply them with type tags. We'll use the tag <span class="KeyTerm1">"polynomial"</span>, and install appropriate operations on tagged polynomials in the operation table. We'll embed all our code in an installation function for the polynomial package, similar to the installation functions in section 2.5.1:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2135"></a><b>function</b> install_polynomial_package() {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2136"></a> <span class="KeyTerm2"><i>// internal functions</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-2137"></a> <span class="KeyTerm2"><i>// representation of poly</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-2138"></a> <b>function</b> make_poly(variable, term_list) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2139"></a> <b>return</b> pair(variable, term_list);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2140"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2141"></a> <b>function</b> variable(p) { <b>return</b> head(p); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2142"></a> <b>function</b> term_list(p) { <b>return</b> tail(p); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2143"></a>    〈<span class="KeyTerm2"><i>functions</i></span> is_same_variable <span class="KeyTerm2"><i>and</i></span> is_variable <span class="KeyTerm2"><i>from</i> <i>section 2.3.2</i></span>〉    </p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-2144"></a> <span class="KeyTerm2"><i>// representation of terms and term lists</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-2145"></a>    〈<span class="KeyTerm2"><i>functions</i></span> adjoin_term…coeff <span class="KeyTerm2"><i>from text below</i></span>〉</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-2146"></a> <b>function</b> add_poly(p1, p2) { … }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2147"></a>    〈<span class="KeyTerm2"><i>functions used by</i></span> add_poly〉</p>
<p class="Sp-text-1"><a id="c002_c2-para-2148"></a> <b>function</b> mul_poly(p1, p2) { … }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2149"></a>    〈<span class="KeyTerm2"><i>functions used by</i></span> mul_poly〉    </p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-2150"></a> <span class="KeyTerm2"><i>// interface to rest of the system</i></span></p>
<p class="Sp-text-1"><a id="c002_c2-para-2151"></a> <b>function</b> tag(p) { <b>return</b> attach_tag("polynomial", p); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2152"></a>    put("add", list("polynomial", "polynomial"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2153"></a>        (p1, p2) =&gt; tag(add_poly(p1, p2)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2154"></a>    put("mul", list("polynomial", "polynomial"),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2155"></a>        (p1, p2) =&gt; tag(mul_poly(p1, p2)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2156"></a>    put("make", "polynomial",</p>
<p class="Sp-text-1"><a id="c002_c2-para-2157"></a>        (variable, terms) =&gt; tag(make_poly(variable, terms)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2158"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c002_c2-para-2159"></a>}</p>
<p><a id="c002_c2-para-2160"></a>Polynomial addition is performed termwise. Terms of the same order (i.e., with the same power of the indeterminate) must be combined. This is done by forming a new term of the same order whose coefficient is the sum of the coefficients of the addends. Terms in one addend for which there are no terms of the same order in the other addend are simply accumulated into the sum polynomial being constructed.</p>
<p><a id="c002_c2-para-2161"></a>In order to manipulate term lists, we will assume that we have a constructor <span class="KeyTerm1">the_empty_termlist</span> that returns an empty term list and a constructor <span class="KeyTerm1">adjoin_ term</span> that adjoins a new term to a term list. We will also assume that we have a predicate <span class="KeyTerm1">is_empty_termlist</span> that tells if a given term list is empty, a selector <span class="KeyTerm1">first_term</span> that extracts the highest-order term from a term list, and a selector <span class="KeyTerm1">rest_terms</span> that returns all but the highest-order term. To manipulate terms, we will suppose that we have a constructor <span class="KeyTerm1">make_term</span> that constructs a term with given order and coefficient, and selectors <span class="KeyTerm1">order</span> and <span class="KeyTerm1">coeff</span> that return, respectively, the order and the coefficient of the term. These operations allow us to consider both terms and term lists as data abstractions, whose concrete representations we can worry about separately.</p>
<p><a id="c002_c2-para-2162"></a>Here is the function that constructs the term list for the sum of two polynomials;<a id="c002_c2-fn-0053a"></a><a href="#c2-fn-0053"><sup>53</sup></a> note that we slightly extend the syntax of conditional statements described in section 1.3.2 by admitting another conditional statement in place of the block following <span class="KeyTerm1"><b>else</b></span>:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2163"></a><b>function</b> add_terms(L1, L2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2164"></a> <b>if</b> (is_empty_termlist(L1)) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2165"></a> <b>return</b> L2;</p>
<p class="Sp-text-1"><a id="c002_c2-para-2166"></a>    } <b>else if</b> (is_empty_termlist(L2)) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2167"></a> <b>return</b> L1;</p>
<p class="Sp-text-1"><a id="c002_c2-para-2168"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2169"></a> <b>const</b> t1 = first_term(L1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2170"></a> <b>const</b> t2 = first_term(L2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2171"></a> <b>return</b> order(t1) &gt; order(t2)</p>
<p class="Sp-text-1"><a id="c002_c2-para-2172"></a>               ? adjoin_term(t1, add_terms(rest_terms(L1), L2))</p>
<p class="Sp-text-1"><a id="c002_c2-para-2173"></a>               : order(t1) &lt; order(t2)</p>
<p class="Sp-text-1"><a id="c002_c2-para-2174"></a>               ? adjoin_term(t2, add_terms(L1, rest_terms(L2)))</p>
<p class="Sp-text-1"><a id="c002_c2-para-2175"></a>               : adjoin_term(make_term(order(t1),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2176"></a>                                       add(coeff(t1), coeff(t2))),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2177"></a>                             add_terms(rest_terms(L1),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2178"></a>                                       rest_terms(L2)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2179"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2180"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-2181"></a>The most important point to note here is that we used the generic addition function <span class="KeyTerm1">add</span> to add together the coefficients of the terms being combined. This has powerful consequences, as we will see below.</p>
<p><a id="c002_c2-para-2182"></a>In order to multiply two term lists, we multiply each term of the first list by all the terms of the other list, repeatedly using <span class="KeyTerm1">mul_term_by_all_terms</span>, which multiplies a given term by all terms in a given term list. The resulting term lists (one for each term of the first list) are accumulated into a sum. Multiplying two terms forms a term whose order is the sum of the orders of the factors and whose coefficient is the product of the coefficients of the factors:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2183"></a><b>function</b> mul_terms(L1, L2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2184"></a> <b>return</b> is_empty_termlist(L1)</p>
<p class="Sp-text-1"><a id="c002_c2-para-2185"></a>          ? the_empty_termlist</p>
<p class="Sp-text-1"><a id="c002_c2-para-2186"></a>          : add_terms(mul_term_by_all_terms(</p>
<p class="Sp-text-1"><a id="c002_c2-para-2187"></a>                                first_term(L1), L2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2188"></a>                      mul_terms(rest_terms(L1), L2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2189"></a>}</p>
<p class="Sp-text-1"><a id="c002_c2-para-2190"></a><b>function</b> mul_term_by_all_terms(t1, L) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2191"></a> <b>if</b> (is_empty_termlist(L)) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2192"></a> <b>return</b> the_empty_termlist;</p>
<p class="Sp-text-1"><a id="c002_c2-para-2193"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2194"></a> <b>const</b> t2 = first_term(L);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2195"></a> <b>return</b> adjoin_term(</p>
<p class="Sp-text-1"><a id="c002_c2-para-2196"></a>                   make_term(order(t1) + order(t2),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2197"></a>                             mul(coeff(t1), coeff(t2))),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2198"></a>                   mul_term_by_all_terms(t1, rest_terms(L)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2199"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2200"></a>}</p>
<p><a id="c002_c2-para-2201"></a>This is really all there is to polynomial addition and multiplication. Notice that, since we operate on terms using the generic functions <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span>, our polynomial package is automatically able to handle any type of coefficient that is known about by the generic arithmetic package. If we include a coercion mechanism such as one of those discussed in section 2.5.2, then we also are automatically able to handle operations on polynomials of different coefficient types, such as</p>
<p><a id="c002_c2-para-2202"></a></p>
<figure id="c002_c2-fig-0037"><img alt="c2-fig-5012.jpg" src="../images/c2-fig-5012.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p><a id="c002_c2-para-2203"></a>Because we installed the polynomial addition and multiplication functions <span class="KeyTerm1">add_ poly</span> and <span class="KeyTerm1">mul_poly</span> in the generic arithmetic system as the <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span> operations for type <span class="KeyTerm1">polynomial</span>, our system is also automatically able to handle polynomial operations such as</p>
<p class="Sp-text-2"><a id="c002_c2-para-2204"></a>(<i>y</i> + 1)<i>x</i><sup>2</sup> + (<i>y</i><sup>2</sup> + 1)<i>x</i> + (<i>y</i> – 1) · (<i>y</i> – 2)<i>x</i> + (<i>y</i><sup>3</sup> + 7)</p>
<p class="paracontinue"><a id="c002_c2-para-2205"></a>The reason is that when the system tries to combine coefficients, it will dispatch through <span class="KeyTerm1">add</span> and <span class="KeyTerm1">mul</span>. Since the coefficients are themselves polynomials (in <i>y</i>), these will be combined using <span class="KeyTerm1">add_poly</span> and <span class="KeyTerm1">mul_poly</span>. The result is a kind of “datadirected recursion” in which, for example, a call to <span class="KeyTerm1">mul_poly</span> will result in recursive calls to <span class="KeyTerm1">mul_poly</span> in order to multiply the coefficients. If the coefficients of the coefficients were themselves polynomials (as might be used to represent polynomials in three variables), the data direction would ensure that the system would follow through another level of recursive calls, and so on through as many levels as the structure of the data dictates.<a id="c002_c2-fn-0054a"></a><a href="#c2-fn-0054"><sup>54</sup></a></p>
</section>
<section>
<h5><a id="c002_c2-sec-0139"></a><a id="c002_c2-title-0140"></a>Representing term lists</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2206"></a>Finally, we must confront the job of implementing a good representation for term lists. A term list is, in effect, a set of coefficients keyed by the order of the term. Hence, any of the methods for representing sets, as discussed in section 2.3.3, can be applied to this task. On the other hand, our functions <span class="KeyTerm1">add_terms</span> and <span class="KeyTerm1">mul_terms</span> always access term lists sequentially from highest to lowest order. Thus, we will use some kind of ordered list representation.</p>
<p><a id="c002_c2-para-2207"></a>How should we structure the list that represents a term list? One consideration is the “density” of the polynomials we intend to manipulate. A polynomial is said to be <i>dense</i> if it has nonzero coefficients in terms of most orders. If it has many zero terms it is said to be <i>sparse</i>. For example,</p>
<p class="Sp-text-2"><a id="c002_c2-para-2208"></a><i>A</i>:  <i>x</i><sup>5</sup> + 2<i>x</i><sup>4</sup> + 3<i>x</i><sup>2</sup> – 2<i>x</i> – 5</p>
<p class="paracontinue"><a id="c002_c2-para-2209"></a>is a dense polynomial, whereas</p>
<p class="Sp-text-2"><a id="c002_c2-para-2210"></a><i>B</i>:  <i>x</i><sup>100</sup> + 2<i>x</i><sup>2</sup> + 1</p>
<p class="paracontinue"><a id="c002_c2-para-2211"></a>is sparse.</p>
<p><a id="c002_c2-para-2212"></a>The term list of a dense polynomial is most efficiently represented as a list of the coefficients. For example, the polynomial <i>A</i> above would be nicely represented as <span class="KeyTerm1">list(1, 2, 0, 3, -2, -5)</span>. The order of a term in this representation is the length of the sublist beginning with that term's coefficient, decremented by 1.<a id="c002_c2-fn-0055a"></a><a href="#c2-fn-0055"><sup>55</sup></a> This would be a terrible representation for a sparse polynomial such as <i>B</i>: There would be a giant list of zeros punctuated by a few lonely nonzero terms. A more reasonable representation of the term list of a sparse polynomial is as a list of the nonzero terms, where each term is a list containing the order of the term and the coefficient for that order. In such a scheme, polynomial <i>B</i> is efficiently represented as <span class="KeyTerm1">list(list(100, 1), list(2, 2), list(0, 1))</span>. As most polynomial manipulations are performed on sparse polynomials, we will use this method. We will assume that term lists are represented as lists of terms, arranged from highest-order to lowest-order term. Once we have made this decision, implementing the selectors and constructors for terms and term lists is straightforward:<a id="c002_c2-fn-0056a"></a><a href="#c2-fn-0056"><sup>56</sup></a></p>
<p class="Sp-text-1"><a id="c002_c2-para-2213"></a><b>function</b> adjoin_term(term, term_list) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2214"></a> <b>return</b> is_equal_to_zero(coeff(term))</p>
<p class="Sp-text-1"><a id="c002_c2-para-2215"></a>           ? term_list</p>
<p class="Sp-text-1"><a id="c002_c2-para-2216"></a>           : pair(term, term_list);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2217"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-2218"></a><b>const</b> the_empty_termlist = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c002_c2-para-2219"></a><b>function</b> first_term(term_list) { <b>return</b> head(term_list); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2220"></a><b>function</b> rest_terms(term_list) { <b>return</b> tail(term_list); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2221"></a><b>function</b> is_empty_termlist(term_list) { <b>return</b> is_null(term_list); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-2222"></a><b>function</b> make_term(order, coeff) { <b>return</b> list(order, coeff); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2223"></a><b>function</b> order(term) { <b>return</b> head(term); }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2224"></a><b>function</b> coeff(term) { <b>return</b> head(tail(term)); }</p>
<p class="paracontinue"><a id="c002_c2-para-2225"></a>where <span class="KeyTerm1">is_equal_to_zero</span> is as defined in exercise 2.80. (See also exercise 2.87 below.)</p>
<p><a id="c002_c2-para-2226"></a>Users of the polynomial package will create (tagged) polynomials by means of the function:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2227"></a><b>function</b> make_polynomial(variable, terms) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2228"></a> <b>return</b> get("make", "polynomial")(variable, terms);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2229"></a>}</p>
</section>
<section>
<h5><a id="c002_c2-sec-0140"></a><a id="c002_c2-title-0141"></a>Exercise 2.87</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2230"></a>Install <span class="KeyTerm1">is_equal_to_zero</span> for polynomials in the generic arithmetic package. This will allow <span class="KeyTerm1">adjoin_term</span> to work for polynomials with coefficients that are themselves polynomials.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0141"></a><a id="c002_c2-title-0142"></a>Exercise 2.88</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2231"></a>Extend the polynomial system to include subtraction of polynomials. (Hint: You may find it helpful to define a generic negation operation.)</p>
</section>
<section>
<h5><a id="c002_c2-sec-0142"></a><a id="c002_c2-title-0143"></a>Exercise 2.89</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2232"></a>Declare functions that implement the term-list representation described above as appropriate for dense polynomials.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0143"></a><a id="c002_c2-title-0144"></a>Exercise 2.90</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2233"></a>Suppose we want to have a polynomial system that is efficient for both sparse and dense polynomials. One way to do this is to allow both kinds of term-list representations in our system. The situation is analogous to the complex-number example of section 2.4, where we allowed both rectangular and polar representations. To do this we must distinguish different types of term lists and make the operations on term lists generic. Redesign the polynomial system to implement this generalization. This is a major effort, not a local change.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0144"></a><a id="c002_c2-title-0145"></a>Exercise 2.91</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2234"></a>A univariate polynomial can be divided by another one to produce a polynomial quotient and a polynomial remainder. For example,</p>
<p class="Sp-text-2"><a id="c002_c2-para-2235"></a><img alt="c2-fig-5013.jpg" src="../images/c2-fig-5013.jpg"/> = <i>x</i><sup>3</sup> + <i>x</i>, remainder <i>x</i> – 1</p>
<p class="paracontinue"><a id="c002_c2-para-2236"></a>Division can be performed via long division. That is, divide the highest-order term of the dividend by the highest-order term of the divisor. The result is the first term of the quotient. Next, multiply the result by the divisor, subtract that from the dividend, and produce the rest of the answer by recursively dividing the difference by the divisor. Stop when the order of the divisor exceeds the order of the dividend and declare the dividend to be the remainder. Also, if the dividend ever becomes zero, return zero as both quotient and remainder.</p>
<p><a id="c002_c2-para-2237"></a>We can design a <span class="KeyTerm1">div_poly</span> function on the model of <span class="KeyTerm1">add_poly</span> and <span class="KeyTerm1">mul_poly</span>. The function checks to see if the two polys have the same variable. If so, <span class="KeyTerm1">div_poly</span> strips off the variable and passes the problem to <span class="KeyTerm1">div_terms</span>, which performs the division operation on term lists. The function <span class="KeyTerm1">div_poly</span> finally reattaches the variable to the result supplied by <span class="KeyTerm1">div_terms</span>. It is convenient to design <span class="KeyTerm1">div_terms</span> to compute both the quotient and the remainder of a division. The function <span class="KeyTerm1">div_terms</span> can take two term lists as arguments and return a list of the quotient term list and the remainder term list.</p>
<p><a id="c002_c2-para-2238"></a>Complete the following definition of <span class="KeyTerm1">div_terms</span> by filling in the missing parts. Use this to implement <span class="KeyTerm1">div_poly</span>, which takes two polys as arguments and returns a list of the quotient and remainder polys.</p>
<p class="Sp-text-1"><a id="c002_c2-para-2239"></a><b>function</b> div_terms(L1, L2) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2240"></a> <b>if</b> (is_empty_termlist(L1)) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2241"></a> <b>return</b> list(the_empty_termlist, the_empty_termlist);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2242"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2243"></a> <b>const</b> t1 = first_term(L1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2244"></a> <b>const</b> t2 = first_term(L2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2245"></a> <b>if</b> (order(t2) &gt; order(t1)) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2246"></a> <b>return</b> list(the_empty_termlist, L1);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2247"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2248"></a> <b>const</b> new_c = div(coeff(t1), coeff(t2));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2249"></a> <b>const</b> new_o = order(t1) - order(t2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2250"></a> <b>const</b> rest_of_result = 〈<span class="KeyTerm2"><i>compute rest of result recursively</i></span>〉;</p>
<p class="Sp-text-1"><a id="c002_c2-para-2251"></a>            〈<span class="KeyTerm2"><i>form and return complete result</i></span>〉</p>
<p class="Sp-text-1"><a id="c002_c2-para-2252"></a> <sub>}</sub></p>
<p class="Sp-text-1"><a id="c002_c2-para-2253"></a>    }</p>
<p class="Sp-text-1"><a id="c002_c2-para-2254"></a>}</p>
</section>
<section>
<h5><a id="c002_c2-sec-0145"></a><a id="c002_c2-title-0146"></a>Hierarchies of types in symbolic algebra</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2255"></a>Our polynomial system illustrates how objects of one type (polynomials) may in fact be complex objects that have objects of many different types as parts. This poses no real difficulty in defining generic operations. We need only install appropriate generic operations for performing the necessary manipulations of the parts of the compound types. In fact, we saw that polynomials form a kind of “recursive data abstraction,” in that parts of a polynomial may themselves be polynomials. Our generic operations and our data-directed programming style can handle this complication without much trouble.</p>
<p><a id="c002_c2-para-2256"></a>On the other hand, polynomial algebra is a system for which the data types cannot be naturally arranged in a tower. For instance, it is possible to have polynomials in <i>x</i> whose coefficients are polynomials in <i>y</i>. It is also possible to have polynomials in <i>y</i> whose coefficients are polynomials in <i>x</i>. Neither of these types is “above” the other in any natural way, yet it is often necessary to add together elements from each set. There are several ways to do this. One possibility is to convert one polynomial to the type of the other by expanding and rearranging terms so that both polynomials have the same principal variable. One can impose a towerlike structure on this by ordering the variables and thus always converting any polynomial to a “canonical form” with the highest-priority variable dominant and the lower-priority variables buried in the coefficients. This strategy works fairly well, except that the conversion may expand a polynomial unnecessarily, making it hard to read and perhaps less efficient to work with. The tower strategy is certainly not natural for this domain or for any domain where the user can invent new types dynamically using old types in various combining forms, such as trigonometric functions, power series, and integrals.</p>
<p><a id="c002_c2-para-2257"></a>It should not be surprising that controlling coercion is a serious problem in the design of large-scale algebraic-manipulation systems. Much of the complexity of such systems is concerned with relationships among diverse types. Indeed, it is fair to say that we do not yet completely understand coercion. In fact, we do not yet completely understand the concept of a data type. Nevertheless, what we know provides us with powerful structuring and modularity principles to support the design of large systems.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0146"></a><a id="c002_c2-title-0147"></a>Exercise 2.92</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2258"></a>By imposing an ordering on variables, extend the polynomial package so that addition and multiplication of polynomials works for polynomials in different variables. (This is not easy!)</p>
</section>
<section>
<h5><a id="c002_c2-sec-0147"></a><a id="c002_c2-title-0148"></a>Extended exercise: Rational functions</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2259"></a>We can extend our generic arithmetic system to include <i>rational functions</i>. These are “fractions” whose numerator and denominator are polynomials, such as</p>
<p><a id="c002_c2-para-2260"></a></p>
<figure id="c002_c2-fig-0038"><img alt="c2-fig-5014.jpg" src="../images/c2-fig-5014.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-2261"></a>The system should be able to add, subtract, multiply, and divide rational functions, and to perform such computations as</p>
<p><a id="c002_c2-para-2262"></a></p>
<figure id="c002_c2-fig-0039"><img alt="c2-fig-5015.jpg" src="../images/c2-fig-5015.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c002_c2-para-2263"></a>(Here the sum has been simplified by removing common factors. Ordinary “cross multiplication” would have produced a fourth-degree polynomial over a fifth-degree polynomial.)</p>
<p><a id="c002_c2-para-2264"></a>If we modify our rational-arithmetic package so that it uses generic operations, then it will do what we want, except for the problem of reducing fractions to lowest terms.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0148"></a><a id="c002_c2-title-0149"></a>Exercise 2.93</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2265"></a>Modify the rational-arithmetic package to use generic operations, but change <span class="KeyTerm1">make_rat</span> so that it does not attempt to reduce fractions to lowest terms. Test your system by calling <span class="KeyTerm1">make_rational</span> on two polynomials to produce a rational function</p>
<p class="Sp-text-1"><a id="c002_c2-para-2266"></a><b>const</b> p1 = make_polynomial("x", list(make_term(2, 1), make_term(0, 1)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2267"></a><b>const</b> p2 = make_polynomial("x", list(make_term(3, 1), make_term(0, 1)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2268"></a><b>const</b> rf = make_rational(p2, p1);</p>
<p class="paracontinue"><a id="c002_c2-para-2269"></a>Now add <span class="KeyTerm1">rf</span> to itself, using <span class="KeyTerm1">add</span>. You will observe that this addition function does not reduce fractions to lowest terms.</p>
<p><a id="c002_c2-para-2270"></a>We can reduce polynomial fractions to lowest terms using the same idea we used with integers: modifying <span class="KeyTerm1">make_rat</span> to divide both the numerator and the denominator by their greatest common divisor. The notion of “greatest common divisor” makes sense for polynomials. In fact, we can compute the GCD of two polynomials using essentially the same Euclid's Algorithm that works for integers.<a id="c002_c2-fn-0057a"></a><a href="#c2-fn-0057"><sup>57</sup></a> The integer version is</p>
<p class="Sp-text-1"><a id="c002_c2-para-2271"></a><b>function</b> gcd(a, b) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2272"></a> <b>return</b> b === 0</p>
<p class="Sp-text-1"><a id="c002_c2-para-2273"></a>           ? a</p>
<p class="Sp-text-1"><a id="c002_c2-para-2274"></a>           : gcd(b, a % b);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2275"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-2276"></a>Using this, we could make the obvious modification to define a GCD operation that works on term lists:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2277"></a><b>function</b> gcd_terms(a, b) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2278"></a> <b>return</b> is_empty_termlist(b)</p>
<p class="Sp-text-1"><a id="c002_c2-para-2279"></a>           ? a</p>
<p class="Sp-text-1"><a id="c002_c2-para-2280"></a>           : gcd_terms(b, remainder_terms(a, b));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2281"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-2282"></a>where <span class="KeyTerm1">remainder_terms</span> picks out the remainder component of the list returned by the term-list division operation <span class="KeyTerm1">div_terms</span> that was implemented in exercise 2.91.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0149"></a><a id="c002_c2-title-0150"></a>Exercise 2.94</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2283"></a>Using <span class="KeyTerm1">div_terms</span>, implement the function <span class="KeyTerm1">remainder_terms</span> and use this to define <span class="KeyTerm1">gcd_ terms</span> as above. Now write a function <span class="KeyTerm1">gcd_poly</span> that computes the polynomial GCD of two polys. (The function should signal an error if the two polys are not in the same variable.) Install in the system a generic operation <span class="KeyTerm1">greatest_common_divisor</span> that reduces to <span class="KeyTerm1">gcd_poly</span> for polynomials and to ordinary <span class="KeyTerm1">gcd</span> for ordinary numbers. As a test, try</p>
<p class="Sp-text-1"><a id="c002_c2-para-2284"></a><b>const</b> p1 = make_polynomial("x", list(make_term(4, 1), make_term(3, -1),</p>
<p class="Sp-text-1"><a id="c002_c2-para-2285"></a>                                     make_term(2, -2), make_term(1, 2)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2286"></a><b>const</b> p2 = make_polynomial("x", list(make_term(3, 1), make_term(1, -1)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2287"></a>greatest_common_divisor(p1, p2);</p>
<p class="paracontinue"><a id="c002_c2-para-2288"></a>and check your result by hand.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0150"></a><a id="c002_c2-title-0151"></a>Exercise 2.95</h5>
<p class="paraaftertitle"><a id="c002_c2-para-2289"></a>Define <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and <i>P</i><sub>3</sub> to be the polynomials</p>
<p class="Sp-text-2"><a id="c002_c2-para-2290"></a><i>P</i><sub>1</sub>:  <i>x</i><sup>2</sup> – 2<i>x</i> + 1</p>
<p class="Sp-text-2"><a id="c002_c2-para-2291"></a><i>P</i><sub>2</sub>:  11<i>x</i><sup>2</sup> + 7</p>
<p class="Sp-text-2"><a id="c002_c2-para-2292"></a><i>P</i><sub>3</sub>:  13<i>x</i> + 5</p>
<p class="paracontinue"><a id="c002_c2-para-2293"></a>Now define <i>Q</i><sub>1</sub> to be the product of <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub> and <i>Q</i><sub>2</sub> to be the product of <i>P</i><sub>1</sub> and <i>P</i><sub>3</sub>, and use <span class="KeyTerm1">greatest_common_divisor</span> (exercise 2.94) to compute the GCD of <i>Q</i><sub>1</sub> and <i>Q</i><sub>2</sub>. Note that the answer is not the same as <i>P</i><sub>1</sub>. This example introduces noninteger operations into the computation, causing difficulties with the GCD algorithm.<a id="c002_c2-fn-0058a"></a><a href="#c2-fn-0058"><sup>58</sup></a> To understand what is happening, try tracing <span class="KeyTerm1">gcd_terms</span> while computing the GCD or try performing the division by hand.</p>
<p><a id="c002_c2-para-2294"></a>We can solve the problem exhibited in exercise 2.95 if we use the following modification of the GCD algorithm (which really works only in the case of polynomials with integer coefficients). Before performing any polynomial division in the GCD computation, we multiply the dividend by an integer constant factor, chosen to guarantee that no fractions will arise during the division process. Our answer will thus differ from the actual GCD by an integer constant factor, but this does not matter in the case of reducing rational functions to lowest terms; the GCD will be used to divide both the numerator and denominator, so the integer constant factor will cancel out.</p>
<p><a id="c002_c2-para-2295"></a>More precisely, if <i>P</i> and <i>Q</i> are polynomials, let <i>O</i><sub>1</sub> be the order of <i>P</i> (i.e., the order of the largest term of <i>P</i>) and let <i>O</i><sub>2</sub> be the order of <i>Q</i>. Let <i>c</i> be the leading coefficient of <i>Q</i>. Then it can be shown that, if we multiply <i>P</i> by the <i>integerizing factor c</i><sup>1+</sup><i><sup>O</sup></i><sup>1–</sup><i><sup>O</sup></i><sup>2,</sup> the resulting polynomial can be divided by <i>Q</i> by using the <span class="KeyTerm1">div_terms</span> algorithm without introducing any fractions. The operation of multiplying the dividend by this constant and then dividing is sometimes called the <i>pseudodivision</i> of <i>P</i> by <i>Q</i>. The remainder of the division is called the <i>pseudoremainder</i>.</p>
</section>
<section>
<h5><a id="c002_c2-sec-0151"></a><a id="c002_c2-title-0152"></a>Exercise 2.96</h5>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0061"></a><span>a. </span>Implement the function <span class="KeyTerm1">pseudoremainder_terms</span>, which is just like <span class="KeyTerm1">remainder_terms</span> except that it multiplies the dividend by the integerizing factor described above before calling <span class="KeyTerm1">div_terms</span>. Modify <span class="KeyTerm1">gcd_terms</span> to use <span class="KeyTerm1">pseudoremainder_terms</span>, and verify that <span class="KeyTerm1">greatest_common_divisor</span> now produces an answer with integer coefficients on the example in exercise 2.95.</li>
<li><a id="c002_c2-li-0062"></a><span>b. </span>The GCD now has integer coefficients, but they are larger than those of <i>P</i><sub>1</sub>. Modify <span class="KeyTerm1">gcd_terms</span> so that it removes common factors from the coefficients of the answer by dividing all the coefficients by their (integer) greatest common divisor.</li>
</ol>
<p><a id="c002_c2-para-2298"></a>Thus, here is how to reduce a rational function to lowest terms:</p>
<ul style="list-style-type:disc">
<li>Compute the GCD of the numerator and denominator, using the version of <span class="KeyTerm1">gcd_ terms</span> from exercise 2.96.</li>
<li>When you obtain the GCD, multiply both numerator and denominator by the same integerizing factor before dividing through by the GCD, so that division by the GCD will not introduce any noninteger coefficients. As the factor you can use the leading coefficient of the GCD raised to the power 1 + <i>O</i><sub>1</sub> – <i>O</i><sub>2</sub>, where <i>O</i><sub>2</sub> is the order of the GCD and <i>O</i><sub>1</sub> is the maximum of the orders of the numerator and denominator. This will ensure that dividing the numerator and denominator by the GCD will not introduce any fractions.</li>
<li>The result of this operation will be a numerator and denominator with integer coefficients. The coefficients will normally be very large because of all of the integerizing factors, so the last step is to remove the redundant factors by computing the (integer) greatest common divisor of all the coefficients of the numerator and the denominator and dividing through by this factor.</li>
</ul>
</section>
<section>
<h5><a id="c002_c2-sec-0152"></a><a id="c002_c2-title-0153"></a>Exercise 2.97</h5>
<ol class="BS_NumberListA">
<li><a id="c002_c2-li-0066"></a><span>a. </span>Implement this algorithm as a function <span class="KeyTerm1">reduce_terms</span> that takes two term lists <span class="KeyTerm1">n</span> and <span class="KeyTerm1">d</span> as arguments and returns a list <span class="KeyTerm1">nn</span>, <span class="KeyTerm1">dd</span>, which are <span class="KeyTerm1">n</span> and <span class="KeyTerm1">d</span> reduced to lowest terms via the algorithm given above. Also write a function <span class="KeyTerm1">reduce_poly</span>, analogous to <span class="KeyTerm1">add_poly</span>, that checks to see if the two polys have the same variable. If so, <span class="KeyTerm1">reduce_poly</span> strips off the variable and passes the problem to <span class="KeyTerm1">reduce_terms</span>, then reattaches the variable to the two term lists supplied by <span class="KeyTerm1">reduce_terms</span>.</li>
<li><a id="c002_c2-li-0067"></a><span>b. </span>Define a function analogous to <span class="KeyTerm1">reduce_terms</span> that does what the original <span class="KeyTerm1">make_rat</span> did for integers:
<p class="Sp-text-1"><a id="c002_c2-para-2304"></a><b>function</b> reduce_integers(n, d) {</p>
<p class="Sp-text-1"><a id="c002_c2-para-2305"></a> <b>const</b> g = gcd(n, d);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2306"></a> <b>return</b> list(n / g, d / g);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2307"></a>}</p>
<p class="paracontinue"><a id="c002_c2-para-2308"></a>and define <span class="KeyTerm1">reduce</span> as a generic operation that calls <span class="KeyTerm1">apply_generic</span> to dispatch either to <span class="KeyTerm1">reduce_poly</span> (for <span class="KeyTerm1">polynomial</span> arguments) or to <span class="KeyTerm1">reduce_integers</span> (for <span class="KeyTerm1">javascript_ number</span> arguments). You can now easily make the rational-arithmetic package reduce fractions to lowest terms by having <span class="KeyTerm1">make_rat</span> call <span class="KeyTerm1">reduce</span> before combining the given numerator and denominator to form a rational number. The system now handles rational expressions in either integers or polynomials. To test your program, try the example at the beginning of this extended exercise:</p>
<p class="Sp-text-1"><a id="c002_c2-para-2309"></a><b>const</b> p1 = make_polynomial("x", list(make_term(1, 1), make_term(0, 1)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2310"></a><b>const</b> p2 = make_polynomial("x", list(make_term(3, 1), make_term(0, -1)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2311"></a><b>const</b> p3 = make_polynomial("x", list(make_term(1, 1)));</p>
<p class="Sp-text-1"><a id="c002_c2-para-2312"></a><b>const</b> p4 = make_polynomial("x", list(make_term(2, 1), make_term(0, -1)));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-2313"></a><b>const</b> rf1 = make_rational(p1, p2);</p>
<p class="Sp-text-1"><a id="c002_c2-para-2314"></a><b>const</b> rf2 = make_rational(p3, p4);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c002_c2-para-2315"></a>add(rf1, rf2);</p>
<p class="paracontinue"><a id="c002_c2-para-2316"></a>See if you get the correct answer, correctly reduced to lowest terms.</p></li>
</ol>
<p><a id="c002_c2-para-2317"></a>The GCD computation is at the heart of any system that does operations on rational functions. The algorithm used above, although mathematically straightforward, is extremely slow. The slowness is due partly to the large number of division operations and partly to the enormous size of the intermediate coefficients generated by the pseudodivisions. One of the active areas in the development of algebraicmanipulation systems is the design of better algorithms for computing polynomial GCDs.<a id="c002_c2-fn-0059a"></a><a href="#c2-fn-0059"><sup>59</sup></a></p>
</section>
</section>
</section>
</section>
<section class="BS_enoteSec">
<aside class="noteEntry"><a id="c002_c2-fn-0001"></a><a href="#c2-fn-0001a">1</a> The ability to directly manipulate functions provides an analogous increase in the expressive power of a programming language. For example, in section 1.3.1 we introduced the <span class="KeyTerm1">sum</span> function, which takes a function <span class="KeyTerm1">term</span> as an argument and computes the sum of the values of <span class="KeyTerm1">term</span> over some specified interval. In order to define <span class="KeyTerm1">sum</span>, it is crucial that we be able to speak of a function such as <span class="KeyTerm1">term</span> as an entity in its own right, without regard for how <span class="KeyTerm1">term</span> might be expressed with more primitive operations. Indeed, if we did not have the notion of “a function,” it is doubtful that we would ever even think of the possibility of defining an operation such as <span class="KeyTerm1">sum</span>. Moreover, insofar as performing the summation is concerned, the details of how <span class="KeyTerm1">term</span> may be constructed from more primitive operations are irrelevant.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0002"></a><a href="#c2-fn-0002a">2</a> Another way to define the selectors and constructor is
<br/><span class="BS_Sp-text-1_FN"><b>const</b> make_rat = pair;</span>
<br/><span class="BS_Sp-text-1_FN"><b>const</b> numer = head;</span>
<br/><span class="BS_Sp-text-1_FN"><b>const</b> denom = tail;</span>
<br/>The first definition associates the name <span class="KeyTerm1">make_rat</span> with the value of the expression <span class="KeyTerm1">pair</span>, which is the primitive function that constructs pairs. Thus <span class="KeyTerm1">make_rat</span> and <span class="KeyTerm1">pair</span> are names for the same primitive constructor.<br/>  Defining selectors and constructors in this way is efficient: Instead of <span class="KeyTerm1">make_rat</span> <i>calling</i> <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">make_rat</span> <i>is</i> <span class="KeyTerm1">pair</span>, so there is only one function called, not two, when <span class="KeyTerm1">make_rat</span> is called. On the other hand, doing this defeats debugging aids that trace function calls or put breakpoints on function calls: You may want to watch <span class="KeyTerm1">make_rat</span> being called, but you certainly don't want to watch every call to <span class="KeyTerm1">pair</span>.<br/>  We have chosen not to use this style of definition in this book.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0003"></a><a href="#c2-fn-0003a">3</a> In JavaScript, the operator <span class="KeyTerm1">+</span> can also be applied to a string and a number and to other operand combinations, but in this book, we choose to apply it either to two numbers or to two strings.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0004"></a><a href="#c2-fn-0004a">4</a> The primitive function <span class="KeyTerm1">display</span> introduced in exercise 1.22 returns its argument, but in the uses of <span class="KeyTerm1">print_rat</span> below, we show only what <span class="KeyTerm1">print_rat</span> prints, not what the interpreter prints as the value returned by <span class="KeyTerm1">print_rat</span>.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0005"></a><a href="#c2-fn-0005a">5</a> Surprisingly, this idea is very difficult to formulate rigorously. There are two approaches to giving such a formulation. One, pioneered by C. A. R. Hoare (1972), is known as the method of <i>abstract models</i>. It formalizes the “functions plus conditions” specification as outlined in the rational-number example above. Note that the condition on the rational-number representation was stated in terms of facts about integers (equality and division). In general, abstract models define new kinds of data objects in terms of previously defined types of data objects. Assertions about data objects can therefore be checked by reducing them to assertions about previously defined data objects. Another approach, introduced by Zilles at MIT, by Goguen, Thatcher, Wagner, and Wright at IBM (see Thatcher, Wagner, and Wright 1978), and by Guttag at Toronto (see Guttag 1977), is called <i>algebraic specification</i>. It regards the “functions” as elements of an abstract algebraic system whose behavior is specified by axioms that correspond to our “conditions,” and uses the techniques of abstract algebra to check assertions about data objects. Both methods are surveyed in the paper by Liskov and Zilles (1975).</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0006"></a><a href="#c2-fn-0006a">6</a> The function <span class="KeyTerm1">error</span> introduced in section 1.3.3 takes as optional second argument a string that gets displayed before the first argument—for example, if <span class="KeyTerm1">m</span> is 42:
<br/><span class="BS_Sp-text-1_FN">Error in line 7: argument not 0 or 1 – pair: 42</span></aside>
<aside class="noteEntry"><a id="c002_c2-fn-0007"></a><a href="#c2-fn-0007a">7</a> The use of the word “closure” here comes from abstract algebra, where a set of elements is said to be closed under an operation if applying the operation to elements in the set produces an element that is again an element of the set. The programming languages community also (unfortunately) uses the word “closure” to describe a totally unrelated concept: A closure is an implementation technique for representing functions with free names. We do not use the word “closure” in this second sense in this book.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0008"></a><a href="#c2-fn-0008a">8</a> In this book, we use <i>list</i> to mean a chain of pairs terminated by the end-of-list marker. In contrast, the term <i>list structure</i> refers to any data structure made out of pairs, not just to lists.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0009"></a><a href="#c2-fn-0009a">9</a> The value <span class="KeyTerm1"><b>null</b></span> is used in JavaScript for various purposes, but in this book we shall only use it to represent the empty list.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0010"></a><a href="#c2-fn-0010a">10</a> Our JavaScript environment provides a primitive function <span class="KeyTerm1">display_list</span> that works like the primitive function <span class="KeyTerm1">display</span>, except that it uses list notation instead of box notation.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0011"></a><a href="#c2-fn-0011a">11</a> The order of the two predicates matters, since <span class="KeyTerm1"><b>null</b></span> satisfies <span class="KeyTerm1">is_null</span> and also is not a pair.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0012"></a><a href="#c2-fn-0012a">12</a> This is, in fact, precisely the <span class="KeyTerm1">fringe</span> function from exercise 2.28. Here we've renamed it to emphasize that it is part of a family of general sequence-manipulation functions.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0013"></a><a href="#c2-fn-0013a">13</a> Richard Waters (1979) developed a program that automatically analyzes traditional Fortran programs, viewing them in terms of maps, filters, and accumulations. He found that fully 90 percent of the code in the Fortran Scientific Subroutine Package fits neatly into this paradigm. One of the reasons for the success of Lisp as a programming language is that lists provide a standard medium for expressing ordered collections so that they can be manipulated using higher-order operations. Many modern languages, such as Python, have learned this lesson.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0014"></a><a href="#c2-fn-0014a">14</a> According to Knuth (1997b), this rule was formulated by W. G. Horner early in the nineteenth century, but the method was actually used by Newton over a hundred years earlier. Horner's rule evaluates the polynomial using fewer additions and multiplications than does the straightforward method of first computing <i>a<sub>n</sub>x<sup>n</sup></i>, then adding <i>a<sub>n</sub></i><sub>–1</sub><i>x<sup>n</sup></i><sup>–1</sup>, and so on. In fact, it is possible to prove that any algorithm for evaluating arbitrary polynomials must use at least as many additions and multiplications as does Horner's rule, and thus Horner's rule is an optimal algorithm for polynomial evaluation. This was proved (for the number of additions) by A. M. Ostrowski in a 1954 paper that essentially founded the modern study of optimal algorithms. The analogous statement for multiplications was proved by V. Y. Pan in 1966. The book by Borodin and Munro (1975) provides an overview of these and other results about optimal algorithms.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0015"></a><a href="#c2-fn-0015a">15</a> This definition uses the function <span class="KeyTerm1">accumulate_n</span> from exercise 2.36.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0016"></a><a href="#c2-fn-0016a">16</a> This approach to nested mappings was shown to us by David Turner, whose languages KRC and Miranda provide elegant formalisms for dealing with these constructs. The examples in this section (see also exercise 2.42) are adapted from Turner 1981. In section 3.5.3, we'll see how this approach generalizes to infinite sequences.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0017"></a><a href="#c2-fn-0017a">17</a> We're representing a pair here as a list of two elements rather than as an ordinary pair. Thus, the “pair” (<i>i</i>, <i>j</i>) is represented as <span class="KeyTerm1">list(i, j)</span>, not <span class="KeyTerm1">pair(i, j)</span>.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0018"></a><a href="#c2-fn-0018a">18</a> The set <i>S</i> – <i>x</i> is the set of all elements of <i>S</i>, excluding <i>x</i>.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0019"></a><a href="#c2-fn-0019a">19</a> The character sequence <i>//</i> in JavaScript programs is used to introduce <i>comments</i>. Everything from <i>//</i> to the end of the line is ignored by the interpreter. In this book we don't use many comments; we try to make our programs self-documenting by using descriptive names.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0020"></a><a href="#c2-fn-0020a">20</a> The picture language is based on the language Peter Henderson created to construct images like M.C. Escher's “Square Limit” woodcut (see Henderson 1982). The woodcut incorporates a repeated scaled pattern, similar to the arrangements drawn using the <span class="KeyTerm1">square_limit</span> function in this section.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0021"></a><a href="#c2-fn-0021a">21</a> William Barton Rogers (1804–1882) was the founder and first president of MIT. A geologist and talented teacher, he taught at William and Mary College and at the University of Virginia. In 1859 he moved to Boston, where he had more time for research, worked on a plan for establishing a “polytechnic institute,” and served as Massachusetts's first State Inspector of Gas Meters.<br/>  When MIT was established in 1861, Rogers was elected its first president. Rogers espoused an ideal of “useful learning” that was different from the university education of the time, with its overemphasis on the classics, which, as he wrote, “stand in the way of the broader, higher and more practical instruction and discipline of the natural and social sciences.” This education was likewise to be different from narrow trade-school education. In Rogers's words:
<blockquote class="quote">
<p class="quoteparafirst"><a id="c002_c2-para-0842"></a>The world-enforced distinction between the practical and the scientific worker is utterly futile, and the whole experience of modern times has demonstrated its utter worthlessness.</p></blockquote>Rogers served as president of MIT until 1870, when he resigned due to ill health. In 1878 the second president of MIT, John Runkle, resigned under the pressure of a financial crisis brought on by the Panic of 1873 and strain of fighting off attempts by Harvard to take over MIT. Rogers returned to hold the office of president until 1881.<br/>  Rogers collapsed and died while addressing MIT's graduating class at the commencement exercises of 1882. Runkle quoted Rogers's last words in a memorial address delivered that same year:
<blockquote class="quote">
<p class="quoteparafirst"><a id="c002_c2-para-0844"></a>“As I stand here today and see what the Institute is, . . . I call to mind the beginnings of science. I remember one hundred and fifty years ago Stephen Hales published a pamphlet on the subject of illuminating gas, in which he stated that his researches had demonstrated that 128 grains of bituminous coal—”</p>
<p class="quotepara"><a id="c002_c2-para-0845"></a>“Bituminous coal,” these were his last words on earth. Here he bent forward, as if consulting some notes on the table before him, then slowly regaining an erect position, threw up his hands, and was translated from the scene of his earthly labors and triumphs to “the tomorrow of death,” where the mysteries of life are solved, and the disembodied spirit finds unending satisfaction in contemplating the new and still unfathomable mysteries of the infinite future.</p></blockquote>In the words of Francis A. Walker (MIT's third president):
<blockquote class="quote">
<p class="quoteparafirst"><a id="c002_c2-para-0847"></a>All his life he had borne himself most faithfully and heroically, and he died as so good a knight would surely have wished, in harness, at his post, and in the very part and act of public duty.</p></blockquote></aside>
<aside class="noteEntry"><a id="c002_c2-fn-0022"></a><a href="#c2-fn-0022a">22</a> In <span class="KeyTerm1">square_of_four</span>, we use an extension of the syntax of lambda expressions that was introduced in section 1.3.2: The body of a lambda expression can be a block, not just a return expression. Such a lambda expression has the shape <span class="KeyTerm1">(</span><i>parameters</i><span class="KeyTerm1">) =&gt; {</span> <i>statements</i> <span class="KeyTerm1">}</span> or <i>parameter</i> <span class="KeyTerm1">=&gt; {</span> <i>statements</i> <span class="KeyTerm1">}</span>.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0023"></a><a href="#c2-fn-0023a">23</a> Equivalently, we could write
<br/><span class="BS_Sp-text-1_FN"><b>const</b> flipped_pairs = square_of_four(identity, flip_vert,</span>
<br/><span class="BS_Sp-text-1_FN">                                     identity, flip_vert);</span></aside>
<aside class="noteEntry"><a id="c002_c2-fn-0024"></a><a href="#c2-fn-0024a">24</a> The function <span class="KeyTerm1">rotate180</span> rotates a painter by 180 degrees. Instead of <span class="KeyTerm1">rotate180</span> we could say <span class="KeyTerm1">compose(flip_vert, flip_horiz)</span>, using the <span class="KeyTerm1">compose</span> function from exercise 1.42.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0025"></a><a href="#c2-fn-0025a">25</a> The function <span class="KeyTerm1">frame_coord_map</span> uses the vector operations described in exercise 2.46 below, which we assume have been implemented using some representation for vectors. Because of data abstraction, it doesn't matter what this vector representation is, so long as the vector operations behave correctly.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0026"></a><a href="#c2-fn-0026a">26</a> The function <span class="KeyTerm1">segments_to_painter</span> uses the representation for line segments described in exercise 2.48 below. It also uses the <span class="KeyTerm1">for_each</span> function described in exercise 2.23.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0027"></a><a href="#c2-fn-0027a">27</a> For example, the <span class="KeyTerm1">rogers</span> painter of <a href="#c2-fig-0018">figure 2.11</a> was constructed from a gray-level image. For each point in a given frame, the <span class="KeyTerm1">rogers</span> painter determines the point in the image that is mapped to it under the frame coordinate map, and shades it accordingly. By allowing different types of painters, we are capitalizing on the abstract data idea discussed in section 2.1.3, where we argued that a rational-number representation could be anything at all that satisfies an appropriate condition. Here we're using the fact that a painter can be implemented in any way at all, so long as it draws something in the designated frame. Section 2.1.3 also showed how pairs could be implemented as functions. Painters are our second example of a functional representation for data.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0028"></a><a href="#c2-fn-0028a">28</a> The function <span class="KeyTerm1">rotate90</span> is a pure rotation only for square frames, because it also stretches and shrinks the image to fit into the rotated frame.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0029"></a><a href="#c2-fn-0029a">29</a> The diamond-shaped images in <a href="#c2-fig-0017">figures 2.10 and 2.11</a> were created with <span class="KeyTerm1">squash_inwards</span> applied to <span class="KeyTerm1">wave</span> and <span class="KeyTerm1">rogers</span>.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0030"></a><a href="#c2-fn-0030a">30</a> Section 3.3.4 describes one such language.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0031"></a><a href="#c2-fn-0031a">31</a> We can consider two strings to be “the same” if they consist of the same characters in the same order. Such a definition skirts a deep issue that we are not yet ready to address: the meaning of “sameness” in a programming language. We will return to this in chapter 3 (section 3.1.3).</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0032"></a><a href="#c2-fn-0032a">32</a> The original version of this book used the programming language Scheme, a dialect of Lisp.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0033"></a><a href="#c2-fn-0033a">33</a> If we want to be more formal, we can specify “consistent with the interpretations given above” to mean that the operations satisfy a collection of rules such as these:<ul style="list-style-type:disc">
<li>For any set <span class="KeyTerm1"><span class="KeyTerm1">S</span> </span>and any object <span class="KeyTerm1">x</span>, <span class="KeyTerm1">is_element_of_set(x, adjoin_set(x, S))</span> is true (informally: “Adjoining an object to a set produces a set that contains the object”).</li>
<li>For any sets <span class="KeyTerm1"><span class="KeyTerm1">S</span> </span>and <span class="KeyTerm1"><span class="KeyTerm1">T</span> </span>and any object <span class="KeyTerm1">x</span>, <span class="KeyTerm1">is_element_of_set(x, union_set(S, T))</span> is equal to <span class="KeyTerm1">is_element_of_set(x, S) || is_element_of_set(x, T)</span> (informally: “The elements of <span class="KeyTerm1">union_set(S, T)</span> are the elements that are in <span class="KeyTerm1"><span class="KeyTerm1">S</span> </span>or in <span class="KeyTerm1"><span class="KeyTerm1">T</span></span>”).</li>
<li>For any object <span class="KeyTerm1">x</span>, <span class="KeyTerm1">is_element_of_set(x, <b>null</b>)</span> is false (informally: “No object is an element of the empty set”).</li>
</ul></aside>
<aside class="noteEntry"><a id="c002_c2-fn-0034"></a><a href="#c2-fn-0034a">34</a> Halving the size of the problem at each step is the distinguishing characteristic of logarithmic growth, as we saw with the fast-exponentiation algorithm of section 1.2.4 and the half-interval search method of section 1.3.3.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0035"></a><a href="#c2-fn-0035a">35</a> We are representing sets in terms of trees, and trees in terms of lists—in effect, a data abstraction built upon a data abstraction. We can regard the functions <span class="KeyTerm1">entry</span>, <span class="KeyTerm1">left_branch</span>, <span class="KeyTerm1">right_branch</span>, and <span class="KeyTerm1">make_tree</span> as a way of isolating the abstraction of a “binary tree” from the particular way we might wish to represent such a tree in terms of list structure.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0036"></a><a href="#c2-fn-0036a">36</a> Examples of such structures include <i>B-trees</i> and <i>red-black trees</i>. There is a large literature on data structures devoted to this problem. See Cormen, Leiserson, Rivest, and Stein 2022.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0037"></a><a href="#c2-fn-0037a">37</a> Exercises 2.63–2.65 are due to Paul Hilfinger.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0038"></a><a href="#c2-fn-0038a">38</a> See Hamming 1980 for a discussion of the mathematical properties of Huffman codes.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0039"></a><a href="#c2-fn-0039a">39</a> In actual computational systems, rectangular form is preferable to polar form most of the time because of roundoff errors in conversion between rectangular and polar form. This is why the complex-number example is unrealistic. Nevertheless, it provides a clear illustration of the design of a system using generic operations and a good introduction to the more substantial systems to be developed later in this chapter.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0040"></a><a href="#c2-fn-0040a">40</a> The arctangent function referred to here, computed by JavaScript's <span class="KeyTerm1">math_atan2</span> function, is defined so as to take two arguments <i>y</i> and <i>x</i> and to return the angle whose tangent is <i>y</i>/<i>x</i>. The signs of the arguments determine the quadrant of the angle.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0041"></a><a href="#c2-fn-0041a">41</a> The name <span class="KeyTerm1">undefined</span> is predeclared in any JavaScript implementation and should not be used other than to refer to that primitive value.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0042"></a><a href="#c2-fn-0042a">42</a> We use the list <span class="KeyTerm1">list("rectangular")</span> rather than the string <span class="KeyTerm1">"rectangular"</span> to allow for the possibility of operations with multiple arguments, not all of the same type.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0043"></a><a href="#c2-fn-0043a">43</a> The type the constructors are installed under needn't be a list because a constructor is always used to make an object of one particular type.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0044"></a><a href="#c2-fn-0044a">44</a> The function <span class="KeyTerm1">apply_generic</span> uses the function <span class="KeyTerm1">apply_in_underlying_javascript</span> given in section 4.1.4 (footnote 18), which takes two arguments, a function and a list, and applies the function, using the elements in the list as arguments. For example,
<br/><span class="BS_Sp-text-1_FN">apply_in_underlying_javascript(sum_of_squares, list(1, 3))</span>
<br/>returns 10.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0045"></a><a href="#c2-fn-0045a">45</a> One limitation of this organization is it permits only generic functions of one argument.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0046"></a><a href="#c2-fn-0046a">46</a> We also have to supply an almost identical function to handle the types
<br/><span class="BS_Sp-text-1_FN">list("javascript_number", "complex").</span></aside>
<aside class="noteEntry"><a id="c002_c2-fn-0047"></a><a href="#c2-fn-0047a">47</a> See exercise 2.82 for generalizations.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0048"></a><a href="#c2-fn-0048a">48</a> If we are clever, we can usually get by with fewer than <i>n</i><sup>2</sup> coercion functions. For instance, if we know how to convert from type 1 to type 2 and from type 2 to type 3, then we can use this knowledge to convert from type 1 to type 3. This can greatly decrease the number of coercion functions we need to supply explicitly when we add a new type to the system. If we are willing to build the required amount of sophistication into our system, we can have it search the “graph” of relations among types and automatically generate those coercion functions that can be inferred from the ones that are supplied explicitly.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0049"></a><a href="#c2-fn-0049a">49</a> This statement, which also appears in the first edition of this book, is just as true now as it was when we wrote it in 1984. Developing a useful, general framework for expressing the relations among different types of entities (what philosophers call “ontology”) seems intractably difficult. The main difference between the confusion that existed in 1984 and the confusion that exists now is that now a variety of inadequate ontological theories have been embodied in a plethora of correspondingly inadequate programming languages. For example, much of the complexity of object-oriented programming languages—and the subtle and confusing differences among contemporary object-oriented languages—centers on the treatment of generic operations on interrelated types. Our own discussion of computational objects in chapter 3 avoids these issues entirely. Readers familiar with object-oriented programming will notice that we have much to say in chapter 3 about local state, but we do not even mention “classes” or “inheritance.” In fact, we suspect that these problems cannot be adequately addressed in terms of computer-language design alone, without also drawing on work in knowledge representation and automated reasoning.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0050"></a><a href="#c2-fn-0050a">50</a> A real number can be projected to an integer using the <span class="KeyTerm1">math_round</span> primitive, which returns the closest integer to its argument.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0051"></a><a href="#c2-fn-0051a">51</a> On the other hand, we will allow polynomials whose coefficients are themselves polynomials in other variables. This will give us essentially the same representational power as a full multivariate system, although it does lead to coercion problems, as discussed below.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0052"></a><a href="#c2-fn-0052a">52</a> For univariate polynomials, giving the value of a polynomial at a given set of points can be a particularly good representation. This makes polynomial arithmetic extremely simple. To obtain, for example, the sum of two polynomials represented in this way, we need only add the values of the polynomials at corresponding points. To transform back to a more familiar representation, we can use the Lagrange interpolation formula, which shows how to recover the coefficients of a polynomial of degree <i>n</i> given the values of the polynomial at <i>n</i> + 1 points.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0053"></a><a href="#c2-fn-0053a">53</a> This operation is very much like the ordered <span class="KeyTerm1">union_set</span> operation we developed in exercise 2.62. In fact, if we think of the terms of the polynomial as a set ordered according to the power of the indeterminate, then the program that produces the term list for a sum is almost identical to <span class="KeyTerm1">union_set</span>.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0054"></a><a href="#c2-fn-0054a">54</a> To make this work completely smoothly, we should also add to our generic arithmetic system the ability to coerce a “number” to a polynomial by regarding it as a polynomial of degree zero whose coefficient is the number. This is necessary if we are going to perform operations such as
<br/>[<i>x</i><sup>2</sup> + (<i>y</i> + 1)<i>x</i> + 5] + [<i>x</i><sup>2</sup> + 2<i>x</i> + 1]
<br/>which requires adding the coefficient <i>y</i> + 1 to the coefficient 2.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0055"></a><a href="#c2-fn-0055a">55</a> In these polynomial examples, we assume that we have implemented the generic arithmetic system using the type mechanism suggested in exercise 2.78. Thus, coefficients that are ordinary numbers will be represented as the numbers themselves rather than as pairs whose <span class="KeyTerm1">head</span> is the string <span class="KeyTerm1">"javascript_number"</span>.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0056"></a><a href="#c2-fn-0056a">56</a> Although we are assuming that term lists are ordered, we have implemented <span class="KeyTerm1">adjoin_term</span> to simply adjoin the new term to the front of the existing term list. We can get away with this so long as we guarantee that the functions (such as <span class="KeyTerm1">add_terms</span>) that use <span class="KeyTerm1">adjoin_term</span> always call it with a higher-order term than appears in the list. If we did not want to make such a guarantee, we could have implemented <span class="KeyTerm1">adjoin_term</span> to be similar to the <span class="KeyTerm1">adjoin_set</span> constructor for the ordered-list representation of sets (exercise 2.61).</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0057"></a><a href="#c2-fn-0057a">57</a> The fact that Euclid's Algorithm works for polynomials is formalized in algebra by saying that polynomials form a kind of algebraic domain called a <i>Euclidean ring</i>. A Euclidean ring is a domain that admits addition, subtraction, and commutative multiplication, together with a way of assigning to each element <i>x</i> of the ring a positive integer “measure” <i>m</i>(<i>x</i>) with the properties that <i>m</i>(<i>xy</i>) <i>m</i>(<i>x</i>) for any nonzero <i>x</i> and <i>y</i> and that, given any <i>x</i> and <i>y</i>, there exists a <i>q</i> such that <i>y</i> = <i>qx</i> + <i>r</i> and either <i>r</i> = 0 or <i>m</i>(<i>r</i>) &lt; <i>m</i>(<i>x</i>). From an abstract point of view, this is what is needed to prove that Euclid's Algorithm works. For the domain of integers, the measure <i>m</i> of an integer is the absolute value of the integer itself. For the domain of polynomials, the measure of a polynomial is its degree.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0058"></a><a href="#c2-fn-0058a">58</a> In JavaScript, division of integers can produce limited-precision decimal numbers, and thus we may fail to get a valid divisor.</aside>
<aside class="noteEntry"><a id="c002_c2-fn-0059"></a><a href="#c2-fn-0059a">59</a> One extremely efficient and elegant method for computing polynomial GCDs was discovered by Richard Zippel (1979). The method is a probabilistic algorithm, as is the fast test for primality that we discussed in chapter 1. Zippel's book (1993) describes this method, together with other ways to compute polynomial GCDs.</aside>
</section>
</section>
</body><body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<h1><a id="c003_c3-title-0001"></a><span class="chapterNumber">3</span><br/><span class="chapterTitle">Modularity, Objects, and State</span></h1>
</header>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c003_c3-para-0001"></a><i>Mεταβάλλον αναπαύεται</i></p>
<p class="quote-epigraphparafirst"><a id="c003_c3-para-0002"></a>(Even while it changes, it stands still.)</p>
<p class="quote-epigraphsource">—Heraclitus</p></blockquote>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c003_c3-para-0003"></a>Plus ça change, plus c’est la même chose.</p>
<p class="quote-epigraphsource">—Alphonse Karr</p></blockquote>
<p class="paraaftertitle"><a id="c003_c3-para-0004"></a>The preceding chapters introduced the basic elements from which programs are made. We saw how primitive functions and primitive data are combined to construct compound entities, and we learned that abstraction is vital in helping us to cope with the complexity of large systems. But these tools are not sufficient for designing programs. Effective program synthesis also requires organizational principles that can guide us in formulating the overall design of a program. In particular, we need strategies to help us structure large systems so that they will be <i>modular</i>, that is, so that they can be divided “naturally” into coherent parts that can be separately developed and maintained.</p>
<p><a id="c003_c3-para-0005"></a>One powerful design strategy, which is particularly appropriate to the construction of programs for modeling physical systems, is to base the structure of our programs on the structure of the system being modeled. For each object in the system, we construct a corresponding computational object. For each system action, we define a symbolic operation in our computational model. Our hope in using this strategy is that extending the model to accommodate new objects or new actions will require no strategic changes to the program, only the addition of the new symbolic analogs of those objects or actions. If we have been successful in our system organization, then to add a new feature or debug an old one we will have to work on only a localized part of the system.</p>
<p><a id="c003_c3-para-0006"></a>To a large extent, then, the way we organize a large program is dictated by our perception of the system to be modeled. In this chapter we will investigate two prominent organizational strategies arising from two rather different “world views” of the structure of systems. The first organizational strategy concentrates on <i>objects</i>, viewing a large system as a collection of distinct objects whose behaviors may change over time. An alternative organizational strategy concentrates on the <i>streams</i> of information that flow in the system, much as an electrical engineer views a signal-processing system.</p>
<p><a id="c003_c3-para-0007"></a>Both the object-based approach and the stream-processing approach raise significant linguistic issues in programming. With objects, we must be concerned with how a computational object can change and yet maintain its identity. This will force us to abandon our old substitution model of computation (section 1.1.5) in favor of a more mechanistic but less theoretically tractable <i>environment model</i> of computation. The difficulties of dealing with objects, change, and identity are a fundamental consequence of the need to grapple with time in our computational models. These difficulties become even greater when we allow the possibility of concurrent execution of programs. The stream approach can be most fully exploited when we decouple simulated time in our model from the order of the events that take place in the computer during evaluation. We will accomplish this using a technique known as <i>delayed evaluation</i>.</p>
<section><a id="c003_c3-title-0002"></a>
<section>
<h2><a id="c003_c3-sec-0002"></a><span>3.1</span> <a id="c003_c3-title-0003"></a>Assignment and Local State</h2>
<p class="paraaftertitle"><a id="c003_c3-para-0008"></a>We ordinarily view the world as populated by independent objects, each of which has a state that changes over time. An object is said to “have state” if its behavior is influenced by its history. A bank account, for example, has state in that the answer to the question “Can I withdraw $100?” depends upon the history of deposit and withdrawal transactions. We can characterize an object's state by one or more <i>state variables</i>, which among them maintain enough information about history to determine the object's current behavior. In a simple banking system, we could characterize the state of an account by a current balance rather than by remembering the entire history of account transactions.</p>
<p><a id="c003_c3-para-0009"></a>In a system composed of many objects, the objects are rarely completely independent. Each may influence the states of others through interactions, which serve to couple the state variables of one object to those of other objects. Indeed, the view that a system is composed of separate objects is most useful when the state variables of the system can be grouped into closely coupled subsystems that are only loosely coupled to other subsystems.</p>
<p><a id="c003_c3-para-0010"></a>This view of a system can be a powerful framework for organizing computational models of the system. For such a model to be modular, it should be decomposed into computational objects that model the actual objects in the system. Each computational object must have its own <i>local state variables</i> describing the actual object's state. Since the states of objects in the system being modeled change over time, the state variables of the corresponding computational objects must also change. If we choose to model the flow of time in the system by the elapsed time in the computer, then we must have a way to construct computational objects whose behaviors change as our programs run. In particular, if we wish to model state variables by ordinary symbolic names in the programming language, then the language must provide an <i>assignment operation</i> to enable us to change the value associated with a name.</p>
<section>
<h3><a id="c003_c3-sec-0003"></a><span>3.1.1</span> <a id="c003_c3-title-0004"></a>Local State Variables</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0011"></a>To illustrate what we mean by having a computational object with time-varying state, let us model the situation of withdrawing money from a bank account. We will do this using a function <span class="KeyTerm1">withdraw</span>, which takes as argument an <span class="KeyTerm1">amount</span> to be withdrawn. If there is enough money in the account to accommodate the withdrawal, then <span class="KeyTerm1">withdraw</span> should return the balance remaining after the withdrawal. Otherwise, <span class="KeyTerm1">withdraw</span> should return the message <i>Insufficient funds.</i> For example, if we begin</p>
<p class="paracontinue"><a id="c003_c3-para-0012"></a>with $100 in the account, we should obtain the following sequence of responses using <span class="KeyTerm1">withdraw</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0013"></a>withdraw(25);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0014"></a><i>75</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0015"></a>withdraw(25);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0016"></a><i>50</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0017"></a>withdraw(60);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0018"></a><i>"Insufficient funds"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0019"></a>withdraw(15);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0020"></a><i>35</i></p>
<p class="paracontinue"><a id="c003_c3-para-0021"></a>Observe that the expression <span class="KeyTerm1">withdraw(25)</span>, evaluated twice, yields different values. This is a new kind of behavior for a function. Until now, all our JavaScript functions could be viewed as specifications for computing mathematical functions. A call to a function computed the value of the function applied to the given arguments, and two calls to the same function with the same arguments always produced the same result.<a id="c003_c3-fn-0001a"></a><a href="#c3-fn-0001"><sup>1</sup></a></p>
<p><a id="c003_c3-para-0022"></a>So far, all our names have been <i>immutable</i>. When a function was applied, the values that its parameters referred to never changed, and once a declaration was evaluated, the declared name never changed its value. To implement functions like <span class="KeyTerm1">withdraw</span>, we introduce <i>variable declarations</i>, which use the keyword <span class="KeyTerm1"><b>let</b></span>, in addition to constant declarations, which use the keyword <span class="KeyTerm1"><b>const</b></span>. We can declare a variable <span class="KeyTerm1">balance</span> to indicate the balance of money in the account and define <span class="KeyTerm1">withdraw</span> as a function that accesses <span class="KeyTerm1">balance</span>. The <span class="KeyTerm1">withdraw</span> function checks to see if <span class="KeyTerm1">balance</span> is at least as large as the requested <span class="KeyTerm1">amount</span>. If so, <span class="KeyTerm1">withdraw</span> decrements <span class="KeyTerm1">balance</span> by <span class="KeyTerm1">amount</span> and returns the new value of <span class="KeyTerm1">balance</span>. Otherwise, <span class="KeyTerm1">withdraw</span> returns the <i>Insufficient funds</i> message. Here are the declarations of <span class="KeyTerm1">balance</span> and <span class="KeyTerm1">withdraw</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0023"></a><b>let</b> balance = 100;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0024"></a><b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0025"></a> <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0026"></a>        balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0027"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0028"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0029"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0030"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0031"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0032"></a>Decrementing <span class="KeyTerm1">balance</span> is accomplished by the expression statement</p>
<p class="Sp-text-1"><a id="c003_c3-para-0033"></a>balance = balance - amount;</p>
<p class="paracontinue"><a id="c003_c3-para-0034"></a>The syntax of <i>assignment</i> expressions is</p>
<p class="Sp-text-1"><a id="c003_c3-para-0035"></a><span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>new</i>-<i>value</i></span></p>
<p class="paracontinue"><a id="c003_c3-para-0036"></a>Here <i>name</i> has been declared with <span class="KeyTerm1"><b>let</b></span> or as a function parameter and <i>new</i>-<i>value</i> is any expression. The assignment changes <i>name</i> so that its value is the result obtained by evaluating <i>new</i>-<i>value</i>. In the case at hand, we are changing <span class="KeyTerm1">balance</span> so that its new value will be the result of subtracting <span class="KeyTerm1">amount</span> from the previous value of <span class="KeyTerm1">balance</span>.<a id="c003_c3-fn-0002a"></a><a href="#c3-fn-0002"><sup>2</sup></a></p>
<p><a id="c003_c3-para-0037"></a>The function <span class="KeyTerm1">withdraw</span> also uses a <i>sequence of statements</i> to cause two statements to be evaluated in the case where the <span class="KeyTerm1"><b>if</b></span> test is true: first decrementing <span class="KeyTerm1">balance</span> and then returning the value of <span class="KeyTerm1">balance</span>. In general, executing a sequence</p>
<p class="Sp-text-1"><a id="c003_c3-para-0038"></a><span class="KeyTerm2"><i>stmt</i><sub>1</sub></span> <span class="KeyTerm2"><i>stmt</i><sub>2</sub></span> <i>. . .</i><span class="KeyTerm2"><i>stmt<sub>n</sub></i></span></p>
<p class="paracontinue"><a id="c003_c3-para-0039"></a>causes the statements <i>stmt</i><sub>1</sub> through <i>stmt<sub>n</sub></i> to be evaluated in sequence.<a id="c003_c3-fn-0003a"></a><a href="#c3-fn-0003"><sup>3</sup></a></p>
<p><a id="c003_c3-para-0040"></a>Although <span class="KeyTerm1">withdraw</span> works as desired, the variable <span class="KeyTerm1">balance</span> presents a problem. As specified above, <span class="KeyTerm1">balance</span> is a name defined in the program environment and is freely accessible to be examined or modified by any function. It would be much better if we could somehow make <span class="KeyTerm1">balance</span> internal to <span class="KeyTerm1">withdraw</span>, so that <span class="KeyTerm1">withdraw</span> would be the only function that could access <span class="KeyTerm1">balance</span> directly and any other function could access <span class="KeyTerm1">balance</span> only indirectly (through calls to <span class="KeyTerm1">withdraw</span>). This would more accurately model the notion that <span class="KeyTerm1">balance</span> is a local state variable used by <span class="KeyTerm1">withdraw</span> to keep track of the state of the account.</p>
<p><a id="c003_c3-para-0047"></a>We can make <span class="KeyTerm1">balance</span> internal to <span class="KeyTerm1">withdraw</span> by rewriting the definition as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0048"></a><b>function</b> make_withdraw_balance_100() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0049"></a> <b>let</b> balance = 100;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0050"></a> <b>return</b> amount =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0051"></a> <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0052"></a>                   balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0053"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0054"></a>               } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0055"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0056"></a>               }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0057"></a>           };</p>
<p class="Sp-text-1"><a id="c003_c3-para-0058"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0059"></a><b>const</b> new_withdraw = make_withdraw_balance_100();</p>
<p class="paracontinue"><a id="c003_c3-para-0060"></a>What we have done here is use <span class="KeyTerm1"><b>let</b></span> to establish an environment with a local variable <span class="KeyTerm1">balance</span>, bound to the initial value 100. Within this local environment, we use a lambda expression<a id="c003_c3-fn-0004a"></a><a href="#c3-fn-0004"><sup>4</sup></a> to create a function that takes <span class="KeyTerm1">amount</span> as an argument and behaves like our previous <span class="KeyTerm1">withdraw</span> function. This function—returned as the result of evaluating the body of the <span class="KeyTerm1">make_withdraw_balance_100</span> function—behaves in precisely the same way as <span class="KeyTerm1">withdraw</span>, but its variable <span class="KeyTerm1">balance</span> is not accessible by any other function.<a id="c003_c3-fn-0005a"></a><a href="#c3-fn-0005"><sup>5</sup></a></p>
<p><a id="c003_c3-para-0061"></a>Combining assignments with variable declarations is the general programming technique we will use for constructing computational objects with local state. Unfortunately, using this technique raises a serious problem: When we first introduced functions, we also introduced the substitution model of evaluation (section 1.1.5) to provide an interpretation of what function application means. We said that applying a function whose body is a return statement should be interpreted as evaluating the return expression of the function with the parameters replaced by their values. For functions with more complex bodies, we need to evaluate the whole body with the parameters replaced by their values. The trouble is that, as soon as we introduce assignment into our language, substitution is no longer an adequate model of function application. (We will see why this is so in section 3.1.3.) As a consequence, we technically have at this point no way to understand why the <span class="KeyTerm1">new_withdraw</span> function behaves as claimed above. In order to really understand a function such as <span class="KeyTerm1">new_withdraw</span>, we will need to develop a new model of function application. In section 3.2 we will introduce such a model, together with an explanation of assignments and variable declarations. First, however, we examine some variations on the theme established by <span class="KeyTerm1">new_withdraw</span>.</p>
<p><a id="c003_c3-para-0063"></a>Parameters of functions as well as names declared with <span class="KeyTerm1"><b>let</b></span> are variables. The following function, <span class="KeyTerm1">make_withdraw</span>, creates “withdrawal processors.” The parameter <span class="KeyTerm1">balance</span> in <span class="KeyTerm1">make_withdraw</span> specifies the initial amount of money in the account.<a id="c003_c3-fn-0006a"></a><a href="#c3-fn-0006"><sup>6</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-0064"></a><b>function</b> make_withdraw(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0065"></a> <b>return</b> amount =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0066"></a> <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0067"></a>                   balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0068"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0069"></a>               } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0070"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0071"></a>               }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0072"></a>           };</p>
<p class="Sp-text-1"><a id="c003_c3-para-0073"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0074"></a>The function <span class="KeyTerm1">make_withdraw</span> can be used as follows to create two objects <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0075"></a><b>const</b> W1 = make_withdraw(100);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0076"></a><b>const</b> W2 = make_withdraw(100);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0077"></a>W1(50);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0078"></a><i>50</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0079"></a>W2(70);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0080"></a><i>30</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0081"></a>W2(40);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0082"></a><i>"Insufficient funds"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0083"></a>W1(40);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0084"></a><i>10</i></p>
<p class="paracontinue"><a id="c003_c3-para-0085"></a>Observe that <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> are completely independent objects, each with its own local state variable <span class="KeyTerm1">balance</span>. Withdrawals from one do not affect the other.</p>
<p><a id="c003_c3-para-0086"></a>We can also create objects that handle deposits as well as withdrawals, and thus we can represent simple bank accounts. Here is a function that returns a “bankaccount object” with a specified initial balance:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0087"></a><b>function</b> make_account(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0088"></a> <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0089"></a> <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0090"></a>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0091"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0092"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0093"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0094"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0095"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0096"></a> <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0097"></a>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0098"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0099"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0100"></a> <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0101"></a> <b>return</b> m === "withdraw"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0102"></a>               ? withdraw</p>
<p class="Sp-text-1"><a id="c003_c3-para-0103"></a>               : m === "deposit"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0104"></a>               ? deposit</p>
<p class="Sp-text-1"><a id="c003_c3-para-0105"></a>               : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0106"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0107"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0108"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0109"></a>Each call to <span class="KeyTerm1">make_account</span> sets up an environment with a local state variable <span class="KeyTerm1">balance</span>. Within this environment, <span class="KeyTerm1">make_account</span> defines functions <span class="KeyTerm1">deposit</span> and <span class="KeyTerm1">withdraw</span> that access <span class="KeyTerm1">balance</span> and an additional function <span class="KeyTerm1">dispatch</span> that takes a “message” as input and returns one of the two local functions. The <span class="KeyTerm1">dispatch</span> function itself is returned as the value that represents the bank-account object. This is precisely the <i>message-passing</i> style of programming that we saw in section 2.4.3, although here we are using it in conjunction with the ability to modify local variables.</p>
<p><a id="c003_c3-para-0110"></a>The function <span class="KeyTerm1">make_account</span> can be used as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0111"></a><b>const</b> acc = make_account(100);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0112"></a>acc("withdraw")(50);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0113"></a><i>50</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0114"></a>acc("withdraw")(60);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0115"></a><i>"Insufficient funds"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0116"></a>acc("deposit")(40);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0117"></a><i>90</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0118"></a>acc("withdraw")(60);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0119"></a><i>30</i></p>
<p class="paracontinue"><a id="c003_c3-para-0120"></a>Each call to <span class="KeyTerm1">acc</span> returns the locally defined <span class="KeyTerm1">deposit</span> or <span class="KeyTerm1">withdraw</span> function, which is then applied to the specified <span class="KeyTerm1">amount</span>. As was the case with <span class="KeyTerm1">make_withdraw</span>, another call to <span class="KeyTerm1">make_account</span></p>
<p class="Sp-text-1"><a id="c003_c3-para-0121"></a><b>const</b> acc2 = make_account(100);</p>
<p class="paracontinue"><a id="c003_c3-para-0122"></a>will produce a completely separate account object, which maintains its own local <span class="KeyTerm1">balance</span>.</p>
<section>
<h5><a id="c003_c3-sec-0004"></a><a id="c003_c3-title-0005"></a>Exercise 3.1</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0124"></a>An <i>accumulator</i> is a function that is called repeatedly with a single numeric argument and accumulates its arguments into a sum. Each time it is called, it returns the currently accumulated sum. Write a function <span class="KeyTerm1">make_accumulator</span> that generates accumulators, each maintaining an independent sum. The input to <span class="KeyTerm1">make_accumulator</span> should specify the initial value of the sum; for example</p>
<p class="Sp-text-1"><a id="c003_c3-para-0125"></a><b>const</b> a = make_accumulator(5); </p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0126"></a>a(10);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0127"></a><i>15</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0128"></a>a(10);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0129"></a><i>25</i></p>
</section>
<section>
<h5><a id="c003_c3-sec-0005"></a><a id="c003_c3-title-0006"></a>Exercise 3.2</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0130"></a>In software-testing applications, it is useful to be able to count the number of times a given function is called during the course of a computation. Write a function <span class="KeyTerm1">make_monitored</span> that takes as input a function, <span class="KeyTerm1">f</span>, that itself takes one input. The result returned by <span class="KeyTerm1">make_monitored</span> is a third function, say <span class="KeyTerm1">mf</span>, that keeps track of the number of times it has been called by maintaining an internal counter. If the input to <span class="KeyTerm1">mf</span> is the string <span class="KeyTerm1">"how many calls"</span>, then <span class="KeyTerm1">mf</span> returns the value of the counter. If the input is the string <span class="KeyTerm1">"reset count"</span>, then <span class="KeyTerm1">mf</span> resets the counter to zero. For any other input, <span class="KeyTerm1">mf</span> returns the result of calling <span class="KeyTerm1">f</span> on that input and increments the counter. For instance, we could make a monitored version of the <span class="KeyTerm1">sqrt</span> function:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0131"></a><b>const</b> s = make_monitored(math_sqrt);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0132"></a>s(100);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0133"></a><i>10</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0134"></a>s("how many calls");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0135"></a><i>1</i></p>
</section>
<section>
<h5><a id="c003_c3-sec-0006"></a><a id="c003_c3-title-0007"></a>Exercise 3.3</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0136"></a>Modify the <span class="KeyTerm1">make_account</span> function so that it creates password-protected accounts. That is, <span class="KeyTerm1">make_account</span> should take a string as an additional argument, as in</p>
<p class="Sp-text-1"><a id="c003_c3-para-0137"></a><b>const</b> acc = make_account(100, "secret password");</p>
<p class="paracontinue"><a id="c003_c3-para-0138"></a>The resulting account object should process a request only if it is accompanied by the password with which the account was created, and should otherwise return a complaint:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0139"></a>acc("secret password", "withdraw")(40);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0140"></a><i>60</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0141"></a>acc("some other password", "deposit")(40);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0142"></a><i>"Incorrect password"</i></p>
</section>
<section>
<h5><a id="c003_c3-sec-0007"></a><a id="c003_c3-title-0008"></a>Exercise 3.4</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0143"></a>Modify the <span class="KeyTerm1">make_account</span> function of exercise 3.3 by adding another local state variable so that, if an account is accessed more than seven consecutive times with an incorrect password, it invokes the function <span class="KeyTerm1">call_the_cops</span>.</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0008"></a><span>3.1.2</span> <a id="c003_c3-title-0009"></a>The Benefits of Introducing Assignment</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0144"></a>As we shall see, introducing assignment into our programming language leads us into a thicket of difficult conceptual issues. Nevertheless, viewing systems as collections of objects with local state is a powerful technique for maintaining a modular design. As a simple example, consider the design of a function <span class="KeyTerm1">rand</span> that, whenever it is called, returns an integer chosen at random.</p>
<p><a id="c003_c3-para-0145"></a>It is not at all clear what is meant by “chosen at random.” What we presumably want is for successive calls to <span class="KeyTerm1">rand</span> to produce a sequence of numbers that has statistical properties of uniform distribution. We will not discuss methods for generating suitable sequences here. Rather, let us assume that we have a function <span class="KeyTerm1">rand_update</span> that has the property that if we start with a given number <i>x</i><sub>1</sub> and form</p>
<p class="Sp-text-1"><a id="c003_c3-para-0146"></a><span class="KeyTerm2"><i>x</i><sub>2</sub></span> = rand_update(<span class="KeyTerm2"><i>x</i><sub>1</sub></span>);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0147"></a><span class="KeyTerm2"><i>x</i><sub>3</sub></span> = rand_update(<span class="KeyTerm2"><i>x</i><sub>2</sub></span>);</p>
<p class="paracontinue"><a id="c003_c3-para-0148"></a>then the sequence of values <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>, <span class="KeyTerm1"><i>. . .</i></span>, will have the desired statistical properties.<a id="c003_c3-fn-0007a"></a><a href="#c3-fn-0007"><sup>7</sup></a></p>
<p><a id="c003_c3-para-5148"></a>We can implement <span class="KeyTerm1">rand</span> as a function with a local state variable <span class="KeyTerm1">x</span> that is initialized to some fixed value <span class="KeyTerm1">random_init</span>. Each call to <span class="KeyTerm1">rand</span> computes <span class="KeyTerm1">rand_update</span> of the current value of <span class="KeyTerm1">x</span>, returns this as the random number, and also stores this as the new value of <span class="KeyTerm1">x</span>.</p>
<p class="Sp-text-1"><a id="c003_c3-para-0149"></a><b>function</b> make_rand() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0150"></a> <b>let</b> x = random_init;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0151"></a> <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0152"></a>              x = rand_update(x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0153"></a> <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0154"></a>           };</p>
<p class="Sp-text-1"><a id="c003_c3-para-0155"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0156"></a><b>const</b> rand = make_rand();</p>
<p><a id="c003_c3-para-0157"></a>Of course, we could generate the same sequence of random numbers without using assignment by simply calling <span class="KeyTerm1">rand_update</span> directly. However, this would mean that any part of our program that used random numbers would have to explicitly remember the current value of <span class="KeyTerm1">x</span> to be passed as an argument to <span class="KeyTerm1">rand_update</span>. To realize what an annoyance this would be, consider using random numbers to implement a technique called <i>Monte Carlo simulation</i>.</p>
<p><a id="c003_c3-para-0158"></a>The Monte Carlo method consists of choosing sample experiments at random from a large set and then making deductions on the basis of the probabilities estimated from tabulating the results of those experiments. For example, we can approximate <i>π</i> using the fact that 6/<i>π</i><sup>2</sup> is the probability that two integers chosen at random will have no factors in common; that is, that their greatest common divisor will be 1.<a id="c003_c3-fn-0008a"></a><a href="#c3-fn-0008"><sup>8</sup></a> To obtain the approximation to <i>π</i>, we perform a large number of experiments. In each experiment we choose two integers at random and perform a test to see if their GCD is 1. The fraction of times that the test is passed gives us our estimate of 6/<i>π</i><sup>2</sup>, and from this we obtain our approximation to <i>π</i>.</p>
<p><a id="c003_c3-para-0159"></a>The heart of our program is a function <span class="KeyTerm1">monte_carlo</span>, which takes as arguments the number of times to try an experiment, together with the experiment, represented as a no-argument function that will return either true or false each time it is run. The function <span class="KeyTerm1">monte_carlo</span> runs the experiment for the designated number of trials and returns a number telling the fraction of the trials in which the experiment was found to be true.</p>
<p class="Sp-text-1"><a id="c003_c3-para-0160"></a><b>function</b> estimate_pi(trials) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0161"></a> <b>return</b> math_sqrt(6 / monte_carlo(trials, dirichlet_test));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0162"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0163"></a><b>function</b> dirichlet_test() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0164"></a> <b>return</b> gcd(rand(), rand()) === 1;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0165"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0166"></a><b>function</b> monte_carlo(trials, experiment) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0167"></a> <b>function</b> iter(trials_remaining, trials_passed) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0168"></a> <b>return</b> trials_remaining === 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0169"></a>               ? trials_passed / trials</p>
<p class="Sp-text-1"><a id="c003_c3-para-0170"></a>               : experiment()</p>
<p class="Sp-text-1"><a id="c003_c3-para-0171"></a>               ? iter(trials_remaining - 1, trials_passed + 1)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0172"></a>               : iter(trials_remaining - 1, trials_passed);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0173"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0174"></a> <b>return</b> iter(trials, 0);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0175"></a>}</p>
<p><a id="c003_c3-para-0176"></a>Now let us try the same computation using <span class="KeyTerm1">rand_update</span> directly rather than <span class="KeyTerm1">rand</span>, the way we would be forced to proceed if we did not use assignment to model local state:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0177"></a><b>function</b> estimate_pi(trials) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0178"></a> <b>return</b> math_sqrt(6 / random_gcd_test(trials, random_init));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0179"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0180"></a><b>function</b> random_gcd_test(trials, initial_x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0181"></a> <b>function</b> iter(trials_remaining, trials_passed, x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0182"></a> <b>const</b> x1 = rand_update(x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0183"></a> <b>const</b> x2 = rand_update(x1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0184"></a> <b>return</b> trials_remaining === 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0185"></a>               ? trials_passed / trials</p>
<p class="Sp-text-1"><a id="c003_c3-para-0186"></a>               : gcd(x1, x2) === 1</p>
<p class="Sp-text-1"><a id="c003_c3-para-0187"></a>               ? iter(trials_remaining - 1, trials_passed + 1, x2)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0188"></a>               : iter(trials_remaining - 1, trials_passed, x2);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0189"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0190"></a> <b>return</b> iter(trials, 0, initial_x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0191"></a>}</p>
<p><a id="c003_c3-para-0192"></a>While the program is still simple, it betrays some painful breaches of modularity. In our first version of the program, using <span class="KeyTerm1">rand</span>, we can express the Monte Carlo method directly as a general <span class="KeyTerm1">monte_carlo</span> function that takes as an argument an arbitrary <span class="KeyTerm1">experiment</span> function. In our second version of the program, with no local state for the random-number generator, <span class="KeyTerm1">random_gcd_test</span> must explicitly manipulate the random numbers <span class="KeyTerm1">x1</span> and <span class="KeyTerm1">x2</span> and recycle <span class="KeyTerm1">x2</span> through the iterative loop as the new input to <span class="KeyTerm1">rand_update</span>. This explicit handling of the random numbers intertwines the structure of accumulating test results with the fact that our particular experiment uses two random numbers, whereas other Monte Carlo experiments might use one random number or three. Even the top-level function <span class="KeyTerm1">estimate_pi</span> has to be concerned with supplying an initial random number. The fact that the random-number generator's insides are leaking out into other parts of the program makes it difficult for us to isolate the Monte Carlo idea so that it can be applied to other tasks. In the first version of the program, assignment encapsulates the state of the random-number generator within the <span class="KeyTerm1">rand</span> function, so that the details of random-number generation remain independent of the rest of the program.</p>
<p><a id="c003_c3-para-0193"></a>The general phenomenon illustrated by the Monte Carlo example is this: From the point of view of one part of a complex process, the other parts appear to change with time. They have hidden time-varying local state. If we wish to write computer programs whose structure reflects this decomposition, we make computational objects (such as bank accounts and random-number generators) whose behavior changes with time. We model state with local state variables, and we model the changes of state with assignments to those variables.</p>
<p><a id="c003_c3-para-0194"></a>It is tempting to conclude this discussion by saying that, by introducing assignment and the technique of hiding state in local variables, we are able to structure systems in a more modular fashion than if all state had to be manipulated explicitly, by passing additional parameters. Unfortunately, as we shall see, the story is not so simple.</p>
<section>
<h5><a id="c003_c3-sec-0009"></a><a id="c003_c3-title-0010"></a>Exercise 3.5</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0195"></a><i>Monte Carlo integration</i> is a method of estimating definite integrals by means of Monte Carlo simulation. Consider computing the area of a region of space described by a predicate <i>P</i>(<i>x</i>, <i>y</i>) that is true for points (<i>x</i>, <i>y</i>) in the region and false for points not in the region. For example, the region contained within a circle of radius 3 centered at (5, 7) is described by the predicate that tests whether (<i>x</i> – 5)<sup>2</sup> + (<i>y</i> – 7)<sup>2</sup> 3<sup>2</sup>. To estimate the area of the region described by such a predicate, begin by choosing a rectangle that contains the region. For example, a rectangle with diagonally opposite corners at (2, 4) and (8, 10) contains the circle above. The desired integral is the area of that portion of the rectangle that lies in the region. We can estimate the integral by picking, at random, points (<i>x</i>, <i>y</i>) that lie in the rectangle, and testing <i>P</i>(<i>x</i>, <i>y</i>) for each point to determine whether the point lies in the region. If we try this with many points, then the fraction of points that fall in the region should give an estimate of the proportion of the rectangle that lies in the region. Hence, multiplying this fraction by the area of the entire rectangle should produce an estimate of the integral.</p>
<p><a id="c003_c3-para-0196"></a>Implement Monte Carlo integration as a function estimate_integral that takes as arguments a predicate P, upper and lower bounds <span class="KeyTerm1">x1</span>, <span class="KeyTerm1">x2</span>, <span class="KeyTerm1">y1</span>, and <span class="KeyTerm1">y2</span> for the rectangle, and the number of trials to perform in order to produce the estimate. Your function should use the same <span class="KeyTerm1">monte_carlo</span> function that was used above to estimate <i>π</i>. Use your <span class="KeyTerm1">estimate_integral</span> to produce an estimate of <i>π</i> by measuring the area of a unit circle.</p>
<p><a id="c003_c3-para-0197"></a>You will find it useful to have a function that returns a number chosen at random from a given range. The following random_in_range function implements this in terms of the math_random function used in section 1.2.6, which returns a nonnegative number less than 1.</p>
<p class="Sp-text-1"><a id="c003_c3-para-0198"></a><b>function</b> random_in_range(low, high) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0199"></a> <b>const</b> range = high - low;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0200"></a> <b>return</b> low + math_random() * range;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0201"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0010"></a><a id="c003_c3-title-0011"></a>Exercise 3.6</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0202"></a>It is useful to be able to reset a random-number generator to produce a sequence starting from a given value. Design a new rand function that is called with an argument that is either the string "<span class="KeyTerm1">generate</span>" or the string "<span class="KeyTerm1">reset</span>" and behaves as follows: rand("<span class="KeyTerm1">generate</span>") produces a new random number; rand("<span class="KeyTerm1">reset</span>")(<i>new</i>-<i>value</i>) resets the internal state variable to the designated <i>new</i>-<i>value</i>. Thus, by resetting the state, one can generate repeatable sequences. These are very handy to have when testing and debugging programs that use random numbers.</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0011"></a><span>3.1.3</span> <a id="c003_c3-title-0012"></a>The Costs of Introducing Assignment</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0203"></a>As we have seen, assignment enables us to model objects that have local state. However, this advantage comes at a price. Our programming language can no longer be interpreted in terms of the substitution model of function application that we introduced in section 1.1.5. Moreover, no simple model with “nice” mathematical properties can be an adequate framework for dealing with objects and assignment in programming languages.</p>
<p><a id="c003_c3-para-0204"></a>So long as we do not use assignments, two evaluations of the same function with the same arguments will produce the same result, so that functions can be viewed as computing mathematical functions. Programming without any use of assignments, as we did throughout the first two chapters of this book, is accordingly known as <i>functional programming</i>.</p>
<p><a id="c003_c3-para-0205"></a>To understand how assignment complicates matters, consider a simplified version of the <span class="KeyTerm1">make_withdraw</span> function of section 3.1.1 that does not bother to check for an insufficient amount:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0206"></a><b>function</b> make_simplified_withdraw(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0207"></a> <b>return</b> amount =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0208"></a>               balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0209"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0210"></a>           };</p>
<p class="Sp-text-1"><a id="c003_c3-para-0211"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0212"></a><b>const</b> W = make_simplified_withdraw(25);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0213"></a>W(20);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0214"></a><i>5</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0215"></a>W(10);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0216"></a><i>-5</i></p>
<p class="paracontinue"><a id="c003_c3-para-0217"></a>Compare this function with the following <span class="KeyTerm1">make_decrementer</span> function, which does not use assignment:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0218"></a><b>function</b> make_decrementer(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0219"></a> <b>return</b> amount =&gt; balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0220"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0221"></a>The function <span class="KeyTerm1">make_decrementer</span> returns a function that subtracts its input from a designated amount <span class="KeyTerm1">balance</span>, but there is no accumulated effect over successive calls, as with <span class="KeyTerm1">make_simplified_withdraw</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0222"></a><b>const</b> D = make_decrementer(25);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0223"></a>D(20);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0224"></a><i>5</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0225"></a>D(10);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0226"></a><i>15</i></p>
<p class="paracontinue"><a id="c003_c3-para-0227"></a>We can use the substitution model to explain how <span class="KeyTerm1">make_decrementer</span> works. For instance, let us analyze the evaluation of the expression</p>
<p class="Sp-text-1"><a id="c003_c3-para-0228"></a>make_decrementer(25)(20)</p>
<p class="paracontinue"><a id="c003_c3-para-0229"></a>We first simplify the function expression of the application by substituting 25 for <span class="KeyTerm1">balance</span> in the body of <span class="KeyTerm1">make_decrementer</span>. This reduces the expression to</p>
<p class="Sp-text-1"><a id="c003_c3-para-0230"></a>(amount =&gt; 25 - amount)(20)</p>
<p class="paracontinue"><a id="c003_c3-para-0231"></a>Now we apply the function by substituting 20 for <span class="KeyTerm1">amount</span> in the body of the lambda expression:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0232"></a>25 - 20</p>
<p class="paracontinue"><a id="c003_c3-para-0233"></a>The final answer is 5.</p>
<p><a id="c003_c3-para-0234"></a>Observe, however, what happens if we attempt a similar substitution analysis with <span class="KeyTerm1">make_simplified_withdraw</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0235"></a>make_simplified_withdraw(25)(20)</p>
<p class="paracontinue"><a id="c003_c3-para-0236"></a>We first simplify the function expression by substituting 25 for <span class="KeyTerm1">balance</span> in the body of <span class="KeyTerm1">make_simplified_withdraw</span>. This reduces the expression to<a id="c003_c3-fn-0009a"></a><a href="#c3-fn-0009"><sup>9</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-0237"></a>(amount =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0238"></a>    balance = 25 - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0239"></a> <b>return</b> 25;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0240"></a>})(20)</p>
<p class="paracontinue"><a id="c003_c3-para-0241"></a>Now we apply the function by substituting 20 for <span class="KeyTerm1">amount</span> in the body of the lambda expression:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0242"></a>balance = 25 - 20;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0243"></a><b>return</b> 25;</p>
<p class="paracontinue"><a id="c003_c3-para-0244"></a>If we adhered to the substitution model, we would have to say that the meaning of the function application is to first set <span class="KeyTerm1">balance</span> to 5 and then return 25 as the value of the expression. This gets the wrong answer. In order to get the correct answer, we would have to somehow distinguish the first occurrence of <span class="KeyTerm1">balance</span> (before the effect of the assignment) from the second occurrence of <span class="KeyTerm1">balance</span> (after the effect of the assignment), and the substitution model cannot do this.</p>
<p><a id="c003_c3-para-0245"></a>The trouble here is that substitution is based ultimately on the notion that the name in our language are essentially symbols for values. This worked well for constants. But a variable, whose value can change with assignment, cannot simply be a name for a value. A variable somehow refers to a place where a value can be stored, and the value stored at this place can change. In section 3.2 we will see how environments play this role of “place” in our computational model.</p>
<section>
<h5><a id="c003_c3-sec-0012"></a><a id="c003_c3-title-0013"></a>Sameness and change</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0246"></a>The issue surfacing here is more profound than the mere breakdown of a particular model of computation. As soon as we introduce change into our computational models, many notions that were previously straightforward become problematical. Consider the concept of two things being “the same.”</p>
<p><a id="c003_c3-para-0247"></a>Suppose we call <span class="KeyTerm1">make_decrementer</span> twice with the same argument to create two functions:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0248"></a><b>const</b> D1 = make_decrementer(25);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0249"></a><b>const</b> D2 = make_decrementer(25);</p>
<p class="paracontinue"><a id="c003_c3-para-0250"></a>Are <span class="KeyTerm1"><span class="KeyTerm1">D1</span> </span>and <span class="KeyTerm1"><span class="KeyTerm1">D2</span> </span>the same? An acceptable answer is yes, because <span class="KeyTerm1"><span class="KeyTerm1">D1</span> </span>and <span class="KeyTerm1"><span class="KeyTerm1">D2</span> </span>have the same computational behavior—each is a function that subtracts its input from 25. In fact, <span class="KeyTerm1"><span class="KeyTerm1">D1</span> </span>could be substituted for <span class="KeyTerm1"><span class="KeyTerm1">D2</span> </span>in any computation without changing the result.</p>
<p><a id="c003_c3-para-0251"></a>Contrast this with making two calls to <span class="KeyTerm1">make_simplified_withdraw</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0252"></a><b>const</b> W1 = make_simplified_withdraw(25);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0253"></a><b>const</b> W2 = make_simplified_withdraw(25);</p>
<p class="paracontinue"><a id="c003_c3-para-0254"></a>Are <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> the same? Surely not, because calls to <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> have distinct effects, as shown by the following sequence of interactions:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0255"></a>W1(20);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0256"></a><i>5</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0257"></a>W1(20);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0258"></a><i>-15</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0259"></a>W2(20);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0260"></a><i>5</i></p>
<p class="paracontinue"><a id="c003_c3-para-0261"></a>Even though <span class="KeyTerm1"><span class="KeyTerm1">W1</span> </span>and <span class="KeyTerm1"><span class="KeyTerm1">W2</span> </span>are “equal” in the sense that they are both created by evaluating the same expression, <span class="KeyTerm1">make_simplified_withdraw(25)</span>, it is not true that <span class="KeyTerm1"><span class="KeyTerm1">W1</span> </span>could be substituted for <span class="KeyTerm1"><span class="KeyTerm1">W2</span> </span>in any expression without changing the result of evaluating the expression.</p>
<p><a id="c003_c3-para-0262"></a>A language that supports the concept that “equals can be substituted for equals” in an expression without changing the value of the expression is said to be <i>referentially transparent</i>. Referential transparency is violated when we include assignment in our computer language. This makes it tricky to determine when we can simplify expressions by substituting equivalent expressions. Consequently, reasoning about programs that use assignment becomes drastically more difficult.</p>
<p><a id="c003_c3-para-0263"></a>Once we forgo referential transparency, the notion of what it means for computational objects to be “the same” becomes difficult to capture in a formal way. Indeed, the meaning of “same” in the real world that our programs model is hardly clear in itself. In general, we can determine that two apparently identical objects are indeed “the same one” only by modifying one object and then observing whether the other object has changed in the same way. But how can we tell if an object has “changed” other than by observing the “same” object twice and seeing whether some property of the object differs from one observation to the next? Thus, we cannot determine “change” without some a priori notion of “sameness,” and we cannot determine sameness without observing the effects of change.</p>
<p><a id="c003_c3-para-0264"></a>As an example of how this issue arises in programming, consider the situation where Peter and Paul have a bank account with $100 in it. There is a substantial difference between modeling this as</p>
<p class="Sp-text-1"><a id="c003_c3-para-0265"></a><b>const</b> peter_acc = make_account(100);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0266"></a><b>const</b> paul_acc = make_account(100);</p>
<p class="paracontinue"><a id="c003_c3-para-0267"></a>and modeling it as</p>
<p class="Sp-text-1"><a id="c003_c3-para-0268"></a><b>const</b> peter_acc = make_account(100);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0269"></a><b>const</b> paul_acc = peter_acc;</p>
<p class="paracontinue"><a id="c003_c3-para-0270"></a>In the first situation, the two bank accounts are distinct. Transactions made by Peter will not affect Paul's account, and vice versa. In the second situation, however, we have defined <span class="KeyTerm1">paul_acc</span> to be <i>the same thing</i> as <span class="KeyTerm1">peter_acc</span>. In effect, Peter and Paul now have a joint bank account, and if Peter makes a withdrawal from <span class="KeyTerm1">peter_acc</span> Paul will observe less money in <span class="KeyTerm1">paul_acc</span>. These two similar but distinct situations can cause confusion in building computational models. With the shared account, in particular, it can be especially confusing that there is one object (the bank account) that has two different names (<span class="KeyTerm1">peter_acc</span> and <span class="KeyTerm1">paul_acc</span>); if we are searching for all the places in our program where <span class="KeyTerm1">paul_acc</span> can be changed, we must remember to look also at things that change <span class="KeyTerm1">peter_acc</span>.<a id="c003_c3-fn-0010a"></a><a href="#c3-fn-0010"><sup>10</sup></a></p>
<p><a id="c003_c3-para-0271"></a>With reference to the above remarks on “sameness” and “change,” observe that if Peter and Paul could only examine their bank balances, and could not perform operations that changed the balance, then the issue of whether the two accounts are distinct would be moot. In general, so long as we never modify data objects, we can regard a compound data object to be precisely the totality of its pieces. For example, a rational number is determined by giving its numerator and its denominator. But this view is no longer valid in the presence of change, where a compound data object has an “identity” that is something different from the pieces of which it is composed. A bank account is still “the same” bank account even if we change the balance by making a withdrawal; conversely, we could have two different bank accounts with the same state information. This complication is a consequence, not of our programming language, but of our perception of a bank account as an object. We do not, for example, ordinarily regard a rational number as a changeable object with identity, such that we could change the numerator and still have “the same” rational number.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0013"></a><a id="c003_c3-title-0014"></a>Pitfalls of imperative programming</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0272"></a>In contrast to functional programming, programming that makes extensive use of assignment is known as <i>imperative programming</i>. In addition to raising complications about computational models, programs written in imperative style are susceptible to bugs that cannot occur in functional programs. For example, recall the iterative factorial program from section 1.2.1 (here using a conditional statement instead of a conditional expression):</p>
<p class="Sp-text-1"><a id="c003_c3-para-0273"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0274"></a> <b>function</b> iter(product, counter) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0275"></a> <b>if</b> (counter &gt; n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0276"></a> <b>return</b> product;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0277"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0278"></a> <b>return</b> iter(counter * product,</p>
<p class="Sp-text-1"><a id="c003_c3-para-0279"></a>                        counter + 1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0280"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0281"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0282"></a> <b>return</b> iter(1, 1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0283"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0284"></a>Instead of passing arguments in the internal iterative loop, we could adopt a more imperative style by using explicit assignment to update the values of the variables <span class="KeyTerm1">product</span> and <span class="KeyTerm1">counter</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0285"></a><b>function</b> factorial(n) { </p>
<p class="Sp-text-1"><a id="c003_c3-para-0286"></a> <b>let</b> product = 1;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0287"></a> <b>let</b> counter = 1;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0288"></a> <b>function</b> iter() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0289"></a> <b>if</b> (counter &gt; n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0290"></a> <b>return</b> product;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0291"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0292"></a>            product = counter * product;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0293"></a>            counter = counter + 1;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0294"></a> <b>return</b> iter();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0295"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0296"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0297"></a> <b>return</b> iter();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0298"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0299"></a>This does not change the results produced by the program, but it does introduce a subtle trap. How do we decide the order of the assignments? As it happens, the program is correct as written. But writing the assignments in the opposite order</p>
<p class="Sp-text-1"><a id="c003_c3-para-0300"></a>counter = counter + 1;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0301"></a>product = counter * product;</p>
<p class="paracontinue"><a id="c003_c3-para-0302"></a>would have produced a different, incorrect result. In general, programming with assignment forces us to carefully consider the relative orders of the assignments to make sure that each statement is using the correct version of the variables that have been changed. This issue simply does not arise in functional programs.<a id="c003_c3-fn-0011a"></a><a href="#c3-fn-0011"><sup>11</sup></a></p>
<p><a id="c003_c3-para-0303"></a>The complexity of imperative programs becomes even worse if we consider applications in which several processes execute concurrently. We will return to this in section 3.4. First, however, we will address the issue of providing a computational model for expressions that involve assignment, and explore the uses of objects with local state in designing simulations.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0014"></a><a id="c003_c3-title-0015"></a>Exercise 3.7</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0304"></a>Consider the bank account objects created by <span class="KeyTerm1">make_account</span>, with the password modification described in exercise 3.3. Suppose that our banking system requires the ability to make joint accounts. Define a function <span class="KeyTerm1">make_joint</span> that accomplishes this. The function <span class="KeyTerm1">make_joint</span> should take three arguments. The first is a password-protected account. The second argument must match the password with which the account was defined in order for the <span class="KeyTerm1">make_joint</span> operation to proceed. The third argument is a new password. The function <span class="KeyTerm1">make_joint</span> is to create an additional access to the original account using the new password. For example, if <span class="KeyTerm1">peter_acc</span> is a bank account with password <span class="KeyTerm1">"open sesame"</span>, then</p>
<p class="Sp-text-1"><a id="c003_c3-para-0305"></a><b>const</b> paul_acc = make_joint(peter_acc, "open sesame", "rosebud");</p>
<p class="paracontinue"><a id="c003_c3-para-0306"></a>will allow one to make transactions on <span class="KeyTerm1">peter_acc</span> using the name <span class="KeyTerm1">paul_acc</span> and the password <span class="KeyTerm1">"rosebud"</span>. You may wish to modify your solution to exercise 3.3 to accommodate this new feature.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0015"></a><a id="c003_c3-title-0016"></a>Exercise 3.8</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0307"></a>When we defined the evaluation model in section 1.1.3, we said that the first step in evaluating an expression is to evaluate its subexpressions. But we never specified the order in which the subexpressions should be evaluated (e.g., left to right or right to left). When we introduce assignment, the order in which the operands of an operator combination are evaluated can make a difference to the result. Define a simple function <span class="KeyTerm1">f</span> such that evaluating <span class="KeyTerm1">f(0) + f(1)</span> will return 0 if the operands of <span class="KeyTerm1">+</span> are evaluated from left to right but will return 1 if the operands are evaluated from right to left.</p>
</section>
</section>
</section>
<section>
<h2><a id="c003_c3-sec-0016"></a><span>3.2</span> <a id="c003_c3-title-0017"></a>The Environment Model of Evaluation</h2>
<p class="paraaftertitle"><a id="c003_c3-para-0308"></a>When we introduced compound functions in chapter 1, we used the substitution model of evaluation (section 1.1.5) to define what is meant by applying a function to arguments:</p>
<ul style="list-style-type:disc">
<li>To apply a compound function to arguments, evaluate the return expression of the function (more generally, the body) with each parameter replaced by the corresponding argument.</li>
</ul>
<p><a id="c003_c3-para-0310"></a>Once we admit assignment into our programming language, such a definition is no longer adequate. In particular, section 3.1.3 argued that, in the presence of assignment, a name cannot be considered to be merely representing a value. Rather, a name must somehow designate a “place” in which values can be stored. In our new model of evaluation, these places will be maintained in structures called <i>environments</i>.</p>
<p><a id="c003_c3-para-0311"></a>An environment is a sequence of <i>frames</i>. Each frame is a table (possibly empty) of <i>bindings</i>, which associate names with their corresponding values. (A single frame may contain at most one binding for any name.) Each frame also has a pointer to its <i>enclosing environment</i>, unless, for the purposes of discussion, the frame is considered to be <i>global</i>. The <i>value of a name</i> with respect to an environment is the value given by the binding of the name in the first frame in the environment that contains a binding for that name. If no frame in the sequence specifies a binding for the name, then the name is said to be <i>unbound</i> in the environment.</p>
<p><a id="c003_c3-para-0312"></a><a id="c003_c3-fig-0001a"></a><a href="#c3-fig-0001">Figure 3.1</a> shows a simple environment structure consisting of three frames, labeled I, II, and III. In the diagram, A, B, C, and D are pointers to environments. C and D point to the same environment. The names <span class="KeyTerm1">z</span> and <span class="KeyTerm1">x</span> are bound in frame II, while <span class="KeyTerm1">y</span> and <span class="KeyTerm1">x</span> are bound in frame I. The value of <span class="KeyTerm1">x</span> in environment D is 3. The value of <span class="KeyTerm1">x</span> with respect to environment B is also 3. This is determined as follows: We examine the first frame in the sequence (frame III) and do not find a binding for <span class="KeyTerm1">x</span>, so we proceed to the enclosing environment D and find the binding in frame I. On the other hand, the value of <span class="KeyTerm1">x</span> in environment A is 7, because the first frame in the sequence (frame II) contains a binding of <span class="KeyTerm1">x</span> to 7. With respect to environment A, the binding of <span class="KeyTerm1">x</span> to 7 in frame II is said to <i>shadow</i> the binding of <span class="KeyTerm1">x</span> to 3 in frame I.</p>
<figure id="c003_c3-fig-0001"><img alt="c3-fig-0001.jpg" src="../images/c3-fig-0001.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0001a">Figure 3.1</a></span> <a id="c003_c3-para-0313"></a>A simple environment structure.</p></figcaption></figure>
<p><a id="c003_c3-para-0314"></a>The environment is crucial to the evaluation process, because it determines the context in which an expression should be evaluated. Indeed, one could say that expressions in a programming language do not, in themselves, have any meaning. Rather, an expression acquires a meaning only with respect to some environment in which it is evaluated. Even the interpretation of an expression as straightforward as <span class="KeyTerm1">display(1)</span> depends on an understanding that one is operating in a context in which the name <span class="KeyTerm1">display</span> refers to the primitive function that displays a value. Thus, in our model of evaluation we will always speak of evaluating an expression with respect to some environment. To describe interactions with the interpreter, we will suppose that there is a global environment, consisting of a single frame (with no enclosing environment) that includes values for the names associated with the primitive functions. For example, the idea that <span class="KeyTerm1">display</span> is the name for the primitive display function is captured by saying that the name <span class="KeyTerm1">display</span> is bound in the global environment to the primitive display function.</p>
<p><a id="c003_c3-para-0315"></a>Before we evaluate a program, we extend the global environment with a new frame, the <i>program frame</i>, resulting in the <i>program environment</i>. We will add the names that are declared at the top level of the program, outside of any block, to this frame. The given program is then evaluated with respect to the program environment.</p>
<section>
<h3><a id="c003_c3-sec-0017"></a><span>3.2.1</span> <a id="c003_c3-title-0018"></a>The Rules for Evaluation</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0316"></a>The overall specification of how the interpreter evaluates a function application remains the same as when we first introduced it in section 1.1.4:</p>
<ul style="list-style-type:disc">
<li>To evaluate an application:<ol class="BS_NumberList1">
<li><a id="c003_c3-li-0003"></a><span>1. </span>Evaluate the subexpressions of the application.<a id="c003_c3-fn-0012a"></a><a href="#c3-fn-0012"><sup>12</sup></a></li>
<li><a id="c003_c3-li-0004"></a><span>2. </span>Apply the value of the function subexpression to the values of the argument subexpressions.</li>
</ol></li>
</ul>
<p class="paracontinue"><a id="c003_c3-para-0320"></a>The environment model of evaluation replaces the substitution model in specifying what it means to apply a compound function to arguments.</p>
<p><a id="c003_c3-para-0321"></a>In the environment model of evaluation, a function is always a pair consisting of some code and a pointer to an environment. Functions are created in one way only: by evaluating a lambda expression. This produces a function whose code is obtained from the text of the lambda expression and whose environment is the environment in which the lambda expression was evaluated to produce the function. For example, consider the function declaration</p>
<p class="Sp-text-1"><a id="c003_c3-para-0322"></a><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0323"></a> <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0324"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0325"></a>evaluated in the program environment. The function declaration syntax is equivalent to an underlying implicit lambda expression. It would have been equivalent to have used<a id="c003_c3-fn-0013a"></a><a href="#c3-fn-0013"><sup>13</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-0326"></a><b>const</b> square = x =&gt; x * x;</p>
<p class="paracontinue"><a id="c003_c3-para-0327"></a>which evaluates <span class="KeyTerm1">x =&gt; x * x</span> and binds <span class="KeyTerm1">square</span> to the resulting value, all in the program environment.</p>
<p><a id="c003_c3-para-0328"></a><a id="c003_c3-fig-0002a"></a><a href="#c3-fig-0002">Figure 3.2</a> shows the result of evaluating this declaration statement. The global environment encloses the program environment. To reduce clutter, after this figure we will not display the global environment (as it is always the same), but we are reminded of its existence by the pointer from the program environment upward. The function object is a pair whose code specifies that the function has one parameter, namely <span class="KeyTerm1">x</span>, and a function body <span class="KeyTerm1"><b>return</b> x * x;</span>. The environment part of the function is a pointer to the program environment, since that is the environment in which the lambda expression was evaluated to produce the function. A new binding, which associates the function object with the name <span class="KeyTerm1">square</span>, has been added to the program frame.</p>
<figure id="c003_c3-fig-0002"><img alt="c3-fig-0002.jpg" src="../images/c3-fig-0002.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0002a">Figure 3.2</a></span> <a id="c003_c3-para-0329"></a>Environment structure produced by evaluating <span class="KeyTerm1"><b>function</b> square(x) { <b>return</b> x * x; }</span> in the program environment.</p></figcaption></figure>
<p><a id="c003_c3-para-0330"></a>In general, <span class="KeyTerm1"><b>const</b></span>, <span class="KeyTerm1"><b>function</b></span>, and <span class="KeyTerm1"><b>let</b></span> add bindings to frames. Assignment is forbidden on constants, so our environment model needs to distinguish names that refer to constants from names that refer to variables. We indicate that a name is a constant by writing an equal sign after the colon that follows the name. We consider function declarations as equivalent to constant declarations;<a id="c003_c3-fn-0014a"></a><a href="#c3-fn-0014"><sup>14</sup></a> observe the equal signs after the colons in <a href="#c3-fig-0002">figure 3.2</a>.</p>
<p><a id="c003_c3-para-0331"></a>Now that we have seen how functions are created, we can describe how functions are applied. The environment model specifies: To apply a function to arguments, create a new environment containing a frame that binds the parameters to the values of the arguments. The enclosing environment of this frame is the environment specified by the function. Now, within this new environment, evaluate the function body.</p>
<p><a id="c003_c3-para-0332"></a>To show how this rule is followed, <a id="c003_c3-fig-0003a"></a><a href="#c3-fig-0003">figure 3.3</a> illustrates the environment structure created by evaluating the expression <span class="KeyTerm1">square(5)</span> in the program environment, where <span class="KeyTerm1">square</span> is the function generated in <a href="#c3-fig-0002">figure 3.2</a>. Applying the function results in the creation of a new environment, labeled E1 in the figure, that begins with a frame in which <span class="KeyTerm1">x</span>, the parameter for the function, is bound to the argument 5. Note that name <span class="KeyTerm1">x</span> in environment E1 is followed by a colon with no equal sign, which indicates that the parameter <span class="KeyTerm1">x</span> is treated as a variable.<a id="c003_c3-fn-0015a"></a><a href="#c3-fn-0015"><sup>15</sup></a> The pointer leading upward from this frame shows that the frame's enclosing environment is the program environment. The program environment is chosen here, because this is the environment that is indicated as part of the <span class="KeyTerm1">square</span> function object. Within E1, we evaluate the body of the function, <span class="KeyTerm1"><b>return</b> x * x;</span>. Since the value of <span class="KeyTerm1">x</span> in E1 is 5, the result is <span class="KeyTerm1">5 * 5</span>, or 25.</p>
<figure id="c003_c3-fig-0003"><img alt="c3-fig-0003.jpg" src="../images/c3-fig-0003.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0003a">Figure 3.3</a></span> <a id="c003_c3-para-0333"></a>Environment created by evaluating <span class="KeyTerm1">square(5)</span> in the program environment.</p></figcaption></figure>
<p><a id="c003_c3-para-0334"></a>The environment model of function application can be summarized by two rules:</p>
<ul style="list-style-type:disc">
<li>A function object is applied to a set of arguments by constructing a frame, binding the parameters of the function to the arguments of the call, and then evaluating the body of the function in the context of the new environment constructed. The new frame has as its enclosing environment the environment part of the function object being applied. The result of the application is the result of evaluating the return expression of the first return statement encountered while evaluating the function body.</li>
<li>A function is created by evaluating a lambda expression relative to a given environment. The resulting function object is a pair consisting of the text of the lambda expression and a pointer to the environment in which the function was created.</li>
</ul>
<p><a id="c003_c3-para-0337"></a>Finally, we specify the behavior of assignment, the operation that forced us to introduce the environment model in the first place. Evaluating the expression <i>name</i> <span class="KeyTerm1">=</span> <i>value</i> in some environment locates the binding of the name in the environment. That is, one finds the first frame in the environment that contains a binding for the name. If the binding is a variable binding—indicated in the frame by just <span class="KeyTerm1">:</span> after the name—that binding is changed to reflect the new value of the variable. Otherwise, if the binding in the frame is a constant binding—indicated in the frame by <span class="KeyTerm1">:=</span> after the name—the assignment signals an <span class="KeyTerm1">"assignment to constant"</span> error. If the name is unbound in the environment, then the assignment signals a <span class="KeyTerm1">"variable undeclared"</span> error.</p>
<p><a id="c003_c3-para-0338"></a>These evaluation rules, though considerably more complex than the substitution model, are still reasonably straightforward. Moreover, the evaluation model, though abstract, provides a correct description of how the interpreter evaluates expressions. In chapter 4 we shall see how this model can serve as a blueprint for implementing a working interpreter. The following sections elaborate the details of the model by analyzing some illustrative programs.</p>
</section>
<section>
<h3><a id="c003_c3-sec-0018"></a><span>3.2.2</span> <a id="c003_c3-title-0019"></a>Applying Simple Functions</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0339"></a>When we introduced the substitution model in section 1.1.5 we showed how the application <span class="KeyTerm1">f(5)</span> evaluates to 136, given the following function declarations:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0340"></a><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0341"></a> <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0342"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0343"></a><b>function</b> sum_of_squares(x, y) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0344"></a> <b>return</b> square(x) + square(y);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0345"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0346"></a><b>function</b> f(a) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0347"></a> <b>return</b> sum_of_squares(a + 1, a * 2);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0348"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0349"></a>We can analyze the same example using the environment model. <a id="c003_c3-fig-0004a"></a><a href="#c3-fig-0004">Figure 3.4</a> shows the three function objects created by evaluating the definitions of <span class="KeyTerm1">f</span>, <span class="KeyTerm1">square</span>, and <span class="KeyTerm1">sum_of_squares</span> in the program environment. Each function object consists of some code, together with a pointer to the program environment.</p>
<figure id="c003_c3-fig-0004"><img alt="c3-fig-0004.jpg" src="../images/c3-fig-0004.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0004a">Figure 3.4</a></span> <a id="c003_c3-para-0350"></a>Function objects in the program frame.</p></figcaption></figure>
<p><a id="c003_c3-para-0351"></a>In <a id="c003_c3-fig-0005a"></a><a href="#c3-fig-0005">figure 3.5</a> we see the environment structure created by evaluating the expression <span class="KeyTerm1">f(5)</span>. The call to <span class="KeyTerm1">f</span> creates a new environment, E1, beginning with a frame in which <span class="KeyTerm1">a</span>, the parameter of <span class="KeyTerm1">f</span>, is bound to the argument 5. In E1, we evaluate the body of <span class="KeyTerm1">f</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0353"></a><b>return</b> sum_of_squares(a + 1, a * 2);</p>
<figure id="c003_c3-fig-0005"><img alt="c3-fig-0005.jpg" src="../images/c3-fig-0005.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0005a">Figure 3.5</a></span> <a id="c003_c3-para-0352"></a>Environments created by evaluating <span class="KeyTerm1">f(5)</span> using the functions in <a href="#c3-fig-0004">figure 3.4</a>.</p></figcaption></figure>
<p class="paracontinue"><a id="c003_c3-para-0354"></a>To evaluate the return statement, we first evaluate the subexpressions of the return expression. The first subexpression, <span class="KeyTerm1">sum_of_squares</span>, has a value that is a function object. (Notice how this value is found: We first look in the first frame of E1, which contains no binding for <span class="KeyTerm1">sum_of_squares</span>. Then we proceed to the enclosing environment, i.e., the program environment, and find the binding shown in <a href="#c3-fig-0004">figure 3.4</a>.) The other two subexpressions are evaluated by applying the primitive operations <span class="KeyTerm1">+</span> and <span class="KeyTerm1">*</span> to evaluate the two combinations <span class="KeyTerm1">a + 1</span> and <span class="KeyTerm1">a * 2</span> to obtain 6 and 10, respectively.</p>
<p><a id="c003_c3-para-0355"></a>Now we apply the function object <span class="KeyTerm1">sum_of_squares</span> to the arguments 6 and 10. This results in a new environment, E2, in which the parameters <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> are bound to the arguments. Within E2 we evaluate the statement</p>
<p class="Sp-text-1"><a id="c003_c3-para-0356"></a><b>return</b> square(x) + square(y);</p>
<p class="paracontinue"><a id="c003_c3-para-0357"></a>This leads us to evaluate <span class="KeyTerm1">square(x)</span>, where <span class="KeyTerm1">square</span> is found in the program frame and <span class="KeyTerm1">x</span> is 6. Once again, we set up a new environment, E3, in which <span class="KeyTerm1">x</span> is bound to 6, and within this we evaluate the body of <span class="KeyTerm1">square</span>, which is <span class="KeyTerm1"><b>return</b> x * x;</span>. Also as part of applying <span class="KeyTerm1">sum_of_squares</span>, we must evaluate the subexpression <span class="KeyTerm1">square(y)</span>, where <span class="KeyTerm1">y</span> is 10. This second call to <span class="KeyTerm1">square</span> creates another environment, E4, in which <span class="KeyTerm1">x</span>, the parameter of <span class="KeyTerm1">square</span>, is bound to 10. And within E4 we must evaluate <span class="KeyTerm1"><b>return</b> x * x;</span>.</p>
<p><a id="c003_c3-para-0358"></a>The important point to observe is that each call to <span class="KeyTerm1">square</span> creates a new environment containing a binding for <span class="KeyTerm1">x</span>. We can see here how the different frames serve to keep separate the different local variables all named <span class="KeyTerm1">x</span>. Notice that each frame created by <span class="KeyTerm1">square</span> points to the program environment, since this is the environment indicated by the <span class="KeyTerm1">square</span> function object.</p>
<p><a id="c003_c3-para-0359"></a>After the subexpressions are evaluated, the results are returned. The values generated by the two calls to <span class="KeyTerm1">square</span> are added by <span class="KeyTerm1">sum_of_squares</span>, and this result is returned by <span class="KeyTerm1">f</span>. Since our focus here is on the environment structures, we will not dwell on how these returned values are passed from call to call; however, this is also an important aspect of the evaluation process, and we will return to it in detail in chapter 5.</p>
<section>
<h5><a id="c003_c3-sec-0019"></a><a id="c003_c3-title-0020"></a>Exercise 3.9</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0360"></a>In section 1.2.1 we used the substitution model to analyze two functions for computing factorials, a recursive version</p>
<p class="Sp-text-1"><a id="c003_c3-para-0361"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0362"></a> <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c003_c3-para-0363"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c003_c3-para-0364"></a>           : n * factorial(n - 1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0365"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0366"></a>and an iterative version</p>
<p class="Sp-text-1"><a id="c003_c3-para-0367"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0368"></a> <b>return</b> fact_iter(1, 1, n);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0369"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0370"></a><b>function</b> fact_iter(product, counter, max_count) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0371"></a> <b>return</b> counter &gt; max_count</p>
<p class="Sp-text-1"><a id="c003_c3-para-0372"></a>           ? product</p>
<p class="Sp-text-1"><a id="c003_c3-para-0373"></a>           : fact_iter(counter * product,</p>
<p class="Sp-text-1"><a id="c003_c3-para-0374"></a>                       counter + 1,</p>
<p class="Sp-text-1"><a id="c003_c3-para-0375"></a>                       max_count);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0376"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0377"></a>Show the environment structures created by evaluating <span class="KeyTerm1">factorial(6)</span> using each version of the <span class="KeyTerm1">factorial</span> function.<a id="c003_c3-fn-0016a"></a><a href="#c3-fn-0016"><sup>16</sup></a></p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0020"></a><span>3.2.3</span> <a id="c003_c3-title-0021"></a>Frames as the Repository of Local State</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0378"></a>We can turn to the environment model to see how functions and assignment can be used to represent objects with local state. As an example, consider the “withdrawal processor” from section 3.1.1 created by calling the function</p>
<p class="Sp-text-1"><a id="c003_c3-para-0379"></a><b>function</b> make_withdraw(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0380"></a> <b>return</b> amount =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0381"></a> <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0382"></a>                   balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0383"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0384"></a>               } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0385"></a> <b>return</b> "insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0386"></a>               }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0387"></a>           };</p>
<p class="Sp-text-1"><a id="c003_c3-para-0388"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0389"></a>Let us describe the evaluation of</p>
<p class="Sp-text-1"><a id="c003_c3-para-0390"></a><b>const</b> W1 = make_withdraw(100); </p>
<p class="paracontinue"><a id="c003_c3-para-0391"></a>followed by</p>
<p class="Sp-text-1"><a id="c003_c3-para-0392"></a>W1(50);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0393"></a><i>50</i></p>
<p class="paracontinue"><a id="c003_c3-para-0394"></a><a id="c003_c3-fig-0006a"></a><a href="#c3-fig-0006">Figure 3.6</a> shows the result of declaring the <span class="KeyTerm1">make_withdraw</span> function in the program environment. This produces a function object that contains a pointer to the program environment. So far, this is no different from the examples we have already seen, except that the return expression in the body of the function is itself a lambda expression.</p>
<figure id="c003_c3-fig-0006"><img alt="c3-fig-0006.jpg" src="../images/c3-fig-0006.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0006a">Figure 3.6</a></span> <a id="c003_c3-para-0395"></a>Result of defining <span class="KeyTerm1">make_withdraw</span> in the program environment.</p></figcaption></figure>
<p><a id="c003_c3-para-0396"></a>The interesting part of the computation happens when we apply the function <span class="KeyTerm1">make_withdraw</span> to an argument:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0397"></a><b>const</b> W1 = make_withdraw(100);</p>
<p class="paracontinue"><a id="c003_c3-para-0398"></a>We begin, as usual, by setting up an environment E1 in which the parameter <span class="KeyTerm1">balance</span> is bound to the argument 100. Within this environment, we evaluate the body of <span class="KeyTerm1">make_withdraw</span>, namely the return statement whose return expression is a lambda expression. The evaluation of this lambda expression constructs a new function object, whose code is as specified by the lambda expression and whose environment is E1, the environment in which the lambda expression was evaluated to produce the function. The resulting function object is the value returned by the call to <span class="KeyTerm1">make_withdraw</span>. This is bound to <span class="KeyTerm1">W1</span> in the program environment, since the constant declaration itself is being evaluated in the program environment. <a id="c003_c3-fig-0007a"></a><a href="#c3-fig-0007">Figure 3.7</a> shows the resulting environment structure.</p>
<figure id="c003_c3-fig-0007"><img alt="c3-fig-0007.jpg" src="../images/c3-fig-0007.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0007a">Figure 3.7</a></span> <a id="c003_c3-para-0399"></a>Result of evaluating <span class="KeyTerm1"><b>const</b> W1 = make_withdraw(100);</span>.</p></figcaption></figure>
<p><a id="c003_c3-para-0400"></a>Now we can analyze what happens when <span class="KeyTerm1">W1</span> is applied to an argument:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0401"></a>W1(50);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0402"></a><i>50</i></p>
<p class="paracontinue"><a id="c003_c3-para-0403"></a>We begin by constructing a frame in which <span class="KeyTerm1">amount</span>, the parameter of <span class="KeyTerm1">W1</span>, is bound to the argument 50. The crucial point to observe is that this frame has as its enclosing environment not the program environment, but rather the environment E1, because this is the environment that is specified by the <span class="KeyTerm1">W1</span> function object. Within this new environment, we evaluate the body of the function:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0404"></a><b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0405"></a>    balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0406"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0407"></a>} <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0408"></a> <b>return</b> "insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0409"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0410"></a>The resulting environment structure is shown in <a id="c003_c3-fig-0008a"></a><a href="#c3-fig-0008">figure 3.8</a>. The expression being evaluated references both <span class="KeyTerm1">amount</span> and <span class="KeyTerm1">balance</span>. The variable <span class="KeyTerm1">amount</span> will be found in the first frame in the environment, and <span class="KeyTerm1">balance</span> will be found by following the enclosing-environment pointer to E1.</p>
<figure id="c003_c3-fig-0008"><img alt="c3-fig-0008.jpg" src="../images/c3-fig-0008.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0008a">Figure 3.8</a></span> <a id="c003_c3-para-0411"></a>Environments created by applying the function object <span class="KeyTerm1">W1</span>.</p></figcaption></figure>
<p><a id="c003_c3-para-0412"></a>When the assignment is executed, the binding of <span class="KeyTerm1">balance</span> in E1 is changed. At the completion of the call to <span class="KeyTerm1"><span class="KeyTerm1">W1</span></span>, <span class="KeyTerm1">balance</span> is 50, and the frame that contains <span class="KeyTerm1">balance</span> is still pointed to by the function object <span class="KeyTerm1"><span class="KeyTerm1">W1</span></span>. The frame that binds <span class="KeyTerm1">amount</span> (in which we executed the code that changed <span class="KeyTerm1">balance</span>) is no longer relevant, since the function call that constructed it has terminated, and there are no pointers to that frame from other parts of the environment. The next time <span class="KeyTerm1"><span class="KeyTerm1">W1</span> </span>is called, this will build a new frame that binds <span class="KeyTerm1">amount</span> and whose enclosing environment is E1. We see that E1 serves as the “place” that holds the local state variable for the function object <span class="KeyTerm1"><span class="KeyTerm1">W1</span></span>. <a id="c003_c3-fig-0009a"></a><a href="#c3-fig-0009">Figure 3.9</a> shows the situation after the call to <span class="KeyTerm1"><span class="KeyTerm1">W1</span></span>.</p>
<figure id="c003_c3-fig-0009"><img alt="c3-fig-0009.jpg" src="../images/c3-fig-0009.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0009a">Figure 3.9</a></span> <a id="c003_c3-para-0413"></a>Environments after the call to <span class="KeyTerm1">W1</span>.</p></figcaption></figure>
<p><a id="c003_c3-para-0414"></a>Observe what happens when we create a second “withdraw” object by making another call to <span class="KeyTerm1">make_withdraw</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0415"></a><b>const</b> W2 = make_withdraw(100);</p>
<p class="paracontinue"><a id="c003_c3-para-0416"></a>This produces the environment structure of <a id="c003_c3-fig-0010a"></a><a href="#c3-fig-0010">figure 3.10</a>, which shows that <span class="KeyTerm1">W2</span> is a function object, that is, a pair with some code and an environment. The environment E2 for <span class="KeyTerm1">W2</span> was created by the call to <span class="KeyTerm1">make_withdraw</span>. It contains a frame with its own local binding for <span class="KeyTerm1">balance</span>. On the other hand, <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> have the same code: the code specified by the lambda expression in the body of <span class="KeyTerm1">make_withdraw</span>.<a id="c003_c3-fn-0017a"></a><a href="#c3-fn-0017"><sup>17</sup></a> We see here why <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> behave as independent objects. Calls to <span class="KeyTerm1">W1</span> reference the state variable <span class="KeyTerm1">balance</span> stored in E1, whereas calls to <span class="KeyTerm1">W2</span> reference the <span class="KeyTerm1">balance</span> stored in E2. Thus, changes to the local state of one object do not affect the other object.</p>
<figure id="c003_c3-fig-0010"><img alt="c3-fig-0010.jpg" src="../images/c3-fig-0010.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0010a">Figure 3.10</a></span> <a id="c003_c3-para-0417"></a>Using <span class="KeyTerm1"><b>const</b> W2 = make_withdraw(100);</span> to create a second object.</p></figcaption></figure>
<section>
<h5><a id="c003_c3-sec-0021"></a><a id="c003_c3-title-0022"></a>Exercise 3.10</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0418"></a>In the <span class="KeyTerm1">make_withdraw</span> function the local variable <span class="KeyTerm1">balance</span> is created as a parameter of <span class="KeyTerm1">make_withdraw</span>. We could also create the local state variable separately, using what we might call an <i>immediately invoked lambda expression</i> as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0419"></a><b>function</b> make_withdraw(initial_amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0420"></a> <b>return</b> (balance =&gt;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0421"></a>              amount =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0422"></a> <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0423"></a>                      balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0424"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0425"></a>                   } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0426"></a> <b>return</b> "insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0427"></a>                   }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0428"></a>              })(initial_amount);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0429"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0430"></a>The outer lambda expression is invoked immediately after it is evaluated. Its only purpose is to create a local variable <span class="KeyTerm1">balance</span> and initialize it to <span class="KeyTerm1">initial_amount</span>. Use the environment model to analyze this alternate version of <span class="KeyTerm1">make_withdraw</span>, drawing figures like the ones above to illustrate the interactions</p>
<p class="Sp-text-1"><a id="c003_c3-para-0431"></a><b>const</b> W1 = make_withdraw(100);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0432"></a>W1(50);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0433"></a><b>const</b> W2 = make_withdraw(100);</p>
<p class="paracontinue"><a id="c003_c3-para-0434"></a>Show that the two versions of <span class="KeyTerm1">make_withdraw</span> create objects with the same behavior. How do the environment structures differ for the two versions?</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0022"></a><span>3.2.4</span> <a id="c003_c3-title-0023"></a>Internal Declarations</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0435"></a>In this section we handle the evaluation of function bodies or other blocks (such as the branches of conditional statements) that contain declarations. Each block opens a new scope for names declared in the block. In order to evaluate a block in a given environment, we extend that environment by a new frame that contains all names declared directly (that is, outside of nested blocks) in the body of the block and then evaluate the body in the newly constructed environment.</p>
<p><a id="c003_c3-para-0436"></a>Section 1.1.8 introduced the idea that functions can have internal declarations, thus leading to a block structure as in the following function to compute square roots:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0437"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0438"></a> <b>function</b> is_good_enough(guess) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0439"></a> <b>return</b> abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0440"></a>   }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0441"></a> <b>function</b> improve(guess) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0442"></a> <b>return</b> average(guess, x / guess);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0443"></a>   }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0444"></a> <b>function</b> sqrt_iter(guess){</p>
<p class="Sp-text-1"><a id="c003_c3-para-0445"></a> <b>return</b> is_good_enough(guess)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0446"></a>             ? guess</p>
<p class="Sp-text-1"><a id="c003_c3-para-0447"></a>             : sqrt_iter(improve(guess));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0448"></a>   }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0449"></a> <b>return</b> sqrt_iter(1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0450"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0451"></a>Now we can use the environment model to see why these internal declarations behave as desired. <a id="c003_c3-fig-0011a"></a><a href="#c3-fig-0011">Figure 3.11</a> shows the point in the evaluation of the expression <span class="KeyTerm1">sqrt(2)</span> where the internal function <span class="KeyTerm1">is_good_enough</span> has been called for the first time with <span class="KeyTerm1">guess</span> equal to 1.</p>
<figure id="c003_c3-fig-0011"><img alt="c3-fig-0011.jpg" src="../images/c3-fig-0011.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0011a">Figure 3.11</a></span> <a id="c003_c3-para-0452"></a>The <span class="KeyTerm1">sqrt</span> function with internal declarations.</p></figcaption></figure>
<p><a id="c003_c3-para-0453"></a>Observe the structure of the environment. The name <span class="KeyTerm1">sqrt</span> is bound in the program environment to a function object whose associated environment is the program environment. When <span class="KeyTerm1">sqrt</span> was called, a new environment, E1, was formed, subordinate to the program environment, in which the parameter <span class="KeyTerm1">x</span> is bound to 2. The body of <span class="KeyTerm1">sqrt</span> was then evaluated in E1. That body is a block with local function declarations and therefore E1 was extended with a new frame for those declarations, resulting in the new environment E2. The body of the block was then evaluated in E2. Since the first statement in the body is</p>
<p class="Sp-text-1"><a id="c003_c3-para-0454"></a><b>function</b> is_good_enough(guess) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0455"></a> <b>return</b> abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0456"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0457"></a>evaluating this declaration created the function <span class="KeyTerm1">is_good_enough</span> in the environment E2. To be more precise, the name <span class="KeyTerm1">is_good_enough</span> in the first frame of E2 was bound to a function object whose associated environment is E2. Similarly, <span class="KeyTerm1">improve</span> and <span class="KeyTerm1">sqrt_iter</span> were defined as functions in E2. For conciseness, <a href="#c3-fig-0011">figure 3.11</a> shows only the function object for <span class="KeyTerm1">is_good_enough</span>.</p>
<p><a id="c003_c3-para-0458"></a>After the local functions were defined, the expression <span class="KeyTerm1">sqrt_iter(1)</span> was evaluated, still in environment E2. So the function object bound to <span class="KeyTerm1">sqrt_iter</span> in E2 was called with 1 as an argument. This created an environment E3 in which <span class="KeyTerm1">guess</span>, the parameter of <span class="KeyTerm1">sqrt_iter</span>, is bound to 1. The function <span class="KeyTerm1">sqrt_iter</span> in turn called <span class="KeyTerm1">is_good_enough</span> with the value of <span class="KeyTerm1">guess</span> (from E3) as the argument for <span class="KeyTerm1">is_good_ enough</span>. This set up another environment, E4, in which <span class="KeyTerm1">guess</span> (the parameter of <span class="KeyTerm1">is_good_enough</span>) is bound to 1. Although <span class="KeyTerm1">sqrt_iter</span> and <span class="KeyTerm1">is_good_enough</span> both have a parameter named <span class="KeyTerm1">guess</span>, these are two distinct local variables located in different frames. Also, E3 and E4 both have E2 as their enclosing environment, because the <span class="KeyTerm1">sqrt_iter</span> and <span class="KeyTerm1">is_good_enough</span> functions both have E2 as their environment part. One consequence of this is that the name <span class="KeyTerm1">x</span> that appears in the body of <span class="KeyTerm1">is_ good_enough</span> will reference the binding of <span class="KeyTerm1">x</span> that appears in E1, namely the value of <span class="KeyTerm1">x</span> with which the original <span class="KeyTerm1">sqrt</span> function was called.</p>
<p><a id="c003_c3-para-0459"></a>The environment model thus explains the two key properties that make local function declarations a useful technique for modularizing programs:</p>
<ul style="list-style-type:disc">
<li>The names of the local functions do not interfere with names external to the enclosing function, because the local function names will be bound in the frame that the block creates when it is evaluated, rather than being bound in the program environment.</li>
<li>The local functions can access the arguments of the enclosing function, simply by using parameter names as free names. This is because the body of the local function is evaluated in an environment that is subordinate to the evaluation environment for the enclosing function.</li>
</ul>
<section>
<h5><a id="c003_c3-sec-0023"></a><a id="c003_c3-title-0024"></a>Exercise 3.11</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0462"></a>In section 3.2.3 we saw how the environment model described the behavior of functions with local state. Now we have seen how internal declarations work. A typical messagepassing function contains both of these aspects. Consider the bank account function of section 3.1.1:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0463"></a><b>function</b> make_account(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0464"></a> <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0465"></a> <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0466"></a>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0467"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0468"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0469"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0470"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0471"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0472"></a> <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0473"></a>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0474"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0475"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0476"></a> <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0477"></a> <b>return</b> m === "withdraw"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0478"></a>               ? withdraw</p>
<p class="Sp-text-1"><a id="c003_c3-para-0479"></a>               : m === "deposit"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0480"></a>               ? deposit</p>
<p class="Sp-text-1"><a id="c003_c3-para-0481"></a>               : "Unknown request: make_account";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0482"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0483"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0484"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0485"></a>Show the environment structure generated by the sequence of interactions</p>
<p class="Sp-text-1"><a id="c003_c3-para-0486"></a><b>const</b> acc = make_account(50);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0487"></a>acc("deposit")(40);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0488"></a><i>90</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0489"></a>acc("withdraw")(60);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0490"></a><i>30</i></p>
<p class="paracontinue"><a id="c003_c3-para-0491"></a>Where is the local state for <span class="KeyTerm1">acc</span> kept? Suppose we define another account</p>
<p class="Sp-text-1"><a id="c003_c3-para-0492"></a><b>const</b> acc2 = make_account(100);</p>
<p class="paracontinue"><a id="c003_c3-para-0493"></a>How are the local states for the two accounts kept distinct? Which parts of the environment structure are shared between <span class="KeyTerm1">acc</span> and <span class="KeyTerm1">acc2</span>?</p>
</section>
<section>
<h5><a id="c003_c3-sec-0024"></a><a id="c003_c3-title-0025"></a>More about blocks</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0494"></a>As we saw, the scope of the names declared in <span class="KeyTerm1">sqrt</span> is the whole body of <span class="KeyTerm1">sqrt</span>. This explains why <i>mutual recursion</i> works, as in this (quite wasteful) way of checking whether a nonnegative integer is even.</p>
<p class="Sp-text-1"><a id="c003_c3-para-0495"></a><b>function</b> f(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0496"></a> <b>function</b> is_even(n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0497"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0498"></a>               ? <b>true</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-0499"></a>               : is_odd(n - 1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0500"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0501"></a> <b>function</b> is_odd(n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0502"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0503"></a>               ? <b>false</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-0504"></a>               : is_even(n - 1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0505"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0506"></a> <b>return</b> is_even(x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0507"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0508"></a>At the time when <span class="KeyTerm1">is_even</span> is called during a call to <span class="KeyTerm1">f</span>, the environment diagram looks like the one in <a href="#c3-fig-0011">figure 3.11</a> when <span class="KeyTerm1">sqrt_iter</span> is called. The functions <span class="KeyTerm1">is_even</span> and <span class="KeyTerm1">is_odd</span> are bound in E2 to function objects that point to E2 as the environment in which to evaluate calls to those functions. Thus <span class="KeyTerm1">is_odd</span> in the body of <span class="KeyTerm1">is_even</span> refers to the right function. Although <span class="KeyTerm1">is_odd</span> is defined after <span class="KeyTerm1">is_even</span>, this is no different from how in the body of <span class="KeyTerm1">sqrt_iter</span> the name <span class="KeyTerm1">improve</span> and the name <span class="KeyTerm1">sqrt_iter</span> itself refer to the right functions.</p>
<p><a id="c003_c3-para-0509"></a>Equipped with a way to handle declarations within blocks, we can revisit declarations of names at the top level. In section 3.2.1, we saw that the names declared at the top level are added to the program frame. A better explanation is that the whole program is placed in an implicit block, which is evaluated in the global environment. The treatment of blocks described above then handles the top level: The global environment is extended by a frame that contains the bindings of all names declared in the implicit block. That frame is the program frame and the resulting environment is the program environment.</p>
<p><a id="c003_c3-para-0510"></a>We said that a block's body is evaluated in an environment that contains all names declared directly in the body of the block. A locally declared name is put into the environment when the block is entered, but without an associated value. The evaluation of its declaration during evaluation of the block body then assigns to the name the result of evaluating the expression to the right of the <span class="KeyTerm1">=</span>, as if the declaration were an assignment. Since the addition of the name to the environment is separate from the evaluation of the declaration, and the whole block is in the scope of the name, an erroneous program could attempt to access the value of a name before its declaration is evaluated; the evaluation of an unassigned name signals an error.<a id="c003_c3-fn-0018a"></a><a href="#c3-fn-0018"><sup>18</sup></a></p>
</section>
</section>
</section>
<section>
<h2><a id="c003_c3-sec-0025"></a><span>3.3</span> <a id="c003_c3-title-0026"></a>Modeling with Mutable Data</h2>
<p class="paraaftertitle"><a id="c003_c3-para-0511"></a>Chapter 2 dealt with compound data as a means for constructing computational objects that have several parts, in order to model real-world objects that have several aspects. In that chapter we introduced the discipline of data abstraction, according to which data structures are specified in terms of constructors, which create data objects, and selectors, which access the parts of compound data objects. But we now know that there is another aspect of data that chapter 2 did not address. The desire to model systems composed of objects that have changing state leads us to the need to modify compound data objects, as well as to construct and select from them. In order to model compound objects with changing state, we will design data abstractions to include, in addition to selectors and constructors, operations called <i>mutators</i>, which modify data objects. For instance, modeling a banking system requires us to change account balances. Thus, a data structure for representing bank accounts might admit an operation</p>
<p class="Sp-text-1"><a id="c003_c3-para-0512"></a>set_balance(<i>account</i>, <i>new</i>-<i>value</i>)</p>
<p class="paracontinue"><a id="c003_c3-para-0513"></a>that changes the balance of the designated account to the designated new value. Data objects for which mutators are defined are known as <i>mutable data objects</i>.</p>
<p><a id="c003_c3-para-0514"></a>Chapter 2 introduced pairs as a general-purpose “glue” for synthesizing compound data. We begin this section by defining basic mutators for pairs, so that pairs can serve as building blocks for constructing mutable data objects. These mutators greatly enhance the representational power of pairs, enabling us to build data structures other than the sequences and trees that we worked with in section 2.2. We also present some examples of simulations in which complex systems are modeled as collections of objects with local state.</p>
<section>
<h3><a id="c003_c3-sec-0026"></a><span>3.3.1</span> <a id="c003_c3-title-0027"></a>Mutable List Structure</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0515"></a>The basic operations on pairs—<span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>—can be used to construct list structure and to select parts from list structure, but they are incapable of modifying list structure. The same is true of the list operations we have used so far, such as <span class="KeyTerm1">append</span> and <span class="KeyTerm1">list</span>, since these can be defined in terms of <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>. To modify list structures we need new operations.</p>
<p><a id="c003_c3-para-0516"></a>The primitive mutators for pairs are <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span>. The function <span class="KeyTerm1">set_head</span> takes two arguments, the first of which must be a pair. It modifies this pair, replacing the <span class="KeyTerm1">head</span> pointer by a pointer to the second argument of <span class="KeyTerm1">set_head</span>.<a id="c003_c3-fn-0019a"></a><a href="#c3-fn-0019"><sup>19</sup></a></p>
<p><a id="c003_c3-para-5516"></a>As an example, suppose that <span class="KeyTerm1">x</span> is bound to <span class="KeyTerm1">list(list("a", "b"), "c", "d")</span> and <span class="KeyTerm1">y</span> to <span class="KeyTerm1">list("e", "f")</span> as illustrated in <a id="c003_c3-fig-0012a"></a><a href="#c3-fig-0012">figure 3.12</a>. Evaluating the expression <span class="KeyTerm1">set_head(x, y)</span> modifies the pair to which <span class="KeyTerm1">x</span> is bound, replacing its <span class="KeyTerm1">head</span> by the value of <span class="KeyTerm1">y</span>. The result of the operation is shown in <a id="c003_c3-fig-0013a"></a><a href="#c3-fig-0013">figure 3.13</a>. The structure <span class="KeyTerm1">x</span> has been modified and is now equivalent to <span class="KeyTerm1">list(list("e", "f"), "c", "d")</span>. The pairs representing the list <span class="KeyTerm1">list("a", "b")</span>, identified by the pointer that was replaced, are now detached from the original structure.<a id="c003_c3-fn-0020a"></a><a href="#c3-fn-0020"><sup>20</sup></a></p>
<figure id="c003_c3-fig-0012"><img alt="c3-fig-0012.jpg" src="../images/c3-fig-0012.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0012a">Figure 3.12</a></span> <a id="c003_c3-para-0517"></a>Lists <span class="KeyTerm1">x</span>: <span class="KeyTerm1">list(list("a", "b"), "c", "d")</span> and <span class="KeyTerm1">y</span>: <span class="KeyTerm1">list("e", "f")</span>.</p></figcaption></figure>
<figure id="c003_c3-fig-0013"><img alt="c3-fig-0013.jpg" src="../images/c3-fig-0013.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0013a">Figure 3.13</a></span> <a id="c003_c3-para-0518"></a>Effect of <span class="KeyTerm1">set_head(x, y)</span> on the lists in <a href="#c3-fig-0012">figure 3.12</a>.</p></figcaption></figure>
<p><a id="c003_c3-para-0519"></a>Compare <a href="#c3-fig-0013">figure 3.13</a> with <a id="c003_c3-fig-0014a"></a><a href="#c3-fig-0014">figure 3.14</a>, which illustrates the result of executing</p>
<p class="Sp-text-1"><a id="c003_c3-para-0521"></a><b>const</b> z = pair(y, tail(x));</p>
<p class="paracontinue"><a id="c003_c3-para-0522"></a>with <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> bound to the original lists of <a href="#c3-fig-0012">figure 3.12</a>. The name <span class="KeyTerm1">z</span> is now bound to a new pair created by the <span class="KeyTerm1">pair</span> operation; the list to which <span class="KeyTerm1">x</span> is bound is unchanged. The <span class="KeyTerm1">set_tail</span> operation is similar to <span class="KeyTerm1">set_head</span>. The only difference is that the <span class="KeyTerm1">tail</span> pointer of the pair, rather than the <span class="KeyTerm1">head</span> pointer, is replaced. The effect of executing <span class="KeyTerm1">set_tail(x, y)</span> on the lists of <a href="#c3-fig-0012">figure 3.12</a> is shown in <a id="c003_c3-fig-0015a"></a><a href="#c3-fig-0015">figure 3.15</a>. Here the <span class="KeyTerm1">tail</span> pointer of <span class="KeyTerm1">x</span> has been replaced by the pointer to <span class="KeyTerm1">list("e", "f")</span>. Also, the list <span class="KeyTerm1">list("c", "d")</span>, which used to be the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">x</span>, is now detached from the structure.</p>
<figure id="c003_c3-fig-0014"><img alt="c3-fig-0014.jpg" src="../images/c3-fig-0014.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0014a">Figure 3.14</a></span> <a id="c003_c3-para-0520"></a>Effect of <span class="KeyTerm1"><b>const</b> z = pair(y, tail(x));</span> on the lists in <a href="#c3-fig-0012">figure 3.12</a>.</p></figcaption></figure>
<figure id="c003_c3-fig-0015"><img alt="c3-fig-0015.jpg" src="../images/c3-fig-0015.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0015a">Figure 3.15</a></span> <a id="c003_c3-para-0523"></a>Effect of <span class="KeyTerm1">set_tail(x, y)</span> on the lists in <a href="#c3-fig-0012">figure 3.12</a>.</p></figcaption></figure>
<p><a id="c003_c3-para-0524"></a>The function <span class="KeyTerm1">pair</span> builds new list structure by creating new pairs, whereas <span class="KeyTerm1">set_ head</span> and <span class="KeyTerm1">set_tail</span> modify existing pairs. Indeed, we could implement <span class="KeyTerm1">pair</span> in terms of the two mutators, together with a function <span class="KeyTerm1">get_new_pair</span>, which returns a new pair that is not part of any existing list structure. We obtain the new pair, set its <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> pointers to the designated objects, and return the new pair as the result of the <span class="KeyTerm1">pair</span>.<a id="c003_c3-fn-0021a"></a><a href="#c3-fn-0021"><sup>21</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-0525"></a><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0526"></a> <b>const</b> fresh = get_new_pair();</p>
<p class="Sp-text-1"><a id="c003_c3-para-5525"></a>    set_head(fresh, x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-5526"></a>    set_tail(fresh, y);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0527"></a> <b>return</b> fresh;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0528"></a>}</p>
<section>
<h5><a id="c003_c3-sec-0027"></a><a id="c003_c3-title-0028"></a>Exercise 3.12</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0529"></a>The following function for appending lists was introduced in section 2.2.1:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0530"></a><b>function</b> append(x, y) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0531"></a> <b>return</b> is_null(x)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0532"></a>           ? y</p>
<p class="Sp-text-1"><a id="c003_c3-para-0533"></a>           : pair(head(x), append(tail(x), y));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0534"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0535"></a>The function <span class="KeyTerm1">append</span> forms a new list by successively adjoining the elements of <span class="KeyTerm1">x</span> to the front of <span class="KeyTerm1">y</span>. The function <span class="KeyTerm1">append_mutator</span> is similar to <span class="KeyTerm1">append</span>, but it is a mutator rather than a constructor. It appends the lists by splicing them together, modifying the final pair of <span class="KeyTerm1">x</span> so that its <span class="KeyTerm1">tail</span> is now <span class="KeyTerm1">y</span>. (It is an error to call <span class="KeyTerm1">append_mutator</span> with an empty <span class="KeyTerm1">x</span>.)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0536"></a><b>function</b> append_mutator(x, y) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0537"></a>    set_tail(last_pair(x), y);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0538"></a> <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0539"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0540"></a>Here <span class="KeyTerm1">last_pair</span> is a function that returns the last pair in its argument:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0541"></a><b>function</b> last_pair(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0542"></a> <b>return</b> is_null(tail(x))</p>
<p class="Sp-text-1"><a id="c003_c3-para-0543"></a>          ? x</p>
<p class="Sp-text-1"><a id="c003_c3-para-0544"></a>          : last_pair(tail(x));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0545"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0546"></a>Consider the interaction</p>
<p class="Sp-text-1"><a id="c003_c3-para-0547"></a><b>const</b> x = list("a", "b");</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0548"></a><b>const</b> y = list("c", "d");</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0549"></a><b>const</b> z = append(x, y);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0550"></a>z;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0551"></a>["a", ["b", ["c", ["d, null]]]]</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0552"></a>tail(x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0553"></a><span class="KeyTerm2"><i>response</i></span></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0554"></a><b>const</b> w = append_mutator(x, y);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0555"></a>w;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0556"></a>["a", ["b", ["c", ["d", null]]]]</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0557"></a>tail(x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0558"></a><span class="KeyTerm2"><i>response</i></span></p>
<p class="paracontinue"><a id="c003_c3-para-0559"></a>What are the missing <i>response</i>s? Draw box-and-pointer diagrams to explain your answer.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0028"></a><a id="c003_c3-title-0029"></a>Exercise 3.13</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0560"></a>Consider the following <span class="KeyTerm1">make_cycle</span> function, which uses the <span class="KeyTerm1">last_pair</span> function defined in exercise 3.12:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0561"></a><b>function</b> make_cycle(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0562"></a>    set_tail(last_pair(x), x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0563"></a> <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0564"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0565"></a>Draw a box-and-pointer diagram that shows the structure <span class="KeyTerm1">z</span> created by</p>
<p class="Sp-text-1"><a id="c003_c3-para-0566"></a><b>const</b> z = make_cycle(list("a", "b", "c"));</p>
<p class="paracontinue"><a id="c003_c3-para-0567"></a>What happens if we try to compute <span class="KeyTerm1">last_pair(z)</span>?</p>
</section>
<section>
<h5><a id="c003_c3-sec-0029"></a><a id="c003_c3-title-0030"></a>Exercise 3.14</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0568"></a>The following function is quite useful, although obscure:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0569"></a><b>function</b> mystery(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0570"></a> <b>function</b> loop(x, y) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0571"></a> <b>if</b> (is_null(x)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0572"></a> <b>return</b> y;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0573"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0574"></a> <b>const</b> temp = tail(x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0575"></a>            set_tail(x, y);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0576"></a> <b>return</b> loop(temp, x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0577"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0578"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0579"></a> <b>return</b> loop(x, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0580"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0581"></a>The function <span class="KeyTerm1">loop</span> uses the “temporary” name <span class="KeyTerm1">temp</span> to hold the old value of the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">x</span>, since the <span class="KeyTerm1">set_tail</span> on the next line destroys the <span class="KeyTerm1">tail</span>. Explain what <span class="KeyTerm1">mystery</span> does in general. Suppose <span class="KeyTerm1">v</span> is defined by</p>
<p class="Sp-text-1"><a id="c003_c3-para-0582"></a><b>const</b> v = list("a", "b", "c", "d");</p>
<p class="paracontinue"><a id="c003_c3-para-0583"></a>Draw the box-and-pointer diagram that represents the list to which <span class="KeyTerm1">v</span> is bound. Suppose that we now evaluate</p>
<p class="Sp-text-1"><a id="c003_c3-para-0584"></a><b>const</b> w = mystery(v);</p>
<p class="paracontinue"><a id="c003_c3-para-0585"></a>Draw box-and-pointer diagrams that show the structures <span class="KeyTerm1">v</span> and <span class="KeyTerm1">w</span> after evaluating this program. What would be printed as the values of <span class="KeyTerm1">v</span> and <span class="KeyTerm1">w</span>?</p>
</section>
<section>
<h5><a id="c003_c3-sec-0030"></a><a id="c003_c3-title-0031"></a>Sharing and identity</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0586"></a>We mentioned in section 3.1.3 the theoretical issues of “sameness” and “change” raised by the introduction of assignment. These issues arise in practice when individual pairs are <i>shared</i> among different data objects. For example, consider the structure formed by</p>
<p class="Sp-text-1"><a id="c003_c3-para-0587"></a><b>const</b> x = list("a", "b");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0588"></a><b>const</b> z1 = pair(x, x);</p>
<p class="paracontinue"><a id="c003_c3-para-0589"></a>As shown in <a id="c003_c3-fig-0016a"></a><a href="#c3-fig-0016">figure 3.16</a>, <span class="KeyTerm1">z1</span> is a pair whose <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> both point to the same pair <span class="KeyTerm1">x</span>. This sharing of <span class="KeyTerm1">x</span> by the <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">z1</span> is a consequence of the straightforward way in which <span class="KeyTerm1">pair</span> is implemented. In general, using <span class="KeyTerm1">pair</span> to construct lists will result in an interlinked structure of pairs in which many individual pairs are shared by many different structures.</p>
<figure id="c003_c3-fig-0016"><img alt="c3-fig-0016.jpg" src="../images/c3-fig-0016.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0016a">Figure 3.16</a></span> <a id="c003_c3-para-0590"></a>The list <span class="KeyTerm1">z1</span> formed by <span class="KeyTerm1">pair(x, x)</span>.</p></figcaption></figure>
<p><a id="c003_c3-para-0591"></a>In contrast to <a href="#c3-fig-0016">figure 3.16</a>, <a id="c003_c3-fig-0017a"></a><a href="#c3-fig-0017">figure 3.17</a> shows the structure created by</p>
<p class="Sp-text-1"><a id="c003_c3-para-0593"></a><b>const</b> z2 = pair(list("a", "b"), list("a", "b"));</p>
<p class="paracontinue"><a id="c003_c3-para-0594"></a>In this structure, the pairs in the two <span class="KeyTerm1">list("a", "b")</span> lists are distinct, although they contain the same strings.<a id="c003_c3-fn-0022a"></a><a href="#c3-fn-0022"><sup>22</sup></a></p>
<figure id="c003_c3-fig-0017"><img alt="c3-fig-0017.jpg" src="../images/c3-fig-0017.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0017a">Figure 3.17</a></span> <a id="c003_c3-para-0592"></a>The list <span class="KeyTerm1">z2</span> formed by <span class="KeyTerm1">pair(list("a", "b"), list("a", "b"))</span>.</p></figcaption></figure>
<p><a id="c003_c3-para-0595"></a>When thought of as a list, <span class="KeyTerm1">z1</span> and <span class="KeyTerm1">z2</span> both represent “the same” list:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0596"></a>list(list("a", "b"), "a", "b")</p>
<p class="paracontinue"><a id="c003_c3-para-0597"></a>In general, sharing is completely undetectable if we operate on lists using only <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>. However, if we allow mutators on list structure, sharing becomes significant. As an example of the difference that sharing can make, consider the following function, which modifies the <span class="KeyTerm1">head</span> of the structure to which it is applied:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0598"></a><b>function</b> set_to_wow(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0599"></a>    set_head(head(x), "wow");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0600"></a> <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0601"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0602"></a>Even though <span class="KeyTerm1">z1</span> and <span class="KeyTerm1">z2</span> are “the same” structure, applying <span class="KeyTerm1">set_to_wow</span> to them yields different results. With <span class="KeyTerm1">z1</span>, altering the <span class="KeyTerm1">head</span> also changes the <span class="KeyTerm1">tail</span>, because in <span class="KeyTerm1">z1</span> the <span class="KeyTerm1">head</span> and the <span class="KeyTerm1">tail</span> are the same pair. With <span class="KeyTerm1">z2</span>, the <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> are distinct, so <span class="KeyTerm1">set_to_wow</span> modifies only the <span class="KeyTerm1">head</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0603"></a>z1;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0604"></a><i>[["a", ["b", null]], ["a", ["b", null]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0605"></a>set_to_wow(z1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0606"></a><i>[["wow", ["b", null]], ["wow", ["b", null]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0607"></a>z2;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0608"></a><i>[["a", ["b", null]], ["a", ["b", null]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0609"></a>set_to_wow(z2);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0610"></a><i>[["wow", ["b", null]], ["a", ["b", null]]]</i></p>
<p><a id="c003_c3-para-0611"></a>One way to detect sharing in list structures is to use the primitive predicate <span class="KeyTerm1">===</span>, which we introduced in section 1.1.6 to test whether two numbers are equal and extended in section 2.3.1 to test whether two strings are equal. When applied to two nonprimitive values, <span class="KeyTerm1">x === y</span> tests whether <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> are the same object (that is, whether <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> are equal as pointers). Thus, with <span class="KeyTerm1">z1</span> and <span class="KeyTerm1">z2</span> as defined in <a href="#c3-fig-0016">figure 3.16 and 3.17</a>, <span class="KeyTerm1">head(z1) === tail(z1)</span> is true and <span class="KeyTerm1">head(z2) === tail(z2)</span> is false.</p>
<p><a id="c003_c3-para-5611"></a>As will be seen in the following sections, we can exploit sharing to greatly extend the repertoire of data structures that can be represented by pairs. On the other hand, sharing can also be dangerous, since modifications made to structures will also affect other structures that happen to share the modified parts. The mutation operations <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span> should be used with care; unless we have a good understanding of how our data objects are shared, mutation can have unanticipated results.<a id="c003_c3-fn-0023a"></a><a href="#c3-fn-0023"><sup>23</sup></a></p>
</section>
<section>
<h5><a id="c003_c3-sec-0031"></a><a id="c003_c3-title-0032"></a>Exercise 3.15</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0612"></a>Draw box-and-pointer diagrams to explain the effect of <span class="KeyTerm1">set_to_wow</span> on the structures <span class="KeyTerm1">z1</span> and <span class="KeyTerm1">z2</span> above.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0032"></a><a id="c003_c3-title-0033"></a>Exercise 3.16</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0613"></a>Ben Bitdiddle decides to write a function to count the number of pairs in any list structure. “It's easy,” he reasons. “The number of pairs in any structure is the number in the <span class="KeyTerm1">head</span> plus the number in the <span class="KeyTerm1">tail</span> plus one more to count the current pair.” So Ben writes the following function</p>
<p class="Sp-text-1"><a id="c003_c3-para-0614"></a><b>function</b> count_pairs(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0615"></a> <b>return</b> ! is_pair(x)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0616"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0617"></a>           : count_pairs(head(x)) +</p>
<p class="Sp-text-1"><a id="c003_c3-para-0618"></a>             count_pairs(tail(x)) + 1;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0619"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0620"></a>Show that this function is not correct. In particular, draw box-and-pointer diagrams representing list structures made up of exactly three pairs for which Ben's function would return 3; return 4; return 7; never return at all.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0033"></a><a id="c003_c3-title-0034"></a>Exercise 3.17</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0621"></a>Devise a correct version of the <span class="KeyTerm1">count_pairs</span> function of exercise 3.16 that returns the number of distinct pairs in any structure. (Hint: Traverse the structure, maintaining an auxiliary data structure that is used to keep track of which pairs have already been counted.)</p>
</section>
<section>
<h5><a id="c003_c3-sec-0034"></a><a id="c003_c3-title-0035"></a>Exercise 3.18</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0622"></a>Write a function that examines a list and determines whether it contains a cycle, that is, whether a program that tried to find the end of the list by taking successive <span class="KeyTerm1">tail</span>s would go into an infinite loop. Exercise 3.13 constructed such lists.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0035"></a><a id="c003_c3-title-0036"></a>Exercise 3.19</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0623"></a>Redo exercise 3.18 using an algorithm that takes only a constant amount of space. (This requires a very clever idea.)</p>
</section>
<section>
<h5><a id="c003_c3-sec-0036"></a><a id="c003_c3-title-0037"></a>Mutation is just assignment</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0624"></a>When we introduced compound data, we observed in section 2.1.3 that pairs can be represented purely in terms of functions:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0625"></a><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0626"></a> <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0627"></a> <b>return</b> m === "head"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0628"></a>           ? x</p>
<p class="Sp-text-1"><a id="c003_c3-para-0629"></a>           : m === "tail"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0630"></a>           ? y</p>
<p class="Sp-text-1"><a id="c003_c3-para-0631"></a>           : error(m, "undefined operation – pair");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0632"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0633"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0634"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0635"></a><b>function</b> head(z) { <b>return</b> z("head"); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0636"></a><b>function</b> tail(z) { <b>return</b> z("tail"); }</p>
<p class="paracontinue"><a id="c003_c3-para-0637"></a>The same observation is true for mutable data. We can implement mutable data objects as functions using assignment and local state. For instance, we can extend the above pair implementation to handle <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span> in a manner analogous to the way we implemented bank accounts using <span class="KeyTerm1">make_account</span> in section 3.1.1:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0638"></a><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0639"></a> <b>function</b> set_x(v) { x = v; }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0640"></a> <b>function</b> set_y(v) { y = v; }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0641"></a> <b>return</b> m =&gt; m === "head"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0642"></a>                ? x</p>
<p class="Sp-text-1"><a id="c003_c3-para-0643"></a>                : m === "tail"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0644"></a>                ? y</p>
<p class="Sp-text-1"><a id="c003_c3-para-0645"></a>                : m === "set_head"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0646"></a>                ? set_x</p>
<p class="Sp-text-1"><a id="c003_c3-para-0647"></a>                : m === "set_tail"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0648"></a>                ? set_y</p>
<p class="Sp-text-1"><a id="c003_c3-para-0649"></a>                : error(m, "undefined operation – pair");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0650"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0651"></a><b>function</b> head(z) { <b>return</b> z("head"); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0652"></a><b>function</b> tail(z) { <b>return</b> z("tail"); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0653"></a><b>function</b> set_head(z, new_value) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0654"></a>    z("set_head")(new_value);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0655"></a> <b>return</b> z;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0656"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0657"></a><b>function</b> set_tail(z, new_value) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0658"></a>    z("set_tail")(new_value);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0659"></a> <b>return</b> z;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0660"></a>}</p>
<p><a id="c003_c3-para-0661"></a>Assignment is all that is needed, theoretically, to account for the behavior of mutable data. As soon as we admit assignment to our language, we raise all the issues, not only of assignment, but of mutable data in general.<a id="c003_c3-fn-0024a"></a><a href="#c3-fn-0024"><sup>24</sup></a></p>
</section>
<section>
<h5><a id="c003_c3-sec-0037"></a><a id="c003_c3-title-0038"></a>Exercise 3.20</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0662"></a>Draw environment diagrams to illustrate the evaluation of the sequence of statements</p>
<p class="Sp-text-1"><a id="c003_c3-para-0663"></a><b>const</b> x = pair(1, 2);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0664"></a><b>const</b> z = pair(x, x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0665"></a>set_head(tail(z), 17);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0666"></a>head(x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0667"></a><i>17</i></p>
<p class="paracontinue"><a id="c003_c3-para-0668"></a>using the functional implementation of pairs given above. (Compare exercise 3.11.)</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0038"></a><span>3.3.2</span> <a id="c003_c3-title-0039"></a>Representing Queues</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0669"></a>The mutators <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span> enable us to use pairs to construct data structures that cannot be built with <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> alone. This section shows how to use pairs to represent a data structure called a queue. Section 3.3.3 will show how to represent data structures called tables.</p>
<p><a id="c003_c3-para-0670"></a>A <i>queue</i> is a sequence in which items are inserted at one end (called the <i>rear</i> of the queue) and deleted from the other end (the <i>front</i>). <a id="c003_c3-fig-0018a"></a><a href="#c3-fig-0018">Figure 3.18</a> shows an initially empty queue in which the items <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> are inserted. Then <span class="KeyTerm1">a</span> is removed, <span class="KeyTerm1">c</span> and <span class="KeyTerm1">d</span> are inserted, and <span class="KeyTerm1">b</span> is removed. Because items are always removed in the order in which they are inserted, a queue is sometimes called a <i>FIFO</i> (first in, first out) buffer.</p>
<figure id="c003_c3-fig-0018"><img alt="c3-fig-0018.jpg" src="../images/c3-fig-0018.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0018a">Figure 3.18</a></span> <a id="c003_c3-para-0671"></a>Queue operations.</p></figcaption></figure>
<p><a id="c003_c3-para-0672"></a>In terms of data abstraction, we can regard a queue as defined by the following set of operations:</p>
<ul style="list-style-type:disc">
<li>a constructor:
<p class="paracontinue"><a id="c003_c3-para-0674"></a><span class="KeyTerm1">make_queue</span>()</p>
<p class="paracontinue"><a id="c003_c3-para-0675"></a>returns an empty queue (a queue containing no items).</p></li>
<li>a predicate:
<p class="paracontinue"><a id="c003_c3-para-0677"></a><span class="KeyTerm1">is_empty_queue</span>(<span class="KeyTerm2"><i>queue</i></span>)</p>
<p class="paracontinue"><a id="c003_c3-para-0678"></a>tests if the queue is empty.</p></li>
<li>a selector:
<p class="paracontinue"><a id="c003_c3-para-0680"></a><span class="KeyTerm1">front_queue</span>(<span class="KeyTerm2"><i>queue</i></span>)</p>
<p class="paracontinue"><a id="c003_c3-para-0681"></a>returns the object at the front of the queue, signaling an error if the queue is empty; it does not modify the queue.</p></li>
<li>two mutators:
<p class="paracontinue"><a id="c003_c3-para-0683"></a><span class="KeyTerm1">insert_queue</span>(<span class="KeyTerm2"><i>queue</i></span>, <span class="KeyTerm2"><i>item</i></span>)</p>
<p class="paracontinue"><a id="c003_c3-para-0684"></a>inserts the item at the rear of the queue and returns the modified queue as its value.</p>
<p class="paracontinue"><a id="c003_c3-para-0685"></a><span class="KeyTerm1">delete_queue</span>(<span class="KeyTerm2"><i>queue</i></span>)</p>
<p class="paracontinue"><a id="c003_c3-para-0686"></a>removes the item at the front of the queue and returns the modified queue as its value, signaling an error if the queue is empty before the deletion.</p></li>
</ul>
<p><a id="c003_c3-para-0687"></a>Because a queue is a sequence of items, we could certainly represent it as an ordinary list; the front of the queue would be the <span class="KeyTerm1">head</span> of the list, inserting an item in the queue would amount to appending a new element at the end of the list, and deleting an item from the queue would just be taking the <span class="KeyTerm1">tail</span> of the list. However, this representation is inefficient, because in order to insert an item we must scan the list until we reach the end. Since the only method we have for scanning a list is by successive <span class="KeyTerm1">tail</span> operations, this scanning requires Θ(<i>n</i>) steps for a list of <i>n</i> items. A simple modification to the list representation overcomes this disadvantage by allowing the queue operations to be implemented so that they require Θ(1) steps; that is, so that the number of steps needed is independent of the length of the queue.</p>
<p><a id="c003_c3-para-5687"></a>The difficulty with the list representation arises from the need to scan to find the end of the list. The reason we need to scan is that, although the standard way of representing a list as a chain of pairs readily provides us with a pointer to the beginning of the list, it gives us no easily accessible pointer to the end. The modification that avoids the drawback is to represent the queue as a list, together with an additional pointer that indicates the final pair in the list. That way, when we go to insert an item, we can consult the rear pointer and so avoid scanning the list.</p>
<p><a id="c003_c3-para-0688"></a>A queue is represented, then, as a pair of pointers, <span class="KeyTerm1">front_ptr</span> and <span class="KeyTerm1">rear_ptr</span>, which indicate, respectively, the first and last pairs in an ordinary list. Since we would like the queue to be an identifiable object, we can use <span class="KeyTerm1">pair</span> to combine the two pointers. Thus, the queue itself will be the <span class="KeyTerm1">pair</span> of the two pointers. <a id="c003_c3-fig-0019a"></a><a href="#c3-fig-0019">Figure 3.19</a> illustrates this representation.</p>
<figure id="c003_c3-fig-0019"><img alt="c3-fig-0019.jpg" src="../images/c3-fig-0019.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0019a">Figure 3.19</a></span> <a id="c003_c3-para-0689"></a>Implementation of a queue as a list with front and rear pointers.</p></figcaption></figure>
<p><a id="c003_c3-para-0690"></a>To define the queue operations we use the following functions, which enable us to select and to modify the front and rear pointers of a queue:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0691"></a><b>function</b> front_ptr(queue) { <b>return</b> head(queue); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0692"></a><b>function</b> rear_ptr(queue) { <b>return</b> tail(queue); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0693"></a><b>function</b> set_front_ptr(queue, item) { set_head(queue, item); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0694"></a><b>function</b> set_rear_ptr(queue, item) { set_tail(queue, item); }</p>
<p><a id="c003_c3-para-0695"></a>Now we can implement the actual queue operations. We will consider a queue to be empty if its front pointer is the empty list:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0696"></a><b>function</b> is_empty_queue(queue) { <b>return</b> is_null(front_ptr(queue)); }</p>
<p class="paracontinue"><a id="c003_c3-para-0697"></a>The <span class="KeyTerm1">make_queue</span> constructor returns, as an initially empty queue, a pair whose <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> are both the empty list:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0698"></a><b>function</b> make_queue() { <b>return</b> pair(<b>null</b>, <b>null</b>); }</p>
<p class="paracontinue"><a id="c003_c3-para-0699"></a>To select the item at the front of the queue, we return the <span class="KeyTerm1">head</span> of the pair indicated by the front pointer:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0700"></a><b>function</b> front_queue(queue) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0701"></a> <b>return</b> is_empty_queue(queue)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0702"></a>           ? error(queue, "front_queue called with an empty queue")</p>
<p class="Sp-text-1"><a id="c003_c3-para-0703"></a>           : head(front_ptr(queue));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0704"></a>}</p>
<p><a id="c003_c3-para-0705"></a>To insert an item in a queue, we follow the method whose result is indicated in <a id="c003_c3-fig-0020a"></a><a href="#c3-fig-0020">figure 3.20</a>. We first create a new pair whose <span class="KeyTerm1">head</span> is the item to be inserted and whose <span class="KeyTerm1">tail</span> is the empty list. If the queue was initially empty, we set the front and rear pointers of the queue to this new pair. Otherwise, we modify the final pair in the queue to point to the new pair, and also set the rear pointer to the new pair.</p>
<p class="Sp-text-1"><a id="c003_c3-para-0707"></a><b>function</b> insert_queue(queue, item) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0708"></a> <b>const</b> new_pair = pair(item, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0709"></a> <b>if</b> (is_empty_queue(queue)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0710"></a>        set_front_ptr(queue, new_pair);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0711"></a>        set_rear_ptr(queue, new_pair);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0712"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0713"></a>        set_tail(rear_ptr(queue), new_pair);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0714"></a>        set_rear_ptr(queue, new_pair);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0715"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0716"></a> <b>return</b> queue;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0717"></a>}</p>
<figure id="c003_c3-fig-0020"><img alt="c3-fig-0020.jpg" src="../images/c3-fig-0020.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0020a">Figure 3.20</a></span> <a id="c003_c3-para-0706"></a>Result of using <span class="KeyTerm1">insert_queue(q, "d")</span> on the queue of <a href="#c3-fig-0019">figure 3.19</a>.</p></figcaption></figure>
<p><a id="c003_c3-para-0718"></a>To delete the item at the front of the queue, we merely modify the front pointer so that it now points at the second item in the queue, which can be found by following the <span class="KeyTerm1">tail</span> pointer of the first item (see <a id="c003_c3-fig-0021a"></a><a href="#c3-fig-0021">figure 3.21</a>):<a id="c003_c3-fn-0025a"></a><a href="#c3-fn-0025"><sup>25</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-0720"></a><b>function</b> delete_queue(queue) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0721"></a> <b>if</b> (is_empty_queue(queue)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0722"></a>        error(queue, "delete_queue called with an empty queue");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0723"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0724"></a>        set_front_ptr(queue, tail(front_ptr(queue)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0725"></a> <b>return</b> queue;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0726"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0727"></a>}</p>
<figure id="c003_c3-fig-0021"><img alt="c3-fig-0021.jpg" src="../images/c3-fig-0021.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0021a">Figure 3.21</a></span> <a id="c003_c3-para-0719"></a>Result of using <span class="KeyTerm1">delete_queue(q)</span> on the queue of <a href="#c3-fig-0020">figure 3.20</a>.</p></figcaption></figure>
<section>
<h5><a id="c003_c3-sec-0039"></a><a id="c003_c3-title-0040"></a>Exercise 3.21</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0728"></a>Ben Bitdiddle decides to test the queue implementation described above. He types in the functions to the JavaScript interpreter and proceeds to try them out:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0729"></a><b>const</b> q1 = make_queue();</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0730"></a>insert_queue(q1, "a");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0731"></a><i>[["a", null], ["a", null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0732"></a>insert_queue(q1, "b");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0733"></a><i>[["a", ["b", null]], ["b", null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0734"></a>delete_queue(q1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0735"></a><i>[["b", null], ["b", null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0736"></a>delete_queue(q1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0737"></a><i>[null, ["b", null]]</i></p>
<p class="paracontinue"><a id="c003_c3-para-0738"></a>“It's all wrong!” he complains. “The interpreter's response shows that the last item is inserted into the queue twice. And when I delete both items, the second <span class="KeyTerm1">b</span> is still there, so the queue isn't empty, even though it's supposed to be.” Eva Lu Ator suggests that Ben has misunderstood what is happening. “It's not that the items are going into the queue twice,” she explains. “It's just that the standard JavaScript printer doesn't know how to make sense of the queue representation. If you want to see the queue printed correctly, you'll have to define your own print function for queues.” Explain what Eva Lu is talking about. In particular, show why Ben's examples produce the printed results that they do. Define a function <span class="KeyTerm1">print_queue</span> that takes a queue as input and prints the sequence of items in the queue.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0040"></a><a id="c003_c3-title-0041"></a>Exercise 3.22</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0739"></a>Instead of representing a queue as a pair of pointers, we can build a queue as a function with local state. The local state will consist of pointers to the beginning and the end of an ordinary list. Thus, the <span class="KeyTerm1">make_queue</span> function will have the form</p>
<p class="Sp-text-1"><a id="c003_c3-para-0740"></a><b>function</b> make_queue() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0741"></a> <b>let</b> front_ptr = <i>. . .</i>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0742"></a> <b>let</b> rear_ptr = <i>. . .</i>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0743"></a>    〈<span class="KeyTerm2"><i>declarations of internal functions</i></span>〉</p>
<p class="Sp-text-1"><a id="c003_c3-para-0744"></a> <b>function</b> dispatch(m) {<i>. . .</i>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0745"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0746"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0747"></a>Complete the definition of <span class="KeyTerm1">make_queue</span> and provide implementations of the queue operations using this representation.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0041"></a><a id="c003_c3-title-0042"></a>Exercise 3.23</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0748"></a>A <i>deque</i> (“double-ended queue”) is a sequence in which items can be inserted and deleted either at the front or at the rear. Operations on deques are the constructor <span class="KeyTerm1">make_deque</span>, the predicate <span class="KeyTerm1">is_empty_deque</span>, selectors <span class="KeyTerm1">front_deque</span> and <span class="KeyTerm1">rear_deque</span>, and mutators <span class="KeyTerm1">front_insert_deque</span>, <span class="KeyTerm1">front_delete_deque</span>, <span class="KeyTerm1">rear_insert_deque</span>, and <span class="KeyTerm1">rear_delete_ deque</span>. Show how to represent deques using pairs, and give implementations of the operations.<a id="c003_c3-fn-0026a"></a><a href="#c3-fn-0026"><sup>26</sup></a> All operations should be accomplished in Θ(1) steps.</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0042"></a><span>3.3.3</span> <a id="c003_c3-title-0043"></a>Representing Tables</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0749"></a>When we studied various ways of representing sets in chapter 2, we mentioned in section 2.3.3 the task of maintaining a table of records indexed by identifying keys. In the implementation of data-directed programming in section 2.4.3, we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures.</p>
<p><a id="c003_c3-para-0750"></a>We first consider a one-dimensional table, in which each value is stored under a single key. We implement the table as a list of records, each of which is implemented as a pair consisting of a key and the associated value. The records are glued together to form a list by pairs whose <span class="KeyTerm1">head</span>s point to successive records. These gluing pairs are called the <i>backbone</i> of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a <i>headed list</i>. A headed list has a special backbone pair at the beginning, which holds a dummy “record”—in this case the arbitrarily chosen string <span class="KeyTerm1">"*table*"</span>. <a id="c003_c3-fig-0022a"></a><a href="#c3-fig-0022">Figure 3.22</a> shows the box-and-pointer diagram for the table</p>
<p class="Sp-text-1"><a id="c003_c3-para-0752"></a>a: 1</p>
<p class="Sp-text-1"><a id="c003_c3-para-0753"></a>b: 2</p>
<p class="Sp-text-1"><a id="c003_c3-para-0754"></a>c: 3</p>
<figure id="c003_c3-fig-0022"><img alt="c3-fig-0022.jpg" src="../images/c3-fig-0022.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0022a">Figure 3.22</a></span> <a id="c003_c3-para-0751"></a>A table represented as a headed list.</p></figcaption></figure>
<p><a id="c003_c3-para-0755"></a>To extract information from a table we use the <span class="KeyTerm1">lookup</span> function, which takes a key as argument and returns the associated value (or <span class="KeyTerm1">undefined</span> if there is no value stored under that key). The function <span class="KeyTerm1">lookup</span> is defined in terms of the <span class="KeyTerm1">assoc</span> operation, which expects a key and a list of records as arguments. Note that <span class="KeyTerm1">assoc</span> never sees the dummy record. The function <span class="KeyTerm1">assoc</span> returns the record that has the given key as its <span class="KeyTerm1">head</span>.<a id="c003_c3-fn-0027a"></a><a href="#c3-fn-0027"><sup>27</sup></a> The function <span class="KeyTerm1">lookup</span> then checks to see that the resulting record returned by <span class="KeyTerm1">assoc</span> is not <span class="KeyTerm1">undefined</span>, and returns the value (the <span class="KeyTerm1">tail</span>) of the record.</p>
<p class="Sp-text-1"><a id="c003_c3-para-0756"></a><b>function</b> lookup(key, table) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0757"></a> <b>const</b> record = assoc(key, tail(table));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0758"></a> <b>return</b> is_undefined(record)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0759"></a>           ? undefined</p>
<p class="Sp-text-1"><a id="c003_c3-para-0760"></a>           : tail(record);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0761"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0762"></a><b>function</b> assoc(key, records) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0763"></a> <b>return</b> is_null(records)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0764"></a>           ? undefined</p>
<p class="Sp-text-1"><a id="c003_c3-para-0765"></a>           : equal(key, head(head(records)))</p>
<p class="Sp-text-1"><a id="c003_c3-para-0766"></a>           ? head(records)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0767"></a>           : assoc(key, tail(records));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0768"></a>}</p>
<p><a id="c003_c3-para-0769"></a>To insert a value in a table under a specified key, we first use <span class="KeyTerm1">assoc</span> to see if there is already a record in the table with this key. If not, we form a new record by <span class="KeyTerm1">pair</span>ing the key with the value, and insert this at the head of the table's list of records, after the dummy record. If there already is a record with this key, we set the <span class="KeyTerm1">tail</span> of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record.<a id="c003_c3-fn-0028a"></a><a href="#c3-fn-0028"><sup>28</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-0770"></a><b>function</b> insert(key, value, table) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0771"></a> <b>const</b> record = assoc(key, tail(table));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0772"></a> <b>if</b> (is_undefined(record)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0773"></a>        set_tail(table,</p>
<p class="Sp-text-1"><a id="c003_c3-para-0774"></a>                 pair(pair(key, value), tail(table)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0775"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0776"></a>        set_tail(record, value);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0777"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0778"></a> <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0779"></a>}</p>
<p><a id="c003_c3-para-0780"></a>To construct a new table, we simply create a list containing just the string <span class="KeyTerm1">"*table*"</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0781"></a><b>function</b> make_table() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0782"></a> <b>return</b> list("*table*");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0783"></a>}</p>
<section>
<h5><a id="c003_c3-sec-0043"></a><a id="c003_c3-title-0044"></a>Two-dimensional tables</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0784"></a>In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. <a id="c003_c3-fig-0023a"></a><a href="#c3-fig-0023">Figure 3.23</a> shows the box-and-pointer diagram for the table</p>
<p class="Sp-text-1"><a id="c003_c3-para-0786"></a>"math":</p>
<p class="Sp-text-1"><a id="c003_c3-para-0787"></a>    "+": 43</p>
<p class="Sp-text-1"><a id="c003_c3-para-0788"></a>    "-": 45</p>
<p class="Sp-text-1"><a id="c003_c3-para-0789"></a>    "*": 42</p>
<p class="Sp-text-1"><a id="c003_c3-para-0790"></a>"letters":</p>
<p class="Sp-text-1"><a id="c003_c3-para-0791"></a>    "a": 97</p>
<p class="Sp-text-1"><a id="c003_c3-para-0792"></a>    "b": 98</p>
<p class="paracontinue"><a id="c003_c3-para-0793"></a>which has two subtables. (The subtables don't need a special header string, since the key that identifies the subtable serves this purpose.)</p>
<figure id="c003_c3-fig-0023"><img alt="c3-fig-0023.jpg" src="../images/c3-fig-0023.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0023a">Figure 3.23</a></span> <a id="c003_c3-para-0785"></a>A two-dimensional table.</p></figcaption></figure>
<p><a id="c003_c3-para-0794"></a>When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable.</p>
<p class="Sp-text-1"><a id="c003_c3-para-0795"></a><b>function</b> lookup(key_1, key_2, table) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0796"></a> <b>const</b> subtable = assoc(key_1, tail(table));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0797"></a> <b>if</b> (is_undefined(subtable)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0798"></a> <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0799"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0800"></a> <b>const</b> record = assoc(key_2, tail(subtable));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0801"></a> <b>return</b> is_undefined(record)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0802"></a>               ? undefined</p>
<p class="Sp-text-1"><a id="c003_c3-para-0803"></a>               : tail(record);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0804"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0805"></a>}</p>
<p><a id="c003_c3-para-0806"></a>To insert a new item under a pair of keys, we use <span class="KeyTerm1">assoc</span> to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record (<span class="KeyTerm1">key_2</span>, <span class="KeyTerm1">value</span>) and insert it into the table under the first key. If a</p>
<p class="paracontinue"><a id="c003_c3-para-0807"></a>subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0808"></a><b>function</b> insert(key_1, key_2, value, table) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0809"></a> <b>const</b> subtable = assoc(key_1, tail(table));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0810"></a> <b>if</b> (is_undefined(subtable)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0811"></a>        set_tail(table,</p>
<p class="Sp-text-1"><a id="c003_c3-para-0812"></a>                 pair(list(key_1, pair(key_2, value)), tail(table)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0813"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0814"></a> <b>const</b> record = assoc(key_2, tail(table));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0815"></a> <b>if</b> (is_undefined(record)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0816"></a>            set_tail(subtable,</p>
<p class="Sp-text-1"><a id="c003_c3-para-0817"></a>                     pair(pair(key_2, value), tail(subtable)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0818"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0819"></a>            set_tail(record, value);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0820"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0821"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0822"></a> <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0823"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0044"></a><a id="c003_c3-title-0045"></a>Creating local tables</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0824"></a>The <span class="KeyTerm1">lookup</span> and <span class="KeyTerm1">insert</span> operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate <span class="KeyTerm1">lookup</span> and <span class="KeyTerm1">insert</span> functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this “table object” supplies the function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0825"></a><b>function</b> make_table() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0826"></a> <b>const</b> local_table = list("*table*");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0827"></a> <b>function</b> lookup(key_1, key_2) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0828"></a> <b>const</b> subtable = assoc(key_1, tail(local_table));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0829"></a> <b>if</b> (is_undefined(subtable)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0830"></a> <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0831"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0832"></a> <b>const</b> record = assoc(key_2, tail(subtable));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0833"></a> <b>return</b> is_undefined(record)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0834"></a>                   ? undefined</p>
<p class="Sp-text-1"><a id="c003_c3-para-0835"></a>                   : tail(record);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0836"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0837"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0838"></a> <b>function</b> insert(key_1, key_2, value) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0839"></a> <b>const</b> subtable = assoc(key_1, tail(local_table));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0840"></a> <b>if</b> (is_undefined(subtable)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0841"></a>            set_tail(local_table,</p>
<p class="Sp-text-1"><a id="c003_c3-para-0842"></a>                     pair(list(key_1, pair(key_2, value)),</p>
<p class="Sp-text-1"><a id="c003_c3-para-0843"></a>                          tail(local_table)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0844"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0845"></a> <b>const</b> record = assoc(key_2, tail(subtable));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0846"></a> <b>if</b> (is_undefined(record)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0847"></a>                set_tail(subtable,</p>
<p class="Sp-text-1"><a id="c003_c3-para-0848"></a>                         pair(pair(key_2, value), tail(subtable)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0849"></a>            } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0850"></a>                set_tail(record, value);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0851"></a>            }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0852"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0853"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0854"></a> <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0855"></a> <b>return</b> m === "lookup"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0856"></a>               ? lookup</p>
<p class="Sp-text-1"><a id="c003_c3-para-0857"></a>               : m === "insert"</p>
<p class="Sp-text-1"><a id="c003_c3-para-0858"></a>               ? insert</p>
<p class="Sp-text-1"><a id="c003_c3-para-0859"></a>               : error(m, "unknown operation – table");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0860"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0861"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0862"></a>}</p>
<p><a id="c003_c3-para-0863"></a>Using <span class="KeyTerm1">make_table</span>, we could implement the <span class="KeyTerm1">get</span> and <span class="KeyTerm1">put</span> operations used in section 2.4.3 for data-directed programming, as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0864"></a><b>const</b> operation_table = make_table();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0865"></a><b>const</b> get = operation_table("lookup");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0866"></a><b>const</b> put = operation_table("insert");</p>
<p class="paracontinue"><a id="c003_c3-para-0867"></a>The function <span class="KeyTerm1">get</span> takes as arguments two keys, and <span class="KeyTerm1">put</span> takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to <span class="KeyTerm1">make_table</span>.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0045"></a><a id="c003_c3-title-0046"></a>Exercise 3.24</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0868"></a>In the table implementations above, the keys are tested for equality using <span class="KeyTerm1">equal</span> (called by <span class="KeyTerm1">assoc</span>). This is not always the appropriate test. For instance, we might have a table with numeric keys in which we don't need an exact match to the number we're looking up, but only a number within some tolerance of it. Design a table constructor <span class="KeyTerm1">make_table</span> that takes as an argument a <span class="KeyTerm1">same_key</span> function that will be used to test “equality” of keys. The function <span class="KeyTerm1">make_table</span> should return a <span class="KeyTerm1">dispatch</span> function that can be used to access appropriate <span class="KeyTerm1">lookup</span> and <span class="KeyTerm1">insert</span> functions for a local table.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0046"></a><a id="c003_c3-title-0047"></a>Exercise 3.25</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0869"></a>Generalizing oneand two-dimensional tables, show how to implement a table in which values are stored under an arbitrary number of keys and different values may be stored under different numbers of keys. The <span class="KeyTerm1">lookup</span> and <span class="KeyTerm1">insert</span> functions should take as input a list of keys used to access the table.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0047"></a><a id="c003_c3-title-0048"></a>Exercise 3.26</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0870"></a>To search a table as implemented above, one needs to scan through the list of records. This is basically the unordered list representation of section 2.3.3. For large tables, it may be more efficient to structure the table in a different manner. Describe a table implementation where the (key, value) records are organized using a binary tree, assuming that keys can be ordered in some way (e.g., numerically or alphabetically). (Compare exercise 2.66 of chapter 2.)</p>
</section>
<section>
<h5><a id="c003_c3-sec-0048"></a><a id="c003_c3-title-0049"></a>Exercise 3.27</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0871"></a><i>Memoization</i> (also called <i>tabulation</i>) is a technique that enables a function to record, in a local table, values that have previously been computed. This technique can make a vast difference in the performance of a program. A memoized function maintains a table in which values of previous calls are stored using as keys the arguments that produced the values. When the memoized function is asked to compute a value, it first checks the table to see if the value is already there and, if so, just returns that value. Otherwise, it computes the new value in the ordinary way and stores this in the table. As an example of memoization, recall from section 1.2.2 the exponential process for computing Fibonacci numbers:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0872"></a><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0873"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0874"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0875"></a>           : n === 1</p>
<p class="Sp-text-1"><a id="c003_c3-para-0876"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c003_c3-para-0877"></a>           : fib(n - 1) + fib(n - 2);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0878"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0879"></a>The memoized version of the same function is</p>
<p class="Sp-text-1"><a id="c003_c3-para-0880"></a><b>const</b> memo_fib = memoize(n =&gt; n === 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0881"></a>                              ? 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0882"></a>                              : n === 1</p>
<p class="Sp-text-1"><a id="c003_c3-para-0883"></a>                              ? 1</p>
<p class="Sp-text-1"><a id="c003_c3-para-0884"></a>                              : memo_fib(n - 1) +</p>
<p class="Sp-text-1"><a id="c003_c3-para-0885"></a>                                memo_fib(n - 2)</p>
<p class="Sp-text-1"><a id="c003_c3-para-0886"></a>                        );</p>
<p class="paracontinue"><a id="c003_c3-para-0887"></a>where the memoizer is defined as</p>
<p class="Sp-text-1"><a id="c003_c3-para-0888"></a><b>function</b> memoize(f) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0889"></a> <b>const</b> table = make_table();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0890"></a> <b>return</b> x =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0891"></a> <b>const</b> previously_computed_result =</p>
<p class="Sp-text-1"><a id="c003_c3-para-0892"></a>                   lookup(x, table);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0893"></a> <b>if</b> (is_undefined(previously_computed_result)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0894"></a> <b>const</b> result = f(x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0895"></a>                   insert(x, result, table);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0896"></a> <b>return</b> result;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0897"></a>               } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0898"></a> <b>return</b> previously_computed_result;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0899"></a>               }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0900"></a>           };</p>
<p class="Sp-text-1"><a id="c003_c3-para-0901"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0902"></a>Draw an environment diagram to analyze the computation of <span class="KeyTerm1">memo_fib(3)</span>. Explain why <span class="KeyTerm1">memo_fib</span> computes the <i>n</i>th Fibonacci number in a number of steps proportional to <i>n</i>. Would the scheme still work if we had simply defined <span class="KeyTerm1">memo_fib</span> to be <span class="KeyTerm1">memoize(fib)</span>?</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0049"></a><span>3.3.4</span> <a id="c003_c3-title-0050"></a>A Simulator for Digital Circuits</h3>
<p class="paraaftertitle"><a id="c003_c3-para-0903"></a>Designing complex digital systems, such as computers, is an important engineering activity. Digital systems are constructed by interconnecting simple elements. Although the behavior of these individual elements is simple, networks of them can have very complex behavior. Computer simulation of proposed circuit designs is an important tool used by digital systems engineers. In this section we design a system for performing digital logic simulations. This system typifies a kind of program called an <i>event-driven simulation</i>, in which actions (“events”) trigger further events that happen at a later time, which in turn trigger more events, and so on.</p>
<p><a id="c003_c3-para-0904"></a>Our computational model of a circuit will be composed of objects that correspond to the elementary components from which the circuit is constructed. There are <i>wires</i>, which carry <i>digital signals</i>. A digital signal may at any moment have only one of two possible values, 0 and 1. There are also various types of digital <i>function boxes</i>, which connect wires carrying input signals to other output wires. Such boxes produce output signals computed from their input signals. The output signal is delayed by a time that depends on the type of the function box. For example, an <i>inverter</i> is a primitive function box that inverts its input. If the input signal to an inverter changes to 0, then one <i>inverter-delay</i> later the inverter will change its output signal to 1. If the input signal to an inverter changes to 1, then one <i>inverter-delay</i> later the inverter will change its output signal to 0. We draw an inverter symbolically as in <a id="c003_c3-fig-0024a"></a><a href="#c3-fig-0024">figure 3.24</a>. An <i>and-gate</i>, also shown in <a href="#c3-fig-0024">figure 3.24</a>, is a primitive function box with two inputs and one output. It drives its output signal to a value that is the <i>logical and</i> of the inputs. That is, if both of its input signals become 1, then one <i>and-gate-delay</i> time later the and-gate will force its output signal to be 1; otherwise the output will be 0. An <i>or-gate</i> is a similar two-input primitive function box that drives its output signal to a value that is the <i>logical or</i> of the inputs. That is, the output will become 1 if at least one of the input signals is 1; otherwise the output will become 0.</p>
<figure id="c003_c3-fig-0024"><img alt="c3-fig-0024.jpg" src="../images/c3-fig-0024.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0024a">Figure 3.24</a></span> <a id="c003_c3-para-0905"></a>Primitive functions in the digital logic simulator.</p></figcaption></figure>
<p><a id="c003_c3-para-0906"></a>We can connect primitive functions together to construct more complex functions. To accomplish this we wire the outputs of some function boxes to the inputs of other function boxes. For example, the <i>half-adder</i> circuit shown in <a id="c003_c3-fig-0025a"></a><a href="#c3-fig-0025">figure 3.25</a> consists of an or-gate, two and-gates, and an inverter. It takes two input signals, <i>A</i> and <i>B</i>, and has two output signals, <i>S</i> and <i>C</i>. <i>S</i> will become 1 whenever precisely one of <i>A</i> and <i>B</i> is 1, and <i>C</i> will become 1 whenever <i>A</i> and <i>B</i> are both 1. We can see from the figure that, because of the delays involved, the outputs may be generated at different times. Many of the difficulties in the design of digital circuits arise from this fact.</p>
<figure id="c003_c3-fig-0025"><img alt="c3-fig-0025.jpg" src="../images/c3-fig-0025.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0025a">Figure 3.25</a></span> <a id="c003_c3-para-0907"></a>A half-adder circuit.</p></figcaption></figure>
<p><a id="c003_c3-para-0908"></a>We will now build a program for modeling the digital logic circuits we wish to study. The program will construct computational objects modeling the wires, which will “hold” the signals. Function boxes will be modeled by functions that enforce the correct relationships among the signals.</p>
<p><a id="c003_c3-para-0909"></a>One basic element of our simulation will be a function <span class="KeyTerm1">make_wire</span>, which constructs wires. For example, we can construct six wires as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0910"></a><b>const</b> a = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0911"></a><b>const</b> b = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0912"></a><b>const</b> c = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0913"></a><b>const</b> d = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0914"></a><b>const</b> e = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0915"></a><b>const</b> s = make_wire();</p>
<p class="paracontinue"><a id="c003_c3-para-0916"></a>We attach a function box to a set of wires by calling a function that constructs that kind of box. The arguments to the constructor function are the wires to be attached to the box. For example, given that we can construct and-gates, or-gates, and inverters, we can wire together the half-adder shown in <a href="#c3-fig-0025">figure 3.25</a>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0917"></a>or_gate(a, b, d);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0918"></a><i>"ok"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0919"></a>and_gate(a, b, c);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0920"></a><i>"ok"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0921"></a>inverter(c, e);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0922"></a><i>"ok"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-0923"></a>and_gate(d, e, s);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0924"></a><i>"ok"</i></p>
<p><a id="c003_c3-para-0925"></a>Better yet, we can explicitly name this operation by defining a function <span class="KeyTerm1">half_ adder</span> that constructs this circuit, given the four external wires to be attached to the half-adder:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0926"></a><b>function</b> half_adder(a, b, s, c) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0927"></a> <b>const</b> d = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0928"></a> <b>const</b> e = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0929"></a>    or_gate(a, b, d);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0930"></a>    and_gate(a, b, c);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0931"></a>    inverter(c, e);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0932"></a>    and_gate(d, e, s);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0933"></a> <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0934"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0935"></a>The advantage of making this definition is that we can use <span class="KeyTerm1">half_adder</span> itself as a building block in creating more complex circuits. <a id="c003_c3-fig-0026a"></a><a href="#c3-fig-0026">Figure 3.26</a>, for example, shows a <i>full-adder</i> composed of two half-adders and an or-gate.<a id="c003_c3-fn-0029a"></a><a href="#c3-fn-0029"><sup>29</sup></a> We can construct a fulladder as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0937"></a><b>function</b> full_adder(a, b, c_in, sum, c_out) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0938"></a> <b>const</b> s = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0939"></a> <b>const</b> c1 = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0940"></a> <b>const</b> c2 = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-0941"></a>    half_adder(b, c_in, s, c1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0942"></a>    half_adder(a, s, sum, c2);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0943"></a>    or_gate(c1, c2, c_out);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0944"></a> <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0945"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-0946"></a>Having defined <span class="KeyTerm1">full_adder</span> as a function, we can now use it as a building block for creating still more complex circuits. (For example, see exercise 3.30.)</p>
<figure id="c003_c3-fig-0026"><img alt="c3-fig-0026.jpg" src="../images/c3-fig-0026.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0026a">Figure 3.26</a></span> <a id="c003_c3-para-0936"></a>A full-adder circuit.</p></figcaption></figure>
<p><a id="c003_c3-para-0947"></a>In essence, our simulator provides us with the tools to construct a language of circuits. If we adopt the general perspective on languages with which we approached the study of JavaScript in section 1.1, we can say that the primitive function boxes form the primitive elements of the language, that wiring boxes together provides a means of combination, and that specifying wiring patterns as functions serves as a means of abstraction.</p>
<section>
<h5><a id="c003_c3-sec-0050"></a><a id="c003_c3-title-0051"></a>Primitive function boxes</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0948"></a>The primitive function boxes implement the “forces” by which a change in the signal on one wire influences the signals on other wires. To build function boxes, we use the following operations on wires:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">get_signal(</span><i>wire</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-0950"></a>returns the current value of the signal on the wire.</p></li>
<li><span class="KeyTerm1">set_signal(</span><i>wire</i><span class="KeyTerm1">,</span> <i>new</i>-<i>value</i><span class="KeyTerm1">)</span>:
<p class="paracontinue"><a id="c003_c3-para-0952"></a>changes the value of the signal on the wire to the new value.</p></li>
<li><span class="KeyTerm1">add_action(</span><i>wire</i><span class="KeyTerm1">,</span> <i>function</i>-<i>of</i> -<i>no</i>-<i>arguments</i><span class="KeyTerm1">)</span>:
<p class="paracontinue"><a id="c003_c3-para-0954"></a>asserts that the designated function should be run whenever the signal on the wire changes value. Such functions are the vehicles by which changes in the signal value on the wire are communicated to other wires.</p></li>
</ul>
<p class="paracontinue"><a id="c003_c3-para-0955"></a>In addition, we will make use of a function <span class="KeyTerm1">after_delay</span> that takes a time delay and a function to be run and executes the given function after the given delay.</p>
<p><a id="c003_c3-para-0956"></a>Using these functions, we can define the primitive digital logic functions. To connect an input to an output through an inverter, we use <span class="KeyTerm1">add_action</span> to associate with the input wire a function that will be run whenever the signal on the input wire changes value. The function computes the <span class="KeyTerm1">logical_not</span> of the input signal, and then, after one <span class="KeyTerm1">inverter_delay</span>, sets the output signal to be this new value:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0957"></a><b>function</b> inverter(input, output) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0958"></a> <b>function</b> invert_input() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0959"></a> <b>const</b> new_value = logical_not(get_signal(input));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0960"></a>        after_delay(inverter_delay,</p>
<p class="Sp-text-1"><a id="c003_c3-para-0961"></a>                    () =&gt; set_signal(output, new_value));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0962"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0963"></a>    add_action(input, invert_input);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0964"></a> <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0965"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-0966"></a><b>function</b> logical_not(s) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0967"></a> <b>return</b> s === 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0968"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c003_c3-para-0969"></a>           : s === 1</p>
<p class="Sp-text-1"><a id="c003_c3-para-0970"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-0971"></a>           : error(s, "invalid signal");</p>
<p class="Sp-text-1"><a id="c003_c3-para-0972"></a>}</p>
<p><a id="c003_c3-para-0973"></a>An and-gate is a little more complex. The action function must be run if either of the inputs to the gate changes. It computes the <span class="KeyTerm1">logical_and</span> (using a function analogous to <span class="KeyTerm1">logical_not</span>) of the values of the signals on the input wires and sets up a change to the new value to occur on the output wire after one <span class="KeyTerm1">and_gate_delay</span>.</p>
<p class="Sp-text-1"><a id="c003_c3-para-0974"></a><b>function</b> and_gate(a1, a2, output) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0975"></a> <b>function</b> and_action_function() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0976"></a> <b>const</b> new_value = logical_and(get_signal(a1),</p>
<p class="Sp-text-1"><a id="c003_c3-para-0977"></a>                                      get_signal(a2));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0978"></a>        after_delay(and_gate_delay,</p>
<p class="Sp-text-1"><a id="c003_c3-para-0979"></a>                    () =&gt; set_signal(output, new_value));</p>
<p class="Sp-text-1"><a id="c003_c3-para-0980"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-0981"></a>    add_action(a1, and_action_function);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0982"></a>    add_action(a2, and_action_function);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0983"></a> <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0984"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0051"></a><a id="c003_c3-title-0052"></a>Exercise 3.28</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0985"></a>Define an or-gate as a primitive function box. Your <span class="KeyTerm1">or_gate</span> constructor should be similar to <span class="KeyTerm1">and_gate</span>.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0052"></a><a id="c003_c3-title-0053"></a>Exercise 3.29</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0986"></a>Another way to construct an or-gate is as a compound digital logic device, built from andgates and inverters. Define a function <span class="KeyTerm1">or_gate</span> that accomplishes this. What is the delay time of the or-gate in terms of <span class="KeyTerm1">and_gate_delay</span> and <span class="KeyTerm1">inverter_delay</span>?</p>
</section>
<section>
<h5><a id="c003_c3-sec-0053"></a><a id="c003_c3-title-0054"></a>Exercise 3.30</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0987"></a><a id="c003_c3-fig-0027a"></a><a href="#c3-fig-0027">Figure 3.27</a> shows a <i>ripple-carry adder</i> formed by stringing together <i>n</i> full-adders. This is the simplest form of parallel adder for adding two <i>n</i>-bit binary numbers. The inputs <i>A</i><sub>1</sub>, <i>A</i><sub>2</sub>, <i>A</i><sub>3</sub>, . . ., <i>A<sub>n</sub></i> and <i>B</i><sub>1</sub>, <i>B</i><sub>2</sub>, <i>B</i><sub>3</sub>, . . ., <i>B<sub>n</sub></i> are the two binary numbers to be added (each <i>A<sub>k</sub></i> and <i>B<sub>k</sub></i> is a 0 or a 1). The circuit generates <i>S</i><sub>1</sub>, <i>S</i><sub>2</sub>, <i>S</i><sub>3</sub>, . . ., <i>S<sub>n</sub></i>, the <i>n</i> bits of the sum, and <i>C</i>, the carry from the addition. Write a function <span class="KeyTerm1">ripple_carry_adder</span> that generates this circuit. The function should take as arguments three lists of <i>n</i> wires each—the <i>A<sub>k</sub></i>, the <i>B<sub>k</sub></i>, and the <i>S<sub>k</sub></i>—and also another wire <i>C</i>. The major drawback of the ripple-carry adder is the need to wait for the carry signals to propagate. What is the delay needed to obtain the complete output from an <i>n</i>-bit ripple-carry adder, expressed in terms of the delays for and-gates, or-gates, and inverters?</p>
<figure id="c003_c3-fig-0027"><img alt="c3-fig-0027.jpg" src="../images/c3-fig-0027.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0027a">Figure 3.27</a></span> <a id="c003_c3-para-0988"></a>A ripple-carry adder for <i>n</i>-bit numbers.</p></figcaption></figure>
</section>
<section>
<h5><a id="c003_c3-sec-0054"></a><a id="c003_c3-title-0055"></a>Representing wires</h5>
<p class="paraaftertitle"><a id="c003_c3-para-0989"></a>A wire in our simulation will be a computational object with two local state variables: a <span class="KeyTerm1">signal_value</span> (initially taken to be 0) and a collection of <span class="KeyTerm1">action_functions</span> to be run when the signal changes value. We implement the wire, using messagepassing style, as a collection of local functions together with a <span class="KeyTerm1">dispatch</span> function that selects the appropriate local operation, just as we did with the simple bankaccount object in section 3.1.1:</p>
<p class="Sp-text-1"><a id="c003_c3-para-0990"></a><b>function</b> make_wire() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0991"></a> <b>let</b> signal_value = 0;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0992"></a> <b>let</b> action_functions = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0993"></a> <b>function</b> set_my_signal(new_value) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0994"></a> <b>if</b> (signal_value !== new_value) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0995"></a>            signal_value = new_value;</p>
<p class="Sp-text-1"><a id="c003_c3-para-0996"></a> <b>return</b> call_each(action_functions);</p>
<p class="Sp-text-1"><a id="c003_c3-para-0997"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-0998"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c003_c3-para-0999"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1000"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1001"></a> <b>function</b> accept_action_function(fun) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1002"></a>        action_functions = pair(fun, action_functions);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1003"></a>        fun();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1004"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1005"></a> <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1006"></a> <b>return</b> m === "get_signal"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1007"></a>               ? signal_value</p>
<p class="Sp-text-1"><a id="c003_c3-para-1008"></a>               : m === "set_signal"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1009"></a>               ? set_my_signal</p>
<p class="Sp-text-1"><a id="c003_c3-para-1010"></a>               : m === "add_action"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1011"></a>               ? accept_action_function</p>
<p class="Sp-text-1"><a id="c003_c3-para-1012"></a>               : error(m, "unknown operation – wire");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1013"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1014"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1015"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1016"></a>The local function <span class="KeyTerm1">set_my_signal</span> tests whether the new signal value changes the signal on the wire. If so, it runs each of the action functions, using the following function <span class="KeyTerm1">call_each</span>, which calls each of the items in a list of no-argument functions:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1017"></a><b>function</b> call_each(functions) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1018"></a> <b>if</b> (is_null(functions)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1019"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1020"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1021"></a>        head(functions)();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1022"></a> <b>return</b> call_each(tail(functions));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1023"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1024"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1025"></a>The local function <span class="KeyTerm1">accept_action_function</span> adds the given function to the list of functions to be run, and then runs the new function once. (See exercise 3.31.)</p>
<p><a id="c003_c3-para-1026"></a>With the local <span class="KeyTerm1">dispatch</span> function set up as specified, we can provide the following functions to access the local operations on wires:<a id="c003_c3-fn-0030a"></a><a href="#c3-fn-0030"><sup>30</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1027"></a><b>function</b> get_signal(wire) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1028"></a> <b>return</b> wire("get_signal");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1029"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1030"></a><b>function</b> set_signal(wire, new_value) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1031"></a> <b>return</b> wire("set_signal")(new_value);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1032"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1033"></a><b>function</b> add_action(wire, action_function) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1034"></a> <b>return</b> wire("add_action")(action_function);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1035"></a>}</p>
<p><a id="c003_c3-para-1036"></a>Wires, which have time-varying signals and may be incrementally attached to devices, are typical of mutable objects. We have modeled them as functions with local state variables that are modified by assignment. When a new wire is created, a new set of state variables is allocated (by the <span class="KeyTerm1"><b>let</b></span> statements in <span class="KeyTerm1">make_wire</span>) and a new <span class="KeyTerm1">dispatch</span> function is constructed and returned, capturing the environment with the new state variables.</p>
<p><a id="c003_c3-para-1037"></a>The wires are shared among the various devices that have been connected to them. Thus, a change made by an interaction with one device will affect all the other devices attached to the wire. The wire communicates the change to its neighbors by calling the action functions provided to it when the connections were established.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0055"></a><a id="c003_c3-title-0056"></a>The agenda</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1038"></a>The only thing needed to complete the simulator is <span class="KeyTerm1">after_delay</span>. The idea here is that we maintain a data structure, called an <i>agenda</i>, that contains a schedule of things to do. The following operations are defined for agendas:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">make_agenda()</span>:
<p class="paracontinue"><a id="c003_c3-para-1040"></a>returns a new empty agenda.</p></li>
<li><span class="KeyTerm1">is_empty_agenda(</span><i>agenda</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-1042"></a>is true if the specified agenda is empty.</p></li>
<li><span class="KeyTerm1">first_agenda_item(</span><i>agenda</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-1044"></a>returns the first item on the agenda.</p></li>
<li><span class="KeyTerm1">remove_first_agenda_item(</span><i>agenda</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-1046"></a>modifies the agenda by removing the first item.</p></li>
<li><span class="KeyTerm1">add_to_agenda(</span><i>time</i><span class="KeyTerm1">,</span> <i>action</i><span class="KeyTerm1">,</span> <i>agenda</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-1048"></a>modifies the agenda by adding the given action function to be run at the specified time.</p></li>
<li><span class="KeyTerm1">current_time(</span><i>agenda</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-1050"></a>returns the current simulation time.</p></li>
</ul>
<p><a id="c003_c3-para-1051"></a>The particular agenda that we use is denoted by <span class="KeyTerm1">the_agenda</span>. The function <span class="KeyTerm1">after_delay</span> adds new elements to <span class="KeyTerm1">the_agenda</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1052"></a><b>function</b> after_delay(delay, action) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1053"></a>    add_to_agenda(delay + current_time(the_agenda),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1054"></a>                  action,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1055"></a>                  the_agenda);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1056"></a>}</p>
<p><a id="c003_c3-para-1057"></a>The simulation is driven by the function <span class="KeyTerm1">propagate</span>, which executes each function on <span class="KeyTerm1">the_agenda</span> in sequence. In general, as the simulation runs, new items will be added to the agenda, and <span class="KeyTerm1">propagate</span> will continue the simulation as long as there are items on the agenda:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1058"></a><b>function</b> propagate() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1059"></a> <b>if</b> (is_empty_agenda(the_agenda)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1060"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1061"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1062"></a> <b>const</b> first_item = first_agenda_item(the_agenda);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1063"></a>        first_item();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1064"></a>        remove_first_agenda_item(the_agenda);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1065"></a> <b>return</b> propagate();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1066"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1067"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0056"></a><a id="c003_c3-title-0057"></a>A sample simulation</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1068"></a>The following function, which places a “probe” on a wire, shows the simulator in action. The probe tells the wire that, whenever its signal changes value, it should print the new signal value, together with the current time and a name that identifies the wire.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1069"></a><b>function</b> probe(name, wire) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1070"></a>    add_action(wire,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1071"></a>               () =&gt; display(name + " " +</p>
<p class="Sp-text-1"><a id="c003_c3-para-1072"></a>                             stringify(current_time(the_agenda)) +</p>
<p class="Sp-text-1"><a id="c003_c3-para-1073"></a>                             ", new value = " +</p>
<p class="Sp-text-1"><a id="c003_c3-para-1074"></a>                             stringify(get_signal(wire))));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1075"></a>}</p>
<p><a id="c003_c3-para-1076"></a>We begin by initializing the agenda and specifying delays for the primitive function boxes:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1077"></a><b>const</b> the_agenda = make_agenda();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1078"></a><b>const</b> inverter_delay = 2;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1079"></a><b>const</b> and_gate_delay = 3;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1080"></a><b>const</b> or_gate_delay = 5;</p>
<p class="paracontinue"><a id="c003_c3-para-1081"></a>Now we define four wires, placing probes on two of them:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1082"></a><b>const</b> input_1 = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1083"></a><b>const</b> input_2 = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1084"></a><b>const</b> sum = make_wire();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1085"></a><b>const</b> carry = make_wire();</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-1086"></a>probe("sum", sum);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1087"></a><i>"sum 0, new value = 0"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-1088"></a>probe("carry", carry);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1089"></a><i>"carry 0, new value = 0"</i></p>
<p class="paracontinue"><a id="c003_c3-para-1090"></a>Next we connect the wires in a half-adder circuit (as in <a href="#c3-fig-0025">figure 3.25</a>), set the signal on <span class="KeyTerm1">input_1</span> to 1, and run the simulation:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1091"></a>half_adder(input_1, input_2, sum, carry);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1092"></a><i>"ok"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-1093"></a>set_signal(input_1, 1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1094"></a><i>"done"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-1095"></a>propagate();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1096"></a><i>"sum 8, new value = 1"</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-1097"></a><i>"done"</i></p>
<p class="paracontinue"><a id="c003_c3-para-1098"></a>The <span class="KeyTerm1">sum</span> signal changes to 1 at time 8. We are now eight time units from the beginning of the simulation. At this point, we can set the signal on <span class="KeyTerm1">input_2</span> to 1 and allow the values to propagate:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1099"></a>set_signal(input_2, 1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1100"></a><i>"done"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-1101"></a>propagate();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1102"></a><i>"carry 11, new value = 1"</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-1103"></a><i>"sum 16, new value = 0"</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-5103"></a><i>"done"</i></p>
<p class="paracontinue"><a id="c003_c3-para-1104"></a>The <span class="KeyTerm1">carry</span> changes to 1 at time 11 and the <span class="KeyTerm1">sum</span> changes to 0 at time 16.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0057"></a><a id="c003_c3-title-0058"></a>Exercise 3.31</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1105"></a>The internal function <span class="KeyTerm1">accept_action_function</span> defined in <span class="KeyTerm1">make_wire</span> specifies that when a new action function is added to a wire, the function is immediately run. Explain why this initialization is necessary. In particular, trace through the half-adder example in the paragraphs above and say how the system's response would differ if we had defined <span class="KeyTerm1">accept_action_function</span> as</p>
<p class="Sp-text-1"><a id="c003_c3-para-1106"></a><b>function</b> accept_action_function(fun) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1107"></a>    action_functions = pair(fun, action_functions);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1108"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0058"></a><a id="c003_c3-title-0059"></a>Implementing the agenda</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1109"></a>Finally, we give details of the agenda data structure, which holds the functions that are scheduled for future execution.</p>
<p><a id="c003_c3-para-1110"></a>The agenda is made up of <i>time segments</i>. Each time segment is a pair consisting of a number (the time) and a queue (see exercise 3.32) that holds the functions that are scheduled to be run during that time segment.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1111"></a><b>function</b> make_time_segment(time, queue) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1112"></a> <b>return</b> pair(time, queue);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1113"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1114"></a><b>function</b> segment_time(s) { <b>return</b> head(s); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1115"></a><b>function</b> segment_queue(s) { <b>return</b> tail(s); }</p>
<p class="paracontinue"><a id="c003_c3-para-1116"></a>We will operate on the time-segment queues using the queue operations described in section 3.3.2.</p>
<p><a id="c003_c3-para-1117"></a>The agenda itself is a one-dimensional table of time segments. It differs from the tables described in section 3.3.3 in that the segments will be sorted in order of increasing time. In addition, we store the <i>current time</i> (i.e., the time of the last action that was processed) at the head of the agenda. A newly constructed agenda has no time segments and has a current time of 0:<a id="c003_c3-fn-0031a"></a><a href="#c3-fn-0031"><sup>31</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1118"></a><b>function</b> make_agenda() { <b>return</b> list(0); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1119"></a><b>function</b> current_time(agenda) { <b>return</b> head(agenda); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1120"></a><b>function</b> set_current_time(agenda, time) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1121"></a>    set_head(agenda, time);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1122"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1123"></a><b>function</b> segments(agenda) { <b>return</b> tail(agenda); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1124"></a><b>function</b> set_segments(agenda, segs) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1125"></a>    set_tail(agenda, segs);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1126"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1127"></a><b>function</b> first_segment(agenda) { <b>return</b> head(segments(agenda)); }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1128"></a><b>function</b> rest_segments(agenda) { <b>return</b> tail(segments(agenda)); }</p>
<p><a id="c003_c3-para-1129"></a>An agenda is empty if it has no time segments:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1130"></a><b>function</b> is_empty_agenda(agenda) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1131"></a> <b>return</b> is_null(segments(agenda));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1132"></a>}</p>
<p><a id="c003_c3-para-1133"></a>To add an action to an agenda, we first check if the agenda is empty. If so, we create a time segment for the action and install this in the agenda. Otherwise, we scan the agenda, examining the time of each segment. If we find a segment for our appointed time, we add the action to the associated queue. If we reach a time later than the one to which we are appointed, we insert a new time segment into the agenda just before it. If we reach the end of the agenda, we must create a new time segment at the end.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1134"></a><b>function</b> add_to_agenda(time, action, agenda) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1135"></a> <b>function</b> belongs_before(segs) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1136"></a> <b>return</b> is_null(segs) || time &lt; segment_time(head(segs));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1137"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1138"></a> <b>function</b> make_new_time_segment(time, action) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1139"></a> <b>const</b> q = make_queue();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1140"></a>        insert_queue(q, action);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1141"></a> <b>return</b> make_time_segment(time, q);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1142"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1143"></a> <b>function</b> add_to_segments(segs) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1144"></a> <b>if</b> (segment_time(head(segs)) === time) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1145"></a>            insert_queue(segment_queue(head(segs)), action);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1146"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1147"></a> <b>const</b> rest = tail(segs);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1148"></a> <b>if</b> (belongs_before(rest)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1149"></a>                set_tail(segs, pair(make_new_time_segment(time, action),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1150"></a>                                    tail(segs)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1151"></a>            } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1152"></a>                add_to_segments(rest);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1153"></a>            }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1154"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1155"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1156"></a> <b>const</b> segs = segments(agenda);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1157"></a> <b>if</b> (belongs_before(segs)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1158"></a>        set_segments(agenda,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1159"></a>                    pair(make_new_time_segment(time, action), segs));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1160"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1161"></a>        add_to_segments(segs);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1162"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1163"></a>}</p>
<p><a id="c003_c3-para-1164"></a>The function that removes the first item from the agenda deletes the item at the front of the queue in the first time segment. If this deletion makes the time segment empty, we remove it from the list of segments:<a id="c003_c3-fn-0032a"></a><a href="#c3-fn-0032"><sup>32</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1165"></a><b>function</b> remove_first_agenda_item(agenda) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1166"></a> <b>const</b> q = segment_queue(first_segment(agenda));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1167"></a>    delete_queue(q);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1168"></a> <b>if</b> (is_empty_queue(q)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1169"></a>        set_segments(agenda, rest_segments(agenda));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1170"></a>    } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1171"></a>}</p>
<p><a id="c003_c3-para-1172"></a>The first agenda item is found at the head of the queue in the first time segment. Whenever we extract an item, we also update the current time:<a id="c003_c3-fn-0033a"></a><a href="#c3-fn-0033"><sup>33</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1173"></a><b>function</b> first_agenda_item(agenda) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1174"></a> <b>if</b> (is_empty_agenda(agenda)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1175"></a>        error("agenda is empty – first_agenda_item");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1176"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1177"></a> <b>const</b> first_seg = first_segment(agenda);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1178"></a>        set_current_time(agenda, segment_time(first_seg));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1179"></a> <b>return</b> front_queue(segment_queue(first_seg));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1180"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1181"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0059"></a><a id="c003_c3-title-0060"></a>Exercise 3.32</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1182"></a>The functions to be run during each time segment of the agenda are kept in a queue. Thus, the functions for each segment are called in the order in which they were added to the agenda (first in, first out). Explain why this order must be used. In particular, trace the behavior of an and-gate whose inputs change from 0,1 to 1,0 in the same segment and say how the behavior would differ if we stored a segment's functions in an ordinary list, adding and removing functions only at the front (last in, first out).</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0060"></a><span>3.3.5</span> <a id="c003_c3-title-0061"></a>Propagation of Constraints</h3>
<p class="paraaftertitle"><a id="c003_c3-para-1183"></a>Computer programs are traditionally organized as one-directional computations, which perform operations on prespecified arguments to produce desired outputs. On the other hand, we often model systems in terms of relations among quantities. For example, a mathematical model of a mechanical structure might include the information that the deflection <i>d</i> of a metal rod is related to the force <i>F</i> on the rod, the length <i>L</i> of the rod, the cross-sectional area <i>A</i>, and the elastic modulus <i>E</i> via the equation</p>
<p class="Sp-text-2"><a id="c003_c3-para-1184"></a><i>dAE</i> = <i>FL</i></p>
<p class="paracontinue"><a id="c003_c3-para-1185"></a>Such an equation is not one-directional. Given any four of the quantities, we can use it to compute the fifth. Yet translating the equation into a traditional computer language would force us to choose one of the quantities to be computed in terms of the other four. Thus, a function for computing the area <i>A</i> could not be used to compute the deflection <i>d</i>, even though the computations of <i>A</i> and <i>d</i> arise from the same equation.<a id="c003_c3-fn-0034a"></a><a href="#c3-fn-0034"><sup>34</sup></a></p>
<p><a id="c003_c3-para-1186"></a>In this section, we sketch the design of a language that enables us to work in terms of relations themselves. The primitive elements of the language are <i>primitive constraints</i>, which state that certain relations hold between quantities. For example, <span class="KeyTerm1">adder(a, b, c)</span> specifies that the quantities <i>a</i>, <i>b</i>, and <i>c</i> must be related by the equation <i>a</i> + <i>b</i> = <i>c</i>, <span class="KeyTerm1">multiplier(x, y, z)</span> expresses the constraint <i>xy</i> = <i>z</i>, and <span class="KeyTerm1">constant(3.14, x)</span> says that the value of <i>x</i> must be 3.14.</p>
<p><a id="c003_c3-para-1187"></a>Our language provides a means of combining primitive constraints in order to express more complex relations. We combine constraints by constructing <i>constraint networks</i>, in which constraints are joined by <i>connectors</i>. A connector is an object that “holds” a value that may participate in one or more constraints. For example, we know that the relationship between Fahrenheit and Celsius temperatures is</p>
<p class="Sp-text-2"><a id="c003_c3-para-1188"></a>9<i>C</i> = 5(<i>F</i> – 32)</p>
<p class="paracontinue"><a id="c003_c3-para-1189"></a>Such a constraint can be thought of as a network consisting of primitive adder, multiplier, and constant constraints (<a id="c003_c3-fig-0028a"></a><a href="#c3-fig-0028">figure 3.28</a>). In the figure, we see on the left a multiplier box with three terminals, labeled <i>m</i><sub>1</sub>, <i>m</i><sub>2</sub>, and <i>p</i>. These connect the multiplier to the rest of the network as follows: The <i>m</i><sub>1</sub> terminal is linked to a connector <i>C</i>, which will hold the Celsius temperature. The <i>m</i><sub>2</sub> terminal is linked to a connector <i>w</i>, which is also linked to a constant box that holds 9. The <i>p</i> terminal, which the multiplier box constrains to be the product of <i>m</i><sub>1</sub> and <i>m</i><sub>2</sub>, is linked to the <i>p</i> terminal of another multiplier box, whose <i>m</i><sub>2</sub> is connected to a constant 5 and whose <i>m</i><sub>1</sub> is connected to one of the terms in a sum.</p>
<figure id="c003_c3-fig-0028"><img alt="c3-fig-0028.jpg" src="../images/c3-fig-0028.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0028a">Figure 3.28</a></span> <a id="c003_c3-para-1190"></a>The relation 9C = 5(F – 32) expressed as a constraint network.</p></figcaption></figure>
<p><a id="c003_c3-para-1191"></a>Computation by such a network proceeds as follows: When a connector is given a value (by the user or by a constraint box to which it is linked), it awakens all of its associated constraints (except for the constraint that just awakened it) to inform them that it has a value. Each awakened constraint box then polls its connectors to see if there is enough information to determine a value for a connector. If so, the box sets that connector, which then awakens all of its associated constraints, and so on. For instance, in conversion between Celsius and Fahrenheit, <i>w</i>, <i>x</i>, and <i>y</i> are immediately set by the constant boxes to 9, 5, and 32, respectively. The connectors awaken the multipliers and the adder, which determine that there is not enough information to proceed. If the user (or some other part of the network) sets <i>C</i> to a value (say 25), the leftmost multiplier will be awakened, and it will set <i>u</i> to 25 9 = 225. Then <i>u</i> awakens the second multiplier, which sets <i>v</i> to 45, and <i>v</i> awakens the adder, which sets <i>F</i> to 77.</p>
<section>
<h5><a id="c003_c3-sec-0061"></a><a id="c003_c3-title-0062"></a>Using the constraint system</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1192"></a>To use the constraint system to carry out the temperature computation outlined above, we first call the constructor <span class="KeyTerm1">make_connector</span> to create two connectors, <span class="KeyTerm1">C</span> and <span class="KeyTerm1">F</span>, and then link them in an appropriate network:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1193"></a><b>const</b> C = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1194"></a><b>const</b> F = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1195"></a>celsius_fahrenheit_converter(C, F);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1196"></a><i>"ok"</i></p>
<p class="paracontinue"><a id="c003_c3-para-1197"></a>The function that creates the network is defined as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1198"></a><b>function</b> celsius_fahrenheit_converter(c, f) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1199"></a> <b>const</b> u = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1200"></a> <b>const</b> v = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1201"></a> <b>const</b> w = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1202"></a> <b>const</b> x = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1203"></a> <b>const</b> y = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1204"></a>    multiplier(c, w, u);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1205"></a>    multiplier(v, x, u);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1206"></a>    adder(v, y, f);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1207"></a>    constant(9, w);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1208"></a>    constant(5, x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1209"></a>    constant(32, y);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1210"></a> <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1211"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1212"></a>This function creates the internal connectors <span class="KeyTerm1">u</span>, <span class="KeyTerm1">v</span>, <span class="KeyTerm1">w</span>, <span class="KeyTerm1">x</span>, and <span class="KeyTerm1">y</span>, and links them as shown in <a href="#c3-fig-0028">figure 3.28</a> using the primitive constraint constructors <span class="KeyTerm1">adder</span>, <span class="KeyTerm1">multiplier</span>, and <span class="KeyTerm1">constant</span>. Just as with the digital-circuit simulator of section 3.3.4, expressing these combinations of primitive elements in terms of functions automatically provides our language with a means of abstraction for compound objects.</p>
<p><a id="c003_c3-para-1213"></a>To watch the network in action, we can place probes on the connectors <span class="KeyTerm1">C</span> and <span class="KeyTerm1">F</span>, using a <span class="KeyTerm1">probe</span> function similar to the one we used to monitor wires in section 3.3.4. Placing a probe on a connector will cause a message to be printed whenever the connector is given a value:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1214"></a>probe("Celsius temp", C);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1215"></a>probe("Fahrenheit temp", F);</p>
<p class="paracontinue"><a id="c003_c3-para-1216"></a>Next we set the value of <span class="KeyTerm1">C</span> to 25. (The third argument to <span class="KeyTerm1">set_value</span> tells <span class="KeyTerm1">C</span> that this directive comes from the <span class="KeyTerm1">user</span>.)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1217"></a>set_value(C, 25, "user");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1218"></a><i>"Probe: Celsius temp = 25"</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-1219"></a><i>"Probe: Fahrenheit temp = 77"</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-1220"></a><i>"done"</i></p>
<p class="paracontinue"><a id="c003_c3-para-1221"></a>The probe on <span class="KeyTerm1">C</span> awakens and reports the value. <span class="KeyTerm1">C</span> also propagates its value through the network as described above. This sets <span class="KeyTerm1">F</span> to 77, which is reported by the probe on <span class="KeyTerm1">F</span>.</p>
<p><a id="c003_c3-para-1222"></a>Now we can try to set <span class="KeyTerm1">F</span> to a new value, say 212:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1223"></a>set_value(F, 212, "user");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1224"></a><i>"Error! Contradiction: (77, 212)"</i></p>
<p class="paracontinue"><a id="c003_c3-para-1225"></a>The connector complains that it has sensed a contradiction: Its value is 77, and someone is trying to set it to 212. If we really want to reuse the network with new values, we can tell <span class="KeyTerm1">C</span> to forget its old value:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1226"></a>forget_value(C, "user");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1227"></a><i>"Probe: Celsius temp = ?"</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-1228"></a><i>"Probe: Fahrenheit temp = ?"</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-1229"></a><i>"done"</i></p>
<p class="paracontinue"><a id="c003_c3-para-1230"></a><span class="KeyTerm1">C</span> finds that the <span class="KeyTerm1">"user"</span>, who set its value originally, is now retracting that value, so <span class="KeyTerm1">C</span> agrees to lose its value, as shown by the probe, and informs the rest of the network of this fact. This information eventually propagates to <span class="KeyTerm1">F</span>, which now finds that it has no reason for continuing to believe that its own value is 77. Thus, <span class="KeyTerm1">F</span> also gives up its value, as shown by the probe.</p>
<p><a id="c003_c3-para-1231"></a>Now that <span class="KeyTerm1">F</span> has no value, we are free to set it to 212:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1232"></a>set_value(F, 212, "user");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1233"></a><i>"Probe: Fahrenheit temp = 212"</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-1234"></a><i>"Probe: Celsius temp = 100"</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-1235"></a><i>"done"</i>?</p>
<p class="paracontinue"><a id="c003_c3-para-1236"></a>This new value, when propagated through the network, forces <span class="KeyTerm1">C</span> to have a value of 100, and this is registered by the probe on <span class="KeyTerm1">C</span>. Notice that the very same network is being used to compute <span class="KeyTerm1">C</span> given <span class="KeyTerm1">F</span> and to compute <span class="KeyTerm1">F</span> given <span class="KeyTerm1">C</span>. This nondirectionality of computation is the distinguishing feature of constraint-based systems.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0062"></a><a id="c003_c3-title-0063"></a>Implementing the constraint system</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1237"></a>The constraint system is implemented via procedural objects with local state, in a manner very similar to the digital-circuit simulator of section 3.3.4. Although the primitive objects of the constraint system are somewhat more complex, the overall system is simpler, since there is no concern about agendas and logic delays.</p>
<p><a id="c003_c3-para-1238"></a>The basic operations on connectors are the following:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">has_value(</span><i>connector</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-1240"></a>tells whether the connector has a value.</p></li>
<li><span class="KeyTerm1">get_value(</span><i>connector</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-1242"></a>returns the connector's current value.</p></li>
<li><span class="KeyTerm1">set_value(</span><i>connector</i><span class="KeyTerm1">,</span> <i>new</i>-<i>value</i><span class="KeyTerm1">,</span> <i>informant</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-1244"></a>indicates that the informant is requesting the connector to set its value to the new value.</p></li>
<li><span class="KeyTerm1">forget_value(</span><i>connector</i><span class="KeyTerm1">,</span> <i>retractor</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-1246"></a>tells the connector that the retractor is requesting it to forget its value.</p></li>
<li><span class="KeyTerm1">connect(</span><i>connector</i><span class="KeyTerm1">,</span> <i>new</i>-<i>constraint</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c003_c3-para-1248"></a>tells the connector to participate in the new constraint.</p></li>
</ul>
<p class="paracontinue"><a id="c003_c3-para-1249"></a>The connectors communicate with the constraints by means of the functions <span class="KeyTerm1">inform_ about_value</span>, which tells the given constraint that the connector has a value, and <span class="KeyTerm1">inform_about_no_value</span>, which tells the constraint that the connector has lost its value.</p>
<p><a id="c003_c3-para-1250"></a><span class="KeyTerm1">Adder</span> constructs an adder constraint among summand connectors <span class="KeyTerm1">a1</span> and <span class="KeyTerm1">a2</span> and a <span class="KeyTerm1">sum</span> connector. An adder is implemented as a function with local state (the function <span class="KeyTerm1">me</span> below):</p>
<p class="Sp-text-1"><a id="c003_c3-para-1251"></a><b>function</b> adder(a1, a2, sum) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1252"></a> <b>function</b> process_new_value() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1253"></a> <b>if</b> (has_value(a1) &amp;&amp; has_value(a2)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1254"></a>            set_value(sum, get_value(a1) + get_value(a2), me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1255"></a>        } <b>else if</b> (has_value(a1) &amp;&amp; has_value(sum)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1256"></a>            set_value(a2, get_value(sum) - get_value(a1), me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1257"></a>        } <b>else if</b> (has_value(a2) &amp;&amp; has_value(sum)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1258"></a>            set_value(a1, get_value(sum) - get_value(a2), me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1259"></a>        } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1260"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1261"></a> <b>function</b> process_forget_value() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1262"></a>        forget_value(sum, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1263"></a>        forget_value(a1, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1264"></a>        forget_value(a2, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1265"></a>        process_new_value();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1266"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1267"></a> <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1268"></a> <b>if</b> (request === "I have a value.") {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1269"></a>            process_new_value();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1270"></a>        } <b>else if</b> (request === "I lost my value.") {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1271"></a>            process_forget_value();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1272"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1273"></a>            error(request, "unknown request – adder");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1274"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1275"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1276"></a>    connect(a1, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1277"></a>    connect(a2, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1278"></a>    connect(sum, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1279"></a> <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1280"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1281"></a>The function <span class="KeyTerm1">adder</span> connects the new adder to the designated connectors and returns it as its value. The function <span class="KeyTerm1">me</span>, which represents the adder, acts as a dispatch to the local functions. The following “syntax interfaces” (see footnote 30 in section 3.3.4) are used in conjunction with the dispatch:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1282"></a><b>function</b> inform_about_value(constraint) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1283"></a> <b>return</b> constraint("I have a value.");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1284"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1285"></a><b>function</b> inform_about_no_value(constraint) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1286"></a> <b>return</b> constraint("I lost my value.");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1287"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1288"></a>The adder's local function <span class="KeyTerm1">process_new_value</span> is called when the adder is informed that one of its connectors has a value. The adder first checks to see if both <span class="KeyTerm1">a1</span> and <span class="KeyTerm1">a2</span> have values. If so, it tells <span class="KeyTerm1">sum</span> to set its value to the sum of the two addends. The <span class="KeyTerm1">informant</span> argument to <span class="KeyTerm1">set_value</span> is <span class="KeyTerm1">me</span>, which is the adder object itself. If <span class="KeyTerm1">a1</span> and <span class="KeyTerm1">a2</span> do not both have values, then the adder checks to see if perhaps <span class="KeyTerm1">a1</span> and <span class="KeyTerm1">sum</span> have values. If so, it sets <span class="KeyTerm1">a2</span> to the difference of these two. Finally, if <span class="KeyTerm1">a2</span> and <span class="KeyTerm1">sum</span> have values, this gives the adder enough information to set <span class="KeyTerm1">a1</span>. If the adder is told that one of its connectors has lost a value, it requests that all of its connectors now lose their values. (Only those values that were set by this adder are actually lost.) Then it runs <span class="KeyTerm1">process_new_value</span>. The reason for this last step is that one or more connectors may still have a value (that is, a connector may have had a value that was not originally set by the adder), and these values may need to be propagated back through the adder.</p>
<p><a id="c003_c3-para-1289"></a>A multiplier is very similar to an adder. It will set its <span class="KeyTerm1">product</span> to 0 if either of the factors is 0, even if the other factor is not known.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1290"></a><b>function</b> multiplier(m1, m2, product) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1291"></a> <b>function</b> process_new_value() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1292"></a> <b>if</b> ((has_value(m1) &amp;&amp; get_value(m1) === 0)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1293"></a>         || (has_value(m2) &amp;&amp; get_value(m2) === 0)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1294"></a>            set_value(product, 0, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1295"></a>        } <b>else if</b> (has_value(m1) &amp;&amp; has_value(m2)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1296"></a>            set_value(product, get_value(m1) * get_value(m2), me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1297"></a>        } <b>else if</b> (has_value(product) &amp;&amp; has_value(m1)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1298"></a>            set_value(m2, get_value(product) / get_value(m1), me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1299"></a>        } <b>else if</b> (has_value(product) &amp;&amp; has_value(m2)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1300"></a>            set_value(m1, get_value(product) / get_value(m2), me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1301"></a>        } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1302"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1303"></a> <b>function</b> process_forget_value() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1304"></a>        forget_value(product, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1305"></a>        forget_value(m1, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1306"></a>        forget_value(m2, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1307"></a>        process_new_value();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1308"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1309"></a> <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1310"></a> <b>if</b> (request === "I have a value.") {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1311"></a>            process_new_value();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1312"></a>        } <b>else if</b> (request === "I lost my value.") {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1313"></a>            process_forget_value();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1314"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1315"></a>            error(request, "unknown request – multiplier");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1316"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1317"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1318"></a>    connect(m1, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1319"></a>    connect(m2, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1320"></a>    connect(product, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1321"></a> <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1322"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1323"></a>A <span class="KeyTerm1">constant</span> constructor simply sets the value of the designated connector. Any <span class="KeyTerm1">"I have a value."</span> or <span class="KeyTerm1">"I lost my value."</span> message sent to the constant box will produce an error.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1324"></a><b>function</b> constant(value, connector) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1325"></a> <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1326"></a>        error(request, "unknown request – constant");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1327"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1328"></a>    connect(connector, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1329"></a>    set_value(connector, value, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1330"></a> <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1331"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1332"></a>Finally, a probe prints a message about the setting or unsetting of the designated connector:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1333"></a><b>function</b> probe(name, connector) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1334"></a> <b>function</b> print_probe(value) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1335"></a>        display("Probe: " + name + " = " + stringify(value));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1336"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1337"></a> <b>function</b> process_new_value() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1338"></a>        print_probe(get_value(connector));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1339"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1340"></a> <b>function</b> process_forget_value() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1341"></a>        print_probe("?");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1342"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1343"></a> <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1344"></a> <b>return</b> request === "I have a value."</p>
<p class="Sp-text-1"><a id="c003_c3-para-1345"></a>               ? process_new_value()</p>
<p class="Sp-text-1"><a id="c003_c3-para-1346"></a>               : request === "I lost my value."</p>
<p class="Sp-text-1"><a id="c003_c3-para-1347"></a>               ? process_forget_value()</p>
<p class="Sp-text-1"><a id="c003_c3-para-1348"></a>               : error(request, "unknown request – probe");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1349"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1350"></a>    connect(connector, me);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1351"></a> <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1352"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0063"></a><a id="c003_c3-title-0064"></a>Representing connectors</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1353"></a>A connector is represented as a procedural object with local state variables <span class="KeyTerm1">value</span>, the current value of the connector; <span class="KeyTerm1">informant</span>, the object that set the connector's value; and <span class="KeyTerm1">constraints</span>, a list of the constraints in which the connector participates.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1354"></a><b>function</b> make_connector() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1355"></a> <b>let</b> value = <b>false</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1356"></a> <b>let</b> informant = <b>false</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1357"></a> <b>let</b> constraints = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1358"></a> <b>function</b> set_my_value(newval, setter) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1359"></a> <b>if</b> (!has_value(me)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1360"></a>            value = newval;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1361"></a>            informant = setter;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1362"></a> <b>return</b> for_each_except(setter,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1363"></a>                                   inform_about_value,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1364"></a>                                   constraints);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1365"></a>        } <b>else if</b> (value !== newval) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1366"></a>            error(list(value, newval), "contradiction");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1367"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1368"></a> <b>return</b> "ignored";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1369"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1370"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1371"></a> <b>function</b> forget_my_value(retractor) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1372"></a> <b>if</b> (retractor === informant) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1373"></a>            informant = <b>false</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1374"></a> <b>return</b> for_each_except(retractor,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1375"></a>                                   inform_about_no_value,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1376"></a>                                   constraints);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1377"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1378"></a> <b>return</b> "ignored";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1379"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1380"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1381"></a> <b>function</b> connect(new_constraint) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1382"></a> <b>if</b> (is_null(member(new_constraint, constraints))) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1383"></a>            constraints = pair(new_constraint, constraints);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1384"></a>        } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1385"></a> <b>if</b> (has_value(me)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1386"></a>            inform_about_value(new_constraint);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1387"></a>        } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1388"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1389"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1390"></a> <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1391"></a> <b>if</b> (request === "has_value") {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1392"></a> <b>return</b> informant !== <b>false</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1393"></a>        } <b>else if</b> (request === "value") {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1394"></a> <b>return</b> value;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1395"></a>        } <b>else if</b> (request === "set_value") {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1396"></a> <b>return</b> set_my_value;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1397"></a>        } <b>else if</b> (request === "forget") {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1398"></a> <b>return</b> forget_my_value;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1399"></a>        } <b>else if</b> (request === "connect") {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1400"></a> <b>return</b> connect;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1401"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1402"></a>            error(request, "unknown operation – connector");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1403"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1404"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1405"></a> <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1406"></a>}</p>
<p><a id="c003_c3-para-1407"></a>The connector's local function <span class="KeyTerm1">set_my_value</span> is called when there is a request to set the connector's value. If the connector does not currently have a value, it will set its value and remember as <span class="KeyTerm1">informant</span> the constraint that requested the value to be set.<a id="c003_c3-fn-0035a"></a><a href="#c3-fn-0035"><sup>35</sup></a> Then the connector will notify all of its participating constraints except the constraint that requested the value to be set. This is accomplished using the following iterator, which applies a designated function to all items in a list except a given one:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1408"></a><b>function</b> for_each_except(exception, fun, list) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1409"></a> <b>function</b> loop(items) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1410"></a> <b>if</b> (is_null(items)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1411"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1412"></a>        } <b>else if</b> (head(items) === exception) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1413"></a> <b>return</b> loop(tail(items));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1414"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1415"></a>            fun(head(items));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1416"></a> <b>return</b> loop(tail(items));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1417"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1418"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1419"></a> <b>return</b> loop(list);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1420"></a>}</p>
<p><a id="c003_c3-para-1421"></a>If a connector is asked to forget its value, it runs <span class="KeyTerm1">forget_my_value</span>, a local function that first checks to make sure that the request is coming from the same object that set the value originally. If so, the connector informs its associated constraints about the loss of the value.</p>
<p><a id="c003_c3-para-1422"></a>The local function <span class="KeyTerm1">connect</span> adds the designated new constraint to the list of constraints if it is not already in that list.<a id="c003_c3-fn-0036a"></a><a href="#c3-fn-0036"><sup>36</sup></a> Then, if the connector has a value, it informs the new constraint of this fact.</p>
<p><a id="c003_c3-para-1423"></a>The connector's function <span class="KeyTerm1">me</span> serves as a dispatch to the other internal functions and also represents the connector as an object. The following functions provide a syntax interface for the dispatch:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1424"></a><b>function</b> has_value(connector) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1425"></a> <b>return</b> connector("has_value");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1426"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1427"></a><b>function</b> get_value(connector) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1428"></a> <b>return</b> connector("value");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1429"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1430"></a><b>function</b> set_value(connector, new_value, informant) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1431"></a> <b>return</b> connector("set_value")(new_value, informant);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1432"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1433"></a><b>function</b> forget_value(connector, retractor) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1434"></a> <b>return</b> connector("forget")(retractor);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1435"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1436"></a><b>function</b> connect(connector, new_constraint) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1437"></a> <b>return</b> connector("connect")(new_constraint);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1438"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0064"></a><a id="c003_c3-title-0065"></a>Exercise 3.33</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1439"></a>Using primitive multiplier, adder, and constant constraints, define a function averager that takes three connectors <span class="KeyTerm1">a</span>, <span class="KeyTerm1">b</span>, and <span class="KeyTerm1">c</span> as inputs and establishes the constraint that the value of c is the average of the values of a and b.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0065"></a><a id="c003_c3-title-0066"></a>Exercise 3.34</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1440"></a>Louis Reasoner wants to build a squarer, a constraint device with two terminals such that the value of connector b on the second terminal will always be the square of the value a on the first terminal. He proposes the following simple device made from a multiplier:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1441"></a><b>function</b> squarer(a, b) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1442"></a> <b>return</b> multiplier(a, a, b);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1443"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1444"></a>There is a serious flaw in this idea. Explain.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0066"></a><a id="c003_c3-title-0067"></a>Exercise 3.35</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1445"></a>Ben Bitdiddle tells Louis that one way to avoid the trouble in exercise 3.34 is to define a squarer as a new primitive constraint. Fill in the missing portions in Ben's outline for a function to implement such a constraint:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1446"></a><b>function</b> squarer(a, b) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1447"></a> <b>function</b> process_new_value() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1448"></a> <b>if</b> (has_value(b)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1449"></a> <b>if</b> (get_value(b) &lt; 0) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1450"></a>                error(get_value(b), "square less than 0 – squarer");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1451"></a>            } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1452"></a> <span class="KeyTerm2"><i>alternative<sub>1</sub></i></span></p>
<p class="Sp-text-1"><a id="c003_c3-para-1453"></a>            }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1454"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1455"></a> <span class="KeyTerm2"><i>alternative<sub>2</sub></i></span></p>
<p class="Sp-text-1"><a id="c003_c3-para-1456"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1457"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1458"></a> <b>function</b> process_forget_value() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1459"></a> <span class="KeyTerm2"><i>body<sub>1</sub></i></span></p>
<p class="Sp-text-1"><a id="c003_c3-para-1460"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1461"></a> <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1462"></a> <span class="KeyTerm2"><i>body<sub>2</sub></i></span></p>
<p class="Sp-text-1"><a id="c003_c3-para-1463"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1464"></a> <span class="KeyTerm2"><i>statements</i></span></p>
<p class="Sp-text-1"><a id="c003_c3-para-1465"></a> <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1466"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0067"></a><a id="c003_c3-title-0068"></a>Exercise 3.36</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1467"></a>Suppose we evaluate the following sequence of statements in the program environment:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1468"></a><b>const</b> a = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1469"></a><b>const</b> b = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1470"></a>set_value(a, 10, "user");</p>
<p class="paracontinue"><a id="c003_c3-para-1471"></a>At some time during evaluation of the <span class="KeyTerm1">set_value</span>, the following expression from the connector's local function is evaluated:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1472"></a>for_each_except(setter, inform_about_value, constraints);</p>
<p class="paracontinue"><a id="c003_c3-para-1473"></a>Draw an environment diagram showing the environment in which the above expression is evaluated.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0068"></a><a id="c003_c3-title-0069"></a>Exercise 3.37</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1474"></a>The <span class="KeyTerm1">celsius_fahrenheit_converter</span> function is cumbersome when compared with a more expression-oriented style of definition, such as</p>
<p class="Sp-text-1"><a id="c003_c3-para-1475"></a><b>function</b> celsius_fahrenheit_converter(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1476"></a> <b>return</b> cplus(cmul(cdiv(cv(9), cv(5)), x), cv(32));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1477"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-1478"></a><b>const</b> C = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1479"></a><b>const</b> F = celsius_fahrenheit_converter(C);</p>
<p class="paracontinue"><a id="c003_c3-para-1480"></a>Here <span class="KeyTerm1">cplus</span>, <span class="KeyTerm1">cmul</span>, etc. are the “constraint” versions of the arithmetic operations. For example, <span class="KeyTerm1">cplus</span> takes two connectors as arguments and returns a connector that is related to these by an adder constraint:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1481"></a><b>function</b> cplus(x, y) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1482"></a> <b>const</b> z = make_connector();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1483"></a>    adder(x, y, z);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1484"></a> <b>return</b> z;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1485"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1486"></a>Define analogous functions <span class="KeyTerm1">cminus</span>, <span class="KeyTerm1">cmul</span>, <span class="KeyTerm1">cdiv</span>, and <span class="KeyTerm1">cv</span> (constant value) that enable us to define compound constraints as in the converter example above.<a id="c003_c3-fn-0037a"></a><a href="#c3-fn-0037"><sup>37</sup></a></p>
</section>
</section>
</section>
<section>
<h2><a id="c003_c3-sec-0069"></a><span>3.4</span> <a id="c003_c3-title-0070"></a>Concurrency: Time Is of the Essence</h2>
<p class="paraaftertitle"><a id="c003_c3-para-1492"></a>We've seen the power of computational objects with local state as tools for modeling. Yet, as section 3.1.3 warned, this power extracts a price: the loss of referential transparency, giving rise to a thicket of questions about sameness and change, and the need to abandon the substitution model of evaluation in favor of the more intricate environment model.</p>
<p><a id="c003_c3-para-1493"></a>The central issue lurking beneath the complexity of state, sameness, and change is that by introducing assignment we are forced to admit <i>time</i> into our computational models. Before we introduced assignment, all our programs were timeless, in the sense that any expression that has a value always has the same value. In contrast, recall the example of modeling withdrawals from a bank account and returning the resulting balance, introduced at the beginning of section 3.1.1:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1494"></a>withdraw(25);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1495"></a><i>75</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-1496"></a>withdraw(25);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1497"></a><i>50</i></p>
<p class="paracontinue"><a id="c003_c3-para-1498"></a>Here successive evaluations of the same expression yield different values. This behavior arises from the fact that the execution of assignments (in this case, assignments to the variable <span class="KeyTerm1">balance</span>) delineates <i>moments in time</i> when values change. The result of evaluating an expression depends not only on the expression itself, but also on whether the evaluation occurs before or after these moments. Building models in terms of computational objects with local state forces us to confront time as an essential concept in programming.</p>
<p><a id="c003_c3-para-1499"></a>We can go further in structuring computational models to match our perception of the physical world. Objects in the world do not change one at a time in sequence. Rather we perceive them as acting <i>concurrently</i>—all at once. So it is often natural to model systems as collections of <i>threads</i> (sequences of computational steps) that execute concurrently.<a id="c003_c3-fn-0038a"></a><a href="#c3-fn-0038"><sup>38</sup></a> Just as we can make our programs modular by organizing models in terms of objects with separate local state, it is often appropriate to divide computational models into parts that evolve separately and concurrently. Even if the programs are to be executed on a sequential computer, the practice of writing programs as if they were to be executed concurrently forces the programmer to avoid inessential timing constraints and thus makes programs more modular.</p>
<p><a id="c003_c3-para-1500"></a>In addition to making programs more modular, concurrent computation can provide a speed advantage over sequential computation. Sequential computers execute only one operation at a time, so the amount of time it takes to perform a task is proportional to the total number of operations performed.<a id="c003_c3-fn-0039a"></a><a href="#c3-fn-0039"><sup>39</sup></a> However, if it is possible to decompose a problem into pieces that are relatively independent and need to communicate only rarely, it may be possible to allocate pieces to separate computing processors, producing a speed advantage proportional to the number of processors available.</p>
<p><a id="c003_c3-para-1501"></a>Unfortunately, the complexities introduced by assignment become even more problematic in the presence of concurrency. The fact of concurrent execution, either because the world operates in parallel or because our computers do, entails additional complexity in our understanding of time.</p>
<section>
<h3><a id="c003_c3-sec-0070"></a><span>3.4.1</span> <a id="c003_c3-title-0071"></a>The Nature of Time in Concurrent Systems</h3>
<p class="paraaftertitle"><a id="c003_c3-para-1502"></a>On the surface, time seems straightforward. It is an ordering imposed on events.<a id="c003_c3-fn-0040a"></a><a href="#c3-fn-0040"><sup>40</sup></a> For any events <i>A</i> and <i>B</i>, either <i>A</i> occurs before <i>B</i>, <i>A</i> and <i>B</i> are simultaneous, or <i>A</i> occurs after <i>B</i>. For instance, returning to the bank account example, suppose that Peter withdraws $10 and Paul withdraws $25 from a joint account that initially contains $100, leaving $65 in the account. Depending on the order of the two withdrawals, the sequence of balances in the account is either $100 $90 $65 or $100 $75 $65. In a computer implementation of the banking system, this changing sequence of balances could be modeled by successive assignments to a variable <span class="KeyTerm1">balance</span>.</p>
<p><a id="c003_c3-para-1503"></a>In complex situations, however, such a view can be problematic. Suppose that Peter and Paul, and other people besides, are accessing the same bank account through a network of banking machines distributed all over the world. The actual sequence of balances in the account will depend critically on the detailed timing of the accesses and the details of the communication among the machines.</p>
<p><a id="c003_c3-para-1504"></a>This indeterminacy in the order of events can pose serious problems in the design of concurrent systems. For instance, suppose that the withdrawals made by Peter and Paul are implemented as two separate threads sharing a common variable <span class="KeyTerm1">balance</span>, each thread specified by the function given in section 3.1.1:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1505"></a><b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1506"></a> <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1507"></a>        balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1508"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1509"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1510"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1511"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1512"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1513"></a>If the two threads operate independently, then Peter might test the balance and attempt to withdraw a legitimate amount. However, Paul might withdraw some funds in between the time that Peter checks the balance and the time Peter completes the withdrawal, thus invalidating Peter's test.</p>
<p><a id="c003_c3-para-1514"></a>Things can be worse still. Consider the statement</p>
<p class="Sp-text-1"><a id="c003_c3-para-1515"></a>balance = balance - amount;</p>
<p class="paracontinue"><a id="c003_c3-para-1516"></a>executed as part of each withdrawal process. This consists of three steps: (1) accessing the value of the <span class="KeyTerm1">balance</span> variable; (2) computing the new balance; (3) setting <span class="KeyTerm1">balance</span> to this new value. If Peter and Paul's withdrawals execute this statement concurrently, then the two withdrawals might interleave the order in which they access <span class="KeyTerm1">balance</span> and set it to the new value.</p>
<p><a id="c003_c3-para-1517"></a>The timing diagram in <a id="c003_c3-fig-0029a"></a><a href="#c3-fig-0029">figure 3.29</a> depicts an order of events where <span class="KeyTerm1">balance</span> starts at 100, Peter withdraws 10, Paul withdraws 25, and yet the final value of <span class="KeyTerm1">balance</span> is 75. As shown in the diagram, the reason for this anomaly is that Paul's assignment of 75 to <span class="KeyTerm1">balance</span> is made under the assumption that the value of <span class="KeyTerm1">balance</span> to be decremented is 100. That assumption, however, became invalid when Peter changed <span class="KeyTerm1">balance</span> to 90. This is a catastrophic failure for the banking system, because the total amount of money in the system is not conserved. Before the transactions, the total amount of money was $100. Afterwards, Peter has $10, Paul has $25, and the bank has $75.<a id="c003_c3-fn-0041a"></a><a href="#c3-fn-0041"><sup>41</sup></a></p>
<figure id="c003_c3-fig-0029"><img alt="c3-fig-0029.jpg" src="../images/c3-fig-0029.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0029a">Figure 3.29</a></span> <a id="c003_c3-para-1518"></a>Timing diagram showing how interleaving the order of events in two banking withdrawals can lead to an incorrect final balance.</p></figcaption></figure>
<p><a id="c003_c3-para-1519"></a>The general phenomenon illustrated here is that several threads may share a common state variable. What makes this complicated is that more than one thread may be trying to manipulate the shared state at the same time. For the bank account example, during each transaction, each customer should be able to act as if the other customers did not exist. When customers change the balance in a way that depends on the balance, they must be able to assume that, just before the moment of change, the balance is still what they thought it was.</p>
<section>
<h5><a id="c003_c3-sec-0071"></a><a id="c003_c3-title-0072"></a>Correct behavior of concurrent programs</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1520"></a>The above example typifies the subtle bugs that can creep into concurrent programs. The root of this complexity lies in the assignments to variables that are shared among the different threads. We already know that we must be careful in writing programs that use assignment, because the results of a computation depend on the order in which the assignments occur.<a id="c003_c3-fn-0042a"></a><a href="#c3-fn-0042"><sup>42</sup></a> With concurrent threads we must be especially careful about assignments, because we may not be able to control the order of the assignments made by the different threads. If several such changes might be made concurrently (as with two depositors accessing a joint account) we need some way to ensure that our system behaves correctly. For example, in the case of withdrawals from a joint bank account, we must ensure that money is conserved. To make concurrent programs behave correctly, we may have to place some restrictions on concurrent execution.</p>
<p><a id="c003_c3-para-1521"></a>One possible restriction on concurrency would stipulate that no two operations that change any shared state variables can occur at the same time. This is an extremely stringent requirement. For distributed banking, it would require the system designer to ensure that only one transaction could proceed at a time. This would be both inefficient and overly conservative. <a id="c003_c3-fig-0030a"></a><a href="#c3-fig-0030">Figure 3.30</a> shows Peter and Paul sharing a bank account, where Paul has a private account as well. The diagram illustrates two withdrawals from the shared account (one by Peter and one by Paul) and a deposit to Paul's private account.<a id="c003_c3-fn-0043a"></a><a href="#c3-fn-0043"><sup>43</sup></a> The two withdrawals from the shared account must not be concurrent (since both access and update the same account), and Paul's deposit and withdrawal must not be concurrent (since both access and update the amount in Paul's wallet). But there should be no problem permitting Paul's deposit to his private account to proceed concurrently with Peter's withdrawal from the shared account.</p>
<figure id="c003_c3-fig-0030"><img alt="c3-fig-0030.jpg" src="../images/c3-fig-0030.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0030a">Figure 3.30</a></span> <a id="c003_c3-para-1522"></a>Concurrent deposits and withdrawals from a joint account in Bank1 and a private account in Bank2.</p></figcaption></figure>
<p><a id="c003_c3-para-1523"></a>A less stringent restriction on concurrency would ensure that a concurrent system produces the same result as if the threads had run sequentially in some order. There are two important aspects to this requirement. First, it does not require the threads to actually run sequentially, but only to produce results that are the same <i>as if</i> they had run sequentially. For the example in <a href="#c3-fig-0030">figure 3.30</a>, the designer of the bank account system can safely allow Paul's deposit and Peter's withdrawal to happen concurrently, because the net result will be the same as if the two operations had happened sequentially. Second, there may be more than one possible “correct” result produced by a concurrent program, because we require only that the result be the same as for <i>some</i> sequential order. For example, suppose that Peter and Paul's joint account starts out with $100, and Peter deposits $40 while Paul concurrently withdraws half the money in the account. Then sequential execution could result in the account balance being either $70 or $90 (see exercise 3.38).<a id="c003_c3-fn-0044a"></a><a href="#c3-fn-0044"><sup>44</sup></a></p>
<p><a id="c003_c3-para-1524"></a>There are still weaker requirements for correct execution of concurrent programs. A program for simulating diffusion (say, the flow of heat in an object) might consist of a large number of threads, each one representing a small volume of space, that update their values concurrently. Each thread repeatedly changes its value to the average of its own value and its neighbors’ values. This algorithm converges to the right answer independent of the order in which the operations are done; there is no need for any restrictions on concurrent use of the shared values.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0072"></a><a id="c003_c3-title-0073"></a>Exercise 3.38</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1525"></a>Suppose that Peter, Paul, and Mary share a joint bank account that initially contains $100. Concurrently, Peter deposits $10, Paul withdraws $20, and Mary withdraws half the money in the account, by executing the following commands:</p>
<figure><figcaption class="tablecaption"><a id="c003_c3-tbl-0001"></a></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c003_c3-para-1526"></a>Peter:</td>
<td><a id="c003_c3-para-1527"></a><span class="KeyTerm1">balance = balance + 10</span></td></tr>
<tr>
<td><a id="c003_c3-para-1528"></a>Paul:</td>
<td><a id="c003_c3-para-1529"></a><span class="KeyTerm1">balance = balance - 20</span></td></tr>
<tr>
<td><a id="c003_c3-para-1530"></a>Mary:</td>
<td><a id="c003_c3-para-1531"></a><span class="KeyTerm1">balance = balance - (balance / 2)</span></td></tr></tbody></table></div></figure>
<ol class="BS_NumberListA">
<li><a id="c003_c3-li-0027"></a><span>a. </span>List all the different possible values for <span class="KeyTerm1">balance</span> after these three transactions have been completed, assuming that the banking system forces the three threads to run sequentially in some order.</li>
<li><a id="c003_c3-li-0028"></a><span>b. </span>What are some other values that could be produced if the system allows the threads to be interleaved? Draw timing diagrams like the one in <a href="#c3-fig-0029">figure 3.29</a> to explain how these values can occur.</li>
</ol>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0073"></a><span>3.4.2</span> <a id="c003_c3-title-0074"></a>Mechanisms for Controlling Concurrency</h3>
<p class="paraaftertitle"><a id="c003_c3-para-1534"></a>We've seen that the difficulty in dealing with concurrent threads is rooted in the need to consider the interleaving of the order of events in the different threads. For example, suppose we have two threads, one with three ordered events (<i>a</i>, <i>b</i>, <i>c</i>) and one with three ordered events (<i>x</i>, <i>y</i>, <i>z</i>). If the two threads run concurrently, with no constraints on how their execution is interleaved, then there are 20 different possible orderings for the events that are consistent with the individual orderings for the two threads:</p>
<figure><figcaption class="tablecaption"><a id="c003_c3-tbl-0002"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c003_c3-para-1535"></a>(<i>a</i>, <i>b</i>, <i>c</i>, <i>x</i>, <i>y</i>, <i>z</i>)</td>
<td><a id="c003_c3-para-1536"></a>(<i>a</i>, <i>x</i>, <i>b</i>, <i>y</i>, <i>c</i>, <i>z</i>)</td>
<td><a id="c003_c3-para-1537"></a>(<i>x</i>, <i>a</i>, <i>b</i>, <i>c</i>, <i>y</i>, <i>z</i>)</td>
<td><a id="c003_c3-para-1538"></a>(<i>x</i>, <i>a</i>, <i>y</i>, <i>z</i>, <i>b</i>, <i>c</i>)</td></tr>
<tr>
<td><a id="c003_c3-para-1539"></a>(<i>a</i>, <i>b</i>, <i>x</i>, <i>c</i>, <i>y</i>, <i>z</i>)</td>
<td><a id="c003_c3-para-1540"></a>(<i>a</i>, <i>x</i>, <i>b</i>, <i>y</i>, <i>z</i>, <i>c</i>)</td>
<td><a id="c003_c3-para-1541"></a>(<i>x</i>, <i>a</i>, <i>b</i>, <i>y</i>, <i>c</i>, <i>z</i>)</td>
<td><a id="c003_c3-para-1542"></a>(<i>x</i>, <i>y</i>, <i>a</i>, <i>b</i>, <i>c</i>, <i>z</i>)</td></tr>
<tr>
<td><a id="c003_c3-para-1543"></a>(<i>a</i>, <i>b</i>, <i>x</i>, <i>y</i>, <i>c</i>, <i>z</i>)</td>
<td><a id="c003_c3-para-1544"></a>(<i>a</i>, <i>x</i>, <i>y</i>, <i>b</i>, <i>c</i>, <i>z</i>)</td>
<td><a id="c003_c3-para-1545"></a>(<i>x</i>, <i>a</i>, <i>b</i>, <i>y</i>, <i>z</i>, <i>c</i>)</td>
<td><a id="c003_c3-para-1546"></a>(<i>x</i>, <i>y</i>, <i>a</i>, <i>b</i>, <i>z</i>, <i>c</i>)</td></tr>
<tr>
<td><a id="c003_c3-para-1547"></a>(<i>a</i>, <i>b</i>, <i>x</i>, <i>y</i>, <i>z</i>, <i>c</i>)</td>
<td><a id="c003_c3-para-1548"></a>(<i>a</i>, <i>x</i>, <i>y</i>, <i>b</i>, <i>z</i>, <i>c</i>)</td>
<td><a id="c003_c3-para-1549"></a>(<i>x</i>, <i>a</i>, <i>y</i>, <i>b</i>, <i>c</i>, <i>z</i>)</td>
<td><a id="c003_c3-para-1550"></a>(<i>x</i>, <i>y</i>, <i>a</i>, <i>z</i>, <i>b</i>, <i>c</i>)</td></tr>
<tr>
<td><a id="c003_c3-para-1551"></a>(<i>a</i>, <i>x</i>, <i>b</i>, <i>c</i>, <i>y</i>, <i>z</i>)</td>
<td><a id="c003_c3-para-1552"></a>(<i>a</i>, <i>x</i>, <i>y</i>, <i>z</i>, <i>b</i>, <i>c</i>)</td>
<td><a id="c003_c3-para-1553"></a>(<i>x</i>, <i>a</i>, <i>y</i>, <i>b</i>, <i>z</i>, <i>c</i>)</td>
<td><a id="c003_c3-para-1554"></a>(<i>x</i>, <i>y</i>, <i>z</i>, <i>a</i>, <i>b</i>, <i>c</i>)</td></tr></tbody></table></div>
</figure>
<p class="paracontinue"><a id="c003_c3-para-1555"></a>As programmers designing this system, we would have to consider the effects of each of these 20 orderings and check that each behavior is acceptable. Such an approach rapidly becomes unwieldy as the numbers of threads and events increase.</p>
<p><a id="c003_c3-para-5555"></a>A more practical approach to the design of concurrent systems is to devise general mechanisms that allow us to constrain the interleaving of concurrent threads so that we can be sure that the program behavior is correct. Many mechanisms have been developed for this purpose. In this section, we describe one of them, the <i>serializer</i>.</p>
<section>
<h5><a id="c003_c3-sec-0074"></a><a id="c003_c3-title-0075"></a>Serializing access to shared state</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1556"></a>Serialization implements the following idea: Threads will execute concurrently, but there will be certain collections of functions that cannot be executed concurrently. More precisely, serialization creates distinguished sets of functions such that only one execution of a function in each serialized set is permitted to happen at a time. If some function in the set is being executed, then a thread that attempts to execute any function in the set will be forced to wait until the first execution has finished.</p>
<p><a id="c003_c3-para-1557"></a>We can use serialization to control access to shared variables. For example, if we want to update a shared variable based on the previous value of that variable, we put the access to the previous value of the variable and the assignment of the new value to the variable in the same function. We then ensure that no other function that assigns to the variable can run concurrently with this function by serializing all of these functions with the same serializer. This guarantees that the value of the variable cannot be changed between an access and the corresponding assignment.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0075"></a><a id="c003_c3-title-0076"></a>Serializers</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1558"></a>To make the above mechanism more concrete, suppose that we have extended JavaScript to include a function called <span class="KeyTerm1">concurrent_execute</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1559"></a>concurrent_execute(<span class="KeyTerm2"><i>f</i><sub>1</sub></span>, <span class="KeyTerm2"><i>f</i><sub>2</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>f<sub>k</sub></i></span>)</p>
<p class="paracontinue"><a id="c003_c3-para-1560"></a>Each <i>f</i> must be a function of no arguments. The function <span class="KeyTerm1">concurrent_execute</span> creates a separate thread for each <i>f,</i> which applies <i>f</i> (to no arguments). These threads all run concurrently.<a id="c003_c3-fn-0045a"></a><a href="#c3-fn-0045"><sup>45</sup></a></p>
<p><a id="c003_c3-para-1561"></a>As an example of how this is used, consider</p>
<p class="Sp-text-1"><a id="c003_c3-para-1562"></a><b>let</b> x = 10;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1563"></a>concurrent_execute(() =&gt; { x = x * x; },</p>
<p class="Sp-text-1"><a id="c003_c3-para-1564"></a>                   () =&gt; { x = x + 1; });</p>
<p class="paracontinue"><a id="c003_c3-para-1565"></a>This creates two concurrent threads—<i>T</i><sub>1</sub>, which sets <span class="KeyTerm1">x</span> to <span class="KeyTerm1">x</span> times <span class="KeyTerm1">x</span>, and <i>T</i><sub>2</sub>, which increments <span class="KeyTerm1">x</span>. After execution is complete, <span class="KeyTerm1">x</span> will be left with one of five possible values, depending on the interleaving of the events of <i>T</i><sub>1</sub> and <i>T</i><sub>2</sub>:</p>
<figure><figcaption class="tablecaption"><a id="c003_c3-tbl-0003"></a></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c003_c3-para-1566"></a>101:</td>
<td><a id="c003_c3-para-1567"></a><i>T</i><sub>1</sub> sets <span class="KeyTerm1">x</span> to 100 and then <i>T</i><sub>2</sub> increments <span class="KeyTerm1">x</span> to 101.</td></tr>
<tr>
<td><a id="c003_c3-para-1568"></a>121:</td>
<td><a id="c003_c3-para-1569"></a><i>T</i><sub>2</sub> increments <span class="KeyTerm1">x</span> to 11 and then <i>T</i><sub>1</sub> sets <span class="KeyTerm1">x</span> to <span class="KeyTerm1">x</span> times <span class="KeyTerm1">x</span>.</td></tr>
<tr>
<td><a id="c003_c3-para-1570"></a>110:</td>
<td><a id="c003_c3-para-1571"></a><i>T</i><sub>2</sub> changes <span class="KeyTerm1">x</span> from 10 to 11 between the two times that <i>T</i><sub>1</sub></td></tr>
<tr>
<td></td>
<td><a id="c003_c3-para-1572"></a>accesses the value of <span class="KeyTerm1">x</span> during the evaluation of <span class="KeyTerm1">x * x</span>.</td></tr>
<tr>
<td><a id="c003_c3-para-1573"></a>11:</td>
<td><a id="c003_c3-para-1574"></a><i>T</i><sub>2</sub> accesses <span class="KeyTerm1">x</span>, then <i>T</i><sub>1</sub> sets <span class="KeyTerm1">x</span> to 100, then <i>T</i><sub>2</sub> sets <span class="KeyTerm1">x</span>.</td></tr>
<tr>
<td><a id="c003_c3-para-1575"></a>100:</td>
<td><a id="c003_c3-para-1576"></a><i>T</i><sub>1</sub> accesses <span class="KeyTerm1">x</span> (twice), then <i>T</i><sub>2</sub> sets <span class="KeyTerm1">x</span> to 11, then <i>T</i><sub>1</sub> sets <span class="KeyTerm1">x</span>.</td></tr></tbody></table></div></figure>
<p><a id="c003_c3-para-1577"></a>We can constrain the concurrency by using serialized functions, which are created by <i>serializers</i>. Serializers are constructed by <span class="KeyTerm1">make_serializer</span>, whose implementation is given below. A serializer takes a function as argument and returns a serialized function that behaves like the original function. All calls to a given serializer return serialized functions in the same set.</p>
<p><a id="c003_c3-para-1578"></a>Thus, in contrast to the example above, executing</p>
<p class="Sp-text-1"><a id="c003_c3-para-1579"></a><b>let</b> x = 10;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1580"></a><b>const</b> s = make_serializer();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1581"></a>concurrent_execute(s(() =&gt; { x = x * x; }),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1582"></a>                   s(() =&gt; { x = x + 1; }));</p>
<p class="paracontinue"><a id="c003_c3-para-1583"></a>can produce only two possible values for <span class="KeyTerm1">x</span>, 101 or 121. The other possibilities are eliminated, because the execution of <i>T</i><sub>1</sub> and <i>T</i><sub>2</sub> cannot be interleaved.</p>
<p><a id="c003_c3-para-1584"></a>Here is a version of the <span class="KeyTerm1">make_account</span> function from section 3.1.1, where the deposits and withdrawals have been serialized:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1585"></a><b>function</b> make_account(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1586"></a> <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1587"></a> <b>if</b> (balance &gt; amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1588"></a>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1589"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1590"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1591"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1592"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1593"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1594"></a> <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1595"></a>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1596"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1597"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1598"></a> <b>const</b> protect = make_serializer();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1599"></a> <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1600"></a> <b>return</b> m === "withdraw"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1601"></a>               ? protect(withdraw)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1602"></a>               : m === "deposit"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1603"></a>               ? protect(deposit)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1604"></a>               : m === "balance"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1605"></a>               ? balance</p>
<p class="Sp-text-1"><a id="c003_c3-para-1606"></a>               : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1607"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1608"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1609"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1610"></a>With this implementation, two threads cannot be withdrawing from or depositing into a single account concurrently. This eliminates the source of the error illustrated in <a href="#c3-fig-0029">figure 3.29</a>, where Peter changes the account balance between the times when Paul accesses the balance to compute the new value and when Paul actually performs the assignment. On the other hand, each account has its own serializer, so that deposits and withdrawals for different accounts can proceed concurrently.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0076"></a><a id="c003_c3-title-0077"></a>Exercise 3.39</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1611"></a>Which of the five possibilities in the concurrent execution shown above remain if we instead serialize execution as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1612"></a><b>let</b> x = 10;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1613"></a><b>const</b> s = make_serializer();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1614"></a>concurrent_execute( () =&gt; { x = s(() =&gt; x * x)(); },</p>
<p class="Sp-text-1"><a id="c003_c3-para-1615"></a>                   s(() =&gt; { x = x + 1; }));</p>
</section>
<section>
<h5><a id="c003_c3-sec-0077"></a><a id="c003_c3-title-0078"></a>Exercise 3.40</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1616"></a>Give all possible values of <span class="KeyTerm1">x</span> that can result from executing</p>
<p class="Sp-text-1"><a id="c003_c3-para-1617"></a><b>let</b> x = 10;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1618"></a>concurrent_execute(() =&gt; { x = x * x; },</p>
<p class="Sp-text-1"><a id="c003_c3-para-1619"></a>                   () =&gt; { x = x * x * x; });</p>
<p class="paracontinue"><a id="c003_c3-para-1620"></a>Which of these possibilities remain if we instead use serialized functions:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1621"></a><b>let</b> x = 10;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1622"></a><b>const</b> s = make_serializer(); concurrent_execute(s(() =&gt; { x = x * x; }),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1623"></a>                   s(() =&gt; { x = x * x * x; }));</p>
</section>
<section>
<h5><a id="c003_c3-sec-0078"></a><a id="c003_c3-title-0079"></a>Exercise 3.41</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1624"></a>Ben Bitdiddle worries that it would be better to implement the bank account as follows (where the commented line has been changed):</p>
<p class="Sp-text-1"><a id="c003_c3-para-1625"></a><b>function</b> make_account(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1626"></a> <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1627"></a> <b>if</b> (balance &gt; amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1628"></a>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1629"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1630"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1631"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1632"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1633"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1634"></a> <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1635"></a>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1636"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1637"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1638"></a> <b>const</b> protect = make_serializer();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1639"></a> <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1640"></a> <b>return</b> m === "withdraw"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1641"></a>               ? protect(withdraw)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1642"></a>               : m === "deposit"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1643"></a>               ? protect(deposit)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1644"></a>               : m === "balance"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1645"></a>               ? protect(() =&gt; balance)(undefined) <span class="KeyTerm2"><i>// serialized</i></span></p>
<p class="Sp-text-1"><a id="c003_c3-para-1646"></a>               : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1647"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1648"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1649"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1650"></a>because allowing unserialized access to the bank balance can result in anomalous behavior. Do you agree? Is there any scenario that demonstrates Ben's concern?</p>
</section>
<section>
<h5><a id="c003_c3-sec-0079"></a><a id="c003_c3-title-0080"></a>Exercise 3.42</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1651"></a>Ben Bitdiddle suggests that it's a waste of time to create a new serialized function in response to every <span class="KeyTerm1">withdraw</span> and <span class="KeyTerm1">deposit</span> message. He says that <span class="KeyTerm1">make_account</span> could be changed so that the calls to <span class="KeyTerm1">protect</span> are done outside the <span class="KeyTerm1">dispatch</span> function. That is, an account would return the same serialized function (which was created at the same time as the account) each time it is asked for a withdrawal function.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1652"></a><b>function</b> make_account(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1653"></a> <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1654"></a> <b>if</b> (balance &gt; amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1655"></a>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1656"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1657"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1658"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1659"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1660"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1661"></a> <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1662"></a>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1663"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1664"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1665"></a> <b>const</b> protect = make_serializer();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1666"></a> <b>const</b> protect_withdraw = protect(withdraw);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1667"></a> <b>const</b> protect_deposit = protect(deposit);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1668"></a> <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1669"></a> <b>return</b> m === "withdraw"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1670"></a>               ? protect_withdraw</p>
<p class="Sp-text-1"><a id="c003_c3-para-1671"></a>               : m === "deposit"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1672"></a>               ? protect_deposit</p>
<p class="Sp-text-1"><a id="c003_c3-para-1673"></a>               : m === "balance"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1674"></a>               ? balance</p>
<p class="Sp-text-1"><a id="c003_c3-para-1675"></a>               : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1676"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1677"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1678"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1679"></a>Is this a safe change to make? In particular, is there any difference in what concurrency is allowed by these two versions of <span class="KeyTerm1">make_account</span> ?</p>
</section>
<section>
<h5><a id="c003_c3-sec-0080"></a><a id="c003_c3-title-0081"></a>Complexity of using multiple shared resources</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1680"></a>Serializers provide a powerful abstraction that helps isolate the complexities of concurrent programs so that they can be dealt with carefully and (hopefully) correctly. However, while using serializers is relatively straightforward when there is only a single shared resource (such as a single bank account), concurrent programming can be treacherously difficult when there are multiple shared resources.</p>
<p><a id="c003_c3-para-1681"></a>To illustrate one of the difficulties that can arise, suppose we wish to swap the balances in two bank accounts. We access each account to find the balance, compute the difference between the balances, withdraw this difference from one account, and deposit it in the other account. We could implement this as follows:<a id="c003_c3-fn-0046a"></a><a href="#c3-fn-0046"><sup>46</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1682"></a><b>function</b> exchange(account1, account2) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1683"></a> <b>const</b> difference = account1("balance") - account2("balance");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1684"></a>    account1("withdraw")(difference);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1685"></a>    account2("deposit")(difference);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1686"></a>}</p>
<p><a id="c003_c3-para-1687"></a>This function works well when only a single thread is trying to do the exchange. Suppose, however, that Peter and Paul both have access to accounts <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, and <i>a</i><sub>3</sub>, and that Peter exchanges <i>a</i><sub>1 </sub>and <i>a</i><sub>2 </sub>while Paul concurrently exchanges <i>a</i><sub>1 </sub>and <i>a</i><sub>3</sub>. Even with account deposits and withdrawals serialized for individual accounts (as in the <span class="KeyTerm1">make_account</span> function shown above in this section), <span class="KeyTerm1">exchange</span> can still produce incorrect results. For example, Peter might compute the difference in the balances for <i>a</i><sub>1</sub> and <i>a</i><sub>2</sub>, but then Paul might change the balance in <i>a</i><sub>1</sub> before Peter is able to complete the exchange.<a id="c003_c3-fn-0047a"></a><a href="#c3-fn-0047"><sup>47</sup></a> For correct behavior, we must arrange for the <span class="KeyTerm1">exchange</span> function to lock out any other concurrent accesses to the accounts during the entire time of the exchange.</p>
<p><a id="c003_c3-para-1688"></a>One way we can accomplish this is by using both accounts’ serializers to serialize the entire <span class="KeyTerm1">exchange</span> function. To do this, we will arrange for access to an account's serializer. Note that we are deliberately breaking the modularity of the bank-account object by exposing the serializer. The following version of <span class="KeyTerm1">make_ account</span> is identical to the original version given in section 3.1.1, except that a serializer is provided to protect the balance variable, and the serializer is exported via message passing:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1689"></a><b>function</b> make_account_and_serializer(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1690"></a> <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1691"></a> <b>if</b> (balance &gt; amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1692"></a>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1693"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1694"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1695"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1696"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1697"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1698"></a> <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1699"></a>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1700"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1701"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1702"></a> <b>const</b> balance_serializer = make_serializer();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1703"></a> <b>return</b> m =&gt; m === "withdraw"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1704"></a>                ? withdraw</p>
<p class="Sp-text-1"><a id="c003_c3-para-1705"></a>                : m === "deposit"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1706"></a>                ? deposit</p>
<p class="Sp-text-1"><a id="c003_c3-para-1707"></a>                : m === "balance"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1708"></a>                ? balance</p>
<p class="Sp-text-1"><a id="c003_c3-para-1709"></a>                : m === "serializer"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1710"></a>                ? balance_serializer</p>
<p class="Sp-text-1"><a id="c003_c3-para-1711"></a>                : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1712"></a>}</p>
<p><a id="c003_c3-para-1713"></a>We can use this to do serialized deposits and withdrawals. However, unlike our earlier serialized account, it is now the responsibility of each user of bank-account objects to explicitly manage the serialization, for example as follows:<a id="c003_c3-fn-0048a"></a><a href="#c3-fn-0048"><sup>48</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1714"></a><b>function</b> deposit(account, amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1715"></a> <b>const</b> s = account("serializer");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1716"></a> <b>const</b> d = account("deposit");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1717"></a>    s(d(amount));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1718"></a>}</p>
<p><a id="c003_c3-para-1719"></a>Exporting the serializer in this way gives us enough flexibility to implement a serialized exchange program. We simply serialize the original <span class="KeyTerm1">exchange</span> function with the serializers for both accounts:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1720"></a><b>function</b> serialized_exchange(account1, account2) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1721"></a> <b>const</b> serializer1 = account1("serializer");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1722"></a> <b>const</b> serializer2 = account2("serializer");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1723"></a>    serializer1(serializer2(exchange))(account1, account2);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1724"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0081"></a><a id="c003_c3-title-0082"></a>Exercise 3.43</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1725"></a>Suppose that the balances in three accounts start out as $10, $20, and $30, and that multiple threads run, exchanging the balances in the accounts. Argue that if the threads are run sequentially, after any number of concurrent exchanges, the account balances should be $10, $20, and $30 in some order. Draw a timing diagram like the one in <a href="#c3-fig-0029">figure 3.29</a> to show how this condition can be violated if the exchanges are implemented using the first version of the account-exchange program in this section. On the other hand, argue that even with this <span class="KeyTerm1">exchange</span> program, the sum of the balances in the accounts will be preserved. Draw a timing diagram to show how even this condition would be violated if we did not serialize the transactions on individual accounts.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0082"></a><a id="c003_c3-title-0083"></a>Exercise 3.44</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1726"></a>Consider the problem of transferring an amount from one account to another. Ben Bitdiddle claims that this can be accomplished with the following function, even if there are multiple people concurrently transferring money among multiple accounts, using any account mechanism that serializes deposit and withdrawal transactions, for example, the version of <span class="KeyTerm1">make_account</span> in the text above.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1727"></a><b>function</b> transfer(from_account, to_account, amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1728"></a>    from_account("withdraw")(amount);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1729"></a>    to_account("deposit")(amount);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1730"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1731"></a>Louis Reasoner claims that there is a problem here, and that we need to use a more sophisticated method, such as the one required for dealing with the exchange problem. Is Louis right? If not, what is the essential difference between the transfer problem and the exchange problem? (You should assume that the balance in <span class="KeyTerm1">from_account</span> is at least <span class="KeyTerm1">amount</span>.)</p>
</section>
<section>
<h5><a id="c003_c3-sec-0083"></a><a id="c003_c3-title-0084"></a>Exercise 3.45</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1732"></a>Louis Reasoner thinks our bank-account system is unnecessarily complex and error-prone now that deposits and withdrawals aren't automatically serialized. He suggests that <span class="KeyTerm1">make_ account_and_serializer</span> should have exported the serializer (for use by such functions as <span class="KeyTerm1">serialized_exchange</span>) in addition to (rather than instead of) using it to serialize accounts and deposits as <span class="KeyTerm1">make_account</span> did. He proposes to redefine accounts as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1733"></a><b>function</b> make_account_and_serializer(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1734"></a> <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1735"></a> <b>if</b> (balance &gt; amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1736"></a>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1737"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1738"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1739"></a> <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c003_c3-para-1740"></a>        }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1741"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1742"></a> <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1743"></a>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1744"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1745"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1746"></a> <b>const</b> balance_serializer = make_serializer();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1747"></a> <b>return</b> m =&gt; m === "withdraw"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1748"></a>                ? balance_serializer(withdraw)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1749"></a>                : m === "deposit"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1750"></a>                ? balance_serializer(deposit)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1751"></a>                : m === "balance"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1752"></a>                ? balance</p>
<p class="Sp-text-1"><a id="c003_c3-para-1753"></a>                : m === "serializer"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1754"></a>                ? balance_serializer</p>
<p class="Sp-text-1"><a id="c003_c3-para-1755"></a>                : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1756"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1757"></a>Then deposits are handled as with the original make_account:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1758"></a><b>function</b> deposit(account, amount) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1759"></a>    account("deposit")(amount);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1760"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1761"></a>Explain what is wrong with Louis's reasoning. In particular, consider what happens when <span class="KeyTerm1">serialized_exchange</span> is called.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0084"></a><a id="c003_c3-title-0085"></a>Implementing serializers</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1762"></a>We implement serializers in terms of a more primitive synchronization mechanism called a <i>mutex</i>. A mutex is an object that supports two operations—the mutex can be <i>acquired</i>, and the mutex can be <i>released</i>. Once a mutex has been acquired, no other acquire operations on that mutex may proceed until the mutex is released.<a id="c003_c3-fn-0049a"></a><a href="#c3-fn-0049"><sup>49</sup></a> In our implementation, each serializer has an associated mutex. Given a function <span class="KeyTerm1">f</span>, the serializer returns a function that acquires the mutex, runs <span class="KeyTerm1">f</span>, and then releases the mutex. This ensures that only one of the functions produced by the serializer can be running at once, which is precisely the serialization property that we need to guarantee. To apply serializers to functions that take an arbitrary number of arguments, we use JavaScript's <i>rest</i> parameter and <i>spread</i> syntax. The <span class="KeyTerm1">…</span> in front of the parameter <span class="KeyTerm1">args</span> collects the rest (here all) of the arguments of any call of the function into a <i>vector</i> data structure. The <span class="KeyTerm1">…</span> in front of <span class="KeyTerm1">args</span> in the application <span class="KeyTerm1">f(…args)</span> spreads the elements of <span class="KeyTerm1">args</span> so that they become separate arguments of <span class="KeyTerm1">f</span>.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1763"></a><b>function</b> make_serializer() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1764"></a> <b>const</b> mutex = make_mutex();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1765"></a> <b>return</b> f =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1766"></a> <b>function</b> serialized_f(…args) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1767"></a>                   mutex("acquire");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1768"></a> <b>const</b> val = f(…args);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1769"></a>                   mutex("release");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1770"></a> <b>return</b> val;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1771"></a>               }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1772"></a> <b>return</b> serialized_f;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1773"></a>           };</p>
<p class="Sp-text-1"><a id="c003_c3-para-1774"></a>}</p>
<p><a id="c003_c3-para-1775"></a>The mutex is a mutable object (here we'll use a one-element list, which we'll refer to as a <i>cell</i>) that can hold the value true or false. When the value is false, the mutex is available to be acquired. When the value is true, the mutex is unavailable, and any thread that attempts to acquire the mutex must wait.</p>
<p><a id="c003_c3-para-1776"></a>Our mutex constructor <span class="KeyTerm1">make_mutex</span> begins by initializing the cell contents to false. To acquire the mutex, we test the cell. If the mutex is available, we set the cell contents to true and proceed. Otherwise, we wait in a loop, attempting to acquire over and over again, until we find that the mutex is available.<a id="c003_c3-fn-0050a"></a><a href="#c3-fn-0050"><sup>50</sup></a> To release the mutex, we set the cell contents to false.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1777"></a><b>function</b> make_mutex() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1778"></a> <b>const</b> cell = list(<b>false</b>);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1779"></a> <b>function</b> the_mutex(m) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1780"></a> <b>return</b> m === "acquire"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1781"></a>           ? test_and_set(cell)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1782"></a>             ? the_mutex("acquire") <i>// retry</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-1783"></a>             : <b>true</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-1784"></a>           : m === "release"</p>
<p class="Sp-text-1"><a id="c003_c3-para-1785"></a>           ? clear(cell)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1786"></a>           : error(m, "unknown request – mutex");</p>
<p class="Sp-text-1"><a id="c003_c3-para-1787"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1788"></a> <b>return</b> the_mutex;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1789"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1790"></a><b>function</b> clear(cell) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1791"></a>    set_head(cell, <b>false</b>);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1792"></a>}</p>
<p><a id="c003_c3-para-1793"></a>The function <span class="KeyTerm1">test_and_set</span> tests the cell and returns the result of the test. In addition, if the test was false, <span class="KeyTerm1">test_and_set</span> sets the cell contents to true before returning false. We can express this behavior as the following function:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1794"></a><b>function</b> test_and_set(cell) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1795"></a> <b>if</b> (head(cell)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1796"></a> <b>return true</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1797"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1798"></a>        set_head(cell, <b>true</b>);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1799"></a> <b>return false</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1800"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1801"></a>}</p>
<p><a id="c003_c3-para-1802"></a>However, this implementation of <span class="KeyTerm1">test_and_set</span> does not suffice as it stands. There is a crucial subtlety here, which is the essential place where concurrency control enters the system: The <span class="KeyTerm1">test_and_set</span> operation must be performed <i>atomically</i>. That is, we must guarantee that, once a thread has tested the cell and found it to be false, the cell contents will actually be set to true before any other thread can test the cell. If we do not make this guarantee, then the mutex can fail in a way similar to the bank-account failure in <a href="#c3-fig-0029">figure 3.29</a>. (See exercise 3.46.)</p>
<p><a id="c003_c3-para-1803"></a>The actual implementation of <span class="KeyTerm1">test_and_set</span> depends on the details of how our system runs concurrent threads. For example, we might be executing concurrent threads on a sequential processor using a time-slicing mechanism that cycles through the threads, permitting each thread to run for a short time before interrupting it and moving on to the next thread. In that case, <span class="KeyTerm1">test_and_set</span> can work by disabling time slicing during the testing and setting. Alternatively, multiprocessing computers provide instructions that support atomic operations directly in hardware.<a id="c003_c3-fn-0051a"></a><a href="#c3-fn-0051"><sup>51</sup></a></p>
</section>
<section>
<h5><a id="c003_c3-sec-0085"></a><a id="c003_c3-title-0086"></a>Exercise 3.46</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1804"></a>Suppose that we implement <span class="KeyTerm1">test_and_set</span> using an ordinary function as shown in the text, without attempting to make the operation atomic. Draw a timing diagram like the one in <a href="#c3-fig-0029">figure 3.29</a> to demonstrate how the mutex implementation can fail by allowing two threads to acquire the mutex at the same time.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0086"></a><a id="c003_c3-title-0087"></a>Exercise 3.47</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1805"></a>A semaphore (of size <i>n</i>) is a generalization of a mutex. Like a mutex, a semaphore supports acquire and release operations, but it is more general in that up to <i>n</i> threads can acquire it concurrently. Additional threads that attempt to acquire the semaphore must wait for release operations. Give implementations of semaphores</p>
<ol class="BS_NumberListA">
<li><a id="c003_c3-li-0029"></a><span>a. </span>in terms of mutexes</li>
<li><a id="c003_c3-li-0030"></a><span>b. </span>in terms of atomic <span class="KeyTerm1">test_and_set</span> operations.</li>
</ol>
</section>
<section>
<h5><a id="c003_c3-sec-0087"></a><a id="c003_c3-title-0088"></a>Deadlock</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1808"></a>Now that we have seen how to implement serializers, we can see that account exchanging still has a problem, even with the <span class="KeyTerm1">serialized_exchange</span> function above. Imagine that Peter attempts to exchange <i>a</i><sub>1</sub> with <i>a</i><sub>2</sub> while Paul concurrently attempts to exchange <i>a</i><sub>2</sub> with <i>a</i><sub>1</sub>. Suppose that Peter's thread reaches the point where it has entered a serialized function protecting <i>a</i><sub>1</sub> and, just after that, Paul's thread enters a serialized function protecting <i>a</i><sub>2</sub>. Now Peter cannot proceed (to enter a serialized function protecting <i>a</i><sub>2</sub>) until Paul exits the serialized function protecting <i>a</i><sub>2</sub>. Similarly, Paul cannot proceed until Peter exits the serialized function protecting <i>a</i><sub>1</sub>. Each thread is stalled forever, waiting for the other. This situation is called a <i>deadlock</i>. Deadlock is always a danger in systems that provide concurrent access to multiple shared resources.</p>
<p><a id="c003_c3-para-1809"></a>One way to avoid the deadlock in this situation is to give each account a unique identification number and rewrite <span class="KeyTerm1">serialized_exchange</span> so that a thread will always attempt to enter a function protecting the lowest-numbered account first. Although this method works well for the exchange problem, there are other situations that require more sophisticated deadlock-avoidance techniques, or where deadlock cannot be avoided at all. (See exercises 3.48 and 3.49.)<a id="c003_c3-fn-0052a"></a><a href="#c3-fn-0052"><sup>52</sup></a></p>
</section>
<section>
<h5><a id="c003_c3-sec-0088"></a><a id="c003_c3-title-0089"></a>Exercise 3.48</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1810"></a>Explain in detail why the deadlock-avoidance method described above, (i.e., the accounts are numbered, and each thread attempts to acquire the smaller-numbered account first) avoids deadlock in the exchange problem. Rewrite <span class="KeyTerm1">serialized_exchange</span> to incorporate this idea. (You will also need to modify <span class="KeyTerm1">make_account</span> so that each account is created with a number, which can be accessed by sending an appropriate message.)</p>
</section>
<section>
<h5><a id="c003_c3-sec-0089"></a><a id="c003_c3-title-0090"></a>Exercise 3.49</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1811"></a>Give a scenario where the deadlock-avoidance mechanism described above does not work. (Hint: In the exchange problem, each thread knows in advance which accounts it will need to get access to. Consider a situation where a thread must get access to some shared resources before it can know which additional shared resources it will require.)</p>
</section>
<section>
<h5><a id="c003_c3-sec-0090"></a><a id="c003_c3-title-0091"></a>Concurrency, time, and communication</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1812"></a>We've seen how programming concurrent systems requires controlling the ordering of events when different threads access shared state, and we've seen how to achieve this control through judicious use of serializers. But the problems of concurrency lie deeper than this, because, from a fundamental point of view, it's not always clear what is meant by “shared state.”</p>
<p><a id="c003_c3-para-1813"></a>Mechanisms such as <span class="KeyTerm1">test_and_set</span> require threads to examine a global shared flag at arbitrary times. This is problematic and inefficient to implement in modern high-speed processors, where due to optimization techniques such as pipelining and cached memory, the contents of memory may not be in a consistent state at every instant. In some multiprocessing systems, therefore, the serializer paradigm is being supplanted by other approaches to concurrency control.<a id="c003_c3-fn-0053a"></a><a href="#c3-fn-0053"><sup>53</sup></a></p>
<p><a id="c003_c3-para-1814"></a>The problematic aspects of shared state also arise in large, distributed systems. For instance, imagine a distributed banking system where individual branch banks maintain local values for bank balances and periodically compare these with values maintained by other branches. In such a system the value of “the account balance” would be undetermined, except right after synchronization. If Peter deposits money in an account he holds jointly with Paul, when should we say that the account balance has changed—when the balance in the local branch changes, or not until after the synchronization? And if Paul accesses the account from a different branch, what are the reasonable constraints to place on the banking system such that the behavior is “correct”? The only thing that might matter for correctness is the behavior observed by Peter and Paul individually and the “state” of the account immediately after synchronization. Questions about the “real” account balance or the order of events between synchronizations may be irrelevant or meaningless.<a id="c003_c3-fn-0054a"></a><a href="#c3-fn-0054"><sup>54</sup></a></p>
<p><a id="c003_c3-para-1815"></a>The basic phenomenon here is that synchronizing different threads, establishing shared state, or imposing an order on events requires communication among the threads. In essence, any notion of time in concurrency control must be intimately tied to communication.<a id="c003_c3-fn-0055a"></a><a href="#c3-fn-0055"><sup>55</sup></a> It is intriguing that a similar connection between time and communication also arises in the Theory of Relativity, where the speed of light (the fastest signal that can be used to synchronize events) is a fundamental constant relating time and space. The complexities we encounter in dealing with time and state in our computational models may in fact mirror a fundamental complexity of the physical universe.</p>
</section>
</section>
</section>
<section>
<h2><a id="c003_c3-sec-0091"></a><span>3.5</span> <a id="c003_c3-title-0092"></a>Streams</h2>
<p class="paraaftertitle"><a id="c003_c3-para-1816"></a>We've gained a good understanding of assignment as a tool in modeling, as well as an appreciation of the complex problems that assignment raises. It is time to ask whether we could have gone about things in a different way, so as to avoid some of these problems. In this section, we explore an alternative approach to modeling state, based on data structures called <i>streams</i>. As we shall see, streams can mitigate some of the complexity of modeling state.</p>
<p><a id="c003_c3-para-1817"></a>Let's step back and review where this complexity comes from. In an attempt to model real-world phenomena, we made some apparently reasonable decisions: We modeled real-world objects with local state by computational objects with local variables. We identified time variation in the real world with time variation in the computer. We implemented the time variation of the states of the model objects in the computer with assignments to the local variables of the model objects.</p>
<p><a id="c003_c3-para-1818"></a>Is there another approach? Can we avoid identifying time in the computer with time in the modeled world? Must we make the model change with time in order to model phenomena in a changing world? Think about the issue in terms of mathematical functions. We can describe the time-varying behavior of a quantity <i>x</i> as a function of time <i>x</i>(<i>t</i>). If we concentrate on <i>x</i> instant by instant, we think of it as a changing quantity. Yet if we concentrate on the entire time history of values, we do not emphasize change—the function itself does not change.<a id="c003_c3-fn-0056a"></a><a href="#c3-fn-0056"><sup>56</sup></a></p>
<p><a id="c003_c3-para-1819"></a>If time is measured in discrete steps, then we can model a time function as a (possibly infinite) sequence. In this section, we will see how to model change in terms of sequences that represent the time histories of the systems being modeled. To accomplish this, we introduce new data structures called <i>streams</i>. From an abstract point of view, a stream is simply a sequence. However, we will find that the straightforward implementation of streams as lists (as in section 2.2.1) doesn't fully reveal the power of stream processing. As an alternative, we introduce the technique of <i>delayed evaluation</i>, which enables us to represent very large (even infinite) sequences as streams.</p>
<p><a id="c003_c3-para-1820"></a>Stream processing lets us model systems that have state without ever using assignment or mutable data. This has important implications, both theoretical and practical, because we can build models that avoid the drawbacks inherent in introducing assignment. On the other hand, the stream framework raises difficulties of its own, and the question of which modeling technique leads to more modular and more easily maintained systems remains open.</p>
<section>
<h3><a id="c003_c3-sec-0092"></a><span>3.5.1</span> <a id="c003_c3-title-0093"></a>Streams Are Delayed Lists</h3>
<p class="paraaftertitle"><a id="c003_c3-para-1821"></a>As we saw in section 2.2.3, sequences can serve as standard interfaces for combining program modules. We formulated powerful abstractions for manipulating sequences, such as <span class="KeyTerm1">map</span>, <span class="KeyTerm1">filter</span>, and <span class="KeyTerm1">accumulate</span>, that capture a wide variety of operations in a manner that is both succinct and elegant.</p>
<p><a id="c003_c3-para-1822"></a>Unfortunately, if we represent sequences as lists, this elegance is bought at the price of severe inefficiency with respect to both the time and space required by our computations. When we represent manipulations on sequences as transformations of lists, our programs must construct and copy data structures (which may be huge) at every step of a process.</p>
<p><a id="c003_c3-para-1823"></a>To see why this is true, let us compare two programs for computing the sum of all the prime numbers in an interval. The first program is written in standard iterative style:<a id="c003_c3-fn-0057a"></a><a href="#c3-fn-0057"><sup>57</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1824"></a><b>function</b> sum_primes(a, b) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1825"></a> <b>function</b> iter(count, accum) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1826"></a> <b>return</b> count &gt; b</p>
<p class="Sp-text-1"><a id="c003_c3-para-1827"></a>               ? accum</p>
<p class="Sp-text-1"><a id="c003_c3-para-1828"></a>               : is_prime(count)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1829"></a>               ? iter(count + 1, count + accum)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1830"></a>               : iter(count + 1, accum);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1831"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1832"></a> <b>return</b> iter(a, 0);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1833"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1834"></a>The second program performs the same computation using the sequence operations of section 2.2.3:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1835"></a><b>function</b> sum_primes(a, b) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1836"></a> <b>return</b> accumulate((x, y) =&gt; x + y,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1837"></a>                      0,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1838"></a>                      filter(is_prime,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1839"></a>                             enumerate_interval(a, b)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1840"></a>}</p>
<p><a id="c003_c3-para-1841"></a>In carrying out the computation, the first program needs to store only the sum being accumulated. In contrast, the filter in the second program cannot do any testing until <span class="KeyTerm1">enumerate_interval</span> has constructed a complete list of the numbers in the interval. The filter generates another list, which in turn is passed to <span class="KeyTerm1">accumulate</span> before being collapsed to form a sum. Such large intermediate storage is not needed by the first program, which we can think of as enumerating the interval incrementally, adding each prime to the sum as it is generated.</p>
<p><a id="c003_c3-para-1842"></a>The inefficiency in using lists becomes painfully apparent if we use the sequence paradigm to compute the second prime in the interval from 10,000 to 1,000,000 by evaluating the expression</p>
<p class="Sp-text-1"><a id="c003_c3-para-1843"></a>head(tail(filter(is_prime,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1844"></a>                 enumerate_interval(10000, 1000000))));</p>
<p class="paracontinue"><a id="c003_c3-para-1845"></a>This expression does find the second prime, but the computational overhead is outrageous. We construct a list of almost a million integers, filter this list by testing each element for primality, and then ignore almost all of the result. In a more traditional programming style, we would interleave the enumeration and the filtering, and stop when we reached the second prime.</p>
<p><a id="c003_c3-para-1846"></a>Streams are a clever idea that allows one to use sequence manipulations without incurring the costs of manipulating sequences as lists. With streams we can achieve the best of both worlds: We can formulate programs elegantly as sequence manipulations, while attaining the efficiency of incremental computation. The basic idea is to arrange to construct a stream only partially, and to pass the partial construction to the program that consumes the stream. If the consumer attempts to access a part of the stream that has not yet been constructed, the stream will automatically construct just enough more of itself to produce the required part, thus preserving the illusion that the entire stream exists. In other words, although we will write programs as if we were processing complete sequences, we design our stream implementation to automatically and transparently interleave the construction of the stream with its use.</p>
<p><a id="c003_c3-para-1847"></a>To accomplish this, we will construct streams using pairs, with the first item of the stream in the head of the pair. However, rather than placing the value of the rest of the stream into the tail of the pair, we will put there a “promise” to compute the rest if it is ever requested. If we have a data item <span class="KeyTerm1">h</span> and a stream <span class="KeyTerm1">t</span>, we construct a stream whose head is <span class="KeyTerm1">h</span> and whose tail is <span class="KeyTerm1">t</span> by evaluating <span class="KeyTerm1">pair(h, () =&gt; t)</span>—the tail <span class="KeyTerm1">t</span> of a stream is “wrapped” in a function of no arguments, so that its evaluation will be <i>delayed</i>. The empty stream is <span class="KeyTerm1"><b>null</b></span>, the same as the empty list.</p>
<p><a id="c003_c3-para-1848"></a>To access the first data item of a nonempty stream, we simply select the <span class="KeyTerm1">head</span> of the pair, as with a list. But to access the tail of a stream, we need to evaluate the delayed expression. For convenience, we define</p>
<p class="Sp-text-1"><a id="c003_c3-para-1849"></a><b>function</b> stream_tail(stream) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1850"></a> <b>return</b> tail(stream)();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1851"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1852"></a>This selects the tail of the pair and applies the function found there to obtain the next pair of the stream (or <span class="KeyTerm1"><b>null</b></span> if the tail of the stream is empty)—in effect, <i>forcing</i> the function in the tail of the pair to fulfill its promise.</p>
<p><a id="c003_c3-para-1853"></a>We can make and use streams, in just the same way as we can make and use lists, to represent aggregate data arranged in a sequence. In particular, we can build stream analogs of the list operations from chapter 2, such as <span class="KeyTerm1">list_ref</span>, <span class="KeyTerm1">map</span>, and <span class="KeyTerm1">for_each</span>:<a id="c003_c3-fn-0058a"></a><a href="#c3-fn-0058"><sup>58</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1854"></a><b>function</b> stream_ref(s, n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1855"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c003_c3-para-1856"></a>           ? head(s)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1857"></a>           : stream_ref(stream_tail(s), n - 1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1858"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1859"></a><b>function</b> stream_map(f, s) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1860"></a> <b>return</b> is_null(s)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1861"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-1862"></a>           : pair(f(head(s)),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1863"></a>                  () =&gt; stream_map(f, stream_tail(s)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1864"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1865"></a><b>function</b> stream_for_each(fun, s) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1866"></a> <b>if</b> (is_null(s)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1867"></a> <b>return true</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1868"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1869"></a>        fun(head(s));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1870"></a> <b>return</b> stream_for_each(fun, stream_tail(s));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1871"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1872"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1873"></a>The function <span class="KeyTerm1">stream_for_each</span> is useful for viewing streams:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1874"></a><b>function</b> display_stream(s) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1875"></a> <b>return</b> stream_for_each(display, s);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1876"></a>}</p>
<p><a id="c003_c3-para-1877"></a>To make the stream implementation automatically and transparently interleave the construction of a stream with its use, we have arranged for the tail of a stream to be evaluated when it is accessed by the <span class="KeyTerm1">stream_tail</span> function rather than when the stream is constructed by <span class="KeyTerm1">pair</span>. This implementation choice is reminiscent of our discussion of rational numbers in section 2.1.2, where we saw that we can choose to implement rational numbers so that the reduction of numerator and denominator to lowest terms is performed either at construction time or at selection time. The two rational-number implementations produce the same data abstraction, but the choice has an effect on efficiency. There is a similar relationship between streams and ordinary lists. As a data abstraction, streams are the same as lists. The difference is the time at which the elements are evaluated. With ordinary lists, both the <span class="KeyTerm1">head</span> and the <span class="KeyTerm1">tail</span> are evaluated at construction time. With streams, the <span class="KeyTerm1">tail</span> is evaluated at selection time.</p>
<section>
<h5><a id="c003_c3-sec-0093"></a><a id="c003_c3-title-0094"></a>Streams in action</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1878"></a>To see how this data structure behaves, let us analyze the “outrageous” prime computation we saw above, reformulated in terms of streams:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1879"></a>head(stream_tail(stream_filter(</p>
<p class="Sp-text-1"><a id="c003_c3-para-1880"></a>                     is_prime,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1881"></a>                     stream_enumerate_interval(10000, 1000000))));</p>
<p class="paracontinue"><a id="c003_c3-para-1882"></a>We will see that it does indeed work efficiently.</p>
<p><a id="c003_c3-para-1883"></a>We begin by calling <span class="KeyTerm1">stream_enumerate_interval</span> with the arguments 10,000 and 1,000,000. The function <span class="KeyTerm1">stream_enumerate_interval</span> is the stream analog of <span class="KeyTerm1">enumerate_interval</span> (section 2.2.3):</p>
<p class="Sp-text-1"><a id="c003_c3-para-1884"></a><b>function</b> stream_enumerate_interval(low, high) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1885"></a> <b>return</b> low &gt; high</p>
<p class="Sp-text-1"><a id="c003_c3-para-1886"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-1887"></a>           : pair(low,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1888"></a>                  () =&gt; stream_enumerate_interval(low + 1, high));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1889"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1890"></a>and thus the result returned by <span class="KeyTerm1">stream_enumerate_interval</span>, formed by the <span class="KeyTerm1">pair</span>, is<a id="c003_c3-fn-0059a"></a><a href="#c3-fn-0059"><sup>59</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1891"></a>pair(10000, () =&gt; stream_enumerate_interval(10001, 1000000));</p>
<p class="paracontinue"><a id="c003_c3-para-1892"></a>That is, <span class="KeyTerm1">stream_enumerate_interval</span> returns a stream represented as a pair whose <span class="KeyTerm1">head</span> is 10,000 and whose <span class="KeyTerm1">tail</span> is a promise to enumerate more of the interval if so requested. This stream is now filtered for primes, using the stream analog of the <span class="KeyTerm1">filter</span> function (section 2.2.3):</p>
<p class="Sp-text-1"><a id="c003_c3-para-1893"></a><b>function</b> stream_filter(pred, stream) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1894"></a> <b>return</b> is_null(stream)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1895"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-1896"></a>           : pred(head(stream))</p>
<p class="Sp-text-1"><a id="c003_c3-para-1897"></a>           ? pair(head(stream),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1898"></a>                  () =&gt; stream_filter(pred, stream_tail(stream)))</p>
<p class="Sp-text-1"><a id="c003_c3-para-1899"></a>           : stream_filter(pred, stream_tail(stream));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1900"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1901"></a>The function <span class="KeyTerm1">stream_filter</span> tests the <span class="KeyTerm1">head</span> of the stream (which is 10,000). Since this is not prime, <span class="KeyTerm1">stream_filter</span> examines the tail of its input stream. The call to <span class="KeyTerm1">stream_tail</span> forces evaluation of the delayed <span class="KeyTerm1">stream_enumerate_interval</span>, which now returns</p>
<p class="Sp-text-1"><a id="c003_c3-para-1902"></a>pair(10001, () =&gt; stream_enumerate_interval(10002, 1000000));</p>
<p class="paracontinue"><a id="c003_c3-para-1903"></a>The function <span class="KeyTerm1">stream_filter</span> now looks at the <span class="KeyTerm1">head</span> of this stream, 10,001, sees that this is not prime either, forces another <span class="KeyTerm1">stream_tail</span>, and so on, until <span class="KeyTerm1">stream_ enumerate_interval</span> yields the prime 10,007, whereupon <span class="KeyTerm1">stream_filter</span>, according to its definition, returns</p>
<p class="Sp-text-1"><a id="c003_c3-para-1904"></a>pair(head(stream),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1905"></a>     stream_filter(pred, stream_tail(stream)));</p>
<p class="paracontinue"><a id="c003_c3-para-1906"></a>which in this case is</p>
<p class="Sp-text-1"><a id="c003_c3-para-1907"></a>pair(10007,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1908"></a>     () =&gt; stream_filter(</p>
<p class="Sp-text-1"><a id="c003_c3-para-1909"></a>              is_prime,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1910"></a>              pair(10008,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1911"></a>                   () =&gt; stream_enumerate_interval(10009, 1000000))));</p>
<p class="paracontinue"><a id="c003_c3-para-1912"></a>This result is now passed to <span class="KeyTerm1">stream_tail</span> in our original expression. This forces the delayed <span class="KeyTerm1">stream_filter</span>, which in turn keeps forcing the delayed <span class="KeyTerm1">stream_ enumerate_interval</span> until it finds the next prime, which is 10,009. Finally, the result passed to <span class="KeyTerm1">head</span> in our original expression is</p>
<p class="Sp-text-1"><a id="c003_c3-para-1913"></a>pair(10009,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1914"></a>     () =&gt; stream_filter(</p>
<p class="Sp-text-1"><a id="c003_c3-para-1915"></a>              is_prime,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1916"></a>              pair(10010,</p>
<p class="Sp-text-1"><a id="c003_c3-para-1917"></a>                   () =&gt; stream_enumerate_interval(10011, 1000000))));</p>
<p class="paracontinue"><a id="c003_c3-para-1918"></a>The function <span class="KeyTerm1">head</span> returns 10,009, and the computation is complete. Only as many integers were tested for primality as were necessary to find the second prime, and the interval was enumerated only as far as was necessary to feed the prime filter.</p>
<p><a id="c003_c3-para-1919"></a>In general, we can think of delayed evaluation as “demand-driven” programming, whereby each stage in the stream process is activated only enough to satisfy the next stage. What we have done is to decouple the actual order of events in the computation from the apparent structure of our functions. We write functions as if the streams existed “all at once” when, in reality, the computation is performed incrementally, as in traditional programming styles.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0094"></a><a id="c003_c3-title-0095"></a>An optimization</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1920"></a>When we construct stream pairs, we delay the evaluation of their tail expressions by wrapping these expressions in a function. We force their evaluation when needed, by applying the function.</p>
<p><a id="c003_c3-para-1921"></a>This implementation suffices for streams to work as advertised, but there is an important optimization that we shall consider where needed. In many applications, we end up forcing the same delayed object many times. This can lead to serious inefficiency in recursive programs involving streams. (See exercise 3.57.) The solution is to build delayed objects so that the first time they are forced, they store the value that is computed. Subsequent forcings will simply return the stored value without repeating the computation. In other words, we implement the construction of stream pairs as a memoized function similar to the one described in exercise 3.27. One way to accomplish this is to use the following function, which takes as argument a function (of no arguments) and returns a memoized version of the function. The first time the memoized function is run, it saves the computed result. On subsequent evaluations, it simply returns the result.<a id="c003_c3-fn-0060a"></a><a href="#c3-fn-0060"><sup>60</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1922"></a><b>function</b> memo(fun) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1923"></a> <b>let</b> already_run = <b>false</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1924"></a> <b>let</b> result = undefined;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1925"></a> <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1926"></a> <b>if</b> (!already_run) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1927"></a>                   result = fun();</p>
<p class="Sp-text-1"><a id="c003_c3-para-1928"></a>                   already_run = <b>true</b>;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1929"></a> <b>return</b> result;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1930"></a>               } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1931"></a> <b>return</b> result;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1932"></a>               }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1933"></a>           };</p>
<p class="Sp-text-1"><a id="c003_c3-para-1934"></a>}</p>
<p><a id="c003_c3-para-1935"></a>We can make use of <span class="KeyTerm1">memo</span> whenever we construct a stream pair. For example, instead of</p>
<p class="Sp-text-1"><a id="c003_c3-para-1936"></a><b>function</b> stream_map(f, s) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1937"></a> <b>return</b> is_null(s)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1938"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-1939"></a>           : pair(f(head(s)),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1940"></a>                  () =&gt; stream_map(f, stream_tail(s)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1941"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1942"></a>we can define an optimized function stream_map as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1943"></a><b>function</b> stream_map_optimized(f, s) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1944"></a> <b>return</b> is_null(s)</p>
<p class="Sp-text-1"><a id="c003_c3-para-1945"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-1946"></a>           : pair(f(head(s)),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1947"></a>                  memo(() =&gt;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1948"></a>                         stream_map_optimized(f, stream_tail(s))));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1949"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0095"></a><a id="c003_c3-title-0096"></a>Exercise 3.50</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1950"></a>Declare a function stream_map_2 that takes a binary function and two streams as arguments and returns a stream whose elements are the results of applying the function pairwise to the corresponding elements of the argument streams.</p>
<p class="Sp-text-1"><a id="c003_c3-para-1951"></a><b>function</b> stream_map_2(f, s1, s2) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1952"></a>    …</p>
<p class="Sp-text-1"><a id="c003_c3-para-1953"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-1954"></a>Similar to <span class="KeyTerm1">stream_map_optimized</span>, declare a function <span class="KeyTerm1">stream_map_2_optimized</span> by modifying your <span class="KeyTerm1">stream_map_2</span> such that the result stream employs memoization.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0096"></a><a id="c003_c3-title-0097"></a>Exercise 3.51</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1955"></a>Note that our primitive function <span class="KeyTerm1">display</span> returns its argument after displaying it. What does the interpreter print in response to evaluating each statement in the following sequence?<a id="c003_c3-fn-0061a"></a><a href="#c3-fn-0061"><sup>61</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-1956"></a><b>let</b> x = stream_map(display, stream_enumerate_interval(0, 10));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1957"></a>stream_ref(x, 5);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1958"></a>stream_ref(x, 7);</p>
<p class="paracontinue"><a id="c003_c3-para-1959"></a>What does the interpreter print if <span class="KeyTerm1">stream_map_optimized</span> is used instead of stream_map?</p>
<p class="Sp-text-1"><a id="c003_c3-para-1960"></a><b>let</b> x = stream_map_optimized(display, stream_enumerate_interval(0, 10));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1961"></a>stream_ref(x, 5);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1962"></a>stream_ref(x, 7);</p>
</section>
<section>
<h5><a id="c003_c3-sec-0097"></a><a id="c003_c3-title-0098"></a>Exercise 3.52</h5>
<p class="paraaftertitle"><a id="c003_c3-para-1963"></a>Consider the sequence of statements</p>
<p class="Sp-text-1"><a id="c003_c3-para-1964"></a><b>let</b> sum = 0;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1965"></a><b>function</b> accum(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1966"></a>    sum = x + sum;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1967"></a> <b>return</b> sum;</p>
<p class="Sp-text-1"><a id="c003_c3-para-1968"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1969"></a><b>const</b> seq = stream_map(accum, stream_enumerate_interval(1, 20));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1970"></a><b>const</b> y = stream_filter(is_even, seq);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1971"></a><b>const</b> z = stream_filter(x =&gt; x % 5 === 0, seq);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1972"></a>stream_ref(y, 7);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1973"></a>display_stream(z);</p>
<p class="paracontinue"><a id="c003_c3-para-1974"></a>What is the value of <span class="KeyTerm1">sum</span> after each of the above statements is evaluated? What is the printed response to evaluating the <span class="KeyTerm1">stream_ref</span> and <span class="KeyTerm1">display_stream</span> expressions? Would these responses differ if we had applied the function <span class="KeyTerm1">memo</span> on every tail of every constructed stream pair, as suggested in the optimization above? Explain.</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0098"></a><span>3.5.2</span> <a id="c003_c3-title-0099"></a>Infinite Streams</h3>
<p class="paraaftertitle"><a id="c003_c3-para-1975"></a>We have seen how to support the illusion of manipulating streams as complete entities even though, in actuality, we compute only as much of the stream as we need to access. We can exploit this technique to represent sequences efficiently as streams, even if the sequences are very long. What is more striking, we can use streams to represent sequences that are infinitely long. For instance, consider the following definition of the stream of positive integers:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1976"></a><b>function</b> integers_starting_from(n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1977"></a> <b>return</b> pair(n, () =&gt; integers_starting_from(n + 1));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1978"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1979"></a><b>const</b> integers = integers_starting_from(1);</p>
<p class="paracontinue"><a id="c003_c3-para-1980"></a>This makes sense because <span class="KeyTerm1">integers</span> will be a pair whose <span class="KeyTerm1">head</span> is 1 and whose <span class="KeyTerm1">tail</span> is a promise to produce the integers beginning with 2. This is an infinitely long stream, but in any given time we can examine only a finite portion of it. Thus, our programs will never know that the entire infinite stream is not there.</p>
<p><a id="c003_c3-para-1981"></a>Using <span class="KeyTerm1">integers</span> we can define other infinite streams, such as the stream of integers that are not divisible by 7:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1982"></a><b>function</b> is_divisible(x, y) { <b>return</b> x % y === 0; }</p>
<p class="Sp-text-1"><a id="c003_c3-para-1983"></a><b>const</b> no_sevens = stream_filter(x =&gt; ! is_divisible(x, 7),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1984"></a>                                integers);</p>
<p class="paracontinue"><a id="c003_c3-para-1985"></a>Then we can find integers not divisible by 7 simply by accessing elements of this stream:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1986"></a>stream_ref(no_sevens, 100);</p>
<p class="Sp-text-1"><a id="c003_c3-para-1987"></a><i>117</i></p>
<p><a id="c003_c3-para-1988"></a>In analogy with <span class="KeyTerm1">integers</span>, we can define the infinite stream of Fibonacci numbers:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1989"></a><b>function</b> fibgen(a, b) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1990"></a> <b>return</b> pair(a, () =&gt; fibgen(b, a + b));</p>
<p class="Sp-text-1"><a id="c003_c3-para-1991"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-1992"></a><b>const</b> fibs = fibgen(0, 1);</p>
<p class="paracontinue"><a id="c003_c3-para-1993"></a>The constant <span class="KeyTerm1">fibs</span> is a pair whose <span class="KeyTerm1">head</span> is 0 and whose <span class="KeyTerm1">tail</span> is a promise to evaluate <span class="KeyTerm1">fibgen(1, 1)</span>. When we evaluate this delayed <span class="KeyTerm1">fibgen(1, 1)</span>, it will produce a pair whose <span class="KeyTerm1">head</span> is 1 and whose <span class="KeyTerm1">tail</span> is a promise to evaluate <span class="KeyTerm1">fibgen(1, 2)</span>, and so on.</p>
<p><a id="c003_c3-para-1994"></a>For a look at a more exciting infinite stream, we can generalize the <span class="KeyTerm1">no_sevens</span> example to construct the infinite stream of prime numbers, using a method known as the <i>sieve of Eratosthenes</i>.<a id="c003_c3-fn-0062a"></a><a href="#c3-fn-0062"><sup>62</sup></a> We start with the integers beginning with 2, which is the first prime. To get the rest of the primes, we start by filtering the multiples of 2 from the rest of the integers. This leaves a stream beginning with 3, which is the next prime. Now we filter the multiples of 3 from the rest of this stream. This leaves a stream beginning with 5, which is the next prime, and so on. In other words, we construct the primes by a sieving process, described as follows: To sieve a stream S, form a stream whose first element is the first element of S and the rest of which is obtained by filtering all multiples of the first element of S out of the rest of S and sieving the result. This process is readily described in terms of stream operations:</p>
<p class="Sp-text-1"><a id="c003_c3-para-1995"></a><b>function</b> sieve(stream) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-1996"></a> <b>return</b> pair(head(stream),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1997"></a>                () =&gt; sieve(stream_filter(</p>
<p class="Sp-text-1"><a id="c003_c3-para-1998"></a>                                 x =&gt; ! is_divisible(x, head(stream)),</p>
<p class="Sp-text-1"><a id="c003_c3-para-1999"></a>                                 stream_tail(stream))));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2000"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-2001"></a><b>const</b> primes = sieve(integers_starting_from(2));</p>
<p class="paracontinue"><a id="c003_c3-para-2002"></a>Now to find a particular prime we need only ask for it:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2003"></a>stream_ref(primes, 50);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2004"></a><i>233</i></p>
<p><a id="c003_c3-para-2005"></a>It is interesting to contemplate the signal-processing system set up by <span class="KeyTerm1">sieve</span>, shown in the “Henderson diagram” in <a id="c003_c3-fig-0031a"></a><a href="#c3-fig-0031">figure 3.31</a>.<a id="c003_c3-fn-0063a"></a><a href="#c3-fn-0063"><sup>63</sup></a> The input stream feeds into an “un<span class="KeyTerm1">pair</span>er” that separates the first element of the stream from the rest of the stream. The first element is used to construct a divisibility filter, through which the rest is passed, and the output of the filter is fed to another sieve box. Then the original first element is adjoined to the output of the internal sieve to form the output stream. Thus, not only is the stream infinite, but the signal processor is also infinite, because the sieve contains a sieve within it.</p>
<figure id="c003_c3-fig-0031"><img alt="c3-fig-0031.jpg" src="../images/c3-fig-0031.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0031a">Figure 3.31</a></span> <a id="c003_c3-para-2006"></a>The prime sieve viewed as a signal-processing system. Each solid line represents a stream of values being transmitted. The dashed line from the <span class="KeyTerm1">head</span> to the <span class="KeyTerm1">pair</span> and the <span class="KeyTerm1">filter</span> indicates that this is a single value rather than a stream.</p></figcaption></figure>
<section>
<h5><a id="c003_c3-sec-0099"></a><a id="c003_c3-title-0100"></a>Defining streams implicitly</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2007"></a>The <span class="KeyTerm1">integers</span> and <span class="KeyTerm1">fibs</span> streams above were defined by specifying “generating” functions that explicitly compute the stream elements one by one. An alternative way to specify streams is to take advantage of delayed evaluation to define streams implicitly. For example, the following statement defines the stream <span class="KeyTerm1">ones</span> to be an infinite stream of ones:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2008"></a><b>const</b> ones = pair(1, () =&gt; ones);</p>
<p class="paracontinue"><a id="c003_c3-para-2009"></a>This works much like the declaration of a recursive function: <span class="KeyTerm1">ones</span> is a pair whose <span class="KeyTerm1">head</span> is 1 and whose <span class="KeyTerm1">tail</span> is a promise to evaluate <span class="KeyTerm1">ones</span>. Evaluating the <span class="KeyTerm1">tail</span> gives us again a 1 and a promise to evaluate <span class="KeyTerm1">ones</span>, and so on.</p>
<p><a id="c003_c3-para-2010"></a>We can do more interesting things by manipulating streams with operations such as <span class="KeyTerm1">add_streams</span>, which produces the elementwise sum of two given streams:<a id="c003_c3-fn-0064a"></a><a href="#c3-fn-0064"><sup>64</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-2011"></a><b>function</b> add_streams(s1, s2) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2012"></a> <b>return</b> stream_map_2((x1, x2) =&gt; x1 + x2, s1, s2);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2013"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2014"></a>Now we can define the integers as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2015"></a><b>const</b> integers = pair(1, () =&gt; add_streams(ones, integers));</p>
<p class="paracontinue"><a id="c003_c3-para-2016"></a>This defines <span class="KeyTerm1">integers</span> to be a stream whose first element is 1 and the rest of which is the sum of <span class="KeyTerm1">ones</span> and <span class="KeyTerm1">integers</span>. Thus, the second element of <span class="KeyTerm1">integers</span> is 1 plus the first element of <span class="KeyTerm1">integers</span>, or 2; the third element of <span class="KeyTerm1">integers</span> is 1 plus the second element of <span class="KeyTerm1">integers</span>, or 3; and so on. This definition works because, at any point, enough of the <span class="KeyTerm1">integers</span> stream has been generated so that we can feed it back into the definition to produce the next integer.</p>
<p><a id="c003_c3-para-2017"></a>We can define the Fibonacci numbers in the same style:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2018"></a><b>const</b> fibs = pair(0,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2019"></a>                  () =&gt; pair(1,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2020"></a>                             () =&gt; add_streams(stream_tail(fibs),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2021"></a>                                               fibs)));</p>
<p class="paracontinue"><a id="c003_c3-para-2022"></a>This definition says that <span class="KeyTerm1">fibs</span> is a stream beginning with 0 and 1, such that the rest of the stream can be generated by adding <span class="KeyTerm1">fibs</span> to itself shifted by one place:</p>
<figure><figcaption class="tablecaption"><a id="c003_c3-tbl-0004"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td></td>
<td></td>
<td><a id="c003_c3-para-2023"></a>1</td>
<td><a id="c003_c3-para-2024"></a>1</td>
<td><a id="c003_c3-para-2025"></a>2</td>
<td><a id="c003_c3-para-2026"></a>3</td>
<td><a id="c003_c3-para-2027"></a>5</td>
<td><a id="c003_c3-para-2028"></a>8</td>
<td><a id="c003_c3-para-2029"></a>13</td>
<td><a id="c003_c3-para-2030"></a>21</td>
<td><a id="c003_c3-para-2031"></a><span class="KeyTerm1"><i>. . .</i></span></td>
<td><a id="c003_c3-para-2032"></a>=</td>
<td><a id="c003_c3-para-2033"></a><span class="KeyTerm1">stream_tail(fibs)</span></td></tr>
<tr>
<td></td>
<td></td>
<td><a id="c003_c3-para-2034"></a>0</td>
<td><a id="c003_c3-para-2035"></a>1</td>
<td><a id="c003_c3-para-2036"></a>1</td>
<td><a id="c003_c3-para-2037"></a>2</td>
<td><a id="c003_c3-para-2038"></a>3</td>
<td><a id="c003_c3-para-2039"></a>5</td>
<td><a id="c003_c3-para-2040"></a>8</td>
<td><a id="c003_c3-para-2041"></a>13</td>
<td><a id="c003_c3-para-2042"></a><span class="KeyTerm1"><i>. . .</i></span></td>
<td><a id="c003_c3-para-2043"></a>=</td>
<td><a id="c003_c3-para-2044"></a><span class="KeyTerm1">fibs</span></td></tr>
<tr style="border-top:1px solid #000000;">
<td><a id="c003_c3-para-2045"></a>0</td>
<td><a id="c003_c3-para-2046"></a>1</td>
<td><a id="c003_c3-para-2047"></a>1</td>
<td><a id="c003_c3-para-2048"></a>2</td>
<td><a id="c003_c3-para-2049"></a>3</td>
<td><a id="c003_c3-para-2050"></a>5</td>
<td><a id="c003_c3-para-2051"></a>8</td>
<td><a id="c003_c3-para-2052"></a>13</td>
<td><a id="c003_c3-para-2053"></a>21</td>
<td><a id="c003_c3-para-2054"></a>34</td>
<td><a id="c003_c3-para-2055"></a><span class="KeyTerm1"><i>. . .</i></span></td>
<td><a id="c003_c3-para-2056"></a>=</td>
<td><a id="c003_c3-para-2057"></a><span class="KeyTerm1">fibs</span></td></tr></tbody></table></div>
</figure>
<p><a id="c003_c3-para-2058"></a>The function <span class="KeyTerm1">scale_stream</span> is also useful in formulating such stream definitions. This multiplies each item in a stream by a given constant:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2059"></a><b>function</b> scale_stream(stream, factor) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2060"></a> <b>return</b> stream_map(x =&gt; x * factor,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2061"></a>                      stream);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2062"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2063"></a>For example,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2064"></a><b>const</b> double = pair(1, () =&gt; scale_stream(double, 2));</p>
<p class="paracontinue"><a id="c003_c3-para-2065"></a>produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, . . . .</p>
<p><a id="c003_c3-para-2066"></a>An alternate definition of the stream of primes can be given by starting with the integers and filtering them by testing for primality. We will need the first prime, 2, to get started:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2067"></a><b>const</b> primes = pair(2,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2068"></a>                    () =&gt; stream_filter(is_prime,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2069"></a>                                        integers_starting_from(3)));</p>
<p class="paracontinue"><a id="c003_c3-para-2070"></a>This definition is not so straightforward as it appears, because we will test whether a number <i>n</i> is prime by checking whether <i>n</i> is divisible by a prime (not by just any integer) less than or equal to <img alt="c3-fig-5001.jpg" src="../images/c3-fig-5001.jpg"/>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2071"></a><b>function</b> is_prime(n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2072"></a> <b>function</b> iter(ps) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2073"></a> <b>return</b> square(head(ps)) &gt; n</p>
<p class="Sp-text-1"><a id="c003_c3-para-2074"></a>               ? <b>true</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-2075"></a>               : is_divisible(n, head(ps))</p>
<p class="Sp-text-1"><a id="c003_c3-para-2076"></a>               ? <b>false</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-2077"></a>               : iter(stream_tail(ps));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2078"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-2079"></a> <b>return</b> iter(primes);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2080"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2081"></a>This is a recursive definition, since <span class="KeyTerm1">primes</span> is defined in terms of the <span class="KeyTerm1">is_prime</span> predicate, which itself uses the <span class="KeyTerm1">primes</span> stream. The reason this function works is that, at any point, enough of the <span class="KeyTerm1">primes</span> stream has been generated to test the primality of the numbers we need to check next. That is, for every <i>n</i> we test for primality, either <i>n</i> is not prime (in which case there is a prime already generated that divides it) or <i>n</i> is prime (in which case there is a prime already generated—i.e., a prime less than <i>n</i>—that is greater than <img alt="c3-fig-5001.jpg" src="../images/c3-fig-5001.jpg"/>).<a id="c003_c3-fn-0065a"></a><a href="#c3-fn-0065"><sup>65</sup></a></p>
</section>
<section>
<h5><a id="c003_c3-sec-0100"></a><a id="c003_c3-title-0101"></a>Exercise 3.53</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2082"></a>Without running the program, describe the elements of the stream defined by</p>
<p class="Sp-text-1"><a id="c003_c3-para-2083"></a><b>const</b> s = pair(1, () =&gt; add_streams(s, s));</p>
</section>
<section>
<h5><a id="c003_c3-sec-0101"></a><a id="c003_c3-title-0102"></a>Exercise 3.54</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2084"></a>Define a function <span class="KeyTerm1">mul_streams</span>, analogous to <span class="KeyTerm1">add_streams</span>, that produces the elementwise product of its two input streams. Use this together with the stream of <span class="KeyTerm1">integers</span> to complete the following definition of the stream whose <i>n</i>th element (counting from 0) is <i>n</i> + 1 factorial:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2085"></a><b>const</b> factorials = pair(1, () =&gt; mul_streams(〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉));</p>
</section>
<section>
<h5><a id="c003_c3-sec-0102"></a><a id="c003_c3-title-0103"></a>Exercise 3.55</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2086"></a>Define a function <span class="KeyTerm1">partial_sums</span> that takes as argument a stream <i>S</i> and returns the stream whose elements are <i>S</i><sub>0</sub>, <i>S</i><sub>0</sub> + <i>S</i><sub>1</sub>, <i>S</i><sub>0</sub> + <i>S</i><sub>1</sub> + <i>S</i><sub>2</sub>, . . . . For example, <span class="KeyTerm1">partial_sums(integers)</span> should be the stream 1, 3, 6, 10, 15, <i>. . .</i>.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0103"></a><a id="c003_c3-title-0104"></a>Exercise 3.56</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2087"></a>A famous problem, first raised by R. Hamming, is to enumerate, in ascending order with no repetitions, all positive integers with no prime factors other than 2, 3, or 5. One obvious way to do this is to simply test each integer in turn to see whether it has any factors other than 2, 3, and 5. But this is very inefficient, since, as the integers get larger, fewer and fewer of them fit the requirement. As an alternative, let us call the required stream of numbers <span class="KeyTerm1">S</span> and notice the following facts about it.</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1"><span class="KeyTerm1">S</span> </span>begins with 1.</li>
<li>The elements of <span class="KeyTerm1">scale_stream(S, 2)</span> are also elements of <span class="KeyTerm1"><span class="KeyTerm1">S</span></span>.</li>
<li>The same is true for <span class="KeyTerm1">scale_stream(S, 3)</span> and <span class="KeyTerm1">scale_stream(S, 5)</span>.</li>
<li>These are all the elements of <span class="KeyTerm1"><span class="KeyTerm1">S</span></span>.</li>
</ul>
<p class="paracontinue"><a id="c003_c3-para-2092"></a>Now all we have to do is combine elements from these sources. For this we define a function <span class="KeyTerm1">merge</span> that combines two ordered streams into one ordered result stream, eliminating repetitions:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2093"></a><b>function</b> merge(s1, s2) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2094"></a> <b>if</b> (is_null(s1)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2095"></a> <b>return</b> s2;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2096"></a>    } <b>else if</b> (is_null(s2)) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2097"></a> <b>return</b> s1;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2098"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2099"></a> <b>const</b> s1head = head(s1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2100"></a> <b>const</b> s2head = head(s2);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2101"></a> <b>return</b> s1head &lt; s2head</p>
<p class="Sp-text-1"><a id="c003_c3-para-2102"></a>               ? pair(s1head, () =&gt; merge(stream_tail(s1), s2))</p>
<p class="Sp-text-1"><a id="c003_c3-para-2103"></a>               : s1head &gt; s2head</p>
<p class="Sp-text-1"><a id="c003_c3-para-2104"></a>               ? pair(s2head, () =&gt; merge(s1, stream_tail(s2)))</p>
<p class="Sp-text-1"><a id="c003_c3-para-2105"></a>               : pair(s1head, () =&gt; merge(stream_tail(s1), stream_tail(s2)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2106"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-2107"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2108"></a>Then the required stream may be constructed with <span class="KeyTerm1">merge</span>, as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2109"></a><b>const</b> S = pair(1, () =&gt; merge(<i>(</i>??<i>)</i>, <i>(</i>??<i>)</i>));</p>
<p class="paracontinue"><a id="c003_c3-para-2110"></a>Fill in the missing expressions in the places marked <i>(</i>??<i>)</i> above.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0104"></a><a id="c003_c3-title-0105"></a>Exercise 3.57</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2111"></a>How many additions are performed when we compute the <i>n</i>th Fibonacci number using the declaration of fibs based on the <span class="KeyTerm1">add_streams</span> function? Show that this number is exponentially greater than the number of additions performed if <span class="KeyTerm1">add_streams</span> had used the function <span class="KeyTerm1">stream_map_2_optimized</span> described in exercise 3.50.<a id="c003_c3-fn-0066a"></a><a href="#c3-fn-0066"><sup>66</sup></a></p>
</section>
<section>
<h5><a id="c003_c3-sec-0105"></a><a id="c003_c3-title-0106"></a>Exercise 3.58</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2112"></a>Give an interpretation of the stream computed by the function</p>
<p class="Sp-text-1"><a id="c003_c3-para-2113"></a><b>function</b> expand(num, den, radix) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2114"></a> <b>return</b> pair(math_trunc((num * radix) / den),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2115"></a>                () =&gt; expand((num * radix) % den, den, radix));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2116"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2117"></a>where <span class="KeyTerm1">math_trunc</span> discards the fractional part of its argument, here the remainder of the division. What are the successive elements produced by <span class="KeyTerm1">expand(1, 7, 10)</span>? What is produced by <span class="KeyTerm1">expand(3, 8, 10)</span>?</p>
</section>
<section>
<h5><a id="c003_c3-sec-0106"></a><a id="c003_c3-title-0107"></a>Exercise 3.59</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2118"></a>In section 2.5.3 we saw how to implement a polynomial arithmetic system representing polynomials as lists of terms. In a similar way, we can work with <i>power series</i>, such as</p>
<p><a id="c003_c3-para-2119"></a></p>
<figure id="c003_c3-fig-0032"><img alt="c3-fig-5003.jpg" src="../images/c3-fig-5003.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c003_c3-para-2120"></a>represented as infinite streams. We will represent the series <i>a</i><sub>0</sub> + <i>a</i><sub>1</sub><i>x</i> + <i>a</i><sub>2</sub><i>x</i><sup>2</sup> + <i>a</i><sub>3</sub><i>x</i><sup>3</sup> + as the stream whose elements are the coefficients <i>a</i><sub>0</sub>, <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, <i>a</i><sub>3</sub>, . . . .</p>
<ol class="BS_NumberListA">
<li><a id="c003_c3-li-0035"></a><span>a. </span>The integral of the series <i>a</i><sub>0</sub> + <i>a</i><sub>1</sub><i>x</i> + <i>a</i><sub>2</sub><i>x</i><sup>2</sup> + <i>a</i><sub>3</sub><i>x</i><sup>3</sup> +· · ·is the series
<p class="Sp-text-2"><a id="c003_c3-para-2122"></a><i>c</i> + <i>a</i><sub>0</sub><i>x</i> + <img alt="c3-fig-5004.jpg" src="../images/c3-fig-5004.jpg"/><i>a</i><sub>1</sub><i>x</i><sup>2</sup> + <img alt="c3-fig-5005.jpg" src="../images/c3-fig-5005.jpg"/><i>a</i><sub>2</sub><i>x</i><sup>3</sup> + <img alt="c3-fig-5002.jpg" src="../images/c3-fig-5002.jpg"/><i>a</i><sub>3</sub><i>x</i><sup>4</sup> + · · ·</p>
<p class="paracontinue"><a id="c003_c3-para-2123"></a>where <i>c</i> is any constant. Define a function <span class="KeyTerm1">integrate_series</span> that takes as input a stream <i>a</i><sub>0</sub>, <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, <i>. . .</i> representing a power series and returns the stream <i>a</i><sub>0</sub>, <img alt="c3-fig-5004.jpg" src="../images/c3-fig-5004.jpg"/><i>a</i><sub>1</sub>, <img alt="c3-fig-5005.jpg" src="../images/c3-fig-5005.jpg"/><i>a</i><sub>2</sub>, <i>. . .</i> of coefficients of the nonconstant terms of the integral of the series. (Since the result has no constant term, it doesn't represent a power series; when we use <span class="KeyTerm1">integrate_series</span>, we will use <span class="KeyTerm1">pair</span> to adjoin the appropriate constant to the beginning of the stream.)</p></li>
<li><a id="c003_c3-li-0036"></a><span>b. </span>The function <i>x</i> <img alt="c3-fig-5007.jpg" src="../images/c3-fig-5007.jpg"/> <i>e<sup>x</sup></i> is its own derivative. This implies that <i>e<sup>x</sup></i> and the integral of <i>e<sup>x</sup></i> are the same series, except for the constant term, which is <i>e</i><sup>0</sup> = 1. Accordingly, we can generate the series for <i>e<sup>x</sup></i> as
<p class="Sp-text-1"><a id="c003_c3-para-2125"></a><b>const</b> exp_series = pair(1, () =&gt; integrate_series(exp_series));</p>
<p class="paracontinue"><a id="c003_c3-para-2126"></a>Show how to generate the series for sine and cosine, starting from the facts that the derivative of sine is cosine and the derivative of cosine is the negative of sine:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2127"></a><b>const</b> cosine_series = pair(1, 〈<span class="KeyTerm2">??</span>〉);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2128"></a><b>const</b> sine_series = pair(0, 〈<span class="KeyTerm2">??</span>〉);</p></li>
</ol>
</section>
<section>
<h5><a id="c003_c3-sec-0107"></a><a id="c003_c3-title-0108"></a>Exercise 3.60</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2129"></a>With power series represented as streams of coefficients as in exercise 3.59, adding series is implemented by <span class="KeyTerm1">add-streams</span>. Complete the declaration of the following function for multiplying series:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2130"></a><b>function</b> mul_series(s1, s2) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2131"></a>    pair(〈<span class="KeyTerm2">??</span>〉, () =&gt; add_streams(〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2132"></a><sub>}</sub></p>
<p class="paracontinue"><a id="c003_c3-para-2133"></a>You can test your function by verifying that <i>sin</i><sup>2</sup><i>x</i> + <i>cos</i><sup>2</sup><i>x</i> = 1, using the series from exercise 3.59.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0108"></a><a id="c003_c3-title-0109"></a>Exercise 3.61</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2134"></a>Let <i>S</i> be a power series (exercise 3.59) whose constant term is 1. Suppose we want to find the power series 1/<i>S</i>, that is, the series <i>X</i> such that <i>S X</i> = 1. Write <i>S</i> = 1 + <i>S<sub>R</sub></i> where <i>S<sub>R</sub></i> is the part of <i>S</i> after the constant term. Then we can solve for <i>X</i> as follows:</p>
<figure><figcaption class="tablecaption"><a id="c003_c3-tbl-0005"></a></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td style="text-align:right;"><a id="c003_c3-para-2135"></a><i>S</i> · <i>X</i></td>
<td><a id="c003_c3-para-2136"></a>=</td>
<td><a id="c003_c3-para-2137"></a>1</td></tr>
<tr>
<td style="text-align:right;"><a id="c003_c3-para-2138"></a>(1 + <i>S<sub>R</sub></i>) <i>· X</i></td>
<td><a id="c003_c3-para-2139"></a>=</td>
<td><a id="c003_c3-para-2140"></a>1</td></tr>
<tr>
<td style="text-align:right;"><a id="c003_c3-para-2141"></a><i>X</i> + <i>S<sub>R</sub> · X</i></td>
<td><a id="c003_c3-para-2142"></a>=</td>
<td><a id="c003_c3-para-2143"></a>1</td></tr>
<tr>
<td style="text-align:right;"><a id="c003_c3-para-2144"></a><i>X</i></td>
<td><a id="c003_c3-para-2145"></a>=</td>
<td><a id="c003_c3-para-2146"></a>1 – <i>S<sub>R</sub> · X</i></td></tr></tbody></table></div></figure>
<p class="paracontinue"><a id="c003_c3-para-2147"></a>In other words, <i>X</i> is the power series whose constant term is 1 and whose higher-order terms are given by the negative of <i>S<sub>R</sub></i> times <i>X</i>. Use this idea to write a function <span class="KeyTerm1">invert_ unit_series</span> that computes 1/<i>S</i> for a power series <i>S</i> with constant term 1. You will need to use <span class="KeyTerm1">mul_series</span> from exercise 3.60.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0109"></a><a id="c003_c3-title-0110"></a>Exercise 3.62</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2148"></a>Use the results of exercises 3.60 and 3.61 to define a function <span class="KeyTerm1">div_series</span> that divides two power series. The function <span class="KeyTerm1">div_series</span> should work for any two series, provided that the denominator series begins with a nonzero constant term. (If the denominator has a zero constant term, then <span class="KeyTerm1">div_series</span> should signal an error.) Show how to use <span class="KeyTerm1">div_series</span> together with the result of exercise 3.59 to generate the power series for tangent.</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0110"></a><span>3.5.3</span> <a id="c003_c3-title-0111"></a>Exploiting the Stream Paradigm</h3>
<p class="paraaftertitle"><a id="c003_c3-para-2149"></a>Streams with delayed evaluation can be a powerful modeling tool, providing many of the benefits of local state and assignment. Moreover, they avoid some of the theoretical tangles that accompany the introduction of assignment into a programming language.</p>
<p><a id="c003_c3-para-2150"></a>The stream approach can be illuminating because it allows us to build systems with different module boundaries than systems organized around assignment to state variables. For example, we can think of an entire time series (or signal) as a focus of interest, rather than the values of the state variables at individual moments. This makes it convenient to combine and compare components of state from different moments.</p>
<section>
<h5><a id="c003_c3-sec-0111"></a><a id="c003_c3-title-0112"></a>Formulating iterations as stream processes</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2151"></a>In section 1.2.1, we introduced iterative processes, which proceed by updating state variables. We know now that we can represent state as a “timeless” stream of values rather than as a set of variables to be updated. Let's adopt this perspective in revisiting the square-root function from section 1.1.7. Recall that the idea is to generate a sequence of better and better guesses for the square root of <i>x</i> by applying over and over again the function that improves guesses:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2152"></a><b>function</b> sqrt_improve(guess, x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2153"></a> <b>return</b> average(guess, x / guess);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2154"></a>}</p>
<p><a id="c003_c3-para-2155"></a>In our original <span class="KeyTerm1">sqrt</span> function, we made these guesses be the successive values of a state variable. Instead we can generate the infinite stream of guesses, starting with an initial guess of 1:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2156"></a><b>function</b> sqrt_stream(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2157"></a> <b>return</b> pair(1, () =&gt; stream_map(guess =&gt; sqrt_improve(guess, x),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2158"></a>                                    sqrt_stream(x)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2159"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-2160"></a>display_stream(sqrt_stream(2));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2161"></a><i>1</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2162"></a><i>1.5</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2163"></a><i>1.4166666666666665</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2164"></a><i>1.4142156862745097</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2165"></a><i>1.4142135623746899</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2166"></a><i>…</i></p>
<p class="paracontinue"><a id="c003_c3-para-2167"></a>We can generate more and more terms of the stream to get better and better guesses. If we like, we can write a function that keeps generating terms until the answer is good enough. (See exercise 3.64.)</p>
<p><a id="c003_c3-para-2168"></a>Another iteration that we can treat in the same way is to generate an approximation to <i>π</i>, based upon the alternating series that we saw in section 1.3.1:</p>
<p><a id="c003_c3-para-2169"></a></p>
<figure id="c003_c3-fig-0033"><img alt="c3-fig-5008.jpg" src="../images/c3-fig-5008.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c003_c3-para-2170"></a>We first generate the stream of summands of the series (the reciprocals of the odd integers, with alternating signs). Then we take the stream of sums of more and more terms (using the <span class="KeyTerm1">partial_sums</span> function of exercise 3.55) and scale the result by 4:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2171"></a><b>function</b> pi_summands(n) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2172"></a> <b>return</b> pair(1 / n, () =&gt; stream_map(x =&gt; - x, pi_summands(n + 2)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2173"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-2174"></a><b>const</b> pi_stream = scale_stream(partial_sums(pi_summands(1)), 4);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c003_c3-para-2175"></a>display_stream(pi_stream);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2176"></a><i>4</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2177"></a><i>2.666666666666667</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2178"></a><i>3.466666666666667</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2179"></a><i>2.8952380952380956</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2180"></a><i>3.3396825396825403</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2181"></a><i>2.9760461760461765</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2182"></a><i>3.2837384837384844</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2183"></a><i>3.017071817071818</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2184"></a><i>…</i></p>
<p class="paracontinue"><a id="c003_c3-para-2185"></a>This gives us a stream of better and better approximations to <i>π</i>, although the approximations converge rather slowly. Eight terms of the sequence bound the value of <i>π</i> between 3.284 and 3.017.</p>
<p><a id="c003_c3-para-2186"></a>So far, our use of the stream of states approach is not much different from updating state variables. But streams give us an opportunity to do some interesting tricks. For example, we can transform a stream with a <i>sequence accelerator</i> that converts a sequence of approximations to a new sequence that converges to the same value as the original, only faster.</p>
<p><a id="c003_c3-para-2187"></a>One such accelerator, due to the eighteenth-century Swiss mathematician Leonhard Euler, works well with sequences that are partial sums of alternating series (series of terms with alternating signs). In Euler's technique, if <i>S<sub>n </sub></i>is the <i>n</i>th term of the original sum sequence, then the accelerated sequence has terms</p>
<p><a id="c003_c3-para-2188"></a></p>
<figure id="c003_c3-fig-0034"><img alt="c3-fig-5009.jpg" src="../images/c3-fig-5009.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c003_c3-para-2189"></a>Thus, if the original sequence is represented as a stream of values, the transformed sequence is given by</p>
<p class="Sp-text-1"><a id="c003_c3-para-2190"></a><b>function</b> euler_transform(s) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2191"></a> <b>const</b> s0 = stream_ref(s, 0);     <span class="KeyTerm2"><i>// S<sub>n</sub></i><sub>–1</sub></span></p>
<p class="Sp-text-1"><a id="c003_c3-para-2192"></a> <b>const</b> s1 = stream_ref(s, 1);     <span class="KeyTerm2"><i>// S<sub>n</sub></i></span></p>
<p class="Sp-text-1"><a id="c003_c3-para-2193"></a> <b>const</b> s2 = stream_ref(s, 2);     <span class="KeyTerm2"><i>// S<sub>n</sub></i><sub>+1</sub></span></p>
<p class="Sp-text-1"><a id="c003_c3-para-2194"></a> <b>return</b> pair(s2 - square(s2 - s1) / (s0 + (-2) * s1 + s2),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2195"></a>                memo(() =&gt; euler_transform(stream_tail(s))));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2196"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2197"></a>Note that we make use of the memoization optimization of section 3.5.1, because in the following we will rely on repeated evaluation of the resulting stream.</p>
<p><a id="c003_c3-para-2198"></a>We can demonstrate Euler acceleration with our sequence of approximations to <i>π</i>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2199"></a>display_stream(euler_transform(pi_stream));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2200"></a><i>3.166666666666667</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2201"></a><i>3.1333333333333337</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2202"></a><i>3.1452380952380956</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2203"></a><i>3.13968253968254</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2204"></a><i>3.1427128427128435</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2205"></a><i>3.1408813408813416</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2206"></a><i>3.142071817071818</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2207"></a><i>3.1412548236077655</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2208"></a><i>…</i></p>
<p><a id="c003_c3-para-2209"></a>Even better, we can accelerate the accelerated sequence, and recursively accelerate that, and so on. Namely, we create a stream of streams (a structure we'll call a <i>tableau</i>) in which each stream is the transform of the preceding one:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2210"></a><b>function</b> make_tableau(transform, s) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2211"></a> <b>return</b> pair(s, () =&gt; make_tableau(transform, transform(s)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2212"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2213"></a>The tableau has the form</p>
<figure><figcaption class="tablecaption"><a id="c003_c3-tbl-0006"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c003_c3-para-2214"></a><i>s</i><sub>00</sub></td>
<td><a id="c003_c3-para-2215"></a><i>s</i><sub>01</sub></td>
<td><a id="c003_c3-para-2216"></a><i>s</i><sub>02</sub></td>
<td><a id="c003_c3-para-2217"></a><i>s</i><sub>03</sub></td>
<td><a id="c003_c3-para-2218"></a><i>s</i><sub>04</sub></td>
<td><a id="c003_c3-para-2219"></a>. . .</td></tr>
<tr>
<td></td>
<td><a id="c003_c3-para-2220"></a><i>s</i><sub>10</sub></td>
<td><a id="c003_c3-para-2221"></a><i>s</i><sub>11</sub></td>
<td><a id="c003_c3-para-2222"></a><i>s</i><sub>12</sub></td>
<td><a id="c003_c3-para-2223"></a><i>s</i><sub>13</sub></td>
<td><a id="c003_c3-para-2224"></a>. . .</td></tr>
<tr>
<td></td>
<td></td>
<td><a id="c003_c3-para-2225"></a><i>s</i><sub>20</sub></td>
<td><a id="c003_c3-para-2226"></a><i>s</i><sub>21</sub></td>
<td><a id="c003_c3-para-2227"></a><i>s</i><sub>22</sub></td>
<td><a id="c003_c3-para-2228"></a>. . .</td></tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><a id="c003_c3-para-2229"></a>. . .</td>
<td></td></tr></tbody></table></div>
</figure>
<p class="paracontinue"><a id="c003_c3-para-2230"></a>Finally, we form a sequence by taking the first term in each row of the tableau:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2231"></a><b>function</b> accelerated_sequence(transform, s) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2232"></a> <b>return</b> stream_map(head, make_tableau(transform, s));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2233"></a>}</p>
<p><a id="c003_c3-para-2234"></a>We can demonstrate this kind of “super-acceleration” of the <i>π</i> sequence:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2235"></a>display_stream(accelerated_sequence(euler_transform, pi_stream));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2236"></a><i>4</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2237"></a><i>3.166666666666667</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2238"></a><i>3.142105263157895</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2239"></a><i>3.141599357319005</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2240"></a><i>3.1415927140337785</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2241"></a><i>3.1415926539752927</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2242"></a><i>3.1415926535911765</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2243"></a><i>3.141592653589778</i></p>
<p class="Sp-text-1"><a id="c003_c3-para-2244"></a><i>…</i></p>
<p class="paracontinue"><a id="c003_c3-para-2245"></a>The result is impressive. Taking eight terms of the sequence yields the correct value of <i>π</i> to 14 decimal places. If we had used only the original <i>π</i> sequence, we would need to compute on the order of 10<sup>13</sup> terms (i.e., expanding the series far enough so that the individual terms are less then 10<sup>–13</sup>) to get that much accuracy!</p>
<p><a id="c003_c3-para-2246"></a>We could have implemented these acceleration techniques without using streams. But the stream formulation is particularly elegant and convenient because the entire sequence of states is available to us as a data structure that can be manipulated with a uniform set of operations.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0112"></a><a id="c003_c3-title-0113"></a>Exercise 3.63</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2247"></a>Louis Reasoner is not happy with the performance of the stream produced by the <span class="KeyTerm1">sqrt_ stream</span> function and tries to optimize it using memoization:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2248"></a><b>function</b> sqrt_stream_optimized(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2249"></a> <b>return</b> pair(1,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2250"></a>                memo(() =&gt; stream_map(guess =&gt;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2251"></a>                                        sqrt_improve(guess, x),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2252"></a>                                      sqrt_stream_optimized(x))));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2253"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2254"></a>Alyssa P. Hacker instead proposes</p>
<p class="Sp-text-1"><a id="c003_c3-para-2255"></a><b>function</b> sqrt_stream_optimized_2(x) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2256"></a> <b>const</b> guesses = pair(1,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2257"></a>                         memo(() =&gt; stream_map(guess =&gt;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2258"></a>                                                 sqrt_improve(guess, x),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2259"></a>                                               guesses)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2260"></a> <b>return</b> guesses;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2261"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2262"></a>and claims that Louis's version is considerably less efficient than hers, because it performs redundant computation. Explain Alyssa's answer. Would Alyssa's approach without memoization be more efficient than the original <span class="KeyTerm1">sqrt_stream</span>?</p>
</section>
<section>
<h5><a id="c003_c3-sec-0113"></a><a id="c003_c3-title-0114"></a>Exercise 3.64</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2263"></a>Write a function <span class="KeyTerm1">stream_limit</span> that takes as arguments a stream and a number (the tolerance). It should examine the stream until it finds two successive elements that differ in absolute value by less than the tolerance, and return the second of the two elements. Using this, we could compute square roots up to a given tolerance by</p>
<p class="Sp-text-1"><a id="c003_c3-para-2264"></a><b>function</b> sqrt(x, tolerance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2265"></a> <b>return</b> stream_limit(sqrt_stream(x), tolerance);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2266"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0114"></a><a id="c003_c3-title-0115"></a>Exercise 3.65</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2267"></a>Use the series</p>
<p class="Sp-text-2"><a id="c003_c3-para-2268"></a><img alt="c3-fig-5017.jpg" src="../images/c3-fig-5017.jpg"/></p>
<p class="paracontinue"><a id="c003_c3-para-2269"></a>to compute three sequences of approximations to the natural logarithm of 2, in the same way we did above for <i>π</i>. How rapidly do these sequences converge?</p>
</section>
<section>
<h5><a id="c003_c3-sec-0115"></a><a id="c003_c3-title-0116"></a>Infinite streams of pairs</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2270"></a>In section 2.2.3, we saw how the sequence paradigm handles traditional nested loops as processes defined on sequences of pairs. If we generalize this technique to infinite streams, then we can write programs that are not easily represented as loops, because the “looping” must range over an infinite set.</p>
<p><a id="c003_c3-para-2271"></a>For example, suppose we want to generalize the <span class="KeyTerm1">prime_sum_pairs</span> function of section 2.2.3 to produce the stream of pairs of <i>all</i> integers (<i>i</i>, <i>j</i>) with <i>i</i> ≤ <i>j</i> such that <i>i</i> + <i>j</i> is prime. If <span class="KeyTerm1">int_pairs</span> is the sequence of all pairs of integers (<i>i</i>, <i>j</i>) with <i>i</i> ≤ <i>j</i>, then our required stream is simply<a id="c003_c3-fn-0067a"></a><a href="#c3-fn-0067"><sup>67</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-2272"></a>stream_filter(pair =&gt; is_prime(head(pair) + head(tail(pair))),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2273"></a>              int_pairs);</p>
<p><a id="c003_c3-para-2274"></a>Our problem, then, is to produce the stream <span class="KeyTerm1">int_pairs</span>. More generally, suppose we have two streams <i>S</i> = (<i>S<sub>i</sub></i>) and <i>T</i> = (<i>T<sub>j</sub></i>), and imagine the infinite rectangular array</p>
<figure><figcaption class="tablecaption"><a id="c003_c3-tbl-0007"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c003_c3-para-2275"></a>(<i>S</i><sub>0</sub>, <i>T</i><sub>0</sub>)</td>
<td><a id="c003_c3-para-2276"></a>(<i>S</i><sub>0</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c003_c3-para-2277"></a>(<i>S</i><sub>0</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c003_c3-para-2278"></a><i>. . .</i></td></tr>
<tr>
<td><a id="c003_c3-para-2279"></a>(<i>S</i><sub>1</sub>, <i>T</i><sub>0</sub>)</td>
<td><a id="c003_c3-para-2280"></a>(<i>S</i><sub>1</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c003_c3-para-2281"></a>(<i>S</i><sub>1</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c003_c3-para-2282"></a><i>. . .</i></td></tr>
<tr>
<td><a id="c003_c3-para-2283"></a>(<i>S</i><sub>2</sub>, <i>T</i><sub>0</sub>)</td>
<td><a id="c003_c3-para-2284"></a>(<i>S</i><sub>2</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c003_c3-para-2285"></a>(<i>S</i><sub>2</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c003_c3-para-2286"></a><i>. . .</i></td></tr>
<tr>
<td><a id="c003_c3-para-2287"></a><i>. . .</i></td>
<td></td>
<td></td>
<td></td></tr></tbody></table></div>
</figure>
<p class="paracontinue"><a id="c003_c3-para-2288"></a>We wish to generate a stream that contains all the pairs in the array that lie on or above the diagonal, i.e., the pairs</p>
<figure><figcaption class="tablecaption"><a id="c003_c3-tbl-0008"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c003_c3-para-2289"></a>(<i>S</i><sub>0</sub>, <i>T</i><sub>0</sub>)</td>
<td><a id="c003_c3-para-2290"></a>(<i>S</i><sub>0</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c003_c3-para-2291"></a>(<i>S</i><sub>0</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c003_c3-para-2292"></a><i>. . .</i></td></tr>
<tr>
<td></td>
<td><a id="c003_c3-para-2293"></a>(<i>S</i><sub>1</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c003_c3-para-2294"></a>(<i>S</i><sub>1</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c003_c3-para-2295"></a><i>. . .</i></td></tr>
<tr>
<td></td>
<td></td>
<td><a id="c003_c3-para-2296"></a>(<i>S</i><sub>2</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c003_c3-para-2297"></a><i>. . .</i></td></tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><a id="c003_c3-para-2298"></a><i>. . .</i></td></tr></tbody></table></div>
</figure>
<p class="paracontinue"><a id="c003_c3-para-2299"></a>(If we take both <i>S</i> and <i>T</i> to be the stream of integers, then this will be our desired stream <span class="KeyTerm1">int_pairs</span>.)</p>
<p><a id="c003_c3-para-2300"></a>Call the general stream of pairs <span class="KeyTerm1">pairs(S, T)</span>, and consider it to be composed of three parts: the pair (<i>S</i><sub>0</sub>, <i>T</i><sub>0</sub>), the rest of the pairs in the first row, and the remaining pairs:<a id="c003_c3-fn-0068a"></a><a href="#c3-fn-0068"><sup>68</sup></a></p>
<figure><figcaption class="tablecaption"><a id="c003_c3-tbl-0009"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr style="border-bottom:1px solid #000000;">
<td style="border-right:1px solid #000000;"><a id="c003_c3-para-2301"></a>(<i>S</i><sub>0</sub>, <i>T</i><sub>0</sub>)</td>
<td><a id="c003_c3-para-2302"></a>(<i>S</i><sub>0</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c003_c3-para-2303"></a>(<i>S</i><sub>0</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c003_c3-para-2304"></a><i>. . .</i></td></tr>
<tr>
<td style="border-right:1px solid #000000;"></td>
<td><a id="c003_c3-para-2305"></a>(<i>S</i><sub>1</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c003_c3-para-2306"></a>(<i>S</i><sub>1</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c003_c3-para-2307"></a><i>. . .</i></td></tr>
<tr>
<td style="border-right:1px solid #000000;"></td>
<td></td>
<td><a id="c003_c3-para-2308"></a>(<i>S</i><sub>2</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c003_c3-para-2309"></a><i>. . .</i></td></tr>
<tr>
<td style="border-right:1px solid #000000;"></td>
<td></td>
<td></td>
<td><a id="c003_c3-para-2310"></a><i>. . .</i></td></tr></tbody></table></div>
</figure>
<p class="paracontinue"><a id="c003_c3-para-2311"></a>Observe that the third piece in this decomposition (pairs that are not in the first row) is (recursively) the pairs formed from <span class="KeyTerm1">stream_tail(S)</span> and <span class="KeyTerm1">stream_tail(T)</span>. Also note that the second piece (the rest of the first row) is</p>
<p class="Sp-text-1"><a id="c003_c3-para-2312"></a>stream_map(x =&gt; list(head(s), x),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2313"></a>stream_tail(t));</p>
<p class="paracontinue"><a id="c003_c3-para-2314"></a>Thus we can form our stream of pairs as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2315"></a><b>function</b> pairs(s, t) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2316"></a> <b>return</b> pair(list(head(s), head(t)),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2317"></a>                () =&gt; <span class="KeyTerm2"><i>combine</i>-<i>in</i>-<i>some</i>-<i>way</i></span>(</p>
<p class="Sp-text-1"><a id="c003_c3-para-2318"></a>                          stream_map(x =&gt; list(head(s), x),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2319"></a>                                     stream_tail(t)),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2320"></a>                          pairs(stream_tail(s), stream_tail(t))));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2321"></a>}</p>
<p><a id="c003_c3-para-2322"></a>In order to complete the function, we must choose some way to combine the two inner streams. One idea is to use the stream analog of the <span class="KeyTerm1">append</span> function from section 2.2.1:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2323"></a><b>function</b> stream_append(s1, s2) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2324"></a> <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c003_c3-para-2325"></a>           ? s2</p>
<p class="Sp-text-1"><a id="c003_c3-para-2326"></a>           : pair(head(s1),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2327"></a>                  () =&gt; stream_append(stream_tail(s1), s2));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2328"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2329"></a>This is unsuitable for infinite streams, however, because it takes all the elements from the first stream before incorporating the second stream. In particular, if we try to generate all pairs of positive integers using</p>
<p class="Sp-text-1"><a id="c003_c3-para-2330"></a>pairs(integers, integers);</p>
<p class="paracontinue"><a id="c003_c3-para-2331"></a>our stream of results will first try to run through all pairs with the first integer equal to 1, and hence will never produce pairs with any other value of the first integer.</p>
<p><a id="c003_c3-para-2332"></a>To handle infinite streams, we need to devise an order of combination that ensures that every element will eventually be reached if we let our program run long enough. An elegant way to accomplish this is with the following <span class="KeyTerm1">interleave</span> function:<a id="c003_c3-fn-0069a"></a><a href="#c3-fn-0069"><sup>69</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-2333"></a><b>function</b> interleave(s1, s2) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2334"></a> <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c003_c3-para-2335"></a>           ? s2</p>
<p class="Sp-text-1"><a id="c003_c3-para-2336"></a>           : pair(head(s1),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2337"></a>                  () =&gt; interleave(s2, stream_tail(s1)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2338"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2339"></a>Since <span class="KeyTerm1">interleave</span> takes elements alternately from the two streams, every element of the second stream will eventually find its way into the interleaved stream, even if the first stream is infinite.</p>
<p><a id="c003_c3-para-2340"></a>We can thus generate the required stream of pairs as</p>
<p class="Sp-text-1"><a id="c003_c3-para-2341"></a><b>function</b> pairs(s, t) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2342"></a> <b>return</b> pair(list(head(s), head(t)),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2343"></a>                () =&gt; interleave(stream_map(x =&gt; list(head(s), x),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2344"></a>                                            stream_tail(t)),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2345"></a>                                 pairs(stream_tail(s),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2346"></a>                                       stream_tail(t))));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2347"></a>}</p>
</section>
<section>
<h5><a id="c003_c3-sec-0116"></a><a id="c003_c3-title-0117"></a>Exercise 3.66</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2348"></a>Examine the stream <span class="KeyTerm1">pairs(integers, integers)</span>. Can you make any general comments about the order in which the pairs are placed into the stream? For example, approximately how many pairs precede the pair (1,100)? the pair (99,100)? the pair (100,100)? (If you can make precise mathematical statements here, all the better. But feel free to give more qualitative answers if you find yourself getting bogged down.)</p>
</section>
<section>
<h5><a id="c003_c3-sec-0117"></a><a id="c003_c3-title-0118"></a>Exercise 3.67</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2349"></a>Modify the <span class="KeyTerm1">pairs</span> function so that <span class="KeyTerm1">pairs(integers, integers)</span> will produce the stream of <i>all</i> pairs of integers (<i>i</i>, <i>j</i>) (without the condition <i>i</i> ≤ <i>j</i>). Hint: You will need to mix in an additional stream.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0118"></a><a id="c003_c3-title-0119"></a>Exercise 3.68</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2350"></a>Louis Reasoner thinks that building a stream of pairs from three parts is unnecessarily complicated. Instead of separating the pair (<i>S</i><sub>0</sub>, <i>T</i><sub>0</sub>) from the rest of the pairs in the first row, he proposes to work with the whole first row, as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2351"></a><b>function</b> pairs(s, t) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2352"></a> <b>return</b> interleave(stream_map(x =&gt; list(head(s), x),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2353"></a>                                 t),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2354"></a>                      pair(stream_tail(s), stream_tail(t)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2355"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2356"></a>Does this work? Consider what happens if we evaluate <span class="KeyTerm1">pairs(integers, integers)</span> using Louis's definition of <span class="KeyTerm1">pairs</span>.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0119"></a><a id="c003_c3-title-0120"></a>Exercise 3.69</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2357"></a>Write a function <span class="KeyTerm1">triples</span> that takes three infinite streams, <i>S</i>, <i>T</i>, and <i>U</i>, and produces the stream of triples (<i>S<sub>i</sub></i>, <i>T<sub>j</sub></i>, <i>U<sub>k</sub></i>) such that <i>i</i> ≤ <i>j ≤ k</i>. Use <span class="KeyTerm1">triples</span> to generate the stream of all Pythagorean triples of positive integers, i.e., the triples (<i>i</i>, <i>j</i>, <i>k</i>) such that <i>i ≤ j</i> and <i>i</i><sup>2</sup> + <i>j</i><sup>2</sup> = <i>k</i><sup>2</sup>.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0120"></a><a id="c003_c3-title-0121"></a>Exercise 3.70</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2358"></a>It would be nice to be able to generate streams in which the pairs appear in some useful order, rather than in the order that results from an <i>ad hoc</i> interleaving process. We can use a technique similar to the <span class="KeyTerm1">merge</span> function of exercise 3.56, if we define a way to say that one pair of integers is “less than” another. One way to do this is to define a “weighting function” <i>W</i>(<i>i</i>, <i>j</i>) and stipulate that (<i>i</i><sub>1</sub>, <i>j</i><sub>1</sub>) is less than (<i>i</i><sub>2</sub>, <i>j</i><sub>2</sub>) if <i>W</i>(<i>i</i><sub>1</sub>, <i>j</i><sub>1</sub>) &lt; <i>W</i>(<i>i</i><sub>2</sub>, <i>j</i><sub>2</sub>). Write a function <span class="KeyTerm1">merge_weighted</span> that is like <span class="KeyTerm1">merge</span>, except that <span class="KeyTerm1">merge_weighted</span> takes an additional argument <span class="KeyTerm1">weight</span>, which is a function that computes the weight of a pair, and is used to determine the order in which elements should appear in the resulting merged stream.<a id="c003_c3-fn-0070a"></a><a href="#c3-fn-0070"><sup>70</sup></a> Using this, generalize <span class="KeyTerm1">pairs</span> to a function <span class="KeyTerm1">weighted_pairs</span> that takes two streams, together with a function that computes a weighting function, and generates the stream of pairs, ordered according to weight. Use your function to generate</p>
<ol class="BS_NumberListA">
<li><a id="c003_c3-li-0037"></a><span>a. </span>the stream of all pairs of positive integers (<i>i</i>, <i>j</i>) with <i>i</i> ≤ <i>j</i> ordered according to the sum <i>i</i> + <i>j</i></li>
<li><a id="c003_c3-li-0038"></a><span>b. </span>the stream of all pairs of positive integers (<i>i</i>, <i>j</i>) with <i>i</i> ≤ <i>j</i>, where neither <i>i</i> nor <i>j</i> is divisible by 2, 3, or 5, and the pairs are ordered according to the sum 2<i>i</i> + 3<i>j</i> + 5<i>ij</i>.</li>
</ol>
</section>
<section>
<h5><a id="c003_c3-sec-0121"></a><a id="c003_c3-title-0122"></a>Exercise 3.71</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2361"></a>Numbers that can be expressed as the sum of two cubes in more than one way are sometimes called <i>Ramanujan numbers</i>, in honor of the mathematician Srinivasa Ramanujan.<a id="c003_c3-fn-0071a"></a><a href="#c3-fn-0071"><sup>71</sup></a> Ordered streams of pairs provide an elegant solution to the problem of computing these numbers. To find a number that can be written as the sum of two cubes in two different ways, we need only generate the stream of pairs of integers (<i>i</i>, <i>j</i>) weighted according to the sum <i>i</i><sup>3</sup> + <i>j</i><sup>3</sup> (see exercise 3.70), then search the stream for two consecutive pairs with the same weight. Write a function to generate the Ramanujan numbers. The first such number is 1,729. What are the next five?</p>
</section>
<section>
<h5><a id="c003_c3-sec-0122"></a><a id="c003_c3-title-0123"></a>Exercise 3.72</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2362"></a>In a similar way to exercise 3.71 generate a stream of all numbers that can be written as the sum of two squares in three different ways (showing how they can be so written).</p>
</section>
<section>
<h5><a id="c003_c3-sec-0123"></a><a id="c003_c3-title-0124"></a>Streams as signals</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2363"></a>We began our discussion of streams by describing them as computational analogs of the “signals” in signal-processing systems. In fact, we can use streams to model signal-processing systems in a very direct way, representing the values of a signal at successive time intervals as consecutive elements of a stream. For instance, we can implement an <i>integrator</i> or <i>summer</i> that, for an input stream <i>x</i> = (<i>x<sub>i</sub></i>), an initial value <i>C</i>, and a small increment <i>dt</i>, accumulates the sum</p>
<p><a id="c003_c3-para-2364"></a></p>
<figure id="c003_c3-fig-0035"><img alt="c3-fig-5010.jpg" src="../images/c3-fig-5010.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c003_c3-para-2365"></a>and returns the stream of values <i>S</i> = (<i>S<sub>i</sub></i>). The following <span class="KeyTerm1">integral</span> function is reminiscent of the “implicit style” definition of the stream of integers (section 3.5.2):</p>
<p class="Sp-text-1"><a id="c003_c3-para-2366"></a><b>function</b> integral(integrand, initial_value, dt) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2367"></a> <b>const</b> integ = pair(initial_value,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2368"></a>                       () =&gt; add_streams(scale_stream(integrand, dt),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2369"></a>                                         integ));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2370"></a> <b>return</b> integ;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2371"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2372"></a><a id="c003_c3-fig-0036a"></a><a href="#c3-fig-0036">Figure 3.32</a> is a picture of a signal-processing system that corresponds to the <span class="KeyTerm1">integral</span> function. The input stream is scaled by <i>dt</i> and passed through an adder, whose output is passed back through the same adder. The self-reference in the definition of <span class="KeyTerm1">integ</span> is reflected in the figure by the feedback loop that connects the output of the adder to one of the inputs.</p>
<figure id="c003_c3-fig-0036"><img alt="c3-fig-0032.jpg" src="../images/c3-fig-0032.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0036a">Figure 3.32</a></span> <a id="c003_c3-para-2373"></a>The <span class="KeyTerm1">integral</span> function viewed as a signal-processing system.</p></figcaption></figure>
</section>
<section>
<h5><a id="c003_c3-sec-0124"></a><a id="c003_c3-title-0125"></a>Exercise 3.73</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2374"></a>We can model electrical circuits using streams to represent the values of currents or voltages at a sequence of times. For instance, suppose we have an <i>RC circuit</i> consisting of a resistor of resistance <i>R</i> and a capacitor of capacitance <i>C</i> in series. The voltage response <i>v</i> of the circuit to an injected current <i>i</i> is determined by the formula in <a id="c003_c3-fig-0037a"></a><a href="#c3-fig-0037">figure 3.33</a>, whose structure is shown by the accompanying signal-flow diagram.</p>
<figure id="c003_c3-fig-0037"><img alt="c3-fig-0033.jpg" src="../images/c3-fig-0033.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0037a">Figure 3.33</a></span> <a id="c003_c3-para-2375"></a>An RC circuit and the associated signal-flow diagram.</p></figcaption></figure>
<p><a id="c003_c3-para-2376"></a>Write a function <span class="KeyTerm1">RC</span> that models this circuit. <span class="KeyTerm1">RC</span> should take as inputs the values of <i>R</i>, <i>C</i>, and <i>dt</i> and should return a function that takes as inputs a stream representing the current <i>i</i> and an initial value for the capacitor voltage <i>v</i><sub>0</sub> and produces as output the stream of voltages <i>v</i>. For example, you should be able to use <span class="KeyTerm1">RC</span> to model an RC circuit with <i>R</i> = 5 ohms, <i>C</i> = 1 farad, and a 0.5-second time step by evaluating <span class="KeyTerm1"><b>const</b> RC1 = RC(5, 1, 0.5)</span>. This defines <span class="KeyTerm1">RC1</span> as a function that takes a stream representing the time sequence of currents and an initial capacitor voltage and produces the output stream of voltages.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0125"></a><a id="c003_c3-title-0126"></a>Exercise 3.74</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2377"></a>Alyssa P. Hacker is designing a system to process signals coming from physical sensors. One important feature she wishes to produce is a signal that describes the <i>zero crossings</i> of the input signal. That is, the resulting signal should be +1 whenever the input signal changes from negative to positive, –1 whenever the input signal changes from positive to negative, and 0 otherwise. (Assume that the sign of a 0 input is positive.) For example, a typical input signal with its associated zero-crossing signal would be</p>
<p><a id="c003_c3-para-2378"></a></p>
<figure id="c003_c3-fig-0038"><img alt="c3-fig-5011.jpg" src="../images/c3-fig-5011.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c003_c3-para-2379"></a>In Alyssa's system, the signal from the sensor is represented as a stream <span class="KeyTerm1">sense_data</span> and the stream <span class="KeyTerm1">zero_crossings</span> is the corresponding stream of zero crossings. Alyssa first writes a function <span class="KeyTerm1">sign_change_detector</span> that takes two values as arguments and compares the signs of the values to produce an appropriate 0, 1, or –1. She then constructs her zero-crossing stream as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2380"></a><b>function</b> make_zero_crossings(input_stream, last_value) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2381"></a> <b>return</b> pair(sign_change_detector(head(input_stream), last_value),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2382"></a>                () =&gt; make_zero_crossings(stream_tail(input_stream),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2383"></a>                                          head(input_stream)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2384"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-2385"></a><b>const</b> zero_crossings = make_zero_crossings(sense_data, 0);</p>
<p class="paracontinue"><a id="c003_c3-para-2386"></a>Alyssa's boss, Eva Lu Ator, walks by and suggests that this program is approximately equivalent to the following one, which uses the function <span class="KeyTerm1">stream_map_2</span> from exercise 3.50:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2387"></a><b>const</b> zero_crossings = stream_map_2(sign_change_detector,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2388"></a>                                    sense_data,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2389"></a> <span class="KeyTerm2"><i>expression</i></span>);</p>
<p class="paracontinue"><a id="c003_c3-para-2390"></a>Complete the program by supplying the indicated <i>expression</i>.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0126"></a><a id="c003_c3-title-0127"></a>Exercise 3.75</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2391"></a>Unfortunately, Alyssa's zero-crossing detector in exercise 3.74 proves to be insufficient, because the noisy signal from the sensor leads to spurious zero crossings. Lem E. Tweakit, a hardware specialist, suggests that Alyssa smooth the signal to filter out the noise before extracting the zero crossings. Alyssa takes his advice and decides to extract the zero crossings from the signal constructed by averaging each value of the sense data with the previous value. She explains the problem to her assistant, Louis Reasoner, who attempts to implement the idea, altering Alyssa's program as follows:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2392"></a><b>function</b> make_zero_crossings(input_stream, last_value) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2393"></a> <b>const</b> avpt = (head(input_stream) + last_value) / 2;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2394"></a> <b>return</b> pair(sign_change_detector(avpt, last_value),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2395"></a>                () =&gt; make_zero_crossings(stream_tail(input_stream),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2396"></a>                                          avpt));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2397"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2398"></a>This does not correctly implement Alyssa's plan. Find the bug that Louis has installed and fix it without changing the structure of the program. (Hint: You will need to increase the number of arguments to <span class="KeyTerm1">make_zero_crossings</span>.)</p>
</section>
<section>
<h5><a id="c003_c3-sec-0127"></a><a id="c003_c3-title-0128"></a>Exercise 3.76</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2399"></a>Eva Lu Ator has a criticism of Louis's approach in exercise 3.75. The program he wrote is not modular, because it intermixes the operation of smoothing with the zero-crossing extraction. For example, the extractor should not have to be changed if Alyssa finds a better way to condition her input signal. Help Louis by writing a function <span class="KeyTerm1">smooth</span> that takes a stream as input and produces a stream in which each element is the average of two successive input stream elements. Then use <span class="KeyTerm1">smooth</span> as a component to implement the zero-crossing detector in a more modular style.</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0128"></a><span>3.5.4</span> <a id="c003_c3-title-0129"></a>Streams and Delayed Evaluation</h3>
<p class="paraaftertitle"><a id="c003_c3-para-2400"></a>The <span class="KeyTerm1">integral</span> function at the end of the preceding section shows how we can use streams to model signal-processing systems that contain feedback loops. The feedback loop for the adder shown in <a href="#c3-fig-0036">figure 3.32</a> is modeled by the fact that <span class="KeyTerm1">integral</span>'s internal stream <span class="KeyTerm1">integ</span> is defined in terms of itself:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2401"></a><b>const</b> integ = pair(initial_value,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2402"></a>                   () =&gt; add_streams(scale_stream(integrand, dt),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2403"></a>                                     integ));</p>
<p class="paracontinue"><a id="c003_c3-para-2404"></a>The interpreter's ability to deal with such an implicit definition depends on the delay resulting from wrapping the call to <span class="KeyTerm1">add_streams</span> in a lambda expression. Without this delay, the interpreter could not construct <span class="KeyTerm1">integ</span> before evaluating the call to <span class="KeyTerm1">add_streams</span>, which would require that <span class="KeyTerm1">integ</span> already be defined. In general, such a delay is crucial for using streams to model signal-processing systems that contain loops. Without a delay, our models would have to be formulated so that the inputs to any signal-processing component would be fully evaluated before the output could be produced. This would outlaw loops.</p>
<p><a id="c003_c3-para-2405"></a>Unfortunately, stream models of systems with loops may require uses of a delay beyond the stream programming pattern seen so far. For instance, <a id="c003_c3-fig-0039a"></a><a href="#c3-fig-0039">figure 3.34</a> shows a signal-processing system for solving the differential equation <i>dy</i>/<i>dt</i> = <i>f</i> (<i>y</i>) where <i>f</i> is a given function. The figure shows a mapping component, which applies <i>f</i> to its input signal, linked in a feedback loop to an integrator in a manner very similar to that of the analog computer circuits that are actually used to solve such equations.</p>
<figure id="c003_c3-fig-0039"><img alt="c3-fig-0034.jpg" src="../images/c3-fig-0034.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0039a">Figure 3.34</a></span> <a id="c003_c3-para-2406"></a>An “analog computer circuit” that solves the equation <i>dy</i>/<i>dt</i> = <i>f</i> (<i>y</i>).</p></figcaption></figure>
<p><a id="c003_c3-para-2407"></a>Assuming we are given an initial value <i>y</i><sub>0</sub> for <i>y</i>, we could try to model this system using the function</p>
<p class="Sp-text-1"><a id="c003_c3-para-2408"></a><b>function</b> solve(f, y0, dt) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2409"></a> <b>const</b> y = integral(dy, y0, dt);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2410"></a> <b>const</b> dy = stream_map(f, y);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2411"></a> <b>return</b> y;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2412"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2413"></a>This function does not work, because in the first line of <span class="KeyTerm1">solve</span> the call to <span class="KeyTerm1">integral</span> requires that the input <span class="KeyTerm1">dy</span> be defined, which does not happen until the second line of <span class="KeyTerm1">solve</span>.</p>
<p><a id="c003_c3-para-2414"></a>On the other hand, the intent of our definition does make sense, because we can, in principle, begin to generate the <span class="KeyTerm1">y</span> stream without knowing <span class="KeyTerm1">dy</span>. Indeed, <span class="KeyTerm1">integral</span> and many other stream operations can generate part of the answer given only partial information about the arguments. For <span class="KeyTerm1">integral</span>, the first element of the output stream is the specified <span class="KeyTerm1">initial_value</span>. Thus, we can generate the first element of the output stream without evaluating the integrand <span class="KeyTerm1">dy</span>. Once we know the first element of <span class="KeyTerm1">y</span>, the <span class="KeyTerm1">stream_map</span> in the second line of <span class="KeyTerm1">solve</span> can begin working to generate the first element of <span class="KeyTerm1">dy</span>, which will produce the next element of <span class="KeyTerm1">y</span>, and so on.</p>
<p><a id="c003_c3-para-2415"></a>To take advantage of this idea, we will redefine <span class="KeyTerm1">integral</span> to expect the integrand stream to be a <i>delayed argument</i>. The function <span class="KeyTerm1">integral</span> will force the integrand to be evaluated only when it is required to generate more than the first element of the output stream:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2416"></a><b>function</b> integral(delayed_integrand, initial_value, dt) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2417"></a> <b>const</b> integ =</p>
<p class="Sp-text-1"><a id="c003_c3-para-2418"></a>        pair(initial_value, </p>
<p class="Sp-text-1"><a id="c003_c3-para-2419"></a>             () =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2420"></a> <b>const</b> integrand = delayed_integrand();</p>
<p class="Sp-text-1"><a id="c003_c3-para-2421"></a> <b>return</b> add_streams(scale_stream(integrand, dt),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2422"></a>                                    integ);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2423"></a>             });</p>
<p class="Sp-text-1"><a id="c003_c3-para-2424"></a> <b>return</b> integ;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2425"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2426"></a>Now we can implement our <span class="KeyTerm1">solve</span> function by delaying the evaluation of <span class="KeyTerm1">dy</span> in the declaration of <span class="KeyTerm1">y</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2427"></a><b>function</b> solve(f, y0, dt) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2428"></a> <b>const</b> y = integral(() =&gt; dy, y0, dt);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2429"></a> <b>const</b> dy = stream_map(f, y);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2430"></a> <b>return</b> y;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2431"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2432"></a>In general, every caller of <span class="KeyTerm1">integral</span> must now delay the integrand argument. We can demonstrate that the <span class="KeyTerm1">solve</span> function works by approximating <i>e</i> ≈ 2.718 by computing the value at <i>y</i> = 1 of the solution to the differential equation <i>dy</i>/<i>dt</i> = <i>y</i> with initial condition <i>y</i>(0) = 1:<a id="c003_c3-fn-0072a"></a><a href="#c3-fn-0072"><sup>72</sup></a></p>
<p class="Sp-text-1"><a id="c003_c3-para-2433"></a>stream_ref(solve(y =&gt; y, 1, 0.001), 1000);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2434"></a><i>2.716923932235896</i></p>
<section>
<h5><a id="c003_c3-sec-0129"></a><a id="c003_c3-title-0130"></a>Exercise 3.77</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2435"></a>The <span class="KeyTerm1">integral</span> function used above was analogous to the “implicit” definition of the infinite stream of integers in section 3.5.2. Alternatively, we can give a definition of <span class="KeyTerm1">integral</span> that is more like <span class="KeyTerm1">integers-starting-from</span> (also in section 3.5.2):</p>
<p class="Sp-text-1"><a id="c003_c3-para-2436"></a><b>function</b> integral(integrand, initial_value, dt) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2437"></a> <b>return</b> pair(initial_value,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2438"></a>                is_null(integrand)</p>
<p class="Sp-text-1"><a id="c003_c3-para-2439"></a>                ? <b>null</b></p>
<p class="Sp-text-1"><a id="c003_c3-para-2440"></a>                : integral(stream_tail(integrand),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2441"></a>                           dt * head(integrand) + initial_value,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2442"></a>                           dt));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2443"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2444"></a>When used in systems with loops, this function has the same problem as does our original version of <span class="KeyTerm1">integral</span>. Modify the function so that it expects the <span class="KeyTerm1">integrand</span> as a delayed argument and hence can be used in the <span class="KeyTerm1">solve</span> function shown above.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0130"></a><a id="c003_c3-title-0131"></a>Exercise 3.78</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2445"></a>Consider the problem of designing a signal-processing system to study the homogeneous second-order linear differential equation</p>
<p><a id="c003_c3-para-2446"></a></p>
<figure id="c003_c3-fig-0052"><img alt="c3-fig-5012.jpg" src="../images/c3-fig-5012.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c003_c3-para-2447"></a>The output stream, modeling <i>y</i>, is generated by a network that contains a loop. This is because the value of <i>d</i><sup>2</sup><i>y</i>/<i>dt</i><sup>2</sup> depends upon the values of <i>y</i> and <i>dy</i>/<i>dt</i> and both of these are determined by integrating <i>d</i><sup>2</sup><i>y</i>/<i>dt</i><sup>2</sup>. The diagram we would like to encode is shown in <a id="c003_c3-fig-0040a"></a><a href="#c3-fig-0040">figure 3.35</a>. Write a function <span class="KeyTerm1">solve_2nd</span> that takes as arguments the constants <i>a</i>, <i>b</i>, and <i>dt</i> and the initial values <i>y</i><sub>0</sub> and <i>dy</i><sub>0</sub> for <i>y</i> and <i>dy</i>/<i>dt</i> and generates the stream of successive values of <i>y</i>.</p>
<figure id="c003_c3-fig-0040"><img alt="c3-fig-0035.jpg" src="../images/c3-fig-0035.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0040a">Figure 3.35</a></span> <a id="c003_c3-para-2448"></a>Signal-flow diagram for the solution to a second-order linear differential equation.</p></figcaption></figure>
</section>
<section>
<h5><a id="c003_c3-sec-0131"></a><a id="c003_c3-title-0132"></a>Exercise 3.79</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2449"></a>Generalize the <span class="KeyTerm1">solve_2nd</span> function of exercise 3.78 so that it can be used to solve general second-order differential equations <i>d</i><sup>2</sup><i>y</i>/<i>dt</i><sup>2</sup> = <i>f</i> (<i>dy</i>/<i>dt</i>, <i>y</i>).</p>
</section>
<section>
<h5><a id="c003_c3-sec-0132"></a><a id="c003_c3-title-0133"></a>Exercise 3.80</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2450"></a>A <i>series RLC circuit</i> consists of a resistor, a capacitor, and an inductor connected in series, as shown in <a id="c003_c3-fig-0041a"></a><a href="#c3-fig-0041">figure 3.36</a>. If <i>R</i>, <i>L</i>, and <i>C</i> are the resistance, inductance, and capacitance, then the relations between voltage (<i>v</i>) and current (<i>i</i>) for the three components are described by the equations</p>
<p><a id="c003_c3-para-2453"></a></p>
<figure id="c003_c3-fig-0053"><img alt="c3-fig-5013.jpg" src="../images/c3-fig-5013.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c003_c3-para-2454"></a>and the circuit connections dictate the relations</p>
<p class="Sp-text-2"><a id="c003_c3-para-2455"></a><i>i<sub>R</sub></i> = <i>i<sub>L</sub></i> = –<i>i<sub>C</sub></i></p>
<p class="Sp-text-2"><a id="c003_c3-para-2456"></a><i>v<sub>C</sub></i> = <i>v<sub>L</sub></i> + <i>v<sub>R</sub></i></p>
<p class="paracontinue"><a id="c003_c3-para-2457"></a>Combining these equations shows that the state of the circuit (summarized by <i>v<sub>C</sub></i>, the voltage across the capacitor, and <i>i<sub>L</sub></i>, the current in the inductor) is described by the pair of differential equations</p>
<p><a id="c003_c3-para-2458"></a></p>
<figure id="c003_c3-fig-0054"><img alt="c3-fig-5014.jpg" src="../images/c3-fig-5014.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
<p class="paracontinue"><a id="c003_c3-para-2459"></a>The signal-flow diagram representing this system of differential equations is shown in <a id="c003_c3-fig-0042a"></a><a href="#c3-fig-0042">figure 3.37</a>.</p>
<figure id="c003_c3-fig-0041"><img alt="c3-fig-0036.jpg" src="../images/c3-fig-0036.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0041a">Figure 3.36</a></span> <a id="c003_c3-para-2451"></a>A series RLC circuit.</p></figcaption></figure>
<figure id="c003_c3-fig-0042"><img alt="c3-fig-0037.jpg" src="../images/c3-fig-0037.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0042a">Figure 3.37</a></span> <a id="c003_c3-para-2460"></a>A signal-flow diagram for the solution to a series RLC circuit.</p></figcaption></figure>
<p><a id="c003_c3-para-2461"></a>Write a function <span class="KeyTerm1">RLC</span> that takes as arguments the parameters <i>R</i>, <i>L</i>, and <i>C</i> of the circuit and the time increment <i>dt</i>. In a manner similar to that of the <span class="KeyTerm1">RC</span> function of exercise 3.73, <span class="KeyTerm1">RLC</span> should produce a function that takes the initial values of the state variables, 5<img alt="c3-fig-5015.jpg" src="../images/c3-fig-5015.jpg"/> and <img alt="c3-fig-5016.jpg" src="../images/c3-fig-5016.jpg"/>, and produces a pair (using <span class="KeyTerm1">pair</span>) of the streams of states <i>v<sub>C</sub></i> and <i>i<sub>L</sub></i>. Using <span class="KeyTerm1">RLC</span>, generate the pair of streams that models the behavior of a series RLC circuit with <i>R</i> = 1 ohm, <i>C</i> = 0.2 farad, <i>L</i> = 1 henry, <i>dt</i> = 0.1 second, and initial values <img alt="c3-fig-5016.jpg" src="../images/c3-fig-5016.jpg"/> = 0 amps and <img alt="c3-fig-5015.jpg" src="../images/c3-fig-5015.jpg"/> = 10 volts.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0133"></a><a id="c003_c3-title-0134"></a>Normal-order evaluation</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2462"></a>The examples in this section illustrate how delayed evaluation provides great programming flexibility, but the same examples also show how this can make our programs more complex. Our new <span class="KeyTerm1">integral</span> function, for instance, gives us the power to model systems with loops, but we must now remember that <span class="KeyTerm1">integral</span> should be called with a delayed integrand, and every function that uses <span class="KeyTerm1">integral</span> must be aware of this. In effect, we have created two classes of functions: ordinary functions and functions that take delayed arguments. In general, creating separate classes of functions forces us to create separate classes of higher-order functions as well.<a id="c003_c3-fn-0073a"></a><a href="#c3-fn-0073"><sup>73</sup></a></p>
<p><a id="c003_c3-para-2463"></a>One way to avoid the need for two different classes of functions is to make all functions take delayed arguments. We could adopt a model of evaluation in which all arguments to functions are automatically delayed and arguments are forced only when they are actually needed (for example, when they are required by a primitive operation). This would transform our language to use normal-order evaluation, which we first described when we introduced the substitution model for evaluation in section 1.1.5. Converting to normal-order evaluation provides a uniform and elegant way to simplify the use of delayed evaluation, and this would be a natural strategy to adopt if we were concerned only with stream processing. In section 4.2, after we have studied the evaluator, we will see how to transform our language in just this way. Unfortunately, including delays in function calls wreaks havoc with our ability to design programs that depend on the order of events, such as programs that use assignment, mutate data, or perform input or output. Even a single delay in the tail of a pair can cause great confusion, as illustrated by exercises 3.51 and 3.52. As far as anyone knows, mutability and delayed evaluation do not mix well in programming languages.</p>
</section>
</section>
<section>
<h3><a id="c003_c3-sec-0134"></a><span>3.5.5</span> <a id="c003_c3-title-0135"></a>Modularity of Functional Programs and Modularity of Objects</h3>
<p class="paraaftertitle"><a id="c003_c3-para-2464"></a>As we saw in section 3.1.2, one of the major benefits of introducing assignment is that we can increase the modularity of our systems by encapsulating, or “hiding,” parts of the state of a large system within local variables. Stream models can provide an equivalent modularity without the use of assignment. As an illustration, we can reimplement the Monte Carlo estimation of <i>π</i>, which we examined in section 3.1.2, from a stream-processing point of view.</p>
<p><a id="c003_c3-para-2465"></a>The key modularity issue was that we wished to hide the internal state of a random-number generator from programs that used random numbers. We began with a function <span class="KeyTerm1">rand_update</span>, whose successive values furnished our supply of random numbers, and used this to produce a random-number generator:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2466"></a><b>function</b> make_rand() {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2467"></a> <b>let</b> x = random_init;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2468"></a> <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2469"></a>               x = rand_update(x);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2470"></a> <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2471"></a>           };</p>
<p class="Sp-text-1"><a id="c003_c3-para-2472"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-2473"></a><b>const</b> rand = make_rand();</p>
<p><a id="c003_c3-para-2474"></a>In the stream formulation there is no random-number generator <i>per se</i>, just a stream of random numbers produced by successive calls to <span class="KeyTerm1">rand_update</span>:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2475"></a><b>const</b> random_numbers =</p>
<p class="Sp-text-1"><a id="c003_c3-para-2476"></a>    pair(random_init,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2477"></a>         () =&gt; stream_map(rand_update, random_numbers));</p>
<p class="paracontinue"><a id="c003_c3-para-2478"></a>We use this to construct the stream of outcomes of the Cesàro experiment performed on consecutive pairs in the <span class="KeyTerm1">random_numbers</span> stream:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2479"></a><b>function</b> map_successive_pairs(f, s) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2480"></a> <b>return</b> pair(f(head(s), head(stream_tail(s))),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2481"></a>                () =&gt; map_successive_pairs(</p>
<p class="Sp-text-1"><a id="c003_c3-para-2482"></a>                          f,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2483"></a>                          stream_tail(stream_tail(s))));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2484"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-2485"></a><b>const</b> dirichlet_stream =</p>
<p class="Sp-text-1"><a id="c003_c3-para-2486"></a>    map_successive_pairs((r1, r2) =&gt; gcd(r1, r2) === 1,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2487"></a>                         random_numbers);</p>
<p class="paracontinue"><a id="c003_c3-para-2488"></a>The <span class="KeyTerm1">dirichlet_stream</span> is now fed to a <span class="KeyTerm1">monte_carlo</span> function, which produces a stream of estimates of probabilities. The results are then converted into a stream of estimates of <i>π</i>. This version of the program doesn't need a parameter telling how many trials to perform. Better estimates of <i>π</i> (from performing more experiments) are obtained by looking farther into the <span class="KeyTerm1">pi</span> stream:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2489"></a><b>function</b> monte_carlo(experiment_stream, passed, failed) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2490"></a> <b>function</b> next(passed, failed) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2491"></a> <b>return</b> pair(passed / (passed + failed),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2492"></a>                    () =&gt; monte_carlo(stream_tail(experiment_stream),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2493"></a>                                      passed, failed));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2494"></a>    }</p>
<p class="Sp-text-1"><a id="c003_c3-para-2495"></a> <b>return</b> head(experiment_stream)</p>
<p class="Sp-text-1"><a id="c003_c3-para-2496"></a>           ? next(passed + 1, failed)</p>
<p class="Sp-text-1"><a id="c003_c3-para-2497"></a>           : next(passed, failed + 1);</p>
<p class="Sp-text-1"><a id="c003_c3-para-2498"></a>}</p>
<p class="Sp-text-1"><a id="c003_c3-para-2499"></a><b>const</b> pi = stream_map(p =&gt; math_sqrt(6 / p),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2500"></a>                      monte_carlo(dirichlet_stream, 0, 0));</p>
<p class="paracontinue"><a id="c003_c3-para-2501"></a>There is considerable modularity in this approach, because we still can formulate a general <span class="KeyTerm1">monte_carlo</span> function that can deal with arbitrary experiments. Yet there is no assignment or local state.</p>
<section>
<h5><a id="c003_c3-sec-0135"></a><a id="c003_c3-title-0136"></a>Exercise 3.81</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2502"></a>Exercise 3.6 discussed generalizing the random-number generator to allow one to reset the random-number sequence so as to produce repeatable sequences of “random” numbers. Produce a stream formulation of this same generator that operates on an input stream of requests to <span class="KeyTerm1">"generate"</span> a new random number or to <span class="KeyTerm1">"reset"</span> the sequence to a specified value and that produces the desired stream of random numbers. Don't use assignment in your solution.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0136"></a><a id="c003_c3-title-0137"></a>Exercise 3.82</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2503"></a>Redo exercise 3.5 on Monte Carlo integration in terms of streams. The stream version of <span class="KeyTerm1">estimate_integral</span> will not have an argument telling how many trials to perform. Instead, it will produce a stream of estimates based on successively more trials.</p>
</section>
<section>
<h5><a id="c003_c3-sec-0137"></a><a id="c003_c3-title-0138"></a>A functional-programming view of time</h5>
<p class="paraaftertitle"><a id="c003_c3-para-2504"></a>Let us now return to the issues of objects and state that were raised at the beginning of this chapter and examine them in a new light. We introduced assignment and mutable objects to provide a mechanism for modular construction of programs that model systems with state. We constructed computational objects with local state variables and used assignment to modify these variables. We modeled the temporal behavior of the objects in the world by the temporal behavior of the corresponding computational objects.</p>
<p><a id="c003_c3-para-2505"></a>Now we have seen that streams provide an alternative way to model objects with local state. We can model a changing quantity, such as the local state of some object, using a stream that represents the time history of successive states. In essence, we represent time explicitly, using streams, so that we decouple time in our simulated world from the sequence of events that take place during evaluation. Indeed, because of the presence of delayed evaluation there may be little relation between simulated time in the model and the order of events during the evaluation.</p>
<p><a id="c003_c3-para-2506"></a>In order to contrast these two approaches to modeling, let us reconsider the implementation of a “withdrawal processor” that monitors the balance in a bank account. In section 3.1.3 we implemented a simplified version of such a processor:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2507"></a><b>function</b> make_simplified_withdraw(balance) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2508"></a> <b>return</b> amount =&gt; {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2509"></a>               balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2510"></a> <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c003_c3-para-2511"></a>           };</p>
<p class="Sp-text-1"><a id="c003_c3-para-2512"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2513"></a>Calls to <span class="KeyTerm1">make_simplified_withdraw</span> produce computational objects, each with a local state variable <span class="KeyTerm1">balance</span> that is decremented by successive calls to the object. The object takes an <span class="KeyTerm1">amount</span> as an argument and returns the new balance. We can imagine the user of a bank account typing a sequence of inputs to such an object and observing the sequence of returned values shown on a display screen.</p>
<p><a id="c003_c3-para-2514"></a>Alternatively, we can model a withdrawal processor as a function that takes as input a balance and a stream of amounts to withdraw and produces the stream of successive balances in the account:</p>
<p class="Sp-text-1"><a id="c003_c3-para-2515"></a><b>function</b> stream_withdraw(balance, amount_stream) {</p>
<p class="Sp-text-1"><a id="c003_c3-para-2516"></a> <b>return</b> pair(balance,</p>
<p class="Sp-text-1"><a id="c003_c3-para-2517"></a>                () =&gt; stream_withdraw(balance - head(amount_stream),</p>
<p class="Sp-text-1"><a id="c003_c3-para-2518"></a>                                      stream_tail(amount_stream)));</p>
<p class="Sp-text-1"><a id="c003_c3-para-2519"></a>}</p>
<p class="paracontinue"><a id="c003_c3-para-2520"></a>The function <span class="KeyTerm1">stream_withdraw</span> implements a well-defined mathematical function whose output is fully determined by its input. Suppose, however, that the input <span class="KeyTerm1">amount_stream</span> is the stream of successive values typed by the user and that the resulting stream of balances is displayed. Then, from the perspective of the user who is typing values and watching results, the stream process has the same behavior as the object created by <span class="KeyTerm1">make_simplified_withdraw</span>. However, with the stream version, there is no assignment, no local state variable, and consequently none of the theoretical difficulties that we encountered in section 3.1.3. Yet the system has state!</p>
<p><a id="c003_c3-para-2521"></a>This is really remarkable. Even though <span class="KeyTerm1">stream_withdraw</span> implements a welldefined mathematical function whose behavior does not change, the user's perception here is one of interacting with a system that has a changing state. One way to resolve this paradox is to realize that it is the user's temporal existence that imposes state on the system. If the user could step back from the interaction and think in terms of streams of balances rather than individual transactions, the system would appear stateless.<a id="c003_c3-fn-0074a"></a><a href="#c3-fn-0074"><sup>74</sup></a></p>
<p><a id="c003_c3-para-2522"></a>From the point of view of one part of a complex process, the other parts appear to change with time. They have hidden time-varying local state. If we wish to write programs that model this kind of natural decomposition in our world (as we see it from our viewpoint as a part of that world) with structures in our computer, we make computational objects that are not functional—they must change with time. We model state with local state variables, and we model the changes of state with assignments to those variables. By doing this we make the time of execution of a computation model time in the world that we are part of, and thus we get “objects” in our computer.</p>
<p><a id="c003_c3-para-2523"></a>Modeling with objects is powerful and intuitive, largely because this matches the perception of interacting with a world of which we are part. However, as we've seen repeatedly throughout this chapter, these models raise thorny problems of constraining the order of events and of synchronizing multiple processes. The possibility of avoiding these problems has stimulated the development of <i>functional programming languages</i>, which do not include any provision for assignment or mutable data. In such a language, all functions implement well-defined mathematical functions of their arguments, whose behavior does not change. The functional approach is extremely attractive for dealing with concurrent systems.<a id="c003_c3-fn-0075a"></a><a href="#c3-fn-0075"><sup>75</sup></a></p>
<p><a id="c003_c3-para-2524"></a>On the other hand, if we look closely, we can see time-related problems creeping into functional models as well. One particularly troublesome area arises when we wish to design interactive systems, especially ones that model interactions between independent entities. For instance, consider once more the implementation of a banking system that permits joint bank accounts. In a conventional system using assignment and objects, we would model the fact that Peter and Paul share an account by having both Peter and Paul send their transaction requests to the same bank-account object, as we saw in section 3.1.3. From the stream point of view, where there are no “objects” <i>per se</i>, we have already indicated that a bank account can be modeled as a process that operates on a stream of transaction requests to produce a stream of responses. Accordingly, we could model the fact that Peter and Paul have a joint bank account by merging Peter's stream of transaction requests with Paul's stream of requests and feeding the result to the bank-account stream process, as shown in <a id="c003_c3-fig-0043a"></a><a href="#c3-fig-0043">figure 3.38</a>.</p>
<figure id="c003_c3-fig-0043"><img alt="c3-fig-0038.jpg" src="../images/c3-fig-0038.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0043a">Figure 3.38</a></span> <a id="c003_c3-para-2525"></a>A joint bank account, modeled by merging two streams of transaction requests.</p></figcaption></figure>
<p><a id="c003_c3-para-2526"></a>The trouble with this formulation is in the notion of <i>merge</i>. It will not do to merge the two streams by simply taking alternately one request from Peter and one request from Paul. Suppose Paul accesses the account only very rarely. We could hardly force Peter to wait for Paul to access the account before he could issue a second transaction. However such a merge is implemented, it must interleave the two transaction streams in some way that is constrained by “real time” as perceived by Peter and Paul, in the sense that, if Peter and Paul meet, they can agree that certain transactions were processed before the meeting, and other transactions were processed after the meeting.<a id="c003_c3-fn-0076a"></a><a href="#c3-fn-0076"><sup>76</sup></a> This is precisely the same constraint that we had to deal with in section 3.4.1, where we found the need to introduce explicit synchronization to ensure a “correct” order of events in concurrent processing of objects with state. Thus, in an attempt to support the functional style, the need to merge inputs from different agents reintroduces the same problems that the functional style was meant to eliminate.</p>
<p><a id="c003_c3-para-2527"></a>We began this chapter with the goal of building computational models whose structure matches our perception of the real world we are trying to model. We can model the world as a collection of separate, time-bound, interacting objects with state, or we can model the world as a single, timeless, stateless unity. Each view has powerful advantages, but neither view alone is completely satisfactory. A grand unification has yet to emerge.<a id="c003_c3-fn-0077a"></a><a href="#c3-fn-0077"><sup>77</sup></a></p>
</section>
</section>
</section>
</section>
<section class="BS_enoteSec">
<aside class="noteEntry"><a id="c003_c3-fn-0001"></a><a href="#c3-fn-0001a">1</a> Actually, this is not quite true. One exception was the random-number generator in section 1.2.6. Another exception involved the operation/type tables we introduced in section 2.4.3, where the values of two calls to <span class="KeyTerm1">get</span> with the same arguments depended on intervening calls to <span class="KeyTerm1">put</span>. On the other hand, until we introduce assignment, we have no way to create such functions ourselves.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0002"></a><a href="#c3-fn-0002a">2</a> The value of an assignment is the value being assigned to the name. Assignment expression statements look similar to and should not be confused with constant and variable declarations of the form
<br/><span class="BS_Sp-text-1_FN"><b>const</b> <span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>value</i></span>;</span>
<br/>and
<br/><span class="BS_Sp-text-1_FN"><b>let</b> <span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>value</i></span>;</span>
<br/>in which a newly declared <i>name</i> is associated with a <i>value</i>. Assignment expressions look similar to and should not be confused with expressions of the form
<br/><span class="BS_Sp-text-1_FN"><span class="KeyTerm2"><i>expression</i><sub>1</sub></span> === <span class="KeyTerm2"><i>expression</i><sub>2</sub></span></span>
<br/>which evaluate to <span class="KeyTerm1"><b>true</b></span> if <i>expression</i><sub>1</sub> evaluates to the same value as <i>expression</i><sub>2</sub> and to <span class="KeyTerm1"><b>false</b></span> otherwise.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0003"></a><a href="#c3-fn-0003a">3</a> We have already used sequences implicitly in our programs, because in JavaScript the body block of a function can contain a sequence of function declarations followed by a return statement, not just a single return statement, as discussed in section 1.1.8.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0004"></a><a href="#c3-fn-0004a">4</a> Blocks as bodies of lambda expressions were introduced in section 2.2.4.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0005"></a><a href="#c3-fn-0005a">5</a> In programming-language jargon, the variable <span class="KeyTerm1">balance</span> is said to be <i>encapsulated</i> within the <span class="KeyTerm1">new_withdraw</span> function. Encapsulation reflects the general system-design principle known as the <i>hiding principle</i>: One can make a system more modular and robust by protecting parts of the system from each other; that is, by providing information access only to those parts of the system that have a “need to know.”</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0006"></a><a href="#c3-fn-0006a">6</a> In contrast with <span class="KeyTerm1">make_withdraw_balance_100</span> above, we do not have to use <span class="KeyTerm1"><b>let</b></span> to make <span class="KeyTerm1">balance</span> a local variable, since parameters are already local. This will be clearer after the discussion of the environment model of evaluation in section 3.2. (See also exercise 3.10.)</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0007"></a><a href="#c3-fn-0007a">7</a> One common way to implement <span class="KeyTerm1">rand_update</span> is to use the rule that <i>x</i> is updated to <i>ax</i> + <i>b</i> modulo <i>m</i>, where <i>a</i>, <i>b</i>, and <i>m</i> are appropriately chosen integers. Chapter 3 of Knuth 1997b includes an extensive discussion of techniques for generating sequences of random numbers and establishing their statistical properties. Notice that the <span class="KeyTerm1">rand_update</span> function computes a mathematical function: Given the same input twice, it produces the same output. Therefore, the number sequence produced by <span class="KeyTerm1">rand_update</span> certainly is not “random,” if by “random” we insist that each number in the sequence is unrelated to the preceding number. The relation between “real randomness” and so-called <i>pseudo-random</i> sequences, which are produced by well-determined computations and yet have suitable statistical properties, is a complex question involving difficult issues in mathematics and philosophy. Kolmogorov, Solomonoff, and Chaitin have made great progress in clarifying these issues; a discussion can be found in Chaitin 1975.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0008"></a><a href="#c3-fn-0008a">8</a> This theorem is due to G. Lejeune Dirichlet. See section 4.5.2 of Knuth 1997b for a discussion and a proof.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0009"></a><a href="#c3-fn-0009a">9</a> We don't substitute for the occurrence of <span class="KeyTerm1">balance</span> in the assignment because the name in an assignment is not evaluated. If we did substitute for it, we would get <span class="KeyTerm1">25 = 25 - amount;</span>, which makes no sense.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0010"></a><a href="#c3-fn-0010a">10</a> The phenomenon of a single computational object being accessed by more than one name is known as <i>aliasing</i>. The joint bank account situation illustrates a very simple example of an alias. In section 3.3 we will see much more complex examples, such as “distinct” compound data structures that share parts. Bugs can occur in our programs if we forget that a change to an object may also, as a “side effect,” change a “different” object because the two “different” objects are actually a single object appearing under different aliases. These so-called <i>side-effect bugs</i> are so difficult to locate and to analyze that some people have proposed that programming languages be designed in such a way as to not allow side effects or aliasing (Lampson et al. 1981; Morris, Schmidt, and Wadler 1980).</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0011"></a><a href="#c3-fn-0011a">11</a> In view of this, it is ironic that introductory programming is most often taught in a highly imperative style. This may be a vestige of a belief, common throughout the 1960s and 1970s, that programs that call functions must inherently be less efficient than programs that perform assignments. (Steele (1977) debunks this argument.) Alternatively it may reflect a view that step-by-step assignment is easier for beginners to visualize than function call. Whatever the reason, it often saddles beginning programmers with “should I set this variable before or after that one” concerns that can complicate programming and obscure the important ideas.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0012"></a><a href="#c3-fn-0012a">12</a> Assignment introduces a subtlety into step 1 of the evaluation rule. As shown in exercise 3.8, the presence of assignment allows us to write expressions that will produce different values depending on the order in which the subexpressions in a combination are evaluated. To eliminate such ambiguities, JavaScript specifies left-to-right evaluation of the subexpressions of combinations and of the argument expressions of applications.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0013"></a><a href="#c3-fn-0013a">13</a> Footnote 54 in chapter 1 mentions subtle differences between the two in full JavaScript, which we will ignore in this book.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0014"></a><a href="#c3-fn-0014a">14</a> We mentioned in footnote 54 in chapter 1 that the full JavaScript language allows assignment to names that are declared with function declarations.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0015"></a><a href="#c3-fn-0015a">15</a> This example does not make use of the fact that the parameter <span class="KeyTerm1">x</span> is a variable, but recall the function <span class="KeyTerm1">make_withdraw</span> in section 3.1.1, which relied on its parameter being a variable.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0016"></a><a href="#c3-fn-0016a">16</a> The environment model will not clarify our claim in section 1.2.1 that the interpreter can execute a function such as <span class="KeyTerm1">fact_iter</span> in a constant amount of space using tail recursion. We will discuss tail recursion when we deal with the control structure of the interpreter in section 5.4.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0017"></a><a href="#c3-fn-0017a">17</a> Whether <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> share the same physical code stored in the computer, or whether they each keep a copy of the code, is a detail of the implementation. For the interpreter we implement in chapter 4, the code is in fact shared.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0018"></a><a href="#c3-fn-0018a">18</a> This explains why the program in footnote 56 of chapter 1 goes wrong. The time between creating the binding for a name and evaluating the declaration of the name is called the <i>temporal dead zone</i> (TDZ).</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0019"></a><a href="#c3-fn-0019a">19</a> The functions <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span> return the value <span class="KeyTerm1">undefined</span>. They should be used only for their effect.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0020"></a><a href="#c3-fn-0020a">20</a> We see from this that mutation operations on lists can create “garbage” that is not part of any accessible structure. We will see in section 5.3.2 that JavaScript memory-management systems include a <i>garbage collector</i>, which identifies and recycles the memory space used by unneeded pairs.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0021"></a><a href="#c3-fn-0021a">21</a> Section 5.3.1 will show how a memory-management system can implement <span class="KeyTerm1">get_new_pair</span>.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0022"></a><a href="#c3-fn-0022a">22</a> The two pairs are distinct because each call to <span class="KeyTerm1">pair</span> returns a new pair. The strings are “the same” in the sense that they are primitive data (just like numbers) that are composed of the same characters in the same order. Since JavaScript provides no way to mutate a string, any sharing that the designers of a JavaScript interpreter might decide to implement for strings is undetectable. We consider primitive data such as numbers, booleans, and strings to be <i>identical</i> if and only if they are <i>indistinguishable</i>.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0023"></a><a href="#c3-fn-0023a">23</a> The subtleties of dealing with sharing of mutable data objects reflect the underlying issues of “sameness” and “change” that were raised in section 3.1.3. We mentioned there that admitting change to our language requires that a compound object must have an “identity” that is something different from the pieces from which it is composed. In JavaScript, we consider this “identity” to be the quality that is tested by <span class="KeyTerm1">===</span>, i.e., by equality of pointers. Since in most JavaScript implementations a pointer is essentially a memory address, we are “solving the problem” of defining the identity of objects by stipulating that a data object “itself” is the information stored in some particular set of memory locations in the computer. This suffices for simple JavaScript programs, but is hardly a general way to resolve the issue of “sameness” in computational models.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0024"></a><a href="#c3-fn-0024a">24</a> On the other hand, from the viewpoint of implementation, assignment requires us to modify the environment, which is itself a mutable data structure. Thus, assignment and mutation are equipotent: Each can be implemented in terms of the other.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0025"></a><a href="#c3-fn-0025a">25</a> If the first item is the final item in the queue, the front pointer will be the empty list after the deletion, which will mark the queue as empty; we needn't worry about updating the rear pointer, which will still point to the deleted item, because <span class="KeyTerm1">is_empty_queue</span> looks only at the front pointer.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0026"></a><a href="#c3-fn-0026a">26</a> Be careful not to make the interpreter try to print a structure that contains cycles. (See exercise 3.13.)</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0027"></a><a href="#c3-fn-0027a">27</a> Because <span class="KeyTerm1">assoc</span> uses <span class="KeyTerm1">equal</span>, it can recognize keys that are strings, numbers, or list structure.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0028"></a><a href="#c3-fn-0028a">28</a> Thus, the first backbone pair is the object that represents the table “itself”; that is, a pointer to the table is a pointer to this pair. This same backbone pair always starts the table. If we did not arrange things in this way, <span class="KeyTerm1">insert</span> would have to return a new value for the start of the table when it added a new record.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0029"></a><a href="#c3-fn-0029a">29</a> A full-adder is a basic circuit element used in adding two binary numbers. Here <i>A</i> and <i>B</i> are the bits at corresponding positions in the two numbers to be added, and <i>C<sub>in</sub></i> is the carry bit from the addition one place to the right. The circuit generates <i>SUM</i>, which is the sum bit in the corresponding position, and <i>C<sub>out</sub></i>, which is the carry bit to be propagated to the left.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0030"></a><a href="#c3-fn-0030a">30</a> These functions are simply syntactic sugar that allow us to use ordinary functional syntax to access the local functions of objects. It is striking that we can interchange the role of “functions” and “data” in such a simple way. For example, if we write <span class="KeyTerm1">wire("get_signal")</span> we think of <span class="KeyTerm1">wire</span> as a function that is called with the message <span class="KeyTerm1">"get_signal"</span> as input. Alternatively, writing <span class="KeyTerm1">get_signal(wire)</span> encourages us to think of <span class="KeyTerm1">wire</span> as a data object that is the input to a function <span class="KeyTerm1">get_signal</span>. The truth of the matter is that, in a language in which we can deal with functions as objects, there is no fundamental difference between “functions” and “data,” and we can choose our syntactic sugar to allow us to program in whatever style we choose.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0031"></a><a href="#c3-fn-0031a">31</a> The agenda is a headed list, like the tables in section 3.3.3, but since the list is headed by the time, we do not need an additional dummy header (such as the <span class="KeyTerm1">"*table*"</span> string used with tables).</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0032"></a><a href="#c3-fn-0032a">32</a> Observe that the conditional statement in this function has an empty block as its alternative statement. Such a “one-armed conditional statement” is used to decide whether to do something, rather than to select between two statements.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0033"></a><a href="#c3-fn-0033a">33</a> In this way, the current time will always be the time of the action most recently processed. Storing this time at the head of the agenda ensures that it will still be available even if the associated time segment has been deleted.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0034"></a><a href="#c3-fn-0034a">34</a> Constraint propagation first appeared in the incredibly forward-looking SKETCHPAD system of Ivan Sutherland (1963). A beautiful constraint-propagation system based on the Smalltalk language was developed by Alan Borning (1977) at Xerox Palo Alto Research Center. Sussman, Stallman, and Steele applied constraint propagation to electrical circuit analysis (Sussman and Stallman 1975; Sussman and Steele 1980). TK!Solver (Konopasek and Jayaraman 1984) is an extensive modeling environment based on constraints.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0035"></a><a href="#c3-fn-0035a">35</a> The <span class="KeyTerm1">setter</span> might not be a constraint. In our temperature example, we used <span class="KeyTerm1">"user"</span> as the <span class="KeyTerm1">setter</span>.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0036"></a><a href="#c3-fn-0036a">36</a> We can use the function <span class="KeyTerm1">member</span> from section 2.3.1 to test whether <span class="KeyTerm1">new_constraint</span> is already in <span class="KeyTerm1">constraints</span>, although <span class="KeyTerm1">member</span> was introduced as being limited to numbers and strings, because we extended <span class="KeyTerm1">===</span> to pointer equality in section 3.3.1.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0037"></a><a href="#c3-fn-0037a">37</a> The expression-oriented format is convenient because it avoids the need to name the intermediate expressions in a computation. Our original formulation of the constraint language is cumbersome in the same way that many languages are cumbersome when dealing with operations on compound data. For example, if we wanted to compute the product (<i>a</i> + <i>b</i>) (<i>c</i> + <i>d</i>), where the variables represent vectors, we could work in “imperative style,” using functions that set the values of designated vector arguments but do not themselves return vectors as values:
<br/><span class="BS_Sp-text-1_FN">v_sum("a", "b", temp1);</span>
<br/><span class="BS_Sp-text-1_FN">v_sum("c", "d", temp2);</span>
<br/><span class="BS_Sp-text-1_FN">v_prod(temp1, temp2, answer);</span>
<br/>Alternatively, we could deal with expressions, using functions that return vectors as values, and thus avoid explicitly mentioning <span class="KeyTerm1">temp1</span> and <span class="KeyTerm1">temp2</span>:
<br/><span class="BS_Sp-text-1_FN"><b>const</b> answer = v_prod(v_sum("a", "b"), v_sum("c", "d"));</span>
<br/>Since JavaScript allows us to return compound objects as values of functions, we can transform our imperative-style constraint language into an expression-oriented style as shown in this exercise. Given the advantage of the expression-oriented format, one might ask if there is any reason to have implemented the system in imperative style, as we did in this section. One reason is that the non-expression-oriented constraint language provides a handle on constraint objects (e.g., the value of the <span class="KeyTerm1">adder</span> function) as well as on connector objects. This is useful if we wish to extend the system with new operations that communicate with constraints directly rather than only indirectly via operations on connectors. Although it is easy to implement the expression-oriented style in terms of the imperative implementation, it is very difficult to do the converse.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0038"></a><a href="#c3-fn-0038a">38</a> Such sequential threads are called “processes” throughout the book, but in this section we use the term “thread” to emphasize their access to shared memory.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0039"></a><a href="#c3-fn-0039a">39</a> Most real processors actually execute a few operations at a time, following a strategy called <i>pipelining</i>. Although this technique greatly improves the effective utilization of the hardware, it is used only to speed up the execution of a sequential instruction stream, while retaining the behavior of the sequential program.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0040"></a><a href="#c3-fn-0040a">40</a> To quote some graffiti seen on a building wall in Cambridge, Massachusetts: “Time is a device that was invented to keep everything from happening at once.”</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0041"></a><a href="#c3-fn-0041a">41</a> An even worse failure for this system could occur if the two assignments attempt to change the balance simultaneously, in which case the actual data appearing in memory might end up being a random combination of the information being written by the two threads. Most computers have interlocks on the primitive memory-write operations, which protect against such simultaneous access. Even this seemingly simple kind of protection, however, raises implementation challenges in the design of multiprocessing computers, where elaborate <i>cache-coherence</i> protocols are required to ensure that the various processors will maintain a consistent view of memory contents, despite the fact that data may be replicated (“cached”) among the different processors to increase the speed of memory access.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0042"></a><a href="#c3-fn-0042a">42</a> The factorial program in section 3.1.3 illustrates this for a single sequential thread.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0043"></a><a href="#c3-fn-0043a">43</a> The columns show the contents of Peter's wallet, the joint account (in Bank1), Paul's wallet, and Paul's private account (in Bank2), before and after each withdrawal (W) and deposit (D). Peter withdraws $10 from Bank1; Paul deposits $5 in Bank2, then withdraws $25 from Bank1.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0044"></a><a href="#c3-fn-0044a">44</a> A more formal way to express this idea is to say that concurrent programs are inherently <i>nondeterministic</i>. That is, they are described not by single-valued functions, but by functions whose results are sets of possible values. In section 4.3 we will study a language for expressing nondeterministic computations.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0045"></a><a href="#c3-fn-0045a">45</a> The function <span class="KeyTerm1">concurrent_execute</span> is not part of the JavaScript standard, but the examples in this section can be implemented in ECMAScript 2020.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0046"></a><a href="#c3-fn-0046a">46</a> We have simplified <span class="KeyTerm1">exchange</span> by exploiting the fact that our <span class="KeyTerm1">deposit</span> message accepts negative amounts. (This is a serious bug in our banking system!)</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0047"></a><a href="#c3-fn-0047a">47</a> If the account balances start out as $10, $20, and $30, then after any number of concurrent exchanges, the balances should still be $10, $20, and $30 in some order. Serializing the deposits to individual accounts is not sufficient to guarantee this. See exercise 3.43.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0048"></a><a href="#c3-fn-0048a">48</a> Exercise 3.45 investigates why deposits and withdrawals are no longer automatically serialized by the account.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0049"></a><a href="#c3-fn-0049a">49</a> The term “mutex” is an abbreviation for <i>mutual exclusion</i>. The general problem of arranging a mechanism that permits concurrent threads to safely share resources is called the mutual exclusion problem. Our mutex is a simple variant of the <i>semaphore</i> mechanism (see exercise 3.47), which was introduced in the “THE” Multiprogramming System developed at the Technological University of Eindhoven and named for the university's initials in Dutch (Dijkstra 1968a). The acquire and release operations were originally called P and V, from the Dutch words <i>passeren</i> (to pass) and <i>vrijgeven</i> (to release), in reference to the semaphores used on railroad systems. Dijkstra's classic exposition (1968b) was one of the first to clearly present the issues of concurrency control, and showed how to use semaphores to handle a variety of concurrency problems.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0050"></a><a href="#c3-fn-0050a">50</a> In most time-shared operating systems, threads that are blocked by a mutex do not waste time “busy-waiting” as above. Instead, the system schedules another thread to run while the first is waiting, and the blocked thread is awakened when the mutex becomes available.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0051"></a><a href="#c3-fn-0051a">51</a> There are many variants of such instructions—including test-and-set, test-and-clear, swap, compare-and-exchange, load-reserve, and store-conditional—whose design must be carefully matched to the machine's processor–memory interface. One issue that arises here is to determine what happens if two threads attempt to acquire the same resource at exactly the same time by using such an instruction. This requires some mechanism for making a decision about which thread gets control. Such a mechanism is called an <i>arbiter</i>. Arbiters usually boil down to some sort of hardware device. Unfortunately, it is possible to prove that one cannot physically construct a fair arbiter that works 100% of the time unless one allows the arbiter an arbitrarily long time to make its decision. The fundamental phenomenon here was originally observed by the fourteenth-century French philosopher Jean Buridan in his commentary on Aristotle's <i>De caelo</i>. Buridan argued that a perfectly rational dog placed between two equally attractive sources of food will starve to death, because it is incapable of deciding which to go to first.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0052"></a><a href="#c3-fn-0052a">52</a> The general technique for avoiding deadlock by numbering the shared resources and acquiring them in order is due to Havender (1968). Situations where deadlock cannot be avoided require <i>deadlock-recovery</i> methods, which entail having threads “back out” of the deadlocked state and try again. Deadlock-recovery mechanisms are widely used in data-base-management systems, a topic that is treated in detail in Gray and Reuter 1993.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0053"></a><a href="#c3-fn-0053a">53</a> One such alternative to serialization is called <i>barrier synchronization</i>. The programmer permits concurrent threads to execute as they please, but establishes certain synchronization points (“barriers”) through which no thread can proceed until all the threads have reached the barrier. Some processors provide machine instructions that permit programmers to establish synchronization points at places where consistency is required. The PowerPC<sup>TM</sup>, for example, includes for this purpose two instructions called SYNC and EIEIO (Enforced In-order Execution of Input/Output).</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0054"></a><a href="#c3-fn-0054a">54</a> This may seem like a strange point of view, but there are systems that work this way. International charges to credit-card accounts, for example, are normally cleared on a per-country basis, and the charges made in different countries are periodically reconciled. Thus the account balance may be different in different countries.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0055"></a><a href="#c3-fn-0055a">55</a> For distributed systems, this perspective was pursued by Lamport (1978), who showed how to use communication to establish “global clocks” that can be used to establish orderings on events in distributed systems.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0056"></a><a href="#c3-fn-0056a">56</a> Physicists sometimes adopt this view by introducing the “world lines” of particles as a device for reasoning about motion. We've also already mentioned (section 2.2.3) that this is the natural way to think about signal-processing systems. We will explore applications of streams to signal processing in section 3.5.3.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0057"></a><a href="#c3-fn-0057a">57</a> Assume that we have a predicate <span class="KeyTerm1">is_prime</span> (e.g., as in section 1.2.6) that tests for primality.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0058"></a><a href="#c3-fn-0058a">58</a> This should bother you. The fact that we are defining such similar functions for streams and lists indicates that we are missing some underlying abstraction. Unfortunately, in order to exploit this abstraction, we will need to exert finer control over the process of evaluation than we can at present. We will discuss this point further at the end of section 3.5.4. In section 4.2, we'll develop a framework that unifies lists and streams.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0059"></a><a href="#c3-fn-0059a">59</a> The numbers shown here do not really appear in the delayed expression. What actually appears is the original expression, in an environment in which the variables are bound to the appropriate numbers. For example, <span class="KeyTerm1">low + 1</span> with <span class="KeyTerm1">low</span> bound to 10,000 actually appears where <span class="KeyTerm1">10001</span> is shown.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0060"></a><a href="#c3-fn-0060a">60</a> There are many possible implementations of streams other than the one described in this section. Delayed evaluation, which is the key to making streams practical, was inherent in Algol 60's <i>call-by-name</i> parameter-passing method. The use of this mechanism to implement streams was first described by Landin (1965). Delayed evaluation for streams was introduced into Lisp by Friedman and Wise (1976). In their implementation, <span class="KeyTerm1">cons</span> (the Lisp equivalent of our <span class="KeyTerm1">pair</span> function) always delays evaluating its arguments, so that lists automatically behave as streams. The memoizing optimization is also known as <i>call-by-need</i>. The Algol community would refer to our original delayed objects as <i>call-by-name thunks</i> and to the optimized versions as <i>call-by-need thunks</i>.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0061"></a><a href="#c3-fn-0061a">61</a> Exercises such as 3.51 and 3.52 are valuable for testing our understanding of how delayed evaluation works. On the other hand, intermixing delayed evaluation with printing—and, even worse, with assignment—is extremely confusing, and instructors of courses on computer languages have traditionally tormented their students with examination questions such as the ones in this section. Needless to say, writing programs that depend on such subtleties is odious programming style. Part of the power of stream processing is that it lets us ignore the order in which events actually happen in our programs. Unfortunately, this is precisely what we cannot afford to do in the presence of assignment, which forces us to be concerned with time and change.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0062"></a><a href="#c3-fn-0062a">62</a> Eratosthenes, a third-century BCE Alexandrian Greek philosopher, is famous for giving the first accurate estimate of the circumference of the Earth, which he computed by observing shadows cast at noon on the day of the summer solstice. Eratosthenes's sieve method, although ancient, has formed the basis for special-purpose hardware “sieves” that, until the 1970s, were the most powerful tools in existence for locating large primes. Since then, however, these methods have been superseded by outgrowths of the probabilistic techniques discussed in section 1.2.6.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0063"></a><a href="#c3-fn-0063a">63</a> We have named these figures after Peter Henderson, who was the first person to show us diagrams of this sort as a way of thinking about stream processing.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0064"></a><a href="#c3-fn-0064a">64</a> This uses the function <span class="KeyTerm1">stream_map_2</span> from exercise 3.50.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0065"></a><a href="#c3-fn-0065a">65</a> This last point is very subtle and relies on the fact that <i>p<sub>n</sub></i><sub>+1</sub> ≤ <img alt="c3-fig-5002.jpg" src="../images/c3-fig-5002.jpg"/>. (Here, <i>p<sub>k</sub></i> denotes the <i>k</i>th prime.) Estimates such as these are very difficult to establish. The ancient proof by Euclid that there are an infinite number of primes shows that <i>p<sub>n</sub></i><sub>+1</sub> ≤ <i>p</i><sub>1</sub><i>p</i><sub>2</sub> ··· <i>p<sub>n</sub></i> + 1, and no substantially better result was proved until 1851, when the Russian mathematician P. L. Chebyshev established that <i>p<sub>n</sub></i><sub>+1</sub> ≤ 2<i>p<sub>n</sub></i> for all <i>n</i>. This result, originally conjectured in 1845, is known as <i>Bertrand's hypothesis</i>. A proof can be found in section 22.3 of Hardy and Wright 1960.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0066"></a><a href="#c3-fn-0066a">66</a> This exercise shows how call-by-need is closely related to ordinary memoization as described in exercise 3.27. In that exercise, we used assignment to explicitly construct a local table. Our call-by-need stream optimization effectively constructs such a table automatically, storing values in the previously forced parts of the stream.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0067"></a><a href="#c3-fn-0067a">67</a> As in section 2.2.3, we represent a pair of integers as a list rather than a pair.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0068"></a><a href="#c3-fn-0068a">68</a> See exercise 3.68 for some insight into why we chose this decomposition.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0069"></a><a href="#c3-fn-0069a">69</a> The precise statement of the required property on the order of combination is as follows: There should be a function <i>f</i> of two arguments such that the pair corresponding to element <i>i</i> of the first stream and element <i>j</i> of the second stream will appear as element number <i>f</i> (<i>i</i>, <i>j</i>) of the output stream. The trick of using <span class="KeyTerm1">interleave</span> to accomplish this was shown to us by David Turner, who employed it in the language KRC (Turner 1981).</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0070"></a><a href="#c3-fn-0070a">70</a> We will require that the weighting function be such that the weight of a pair increases as we move out along a row or down along a column of the array of pairs.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0071"></a><a href="#c3-fn-0071a">71</a> To quote from G. H. Hardy's obituary of Ramanujan (Hardy 1921): “It was Mr. Littlewood (I believe) who remarked that ‘every positive integer was one of his friends.’ I remember once going to see him when he was lying ill at Putney. I had ridden in taxi-cab No. 1729, and remarked that the number seemed to me a rather dull one, and that I hoped it was not an unfavorable omen. ‘No,’ he replied, ‘it is a very interesting number; it is the smallest number expressible as the sum of two cubes in two different ways.”’ The trick of using weighted pairs to generate the Ramanujan numbers was shown to us by Charles Leiserson.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0072"></a><a href="#c3-fn-0072a">72</a> To complete in reasonable time, this calculation requires the use of the memoization optimization from section 3.5.1 in <span class="KeyTerm1">integral</span> and in the function <span class="KeyTerm1">add_streams</span> used in <span class="KeyTerm1">integral</span> (using the function <span class="KeyTerm1">stream_map_2_optimized</span> as suggested in exercise 3.57).</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0073"></a><a href="#c3-fn-0073a">73</a> This is a small reflection, in JavaScript, of the difficulties that early statically typed languages such as Pascal had in coping with higher-order functions. In these languages, the programmer had to specify the data types of the arguments and the result of each function: number, logical value, sequence, and so on. Consequently, we could not express an abstraction such as “map a given function <span class="KeyTerm1">fun</span> over all the elements in a sequence” by a single higherorder function such as <span class="KeyTerm1">stream_map</span>. Rather, we would need a different mapping function for each different combination of argument and result data types that might be specified for a <span class="KeyTerm1">fun</span>. Maintaining a practical notion of “data type” in the presence of higher-order functions raises many difficult issues. One way of dealing with this problem is illustrated by the language ML (Gordon, Milner, and Wadsworth 1979), whose “parametrically polymorphic data types” include templates for higher-order transformations between data types. Moreover, data types for most functions in ML are never explicitly declared by the programmer. Instead, ML includes a <i>type-inferencing</i> mechanism that uses information in the environment to deduce the data types for newly defined functions. Today, statically typed programming languages have evolved to typically support some form of type inference as well as parametric polymorphism, with varying degrees of power. Haskell couples an expressive type system with powerful type inference.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0074"></a><a href="#c3-fn-0074a">74</a> Similarly in physics, when we observe a moving particle, we say that the position (state) of the particle is changing. However, from the perspective of the particle's world line in space-time there is no change involved.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0075"></a><a href="#c3-fn-0075a">75</a> John Backus, the inventor of Fortran, gave high visibility to functional programming when he was awarded the ACM Turing award in 1978. His acceptance speech (Backus 1978) strongly advocated the functional approach. A good overview of functional programming is given in Henderson 1980 and in Darlington, Henderson, and Turner 1982.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0076"></a><a href="#c3-fn-0076a">76</a> Observe that, for any two streams, there is in general more than one acceptable order of interleaving. Thus, technically, “merge” is a relation rather than a function—the answer is not a deterministic function of the inputs. We already mentioned (footnote 44) that nondeterminism is essential when dealing with concurrency. The merge relation illustrates the same essential nondeterminism, from the functional perspective. In section 4.3, we will look at nondeterminism from yet another point of view.</aside>
<aside class="noteEntry"><a id="c003_c3-fn-0077"></a><a href="#c3-fn-0077a">77</a> The object model approximates the world by dividing it into separate pieces. The functional model does not modularize along object boundaries. The object model is useful when the unshared state of the “objects” is much larger than the state that they share. An example of a place where the object viewpoint fails is quantum mechanics, where thinking of things as individual particles leads to paradoxes and confusions. Unifying the object view with the functional view may have little to do with programming, but rather with fundamental epistemological issues.</aside>
</section>
</section>
</body><body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<h1><a id="c004_c4-title-0001"></a><span class="chapterNumber">4</span><br/><span class="chapterTitle">Metalinguistic Abstraction</span></h1>
</header>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c004_c4-para-0001"></a>. . . It's in words that the magic is—Abracadabra, Open Sesame, and the rest—but the magic words in one story aren't magical in the next. The real magic is to understand which words work, and when, and for what; the trick is to learn the trick.</p>
<p class="quote-epigraphparafirst"><a id="c004_c4-para-0002"></a>. . . And those words are made from the letters of our alphabet: a couple-dozen squiggles we can draw with the pen. This is the key! And the treasure, too, if we can only get our hands on it! It's as if—as if the key to the treasure <i>is</i> the treasure!</p>
<p class="quote-epigraphsource">—John Barth, <i>Chimera</i></p></blockquote>
<p class="paraaftertitle"><a id="c004_c4-para-0003"></a>In our study of program design, we have seen that expert programmers control the complexity of their designs with the same general techniques used by designers of all complex systems. They combine primitive elements to form compound objects, they abstract compound objects to form higher-level building blocks, and they preserve modularity by adopting appropriate large-scale views of system structure. In illustrating these techniques, we have used JavaScript as a language for describing processes and for constructing computational data objects and processes to model complex phenomena in the real world. However, as we confront increasingly complex problems, we will find that JavaScript, or indeed any fixed programming language, is not sufficient for our needs. We must constantly turn to new languages in order to express our ideas more effectively. Establishing new languages is a powerful strategy for controlling complexity in engineering design; we can often enhance our ability to deal with a complex problem by adopting a new language that enables us to describe (and hence to think about) the problem in a different way, using primitives, means of combination, and means of abstraction that are particularly well suited to the problem at hand.<a id="c004_c4-fn-0001a"></a><a href="#c4-fn-0001"><sup>1</sup></a></p>
<p><a id="c004_c4-para-0004"></a>Programming is endowed with a multitude of languages. There are physical languages, such as the machine languages for particular computers. These languages are concerned with the representation of data and control in terms of individual bits of storage and primitive machine instructions. The machine-language programmer is concerned with using the given hardware to erect systems and utilities for the efficient implementation of resource-limited computations. High-level languages, erected on a machine-language substrate, hide concerns about the representation of data as collections of bits and the representation of programs as sequences of primitive instructions. These languages have means of combination and abstraction, such as function declaration, that are appropriate to the larger-scale organization of systems.</p>
<p><a id="c004_c4-para-0005"></a><i>Metalinguistic abstraction</i>—establishing new languages—plays an important role in all branches of engineering design. It is particularly important to computer programming, because in programming not only can we formulate new languages but we can also implement these languages by constructing evaluators. An <i>evaluator</i> (or <i>interpreter</i>) for a programming language is a function that, when applied to a statement or expression of the language, performs the actions required to evaluate that statement or expression. It is no exaggeration to regard this as the most fundamental idea in programming:</p>
<blockquote class="quote">
<p class="quoteparafirst"><a id="c004_c4-para-0006"></a>The evaluator, which determines the meaning of statements and expressions in a programming language, is just another program.</p></blockquote>
<p class="paracontinue"><a id="c004_c4-para-0007"></a>To appreciate this point is to change our images of ourselves as programmers. We come to see ourselves as designers of languages, rather than only users of languages designed by others.</p>
<p><a id="c004_c4-para-0008"></a>In fact, we can regard almost any program as the evaluator for some language. For instance, the polynomial manipulation system of section 2.5.3 embodies the rules of polynomial arithmetic and implements them in terms of operations on list-structured data. If we augment this system with functions to read and print polynomial expressions, we have the core of a special-purpose language for dealing with problems in symbolic mathematics. The digital-logic simulator of section 3.3.4 and the constraint propagator of section 3.3.5 are legitimate languages in their own right, each with its own primitives, means of combination, and means of abstraction. Seen from this perspective, the technology for coping with large-scale computer systems merges with the technology for building new computer languages, and computer science itself becomes no more (and no less) than the discipline of constructing appropriate descriptive languages.</p>
<p><a id="c004_c4-para-0009"></a>We now embark on a tour of the technology by which languages are established in terms of other languages. In this chapter we shall use JavaScript as a base, implementing evaluators as JavaScript functions. We will take the first step in understanding how languages are implemented by building an evaluator for JavaScript itself. The language implemented by our evaluator will be a subset of JavaScript. Although the evaluator described in this chapter is written for a particular subset of JavaScript, it contains the essential structure of an evaluator for any language designed for writing programs for a sequential machine. (In fact, most language processors contain, deep within them, a little evaluator.) The evaluator has been simplified for the purposes of illustration and discussion, and some features have been left out that would be important to include in a production-quality JavaScript system. Nevertheless, this simple evaluator is adequate to execute most of the programs in this book.<a id="c004_c4-fn-0002a"></a><a href="#c4-fn-0002"><sup>2</sup></a></p>
<p><a id="c004_c4-para-0010"></a>An important advantage of making the evaluator accessible as a JavaScript program is that we can implement alternative evaluation rules by describing these as modifications to the evaluator program. One place where we can use this power to good effect is to gain extra control over the ways in which computational models embody the notion of time, which was so central to the discussion in chapter 3. There, we mitigated some of the complexities of state and assignment by using streams to decouple the representation of time in the world from time in the computer. Our stream programs, however, were sometimes cumbersome, because they were constrained by the applicative-order evaluation of JavaScript. In section 4.2, we'll change the underlying language to provide for a more elegant approach, by modifying the evaluator to provide for <i>normal-order evaluation</i>.</p>
<p><a id="c004_c4-para-0011"></a>Section 4.3 implements a more ambitious linguistic change, whereby statements and expressions have many values, rather than just a single value. In this language of <i>nondeterministic computing</i>, it is natural to express processes that generate all possible values for statements and expressions and then search for those values that satisfy certain constraints. In terms of models of computation and time, this is like having time branch into a set of “possible futures” and then searching for appropriate time lines. With our nondeterministic evaluator, keeping track of multiple values and performing searches are handled automatically by the underlying mechanism of the language.</p>
<p><a id="c004_c4-para-0012"></a>In section 4.4 we implement a <i>logic-programming</i> language in which knowledge is expressed in terms of relations, rather than in terms of computations with inputs and outputs. Even though this makes the language drastically different from JavaScript, or indeed from any conventional language, we will see that the logic-programming evaluator shares the essential structure of the JavaScript evaluator.</p>
<section><a id="c004_c4-title-0002"></a>
<section>
<h2><a id="c004_c4-sec-0002"></a><span>4.1</span> <a id="c004_c4-title-0003"></a>The Metacircular Evaluator</h2>
<p class="paraaftertitle"><a id="c004_c4-para-0013"></a>Our evaluator for JavaScript will be implemented as a JavaScript program. It may seem circular to think about evaluating JavaScript programs using an evaluator that is itself implemented in JavaScript. However, evaluation is a process, so it is appropriate to describe the evaluation process using JavaScript, which, after all, is our tool for describing processes.<a id="c004_c4-fn-0003a"></a><a href="#c4-fn-0003"><sup>3</sup></a> An evaluator that is written in the same language that it evaluates is said to be <i>metacircular</i>.</p>
<p><a id="c004_c4-para-0014"></a>The metacircular evaluator is essentially a JavaScript formulation of the environment model of evaluation described in section 3.2. Recall that the model specifies the evaluation of function application in two basic steps:</p>
<ol class="BS_NumberList1">
<li><a id="c004_c4-li-0001"></a><span>1. </span>To evaluate a function application, evaluate the subexpressions and then apply the value of the function subexpression to the values of the argument subexpressions.</li>
<li><a id="c004_c4-li-0002"></a><span>2. </span>To apply a compound function to a set of arguments, evaluate the body of the function in a new environment. To construct this environment, extend the environment part of the function object by a frame in which the parameters of the function are bound to the arguments to which the function is applied.</li>
</ol>
<p><a id="c004_c4-para-0017"></a>These two rules describe the essence of the evaluation process, a basic cycle in which statements and expressions to be evaluated in environments are reduced to functions to be applied to arguments, which in turn are reduced to new statements and expressions to be evaluated in new environments, and so on, until we get down to names, whose values are looked up in the environment, and to operators and primitive functions, which are applied directly (see <a id="c004_c4-fig-0001a"></a><a href="#c4-fig-0001">figure 4.1</a>).<a id="c004_c4-fn-0004a"></a><a href="#c4-fn-0004"><sup>4</sup></a> This evaluation cycle will be embodied by the interplay between the two critical functions in the evaluator, <span class="KeyTerm1">evaluate</span> and <span class="KeyTerm1">apply</span>, which are described in section 4.1.1 (see <a href="#c4-fig-0001">figure 4.1</a>).</p>
<figure id="c004_c4-fig-0001"><img alt="c4-fig-0001.jpg" src="../images/c4-fig-0001.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0001a">Figure 4.1</a></span> <a id="c004_c4-para-0018"></a>The <span class="KeyTerm1">evaluate</span>–<span class="KeyTerm1">apply</span> cycle exposes the essence of a computer language.</p></figcaption></figure>
<p><a id="c004_c4-para-0019"></a>The implementation of the evaluator will depend upon functions that define the <i>syntax</i> of the statements and expressions to be evaluated. We will use data abstraction to make the evaluator independent of the representation of the language. For example, rather than committing to a choice that an assignment is to be represented by a string beginning with a name followed by <span class="KeyTerm1">=</span>, we use an abstract predicate <span class="KeyTerm1">is_assignment</span> to test for an assignment, and we use abstract selectors <span class="KeyTerm1">assignment_symbol</span> and <span class="KeyTerm1">assignment_value_expression</span> to access the parts of an assignment. The data abstraction layers presented in section 4.1.2 will allow the evaluator to remain independent of concrete syntactic issues, such as the keywords of the interpreted language, and of the choice of data structures that represent the program components. There are also operations, described in section 4.1.3, that specify the representation of functions and environments. For example, <span class="KeyTerm1">make_function</span> constructs compound functions, <span class="KeyTerm1">lookup_symbol_value</span> accesses the values of names, and <span class="KeyTerm1">apply_primitive_function</span> applies a primitive function to a given list of arguments.</p>
<section>
<h3><a id="c004_c4-sec-0003"></a><span>4.1.1</span> <a id="c004_c4-title-0004"></a>The Core of the Evaluator</h3>
<p class="paraaftertitle"><a id="c004_c4-para-0020"></a>The evaluation process can be described as the interplay between two functions: <span class="KeyTerm1">evaluate</span> and <span class="KeyTerm1">apply</span>.</p>
<section>
<h5><a id="c004_c4-sec-0004"></a><a id="c004_c4-title-0005"></a>The function <span class="KeyTerm1">evaluate</span></h5>
<p class="paraaftertitle"><a id="c004_c4-para-0021"></a>The function <span class="KeyTerm1">evaluate</span> takes as arguments a program <i>component</i>—a statement or expression<a id="c004_c4-fn-0005a"></a><a href="#c4-fn-0005"><sup>5</sup></a>—and an environment. It classifies the component and directs its evaluation. The function <span class="KeyTerm1">evaluate</span> is structured as a case analysis of the syntactic type of the component to be evaluated. In order to keep the function general, we express the determination of the type of a component abstractly, making no commitment to any particular representation for the various types of components. Each type of component has a <i>syntax predicate</i> that tests for it and an abstract means for selecting its parts. This <i>abstract syntax</i> makes it easy to see how we can change the syntax of the language by using the same evaluator, but with a different collection of syntax functions.</p>
<section>
<h6><a id="c004_c4-sec-0005"></a><a id="c004_c4-title-0006"></a>Primitive expressions</h6>
<ul style="list-style-type:disc">
<li>For literal expressions, such as numbers, <span class="KeyTerm1">evaluate</span> returns their value.</li>
<li>The function <span class="KeyTerm1">evaluate</span> must look up names in the environment to find their values.</li>
</ul>
</section>
<section>
<h6><a id="c004_c4-sec-0006"></a><a id="c004_c4-title-0007"></a>Combinations</h6>
<ul style="list-style-type:disc">
<li>For a function application, <span class="KeyTerm1">evaluate</span> must recursively evaluate the function expression and the argument expressions of the application. The resulting function and arguments are passed to <span class="KeyTerm1">apply</span>, which handles the actual function application.</li>
<li>An operator combination is transformed into a function application and then evaluated.</li>
</ul>
</section>
<section>
<h6><a id="c004_c4-sec-0007"></a><a id="c004_c4-title-0008"></a>Syntactic forms</h6>
<ul style="list-style-type:disc">
<li>A conditional expression or statement requires special processing of its parts, so as to evaluate the consequent if the predicate is true, and otherwise to evaluate the alternative.</li>
<li>A lambda expression must be transformed into an applicable function by packaging together the parameters and body specified by the lambda expression with the environment of the evaluation.</li>
<li>A sequence of statements requires evaluating its components in the order in which they appear.</li>
<li>A block requires evaluating its body in a new environment that reflects all names declared within the block.</li>
<li>A return statement must produce a value that becomes the result of the function call that gave rise to the evaluation of the return statement.</li>
<li>A function declaration is transformed into a constant declaration and then evaluated.</li>
<li>A constant or variable declaration or an assignment must call <span class="KeyTerm1">evaluate</span> recursively to compute the new value to be associated with the name being declared or assigned. The environment must be modified to reflect the new value of the name.</li>
</ul>
<p class="paraaftertitle"><a id="c004_c4-para-0033"></a>Here is the declaration of <span class="KeyTerm1">evaluate</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0034"></a><b>function</b> evaluate(component, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0035"></a> <b>return</b> is_literal(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0036"></a>           ? literal_value(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0037"></a>           : is_name(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0038"></a>           ? lookup_symbol_value(symbol_of_name(component), env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0039"></a>           : is_application(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0040"></a>           ? apply(evaluate(function_expression(component), env),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0041"></a>                   list_of_values(arg_expressions(component), env))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0042"></a>           : is_operator_combination(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0043"></a>           ? evaluate(operator_combination_to_application(component), env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0044"></a>           : is_conditional(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0045"></a>           ? eval_conditional(component, env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0046"></a>           : is_lambda_expression(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0047"></a>           ? make_function(lambda_parameter_symbols(component),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0048"></a>                           lambda_body(component), env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0049"></a>           : is_sequence(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0050"></a>           ? eval_sequence(sequence_statements(component), env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0051"></a>           : is_block(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0052"></a>           ? eval_block(component, env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0053"></a>           : is_return_statement(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0054"></a>           ? eval_return_statement(component, env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0055"></a>           : is_function_declaration(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0056"></a>           ? evaluate(function_decl_to_constant_decl(component), env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0057"></a>           : is_declaration(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0058"></a>           ? eval_declaration(component, env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0059"></a>           : is_assignment(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0060"></a>           ? eval_assignment(component, env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0061"></a>           : error(component, "unknown syntax – evaluate");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0062"></a>}</p>
<p><a id="c004_c4-para-0063"></a>For clarity, <span class="KeyTerm1">evaluate</span> has been implemented as a case analysis using conditional expressions. The disadvantage of this is that our function handles only a few distinguishable types of statements and expressions, and no new ones can be defined without editing the declaration of <span class="KeyTerm1">evaluate</span>. In most interpreter implementations, dispatching on the type of a component is done in a data-directed style. This allows a user to add new types of components that <span class="KeyTerm1">evaluate</span> can distinguish, without modifying the declaration of <span class="KeyTerm1">evaluate</span> itself. (See exercise 4.3.)</p>
<p><a id="c004_c4-para-0064"></a>The representation of names is handled by the syntax abstractions. Internally, the evaluator uses strings to represent names, and we refer to such strings as <i>symbols</i>. The function <span class="KeyTerm1">symbol_of_name</span> used in <span class="KeyTerm1">evaluate</span> extracts from a name the symbol by which it is represented.</p>
</section>
</section>
<section>
<h5><a id="c004_c4-sec-0008"></a><a id="c004_c4-title-0009"></a>Apply</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0065"></a>The function <span class="KeyTerm1">apply</span> takes two arguments, a function and a list of arguments to which the function should be applied. The function <span class="KeyTerm1">apply</span> classifies functions into two kinds: It calls <span class="KeyTerm1">apply_primitive_function</span> to apply primitives; it applies compound functions by evaluating the block that makes up the body of the function. The environment for the evaluation of the body of a compound function is constructed by extending the base environment carried by the function to include a frame that binds the parameters of the function to the arguments to which the function is to be applied. Here is the declaration of <span class="KeyTerm1">apply</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0066"></a><b>function</b> apply(fun, args) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0067"></a> <b>if</b> (is_primitive_function(fun)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0068"></a> <b>return</b> apply_primitive_function(fun, args);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0069"></a>    } <b>else if</b> (is_compound_function(fun)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0070"></a> <b>const</b> result = evaluate(function_body(fun),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0071"></a>                               extend_environment(</p>
<p class="Sp-text-1"><a id="c004_c4-para-0072"></a>                                   function_parameters(fun),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0073"></a>                                   args,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0074"></a>                                   function_environment(fun)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0075"></a> <b>return</b> is_return_value(result)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0076"></a>               ? return_value_content(result)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0077"></a>               : undefined;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0078"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0079"></a>        error(fun, "unknown function type – apply");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0080"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0081"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0082"></a>In order to return a value, a JavaScript function needs to evaluate a return statement. If a function terminates without evaluating a return statement, the value <span class="KeyTerm1">undefined</span> is returned. To distinguish the two cases, the evaluation of a return statement will wrap the result of evaluating its return expression into a <i>return value</i>. If the evaluation of the function body yields such a return value, the content of the return value is retrieved; otherwise the value <span class="KeyTerm1">undefined</span> is returned.<a id="c004_c4-fn-0006a"></a><a href="#c4-fn-0006"><sup>6</sup></a></p>
</section>
<section>
<h5><a id="c004_c4-sec-0009"></a><a id="c004_c4-title-0010"></a>Function arguments</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0083"></a>When <span class="KeyTerm1">evaluate</span> processes a function application, it uses <span class="KeyTerm1">list_of_values</span> to produce the list of arguments to which the function is to be applied. The function <span class="KeyTerm1">list_of_values</span> takes as an argument the argument expressions of the application. It evaluates each argument expression and returns a list of the corresponding values:<a id="c004_c4-fn-0007a"></a><a href="#c4-fn-0007"><sup>7</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0084"></a><b>function</b> list_of_values(exps, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0085"></a> <b>return</b> map(arg =&gt; evaluate(arg, env), exps);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0086"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0010"></a><a id="c004_c4-title-0011"></a>Conditionals</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0087"></a>The function <span class="KeyTerm1">eval_conditional</span> evaluates the predicate part of a conditional component in the given environment. If the result is true, the consequent is evaluated, otherwise the alternative is evaluated:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0088"></a><b>function</b> eval_conditional(component, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0089"></a> <b>return</b> is_truthy(evaluate(conditional_predicate(component), env))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0090"></a>           ? evaluate(conditional_consequent(component), env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0091"></a>           : evaluate(conditional_alternative(component), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0092"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0093"></a>Note that the evaluator does not need to distinguish between conditional expressions and conditional statements.</p>
<p><a id="c004_c4-para-0094"></a>The use of <span class="KeyTerm1">is_truthy</span> in <span class="KeyTerm1">eval_conditional</span> highlights the issue of the connection between an implemented language and an implementation language. The <span class="KeyTerm1">conditional_predicate</span> is evaluated in the language being implemented and thus yields a value in that language. The interpreter predicate <span class="KeyTerm1">is_truthy</span> translates that value into a value that can be tested by the conditional expression in the implementation language: The metacircular representation of truth might not be the same as that of the underlying JavaScript.<a id="c004_c4-fn-0008a"></a><a href="#c4-fn-0008"><sup>8</sup></a></p>
</section>
<section>
<h5><a id="c004_c4-sec-0011"></a><a id="c004_c4-title-0012"></a>Sequences</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0095"></a>The function <span class="KeyTerm1">eval_sequence</span> is used by <span class="KeyTerm1">evaluate</span> to evaluate a sequence of statements at the top level or in a block. It takes as arguments a sequence of statements and an environment, and evaluates the statements in the order in which they occur. The value returned is the value of the final statement, except that if the evaluation of any statement in the sequence yields a return value, that value is returned and the subsequent statements are ignored.<a id="c004_c4-fn-0009a"></a><a href="#c4-fn-0009"><sup>9</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0103"></a><b>function</b> eval_sequence(stmts, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0104"></a> <b>if</b> (is_empty_sequence(stmts)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0105"></a> <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0106"></a>    } <b>else if</b> (is_last_statement(stmts)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0107"></a> <b>return</b> evaluate(first_statement(stmts), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0108"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0109"></a> <b>const</b> first_stmt_value =</p>
<p class="Sp-text-1"><a id="c004_c4-para-0110"></a>            evaluate(first_statement(stmts), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0111"></a> <b>if</b> (is_return_value(first_stmt_value)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0112"></a> <b>return</b> first_stmt_value;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0113"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0114"></a> <b>return</b> eval_sequence(rest_statements(stmts), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0115"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0116"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0117"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0012"></a><a id="c004_c4-title-0013"></a>Blocks</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0118"></a>The function <span class="KeyTerm1">eval_block</span> handles blocks. The variables and constants (including functions) declared in the block have the whole block as their scope and thus are “scanned out” before the body of the block is evaluated. The body of the block is evaluated with respect to an environment that extends the current environment by a frame that binds each local name to a special value, <span class="KeyTerm1">"*unassigned*"</span>. This string serves as a placeholder, before the evaluation of the declaration assigns the name its proper value. An attempt to access the value of the name before its declaration is evaluated leads to an error at run time (see exercise 4.12), as stated in footnote 56 in chapter 1.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0119"></a><b>function</b> eval_block(component, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0120"></a> <b>const</b> body = block_body(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0121"></a> <b>const</b> locals = scan_out_declarations(body);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0122"></a> <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0123"></a> <b>return</b> evaluate(body, extend_environment(locals,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0124"></a>                                             unassigneds,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0125"></a>                                             env));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0126"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0127"></a><b>function</b> list_of_unassigned(symbols) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0128"></a> <b>return</b> map(symbol =&gt; "*unassigned*", symbols);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0129"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0130"></a>The function <span class="KeyTerm1">scan_out_declarations</span> collects a list of all symbols representing names declared in the body. It uses <span class="KeyTerm1">declaration_symbol</span> to retrieve the symbol that represents the name from the declaration statements it finds.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0131"></a><b>function</b> scan_out_declarations(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0132"></a> <b>return</b> is_sequence(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0133"></a>           ? accumulate(append,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0134"></a> <b>null</b>,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0135"></a>                        map(scan_out_declarations,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0136"></a>                            sequence_statements(component)))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0137"></a>           : is_declaration(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0138"></a>           ? list(declaration_symbol(component))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0139"></a>           : <b>null</b>;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0140"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0141"></a>We ignore declarations that are nested in another block, because the evaluation of that block will take care of them. The function <span class="KeyTerm1">scan_out_declarations</span> looks for declarations only in sequences because declarations in conditional statements, function declarations, and lambda expressions are always in a nested block.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0013"></a><a id="c004_c4-title-0014"></a>Return statements</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0142"></a>The function <span class="KeyTerm1">eval_return_statement</span> is used to evaluate return statements. As seen in <span class="KeyTerm1">apply</span> and the evaluation of sequences, the result of evaluation of a return statement needs to be identifiable so that the evaluation of a function body can return immediately, even if there are statements after the return statement. For this purpose, the evaluation of a return statement wraps the result of evaluating the return expression in a return value object.<a id="c004_c4-fn-0010a"></a><a href="#c4-fn-0010"><sup>10</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0143"></a><b>function</b> eval_return_statement(component, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0144"></a> <b>return</b> make_return_value(evaluate(return_expression(component),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0145"></a>                                      env));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0146"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0014"></a><a id="c004_c4-title-0015"></a>Assignments and declarations</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0147"></a>The function <span class="KeyTerm1">eval_assignment</span> handles assignments to names. (To simplify the presentation of our evaluator, we are allowing assignment not just to variables but also—erroneously—to constants. Exercise 4.11 explains how we could distinguish constants from variables and prevent assignment to constants.) The function <span class="KeyTerm1">eval_assignment</span> calls <span class="KeyTerm1">evaluate</span> on the value expression to find the value to be assigned and calls <span class="KeyTerm1">assignment_symbol</span> to retrieve the symbol that represents the name from the assignment. The function <span class="KeyTerm1">eval_assignment</span> transmits the symbol and the value to <span class="KeyTerm1">assign_symbol_value</span> to be installed in the designated environment. The evaluation of an assignment returns the value that was assigned.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0148"></a><b>function</b> eval_assignment(component, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0149"></a> <b>const</b> value = evaluate(assignment_value_expression(component),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0150"></a>                           env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0151"></a>    assign_symbol_value(assignment_symbol(component), value, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0152"></a> <b>return</b> value;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0153"></a>}</p>
<p><a id="c004_c4-para-0154"></a>Constant and variable declarations are both recognized by the <span class="KeyTerm1">is_declaration</span> syntax predicate. They are treated in a manner similar to assignments, because <span class="KeyTerm1">eval_block</span> has already bound their symbols to <span class="KeyTerm1">"*unassigned*"</span> in the current environment. Their evaluation replaces <span class="KeyTerm1">"*unassigned*"</span> with the result of evaluating the value expression.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0155"></a><b>function</b> eval_declaration(component, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0156"></a>    assign_symbol_value(</p>
<p class="Sp-text-1"><a id="c004_c4-para-0157"></a>        declaration_symbol(component),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0158"></a>        evaluate(declaration_value_expression(component), env), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0159"></a> <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0160"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0161"></a>The result of evaluating the body of a function is determined by return statements, and therefore the return value <span class="KeyTerm1">undefined</span> in <span class="KeyTerm1">eval_declaration</span> only matters when the declaration occurs at the top level, outside of any function body. Here we use the return value <span class="KeyTerm1">undefined</span> to simplify the presentation; exercise 4.8 describes the real result of evaluating top-level components in JavaScript.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0015"></a><a id="c004_c4-title-0016"></a>Exercise 4.1</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0162"></a>Notice that we cannot tell whether the metacircular evaluator evaluates argument expressions from left to right or from right to left. Its evaluation order is inherited from the underlying JavaScript: If the arguments to <span class="KeyTerm1">pair</span> in <span class="KeyTerm1">map</span> are evaluated from left to right, then <span class="KeyTerm1">list_of_values</span> will evaluate argument expressions from left to right; and if the arguments to <span class="KeyTerm1">pair</span> are evaluated from right to left, then <span class="KeyTerm1">list_of_values</span> will evaluate argument expressions from right to left.</p>
<p><a id="c004_c4-para-0163"></a>Write a version of <span class="KeyTerm1">list_of_values</span> that evaluates argument expressions from left to right regardless of the order of evaluation in the underlying JavaScript. Also write a version of <span class="KeyTerm1">list_of_values</span> that evaluates argument expressions from right to left.</p>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0016"></a><span>4.1.2</span> <a id="c004_c4-title-0017"></a>Representing Components</h3>
<p class="paraaftertitle"><a id="c004_c4-para-0164"></a>Programmers write programs as text, i.e. sequences of characters, entered in a programming environment or a text editor. To run our evaluator, we need to start with a representation of this program text as a JavaScript value. In section 2.3.1 we introduced strings to represent text. We would like to evaluate programs such as <span class="KeyTerm1">"const size = 2; 5 * size;"</span> from section 1.1.2. Unfortunately, such program text does not provide enough structure to the evaluator. In this example, the program parts <span class="KeyTerm1">"size = 2"</span> and <span class="KeyTerm1">"5 * size"</span> look similar, but carry very different meanings. Abstract syntax functions such as <span class="KeyTerm1">declaration_value_expression</span> would be difficult and error-prone to implement by examining the program text. In this section, we therefore introduce a function <span class="KeyTerm1">parse</span> that translates program text to a <i>taggedlist representation</i>, reminiscent of the tagged data of section 2.4.2. For example, the application of <span class="KeyTerm1">parse</span> to the program string above produces a data structure that reflects the structure of the program: a sequence consisting of a constant declaration associating the name <span class="KeyTerm1">size</span> with the value 2 and a multiplication.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0165"></a>parse("const size = 2; 5 * size;");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0166"></a><i>list("sequence",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-0167"></a> <i>list(list("constant_declaration",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-0168"></a> <i>list("name", "size"), list("literal", 2)),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-0169"></a> <i>list("binary_operator_combination", "*",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-0170"></a> <i>list("literal", 5), list("name", "size"))))</i></p>
<p class="paracontinue"><a id="c004_c4-para-0171"></a>The syntax functions used by the evaluator access the tagged-list representation produced by <span class="KeyTerm1">parse</span>.</p>
<p><a id="c004_c4-para-0172"></a>The evaluator is reminiscent of the symbolic differentiation program discussed in section 2.3.2. Both programs operate on symbolic data. In both programs, the result of operating on an object is determined by operating recursively on the pieces of the object and combining the results in a way that depends on the type of the object. In both programs we used data abstraction to decouple the general rules of operation from the details of how the objects are represented. In the differentiation program this meant that the same differentiation function could deal with algebraic expressions in prefix form, in infix form, or in some other form. For the evaluator, this means that the syntax of the language being evaluated is determined solely by <span class="KeyTerm1">parse</span> and the functions that classify and extract pieces of the tagged lists produced by <span class="KeyTerm1">parse</span>.</p>
<p><a id="c004_c4-para-0173"></a><a id="c004_c4-fig-0002a"></a><a href="#c4-fig-0002">Figure 4.2</a> depicts the abstraction barrier formed by the syntax predicates and selectors, which interface the evaluator to the tagged-list representation of programs, which in turn is separated from the string representation by <span class="KeyTerm1">parse</span>. Below we describe the parsing of program components and list the corresponding syntax predicates and selectors, as well as constructors if they are needed.</p>
<figure id="c004_c4-fig-0002"><img alt="c4-fig-0002.jpg" src="../images/c4-fig-0002.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0002a">Figure 4.2</a></span> <a id="c004_c4-para-0174"></a>Syntax abstraction in the evaluator.</p></figcaption></figure>
<section>
<h5><a id="c004_c4-sec-0017"></a><a id="c004_c4-title-0018"></a>Literal expression</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0175"></a>Literal expressions are parsed into tagged lists with tag <span class="KeyTerm1">"literal"</span> and the actual value.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0176"></a>《<span class="KeyTerm2"><i>literal</i>-<i>expression</i></span> 》 = list("literal", <span class="KeyTerm2"><i>value</i></span>)</p>
<p class="paracontinue"><a id="c004_c4-para-0177"></a>where <i>value</i> is the JavaScript value represented by the <i>literal</i>-<i>expression</i> string. Here 《 <i>literal</i>-<i>expression</i> 》 denotes the result of parsing the string <i>literal</i>-<i>expression</i>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0178"></a>parse("1;");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0179"></a><i>list("literal", 1)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-0180"></a>parse("'hello world';");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0181"></a><i>list("literal", "hello world")</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-0182"></a>parse("null;");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0183"></a><i>list("literal", null)</i></p>
<p class="paracontinue"><a id="c004_c4-para-0184"></a>The syntax predicate for literal expressions is <span class="KeyTerm1">is_literal</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0185"></a><b>function</b> is_literal(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0186"></a> <b>return</b> is_tagged_list(component, "literal");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0187"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0188"></a>It is defined in terms of the function <span class="KeyTerm1">is_tagged_list</span>, which identifies lists that begin with a designated string:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0189"></a><b>function</b> is_tagged_list(component, the_tag) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0190"></a> <b>return</b> is_pair(component) &amp;&amp; head(component) === the_tag;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0191"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0192"></a>The second element of the list that results from parsing a literal expression is its actual JavaScript value. The selector for retrieving the value is <span class="KeyTerm1">literal_value</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0193"></a><b>function</b> literal_value(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0194"></a> <b>return</b> head(tail(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0195"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-0196"></a>literal_value(parse("null;"));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0197"></a><i>null</i></p>
<p class="paracontinue"><a id="c004_c4-para-0198"></a>In the rest of this section, we just list the syntax predicates and selectors, and omit their declarations if they just access the obvious list elements.</p>
<p><a id="c004_c4-para-0199"></a>We provide a constructor for literals, which will come in handy:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0200"></a><b>function</b> make_literal(value) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0201"></a> <b>return</b> list("literal", value);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0202"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0018"></a><a id="c004_c4-title-0019"></a>Names</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0203"></a>The tagged-list representation for names includes the tag <span class="KeyTerm1">"name"</span> as first element and the string representing the name as second element.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0204"></a>《 <span class="KeyTerm2"><i>name</i></span> 》 = list("name", <span class="KeyTerm2"><i>symbol</i></span>)</p>
<p class="paracontinue"><a id="c004_c4-para-0205"></a>where <i>symbol</i> is a string that contains the characters that make up the <i>name</i> as written in the program. The syntax predicate for names is <span class="KeyTerm1">is_name</span>. The symbol is accessed using the selector <span class="KeyTerm1">symbol_of_name</span>. We provide a constructor for names, to be used by <span class="KeyTerm1">operator_combination_to_application</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0206"></a><b>function</b> make_name(symbol) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0207"></a> <b>return</b> list("name", symbol);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0208"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0019"></a><a id="c004_c4-title-0020"></a>Expression statements</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0209"></a>We do not need to distinguish between expressions and expression statements. Consequently, <span class="KeyTerm1">parse</span> can ignore the difference between the two kinds of components:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0210"></a>《 <span class="KeyTerm2"><i>expression</i></span>; 》 = 《 <span class="KeyTerm2"><i>expression</i></span> 》</p>
</section>
<section>
<h5><a id="c004_c4-sec-0020"></a><a id="c004_c4-title-0021"></a>Function applications</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0211"></a>Function applications are parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0212"></a>《 <span class="KeyTerm2"><i>fun</i>-<i>expr</i>(<i>arg</i>-<i>expr</i><sub>1</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>arg</i>-<i>expr<sub>n</sub></i>)</span> 》=</p>
<p class="Sp-text-1"><a id="c004_c4-para-0213"></a>     list("application",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0214"></a>          《 <span class="KeyTerm2"><i>fun</i>-<i>expr</i></span> 》,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0215"></a>          list(《 <span class="KeyTerm2"><i>arg</i>-<i>expr</i><sub>1</sub></span> 》, <i>. . .</i>, 《 <span class="KeyTerm2"><i>arg</i>-<i>expr<sub>n</sub></i></span> 》))</p>
<p class="paracontinue"><a id="c004_c4-para-0216"></a>We declare <span class="KeyTerm1">is_application</span> as the syntax predicate and <span class="KeyTerm1">function_expression</span> and <span class="KeyTerm1">arg_expressions</span> as the selectors. We add a constructor for function applications, to be used by <span class="KeyTerm1">operator_combination_to_application</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0217"></a><b>function</b> make_application(function_expression, argument_expressions) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0218"></a> <b>return</b> list("application",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0219"></a>                function_expression, argument_expressions);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0220"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0021"></a><a id="c004_c4-title-0022"></a>Conditionals</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0221"></a>Conditional expressions are parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0222"></a>《 <span class="KeyTerm2"><i>predicate</i></span> ? <span class="KeyTerm2"><i>consequent</i>-<i>expression</i></span> : <span class="KeyTerm2"><i>alternative</i>-<i>expression</i></span> 》=</p>
<p class="Sp-text-1"><a id="c004_c4-para-0223"></a>         list("conditional_expression",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0224"></a>              《 <i>predicate</i> 》,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0225"></a>              《 <i>consequent</i>-<i>expression</i> 》,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0226"></a>              《 <i>alternative</i>-<i>expression</i> 》)</p>
<p class="paracontinue"><a id="c004_c4-para-0227"></a>Similarly, conditional statements are parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0228"></a>《 <b>if</b> (<span class="KeyTerm2"><i>predicate</i></span>) <span class="KeyTerm2"><i>consequent</i>-<i>block</i></span> <b>else</b> <span class="KeyTerm2"><i>alternative</i>-<i>block</i></span> 》=</p>
<p class="Sp-text-1"><a id="c004_c4-para-0229"></a>         list("conditional_statement",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0230"></a>              《 <i>predicate</i> 》,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0231"></a>              《 <i>consequent</i>-<i>block</i> 》,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0232"></a>              《 <i>alternative</i>-<i>block</i> 》)</p>
<p class="paracontinue"><a id="c004_c4-para-0233"></a>The syntax predicate <span class="KeyTerm1">is_conditional</span> returns true for both kinds of conditionals, and the selectors <span class="KeyTerm1">conditional_predicate</span>, <span class="KeyTerm1">conditional_consequent</span>, and <span class="KeyTerm1">conditional_alternative</span> can be applied to both kinds.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0022"></a><a id="c004_c4-title-0023"></a>Lambda expressions</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0234"></a>A lambda expression whose body is an expression is parsed as if the body consisted of a block containing a single return statement whose return expression is the body of the lambda expression.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0235"></a>《 (<span class="KeyTerm2"><i>name</i><sub>1</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>name<sub>n</sub></i></span>) =&gt; <span class="KeyTerm2"><i>expression</i></span> 》 =</p>
<p class="Sp-text-1"><a id="c004_c4-para-0236"></a>    《 (<span class="KeyTerm2"><i>name</i><sub>1</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>name<sub>n</sub></i></span>) =&gt; { <b>return</b> <span class="KeyTerm2"><i>expression</i></span> ; } 》</p>
<p><a id="c004_c4-para-0237"></a>A lambda expression whose body is a block is parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0238"></a>《 (<span class="KeyTerm2"><i>name</i><sub>1</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>name<sub>n</sub></i></span>) =&gt; <i>block</i> 》=</p>
<p class="Sp-text-1"><a id="c004_c4-para-0239"></a>    list("lambda_expression",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0240"></a>     list(《 <span class="KeyTerm2"><i>name</i><sub>1</sub></span> 》, <i>. . .</i>, 《 <span class="KeyTerm2"><i>name<sub>n</sub></i></span> 》),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0241"></a>     《 <span class="KeyTerm2"><i>block</i></span> 》)</p>
<p class="paracontinue"><a id="c004_c4-para-0242"></a>The syntax predicate is <span class="KeyTerm1">is_lambda_expression</span> and the selector for the body of the lambda expression is <span class="KeyTerm1">lambda_body</span>. The selector for the parameters, called <span class="KeyTerm1">lambda_parameter_symbols</span>, additionally extracts the symbols from the names.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0243"></a><b>function</b> lambda_parameter_symbols(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0244"></a> <b>return</b> map(symbol_of_name, head(tail(component)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0245"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0246"></a>The function <span class="KeyTerm1">function_decl_to_constant_decl</span> needs a constructor for lambda expressions:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0247"></a><b>function</b> make_lambda_expression(parameters, body) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0248"></a> <b>return</b> list("lambda_expression", parameters, body);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0249"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0023"></a><a id="c004_c4-title-0024"></a>Sequences</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0250"></a>A sequence statement packages a sequence of statements into a single statement. A sequence of statements is parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0251"></a>《 <span class="KeyTerm2"><i>statement</i><sub>1</sub></span> <i>· · ·</i> <span class="KeyTerm2"><i>statement<sub>n</sub></i></span> 》 =</p>
<p class="Sp-text-1"><a id="c004_c4-para-0252"></a>      list("sequence", list(《 <span class="KeyTerm2"><i>statement</i><sub>1</sub></span> 》, <i>. . .</i>, 《 <span class="KeyTerm2"><i>statement<sub>n</sub></i></span> 》))</p>
<p class="paracontinue"><a id="c004_c4-para-0253"></a>The syntax predicate is <span class="KeyTerm1">is_sequence</span> and the selector is <span class="KeyTerm1">sequence_statements</span>. We retrieve the first of a list of statements using <span class="KeyTerm1">first_statement</span> and the remaining statements using <span class="KeyTerm1">rest_statements</span>. We test whether the list is empty using the predicate <span class="KeyTerm1">is_empty_sequence</span> and whether it contains only one element using the predicate <span class="KeyTerm1">is_last_statement</span>.<a id="c004_c4-fn-0011a"></a><a href="#c4-fn-0011"><sup>11</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0254"></a><b>function</b> first_statement(stmts) { <b>return</b> head(stmts); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0255"></a><b>function</b> rest_statements(stmts) { <b>return</b> tail(stmts); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0256"></a><b>function</b> is_empty_sequence(stmts) { <b>return</b> is_null(stmts); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0257"></a><b>function</b> is_last_statement(stmts) { <b>return</b> is_null(tail(stmts)); }</p>
</section>
<section>
<h5><a id="c004_c4-sec-0024"></a><a id="c004_c4-title-0025"></a>Blocks</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0258"></a>Blocks are parsed as follows:<a id="c004_c4-fn-0012a"></a><a href="#c4-fn-0012"><sup>12</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0259"></a>《 { <span class="KeyTerm2"><i>statements</i></span> } 》 = list("block", 《 <span class="KeyTerm2"><i>statements</i></span> 》 )</p>
<p class="paracontinue"><a id="c004_c4-para-0260"></a>Here <i>statements</i> refers to a sequence of statements, as shown above. The syntax predicate is <span class="KeyTerm1">is_block</span> and the selector is <span class="KeyTerm1">block_body</span>.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0025"></a><a id="c004_c4-title-0026"></a>Return statements</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0261"></a>Return statements are parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0262"></a>《 <b>return</b> <span class="KeyTerm2"><i>expression</i></span>; 》 = list("return_statement", 《 <span class="KeyTerm2"><i>expression</i></span> 》 )</p>
<p class="paracontinue"><a id="c004_c4-para-0263"></a>The syntax predicate and selector are, respectively, <span class="KeyTerm1">is_return_statement</span> and <span class="KeyTerm1">return_expression</span>.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0026"></a><a id="c004_c4-title-0027"></a>Assignments</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0264"></a>Assignments are parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0265"></a>《 <span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>expression</i></span> 》 = list("assignment", 《 <span class="KeyTerm2"><i>name</i></span> 》 , 《 <span class="KeyTerm2"><i>expression</i></span> 》 )</p>
<p class="paracontinue"><a id="c004_c4-para-0266"></a>The syntax predicate is <span class="KeyTerm1">is_assignment</span> and the selectors are <span class="KeyTerm1">assignment_symbol</span> and <span class="KeyTerm1">assignment_value_expression</span>. The symbol is wrapped in a tagged list representing the name, and thus <span class="KeyTerm1">assignment_symbol</span> needs to unwrap it.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0267"></a><b>function</b> assignment_symbol(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0268"></a> <b>return</b> symbol_of_name(head(tail(component))));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0269"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0027"></a><a id="c004_c4-title-0028"></a>Constant, variable, and function declarations</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0270"></a>Constant and variable declarations are parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0271"></a>《 <b>const</b> <span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>expression</i></span>; 》 =</p>
<p class="Sp-text-1"><a id="c004_c4-para-0272"></a>    list("constant_declaration", 《 <span class="KeyTerm2"><i>name</i></span> 》, 《 <span class="KeyTerm2"><i>expression</i></span> 》)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0273"></a>《 <b>let</b> <span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>expression</i></span>; 》 =</p>
<p class="Sp-text-1"><a id="c004_c4-para-0274"></a>    list("variable_declaration", 《 <span class="KeyTerm2"><i>name</i></span> 》, 《 <span class="KeyTerm2"><i>expression</i></span> 》)</p>
<p class="paracontinue"><a id="c004_c4-para-0275"></a>The selectors <span class="KeyTerm1">declaration_symbol</span> and <span class="KeyTerm1">declaration_value_expression</span> apply to both kinds.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0276"></a><b>function</b> declaration_symbol(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0277"></a> <b>return</b> symbol_of_name(head(tail(component)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0278"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0279"></a><b>function</b> declaration_value_expression(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0280"></a> <b>return</b> head(tail(tail(component)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0281"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0282"></a>The function <span class="KeyTerm1">function_decl_to_constant_decl</span> needs a constructor for constant declarations:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0283"></a><b>function</b> make_constant_declaration(name, value_expression) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0284"></a> <b>return</b> list("constant_declaration", name, value_expression);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0285"></a>}</p>
<p><a id="c004_c4-para-0286"></a>Function declarations are parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0287"></a><b>function</b> <span class="KeyTerm2"><i>name</i></span>(<span class="KeyTerm2"><i>name</i><sub>1</sub></span>, <i>. . .</i> <span class="KeyTerm2"><i>name<sub>n</sub></i></span>) <span class="KeyTerm2"><i>block</i></span> 》=</p>
<p class="Sp-text-1"><a id="c004_c4-para-0288"></a>    list("function_declaration",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0289"></a>     《 <span class="KeyTerm2"><i>name</i></span> 》,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0290"></a>     list(《 <span class="KeyTerm2"><i>name</i><sub>1</sub></span> 》, <i>. . .</i>, 《 <span class="KeyTerm2"><i>name<sub>n</sub></i></span> 》),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0291"></a>     《 <span class="KeyTerm2"><i>block</i></span> 》)</p>
<p class="paracontinue"><a id="c004_c4-para-0292"></a>The syntax predicate <span class="KeyTerm1">is_function_declaration</span> recognizes these. The selectors are <span class="KeyTerm1">function_declaration_name</span>, <span class="KeyTerm1">function_declaration_parameters</span>, and <span class="KeyTerm1">function_declaration_body</span>.</p>
<p><a id="c004_c4-para-0293"></a>The syntax predicate <span class="KeyTerm1">is_declaration</span> returns true for all three kinds of declarations.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0294"></a><b>function</b> is_declaration(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0295"></a> <b>return</b> is_tagged_list(component, "constant_declaration") ||</p>
<p class="Sp-text-1"><a id="c004_c4-para-0296"></a>           is_tagged_list(component, "variable_declaration") ||</p>
<p class="Sp-text-1"><a id="c004_c4-para-0297"></a>           is_tagged_list(component, "function_declaration");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0298"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0028"></a><a id="c004_c4-title-0029"></a>Derived components</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0299"></a>Some syntactic forms in our language can be defined in terms of components involving other syntactic forms, rather than being implemented directly. One example is function declaration, which <span class="KeyTerm1">evaluate</span> transforms into a constant declaration whose value expression is a lambda expression.<a id="c004_c4-fn-0013a"></a><a href="#c4-fn-0013"><sup>13</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0300"></a><b>function</b> function_decl_to_constant_decl(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0301"></a> <b>return</b> make_constant_declaration(</p>
<p class="Sp-text-1"><a id="c004_c4-para-0302"></a>               function_declaration_name(component),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0303"></a>               make_lambda_expression(</p>
<p class="Sp-text-1"><a id="c004_c4-para-0304"></a>                   function_declaration_parameters(component),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0305"></a>                   function_declaration_body(component)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0306"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0307"></a>Implementing the evaluation of function declarations in this way simplifies the evaluator because it reduces the number of syntactic forms for which the evaluation process must be explicitly specified.</p>
<p><a id="c004_c4-para-0308"></a>Similarly, we define operator combinations in terms of function applications. Operator combinations are unary or binary and carry their operator symbol as second element in the tagged-list representation:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0309"></a>《 <span class="KeyTerm2"><i>unary</i>-<i>operator expression</i></span> 》=</p>
<p class="Sp-text-1"><a id="c004_c4-para-0310"></a>    list("unary_operator_combination",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0311"></a>         "<span class="KeyTerm2"><i>unary</i>-<i>operator</i></span>",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0312"></a>         list(《 <span class="KeyTerm2"><i>expression</i></span> 》))</p>
<p class="paracontinue"><a id="c004_c4-para-0313"></a>where <i>unary</i>-<i>operator</i> is <span class="KeyTerm1">!</span> (for logical negation) or <span class="KeyTerm1">-unary</span> (for numeric negation), and</p>
<p class="Sp-text-1"><a id="c004_c4-para-0314"></a>《 <span class="KeyTerm2"><i>expression</i><sub>1</sub> <i>binary</i>-<i>operator expression</i><sub>2</sub></span> 》=</p>
<p class="Sp-text-1"><a id="c004_c4-para-0315"></a>    list("binary_operator_combination",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0316"></a>         "<span class="KeyTerm2"><i>binary</i>-<i>operator</i></span>",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0317"></a>         list(《 <span class="KeyTerm2"><i>expression</i><sub>1</sub></span> 》, 《 <span class="KeyTerm2"><i>expression</i><sub>2</sub></span> 》))</p>
<p class="paracontinue"><a id="c004_c4-para-0318"></a>where <i>binary</i>-<i>operator</i> is <span class="KeyTerm1">+</span>, <span class="KeyTerm1">-</span>, <span class="KeyTerm1">*</span>, <span class="KeyTerm1">/</span>, <span class="KeyTerm1">%</span>, <span class="KeyTerm1">===</span>, <span class="KeyTerm1">!==</span>, <span class="KeyTerm1">&gt;</span>, <span class="KeyTerm1">&lt;</span>, <span class="KeyTerm1">&gt;=</span> or <span class="KeyTerm1">&lt;=</span>. The syntax predicates are <span class="KeyTerm1">is_operator_combination</span>, <span class="KeyTerm1">is_unary_operator_combination</span>, and <span class="KeyTerm1">is_binary_operator_combination</span>, and the selectors are <span class="KeyTerm1">operator_symbol</span>, <span class="KeyTerm1">first_operand</span>, and <span class="KeyTerm1">second_operand</span>.</p>
<p><a id="c004_c4-para-0319"></a>The evaluator uses <span class="KeyTerm1">operator_combination_to_application</span> to transform an operator combination into a function application whose function expression is the name of the operator:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0320"></a><b>function</b> operator_combination_to_application(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0321"></a> <b>const</b> operator = operator_symbol(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0322"></a> <b>return</b> is_unary_operator_combination(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0323"></a>           ? make_application(make_name(operator),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0324"></a>                              list(first_operand(component)))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0325"></a>           : make_application(make_name(operator),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0326"></a>                              list(first_operand(component),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0327"></a>                                   second_operand(component)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0328"></a>}</p>
<p><a id="c004_c4-para-0329"></a>Components (such as function declarations and operator combinations) that we choose to implement as syntactic transformations are called <i>derived components</i>. Logical composition operations are also derived components (see exercise 4.4).</p>
</section>
<section>
<h5><a id="c004_c4-sec-0029"></a><a id="c004_c4-title-0030"></a>Exercise 4.2</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0330"></a>The inverse of <span class="KeyTerm1">parse</span> is called <span class="KeyTerm1">unparse</span>. It takes as argument a tagged list as produced by <span class="KeyTerm1">parse</span> and returns a string that adheres to JavaScript notation.</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0014"></a><span>a. </span>Write a function <span class="KeyTerm1">unparse</span> by following the structure of <span class="KeyTerm1">evaluate</span> (without the environment parameter), but producing a string that represents the given component, rather than evaluating it. Recall from section 3.3.4 that the operator <span class="KeyTerm1">+</span> can be applied to two strings to concatenate them and that the primitive function <span class="KeyTerm1">stringify</span> turns values such as 1.5, true, <span class="KeyTerm1"><b>null</b></span> and <span class="KeyTerm1">undefined</span> into strings. Take care to respect operator precedences by surrounding the strings that result from unparsing operator combinations with parentheses (always or whenever necessary).</li>
<li><a id="c004_c4-li-0015"></a><span>b. </span>Your <span class="KeyTerm1">unparse</span> function will come in handy when solving later exercises in this section. Improve <span class="KeyTerm1">unparse</span> by adding <span class="KeyTerm1">" "</span> (space) and <span class="KeyTerm1">"\n"</span> (newline) characters to the result string, to follow the indentation style used in the JavaScript programs of this book. Adding such whitespace characters to (or removing them from) a program text in order to make the text easier to read is called <i>pretty-printing</i>.</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0030"></a><a id="c004_c4-title-0031"></a>Exercise 4.3</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0333"></a>Rewrite <span class="KeyTerm1">evaluate</span> so that the dispatch is done in data-directed style. Compare this with the data-directed differentiation function of exercise 2.73. (You may use the tag of the tagged-list representation as the type of the components.)</p>
</section>
<section>
<h5><a id="c004_c4-sec-0031"></a><a id="c004_c4-title-0032"></a>Exercise 4.4</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0334"></a>Recall from section 1.1.6 that the logical composition operations <span class="KeyTerm1">&amp;&amp;</span> and <span class="KeyTerm1">||</span> are syntactic sugar for conditional expressions: The logical conjunction <i>expression</i><sub>1</sub> <span class="KeyTerm1">&amp;&amp;</span> <i>expression</i><sub>2</sub> is syntactic sugar for <i>expression</i><sub>1</sub> <span class="KeyTerm1">?</span> <i>expression</i><sub>2</sub> : <span class="KeyTerm1"><b>false</b></span>, and the logical disjunction <i>expression</i><sub>1 </sub><span class="KeyTerm1">||</span> <i>expression</i><sub>2 </sub>is syntactic sugar for <i>expression</i><sub>1 </sub><span class="KeyTerm1">? <b>true</b></span> : <i>expression</i><sub>2</sub>. They are parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0335"></a>《 <span class="KeyTerm2"><i>expression</i><sub>1</sub> <i>logical</i>-<i>operation expression</i><sub>2</sub></span> 》=</p>
<p class="Sp-text-1"><a id="c004_c4-para-0336"></a>    list("logical_composition",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0337"></a>         "<span class="KeyTerm2"><i>logical</i>-<i>operation</i></span>",</p>
<p class="Sp-text-1"><a id="c004_c4-para-0338"></a>         list(《 <span class="KeyTerm2"><i>expression</i><sub>1</sub> </span> 》, 《 <span class="KeyTerm2"><i>expression</i><sub>2</sub> </span> 》))</p>
<p class="paracontinue"><a id="c004_c4-para-0339"></a>where <i>logical</i>-<i>operation</i> is <span class="KeyTerm1">&amp;&amp;</span> or <span class="KeyTerm1">||</span>. Install <span class="KeyTerm1">&amp;&amp;</span> and <span class="KeyTerm1">||</span> as new syntactic forms for the evaluator by declaring appropriate syntax functions and evaluation functions <span class="KeyTerm1">eval_and</span> and <span class="KeyTerm1">eval_or</span>. Alternatively, show how to implement <span class="KeyTerm1">&amp;&amp;</span> and <span class="KeyTerm1">||</span> as derived components.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0032"></a><a id="c004_c4-title-0033"></a>Exercise 4.5</h5>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0016"></a><span>a. </span>In JavaScript, lambda expressions must not have duplicate parameters. The evaluator in section 4.1.1 does not check for this.<ul style="list-style-type:disc">
<li>Modify the evaluator so that any attempt to apply a function with duplicate parameters signals an error.</li>
<li>Implement a <span class="KeyTerm1">verify</span> function that checks whether any lambda expression in a given program contains duplicate parameters. With such a function, we could check the entire program before we pass it to <span class="KeyTerm1">evaluate</span>.</li>
</ul>
<p class="paracontinue"><a id="c004_c4-para-0343"></a>In order to implement this check in an evaluator for JavaScript, which of these two approaches would you prefer? Why?</p></li>
<li><a id="c004_c4-li-0019"></a><span>b. </span>In JavaScript, the parameters of a lambda expression must be distinct from the names declared <i>directly</i> in the body block of the lambda expression (as opposed to in an inner block). Use your preferred approach above to check for this as well.</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0033"></a><a id="c004_c4-title-0034"></a>Exercise 4.6</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0345"></a>The language Scheme includes a variant of <span class="KeyTerm1"><b>let</b></span> called <span class="KeyTerm1"><b>let</b>*</span>. We could approximate the behavior of <span class="KeyTerm1"><b>let</b>*</span> in JavaScript by stipulating that a <span class="KeyTerm1"><b>let</b>*</span> declaration implicitly introduces a new block whose body includes the declaration and all subsequent statements of the statement sequence in which the declaration occurs. For example, the program</p>
<p class="Sp-text-1"><a id="c004_c4-para-0346"></a><b>let</b>* x = 3;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0347"></a><b>let</b>* y = x + 2;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0348"></a><b>let</b>* z = x + y + 5;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0349"></a>display(x * z);</p>
<p class="paracontinue"><a id="c004_c4-para-0350"></a>displays 39 and could be seen as a shorthand for</p>
<p class="Sp-text-1"><a id="c004_c4-para-0351"></a>{</p>
<p class="Sp-text-1"><a id="c004_c4-para-0352"></a> <b>let</b> x = 3;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0353"></a>  {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0354"></a> <b>let</b> y = x + 2;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0355"></a>    {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0356"></a> <b>let</b> z = x + y + 5;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0357"></a>      display(x * z);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0358"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0359"></a>  }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0360"></a>}</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0020"></a><span>a. </span>Write a program in such an extended JavaScript language that behaves differently when some occurrences of the keyword <span class="KeyTerm1"><b>let</b></span> are replaced with <span class="KeyTerm1"><b>let</b>*</span>.</li>
<li><a id="c004_c4-li-0021"></a><span>b. </span>Introduce <span class="KeyTerm1"><b>let</b>*</span> as a new syntactic form by designing a suitable tagged-list representation and writing a parse rule. Declare a syntax predicate and selectors for the tagged-list representation.</li>
<li><a id="c004_c4-li-0022"></a><span>c. </span>Assuming that <span class="KeyTerm1">parse</span> implements your new rule, write a <span class="KeyTerm1">let_star_to_nested_let</span> function that transforms any occurrence of <span class="KeyTerm1"><b>let</b>*</span> in a given program as described above. We could then evaluate a program <span class="KeyTerm1">p</span> in the extended language by running <span class="KeyTerm1">evaluate(let_star_to_nested_let(p))</span>.</li>
<li><a id="c004_c4-li-0023"></a><span>d. </span>As an alternative, consider implementing <span class="KeyTerm1"><b>let</b>*</span> by adding to <span class="KeyTerm1">evaluate</span> a clause that recognizes the new syntactic form and calls a function <span class="KeyTerm1">eval_let_star_declaration</span>. Why does this approach not work?</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0034"></a><a id="c004_c4-title-0035"></a>Exercise 4.7</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0365"></a>JavaScript supports <i>while loops</i> that execute a given statement repeatedly. Specifically,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0366"></a><b>while</b> (<span class="KeyTerm2"><i>predicate</i></span>) { <span class="KeyTerm2"><i>body</i></span> }</p>
<p class="paracontinue"><a id="c004_c4-para-0367"></a>evaluates the <i>predicate</i>, and if the result is true, evaluates the <i>body</i> and then evaluates the whole while loop again. Once the <i>predicate</i> evaluates to false, the while loop terminates.</p>
<p><a id="c004_c4-para-0368"></a>For example, recall the imperative-style version of the iterative factorial function from section 3.1.3:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0369"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0370"></a> <b>let</b> product = 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0371"></a> <b>let</b> counter = 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0372"></a> <b>function</b> iter() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0373"></a> <b>if</b> (counter &gt; n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0374"></a> <b>return</b> product;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0375"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0376"></a>            product = counter * product;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0377"></a>            counter = counter + 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0378"></a> <b>return</b> iter();</p>
<p class="Sp-text-1"><a id="c004_c4-para-0379"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0380"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0381"></a> <b>return</b> iter();</p>
<p class="Sp-text-1"><a id="c004_c4-para-0382"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0383"></a>We can formulate the same algorithm using a while loop as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0384"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0385"></a> <b>let</b> product = 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0386"></a> <b>let</b> counter = 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0387"></a> <b>while</b> (counter &lt;= n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0388"></a>        product = counter * product;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0389"></a>        counter = counter + 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0390"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0391"></a> <b>return</b> product;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0392"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0393"></a>While loops are parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0394"></a>《 <b>while</b> (<span class="KeyTerm2"><i>predicate</i></span>) <span class="KeyTerm2"><i>block</i></span> 》 =</p>
<p class="Sp-text-1"><a id="c004_c4-para-0395"></a>        list("while_loop", 《 <span class="KeyTerm2"><i>predicate</i></span> 》, 《 <span class="KeyTerm2"><i>block</i></span> 》)</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0024"></a><span>a. </span>Declare a syntax predicate and selectors to handle while loops.</li>
<li><a id="c004_c4-li-0025"></a><span>b. </span>Declare a function <span class="KeyTerm1">while_loop</span> that takes as arguments a predicate and a body—each represented by a function of no arguments—and simulates the behavior of the while loop. The <span class="KeyTerm1">factorial</span> function would then look as follows:
<p class="Sp-text-1"><a id="c004_c4-para-0398"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0399"></a> <b>let</b> product = 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0400"></a> <b>let</b> counter = 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0401"></a>    while_loop(() =&gt; counter &lt;= n,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0402"></a>               () =&gt; {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0403"></a>                   product = counter * product;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0404"></a>                   counter = counter + 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0405"></a>               });</p>
<p class="Sp-text-1"><a id="c004_c4-para-0406"></a> <b>return</b> product;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0407"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0408"></a>Your function <span class="KeyTerm1">while_loop</span> should generate an iterative process (see section 1.2.1).</p></li>
<li><a id="c004_c4-li-0026"></a><span>c. </span>Install while loops as a derived component by defining a transformation function <span class="KeyTerm1">while_to_application</span> that makes use of your function <span class="KeyTerm1">while_loop</span>.</li>
<li><a id="c004_c4-li-0027"></a><span>d. </span>What problem arises with this approach for implementing while loops, when the programmer decides within the body of the loop to return from the function that contains the loop?</li>
<li><a id="c004_c4-li-0028"></a><span>e. </span>Change your approach to address the problem. How about directly installing while loops for the evaluator, using a function <span class="KeyTerm1">eval_while</span>?</li>
<li><a id="c004_c4-li-0029"></a><span>f. </span>Following this direct approach, implement a <span class="KeyTerm1"><b>break</b>;</span> statement that immediately terminates the loop in which it is evaluated.</li>
<li><a id="c004_c4-li-0030"></a><span>g. </span>Implement a <span class="KeyTerm1"><b>continue</b>;</span> statement that terminates only the loop iteration in which it is evaluated, and continues with evaluating the while loop predicate.</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0035"></a><a id="c004_c4-title-0036"></a>Exercise 4.8</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0414"></a>The result of evaluating the body of a function is determined by its return statements. Following up on footnote 9 and the evaluation of declarations in section 4.1.1, this exercise addresses the question of what should be the result of evaluating a JavaScript program that consists of a sequence of statements (declarations, blocks, expression statements, and conditional statements) <i>outside of</i> any function body.</p>
<p><a id="c004_c4-para-0415"></a>For such a program, JavaScript statically distinguishes between <i>value-producing</i> and <i>non-value-producing statements</i>. (Here “statically” means that we can make the distinction by <i>inspecting</i> the program rather than by running it.) All declarations are non-valueproducing, and all expression statements and conditional statements are value-producing. The value of an expression statement is the value of the expression. The value of a conditional statement is the value of the branch that gets executed, or the value <span class="KeyTerm1">undefined</span> if that branch is not value-producing. A block is value-producing if its body (sequence of statements) is value-producing, and then its value is the value of its body. A sequence is value-producing if any of its component statements is value-producing, and then its value is the value of its <i>last</i> value-producing component statement. Finally, if the whole program is not value-producing, its value is the value <span class="KeyTerm1">undefined</span>.</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0031"></a><span>a. </span>According to this specification, what are the values of the following four programs?
<p class="Sp-text-1"><a id="c004_c4-para-0417"></a>1; 2; 3;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-0418"></a>1; { <b>if</b> (<b>true</b>) {} <b>else</b> { 2; } }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-5418"></a>1; <b>const</b> x = 2;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-0419"></a>1; { <b>let</b> x = 2; { x = x + 3; } }</p></li>
<li><a id="c004_c4-li-0032"></a><span>b. </span>Modify the evaluator to adhere to this specification.</li>
</ol>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0036"></a><span>4.1.3</span> <a id="c004_c4-title-0037"></a>Evaluator Data Structures</h3>
<p class="paraaftertitle"><a id="c004_c4-para-0421"></a>In addition to defining the representation of components, the evaluator implementation must also define the data structures that the evaluator manipulates internally, as part of the execution of a program, such as the representation of functions and environments and the representation of true and false.</p>
<section>
<h5><a id="c004_c4-sec-0037"></a><a id="c004_c4-title-0038"></a>Testing of predicates</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0422"></a>In order to limit the predicate expressions of conditionals to proper predicates (expressions that evaluate to a boolean value) as we do throughout this book, we insist here that the function <span class="KeyTerm1">is_truthy</span> gets applied only to boolean values, and we accept only the boolean value <span class="KeyTerm1"><b>true</b></span> to be truthy. The opposite of <span class="KeyTerm1">is_truthy</span> is called <span class="KeyTerm1">is_falsy</span>.<a id="c004_c4-fn-0014a"></a><a href="#c4-fn-0014"><sup>14</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0432"></a><b>function</b> is_truthy(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0433"></a> <b>return</b> is_boolean(x)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0434"></a>           ? x</p>
<p class="Sp-text-1"><a id="c004_c4-para-0435"></a>           : error(x, "boolean expected, received");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0436"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0437"></a><b>function</b> is_falsy(x) { <b>return</b> ! is_truthy(x); }</p>
</section>
<section>
<h5><a id="c004_c4-sec-0038"></a><a id="c004_c4-title-0039"></a>Representing functions</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0438"></a>To handle primitives, we assume that we have available the following functions:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">apply_primitive_function(</span><i>fun</i><span class="KeyTerm1">,</span> <i>args</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c004_c4-para-0440"></a>applies the given primitive function to the argument values in the list <i>args</i> and returns the result of the application.</p></li>
<li><span class="KeyTerm1">is_primitive_function(</span><i>fun</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c004_c4-para-0442"></a>tests whether <i>fun</i> is a primitive function.</p></li>
</ul>
<p class="paracontinue"><a id="c004_c4-para-0443"></a>These mechanisms for handling primitives are further described in section 4.1.4.</p>
<p><a id="c004_c4-para-0444"></a>Compound functions are constructed from parameters, function bodies, and environments using the constructor <span class="KeyTerm1">make_function</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0445"></a><b>function</b> make_function(parameters, body, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0446"></a> <b>return</b> list("compound_function", parameters, body, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0447"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0448"></a><b>function</b> is_compound_function(f) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0449"></a> <b>return</b> is_tagged_list(f, "compound_function");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0450"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0451"></a><b>function</b> function_parameters(f) { <b>return</b> list_ref(f, 1); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0452"></a><b>function</b> function_body(f) { <b>return</b> list_ref(f, 2); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0453"></a><b>function</b> function_environment(f) { <b>return</b> list_ref(f, 3); }</p>
</section>
<section>
<h5><a id="c004_c4-sec-0039"></a><a id="c004_c4-title-0040"></a>Representing return values</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0454"></a>We saw in section 4.1.1 that the evaluation of a sequence terminates when a return statement is encountered, and that the evaluation of a function application needs to return the value <span class="KeyTerm1">undefined</span> if the evaluation of the function body does not encounter a return statement. In order to recognize that a value resulted from a return statement, we introduce <i>return values</i> as evaluator data structures.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0455"></a><b>function</b> make_return_value(content) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0456"></a> <b>return</b> list("return_value", content);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0457"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0458"></a><b>function</b> is_return_value(value) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0459"></a> <b>return</b> is_tagged_list(value, "return_value");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0460"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0461"></a><b>function</b> return_value_content(value) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0462"></a> <b>return</b> head(tail(value));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0463"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0040"></a><a id="c004_c4-title-0041"></a>Operations on Environments</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0464"></a>The evaluator needs operations for manipulating environments. As explained in section 3.2, an environment is a sequence of frames, where each frame is a table of bindings that associate symbols with their corresponding values. We use the following operations for manipulating environments:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">lookup_symbol_value(</span><i>symbol</i><span class="KeyTerm1">,</span> <i>env</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c004_c4-para-0466"></a>returns the value that is bound to <i>symbol</i> in the environment <i>env</i>, or signals an error if <i>symbol</i> is unbound.</p></li>
<li><span class="KeyTerm1">extend_environment(</span><i>symbols</i><span class="KeyTerm1">,</span> <i>values</i><span class="KeyTerm1">,</span> <i>base</i>-<i>env</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c004_c4-para-0468"></a>returns a new environment, consisting of a new frame in which the symbols in the list <i>symbols</i> are bound to the corresponding elements in the list <i>values</i>, where the enclosing environment is the environment <i>base</i>-<i>env</i>.</p></li>
<li><span class="KeyTerm1">assign_symbol_value(</span><i>symbol</i><span class="KeyTerm1">,</span> <i>value</i><span class="KeyTerm1">,</span> <i>env</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c004_c4-para-0470"></a>finds the innermost frame of <i>env</i> in which <i>symbol</i> is bound, and changes that frame so that <i>symbol</i> is now bound to <i>value</i>, or signals an error if <i>symbol</i> is unbound.</p></li>
</ul>
<p><a id="c004_c4-para-0471"></a>To implement these operations we represent an environment as a list of frames. The enclosing environment of an environment is the <span class="KeyTerm1">tail</span> of the list. The empty environment is simply the empty list.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0472"></a><b>function</b> enclosing_environment(env) { <b>return</b> tail(env); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0473"></a><b>function</b> first_frame(env) { <b>return</b> head(env); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0474"></a><b>const</b> the_empty_environment = <b>null</b>;</p>
<p class="paracontinue"><a id="c004_c4-para-0475"></a>Each frame of an environment is represented as a pair of lists: a list of the names bound in that frame and a list of the associated values.<a id="c004_c4-fn-0015a"></a><a href="#c4-fn-0015"><sup>15</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0476"></a><b>function</b> make_frame(symbols, values) { <b>return</b> pair(symbols, values); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0477"></a><b>function</b> frame_symbols(frame) { <b>return</b> head(frame); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0478"></a><b>function</b> frame_values(frame) { <b>return</b> tail(frame); }</p>
<p><a id="c004_c4-para-0479"></a>To extend an environment by a new frame that associates symbols with values, we make a frame consisting of the list of symbols and the list of values, and we adjoin this to the environment. We signal an error if the number of symbols does not match the number of values.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0480"></a><b>function</b> extend_environment(symbols, vals, base_env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0481"></a> <b>return</b> length(symbols) === length(vals)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0482"></a>           ? pair(make_frame(symbols, vals), base_env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0483"></a>           : error(pair(symbols, vals),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0484"></a>                   length(symbols) &lt; length(vals)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0485"></a>                   ? "too many arguments supplied"</p>
<p class="Sp-text-1"><a id="c004_c4-para-0486"></a>                   : "too few arguments supplied");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0487"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0488"></a>This is used by <span class="KeyTerm1">apply</span> in section 4.1.1 to bind the parameters of a function to its arguments.</p>
<p><a id="c004_c4-para-0489"></a>To look up a symbol in an environment, we scan the list of symbols in the first frame. If we find the desired symbol, we return the corresponding element in the list of values. If we do not find the symbol in the current frame, we search the enclosing environment, and so on. If we reach the empty environment, we signal an <span class="KeyTerm1">"unbound name"</span> error.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0490"></a><b>function</b> lookup_symbol_value(symbol, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0491"></a> <b>function</b> env_loop(env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0492"></a> <b>function</b> scan(symbols, vals) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0493"></a> <b>return</b> is_null(symbols)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0494"></a>                   ? env_loop(enclosing_environment(env))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0495"></a>                   : symbol === head(symbols)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0496"></a>                   ? head(vals)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0497"></a>                   : scan(tail(symbols), tail(vals));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0498"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0499"></a> <b>if</b> (env === the_empty_environment) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0500"></a>            error(symbol, "unbound name");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0501"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0502"></a> <b>const</b> frame = first_frame(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0503"></a> <b>return</b> scan(frame_symbols(frame), frame_values(frame));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0504"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0505"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0506"></a> <b>return</b> env_loop(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0507"></a>}</p>
<p><a id="c004_c4-para-0508"></a>To assign a new value to a symbol in a specified environment, we scan for the symbol, just as in <span class="KeyTerm1">lookup_symbol_value</span>, and change the corresponding value when we find it.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0509"></a><b>function</b> assign_symbol_value(symbol, val, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0510"></a> <b>function</b> env_loop(env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0511"></a> <b>function</b> scan(symbols, vals) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0512"></a> <b>return</b> is_null(symbols)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0513"></a>                   ? env_loop(enclosing_environment(env))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0514"></a>                   : symbol === head(symbols)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0515"></a>                   ? set_head(vals, val)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0516"></a>                   : scan(tail(symbols), tail(vals));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0517"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0518"></a> <b>if</b> (env === the_empty_environment) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0519"></a>            error(symbol, "unbound name – assignment");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0520"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0521"></a> <b>const</b> frame = first_frame(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0522"></a> <b>return</b> scan(frame_symbols(frame), frame_values(frame));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0523"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0524"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0525"></a> <b>return</b> env_loop(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0526"></a>}</p>
<p><a id="c004_c4-para-0527"></a>The method described here is only one of many plausible ways to represent environments. Since we used data abstraction to isolate the rest of the evaluator from the detailed choice of representation, we could change the environment representation if we wanted to. (See exercise 4.9.) In a production-quality JavaScript system, the speed of the evaluator's environment operations—especially that of symbol lookup—has a major impact on the performance of the system. The representation described here, although conceptually simple, is not efficient and would not ordinarily be used in a production system.<a id="c004_c4-fn-0016a"></a><a href="#c4-fn-0016"><sup>16</sup></a></p>
</section>
<section>
<h5><a id="c004_c4-sec-0041"></a><a id="c004_c4-title-0042"></a>Exercise 4.9</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0528"></a>Instead of representing a frame as a pair of lists, we can represent a frame as a list of bindings, where each binding is a symbol-value pair. Rewrite the environment operations to use this alternative representation.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0042"></a><a id="c004_c4-title-0043"></a>Exercise 4.10</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0529"></a>The functions <span class="KeyTerm1">lookup_symbol_value</span> and <span class="KeyTerm1">assign_symbol_value</span> can be expressed in terms of a more abstract function for traversing the environment structure. Define an abstraction that captures the common pattern and redefine the two functions in terms of this abstraction.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0043"></a><a id="c004_c4-title-0044"></a>Exercise 4.11</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0530"></a>Our language distinguishes constants from variables by using different keywords—<span class="KeyTerm1"><b>const</b></span> and <span class="KeyTerm1"><b>let</b></span>—and prevents assignment to constants. However, our interpreter does not make use of this distinction; the function <span class="KeyTerm1">assign_symbol_value</span> will happily assign a new value to a given symbol, regardless whether it is declared as a constant or a variable. Correct this flaw by calling the function <span class="KeyTerm1">error</span> whenever an attempt is made to use a constant on the left-hand side of an assignment. You may proceed as follows:</p>
<ul style="list-style-type:disc">
<li>Introduce predicates <span class="KeyTerm1">is_constant_declaration</span> and <span class="KeyTerm1">is_variable_declaration</span> that allow you to distinguish the two kinds. As shown in section 4.1.2, <span class="KeyTerm1">parse</span> distinguishes them by using the tags <span class="KeyTerm1">"constant_declaration"</span> and <span class="KeyTerm1">"variable_declaration"</span>.</li>
<li>Change <span class="KeyTerm1">scan_out_declarations</span> and (if necessary) <span class="KeyTerm1">extend_environment</span> such that constants are distinguishable from variables in the frames in which they are bound.</li>
<li>Change <span class="KeyTerm1">assign_symbol_value</span> such that it checks whether the given symbol has been declared as a variable or as a constant, and in the latter case signals an error that assignment operations are not allowed on constants.</li>
<li>Change <span class="KeyTerm1">eval_declaration</span> such that when it encounters a constant declaration, it calls a new function, <span class="KeyTerm1">assign_constant_value</span>, which does not perform the check that you introduced in <span class="KeyTerm1">assign_symbol_value</span>.</li>
<li>If necessary, change <span class="KeyTerm1">apply</span> to ensure that assignment to function parameters remains possible.</li>
</ul>
</section>
<section>
<h5><a id="c004_c4-sec-0044"></a><a id="c004_c4-title-0045"></a>Exercise 4.12</h5>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0043"></a><span>a. </span>JavaScript's specification requires an implementation to signal a runtime error upon an attempt to access the value of a name before its declaration is evaluated (see the end of section 3.2.4). To achieve this behavior in the evaluator, change <span class="KeyTerm1">lookup_symbol_value</span> to signal an error if the value it finds is <span class="KeyTerm1">"*unassigned*"</span>.</li>
<li><a id="c004_c4-li-0044"></a><span>b. </span>Similarly, we must not assign a new value to a variable if we have not evaluated its <span class="KeyTerm1"><b>let</b></span> declaration yet. Change the evaluation of assignment such that assignment to a variable declared with <span class="KeyTerm1"><b>let</b></span> signals an error in this case.</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0045"></a><a id="c004_c4-title-0046"></a>Exercise 4.13</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0538"></a>Prior to ECMAScript 2015's strict mode that we are using in this book, JavaScript variables worked quite differently from Scheme variables, which would have made this adaptation to JavaScript considerably less compelling.</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0045"></a><span>a. </span>Before ECMAScript 2015, the only way to declare a local variable in JavaScript was using the keyword <span class="KeyTerm1"><b>var</b></span> instead of the keyword <span class="KeyTerm1"><b>let</b></span>. The scope of variables declared with <span class="KeyTerm1"><b>var</b></span> is the entire body of the immediately surrounding function declaration or lambda expression, rather than just the immediately enclosing block. Modify <span class="KeyTerm1">scan_out_declarations</span> and <span class="KeyTerm1">eval_block</span> such that names declared with <span class="KeyTerm1"><b>const</b></span> and <span class="KeyTerm1"><b>let</b></span> follow the scoping rules of <span class="KeyTerm1"><b>var</b></span>.</li>
<li><a id="c004_c4-li-0046"></a><span>b. </span>When not in strict mode, JavaScript permits undeclared names to appear to the left of the <span class="KeyTerm1">=</span> in assignments. Such an assignment adds the new binding to the global environment. Modify the function <span class="KeyTerm1">assign_symbol_value</span> to make assignment behave this way. The strict mode, which forbids such assignments, was introduced in JavaScript in order to make programs more secure. What security issue is addressed by preventing assignment from adding bindings to the global environment?</li>
</ol>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0046"></a><span>4.1.4</span> <a id="c004_c4-title-0047"></a>Running the Evaluator as a Program</h3>
<p class="paraaftertitle"><a id="c004_c4-para-0541"></a>Given the evaluator, we have in our hands a description (expressed in JavaScript) of the process by which JavaScript statements and expressions are evaluated. One advantage of expressing the evaluator as a program is that we can run the program. This gives us, running within JavaScript, a working model of how JavaScript itself evaluates expressions. This can serve as a framework for experimenting with evaluation rules, as we shall do later in this chapter.</p>
<p><a id="c004_c4-para-0542"></a>Our evaluator program reduces expressions ultimately to the application of primitive functions. Therefore, all that we need to run the evaluator is to create a mechanism that calls on the underlying JavaScript system to model the application of primitive functions.</p>
<p><a id="c004_c4-para-0543"></a>There must be a binding for each primitive function name and operator, so that when <span class="KeyTerm1">evaluate</span> evaluates the function expression of an application of a primitive, it will find an object to pass to <span class="KeyTerm1">apply</span>. We thus set up a global environment that associates unique objects with the names of the primitive functions and operators that can appear in the expressions we will be evaluating. The global environment also includes bindings for <span class="KeyTerm1">undefined</span> and other names, so that they can be used as constants in expressions to be evaluated.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0544"></a><b>function</b> setup_environment() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0545"></a> <b>return</b> extend_environment(append(primitive_function_symbols,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0546"></a>                                     primitive_constant_symbols),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0547"></a>                              append(primitive_function_objects,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0548"></a>                                     primitive_constant_values),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0549"></a>                              the_empty_environment);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0550"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0551"></a><b>const</b> the_global_environment = setup_environment();</p>
<p><a id="c004_c4-para-0552"></a>It does not matter how we represent primitive function objects, so long as <span class="KeyTerm1">apply</span> can identify and apply them using the functions <span class="KeyTerm1">is_primitive_function</span> and <span class="KeyTerm1">apply_primitive_function</span>. We have chosen to represent a primitive function as a list beginning with the string <span class="KeyTerm1">"primitive"</span> and containing a function in the underlying JavaScript that implements that primitive.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0553"></a><b>function</b> is_primitive_function(fun) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0554"></a> <b>return</b> is_tagged_list(fun, "primitive");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0555"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0556"></a><b>function</b> primitive_implementation(fun) { <b>return</b> head(tail(fun)); }</p>
<p><a id="c004_c4-para-0557"></a>The function <span class="KeyTerm1">setup_environment</span> will get the primitive names and implementation functions from a list:<a id="c004_c4-fn-0017a"></a><a href="#c4-fn-0017"><sup>17</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0558"></a><b>const</b> primitive_functions = list(list("head", head ),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0559"></a>                                 list("tail", tail ),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0560"></a>                                 list("pair", pair ),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0561"></a>                                 list("is_null", is_null ),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0562"></a>                                 list("+", (x, y) =&gt; x + y ),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0563"></a>                                 〈<span class="KeyTerm2"><i>more primitive functions</i></span>〉</p>
<p class="Sp-text-1"><a id="c004_c4-para-0564"></a>                                );</p>
<p class="Sp-text-1"><a id="c004_c4-para-0565"></a><b>const</b> primitive_function_symbols =</p>
<p class="Sp-text-1"><a id="c004_c4-para-0566"></a>    map(f =&gt; head(f), primitive_functions);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0567"></a><b>const</b> primitive_function_objects =</p>
<p class="Sp-text-1"><a id="c004_c4-para-0568"></a>    map(f =&gt; list("primitive", head(tail(f))),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0569"></a>        primitive_functions);</p>
<p><a id="c004_c4-para-0570"></a>Similar to primitive functions, we define other primitive constants that are installed in the global environment by the function <span class="KeyTerm1">setup_environment</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0571"></a><b>const</b> primitive_constants = list(list("undefined", undefined),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0572"></a>                                 list("math_PI", math_PI)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0573"></a>                                 〈<span class="KeyTerm2"><i>more primitive constants</i></span>〉</p>
<p class="Sp-text-1"><a id="c004_c4-para-0574"></a>                                );</p>
<p class="Sp-text-1"><a id="c004_c4-para-0575"></a><b>const</b> primitive_constant_symbols =</p>
<p class="Sp-text-1"><a id="c004_c4-para-0576"></a>    map(c =&gt; head(c), primitive_constants);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0577"></a><b>const</b> primitive_constant_values =</p>
<p class="Sp-text-1"><a id="c004_c4-para-0578"></a>    map(c =&gt; head(tail(c)), primitive_constants);</p>
<p><a id="c004_c4-para-0579"></a>To apply a primitive function, we simply apply the implementation function to the arguments, using the underlying JavaScript system:<a id="c004_c4-fn-0018a"></a><a href="#c4-fn-0018"><sup>18</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0580"></a><b>function</b> apply_primitive_function(fun, arglist) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0581"></a> <b>return</b> apply_in_underlying_javascript(</p>
<p class="Sp-text-1"><a id="c004_c4-para-0582"></a>               primitive_implementation(fun), arglist);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0583"></a>}</p>
<p><a id="c004_c4-para-0584"></a>For convenience in running the metacircular evaluator, we provide a <i>driver loop</i> that models the read-evaluate-print loop of the underlying JavaScript system. It prints a <i>prompt</i> and reads an input program as a string. It transforms the program string into a tagged-list representation of the statement as described in section 4.1.2—a process called parsing and accomplished by the primitive function <span class="KeyTerm1">parse</span>. We precede each printed result by an <i>output prompt</i> so as to distinguish the value of the program from other output that may be printed. The driver loop gets the program environment of the previous program as argument. As described at the end of section 3.2.4, the driver loop treats the program as if it were in a block: It scans out the declarations, extends the given environment by a frame containing a binding of each name to <span class="KeyTerm1">"*unassigned*"</span>, and evaluates the program with respect to the extended environment, which is then passed as argument to the next iteration of the driver loop.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0596"></a><b>const</b> input_prompt = "M-evaluate input: ";</p>
<p class="Sp-text-1"><a id="c004_c4-para-0597"></a><b>const</b> output_prompt = "M-evaluate value: ";</p>
<p class="Sp-text-1"><a id="c004_c4-para-0598"></a><b>function</b> driver_loop(env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0599"></a> <b>const</b> input = user_read(input_prompt);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0600"></a> <b>if</b> (is_null(input)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0601"></a>       display("evaluator terminated");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0602"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0603"></a> <b>const</b> program = parse(input);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0604"></a> <b>const</b> locals = scan_out_declarations(program);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0605"></a> <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0606"></a> <b>const</b> program_env = extend_environment(locals, unassigneds, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0607"></a> <b>const</b> output = evaluate(program, program_env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0608"></a>       user_print(output_prompt, output);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0609"></a> <b>return</b> driver_loop(program_env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0610"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0611"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0612"></a>We use JavaScript's <span class="KeyTerm1">prompt</span> function to request and read the input string from the user:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0613"></a><b>function</b> user_read(prompt_string) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0614"></a> <b>return</b> prompt(prompt_string);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0615"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0616"></a>The function <span class="KeyTerm1">prompt</span> returns <span class="KeyTerm1"><b>null</b></span> when the user cancels the input. We use a special printing function <span class="KeyTerm1">user_print</span>, to avoid printing the environment part of a compound function, which may be a very long list (or may even contain cycles).</p>
<p class="Sp-text-1"><a id="c004_c4-para-0617"></a><b>function</b> user_print(string, object) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0618"></a> <b>function</b> prepare(object) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0619"></a> <b>return</b> is_compound_function(object)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0620"></a>               ? "&lt; compound-function &gt;"</p>
<p class="Sp-text-1"><a id="c004_c4-para-0621"></a>               : is_primitive_function(object)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0622"></a>               ? "&lt; primitive-function &gt;"</p>
<p class="Sp-text-1"><a id="c004_c4-para-0623"></a>               : is_pair(object)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0624"></a>               ? pair(prepare(head(object)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0625"></a>                      prepare(tail(object)))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0626"></a>               : object;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0627"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0628"></a>    display(string + " " + stringify(prepare(object)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0629"></a>}</p>
<p><a id="c004_c4-para-0630"></a>Now all we need to do to run the evaluator is to initialize the global environment and start the driver loop. Here is a sample interaction:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0631"></a><b>const</b> the_global_environment = setup_environment();</p>
<p class="Sp-text-1"><a id="c004_c4-para-0632"></a>driver_loop(the_global_environment);</p>
<p class="Sp-text-3"><a id="c004_c4-para-0633"></a><i>M-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-0634"></a><b>function</b> append(xs, ys) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0635"></a> <b>return</b> is_null(xs)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0636"></a>           ? ys</p>
<p class="Sp-text-1"><a id="c004_c4-para-0637"></a>           : pair(head(xs), append(tail(xs), ys));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0638"></a>}</p>
<p class="Sp-text-3"><a id="c004_c4-para-0639"></a><i>M-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-0640"></a><i>undefined</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-0641"></a><i>M-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-0642"></a>append(list("a", "b", "c"), list("d", "e", "f"));</p>
<p class="Sp-text-3"><a id="c004_c4-para-0643"></a><i>M-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-0644"></a><i>["a", ["b", ["c", ["d", ["e", ["f", null]]]]]]</i></p>
<section>
<h5><a id="c004_c4-sec-0047"></a><a id="c004_c4-title-0048"></a>Exercise 4.14</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0645"></a>Eva Lu Ator and Louis Reasoner are each experimenting with the metacircular evaluator. Eva types in the definition of <span class="KeyTerm1">map</span>, and runs some test programs that use it. They work fine. Louis, in contrast, has installed the system version of <span class="KeyTerm1">map</span> as a primitive for the metacircular evaluator. When he tries it, things go terribly wrong. Explain why Louis's <span class="KeyTerm1">map</span> fails even though Eva's works.</p>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0048"></a><span>4.1.5</span> <a id="c004_c4-title-0049"></a>Data as Programs</h3>
<p class="paraaftertitle"><a id="c004_c4-para-0646"></a>In thinking about a JavaScript program that evaluates JavaScript statements and expressions, an analogy might be helpful. One operational view of the meaning of a program is that a program is a description of an abstract (perhaps infinitely large) machine. For example, consider the familiar program to compute factorials:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0647"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0648"></a> <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c004_c4-para-0649"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c004_c4-para-0650"></a>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0651"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0652"></a>We may regard this program as the description of a machine containing parts that decrement, multiply, and test for equality, together with a two-position switch and another factorial machine. (The factorial machine is infinite because it contains another factorial machine within it.) <a id="c004_c4-fig-0003a"></a><a href="#c4-fig-0003">Figure 4.3</a> is a flow diagram for the factorial machine, showing how the parts are wired together.</p>
<figure id="c004_c4-fig-0003"><img alt="c4-fig-0003.jpg" src="../images/c4-fig-0003.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0003a">Figure 4.3</a></span> <a id="c004_c4-para-0653"></a>The factorial program, viewed as an abstract machine.</p></figcaption></figure>
<p><a id="c004_c4-para-0654"></a>In a similar way, we can regard the evaluator as a very special machine that takes as input a description of a machine. Given this input, the evaluator configures itself to emulate the machine described. For example, if we feed our evaluator the definition of <span class="KeyTerm1">factorial</span>, as shown in <a id="c004_c4-fig-0004a"></a><a href="#c4-fig-0004">figure 4.4</a>, the evaluator will be able to compute factorials.</p>
<figure id="c004_c4-fig-0004"><img alt="c4-fig-0004.jpg" src="../images/c4-fig-0004.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0004a">Figure 4.4</a></span> <a id="c004_c4-para-0655"></a>The evaluator emulating a factorial machine.</p></figcaption></figure>
<p><a id="c004_c4-para-0656"></a>From this perspective, our evaluator is seen to be a <i>universal machine</i>. It mimics other machines when these are described as JavaScript programs.<a id="c004_c4-fn-0019a"></a><a href="#c4-fn-0019"><sup>19</sup></a> This is striking. Try to imagine an analogous evaluator for electrical circuits. This would be a circuit that takes as input a signal encoding the plans for some other circuit, such as a filter. Given this input, the circuit evaluator would then behave like a filter with the same description. Such a universal electrical circuit is almost unimaginably complex. It is remarkable that the program evaluator is a rather simple program.<a id="c004_c4-fn-0020a"></a><a href="#c4-fn-0020"><sup>20</sup></a></p>
<p><a id="c004_c4-para-0657"></a>Another striking aspect of the evaluator is that it acts as a bridge between the data objects that are manipulated by our programming language and the programming language itself. Imagine that the evaluator program (implemented in JavaScript) is running, and that a user is typing programs to the evaluator and observing the results. From the perspective of the user, an input program such as <span class="KeyTerm1">x * x;</span> is a program in the programming language, which the evaluator should execute. From the perspective of the evaluator, however, the program is simply a string or—after parsing—a tagged-list representation that is to be manipulated according to a well-defined set of rules.</p>
<p><a id="c004_c4-para-0658"></a>That the user's programs are the evaluator's data need not be a source of confusion. In fact, it is sometimes convenient to ignore this distinction, and to give the user the ability to explicitly evaluate a string as a JavaScript statement, using JavaScript's primitive function <span class="KeyTerm1">eval</span> that takes as argument a string. It parses the string and—provided that it is syntactically correct—evaluates the resulting representation in the environment in which <span class="KeyTerm1">eval</span> is applied. Thus,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0659"></a>eval("5 * 5;");</p>
<p class="paracontinue"><a id="c004_c4-para-0660"></a>and</p>
<p class="Sp-text-1"><a id="c004_c4-para-0661"></a>evaluate(parse("5 * 5;"), the_global_environment);</p>
<p class="paracontinue"><a id="c004_c4-para-0662"></a>will both return 25.<a id="c004_c4-fn-0021a"></a><a href="#c4-fn-0021"><sup>21</sup></a></p>
<section>
<h5><a id="c004_c4-sec-0049"></a><a id="c004_c4-title-0050"></a>Exercise 4.15</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0663"></a>Given a one-argument function <span class="KeyTerm1">f</span> and an object <span class="KeyTerm1">a</span>, <span class="KeyTerm1">f</span> is said to “halt” on <span class="KeyTerm1">a</span> if evaluating the expression <span class="KeyTerm1">f(a)</span> returns a value (as opposed to terminating with an error message or running forever). Show that it is impossible to write a function <span class="KeyTerm1">halts</span> that correctly determines whether <span class="KeyTerm1">f</span> halts on <span class="KeyTerm1">a</span> for any function <span class="KeyTerm1">f</span> and object <span class="KeyTerm1">a</span>. Use the following reasoning: If you had such a function <span class="KeyTerm1">halts</span>, you could implement the following program:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0664"></a><b>function</b> run_forever() { <b>return</b> run_forever(); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0665"></a><b>function</b> strange(f) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0666"></a> <b>return</b> halts(f, f)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0667"></a>           ? run_forever();</p>
<p class="Sp-text-1"><a id="c004_c4-para-0668"></a>           : "halted";</p>
<p class="Sp-text-1"><a id="c004_c4-para-0669"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0670"></a>Now consider evaluating the expression <span class="KeyTerm1">strange(strange)</span> and show that any possible outcome (either halting or running forever) violates the intended behavior of <span class="KeyTerm1">halts</span>.<a id="c004_c4-fn-0022a"></a><a href="#c4-fn-0022"><sup>22</sup></a></p>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0050"></a><span>4.1.6</span> <a id="c004_c4-title-0051"></a>Internal Declarations</h3>
<p class="paraaftertitle"><a id="c004_c4-para-0671"></a>In JavaScript, the scope of a declaration is the entire block that immediately surrounds the declaration, not just the portion of the block starting at the point where the declaration occurs. This section takes a closer look at this design choice.</p>
<p><a id="c004_c4-para-0672"></a>Let us revisit the pair of mutually recursive functions <span class="KeyTerm1">is_even</span> and <span class="KeyTerm1">is_odd</span> from Section 3.2.4, declared locally in the body of a function <span class="KeyTerm1">f</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0673"></a><b>function</b> f(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0674"></a> <b>function</b> is_even(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0675"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c004_c4-para-0676"></a>               ? <b>true</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-0677"></a>               : is_odd(n - 1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0678"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0679"></a> <b>function</b> is_odd(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0680"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c004_c4-para-0681"></a>               ? <b>false</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-0682"></a>               : is_even(n - 1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0683"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0684"></a> <b>return</b> is_even(x);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0685"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0686"></a>Our intention here is that the name <span class="KeyTerm1">is_odd</span> in the body of the function <span class="KeyTerm1">is_even</span> should refer to the function <span class="KeyTerm1">is_odd</span> that is declared after <span class="KeyTerm1">is_even</span>. The scope of the name <span class="KeyTerm1">is_odd</span> is the entire body block of <span class="KeyTerm1">f</span>, not just the portion of the body of <span class="KeyTerm1">f</span> starting at the point where the declaration of <span class="KeyTerm1">is_odd</span> occurs. Indeed, when we consider that <span class="KeyTerm1">is_odd</span> is itself defined in terms of <span class="KeyTerm1">is_even</span>—so that <span class="KeyTerm1">is_even</span> and <span class="KeyTerm1">is_odd</span> are mutually recursive functions—we see that the only satisfactory interpretation of the two declarations is to regard them as if the names <span class="KeyTerm1">is_even</span> and <span class="KeyTerm1">is_odd</span> were being added to the environment simultaneously. More generally, in block structure, the scope of a local name is the entire block in which the declaration is evaluated.</p>
<p><a id="c004_c4-para-0687"></a>The evaluation of blocks in the metacircular evaluator of section 4.1.1 achieves such a simultaneous scope for local names by scanning out the declarations in the block and extending the current environment with a frame containing bindings for all the declared names before evaluating the declarations. Thus the new environment in which the block body is evaluated already contains bindings for <span class="KeyTerm1">is_even</span> and <span class="KeyTerm1">is_odd</span>, and any occurrence of one of these names refers to the correct binding. Once their declarations are evaluated, these names are bound to their declared values, namely function objects that have the extended environment as their environment part. Thus, for example, by the time <span class="KeyTerm1">is_even</span> gets applied in the body of <span class="KeyTerm1">f</span>, its environment already contains the correct binding for the symbol <span class="KeyTerm1">is_odd</span>, and the evaluation of the name <span class="KeyTerm1">is_odd</span> in the body of <span class="KeyTerm1">is_even</span> retrieves the correct value.</p>
<section>
<h5><a id="c004_c4-sec-0051"></a><a id="c004_c4-title-0052"></a>Exercise 4.16</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0688"></a>Consider the function <span class="KeyTerm1">f_3</span> of section 1.3.2:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0689"></a><b>function</b> f_3(x, y) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0690"></a> <b>const</b> a = 1 + x * y;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0691"></a> <b>const</b> b = 1 - y;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0692"></a> <b>return</b> x * square(a) + y * b + a * b;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0693"></a>}</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0047"></a><span>a. </span>Draw a diagram of the environment in effect during evaluation of the return expression of <span class="KeyTerm1">f_3</span>.</li>
<li><a id="c004_c4-li-0048"></a><span>b. </span>When evaluating a function application, the evaluator creates two frames: one for the parameters and one for the names declared <i>directly</i> in the function's body block, as opposed to in an inner block. Since all these names have the same scope, an implementation could combine the two frames. Change the evaluator such that the evaluation of the body block does not create a new frame. You may assume that this will not result in duplicate names in the frame (exercise 4.5 justifies this).</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0052"></a><a id="c004_c4-title-0053"></a>Exercise 4.17</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0696"></a>Eva Lu Ator is writing programs in which function declarations and other statements are interleaved. She needs to make sure that the declarations are evaluated before the functions are applied. She complains: “Why can't the evaluator take care of this chore, and hoist all function declarations to the beginning of the block in which they appear? Function declarations outside of blocks should be hoisted to the beginning of the program.”</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0049"></a><span>a. </span>Modify the evaluator following Eva's suggestion.</li>
<li><a id="c004_c4-li-0050"></a><span>b. </span>The designers of JavaScript decided to follow Eva's approach. Discuss this decision.</li>
<li><a id="c004_c4-li-0051"></a><span>c. </span>In addition, the designers of JavaScript decided to allow the name declared by a function declaration to be reassigned using assignment. Modify your solution accordingly and discuss this decision.</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0053"></a><a id="c004_c4-title-0054"></a>Exercise 4.18</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0700"></a>Recursive functions are obtained in a roundabout way in our interpreter: First declare the name that will refer to the recursive function and assign to it the special value <span class="KeyTerm1">"*unassigned*"</span>; then define the recursive function in the scope of that name; and finally assign the defined function to the name. By the time the recursive function gets applied, any occurrences of the name in the body properly refer to the recursive function. Amazingly, it is possible to specify recursive functions without using declarations or assignment. The following program computes 10 factorial by applying a recursive factorial function:<a id="c004_c4-fn-0023a"></a><a href="#c4-fn-0023"><sup>23</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0701"></a>(n =&gt; (fact =&gt; fact(fact, n))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0702"></a>      ((ft, k) =&gt; k === 1</p>
<p class="Sp-text-1"><a id="c004_c4-para-0703"></a>                  ? 1</p>
<p class="Sp-text-1"><a id="c004_c4-para-0704"></a>                  : k * ft(ft, k - 1)))(10);</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0052"></a><span>a. </span>Check (by evaluating the expression) that this really does compute factorials. Devise an analogous expression for computing Fibonacci numbers.</li>
<li><a id="c004_c4-li-0053"></a><span>b. </span>Consider the function <span class="KeyTerm1">f</span> given above:
<p class="Sp-text-1"><a id="c004_c4-para-0707"></a><b>function</b> f(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0708"></a> <b>function</b> is_even(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0709"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c004_c4-para-0710"></a>               ? <b>true</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-0711"></a>               : is_odd(n - 1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0712"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0713"></a> <b>function</b> is_odd(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0714"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c004_c4-para-0715"></a>               ? <b>false</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-0716"></a>               : is_even(n - 1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0717"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0718"></a> <b>return</b> is_even(x);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0719"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0720"></a>Fill in the missing expressions to complete an alternative declaration of <span class="KeyTerm1">f</span>, which has no internal function declarations:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0721"></a><b>function</b> f(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0722"></a> <b>return</b> ((is_even, is_odd) =&gt; is_even(is_even, is_odd, x))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0723"></a>           ((is_ev, is_od, n) =&gt; n === 0 ? <b>true</b> : is_od(〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0724"></a>            (is_ev, is_od, n) =&gt; n === 0 ? <b>false</b> : is_ev( 〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0725"></a><sub>}</sub></p></li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0054"></a><a id="c004_c4-title-0055"></a>Sequential Declaration Processing</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0726"></a>The design of our evaluator of section 4.1.1 imposes a runtime burden on the evaluation of blocks: It needs to scan the body of the block for locally declared names, extend the current environment with a new frame that binds those names, and evaluate the block body in this extended environment. Alternatively, the evaluation of a block could extend the current environment with an empty frame. The evaluation of each declaration in the block body would then add a new binding to that frame. To implement this design, we first simplify <span class="KeyTerm1">eval_block</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0727"></a><b>function</b> eval_block(component, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0728"></a> <b>const</b> body = block_body(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0729"></a> <b>return</b> evaluate(body, extend_environment(<b>null</b>, <b>null</b>, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0730"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0731"></a>The function <span class="KeyTerm1">eval_declaration</span> can no longer assume that the environment already has a binding for the name. Instead of using <span class="KeyTerm1">assign_symbol_value</span> to change an existing binding, it calls a new function, <span class="KeyTerm1">add_binding_to_frame</span>, to add to the first frame of the environment a binding of the name to the value of the value expression.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0732"></a><b>function</b> eval_declaration(component, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0733"></a>    add_binding_to_frame(</p>
<p class="Sp-text-1"><a id="c004_c4-para-0734"></a>        declaration_symbol(component),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0735"></a>        evaluate(declaration_value_expression(component), env),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0736"></a>        first_frame(env));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0737"></a> <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0738"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0739"></a><b>function</b> add_binding_to_frame(symbol, value, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0740"></a>    set_head(frame, pair(symbol, head(frame)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0741"></a>    set_tail(frame, pair(value, tail(frame)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0742"></a>}</p>
<p><a id="c004_c4-para-0743"></a>With sequential declaration processing, the scope of a declaration is no longer the entire block that immediately surrounds the declaration, but rather just the portion of the block starting at the point where the declaration occurs. Although we no longer have simultaneous scope, sequential declaration processing will evaluate calls to the function <span class="KeyTerm1">f</span> at the beginning of this section correctly, but for an “accidental” reason: Since the declarations of the internal functions come first, no calls to these functions will be evaluated until all of them have been declared. Hence, <span class="KeyTerm1">is_odd</span> will have been declared by the time <span class="KeyTerm1">is_even</span> is executed. In fact, sequential declaration processing will give the same result as our scanning-out-names evaluator in section 4.1.1 for any function in which the internal declarations come first in a body and evaluation of the value expressions for the declared names doesn't actually use any of the declared names. Exercise 4.19 shows an example of a function that doesn't obey these restrictions, so that the alternative evaluator isn't equivalent to our scanning-out-names evaluator.</p>
<p><a id="c004_c4-para-0744"></a>Sequential declaration processing is more efficient and easier to implement than scanning out names. However, with sequential processing, the declaration to which a name refers may depend on the order in which the statements in a block are evaluated. In exercise 4.19, we see that views may differ as to whether that is desirable.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0055"></a><a id="c004_c4-title-0056"></a>Exercise 4.19</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0745"></a>Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are arguing about the desired result of evaluating the program</p>
<p class="Sp-text-1"><a id="c004_c4-para-0746"></a><b>const</b> a = 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0747"></a><b>function</b> f(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0748"></a> <b>const</b> b = a + x;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0749"></a> <b>const</b> a = 5;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0750"></a> <b>return</b> a + b;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0751"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0752"></a>f(10);</p>
<p class="paracontinue"><a id="c004_c4-para-0753"></a>Ben asserts that the result should be obtained using the sequential processing of declarations: <span class="KeyTerm1">b</span> is declared to be 11, then <span class="KeyTerm1">a</span> is declared to be 5, so the result is 16. Alyssa objects that mutual recursion requires the simultaneous scope rule for internal function declarations, and that it is unreasonable to treat function names differently from other names. Thus, she argues for the mechanism implemented in section 4.1.1. This would lead to <span class="KeyTerm1">a</span> being unassigned at the time that the value for <span class="KeyTerm1">b</span> is to be computed. Hence, in Alyssa's view the function should produce an error. Eva has a third opinion. She says that if the declarations of <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> are truly meant to be simultaneous, then the value 5 for <span class="KeyTerm1">a</span> should be used in evaluating <span class="KeyTerm1">b</span>. Hence, in Eva's view <span class="KeyTerm1">a</span> should be 5, <span class="KeyTerm1">b</span> should be 15, and the result should be 20. Which (if any) of these viewpoints do you support? Can you devise a way to implement internal declarations so that they behave as Eva prefers?<a id="c004_c4-fn-0024a"></a><a href="#c4-fn-0024"><sup>24</sup></a></p>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0056"></a><span>4.1.7</span> <a id="c004_c4-title-0057"></a>Separating Syntactic Analysis from Execution</h3>
<p class="paraaftertitle"><a id="c004_c4-para-0754"></a>The evaluator implemented above is simple, but it is very inefficient, because the syntactic analysis of components is interleaved with their execution. Thus if a program is executed many times, its syntax is analyzed many times. Consider, for example, evaluating <span class="KeyTerm1">factorial(4)</span> using the following definition of <span class="KeyTerm1">factorial</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0755"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0756"></a> <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c004_c4-para-0757"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c004_c4-para-0758"></a>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0759"></a>}</p>
<p><a id="c004_c4-para-0760"></a>Each time <span class="KeyTerm1">factorial</span> is called, the evaluator must determine that the body is a conditional expression and extract the predicate. Only then can it evaluate the predicate and dispatch on its value. Each time it evaluates the expression <span class="KeyTerm1">factorial(n - 1) * n</span>, or the subexpressions <span class="KeyTerm1">factorial(n - 1)</span> and <span class="KeyTerm1">n - 1</span>, the evaluator must perform the case analysis in <span class="KeyTerm1">evaluate</span> to determine that the expression is an application, and must extract its function expression and argument expressions. This analysis is expensive. Performing it repeatedly is wasteful.</p>
<p><a id="c004_c4-para-0761"></a>We can transform the evaluator to be significantly more efficient by arranging things so that syntactic analysis is performed only once.<a id="c004_c4-fn-0025a"></a><a href="#c4-fn-0025"><sup>25</sup></a> We split <span class="KeyTerm1">evaluate</span>, which takes a component and an environment, into two parts. The function <span class="KeyTerm1">analyze</span> takes only the component. It performs the syntactic analysis and returns a new function, the <i>execution function</i>, that encapsulates the work to be done in executing the analyzed component. The execution function takes an environment as its argument and completes the evaluation. This saves work because <span class="KeyTerm1">analyze</span> will be called only once on a component, while the execution function may be called many times.</p>
<p><a id="c004_c4-para-0762"></a>With the separation into analysis and execution, <span class="KeyTerm1">evaluate</span> now becomes</p>
<p class="Sp-text-1"><a id="c004_c4-para-0763"></a><b>function</b> evaluate(component, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0764"></a> <b>return</b> analyze(component)(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0765"></a>}</p>
<p><a id="c004_c4-para-0766"></a>The result of calling <span class="KeyTerm1">analyze</span> is the execution function to be applied to the environment. The <span class="KeyTerm1">analyze</span> function is the same case analysis as performed by the original <span class="KeyTerm1">evaluate</span> of section 4.1.1, except that the functions to which we dispatch perform only analysis, not full evaluation:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0767"></a><b>function</b> analyze(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0768"></a> <b>return</b> is_literal(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0769"></a>           ? analyze_literal(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0770"></a>           : is_name(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0771"></a>           ? analyze_name(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0772"></a>           : is_application(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0773"></a>           ? analyze_application(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0774"></a>           : is_operator_combination(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0775"></a>           ? analyze(operator_combination_to_application(component))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0776"></a>           : is_conditional(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0777"></a>           ? analyze_conditional(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0778"></a>           : is_lambda_expression(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0779"></a>           ? analyze_lambda_expression(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0780"></a>           : is_sequence(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0781"></a>           ? analyze_sequence(sequence_statements(component))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0782"></a>           : is_block(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0783"></a>           ? analyze_block(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0784"></a>           : is_return_statement(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0785"></a>           ? analyze_return_statement(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0786"></a>           : is_function_declaration(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0787"></a>           ? analyze(function_decl_to_constant_decl(component))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0788"></a>           : is_declaration(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0789"></a>           ? analyze_declaration(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0790"></a>           : is_assignment(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0791"></a>           ? analyze_assignment(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0792"></a>           : error(component, "unknown syntax – analyze");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0793"></a>}</p>
<p><a id="c004_c4-para-0794"></a>Here is the simplest syntactic analysis function, which handles literal expressions. It returns an execution function that ignores its environment argument and just returns the value of the literal:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0795"></a><b>function</b> analyze_literal(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0796"></a> <b>return</b> env =&gt; literal_value(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0797"></a>}</p>
<p><a id="c004_c4-para-0798"></a>Looking up the value of a name must still be done in the execution phase, since this depends upon knowing the environment.<a id="c004_c4-fn-0026a"></a><a href="#c4-fn-0026"><sup>26</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-0799"></a><b>function</b> analyze_name(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0800"></a> <b>return</b> env =&gt; lookup_symbol_value(symbol_of_name(component), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0801"></a>}</p>
<p><a id="c004_c4-para-0802"></a>To analyze an application, we analyze the function expression and argument expressions and construct an execution function that calls the execution function of the function expression (to obtain the actual function to be applied) and the argument-expression execution functions (to obtain the actual arguments). We then pass these to <span class="KeyTerm1">execute_application</span>, which is the analog of <span class="KeyTerm1">apply</span> in section 4.1.1. The function <span class="KeyTerm1">execute_application</span> differs from <span class="KeyTerm1">apply</span> in that the function body for a compound function has already been analyzed, so there is no need to do further analysis. Instead, we just call the execution function for the body on the extended environment.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0803"></a><b>function</b> analyze_application(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0804"></a> <b>const</b> ffun = analyze(function_expression(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0805"></a> <b>const</b> afuns = map(analyze, arg_expressions(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0806"></a> <b>return</b> env =&gt; execute_application(ffun(env),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0807"></a>                                      map(afun =&gt; afun(env), afuns));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0808"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0809"></a><b>function</b> execute_application(fun, args) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0810"></a> <b>if</b> (is_primitive_function(fun)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0811"></a> <b>return</b> apply_primitive_function(fun, args);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0812"></a>    } <b>else if</b> (is_compound_function(fun)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0813"></a> <b>const</b> result = function_body(fun)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0814"></a>                       (extend_environment(function_parameters(fun),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0815"></a>                                           args,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0816"></a>                                           function_environment(fun)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0817"></a> <b>return</b> is_return_value(result)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0818"></a>               ? return_value_content(result)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0819"></a>               : undefined;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0820"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0821"></a>        error(fun, "unknown function type – execute_application");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0822"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0823"></a>}</p>
<p><a id="c004_c4-para-0824"></a>For conditionals, we extract and analyze the predicate, consequent, and alternative at analysis time.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0825"></a><b>function</b> analyze_conditional(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0826"></a> <b>const</b> pfun = analyze(conditional_predicate(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0827"></a> <b>const</b> cfun = analyze(conditional_consequent(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0828"></a> <b>const</b> afun = analyze(conditional_alternative(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0829"></a> <b>return</b> env =&gt; is_truthy(pfun(env)) ? cfun(env) : afun(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0830"></a>}</p>
<p><a id="c004_c4-para-0831"></a>Analyzing a lambda expression also achieves a major gain in efficiency: We analyze the lambda body only once, even though functions resulting from evaluation of the lambda expression may be applied many times.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0832"></a><b>function</b> analyze_lambda_expression(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0833"></a> <b>const</b> params = lambda_parameter_symbols(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0834"></a> <b>const</b> bfun = analyze(lambda_body(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0835"></a> <b>return</b> env =&gt; make_function(params, bfun, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0836"></a>}</p>
<p><a id="c004_c4-para-0837"></a>Analysis of a sequence of statements is more involved.<a id="c004_c4-fn-0027a"></a><a href="#c4-fn-0027"><sup>27</sup></a> Each statement in the sequence is analyzed, yielding an execution function. These execution functions are combined to produce an execution function that takes an environment as argument and sequentially calls each individual execution function with the environment as argument.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0838"></a><b>function</b> analyze_sequence(stmts) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0839"></a> <b>function</b> sequentially(fun1, fun2) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0840"></a> <b>return</b> env =&gt; {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0841"></a> <b>const</b> fun1_val = fun1(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0842"></a> <b>return</b> is_return_value(fun1_val)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0843"></a>                          ? fun1_val</p>
<p class="Sp-text-1"><a id="c004_c4-para-0844"></a>                          : fun2(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0845"></a>               };</p>
<p class="Sp-text-1"><a id="c004_c4-para-0846"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0847"></a> <b>function</b> loop(first_fun, rest_funs) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0848"></a> <b>return</b> is_null(rest_funs)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0849"></a>               ? first_fun</p>
<p class="Sp-text-1"><a id="c004_c4-para-0850"></a>               : loop(sequentially(first_fun, head(rest_funs)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0851"></a>                      tail(rest_funs));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0852"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0853"></a> <b>const</b> funs = map(analyze, stmts);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0854"></a> <b>return</b> is_null(funs)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0855"></a>           ? env =&gt; undefined</p>
<p class="Sp-text-1"><a id="c004_c4-para-0856"></a>           : loop(head(funs), tail(funs));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0857"></a>}</p>
<p><a id="c004_c4-para-0858"></a>The body of a block is scanned only once for local declarations. The bindings are installed in the environment when the execution function for the block is called.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0859"></a><b>function</b> analyze_block(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0860"></a> <b>const</b> body = block_body(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0861"></a> <b>const</b> bfun = analyze(body);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0862"></a> <b>const</b> locals = scan_out_declarations(body);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0863"></a> <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0864"></a> <b>return</b> env =&gt; bfun(extend_environment(locals, unassigneds, env));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0865"></a>}</p>
<p><a id="c004_c4-para-0866"></a>For return statements, we analyze the return expression. The execution function for the return statement simply calls the execution function for the return expression and wraps the result in a return value.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0867"></a><b>function</b> analyze_return_statement(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0868"></a> <b>const</b> rfun = analyze(return_expression(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0869"></a> <b>return</b> env =&gt; make_return_value(rfun(env));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0870"></a>}</p>
<p><a id="c004_c4-para-0871"></a>The function <span class="KeyTerm1">analyze_assignment</span> must defer actually setting the variable until the execution, when the environment has been supplied. However, the fact that the assignment-value expression can be analyzed (recursively) during analysis is a major gain in efficiency, because the assignment-value expression will now be analyzed only once. The same holds true for constant and variable declarations.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0872"></a><b>function</b> analyze_assignment(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0873"></a> <b>const</b> symbol = assignment_symbol(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0874"></a> <b>const</b> vfun = analyze(assignment_value_expression(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0875"></a> <b>return</b> env =&gt; {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0876"></a> <b>const</b> value = vfun(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0877"></a>               assign_symbol_value(symbol, value, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0878"></a> <b>return</b> value;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0879"></a>           };</p>
<p class="Sp-text-1"><a id="c004_c4-para-0880"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0881"></a><b>function</b> analyze_declaration(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0882"></a> <b>const</b> symbol = declaration_symbol(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0883"></a> <b>const</b> vfun = analyze(declaration_value_expression(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0884"></a> <b>return</b> env =&gt; {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0885"></a>               assign_symbol_value(symbol, vfun(env), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0886"></a> <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0887"></a>           };</p>
<p class="Sp-text-1"><a id="c004_c4-para-0888"></a>}</p>
<p><a id="c004_c4-para-0889"></a>Our new evaluator uses the same data structures, syntax functions, and runtime support functions as in sections 4.1.2, 4.1.3, and 4.1.4.</p>
<section>
<h5><a id="c004_c4-sec-0057"></a><a id="c004_c4-title-0058"></a>Exercise 4.20</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0890"></a>Extend the evaluator in this section to support while loops. (See exercise 4.7.)</p>
</section>
<section>
<h5><a id="c004_c4-sec-0058"></a><a id="c004_c4-title-0059"></a>Exercise 4.21</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0891"></a>Alyssa P. Hacker doesn't understand why <span class="KeyTerm1">analyze_sequence</span> needs to be so complicated. All the other analysis functions are straightforward transformations of the corresponding evaluation functions (or <span class="KeyTerm1">evaluate</span> clauses) in section 4.1.1. She expected <span class="KeyTerm1">analyze_sequence</span> to look like this:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0892"></a><b>function</b> analyze_sequence(stmts) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0893"></a> <b>function</b> execute_sequence(funs, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0894"></a> <b>if</b> (is_null(funs)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0895"></a> <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0896"></a>        } <b>else if</b> (is_null(tail(funs))) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0897"></a> <b>return</b> head(funs)(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0898"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0899"></a> <b>const</b> head_val = head(funs)(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0900"></a> <b>return</b> is_return_value(head_val)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0901"></a>                   ? head_val</p>
<p class="Sp-text-1"><a id="c004_c4-para-0902"></a>                   : execute_sequence(tail(funs), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0903"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0904"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0905"></a> <b>const</b> funs = map(analyze, stmts);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0906"></a> <b>return</b> env =&gt; execute_sequence(funs, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0907"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0908"></a>Eva Lu Ator explains to Alyssa that the version in the text does more of the work of evaluating a sequence at analysis time. Alyssa's sequence-execution function, rather than having the calls to the individual execution functions built in, loops through the functions in order to call them: In effect, although the individual statements in the sequence have been analyzed, the sequence itself has not been.</p>
<p><a id="c004_c4-para-0909"></a>Compare the two versions of <span class="KeyTerm1">analyze_sequence</span>. For example, consider the common case (typical of function bodies) where the sequence has just one statement. What work will the execution function produced by Alyssa's program do? What about the execution function produced by the program in the text above? How do the two versions compare for a sequence with two expressions?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0059"></a><a id="c004_c4-title-0060"></a>Exercise 4.22</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0910"></a>Design and carry out some experiments to compare the speed of the original metacircular evaluator with the version in this section. Use your results to estimate the fraction of time that is spent in analysis versus execution for various functions.</p>
</section>
</section>
</section>
<section>
<h2><a id="c004_c4-sec-0060"></a><span>4.2</span> <a id="c004_c4-title-0061"></a>Lazy Evaluation</h2>
<p class="paraaftertitle"><a id="c004_c4-para-0911"></a>Now that we have an evaluator expressed as a JavaScript program, we can experiment with alternative choices in language design simply by modifying the evaluator. Indeed, new languages are often invented by first writing an evaluator that embeds the new language within an existing high-level language. For example, if we wish to discuss some aspect of a proposed modification to JavaScript with another member of the JavaScript community, we can supply an evaluator that embodies the change. The recipient can then experiment with the new evaluator and send back comments as further modifications. Not only does the high-level implementation base make it easier to test and debug the evaluator; in addition, the embedding enables the designer to snarf<a id="c004_c4-fn-0028a"></a><a href="#c4-fn-0028"><sup>28</sup></a> features from the underlying language, just as our embedded JavaScript evaluator uses primitives and control structure from the underlying JavaScript. Only later (if ever) need the designer go to the trouble of building a complete implementation in a low-level language or in hardware. In this section and the next we explore some variations on JavaScript that provide significant additional expressive power.</p>
<section>
<h3><a id="c004_c4-sec-0061"></a><span>4.2.1</span> <a id="c004_c4-title-0062"></a>Normal Order and Applicative Order</h3>
<p class="paraaftertitle"><a id="c004_c4-para-0912"></a>In section 1.1, where we began our discussion of models of evaluation, we noted that JavaScript is an <i>applicative-order</i> language, namely, that all the arguments to JavaScript functions are evaluated when the function is applied. In contrast, <i>normalorder</i> languages delay evaluation of function arguments until the actual argument values are needed. Delaying evaluation of function arguments until the last possible moment (e.g., until they are required by a primitive operation) is called <i>lazy evaluation</i>.<a id="c004_c4-fn-0029a"></a><a href="#c4-fn-0029"><sup>29</sup></a> Consider the function</p>
<p class="Sp-text-1"><a id="c004_c4-para-0913"></a><b>function</b> try_me(a, b) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0914"></a> <b>return</b> a === 0 ? 1 : b;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0915"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0916"></a>Evaluating <span class="KeyTerm1">try_me(0, head(<b>null</b>));</span> signals an error in JavaScript. With lazy evaluation, there would be no error. Evaluating the statement would return 1, because the argument <span class="KeyTerm1">head(<b>null</b>)</span> would never be evaluated.</p>
<p><a id="c004_c4-para-0917"></a>An example that exploits lazy evaluation is the declaration of a function <span class="KeyTerm1">unless</span></p>
<p class="Sp-text-1"><a id="c004_c4-para-0918"></a><b>function</b> unless(condition, usual_value, exceptional_value) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0919"></a> <b>return</b> condition ? exceptional_value : usual_value;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0920"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0921"></a>that can be used in statements such as</p>
<p class="Sp-text-1"><a id="c004_c4-para-0922"></a>unless(is_null(xs), head(xs), display("error: xs should not be null"));</p>
<p class="paracontinue"><a id="c004_c4-para-0923"></a>This won't work in an applicative-order language because both the usual value and the exceptional value will be evaluated before <span class="KeyTerm1">unless</span> is called (compare exercise 1.6). An advantage of lazy evaluation is that some functions, such as <span class="KeyTerm1">unless</span>, can do useful computation even if evaluation of some of their arguments would produce errors or would not terminate.</p>
<p><a id="c004_c4-para-0924"></a>If the body of a function is entered before an argument has been evaluated we say that the function is <i>non-strict</i> in that argument. If the argument is evaluated before the body of the function is entered we say that the function is <i>strict</i> in that argument.<a id="c004_c4-fn-0030a"></a><a href="#c4-fn-0030"><sup>30</sup></a> In a purely applicative-order language, all functions are strict in each argument. In a purely normal-order language, all compound functions are non-strict in each argument, and primitive functions may be either strict or non-strict. There are also languages (see exercise 4.29) that give programmers detailed control over the strictness of the functions they define.</p>
<p><a id="c004_c4-para-0925"></a>A striking example of a function that can usefully be made non-strict is <span class="KeyTerm1">pair</span> (or, in general, almost any constructor for data structures). One can do useful computation, combining elements to form data structures and operating on the resulting data structures, even if the values of the elements are not known. It makes perfect sense, for instance, to compute the length of a list without knowing the values of the individual elements in the list. We will exploit this idea in section 4.2.3 to implement the streams of chapter 3 as lists formed of non-strict pairs.</p>
<section>
<h5><a id="c004_c4-sec-0062"></a><a id="c004_c4-title-0063"></a>Exercise 4.23</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0926"></a>Suppose that (in ordinary applicative-order JavaScript) we define <span class="KeyTerm1">unless</span> as shown above and then define <span class="KeyTerm1">factorial</span> in terms of <span class="KeyTerm1">unless</span> as</p>
<p class="Sp-text-1"><a id="c004_c4-para-0927"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0928"></a> <b>return</b> unless(n === 1,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0929"></a>                  n * factorial(n - 1),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0930"></a>                  1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0931"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0932"></a>What happens if we attempt to evaluate <span class="KeyTerm1">factorial(5)</span>? Will our functions work in a normal-order language?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0063"></a><a id="c004_c4-title-0064"></a>Exercise 4.24</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0933"></a>Ben Bitdiddle and Alyssa P. Hacker disagree over the importance of lazy evaluation for implementing things such as <span class="KeyTerm1">unless</span>. Ben points out that it's possible to implement <span class="KeyTerm1">unless</span> in applicative order as a syntactic form. Alyssa counters that, if one did that, <span class="KeyTerm1">unless</span> would be merely syntax, not a function that could be used in conjunction with higher-order functions. Fill in the details on both sides of the argument. Show how to implement <span class="KeyTerm1">unless</span> as a derived component (like operator combination), by catching in <span class="KeyTerm1">evaluate</span> applications whose function expression is the name <span class="KeyTerm1">unless</span>. Give an example of a situation where it might be useful to have <span class="KeyTerm1">unless</span> available as a function, rather than as a syntactic form.</p>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0064"></a><span>4.2.2</span> <a id="c004_c4-title-0065"></a>An Interpreter with Lazy Evaluation</h3>
<p class="paraaftertitle"><a id="c004_c4-para-0934"></a>In this section we will implement a normal-order language that is the same as JavaScript except that compound functions are non-strict in each argument. Primitive functions will still be strict. It is not difficult to modify the evaluator of section 4.1.1 so that the language it interprets behaves this way. Almost all the required changes center around function application.</p>
<p><a id="c004_c4-para-0935"></a>The basic idea is that, when applying a function, the interpreter must determine which arguments are to be evaluated and which are to be delayed. The delayed arguments are not evaluated; instead, they are transformed into objects called <i>thunk</i>s.<a id="c004_c4-fn-0031a"></a><a href="#c4-fn-0031"><sup>31</sup></a> The thunk must contain the information required to produce the value of the argument when it is needed, as if it had been evaluated at the time of the application. Thus, the thunk must contain the argument expression and the environment in which the function application is being evaluated.</p>
<p><a id="c004_c4-para-0936"></a>The process of evaluating the expression in a thunk is called <i>forcing</i>.<a id="c004_c4-fn-0032a"></a><a href="#c4-fn-0032"><sup>32</sup></a> In general, a thunk will be forced only when its value is needed: when it is passed to a primitive function that will use the value of the thunk; when it is the value of a predicate of a conditional; and when it is the value of a function expression that is about to be applied as a function. One design choice we have available is whether or not to <i>memoize</i> thunks, similar to the optimization for streams in section 3.5.1. With memoization, the first time a thunk is forced, it stores the value that is computed. Subsequent forcings simply return the stored value without repeating the computation. We'll make our interpreter memoize, because this is more efficient for many applications. There are tricky considerations here, however.<a id="c004_c4-fn-0033a"></a><a href="#c4-fn-0033"><sup>33</sup></a></p>
<section>
<h5><a id="c004_c4-sec-0065"></a><a id="c004_c4-title-0066"></a>Modifying the evaluator</h5>
<p class="paraaftertitle"><a id="c004_c4-para-0937"></a>The main difference between the lazy evaluator and the one in section 4.1 is in the handling of function applications in <span class="KeyTerm1">evaluate</span> and <span class="KeyTerm1">apply</span>.</p>
<p><a id="c004_c4-para-0938"></a>The <span class="KeyTerm1">is_application</span> clause of <span class="KeyTerm1">evaluate</span> becomes</p>
<p class="Sp-text-1"><a id="c004_c4-para-0939"></a>: is_application(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0940"></a>? apply(actual_value(function_expression(component), env),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0941"></a>        arg_expressions(component), env)</p>
<p class="paracontinue"><a id="c004_c4-para-0942"></a>This is almost the same as the <span class="KeyTerm1">is_application</span> clause of <span class="KeyTerm1">evaluate</span> in section 4.1.1. For lazy evaluation, however, we call <span class="KeyTerm1">apply</span> with the argument expressions, rather than the arguments produced by evaluating them. Since we will need the environment to construct thunks if the arguments are to be delayed, we must pass this as well. We still evaluate the function expression, because <span class="KeyTerm1">apply</span> needs the actual function to be applied in order to dispatch on its type (primitive versus compound) and apply it.</p>
<p><a id="c004_c4-para-0944"></a>Whenever we need the actual value of an expression, we use</p>
<p class="Sp-text-1"><a id="c004_c4-para-0945"></a><b>function</b> actual_value(exp, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0946"></a> <b>return</b> force_it(evaluate(exp, env));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0947"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0948"></a>instead of just <span class="KeyTerm1">evaluate</span>, so that if the expression's value is a thunk, it will be forced.</p>
<p><a id="c004_c4-para-0949"></a>Our new version of <span class="KeyTerm1">apply</span> is also almost the same as the version in section 4.1.1. The difference is that <span class="KeyTerm1">evaluate</span> has passed in unevaluated argument expressions: For primitive functions (which are strict), we evaluate all the arguments before applying the primitive; for compound functions (which are non-strict) we delay all the arguments before applying the function.</p>
<p class="Sp-text-1"><a id="c004_c4-para-0950"></a><b>function</b> apply(fun, args, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0951"></a> <b>if</b> (is_primitive_function(fun)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0952"></a> <b>return</b> apply_primitive_function(</p>
<p class="Sp-text-1"><a id="c004_c4-para-0953"></a>                   fun,</p>
<p class="Sp-text-1"><a id="c004_c4-para-0954"></a>                   list_of_arg_values(args, env));              <span class="KeyTerm2"><i>// changed</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-0955"></a>    } <b>else if</b> (is_compound_function(fun)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0956"></a> <b>const</b> result = evaluate(</p>
<p class="Sp-text-1"><a id="c004_c4-para-0957"></a>                           function_body(fun),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0958"></a>                           extend_environment(</p>
<p class="Sp-text-1"><a id="c004_c4-para-0959"></a>                               function_parameters(fun),</p>
<p class="Sp-text-1"><a id="c004_c4-para-0960"></a>                               list_of_delayed_args(args, env), <span class="KeyTerm2"><i>// changed</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-0961"></a>                               function_environment(fun)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-0962"></a> <b>return</b> is_return_value(result)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0963"></a>               ? return_value_content(result)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0964"></a>               : undefined;</p>
<p class="Sp-text-1"><a id="c004_c4-para-0965"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0966"></a>        error(fun, "unknown function type – apply");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0967"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0968"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-0969"></a>The functions that process the arguments are just like <span class="KeyTerm1">list_of_values</span> from section 4.1.1, except that <span class="KeyTerm1">list_of_delayed_args</span> delays the arguments instead of evaluating them, and <span class="KeyTerm1">list_of_arg_values</span> uses <span class="KeyTerm1">actual_value</span> instead of <span class="KeyTerm1">evaluate</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0970"></a><b>function</b> list_of_arg_values(exps, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0971"></a> <b>return</b> map(exp =&gt; actual_value(exp, env), exps);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0972"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-0973"></a><b>function</b> list_of_delayed_args(exps, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0974"></a> <b>return</b> map(exp =&gt; delay_it(exp, env), exps);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0975"></a>}</p>
<p><a id="c004_c4-para-0976"></a>The other place we must change the evaluator is in the handling of conditionals, where we must use <span class="KeyTerm1">actual_value</span> instead of <span class="KeyTerm1">evaluate</span> to get the value of the predicate expression before testing whether it is true or false:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0977"></a><b>function</b> eval_conditional(component, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0978"></a> <b>return</b> is_truthy(actual_value(conditional_predicate(component), env))</p>
<p class="Sp-text-1"><a id="c004_c4-para-0979"></a>           ? evaluate(conditional_consequent(component), env)</p>
<p class="Sp-text-1"><a id="c004_c4-para-0980"></a>           : evaluate(conditional_alternative(component), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0981"></a>}</p>
<p><a id="c004_c4-para-0982"></a>Finally, we must change the <span class="KeyTerm1">driver_loop</span> function (from section 4.1.4) to use <span class="KeyTerm1">actual_value</span> instead of <span class="KeyTerm1">evaluate</span>, so that if a delayed value is propagated back to the read-evaluate-print loop, it will be forced before being printed. We also change the prompts to indicate that this is the lazy evaluator:</p>
<p class="Sp-text-1"><a id="c004_c4-para-0983"></a><b>const</b> input_prompt = "L-evaluate input: ";</p>
<p class="Sp-text-1"><a id="c004_c4-para-0984"></a><b>const</b> output_prompt = "L-evaluate value: ";</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-0985"></a><b>function</b> driver_loop(env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0986"></a> <b>const</b> input = user_read(input_prompt);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0987"></a> <b>if</b> (is_null(input)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0988"></a>        display("evaluator terminated");</p>
<p class="Sp-text-1"><a id="c004_c4-para-0989"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-0990"></a> <b>const</b> program = parse(input);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0991"></a> <b>const</b> locals = scan_out_declarations(program);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0992"></a> <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0993"></a> <b>const</b> program_env = extend_environment(locals, unassigneds, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0994"></a> <b>const</b> output = actual_value(program, program_env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0995"></a>        user_print(output_prompt, output);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0996"></a> <b>return</b> driver_loop(program_env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-0997"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-0998"></a>}</p>
<p><a id="c004_c4-para-0999"></a>With these changes made, we can start the evaluator and test it. The successful evaluation of the <span class="KeyTerm1">try_me</span> expression discussed in section 4.2.1 indicates that the interpreter is performing lazy evaluation:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1000"></a><b>const</b> the_global_environment = setup_environment(); driver_loop(the_global_environment);</p>
<p class="Sp-text-3"><a id="c004_c4-para-1001"></a><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1002"></a><b>function</b> try_me(a, b) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1003"></a> <b>return</b> a === 0 ? 1 : b;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1004"></a>}</p>
<p class="Sp-text-3"><a id="c004_c4-para-1005"></a><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1006"></a><i>undefined</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1007"></a><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1008"></a>try_me(0, head(<b>null</b>));</p>
<p class="Sp-text-3"><a id="c004_c4-para-1009"></a><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1010"></a><i>1</i></p>
</section>
<section>
<h5><a id="c004_c4-sec-0066"></a><a id="c004_c4-title-0067"></a>Representing thunks</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1011"></a>Our evaluator must arrange to create thunks when functions are applied to arguments and to force these thunks later. A thunk must package an expression together with the environment, so that the argument can be produced later. To force the thunk, we simply extract the expression and environment from the thunk and evaluate the expression in the environment. We use <span class="KeyTerm1">actual_value</span> rather than <span class="KeyTerm1">evaluate</span> so that in case the value of the expression is itself a thunk, we will force that, and so on, until we reach something that is not a thunk:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1012"></a><b>function</b> force_it(obj) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1013"></a> <b>return</b> is_thunk(obj)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1014"></a>           ? actual_value(thunk_exp(obj), thunk_env(obj))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1015"></a>           : obj;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1016"></a>}</p>
<p><a id="c004_c4-para-1017"></a>One easy way to package an expression with an environment is to make a list containing the expression and the environment. Thus, we create a thunk as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1018"></a><b>function</b> delay_it(exp, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1019"></a> <b>return</b> list("thunk", exp, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1020"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1021"></a><b>function</b> is_thunk(obj) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1022"></a> <b>return</b> is_tagged_list(obj, "thunk");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1023"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1024"></a><b>function</b> thunk_exp(thunk) { <b>return</b> head(tail(thunk)); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1025"></a><b>function</b> thunk_env(thunk) { <b>return</b> head(tail(tail(thunk))); }</p>
<p><a id="c004_c4-para-1026"></a>Actually, what we want for our interpreter is not quite this, but rather thunks that have been memoized. When a thunk is forced, we will turn it into an evaluated thunk by replacing the stored expression with its value and changing the <span class="KeyTerm1">thunk</span> tag so that it can be recognized as already evaluated.<a id="c004_c4-fn-0034a"></a><a href="#c4-fn-0034"><sup>34</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-1027"></a><b>function</b> is_evaluated_thunk(obj) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1028"></a> <b>return</b> is_tagged_list(obj, "evaluated_thunk");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1029"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1030"></a><b>function</b> thunk_value(evaluated_thunk) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1031"></a> <b>return</b> head(tail(evaluated_thunk));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1032"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1033"></a><b>function</b> force_it(obj) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1034"></a> <b>if</b> (is_thunk(obj)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1035"></a> <b>const</b> result = actual_value(thunk_exp(obj), thunk_env(obj));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1036"></a>        set_head(obj, "evaluated_thunk");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1037"></a>        set_head(tail(obj), result); <i>//</i> <span class="KeyTerm2"><i>replace exp with its value</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-1038"></a>        set_tail(tail(obj), <b>null</b>); <i>//</i> <span class="KeyTerm2"><i>forget unneeded env</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-1039"></a> <b>return</b> result;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1040"></a>    } <b>else if</b> (is_evaluated_thunk(obj)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1041"></a> <b>return</b> thunk_value(obj);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1042"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1043"></a> <b>return</b> obj;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1044"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1045"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1046"></a>Notice that the same <span class="KeyTerm1">delay_it</span> function works both with and without memoization.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0067"></a><a id="c004_c4-title-0068"></a>Exercise 4.25</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1047"></a>Suppose we type in the following declarations to the lazy evaluator:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1048"></a><b>let</b> count = 0;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1049"></a><b>function</b> id(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1050"></a>    count = count + 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1051"></a> <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1052"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1053"></a>Give the missing values in the following sequence of interactions, and explain your answers.<a id="c004_c4-fn-0035a"></a><a href="#c4-fn-0035"><sup>35</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-1054"></a><b>const</b> w = id(id(10));</p>
<p class="Sp-text-3"><a id="c004_c4-para-1055"></a><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1056"></a>count;</p>
<p class="Sp-text-3"><a id="c004_c4-para-1057"></a><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1058"></a>〈<span class="KeyTerm2"><i>response</i></span>〉</p>
<p class="Sp-text-3"><a id="c004_c4-para-1059"></a><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1060"></a>w;</p>
<p class="Sp-text-3"><a id="c004_c4-para-1061"></a><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1062"></a>〈<span class="KeyTerm2"><i>response</i></span>〉</p>
<p class="Sp-text-3"><a id="c004_c4-para-1063"></a><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1064"></a>count;</p>
<p class="Sp-text-3"><a id="c004_c4-para-1065"></a><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1066"></a>〈<span class="KeyTerm2"><i>response</i></span>〉</p>
</section>
<section>
<h5><a id="c004_c4-sec-0068"></a><a id="c004_c4-title-0069"></a>Exercise 4.26</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1067"></a>The function <span class="KeyTerm1">evaluate</span> uses <span class="KeyTerm1">actual_value</span> rather than <span class="KeyTerm1">evaluate</span> to evaluate the function expression before passing it to <span class="KeyTerm1">apply</span>, in order to force the value of the function expression. Give an example that demonstrates the need for this forcing.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0069"></a><a id="c004_c4-title-0070"></a>Exercise 4.27</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1068"></a>Exhibit a program that you would expect to run much more slowly without memoization than with memoization. Also, consider the following interaction, where the <span class="KeyTerm1">id</span> function is defined as in exercise 4.25 and <span class="KeyTerm1">count</span> starts at 0:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1069"></a><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1070"></a> <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1071"></a>}</p>
<p class="Sp-text-3"><a id="c004_c4-para-1072"></a><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1073"></a>square(id(10));</p>
<p class="Sp-text-3"><a id="c004_c4-para-1074"></a><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1075"></a>〈<span class="KeyTerm2"><i>response</i></span>〉</p>
<p class="Sp-text-3"><a id="c004_c4-para-1076"></a><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1077"></a>count;</p>
<p class="Sp-text-3"><a id="c004_c4-para-1078"></a><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1079"></a>〈<span class="KeyTerm2"><i>response</i></span>〉</p>
<p class="paracontinue"><a id="c004_c4-para-1080"></a>Give the responses both when the evaluator memoizes and when it does not.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0070"></a><a id="c004_c4-title-0071"></a>Exercise 4.28</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1081"></a>Cy D. Fect, a reformed C programmer, is worried that some side effects may never take place, because the lazy evaluator doesn't force the statements in a sequence. Since the value of a statement in a sequence may not be used (the statement may be there only for its effect, such as assigning to a variable or printing), there may be no subsequent use of this value (e.g., as an argument to a primitive function) that will cause it to be forced. Cy thus thinks that when evaluating sequences, we must force all statements in the sequence. He proposes to modify <span class="KeyTerm1">evaluate_sequence</span> from section 4.1.1 to use <span class="KeyTerm1">actual_value</span> rather than <span class="KeyTerm1">evaluate</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1082"></a><b>function</b> eval_sequence(stmts, env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1083"></a> <b>if</b> (is_empty_sequence(stmts)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1084"></a> <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1085"></a>    } <b>else if</b> (is_last_statement(stmts)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1086"></a> <b>return</b> actual_value(first_statement(stmts), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1087"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1088"></a> <b>const</b> first_stmt_value =</p>
<p class="Sp-text-1"><a id="c004_c4-para-1089"></a>            actual_value(first_statement(stmts), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1090"></a> <b>if</b> (is_return_value(first_stmt_value)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1091"></a> <b>return</b> first_stmt_value;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1092"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1093"></a> <b>return</b> eval_sequence(rest_statements(stmts), env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1094"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1095"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1096"></a>}</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0054"></a><span>a. </span>Ben Bitdiddle thinks Cy is wrong. He shows Cy the <span class="KeyTerm1">for_each</span> function described in exercise 2.23, which gives an important example of a sequence with side effects:
<p class="Sp-text-1"><a id="c004_c4-para-1098"></a><b>function</b> for_each(fun, items) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1099"></a> <b>if</b> (is_null(items)){</p>
<p class="Sp-text-1"><a id="c004_c4-para-1100"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c004_c4-para-1101"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1102"></a>        fun(head(items));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1103"></a>        for_each(fun, tail(items));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1104"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1105"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1106"></a>He claims that the evaluator in the text (with the original <span class="KeyTerm1">eval_sequence</span>) handles this correctly:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1107"></a><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1108"></a>for_each(display, list(57, 321, 88));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1109"></a><i>57</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1110"></a><i>321</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1111"></a><i>88</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1112"></a><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1113"></a><i>"done"</i></p>
<p class="paracontinue"><a id="c004_c4-para-1114"></a>Explain why Ben is right about the behavior of <span class="KeyTerm1">for_each</span>.</p></li>
<li><a id="c004_c4-li-0055"></a><span>b. </span>Cy agrees that Ben is right about the <span class="KeyTerm1">for_each</span> example, but says that that's not the kind of program he was thinking about when he proposed his change to <span class="KeyTerm1">eval_sequence</span>. He declares the following two functions in the lazy evaluator:
<p class="Sp-text-1"><a id="c004_c4-para-1116"></a><b>function</b> f1(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1117"></a>    x = pair(x, list(2));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1118"></a> <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1119"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1120"></a><b>function</b> f2(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1121"></a> <b>function</b> f(e) { </p>
<p class="Sp-text-1"><a id="c004_c4-para-1122"></a>        e;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1123"></a> <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1124"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1125"></a> <b>return</b> f(x = pair(x, list(2)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1126"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1127"></a>What are the values of <span class="KeyTerm1">f1(1)</span> and <span class="KeyTerm1">f2(1)</span> with the original <span class="KeyTerm1">eval_sequence</span>? What would the values be with Cy's proposed change to <span class="KeyTerm1">eval_sequence</span>?</p></li>
<li><a id="c004_c4-li-0056"></a><span>c. </span>Cy also points out that changing <span class="KeyTerm1">eval_sequence</span> as he proposes does not affect the behavior of the example in part a. Explain why this is true.</li>
<li><a id="c004_c4-li-0057"></a><span>d. </span>How do you think sequences ought to be treated in the lazy evaluator? Do you like Cy's approach, the approach in the text, or some other approach?</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0071"></a><a id="c004_c4-title-0072"></a>Exercise 4.29</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1130"></a>The approach taken in this section is somewhat unpleasant, because it makes an incompatible change to JavaScript. It might be nicer to implement lazy evaluation as an <i>upward-compatible extension</i>, that is, so that ordinary JavaScript programs will work as before. We can do this by introducing optional parameter declaration as a new syntactic form inside function declarations to let the user control whether or not arguments are to be delayed. While we're at it, we may as well also give the user the choice between delaying with and without memoization. For example, the declaration</p>
<p class="Sp-text-1"><a id="c004_c4-para-1131"></a><b>function</b> f(a, b, c, d) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1132"></a>    parameters("strict", "lazy", "strict", "lazy_memo");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1133"></a> <i>. . .</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1134"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1135"></a>would define <span class="KeyTerm1">f</span> to be a function of four arguments, where the first and third arguments are evaluated when the function is called, the second argument is delayed, and the fourth argument is both delayed and memoized. You can assume that the parameter declaration is always the first statement in the body of a function declaration, and if it is omitted, all parameters are strict. Thus, ordinary function declaration will produce the same behavior as ordinary JavaScript, while adding the <span class="KeyTerm1">"lazy_memo"</span> declaration to each parameter of every compound function will produce the behavior of the lazy evaluator defined in this section. Design and implement the changes required to produce such an extension to JavaScript. The <span class="KeyTerm1">parse</span> function will treat parameter declarations as function applications, so you need to modify <span class="KeyTerm1">apply</span> to dispatch to your implementation of the new syntactic form. You must also arrange for <span class="KeyTerm1">evaluate</span> or <span class="KeyTerm1">apply</span> to determine when arguments are to be delayed, and to force or delay arguments accordingly, and you must arrange for forcing to memoize or not, as appropriate.</p>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0072"></a><span>4.2.3</span> <a id="c004_c4-title-0073"></a>Streams as Lazy Lists</h3>
<p class="paraaftertitle"><a id="c004_c4-para-1136"></a>In section 3.5.1, we showed how to implement streams as delayed lists. We used a lambda expression to construct a “promise” to compute the tail of a stream, without actually fulfilling that promise until later. We were forced to create streams as a new kind of data object similar but not identical to lists, and this required us to reimplement many ordinary list operations (<span class="KeyTerm1">map</span>, <span class="KeyTerm1">append</span>, and so on) for use with streams.</p>
<p><a id="c004_c4-para-1137"></a>With lazy evaluation, streams and lists can be identical, so there is no need for separate list and stream operations. All we need to do is to arrange matters so that <span class="KeyTerm1">pair</span> is non-strict. One way to accomplish this is to extend the lazy evaluator to allow for non-strict primitives, and to implement <span class="KeyTerm1">pair</span> as one of these. An easier way is to recall (section 2.1.3) that there is no fundamental need to implement <span class="KeyTerm1">pair</span> as a primitive at all. Instead, we can represent pairs as functions:<a id="c004_c4-fn-0036a"></a><a href="#c4-fn-0036"><sup>36</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-1138"></a><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1139"></a> <b>return</b> m =&gt; m(x, y);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1140"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1141"></a><b>function</b> head(z) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1142"></a> <b>return</b> z((p, q) =&gt; p);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1143"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1144"></a><b>function</b> tail(z) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1145"></a> <b>return</b> z((p, q) =&gt; q);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1146"></a>}</p>
<p><a id="c004_c4-para-1147"></a>In terms of these basic operations, the standard definitions of the list operations will work with infinite lists (streams) as well as finite ones, and the stream operations can be implemented as list operations. Here are some examples:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1148"></a><b>function</b> list_ref(items, n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1149"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c004_c4-para-1150"></a>           ? head(items)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1151"></a>           : list_ref(tail(items), n - 1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1152"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1153"></a><b>function</b> map(fun, items) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1154"></a> <b>return</b> is_null(items)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1155"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-1156"></a>           : pair(fun(head(items)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1157"></a>                  map(fun, tail(items)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1158"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1159"></a><b>function</b> scale_list(items, factor) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1160"></a> <b>return</b> map(x =&gt; x * factor, items);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1161"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1162"></a><b>function</b> add_lists(list1, list2) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1163"></a> <b>return</b> is_null(list1)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1164"></a>           ? list2</p>
<p class="Sp-text-1"><a id="c004_c4-para-1165"></a>           : is_null(list2)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1166"></a>           ? list1</p>
<p class="Sp-text-1"><a id="c004_c4-para-1167"></a>           : pair(head(list1) + head(list2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1168"></a>                  add_lists(tail(list1), tail(list2)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1169"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1170"></a><b>const</b> ones = pair(1, ones);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1171"></a><b>const</b> integers = pair(1, add_lists(ones, integers));</p>
<p class="Sp-text-3"><a id="c004_c4-para-1172"></a><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1173"></a>list_ref(integers, 17);</p>
<p class="Sp-text-3"><a id="c004_c4-para-1174"></a><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1175"></a><i>18</i></p>
<p><a id="c004_c4-para-1176"></a>Note that these lazy lists are even lazier than the streams of chapter 3: The head of the list, as well as the tail, is delayed.<a id="c004_c4-fn-0037a"></a><a href="#c4-fn-0037"><sup>37</sup></a> In fact, even accessing the <span class="KeyTerm1">head</span> or <span class="KeyTerm1">tail</span> of a lazy pair need not force the value of a list element. The value will be forced only when it is really needed—e.g., for use as the argument of a primitive, or to be printed as an answer.</p>
<p><a id="c004_c4-para-1177"></a>Lazy pairs also help with the problem that arose with streams in section 3.5.4, where we found that formulating stream models of systems with loops may require us to sprinkle our programs with additional lambda expressions for delays, beyond the ones required to construct a stream pair. With lazy evaluation, all arguments to functions are delayed uniformly. For instance, we can implement functions to integrate lists and solve differential equations as we originally intended in section 3.5.4:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1178"></a><b>function</b> integral(integrand, initial_value, dt) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1179"></a> <b>const</b> int = pair(initial_value,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1180"></a>                     add_lists(scale_list(integrand, dt),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1181"></a>                               int));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1182"></a> <b>return</b> int;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1183"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1184"></a><b>function</b> solve(f, y0, dt) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1185"></a> <b>const</b> y = integral(dy, y0, dt);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1186"></a> <b>const</b> dy = map(f, y);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1187"></a> <b>return</b> y;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1188"></a>}</p>
<p class="Sp-text-3"><a id="c004_c4-para-1189"></a><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1190"></a>list_ref(solve(x =&gt; x, 1, 0.001), 1000);</p>
<p class="Sp-text-3"><a id="c004_c4-para-1191"></a><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1192"></a><i>2.716924</i></p>
<section>
<h5><a id="c004_c4-sec-0073"></a><a id="c004_c4-title-0074"></a>Exercise 4.30</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1193"></a>Give some examples that illustrate the difference between the streams of chapter 3 and the “lazier” lazy lists described in this section. How can you take advantage of this extra laziness?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0074"></a><a id="c004_c4-title-0075"></a>Exercise 4.31</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1194"></a>Ben Bitdiddle tests the lazy list implementation given above by evaluating the expression</p>
<p class="Sp-text-1"><a id="c004_c4-para-1195"></a>head(list("a", "b", "c"));</p>
<p class="paracontinue"><a id="c004_c4-para-1196"></a>To his surprise, this produces an error. After some thought, he realizes that the “lists” obtained from the primitive <span class="KeyTerm1">list</span> function are different from the lists manipulated by the new definitions of <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>. Modify the evaluator such that applications of the primitive <span class="KeyTerm1">list</span> function typed at the driver loop will produce true lazy lists.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0075"></a><a id="c004_c4-title-0076"></a>Exercise 4.32</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1197"></a>Modify the driver loop for the evaluator so that lazy pairs and lists will print in some reasonable way. (What are you going to do about infinite lists?) You may also need to modify the representation of lazy pairs so that the evaluator can identify them in order to print them.</p>
</section>
</section>
</section>
<section>
<h2><a id="c004_c4-sec-0076"></a><span>4.3</span> <a id="c004_c4-title-0077"></a>Nondeterministic Computing</h2>
<p class="paraaftertitle"><a id="c004_c4-para-1198"></a>In this section, we extend the JavaScript evaluator to support a programming paradigm called <i>nondeterministic computing</i> by building into the evaluator a facility to support automatic search. This is a much more profound change to the language than the introduction of lazy evaluation in section 4.2.</p>
<p><a id="c004_c4-para-1199"></a>Nondeterministic computing, like stream processing, is useful for “generate and test” applications. Consider the task of starting with two lists of positive integers and finding a pair of integers—one from the first list and one from the second list—whose sum is prime. We saw how to handle this with finite sequence operations in section 2.2.3 and with infinite streams in section 3.5.3. Our approach was to generate the sequence of all possible pairs and filter these to select the pairs whose sum is prime. Whether we actually generate the entire sequence of pairs first as in chapter 2, or interleave the generating and filtering as in chapter 3, is immaterial to the essential image of how the computation is organized.</p>
<p><a id="c004_c4-para-1200"></a>The nondeterministic approach evokes a different image. Imagine simply that we choose (in some way) a number from the first list and a number from the second list and require (using some mechanism) that their sum be prime. This is expressed by the following function:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1201"></a><b>function</b> prime_sum_pair(list1, list2) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1202"></a> <b>const</b> a = an_element_of(list1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1203"></a> <b>const</b> b = an_element_of(list2);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1204"></a>    require(is_prime(a + b));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1205"></a> <b>return</b> list(a, b);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1206"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1207"></a>It might seem as if this function merely restates the problem, rather than specifying a way to solve it. Nevertheless, this is a legitimate nondeterministic program.<a id="c004_c4-fn-0038a"></a><a href="#c4-fn-0038"><sup>38</sup></a></p>
<p><a id="c004_c4-para-1208"></a>The key idea here is that components in a nondeterministic language can have more than one possible value. For instance, <span class="KeyTerm1">an_element_of</span> might return any element of the given list. Our nondeterministic program evaluator will work by automatically choosing a possible value and keeping track of the choice. If a subsequent requirement is not met, the evaluator will try a different choice, and it will keep trying new choices until the evaluation succeeds, or until we run out of choices. Just as the lazy evaluator freed the programmer from the details of how values are delayed and forced, the nondeterministic program evaluator will free the programmer from the details of how choices are made.</p>
<p><a id="c004_c4-para-1209"></a>It is instructive to contrast the different images of time evoked by nondeterministic evaluation and stream processing. Stream processing uses lazy evaluation to decouple the time when the stream of possible answers is assembled from the time when the actual stream elements are produced. The evaluator supports the illusion that all the possible answers are laid out before us in a timeless sequence. With nondeterministic evaluation, a component represents the exploration of a set of possible worlds, each determined by a set of choices. Some of the possible worlds lead to dead ends, while others have useful values. The nondeterministic program evaluator supports the illusion that time branches, and that our programs have different possible execution histories. When we reach a dead end, we can revisit a previous choice point and proceed along a different branch.</p>
<p><a id="c004_c4-para-1210"></a>The nondeterministic program evaluator implemented below is called the <span class="KeyTerm1">amb</span> evaluator because it is based on a new syntactic form called <span class="KeyTerm1">amb</span>. We can type the above declaration of <span class="KeyTerm1">prime_sum_pair</span> at the <span class="KeyTerm1">amb</span> evaluator driver loop (along with declarations of <span class="KeyTerm1">is_prime</span>, <span class="KeyTerm1">an_element_of</span>, and <span class="KeyTerm1">require</span>) and run the function as follows:</p>
<p class="Sp-text-3"><a id="c004_c4-para-1211"></a><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1212"></a>prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));</p>
<p class="Sp-text-3"><a id="c004_c4-para-1213"></a><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1214"></a><i>amb-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1215"></a><i>[3, [20, null]]</i></p>
<p class="paracontinue"><a id="c004_c4-para-1216"></a>The value returned was obtained after the evaluator repeatedly chose elements from each of the lists, until a successful choice was made.</p>
<p><a id="c004_c4-para-1217"></a>Section 4.3.1 introduces <span class="KeyTerm1">amb</span> and explains how it supports nondeterminism through the evaluator's automatic search mechanism. Section 4.3.2 presents examples of nondeterministic programs, and section 4.3.3 gives the details of how to implement the <span class="KeyTerm1">amb</span> evaluator by modifying the ordinary JavaScript evaluator.</p>
<section>
<h3><a id="c004_c4-sec-0077"></a><span>4.3.1</span> <a id="c004_c4-title-0078"></a>Search and <span class="KeyTerm1">amb</span></h3>
<p class="paraaftertitle"><a id="c004_c4-para-1218"></a>To extend JavaScript to support nondeterminism, we introduce a new syntactic form called <span class="KeyTerm1">amb</span>.<a id="c004_c4-fn-0039a"></a><a href="#c4-fn-0039"><sup>39</sup></a> The expression <span class="KeyTerm1">amb(</span><i>e</i><sub>1</sub>, <i>e</i><sub>2</sub>, <span class="KeyTerm1"><i>. . .</i></span> , <i>e<sub>n</sub></i><span class="KeyTerm1">)</span> returns the value of one of the <i>n</i> expressions <i>e<sub>i</sub></i> “ambiguously.” For example, the expression</p>
<p class="Sp-text-1"><a id="c004_c4-para-1219"></a>list(amb(1, 2, 3), amb("a", "b"));</p>
<p class="paracontinue"><a id="c004_c4-para-1220"></a>can have six possible values:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1221"></a>list(1, "a") list(1, "b") list(2, "a")</p>
<p class="Sp-text-1"><a id="c004_c4-para-1222"></a>list(2, "b") list(3, "a") list(3, "b")</p>
<p class="paracontinue"><a id="c004_c4-para-1223"></a>An <span class="KeyTerm1">amb</span> expression with a single choice produces an ordinary (single) value.</p>
<p><a id="c004_c4-para-1224"></a>An <span class="KeyTerm1">amb</span> expression with no choices—the expression <span class="KeyTerm1">amb()</span>—is an expression with no acceptable values. Operationally, we can think of <span class="KeyTerm1">amb()</span> as an expression that when evaluated causes the computation to “fail”: The computation aborts and no value is produced. Using this idea, we can express the requirement that a particular predicate expression <span class="KeyTerm1">p</span> must be true as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1225"></a><b>function</b> require(p) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1226"></a> <b>if</b> (! p) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1227"></a>        amb();</p>
<p class="Sp-text-1"><a id="c004_c4-para-1228"></a>    } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1229"></a>}</p>
<p><a id="c004_c4-para-1230"></a>With <span class="KeyTerm1">amb</span> and <span class="KeyTerm1">require</span>, we can implement the <span class="KeyTerm1">an_element_of</span> function used above:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1231"></a><b>function</b> an_element_of(items) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1232"></a>    require(! is_null(items));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1233"></a> <b>return</b> amb(head(items), an_element_of(tail(items)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1234"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1235"></a>An application of <span class="KeyTerm1">an_element_of</span> fails if the list is empty. Otherwise it ambiguously returns either the first element of the list or an element chosen from the rest of the list.</p>
<p><a id="c004_c4-para-1236"></a>We can also express infinite ranges of choices. The following function potentially returns any integer greater than or equal to some given <i>n</i>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1237"></a><b>function</b> an_integer_starting_from(n) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1238"></a> <b>return</b> amb(n, an_integer_starting_from(n + 1));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1239"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1240"></a>This is like the stream function <span class="KeyTerm1">integers_starting_from</span> described in section 3.5.2, but with an important difference: The stream function returns an object that represents the sequence of all integers beginning with <i>n</i>, whereas the <span class="KeyTerm1">amb</span> function returns a single integer.<a id="c004_c4-fn-0040a"></a><a href="#c4-fn-0040"><sup>40</sup></a></p>
<p><a id="c004_c4-para-1241"></a>Abstractly, we can imagine that evaluating an <span class="KeyTerm1">amb</span> expression causes time to split into branches, where the computation continues on each branch with one of the possible values of the expression. We say that <span class="KeyTerm1">amb</span> represents a <i>nondeterministic choice point</i>. If we had a machine with a sufficient number of processors that could be dynamically allocated, we could implement the search in a straightforward way. Execution would proceed as in a sequential machine, until an <span class="KeyTerm1">amb</span> expression is encountered. At this point, more processors would be allocated and initialized to continue all of the parallel executions implied by the choice. Each processor would proceed sequentially as if it were the only choice, until it either terminates by encountering a failure, or it further subdivides, or it finishes.<a id="c004_c4-fn-0041a"></a><a href="#c4-fn-0041"><sup>41</sup></a></p>
<p><a id="c004_c4-para-1242"></a>On the other hand, if we have a machine that can execute only one process (or a few concurrent processes), we must consider the alternatives sequentially. One could imagine modifying an evaluator to pick at random a branch to follow whenever it encounters a choice point. Random choice, however, can easily lead to failing values. We might try running the evaluator over and over, making random choices and hoping to find a non-failing value, but it is better to <i>systematically search</i> all possible execution paths. The <span class="KeyTerm1">amb</span> evaluator that we will develop and work with in this section implements a systematic search as follows: When the evaluator encounters an application of <span class="KeyTerm1">amb</span>, it initially selects the first alternative. This selection may itself lead to a further choice. The evaluator will always initially choose the first alternative at each choice point. If a choice results in a failure, then the evaluator automagically<a id="c004_c4-fn-0042a"></a><a href="#c4-fn-0042"><sup>42</sup></a> <i>backtracks</i> to the most recent choice point and tries the next alternative. If it runs out of alternatives at any choice point, the evaluator will back up to the previous choice point and resume from there. This process leads to a search strategy known as <i>depth-first search</i> or <i>chronological backtracking</i>.<a id="c004_c4-fn-0043a"></a><a href="#c4-fn-0043"><sup>43</sup></a></p>
<section>
<h5><a id="c004_c4-sec-0078"></a><a id="c004_c4-title-0079"></a>Driver loop</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1243"></a>The driver loop for the <span class="KeyTerm1">amb</span> evaluator has some unusual properties. It reads a program and prints the value of the first non-failing execution, as in the <span class="KeyTerm1">prime_sum_pair</span> example shown above. If we want to see the value of the next successful execution, we can ask the interpreter to backtrack and attempt to generate a second non-failing execution. This is signaled by typing <span class="KeyTerm1">retry</span>. If any other input except <span class="KeyTerm1">retry</span> is given, the interpreter will start a new problem, discarding the unexplored alternatives in the previous problem. Here is a sample interaction:</p>
<p class="Sp-text-3"><a id="c004_c4-para-1244"></a><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1245"></a>prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));</p>
<p class="Sp-text-3"><a id="c004_c4-para-1246"></a><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1247"></a><i>amb-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1248"></a><i>[3, [20, null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-3"><a id="c004_c4-para-1249"></a><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1250"></a>retry</p>
<p class="Sp-text-3"><a id="c004_c4-para-1251"></a><i>amb-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1252"></a><i>[3, [110, null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-3"><a id="c004_c4-para-1253"></a><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1254"></a>retry</p>
<p class="Sp-text-3"><a id="c004_c4-para-1255"></a><i>amb-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1256"></a><i>[8, [35, null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-3"><a id="c004_c4-para-1257"></a><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1258"></a>retry</p>
<p class="Sp-text-3"><a id="c004_c4-para-1259"></a><i>There are no more values of</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1260"></a><i>prime_sum_pair([1, [3, [5, [8, null]]]], [20, [35, [110, null]]])</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-3"><a id="c004_c4-para-1261"></a><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1262"></a>prime_sum_pair(list(19, 27, 30), list(11, 36, 58));</p>
<p class="Sp-text-3"><a id="c004_c4-para-1263"></a><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1264"></a><i>amb-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1265"></a><i>[30, [11, null]]</i></p>
</section>
<section>
<h5><a id="c004_c4-sec-0079"></a><a id="c004_c4-title-0080"></a>Exercise 4.33</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1266"></a>Write a function <span class="KeyTerm1">an_integer_between</span> that returns an integer between two given bounds. This can be used to implement a function that finds Pythagorean triples, i.e., triples of integers (<i>i</i>, <i>j</i>, <i>k</i>) between the given bounds such that <i>i ≤ j</i> and <i>i</i><sup>2</sup> + <i>j</i><sup>2</sup> = <i>k</i><sup>2</sup>, as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1267"></a><b>function</b> a_pythogorean_triple_between(low, high) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1268"></a> <b>const</b> i = an_integer_between(low, high);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1269"></a> <b>const</b> j = an_integer_between(i, high);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1270"></a> <b>const</b> k = an_integer_between(j, high);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1271"></a>    require(i * i + j * j === k * k);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1272"></a> <b>return</b> list(i, j, k);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1273"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0080"></a><a id="c004_c4-title-0081"></a>Exercise 4.34</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1274"></a>Exercise 3.69 discussed how to generate the stream of <i>all</i> Pythagorean triples, with no upper bound on the size of the integers to be searched. Explain why simply replacing <span class="KeyTerm1">an_integer_between</span> by <span class="KeyTerm1">an_integer_starting_from</span> in the function in exercise 4.33 is not an adequate way to generate arbitrary Pythagorean triples. Write a function that actually will accomplish this. (That is, write a function for which repeatedly typing <span class="KeyTerm1">retry</span> would in principle eventually generate all Pythagorean triples.)</p>
</section>
<section>
<h5><a id="c004_c4-sec-0081"></a><a id="c004_c4-title-0082"></a>Exercise 4.35</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1275"></a>Ben Bitdiddle claims that the following method for generating Pythagorean triples is more efficient than the one in exercise 4.33. Is he correct? (Hint: Consider the number of possibilities that must be explored.)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1276"></a><b>function</b> a_pythagorean_triple_between(low, high) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1277"></a> <b>const</b> i = an_integer_between(low, high);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1278"></a> <b>const</b> hsq = high * high;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1279"></a> <b>const</b> j = an_integer_between(i, high);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1280"></a> <b>const</b> ksq = i * i + j * j;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1281"></a>    require(hsq &gt;= ksq);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1282"></a> <b>const</b> k = math_sqrt(ksq);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1283"></a>    require(is_integer(k));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1284"></a> <b>return</b> list(i, j, k);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1285"></a>}</p>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0082"></a><span>4.3.2</span> <a id="c004_c4-title-0083"></a>Examples of Nondeterministic Programs</h3>
<p class="paraaftertitle"><a id="c004_c4-para-1286"></a>Section 4.3.3 describes the implementation of the <span class="KeyTerm1">amb</span> evaluator. First, however, we give some examples of how it can be used. The advantage of nondeterministic programming is that we can suppress the details of how search is carried out, thereby expressing our programs at a higher level of abstraction.</p>
<section>
<h5><a id="c004_c4-sec-0083"></a><a id="c004_c4-title-0084"></a>Logic Puzzles</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1287"></a>The following puzzle (adapted from Dinesman 1968) is typical of a large class of simple logic puzzles:</p>
<blockquote class="quote">
<p class="quoteparafirst"><a id="c004_c4-para-1288"></a>The software company Gargle is expanding, and Alyssa, Ben, Cy, Lem, and Louis are moving into a row of five private offices in a new building. Alyssa does not move into the last office. Ben does not move into the first office. Cy takes neither the first nor the last office. Lem moves into an office after Ben's. Louis's office is not next to Cy's. Cy's office is not next to Ben's. Who moves into which office?</p></blockquote>
<p><a id="c004_c4-para-1289"></a>We can determine who moves into which office in a straightforward way by enumerating all the possibilities and imposing the given restrictions:<a id="c004_c4-fn-0044a"></a><a href="#c4-fn-0044"><sup>44</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-1290"></a><b>function</b> office_move() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1291"></a> <b>const</b> alyssa = amb(1, 2, 3, 4, 5);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1292"></a> <b>const</b> ben = amb(1, 2, 3, 4, 5);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1293"></a> <b>const</b> cy = amb(1, 2, 3, 4, 5);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1294"></a> <b>const</b> lem = amb(1, 2, 3, 4, 5);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1295"></a> <b>const</b> louis = amb(1, 2, 3, 4, 5);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1296"></a>    require(distinct(list(alyssa, ben, cy, lem, louis)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1297"></a>    require(alyssa !== 5);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1298"></a>    require(ben !== 1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1299"></a>    require(cy !== 5);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1300"></a>    require(cy !== 1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1301"></a>    require(lem &gt; ben);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1302"></a>    require(math_abs(louis - cy) !== 1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1303"></a>    require(math_abs(cy - ben) !== 1);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1304"></a> <b>return</b> list(list("alyssa", alyssa),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1305"></a>                list("ben", ben),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1306"></a>                list("cy", cy),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1307"></a>                list("lem", lem),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1308"></a>                list("louis", louis));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1309"></a>}</p>
<p><a id="c004_c4-para-1310"></a>Evaluating the expression <span class="KeyTerm1">office_move()</span> produces the result</p>
<p class="Sp-text-1"><a id="c004_c4-para-1311"></a>list(list("alyssa", 3), list("ben", 2), list("cy", 4),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1312"></a>     list("lem", 5), list("louis", 1))</p>
<p class="paracontinue"><a id="c004_c4-para-1313"></a>Although this simple function works, it is very slow. Exercises 4.37 and 4.38 discuss some possible improvements.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0084"></a><a id="c004_c4-title-0085"></a>Exercise 4.36</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1314"></a>Modify the office-move function to omit the requirement that Louis's office is not next to Cy's. How many solutions are there to this modified puzzle?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0085"></a><a id="c004_c4-title-0086"></a>Exercise 4.37</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1315"></a>Does the order of the restrictions in the office-move function affect the answer? Does it affect the time to find an answer? If you think it matters, demonstrate a faster program obtained from the given one by reordering the restrictions. If you think it does not matter, argue your case.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0086"></a><a id="c004_c4-title-0087"></a>Exercise 4.38</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1325"></a>In the office move problem, how many sets of assignments are there of people to offices, both before and after the requirement that office assignments be distinct? It is very inefficient to generate all possible assignments of people to offices and then leave it to backtracking to eliminate them. For example, most of the restrictions depend on only one or two of the person-office names, and can thus be imposed before offices have been selected for all the people. Write and demonstrate a much more efficient nondeterministic function that solves this problem based upon generating only those possibilities that are not already ruled out by previous restrictions.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0087"></a><a id="c004_c4-title-0088"></a>Exercise 4.39</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1326"></a>Write an ordinary JavaScript program to solve the office move puzzle.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0088"></a><a id="c004_c4-title-0089"></a>Exercise 4.40</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1327"></a>Solve the following “Liars” puzzle (adapted from Phillips 1934):</p>
<blockquote class="quote">
<p class="quoteparafirst"><a id="c004_c4-para-1328"></a>Alyssa, Cy, Eva, Lem, and Louis meet for a business lunch at SoSoService. Their meals arrive one after the other, a considerable time after they placed their orders. To entertain Ben, who expects them back at the office for a meeting, they decide to each make one true statement and one false statement about their orders:</p>
<p class="quoteparafirst"><a id="c004_c4-para-1329"></a></p>
<ul style="list-style-type:disc">
<li>Alyssa: “Lem's meal arrived second. Mine arrived third.”</li>
<li>Cy: “Mine arrived first. Eva's arrived second.”</li>
<li>Eva: “Mine arrived third, and poor Cy's arrived last.”</li>
<li>Lem: “Mine arrived second. Louis's arrived fourth.”</li>
<li>Louis: “Mine arrived fourth. Alyssa's meal arrived first.”</li>
</ul>
<p class="quoteparafirst"><a id="c004_c4-para-1335"></a>What was the real order in which the five diners received their meals?</p></blockquote>
</section>
<section>
<h5><a id="c004_c4-sec-0089"></a><a id="c004_c4-title-0090"></a>Exercise 4.41</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1336"></a>Use the <span class="KeyTerm1">amb</span> evaluator to solve the following puzzle (adapted from Phillips 1961):</p>
<blockquote class="quote">
<p class="quoteparafirst"><a id="c004_c4-para-1337"></a>Alyssa, Ben, Cy, Eva, and Louis each pick a different chapter of SICP JS and solve all the exercises in that chapter. Louis solves the exercises in the “Functions” chapter, Alyssa the ones in the “Data” chapter, and Cy the ones in the “State” chapter. They decide to check each other's work, and Alyssa volunteers to check the exercises in the “Meta” chapter. The exercises in the “Register Machines” chapter are solved by Ben and checked by Louis. The person who checks the exercises in the “Functions” chapter solves the exercises that are checked by Eva. Who checks the exercises in the “Data” chapter?</p></blockquote>
<p class="paracontinue"><a id="c004_c4-para-1338"></a>Try to write the program so that it runs efficiently (see exercise 4.38). Also determine how many solutions there are if we are not told that Alyssa checks the exercises in the “Meta” chapter.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0090"></a><a id="c004_c4-title-0091"></a>Exercise 4.42</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1339"></a>Exercise 2.42 described the “eight-queens puzzle” of placing queens on a chessboard so that no two attack each other. Write a nondeterministic program to solve this puzzle.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0091"></a><a id="c004_c4-title-0092"></a>Parsing natural language</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1340"></a>Programs designed to accept natural language as input usually start by attempting to <i>parse</i> the input, that is, to match the input against some grammatical structure. For example, we might try to recognize simple sentences consisting of an article followed by a noun followed by a verb, such as “The cat eats.” To accomplish such an analysis, we must be able to identify the parts of speech of individual words. We could start with some lists that classify various words:<a id="c004_c4-fn-0045a"></a><a href="#c4-fn-0045"><sup>45</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-1341"></a><b>const</b> nouns = list("noun", "student", "professor", "cat", "class");</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1342"></a><b>const</b> verbs = list("verb", "studies", "lectures", "eats", "sleeps");</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1343"></a><b>const</b> articles = list("article", "the", "a");</p>
<p class="paracontinue"><a id="c004_c4-para-1344"></a>We also need a <i>grammar</i>, that is, a set of rules describing how grammatical elements are composed from simpler elements. A very simple grammar might stipulate that a sentence always consists of two pieces—a noun phrase followed by a verb—and that a noun phrase consists of an article followed by a noun. With this grammar, the sentence “The cat eats” is parsed as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1345"></a>list("sentence",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1346"></a>     list("noun-phrase", list("article", "the"), list("noun", "cat"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1347"></a>     list("verb", "eats"))</p>
<p><a id="c004_c4-para-1348"></a>We can generate such a parse with a simple program that has separate functions for each of the grammatical rules. To parse a sentence, we identify its two constituent pieces and return a list of these two elements, tagged with the symbol <span class="KeyTerm1">sentence</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1349"></a><b>function</b> parse_sentence() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1350"></a> <b>return</b> list("sentence",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1351"></a>                parse_noun_phrase(),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1352"></a>                parse_word(verbs));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1353"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1354"></a>A noun phrase, similarly, is parsed by finding an article followed by a noun:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1355"></a><b>function</b> parse_noun_phrase() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1356"></a> <b>return</b> list("noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1357"></a>                parse_word(articles),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1358"></a>                parse_word(nouns));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1359"></a>}</p>
<p><a id="c004_c4-para-1360"></a>At the lowest level, parsing boils down to repeatedly checking that the next not-yet-parsed word is a member of the list of words for the required part of speech. To implement this, we maintain a global variable <span class="KeyTerm1">not_yet_parsed</span>, which is the input that has not yet been parsed. Each time we check a word, we require that <span class="KeyTerm1">not_yet_parsed</span> must be nonempty and that it should begin with a word from the designated list. If so, we remove that word from <span class="KeyTerm1">not_yet_parsed</span> and return the word together with its part of speech (which is found at the head of the list):<a id="c004_c4-fn-0046a"></a><a href="#c4-fn-0046"><sup>46</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-1361"></a><b>function</b> parse_word(word_list) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1362"></a>    require(! is_null(not_yet_parsed));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1363"></a>    require(! is_null(member(head(not_yet_parsed), tail(word_list))));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1364"></a> <b>const</b> found_word = head(not_yet_parsed);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1365"></a>    not_yet_parsed = tail(not_yet_parsed);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1366"></a> <b>return</b> list(head(word_list), found_word);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1367"></a>}</p>
<p><a id="c004_c4-para-1368"></a>To start the parsing, all we need to do is set <span class="KeyTerm1">not_yet_parsed</span> to be the entire input, try to parse a sentence, and check that nothing is left over:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1369"></a><b>let</b> not_yet_parsed = <b>null</b>;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1370"></a><b>function</b> parse_input(input) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1371"></a>    not_yet_parsed = input;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1372"></a> <b>const</b> sent = parse_sentence();</p>
<p class="Sp-text-1"><a id="c004_c4-para-1373"></a>    require(is_null(not_yet_parsed));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1374"></a> <b>return</b> sent;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1375"></a>}</p>
<p><a id="c004_c4-para-1376"></a>We can now try the parser and verify that it works for our simple test sentence:</p>
<p class="Sp-text-3"><a id="c004_c4-para-1377"></a><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1378"></a>parse_input(list("the",  "cat",  "eats"));</p>
<p class="Sp-text-3"><a id="c004_c4-para-1379"></a><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1380"></a><i>amb-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1381"></a><i>list("sentence",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1382"></a> <i>list("noun-phrase", list("article", "the"), list("noun", "cat")),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1383"></a> <i>list("verb", "eats"))</i></p>
<p><a id="c004_c4-para-1384"></a>The <span class="KeyTerm1">amb</span> evaluator is useful here because it is convenient to express the parsing constraints with the aid of <span class="KeyTerm1">require</span>. Automatic search and backtracking really pay off, however, when we consider more complex grammars where there are choices for how the units can be decomposed.</p>
<p><a id="c004_c4-para-1385"></a>Let's add to our grammar a list of prepositions:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1386"></a><b>const</b> prepositions = list("prep", "for", "to", "in", "by", "with");</p>
<p class="paracontinue"><a id="c004_c4-para-1387"></a>and define a prepositional phrase (e.g., “for the cat”) to be a preposition followed by a noun phrase:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1388"></a><b>function</b> parse_prepositional_phrase() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1389"></a> <b>return</b> list("prep-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1390"></a>                parse_word(prepositions),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1391"></a>                parse_noun_phrase());</p>
<p class="Sp-text-1"><a id="c004_c4-para-1392"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1393"></a>Now we can define a sentence to be a noun phrase followed by a verb phrase, where a verb phrase can be either a verb or a verb phrase extended by a prepositional phrase:<a id="c004_c4-fn-0047a"></a><a href="#c4-fn-0047"><sup>47</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-1394"></a><b>function</b> parse_sentence() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1395"></a> <b>return</b> list("sentence",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1396"></a>                parse_noun_phrase(),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1397"></a>                parse_verb_phrase());</p>
<p class="Sp-text-1"><a id="c004_c4-para-1398"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1399"></a><b>function</b> parse_verb_phrase() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1400"></a> <b>function</b> maybe_extend(verb_phrase) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1401"></a> <b>return</b> amb(verb_phrase,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1402"></a>                   maybe_extend(list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1403"></a>                                     verb_phrase,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1404"></a>                                     parse_prepositional_phrase())));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1405"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1406"></a> <b>return</b> maybe_extend(parse_word(verbs));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1407"></a>}</p>
<p><a id="c004_c4-para-1408"></a>While we're at it, we can also elaborate the definition of noun phrases to permit such things as “a cat in the class.” What we used to call a noun phrase, we'll now call a simple noun phrase, and a noun phrase will now be either a simple noun phrase or a noun phrase extended by a prepositional phrase:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1409"></a><b>function</b> parse_simple_noun_phrase() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1410"></a> <b>return</b> list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1411"></a>                parse_word(articles),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1412"></a>                parse_word(nouns));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1413"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1414"></a><b>function</b> parse_noun_phrase() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1415"></a> <b>function</b> maybe_extend(noun_phrase) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1416"></a> <b>return</b> amb(noun_phrase,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1417"></a>                   maybe_extend(list("noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1418"></a>                                     noun_phrase,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1419"></a>                                     parse_prepositional_phrase())));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1420"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1421"></a> <b>return</b> maybe_extend(parse_simple_noun_phrase());</p>
<p class="Sp-text-1"><a id="c004_c4-para-1422"></a>}</p>
<p><a id="c004_c4-para-1423"></a>Our new grammar lets us parse more complex sentences. For example</p>
<p class="Sp-text-1"><a id="c004_c4-para-1424"></a>parse_input(list("the", "student", "with", "the", "cat",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1425"></a>                 "sleeps", "in", "the", "class"));</p>
<p class="paracontinue"><a id="c004_c4-para-1426"></a>produces</p>
<p class="Sp-text-1"><a id="c004_c4-para-1427"></a>list("sentence",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1428"></a>     list("noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1429"></a>          list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1430"></a>               list("article", "the"), list("noun", "student")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1431"></a>          list("prep-phrase", list("prep", "with"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1432"></a>               list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1433"></a>                    list("article", "the"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1434"></a>                    list("noun", "cat")))),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1435"></a>     list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1436"></a>          list("verb", "sleeps"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1437"></a>          list("prep-phrase", list("prep", "in"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1438"></a>               list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1439"></a>                    list("article", "the"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1440"></a>                    list("noun", "class")))))</p>
<p><a id="c004_c4-para-1441"></a>Observe that a given input may have more than one legal parse. In the sentence “The professor lectures to the student with the cat,” it may be that the professor is lecturing with the cat, or that the student has the cat. Our nondeterministic program finds both possibilities:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1442"></a>parse_input(list("the", "professor", "lectures",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1443"></a>                 "to", "the", "student", "with", "the", "cat"));</p>
<p class="paracontinue"><a id="c004_c4-para-1444"></a>produces</p>
<p class="Sp-text-1"><a id="c004_c4-para-1445"></a>list("sentence",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1446"></a>     list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1447"></a>          list("article", "the"), list("noun", "professor")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1448"></a>     list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1449"></a>          list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1450"></a>               list("verb", "lectures"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1451"></a>               list("prep-phrase", list("prep", "to"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1452"></a>                    list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1453"></a>                    list("article", "the"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1454"></a>                    list("noun", "student")))),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1455"></a>          list("prep-phrase", list("prep", "with"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1456"></a>               list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1457"></a>                    list("article", "the"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1458"></a>                    list("noun", "cat")))))</p>
<p class="paracontinue"><a id="c004_c4-para-1459"></a>Asking the evaluator to retry yields</p>
<p class="Sp-text-1"><a id="c004_c4-para-1460"></a>list("sentence",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1461"></a>     list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1462"></a>          list("article", "the"), list("noun", "professor")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1463"></a>     list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1464"></a>          list("verb", "lectures"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1465"></a>          list("prep-phrase", list("prep", "to"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1466"></a>               list("noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1467"></a>                    list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1468"></a>                         list("article", "the"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1469"></a>                         list("noun", "student")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1470"></a>                    list("prep-phrase", list("prep", "with"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1471"></a>                         list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1472"></a>                         list("article", "the"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1473"></a>                         list("noun", "cat")))))))</p>
</section>
<section>
<h5><a id="c004_c4-sec-0092"></a><a id="c004_c4-title-0093"></a>Exercise 4.43</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1474"></a>With the grammar given above, the following sentence can be parsed in five different ways: “The professor lectures to the student in the class with the cat.” Give the five parses and explain the differences in shades of meaning among them.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0093"></a><a id="c004_c4-title-0094"></a>Exercise 4.44</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1475"></a>The evaluators in sections 4.1 and 4.2 do not determine what order argument expressions are evaluated in. We will see that the <span class="KeyTerm1">amb</span> evaluator evaluates them from left to right. Explain why our parsing program wouldn't work if the argument expressions were evaluated in some other order.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0094"></a><a id="c004_c4-title-0095"></a>Exercise 4.45</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1476"></a>Louis Reasoner suggests that, since a verb phrase is either a verb or a verb phrase followed by a prepositional phrase, it would be much more straightforward to declare the function <span class="KeyTerm1">parse_verb_phrase</span> as follows (and similarly for noun phrases):</p>
<p class="Sp-text-1"><a id="c004_c4-para-1477"></a><b>function</b> parse_verb_phrase() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1478"></a> <b>return</b> amb(parse_word(verbs),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1479"></a>               list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c004_c4-para-1480"></a>                   parse_verb_phrase(),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1481"></a>                   parse_prepositional_phrase()));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1482"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1483"></a>Does this work? Does the program's behavior change if we interchange the order of expressions in the <span class="KeyTerm1">amb</span>?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0095"></a><a id="c004_c4-title-0096"></a>Exercise 4.46</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1484"></a>Extend the grammar given above to handle more complex sentences. For example, you could extend noun phrases and verb phrases to include adjectives and adverbs, or you could handle compound sentences.<a id="c004_c4-fn-0048a"></a><a href="#c4-fn-0048"><sup>48</sup></a></p>
</section>
<section>
<h5><a id="c004_c4-sec-0096"></a><a id="c004_c4-title-0097"></a>Exercise 4.47</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1485"></a>Alyssa P. Hacker is more interested in generating interesting sentences than in parsing them. She reasons that by simply changing the function <span class="KeyTerm1">parse_word</span> so that it ignores the “input sentence” and instead always succeeds and generates an appropriate word, we can use the programs we had built for parsing to do generation instead. Implement Alyssa's idea, and show the first half-dozen or so sentences generated.<a id="c004_c4-fn-0049a"></a><a href="#c4-fn-0049"><sup>49</sup></a></p>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0097"></a><span>4.3.3</span> <a id="c004_c4-title-0098"></a>Implementing the <span class="KeyTerm1">amb</span> Evaluator</h3>
<p class="paraaftertitle"><a id="c004_c4-para-1486"></a>The evaluation of an ordinary JavaScript program may return a value, may never terminate, or may signal an error. In nondeterministic JavaScript the evaluation of a program may in addition result in the discovery of a dead end, in which case evaluation must backtrack to a previous choice point. The interpretation of nondeterministic JavaScript is complicated by this extra case.</p>
<p><a id="c004_c4-para-1487"></a>We will construct the <span class="KeyTerm1">amb</span> evaluator for nondeterministic JavaScript by modifying the analyzing evaluator of section 4.1.7.<a id="c004_c4-fn-0050a"></a><a href="#c4-fn-0050"><sup>50</sup></a> As in the analyzing evaluator, evaluation of a component is accomplished by calling an execution function produced by analysis of that component. The difference between the interpretation of ordinary JavaScript and the interpretation of nondeterministic JavaScript will be entirely in the execution functions.</p>
<section>
<h5><a id="c004_c4-sec-0098"></a><a id="c004_c4-title-0099"></a>Execution functions and continuations</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1488"></a>Recall that the execution functions for the ordinary evaluator take one argument: the environment of execution. In contrast, the execution functions in the <span class="KeyTerm1">amb</span> evaluator take three arguments: the environment, and two functions called <i>continuation functions</i>. The evaluation of a component will finish by calling one of these two continuations: If the evaluation results in a value, the <i>success continuation</i> is called with that value; if the evaluation results in the discovery of a dead end, the <i>failure continuation</i> is called. Constructing and calling appropriate continuations is the mechanism by which the nondeterministic evaluator implements backtracking.</p>
<p><a id="c004_c4-para-1489"></a>It is the job of the success continuation to receive a value and proceed with the computation. Along with that value, the success continuation is passed another failure continuation, which is to be called subsequently if the use of that value leads to a dead end.</p>
<p><a id="c004_c4-para-1490"></a>It is the job of the failure continuation to try another branch of the nondeterministic process. The essence of the nondeterministic language is in the fact that components may represent choices among alternatives. The evaluation of such a component must proceed with one of the indicated alternative choices, even though it is not known in advance which choices will lead to acceptable results. To deal with this, the evaluator picks one of the alternatives and passes this value to the success continuation. Together with this value, the evaluator constructs and passes along a failure continuation that can be called later to choose a different alternative.</p>
<p><a id="c004_c4-para-1491"></a>A failure is triggered during evaluation (that is, a failure continuation is called) when a user program explicitly rejects the current line of attack (for example, a call to <span class="KeyTerm1">require</span> may result in execution of <span class="KeyTerm1">amb()</span>, an expression that always fails—see section 4.3.1). The failure continuation in hand at that point will cause the most recent choice point to choose another alternative. If there are no more alternatives to be considered at that choice point, a failure at an earlier choice point is triggered, and so on. Failure continuations are also invoked by the driver loop in response to a <span class="KeyTerm1">retry</span> request, to find another value of the program.</p>
<p><a id="c004_c4-para-1492"></a>In addition, if a side-effect operation (such as assignment to a variable) occurs on a branch of the process resulting from a choice, it may be necessary, when the process finds a dead end, to undo the side effect before making a new choice. This is accomplished by having the side-effect operation produce a failure continuation that undoes the side effect and propagates the failure.</p>
<p><a id="c004_c4-para-1493"></a>In summary, failure continuations are constructed by</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">amb</span> expressions—to provide a mechanism to make alternative choices if the current choice made by the <span class="KeyTerm1">amb</span> expression leads to a dead end;</li>
<li>the top-level driver—to provide a mechanism to report failure when the choices are exhausted;</li>
<li>assignments—to intercept failures and undo assignments during backtracking. </li>
</ul>
<p><a id="c004_c4-para-1497"></a>Failures are initiated only when a dead end is encountered. This occurs</p>
<ul style="list-style-type:disc">
<li>if the user program executes <span class="KeyTerm1">amb()</span>;</li>
<li>if the user types <span class="KeyTerm1">retry</span> at the top-level driver.</li>
</ul>
<p><a id="c004_c4-para-1500"></a>Failure continuations are also called during processing of a failure:</p>
<ul style="list-style-type:disc">
<li>When the failure continuation created by an assignment finishes undoing a side effect, it calls the failure continuation it intercepted, in order to propagate the failure back to the choice point that led to this assignment or to the top level.</li>
<li>When the failure continuation for an <span class="KeyTerm1">amb</span> runs out of choices, it calls the failure continuation that was originally given to the <span class="KeyTerm1">amb</span>, in order to propagate the failure back to the previous choice point or to the top level.</li>
</ul>
</section>
<section>
<h5><a id="c004_c4-sec-0099"></a><a id="c004_c4-title-0100"></a>Structure of the evaluator</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1503"></a>The syntaxand data-representation functions for the <span class="KeyTerm1">amb</span> evaluator, and also the basic <span class="KeyTerm1">analyze</span> function, are identical to those in the evaluator of section 4.1.7, except for the fact that we need additional syntax functions to recognize the <span class="KeyTerm1">amb</span> syntactic form:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1504"></a><b>function</b> is_amb(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1505"></a> <b>return</b> is_tagged_list(component, "application") &amp;&amp;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1506"></a>           is_name(function_expression(component)) &amp;&amp;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1507"></a>           symbol_of_name(function_expression(component)) === "amb";</p>
<p class="Sp-text-1"><a id="c004_c4-para-1508"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1509"></a><b>function</b> amb_choices(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1510"></a> <b>return</b> arg_expressions(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1511"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1512"></a>We continue to use the parse function of section 4.1.2, which doesn't support <span class="KeyTerm1">amb</span> as a syntactic form and instead treats <span class="KeyTerm1">amb(</span><span class="KeyTerm1"><i>. . .</i></span><span class="KeyTerm1">)</span> as a function application. The function <span class="KeyTerm1">is_amb</span> ensures that whenever the name <span class="KeyTerm1">amb</span> appears as the function expression of an application, the evaluator treats the “application” as a nondeterministic choice point.<a id="c004_c4-fn-0051a"></a><a href="#c4-fn-0051"><sup>51</sup></a></p>
<p><a id="c004_c4-para-1513"></a>We must also add to the dispatch in <span class="KeyTerm1">analyze</span> a clause that will recognize such expressions and generate an appropriate execution function:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1514"></a><i>. . .</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1515"></a>: is_amb(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1516"></a>? analyze_amb(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1517"></a>: is_application(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1518"></a><i>. . .</i></p>
<p><a id="c004_c4-para-1519"></a>The top-level function <span class="KeyTerm1">ambeval</span> (similar to the version of <span class="KeyTerm1">evaluate</span> given in section 4.1.7) analyzes the given component and applies the resulting execution function to the given environment, together with two given continuations:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1520"></a><b>function</b> ambeval(component, env, succeed, fail) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1521"></a> <b>return</b> analyze(component)(env, succeed, fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1522"></a>}</p>
<p><a id="c004_c4-para-1523"></a>A success continuation is a function of two arguments: the value just obtained and another failure continuation to be used if that value leads to a subsequent failure. A failure continuation is a function of no arguments. So the general form of an execution function is</p>
<p class="Sp-text-1"><a id="c004_c4-para-1524"></a>(env, succeed, fail) =&gt; {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1525"></a> <i>//</i> succeed <span class="KeyTerm2"><i>is</i></span> (value, fail) =&gt; <i>. . .</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1526"></a> <i>//</i> fail <span class="KeyTerm2"><i>is</i></span> () =&gt; <i>. . .</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1527"></a> <i>. . .</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1528"></a>}</p>
<p><a id="c004_c4-para-1529"></a>For example, executing</p>
<p class="Sp-text-1"><a id="c004_c4-para-1530"></a>ambeval(<span class="KeyTerm2"><i>component</i></span>,</p>
<p class="Sp-text-1"><a id="c004_c4-para-5531"></a>        the_global_environment,</p>
<p class="Sp-text-1"><a id="c004_c4-para-5532"></a>        (value, fail) =&gt; value,</p>
<p class="Sp-text-1"><a id="c004_c4-para-5533"></a>        () =&gt; "failed");</p>
<p class="paracontinue"><a id="c004_c4-para-1532"></a>will attempt to evaluate the given component and will return either the component's value (if the evaluation succeeds) or the string <span class="KeyTerm1">"failed"</span> (if the evaluation fails). The call to <span class="KeyTerm1">ambeval</span> in the driver loop shown below uses much more complicated continuation functions, which continue the loop and support the <span class="KeyTerm1">retry</span> request.</p>
<p><a id="c004_c4-para-1533"></a>Most of the complexity of the <span class="KeyTerm1">amb</span> evaluator results from the mechanics of passing the continuations around as the execution functions call each other. In going through the following code, you should compare each of the execution functions with the corresponding function for the ordinary evaluator given in section 4.1.7.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0100"></a><a id="c004_c4-title-0101"></a>Simple expressions</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1534"></a>The execution functions for the simplest kinds of expressions are essentially the same as those for the ordinary evaluator, except for the need to manage the continuations. The execution functions simply succeed with the value of the expression, passing along the failure continuation that was passed to them.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1535"></a><b>function</b> analyze_literal(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1536"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1537"></a>             succeed(literal_value(component), fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1538"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1539"></a><b>function</b> analyze_name(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1540"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1541"></a>             succeed(lookup_symbol_value(symbol_of_name(component),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1542"></a>                                         env),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1543"></a>                    fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1544"></a>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1545"></a><b>function</b> analyze_lambda_expression(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1546"></a> <b>const</b> params = lambda_parameter_symbols(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1547"></a> <b>const</b> bfun = analyze(lambda_body(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1548"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1549"></a>             succeed(make_function(params, bfun, env),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1550"></a>                     fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1551"></a>}</p>
<p><a id="c004_c4-para-1552"></a>Notice that looking up a name always “succeeds.” If <span class="KeyTerm1">lookup_symbol_value</span> fails to find the name, it signals an error, as usual. Such a “failure” indicates a program bug—a reference to an unbound name; it is not an indication that we should try another nondeterministic choice instead of the one that is currently being tried.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0101"></a><a id="c004_c4-title-0102"></a>Conditionals and sequences</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1553"></a>Conditionals are also handled in a similar way as in the ordinary evaluator. The execution function generated by <span class="KeyTerm1">analyze_conditional</span> invokes the predicate execution function pfun with a success continuation that checks whether the predicate value is true and goes on to execute either the consequent or the alternative. If the execution of pfun fails, the original failure continuation for the conditional expression is called.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1554"></a><b>function</b> analyze_conditional(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1555"></a> <b>const</b> pfun = analyze(conditional_predicate(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1556"></a> <b>const</b> cfun = analyze(conditional_consequent(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1557"></a> <b>const</b> afun = analyze(conditional_alternative(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1558"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1559"></a>             pfun(env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1560"></a> <i>//</i> <span class="KeyTerm2"><i>success continuation for evaluating the predicate</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-1561"></a> <i>//</i> <span class="KeyTerm2"><i>to obtain</i></span> pred_value (pred_value, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1562"></a>                    is_truthy(pred_value)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1563"></a>                    ? cfun(env, succeed, fail2)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1564"></a>                    : afun(env, succeed, fail2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1565"></a> <i>//</i> <span class="KeyTerm2"><i>failure continuation for evaluating the predicate</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-1566"></a>                  fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1567"></a>}</p>
<p><a id="c004_c4-para-1568"></a>Sequences are also handled in the same way as in the previous evaluator, except for the machinations in the subfunction <span class="KeyTerm1">sequentially</span> that are required for passing the continuations. Namely, to sequentially execute <span class="KeyTerm1">a</span> and then <span class="KeyTerm1">b</span>, we call <span class="KeyTerm1">a</span> with a success continuation that calls <span class="KeyTerm1">b</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1569"></a><b>function</b> analyze_sequence(stmts) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1570"></a> <b>function</b> sequentially(a, b) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1571"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1572"></a>                 a(env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1573"></a> <i>//</i> <span class="KeyTerm2"><i>success continuation for calling</i></span> a</p>
<p class="Sp-text-1"><a id="c004_c4-para-1574"></a>                   (a_value, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1575"></a>                     is_return_value(a_value)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1576"></a>                     ? succeed(a_value, fail2)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1577"></a>                     : b(env, succeed, fail2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1578"></a> <i>//</i> <span class="KeyTerm2"><i>failure continuation for calling</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-1579"></a>                   a fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1580"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1581"></a> <b>function</b> loop(first_fun, rest_funs) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1582"></a> <b>return</b> is_null(rest_funs)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1583"></a>               ? first_fun</p>
<p class="Sp-text-1"><a id="c004_c4-para-1584"></a>               : loop(sequentially(first_fun, head(rest_funs)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1585"></a>                      tail(rest_funs));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1586"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1587"></a> <b>const</b> funs = map(analyze, stmts);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1588"></a> <b>return</b> is_null(funs)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1589"></a>           ? env =&gt; undefined</p>
<p class="Sp-text-1"><a id="c004_c4-para-1590"></a>           : loop(head(funs), tail(funs));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1591"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0102"></a><a id="c004_c4-title-0103"></a>Declarations and assignments</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1592"></a>Declarations are another case where we must go to some trouble to manage the continuations, because it is necessary to evaluate the declaration-value expression before actually declaring the new name. To accomplish this, the declaration-value execution function <span class="KeyTerm1">vfun</span> is called with the environment, a success continuation, and the failure continuation. If the execution of <span class="KeyTerm1">vfun</span> succeeds, obtaining a value <span class="KeyTerm1">val</span> for the declared name, the name is declared and the success is propagated:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1593"></a><b>function</b> analyze_declaration(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1594"></a> <b>const</b> symbol = declaration_symbol(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1595"></a> <b>const</b> vfun = analyze(declaration_value_expression(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1596"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1597"></a>             vfun(env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1598"></a>                  (val, fail2) =&gt; {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1599"></a>                      assign_symbol_value(symbol, val, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1600"></a> <b>return</b> succeed(undefined, fail2);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1601"></a>                  },</p>
<p class="Sp-text-1"><a id="c004_c4-para-1602"></a>                  fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1603"></a>}</p>
<p><a id="c004_c4-para-1604"></a>Assignments are more interesting. This is the first place where we really use the continuations, rather than just passing them around. The execution function for assignments starts out like the one for declarations. It first attempts to obtain the new value to be assigned to the name. If this evaluation of <span class="KeyTerm1">vfun</span> fails, the assignment fails.</p>
<p><a id="c004_c4-para-1605"></a>If <span class="KeyTerm1">vfun</span> succeeds, however, and we go on to make the assignment, we must consider the possibility that this branch of the computation might later fail, which will require us to backtrack out of the assignment. Thus, we must arrange to undo the assignment as part of the backtracking process.<a id="c004_c4-fn-0052a"></a><a href="#c4-fn-0052"><sup>52</sup></a></p>
<p><a id="c004_c4-para-1606"></a>This is accomplished by giving <span class="KeyTerm1">vfun</span> a success continuation (marked with the comment “*1*” below) that saves the old value of the variable before assigning the new value to the variable and proceeding from the assignment. The failure continuation that is passed along with the value of the assignment (marked with the comment “*2*” below) restores the old value of the variable before continuing the failure. That is, a successful assignment provides a failure continuation that will intercept a subsequent failure; whatever failure would otherwise have called <span class="KeyTerm1">fail2</span> calls this function instead, to undo the assignment before actually calling <span class="KeyTerm1">fail2</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1607"></a><b>function</b> analyze_assignment(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1608"></a> <b>const</b> symbol = assignment_symbol(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1609"></a> <b>const</b> vfun = analyze(assignment_value_expression(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1610"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1611"></a>             vfun(env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1612"></a>                  (val, fail2) =&gt; { <i>//</i> *<i>1</i>*</p>
<p class="Sp-text-1"><a id="c004_c4-para-1613"></a> <b>const</b> old_value = lookup_symbol_value(symbol,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1614"></a>                                                            env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1615"></a>                      assign_symbol_value(symbol, val, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1616"></a> <b>return</b> succeed(val,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1617"></a>                                     () =&gt; { <i>//</i> *<i>2</i>*</p>
<p class="Sp-text-1"><a id="c004_c4-para-1618"></a>                                         assign_symbol_value(symbol,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1619"></a>                                                             old_value,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1620"></a>                                                             env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1621"></a> <b>return</b> fail2();</p>
<p class="Sp-text-1"><a id="c004_c4-para-1622"></a>                                     });</p>
<p class="Sp-text-1"><a id="c004_c4-para-1623"></a>                  },</p>
<p class="Sp-text-1"><a id="c004_c4-para-1624"></a>                  fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1625"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0103"></a><a id="c004_c4-title-0104"></a>Return statements and blocks</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1626"></a>Analyzing return statements is straightforward. The return expression is analyzed to produce an execution function. The execution function for the return statement calls that execution function with a success continuation that wraps the return value in a return value object and passes it to the original success continuation.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1627"></a><b>function</b> analyze_return_statement(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1628"></a> <b>const</b> rfun = analyze(return_expression(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1629"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1630"></a>             rfun(env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1631"></a>                  (val, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1632"></a>                    succeed(make_return_value(val), fail2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1633"></a>                  fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1634"></a>}</p>
<p><a id="c004_c4-para-1635"></a>The execution function for blocks calls the body's execution function on an extended environment, without changing success or failure continuations.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1636"></a><b>function</b> analyze_block(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1637"></a> <b>const</b> body = block_body(component);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1638"></a> <b>const</b> locals = scan_out_declarations(body);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1639"></a> <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1640"></a> <b>const</b> bfun = analyze(body);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1641"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1642"></a>             bfun(extend_environment(locals, unassigneds, env),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1643"></a>                  succeed,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1644"></a>                  fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1645"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0104"></a><a id="c004_c4-title-0105"></a>Function applications</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1646"></a>The execution function for applications contains no new ideas except for the technical complexity of managing the continuations. This complexity arises in <span class="KeyTerm1">analyze_ application</span>, due to the need to keep track of the success and failure continuations as we evaluate the argument expressions. We use a function <span class="KeyTerm1">get_args</span> to evaluate the list of argument expressions, rather than a simple <span class="KeyTerm1">map</span> as in the ordinary evaluator.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1647"></a><b>function</b> analyze_application(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1648"></a> <b>const</b> ffun = analyze(function_expression(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1649"></a> <b>const</b> afuns = map(analyze, arg_expressions(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1650"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1651"></a>             ffun(env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1652"></a>                  (fun, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1653"></a>                    get_args(afuns,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1654"></a>                             env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1655"></a>                             (args, fail3) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1656"></a>                               execute_application(fun,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1657"></a>                                                   args,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1658"></a>                                                   succeed,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1659"></a>                                                   fail3),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1660"></a>                             fail2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1661"></a>                  fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1662"></a>}</p>
<p><a id="c004_c4-para-1663"></a>In <span class="KeyTerm1">get_args</span>, notice how walking down the list of <span class="KeyTerm1">afun</span> execution functions and constructing the resulting list of <span class="KeyTerm1">args</span> is accomplished by calling each <span class="KeyTerm1">afun</span> in the list with a success continuation that recursively calls <span class="KeyTerm1">get_args</span>. Each of these recursive calls to <span class="KeyTerm1">get_args</span> has a success continuation whose value is the new list resulting from using <span class="KeyTerm1">pair</span> to adjoin the newly obtained argument to the list of accumulated arguments:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1664"></a><b>function</b> get_args(afuns, env, succeed, fail) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1665"></a> <b>return</b> is_null(afuns)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1666"></a>           ? succeed(<b>null</b>, fail)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1667"></a>           : head(afuns)(env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1668"></a> <i>//</i> <span class="KeyTerm2"><i>success continuation for this</i></span> afun</p>
<p class="Sp-text-1"><a id="c004_c4-para-1669"></a>                         (arg, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1670"></a>                           get_args(tail(afuns),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1671"></a>                                    env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1672"></a> <i>//</i> <span class="KeyTerm2"><i>success continuation for</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-1673"></a> <i>//</i> <span class="KeyTerm2"><i>recursive call to</i></span> get_args</p>
<p class="Sp-text-1"><a id="c004_c4-para-1674"></a>                                    (args, fail3) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1675"></a>                                      succeed(pair(arg, args),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1676"></a>                                              fail3),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1677"></a>                                    fail2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1678"></a>                         fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1679"></a>}</p>
<p><a id="c004_c4-para-1680"></a>The actual function application, which is performed by <span class="KeyTerm1">execute_application</span>, is accomplished in the same way as for the ordinary evaluator, except for the need to manage the continuations.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1681"></a><b>function</b> execute_application(fun, args, succeed, fail) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1682"></a> <b>return</b> is_primitive_function(fun)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1683"></a>           ? succeed(apply_primitive_function(fun, args),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1684"></a>                     fail)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1685"></a>           : is_compound_function(fun)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1686"></a>           ? function_body(fun)(</p>
<p class="Sp-text-1"><a id="c004_c4-para-1687"></a>                 extend_environment(function_parameters(fun),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1688"></a>                                    args,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1689"></a>                                    function_environment(fun)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1690"></a>                 (body_result, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1691"></a>                   succeed(is_return_value(body_result)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1692"></a>                           ? return_value_content(body_result)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1693"></a>                           : undefined,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1694"></a>                           fail2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1695"></a>                 fail)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1696"></a>           : error(fun, "unknown function type - execute_application");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1697"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0105"></a><a id="c004_c4-title-0106"></a>Evaluating <span class="KeyTerm1"><b>amb</b></span> expressions</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1698"></a>The <span class="KeyTerm1">amb</span> syntactic form is the key element in the nondeterministic language. Here we see the essence of the interpretation process and the reason for keeping track of the continuations. The execution function for <span class="KeyTerm1">amb</span> defines a loop <span class="KeyTerm1">try_next</span> that cycles through the execution functions for all the possible values of the <span class="KeyTerm1">amb</span> expression. Each execution function is called with a failure continuation that will try the next one. When there are no more alternatives to try, the entire <span class="KeyTerm1">amb</span> expression fails.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1699"></a><b>function</b> analyze_amb(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1700"></a> <b>const</b> cfuns = map(analyze, amb_choices(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1701"></a> <b>return</b> (env, succeed, fail) =&gt; {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1702"></a> <b>function</b> try_next(choices) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1703"></a> <b>return</b> is_null(choices)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1704"></a>                          ? fail()</p>
<p class="Sp-text-1"><a id="c004_c4-para-1705"></a>                          : head(choices)(env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1706"></a>                                          succeed,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1707"></a>                                          () =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1708"></a>                                            try_next(tail(choices)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1709"></a>               }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1710"></a> <b>return</b> try_next(cfuns);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1711"></a>           };</p>
<p class="Sp-text-1"><a id="c004_c4-para-1712"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0106"></a><a id="c004_c4-title-0107"></a>Driver loop</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1713"></a>The driver loop for the <span class="KeyTerm1">amb</span> evaluator is complex, due to the mechanism that permits the user to retry in evaluating a program. The driver uses a function called <span class="KeyTerm1">internal_loop</span>, which takes as argument a function <span class="KeyTerm1">retry</span>. The intent is that calling <span class="KeyTerm1">retry</span> should go on to the next untried alternative in the nondeterministic evaluation. The function <span class="KeyTerm1">internal_loop</span> either calls <span class="KeyTerm1">retry</span> in response to the user typing <span class="KeyTerm1">retry</span> at the driver loop, or else starts a new evaluation by calling <span class="KeyTerm1">ambeval</span>.</p>
<p><a id="c004_c4-para-1714"></a>The failure continuation for this call to <span class="KeyTerm1">ambeval</span> informs the user that there are no more values and reinvokes the driver loop.</p>
<p><a id="c004_c4-para-1715"></a>The success continuation for the call to <span class="KeyTerm1">ambeval</span> is more subtle. We print the obtained value and then reinvoke the internal loop with a <span class="KeyTerm1">retry</span> function that will be able to try the next alternative. This <span class="KeyTerm1">next_alternative</span> function is the second argument that was passed to the success continuation. Ordinarily, we think of this second argument as a failure continuation to be used if the current evaluation branch later fails. In this case, however, we have completed a successful evaluation, so we can invoke the “failure” alternative branch in order to search for additional successful evaluations.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1716"></a><b>const</b> input_prompt = "amb-evaluate input:";</p>
<p class="Sp-text-1"><a id="c004_c4-para-1717"></a><b>const</b> output_prompt = "amb-evaluate value:";</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1718"></a><b>function</b> driver_loop(env) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1719"></a> <b>function</b> internal_loop(retry) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1720"></a> <b>const</b> input = user_read(input_prompt);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1721"></a> <b>if</b> (is_null(input)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1722"></a>            display("evaluator terminated");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1723"></a>        } <b>else if</b> (input === "retry") {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1724"></a> <b>return</b> retry();</p>
<p class="Sp-text-1"><a id="c004_c4-para-1725"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1726"></a>            display("Starting a new problem");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1727"></a> <b>const</b> program = parse(input);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1728"></a> <b>const</b> locals = scan_out_declarations(program);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1729"></a> <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1730"></a> <b>const</b> program_env = extend_environment(</p>
<p class="Sp-text-1"><a id="c004_c4-para-1731"></a>                                     locals, unassigneds, env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1732"></a> <b>return</b> ambeval(</p>
<p class="Sp-text-1"><a id="c004_c4-para-1733"></a>                       program,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1734"></a>                       program_env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1735"></a> <i>//</i> <span class="KeyTerm2"><i>ambeval success</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-1736"></a>                       (val, next_alternative) =&gt; {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1737"></a>                           user_print(output_prompt, val);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1738"></a> <b>return</b> internal_loop(next_alternative);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1739"></a>                       },</p>
<p class="Sp-text-1"><a id="c004_c4-para-1740"></a> <i>//</i> <span class="KeyTerm2"><i>ambeval failure</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-1741"></a>                       () =&gt; {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1742"></a>                           display("There are no more values of");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1743"></a>                           display(input);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1744"></a> <b>return</b> driver_loop(program_env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1745"></a>                       });</p>
<p class="Sp-text-1"><a id="c004_c4-para-1746"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1747"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-1748"></a> <b>return</b> internal_loop(() =&gt; {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1749"></a>                             display("There is no current problem");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1750"></a> <b>return</b> driver_loop(env);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1751"></a>                         });</p>
<p class="Sp-text-1"><a id="c004_c4-para-1752"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1753"></a>The initial call to <span class="KeyTerm1">internal_loop</span> uses a <span class="KeyTerm1">retry</span> function that complains that there is no current problem and restarts the driver loop. This is the behavior that will happen if the user types <span class="KeyTerm1">retry</span> when there is no evaluation in progress.</p>
<p><a id="c004_c4-para-1754"></a>We start the driver loop as usual, by setting up the global environment and passing it as the enclosing environment for the first iteration of <span class="KeyTerm1">driver_loop</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1755"></a><b>const</b> the_global_environment = setup_environment();</p>
<p class="Sp-text-1"><a id="c004_c4-para-1756"></a>driver_loop(the_global_environment);</p>
</section>
<section>
<h5><a id="c004_c4-sec-0107"></a><a id="c004_c4-title-0108"></a>Exercise 4.48</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1757"></a>Implement a new syntactic form <span class="KeyTerm1">ramb</span> that is like <span class="KeyTerm1">amb</span> except that it searches alternatives in a random order, rather than from left to right. Show how this can help with Alyssa's problem in exercise 4.47.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0108"></a><a id="c004_c4-title-0109"></a>Exercise 4.49</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1758"></a>Change the implementation of assignment so that it is not undone upon failure. For example, we can choose two distinct elements from a list and count the number of trials required to make a successful choice as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1759"></a><b>let</b> count = 0;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1760"></a><b>let</b> x = an_element_of("a", "b", "c");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1761"></a><b>let</b> y = an_element_of("a", "b", "c"); count = count + 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1762"></a>require(x !== y); list(x, y, count);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1763"></a><i>Starting a new problem</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1764"></a><i>amb-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1765"></a><i>["a", ["b", [2, null]]]</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1766"></a><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1767"></a>retry</p>
<p class="Sp-text-3"><a id="c004_c4-para-1768"></a><i>amb-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1769"></a><i>["a", ["c", [3, null]]]</i></p>
<p class="paracontinue"><a id="c004_c4-para-1770"></a>What values would have been displayed if we had used the original meaning of assignment rather than permanent assignment?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0109"></a><a id="c004_c4-title-0110"></a>Exercise 4.50</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1771"></a>We shall horribly abuse the syntax for conditional statements, by implementing a construct of the following form:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1772"></a><b>if</b> (evaluation_succeeds_take) { <span class="KeyTerm2"><i>statement</i></span> } <b>else</b> { <span class="KeyTerm2"><i>alternative</i></span> }</p>
<p class="paracontinue"><a id="c004_c4-para-1773"></a>The construct permits the user to catch the failure of a statement. It evaluates the statement as usual and returns as usual if the evaluation succeeds. If the evaluation fails, however, the given alternative statement is evaluated, as in the following example:</p>
<p class="Sp-text-3"><a id="c004_c4-para-1774"></a>amb-evaluate input:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1775"></a><b>if</b> (evaluation_succeeds_take) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1776"></a> <b>const</b> x = an_element_of(list(1, 3, 5));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1777"></a>    require(is_even(x));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1778"></a>    x;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1779"></a>} <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1780"></a>    "all odd";</p>
<p class="Sp-text-1"><a id="c004_c4-para-1781"></a>}</p>
<p class="Sp-text-3"><a id="c004_c4-para-1782"></a><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1783"></a><i>amb-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1784"></a><i>"all odd"</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1785"></a>amb-evaluate input:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1786"></a><b>if</b> (evaluation_succeeds_take) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1787"></a> <b>const</b> x = an_element_of(list(1, 3, 5, 8));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1788"></a>    require(is_even(x));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1789"></a>    x;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1790"></a>} <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1791"></a>    "all odd";</p>
<p class="Sp-text-1"><a id="c004_c4-para-1792"></a>}</p>
<p class="Sp-text-3"><a id="c004_c4-para-1793"></a><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1794"></a><i>amb-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1795"></a><i>8</i></p>
<p class="paracontinue"><a id="c004_c4-para-1796"></a>Implement this construct by extending the <span class="KeyTerm1">amb</span> evaluator. Hint: The function <span class="KeyTerm1">is_amb</span> shows how to abuse the existing JavaScript syntax in order to implement a new syntactic form.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0110"></a><a id="c004_c4-title-0111"></a>Exercise 4.51</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1797"></a>With the new kind of assignment as described in exercise 4.49 and the construct</p>
<p class="Sp-text-1"><a id="c004_c4-para-1798"></a><b>if</b> (evaluation_succeeds_take) { <i>. . .</i> } <b>else</b> { <i>. . .</i> }</p>
<p class="paracontinue"><a id="c004_c4-para-1799"></a>as in exercise 4.50, what will be the result of evaluating</p>
<p class="Sp-text-1"><a id="c004_c4-para-1800"></a><b>let</b> pairs = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1801"></a><b>if</b> (evaluation_succeeds_take) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1802"></a> <b>const</b> p = prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1803"></a>    pairs = pair(p, pairs); <i>//</i> <span class="KeyTerm2"><i>using permanent assignment</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-1804"></a>    amb();</p>
<p class="Sp-text-1"><a id="c004_c4-para-1805"></a>} <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1806"></a>    pairs;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1807"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0111"></a><a id="c004_c4-title-0112"></a>Exercise 4.52</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1808"></a>If we had not realized that <span class="KeyTerm1">require</span> could be implemented as an ordinary function that uses <span class="KeyTerm1">amb</span>, to be defined by the user as part of a nondeterministic program, we would have had to implement it as a syntactic form. This would require syntax functions</p>
<p class="Sp-text-1"><a id="c004_c4-para-1809"></a><b>function</b> is_require(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1810"></a> <b>return</b> is_tagged_list(component, "require");</p>
<p class="Sp-text-1"><a id="c004_c4-para-1811"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-1812"></a><b>function</b> require_predicate(component) { <b>return</b> head(tail(component)); }</p>
<p class="paracontinue"><a id="c004_c4-para-1813"></a>and a new clause in the dispatch in <span class="KeyTerm1">analyze</span></p>
<p class="Sp-text-1"><a id="c004_c4-para-1814"></a>: is_require(component)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1815"></a>? analyze_require(component)</p>
<p class="paracontinue"><a id="c004_c4-para-1816"></a>as well the function <span class="KeyTerm1">analyze_require</span> that handles <span class="KeyTerm1">require</span> expressions. Complete the following definition of <span class="KeyTerm1">analyze_require</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-1817"></a><b>function</b> analyze_require(component) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1818"></a> <b>const</b> pfun = analyze(require_predicate(component));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1819"></a> <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1820"></a>            pfun(env,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1821"></a>                 (pred_value, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-1822"></a>                   〈??〉</p>
<p class="Sp-text-1"><a id="c004_c4-para-1823"></a>                   ? 〈??〉</p>
<p class="Sp-text-1"><a id="c004_c4-para-1824"></a>                   : succeed("ok", fail2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1825"></a>                 fail);</p>
<p class="Sp-text-1"><a id="c004_c4-para-1826"></a>}</p>
</section>
</section>
</section>
<section>
<h2><a id="c004_c4-sec-0112"></a><span>4.4</span> <a id="c004_c4-title-0113"></a>Logic Programming</h2>
<p class="paraaftertitle"><a id="c004_c4-para-1827"></a>In chapter 1 we stressed that computer science deals with imperative (how to) knowledge, whereas mathematics deals with declarative (what is) knowledge. Indeed, programming languages require that the programmer express knowledge in a form that indicates the step-by-step methods for solving particular problems. On the other hand, high-level languages provide, as part of the language implementation, a substantial amount of methodological knowledge that frees the user from concern with numerous details of how a specified computation will progress.</p>
<p><a id="c004_c4-para-1828"></a>Most programming languages, including JavaScript, are organized around computing the values of mathematical functions. Expression-oriented languages (such as Lisp, C, Python, and JavaScript) capitalize on the “pun” that an expression that describes the value of a function may also be interpreted as a means of computing that value. Because of this, most programming languages are strongly biased toward unidirectional computations (computations with well-defined inputs and outputs). There are, however, radically different programming languages that relax this bias. We saw one such example in section 3.3.5, where the objects of computation were arithmetic constraints. In a constraint system the direction and the order of computation are not so well specified; in carrying out a computation the system must therefore provide more detailed “how to” knowledge than would be the case with an ordinary arithmetic computation. This does not mean, however, that the user is released altogether from the responsibility of providing imperative knowledge. There are many constraint networks that implement the same set of constraints, and the user must choose from the set of mathematically equivalent networks a suitable network to specify a particular computation.</p>
<p><a id="c004_c4-para-1829"></a>The nondeterministic program evaluator of section 4.3 also moves away from the view that programming is about constructing algorithms for computing unidirectional functions. In a nondeterministic language, expressions can have more than one value, and, as a result, the computation is dealing with relations rather than with single-valued functions. Logic programming extends this idea by combining a relational vision of programming with a powerful kind of symbolic pattern matching called <i>unification</i>.<a id="c004_c4-fn-0053a"></a><a href="#c4-fn-0053"><sup>53</sup></a></p>
<p><a id="c004_c4-para-1830"></a>This approach, when it works, can be a very powerful way to write programs. Part of the power comes from the fact that a single “what is” fact can be used to solve a number of different problems that would have different “how to” components. As an example, consider the <span class="KeyTerm1">append</span> operation, which takes two lists as arguments and combines their elements to form a single list. In a procedural language such as JavaScript, we could define <span class="KeyTerm1">append</span> in terms of the basic list constructor <span class="KeyTerm1">pair</span>, as we did in section 2.2.1:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1831"></a><b>function</b> append(x, y) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-1832"></a> <b>return</b> is_null(x)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1833"></a>           ? y</p>
<p class="Sp-text-1"><a id="c004_c4-para-1834"></a>           : pair(head(x), append(tail(x), y));</p>
<p class="Sp-text-1"><a id="c004_c4-para-1835"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-1836"></a>This function can be regarded as a translation into JavaScript of the following two rules, the first of which covers the case where the first list is empty and the second of which handles the case of a nonempty list, which is a <span class="KeyTerm1">pair</span> of two parts:</p>
<ul style="list-style-type:disc">
<li>For any list <span class="KeyTerm1">y</span>, the empty list and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">y</span>.</li>
<li>For any <span class="KeyTerm1">u</span>, <span class="KeyTerm1">v</span>, <span class="KeyTerm1">y</span>, and <span class="KeyTerm1">z</span>, <span class="KeyTerm1">pair(u, v)</span> and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">pair(u, z)</span> if <span class="KeyTerm1">v</span> and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">z</span>.<a id="c004_c4-fn-0054a"></a><a href="#c4-fn-0054"><sup>54</sup></a></li>
</ul>
<p class="paracontinue"><a id="c004_c4-para-1839"></a>Using the <span class="KeyTerm1">append</span> function, we can answer questions such as</p>
<p><a id="c004_c4-para-5839"></a>Find the <span class="KeyTerm1">append</span> of <span class="KeyTerm1">list("a", "b")</span> and <span class="KeyTerm1">list("c", "d")</span>.</p>
<p class="paracontinue"><a id="c004_c4-para-1840"></a>But the same two rules are also sufficient for answering the following sorts of questions, which the function can't answer:</p>
<p><a id="c004_c4-para-1841"></a>Find a list <span class="KeyTerm1">y</span> that <span class="KeyTerm1">append</span>s with <span class="KeyTerm1">list("a", "b")</span> to produce</p>
<p class="Sp-text-1"><a id="c004_c4-para-1842"></a>    list("a", "b", "c", "d").</p>
<p><a id="c004_c4-para-1843"></a>Find all <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> that <span class="KeyTerm1">append</span> to form <span class="KeyTerm1">list("a", "b", "c", "d")</span>.</p>
<p class="paracontinue"><a id="c004_c4-para-1844"></a>In a logic programming language, the programmer writes an <span class="KeyTerm1">append</span> “function” by stating the two rules about <span class="KeyTerm1">append</span> given above. “How to” knowledge is provided automatically by the interpreter to allow this single pair of rules to be used to answer all three types of questions about <span class="KeyTerm1">append</span>.<a id="c004_c4-fn-0055a"></a><a href="#c4-fn-0055"><sup>55</sup></a></p>
<p><a id="c004_c4-para-1845"></a>Contemporary logic programming languages (including the one we implement here) have substantial deficiencies, in that their general “how to” methods can lead them into spurious infinite loops or other undesirable behavior. Logic programming is an active field of research in computer science.<a id="c004_c4-fn-0056a"></a><a href="#c4-fn-0056"><sup>56</sup></a></p>
<p><a id="c004_c4-para-1846"></a>Earlier in this chapter we explored the technology of implementing interpreters and described the elements that are essential to an interpreter for a JavaScript-like language (indeed, to an interpreter for any conventional language). Now we will apply these ideas to discuss an interpreter for a logic programming language. We call this language the <i>query language</i>, because it is very useful for retrieving information from data bases by formulating <i>queries</i>, or questions, expressed in the language. Even though the query language is very different from JavaScript, we will find it convenient to describe the language in terms of the same general framework we have been using all along: as a collection of primitive elements, together with means of combination that enable us to combine simple elements to create more complex elements and means of abstraction that enable us to regard complex elements as single conceptual units. An interpreter for a logic programming language is considerably more complex than an interpreter for a language like JavaScript. Nevertheless, we will see that our query-language interpreter contains many of the same elements found in the interpreter of section 4.1. In particular, there will be an “evaluate” part that classifies expressions according to type and an “apply” part that implements the language's abstraction mechanism (functions in the case of JavaScript, and <i>rules</i> in the case of logic programming). Also, a central role is played in the implementation by a frame data structure, which determines the correspondence between symbols and their associated values. One additional interesting aspect of our query-language implementation is that we make substantial use of streams, which were introduced in chapter 3.</p>
<section>
<h3><a id="c004_c4-sec-0113"></a><span>4.4.1</span> <a id="c004_c4-title-0114"></a>Deductive Information Retrieval</h3>
<p class="paraaftertitle"><a id="c004_c4-para-1847"></a>Logic programming excels in providing interfaces to data bases for information retrieval. The query language we shall implement in this chapter is designed to be used in this way.</p>
<p><a id="c004_c4-para-1848"></a>In order to illustrate what the query system does, we will show how it can be used to manage the data base of personnel records for Gargle, a thriving high-technology company in the Boston area. The language provides pattern-directed access to personnel information and can also take advantage of general rules in order to make logical deductions.</p>
<section>
<h5><a id="c004_c4-sec-0114"></a><a id="c004_c4-title-0115"></a>A sample data base</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1849"></a>The personnel data base for Gargle contains <i>assertions</i> about company personnel. Here is the information about Ben Bitdiddle, the resident computer wizard:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1850"></a>address(list("Bitdiddle", "Ben"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1851"></a>        list("Slumerville", list("Ridge", "Road"), 10))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1852"></a>job(list("Bitdiddle", "Ben"), list("computer", "wizard"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1853"></a>salary(list("Bitdiddle", "Ben"), 122000)</p>
<p class="paracontinue"><a id="c004_c4-para-1854"></a>Assertions look just like function applications in JavaScript, but they actually represent information in the data base. The first symbols—here <span class="KeyTerm1">address</span>, <span class="KeyTerm1">job</span> and <span class="KeyTerm1">salary</span>—describe the <i>kind of information</i> contained in the respective assertion, and the “arguments” are lists or primitive values such as strings and numbers. The first symbols do not need to be declared, as do constants or variables in JavaScript; their scope is global.</p>
<p><a id="c004_c4-para-1855"></a>As resident wizard, Ben is in charge of the company's computer division, and he supervises two programmers and one technician. Here is the information about them:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1856"></a>address(list("Hacker", "Alyssa", "P"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1857"></a>        list("Cambridge", list("Mass", "Ave"), 78))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1858"></a>job(list("Hacker", "Alyssa", "P"), list("computer", "programmer"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1859"></a>salary(list("Hacker", "Alyssa", "P"), 81000)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1860"></a>supervisor(list("Hacker", "Alyssa", "P"), list("Bitdiddle", "Ben"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1861"></a>address(list("Fect", "Cy", "D"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1862"></a>        list("Cambridge", list("Ames", "Street"), 3))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1863"></a>job(list("Fect", "Cy", "D"), list("computer", "programmer"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1864"></a>salary(list("Fect", "Cy", "D"), 70000)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1865"></a>supervisor(list("Fect", "Cy", "D"), list("Bitdiddle", "Ben"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1866"></a>address(list("Tweakit", "Lem", "E"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1867"></a>        list("Boston", list("Bay", "State", "Road"), 22))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1868"></a>job(list("Tweakit", "Lem", "E"), list("computer", "technician"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1869"></a>salary(list("Tweakit", "Lem", "E"), 51000)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1870"></a>supervisor(list("Tweakit", "Lem", "E"), list("Bitdiddle", "Ben"))</p>
<p class="paracontinue"><a id="c004_c4-para-1871"></a>There is also a programmer trainee, who is supervised by Alyssa:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1872"></a>address(list("Reasoner", "Louis"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1873"></a>        list("Slumerville", list("Pine", "Tree", "Road"), 80))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1874"></a>job(list("Reasoner", "Louis"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1875"></a>        list("computer", "programmer", "trainee"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1876"></a>salary(list("Reasoner", "Louis"), 62000)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1877"></a>supervisor(list("Reasoner", "Louis"), list("Hacker", "Alyssa", "P"))</p>
<p class="paracontinue"><a id="c004_c4-para-1878"></a>All these people are in the computer division, as indicated by the word <span class="KeyTerm1">"computer"</span> as the first item in their job descriptions.</p>
<p><a id="c004_c4-para-1879"></a>Ben is a high-level employee. His supervisor is the company's big wheel himself:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1880"></a>supervisor(list("Bitdiddle", "Ben"), list("Warbucks", "Oliver"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1881"></a>address(list("Warbucks", "Oliver"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1882"></a>        list("Swellesley", list("Top", "Heap", "Road")))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1883"></a>job(list("Warbucks", "Oliver"), list("administration", "big", "wheel"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1884"></a>salary(list("Warbucks", "Oliver"), 314159)</p>
<p><a id="c004_c4-para-1885"></a>Besides the computer division supervised by Ben, the company has an accounting division, consisting of a chief accountant and his assistant:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1886"></a>address(list("Scrooge", "Eben"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1887"></a>        list("Weston", list("Shady", "Lane"), 10))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1888"></a>job(list("Scrooge", "Eben"), list("accounting", "chief", "accountant"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1889"></a>salary(list("Scrooge", "Eben"), 141421)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1890"></a>supervisor(list("Scrooge", "Eben"), list("Warbucks", "Oliver"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1891"></a>address(list("Cratchit", "Robert"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1892"></a>        list("Allston", list("N", "Harvard", "Street"), 16))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1893"></a>job(list("Cratchit", "Robert"), list("accounting", "scrivener"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1894"></a>salary(list("Cratchit", "Robert"), 26100)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1895"></a>supervisor(list("Cratchit", "Robert"), list("Scrooge", "Eben"))</p>
<p class="paracontinue"><a id="c004_c4-para-1896"></a>There is also an administrative assistant for the big wheel:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1897"></a>address(list("Aull", "DeWitt"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1898"></a>        list("Slumerville", list("Onion", "Square"), 5))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1899"></a>job(list("Aull", "DeWitt"), list("administration", "assistant"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1900"></a>salary(list("Aull", "DeWitt"), 42195)</p>
<p class="Sp-text-1"><a id="c004_c4-para-1901"></a>supervisor(list("Aull", "DeWitt"), list("Warbucks", "Oliver"))</p>
<p><a id="c004_c4-para-1902"></a>The data base also contains assertions about which kinds of jobs can be done by people holding other kinds of jobs. For instance, a computer wizard can do the jobs of both a computer programmer and a computer technician:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1903"></a>can_do_job(list("computer", "wizard"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1904"></a>           list("computer", "programmer"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1905"></a>can_do_job(list("computer", "wizard"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1906"></a>           list("computer", "technician"))</p>
<p class="paracontinue"><a id="c004_c4-para-1907"></a>A computer programmer could fill in for a trainee:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1908"></a>can_do_job(list("computer", "programmer"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1909"></a>           list("computer", "programmer", "trainee"))</p>
<p class="paracontinue"><a id="c004_c4-para-1910"></a>Also, as is well known,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1911"></a>can_do_job(list("administration", "assistant"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1912"></a>           list("administration", "big", "wheel"))</p>
</section>
<section>
<h5><a id="c004_c4-sec-0115"></a><a id="c004_c4-title-0116"></a>Simple queries</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1913"></a>The query language allows users to retrieve information from the data base by posing queries in response to the system's prompt. For example, to find all computer programmers one can say</p>
<p class="Sp-text-3"><a id="c004_c4-para-1914"></a><i>Query input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1915"></a>job($x, list("computer", "programmer"))</p>
<p class="paracontinue"><a id="c004_c4-para-1916"></a>The system will respond with the following items:</p>
<p class="Sp-text-3"><a id="c004_c4-para-1917"></a><i>Query results:</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1918"></a><i>job(list("Hacker", "Alyssa", "P"), list("computer", "programmer"))</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-1919"></a><i>job(list("Fect", "Cy", "D"), list("computer", "programmer"))</i></p>
<p><a id="c004_c4-para-1920"></a>The input query specifies that we are looking for entries in the data base that match a certain <i>pattern</i>. In this example, the pattern specifies <span class="KeyTerm1">job</span> as the kind of information that we are looking for. The first item can be anything, and the second is the literal list <span class="KeyTerm1">list("computer", "programmer")</span>. The “anything” that can be the first item in the matching assertion is specified by a <i>pattern variable</i>, <span class="KeyTerm1">$x</span>. As pattern variables, we use JavaScript names that start with a dollar sign. We will see below why it is useful to specify names for pattern variables rather than just putting a single symbol such as <span class="KeyTerm1">$</span> into patterns to represent “anything.” The system responds to a simple query by showing all entries in the data base that match the specified pattern.</p>
<p><a id="c004_c4-para-1921"></a>A pattern can have more than one variable. For example, the query</p>
<p class="Sp-text-1"><a id="c004_c4-para-1922"></a>address($x, $y)</p>
<p class="paracontinue"><a id="c004_c4-para-1923"></a>will list all the employees’ addresses.</p>
<p><a id="c004_c4-para-1924"></a>A pattern can have no variables, in which case the query simply determines whether that pattern is an entry in the data base. If so, there will be one match; if not, there will be no matches.</p>
<p><a id="c004_c4-para-1925"></a>The same pattern variable can appear more than once in a query, specifying that the same “anything” must appear in each position. This is why variables have names. For example,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1926"></a>supervisor($x, $x)</p>
<p class="paracontinue"><a id="c004_c4-para-1927"></a>finds all people who supervise themselves (though there are no such assertions in our sample data base).</p>
<p><a id="c004_c4-para-1928"></a>The query</p>
<p class="Sp-text-1"><a id="c004_c4-para-1929"></a>job($x, list("computer", $type))</p>
<p class="paracontinue"><a id="c004_c4-para-1930"></a>matches all job entries whose second item is a two-element list whose first item is <span class="KeyTerm1">"computer"</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1931"></a>job(list("Bitdiddle", "Ben"), list("computer", "wizard"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1932"></a>job(list("Hacker", "Alyssa", "P"), list("computer", "programmer"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1933"></a>job(list("Fect", "Cy", "D"), list("computer", "programmer"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-1934"></a>job(list("Tweakit", "Lem", "E"), list("computer", "technician"))</p>
<p class="paracontinue"><a id="c004_c4-para-1935"></a>This same pattern does <i>not</i> match</p>
<p class="Sp-text-1"><a id="c004_c4-para-1936"></a>job(list("Reasoner", "Louis"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1937"></a>    list("computer", "programmer", "trainee"))</p>
<p class="paracontinue"><a id="c004_c4-para-1938"></a>because the second item in the assertion is a list of three elements, and the pattern's second item specifies that there should be two elements. If we wanted to change the pattern so that the second item could be any list beginning with <span class="KeyTerm1">"computer"</span>, we could specify</p>
<p class="Sp-text-1"><a id="c004_c4-para-1939"></a>job($x, pair("computer", $type))</p>
<p class="paracontinue"><a id="c004_c4-para-1940"></a>For example,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1941"></a>pair("computer", $type)</p>
<p class="paracontinue"><a id="c004_c4-para-1942"></a>matches the data</p>
<p class="Sp-text-1"><a id="c004_c4-para-1943"></a>list("computer", "programmer", "trainee")</p>
<p class="paracontinue"><a id="c004_c4-para-1944"></a>with <span class="KeyTerm1">$type</span> as <span class="KeyTerm1">list("programmer", "trainee")</span>. It also matches the data</p>
<p class="Sp-text-1"><a id="c004_c4-para-1945"></a>list("computer", "programmer")</p>
<p class="paracontinue"><a id="c004_c4-para-1946"></a>with <span class="KeyTerm1">$type</span> as <span class="KeyTerm1">list("programmer")</span>, and matches the data</p>
<p class="Sp-text-1"><a id="c004_c4-para-1947"></a>list("computer")</p>
<p class="paracontinue"><a id="c004_c4-para-1948"></a>with <span class="KeyTerm1">$type</span> as the empty list, <span class="KeyTerm1"><b>null</b></span>.</p>
<p><a id="c004_c4-para-1949"></a>We can describe the query language's processing of simple queries as follows:</p>
<ul style="list-style-type:disc">
<li>The system finds all assignments to variables in the query pattern that <i>satisfy</i> the pattern—that is, all sets of values for the variables such that if the pattern variables are <i>instantiated with</i> (replaced by) the values, the result is in the data base.</li>
<li>The system responds to the query by listing all instantiations of the query pattern with the variable assignments that satisfy it.</li>
</ul>
<p class="paracontinue"><a id="c004_c4-para-1952"></a>Note that if the pattern has no variables, the query reduces to a determination of whether that pattern is in the data base. If so, the empty assignment, which assigns no values to variables, satisfies that pattern for that data base.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0116"></a><a id="c004_c4-title-0117"></a>Exercise 4.53</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1953"></a>Give simple queries that retrieve the following information from the data base:</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0074"></a><span>a. </span>all people supervised by Ben Bitdiddle;</li>
<li><a id="c004_c4-li-0075"></a><span>b. </span>the names and jobs of all people in the accounting division;</li>
<li><a id="c004_c4-li-0076"></a><span>c. </span>the names and addresses of all people who live in Slumerville.</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0117"></a><a id="c004_c4-title-0118"></a>Compound queries</h5>
<p class="paraaftertitle"><a id="c004_c4-para-1957"></a>Simple queries form the primitive operations of the query language. In order to form compound operations, the query language provides means of combination. One thing that makes the query language a logic programming language is that the means of combination mirror the means of combination used in forming logical expressions: <span class="KeyTerm1">and</span>, <span class="KeyTerm1">or</span>, and <span class="KeyTerm1">not</span>.</p>
<p><a id="c004_c4-para-1958"></a>We can use <span class="KeyTerm1">and</span> as follows to find the addresses of all the computer programmers:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1959"></a>and(job($person, list("computer", "programmer")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1960"></a>    address($person, $where))</p>
<p class="paracontinue"><a id="c004_c4-para-1961"></a>The resulting output is</p>
<p class="Sp-text-1"><a id="c004_c4-para-1962"></a><i>and(job(list("Hacker", "Alyssa", "P"), list("computer", "programmer")),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1963"></a> <i>address(list("Hacker", "Alyssa", "P"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1964"></a> <i>list("Cambridge", list("Mass", "Ave"), 78)))</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1965"></a><i>and(job(list("Fect", "Cy", "D"), list("computer", "programmer")),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1966"></a> <i>address(list("Fect", "Cy", "D"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1967"></a> <i>list("Cambridge", list("Ames", "Street"), 3)))</i></p>
<p class="paracontinue"><a id="c004_c4-para-1968"></a>In general,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1969"></a>and(<span class="KeyTerm2"><i>query</i><sub>1</sub></span>, <span class="KeyTerm2"><i>query</i><sub>2</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>query<sub>n</sub></i></span>)</p>
<p class="paracontinue"><a id="c004_c4-para-1970"></a>is satisfied by all sets of values for the pattern variables that simultaneously satisfy <i>query</i><sub>1</sub>, <span class="KeyTerm1"><i>. . .</i></span> , <i>query<sub>n</sub></i>.</p>
<p><a id="c004_c4-para-1971"></a>As for simple queries, the system processes a compound query by finding all assignments to the pattern variables that satisfy the query, then displaying instantiations of the query with those values.</p>
<p><a id="c004_c4-para-1972"></a>Another means of constructing compound queries is through <span class="KeyTerm1">or</span>. For example,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1973"></a>or(supervisor($x, list("Bitdiddle", "Ben")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1974"></a>   supervisor($x, list("Hacker", "Alyssa", "P")))</p>
<p class="paracontinue"><a id="c004_c4-para-1975"></a>will find all employees supervised by Ben Bitdiddle or Alyssa P. Hacker:</p>
<p class="Sp-text-1"><a id="c004_c4-para-1976"></a><i>or(supervisor(list("Hacker", "Alyssa", "P"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1977"></a> <i>list("Bitdiddle", "Ben")),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1978"></a> <i>supervisor(list("Hacker", "Alyssa", "P"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1979"></a> <i>list("Hacker", "Alyssa", "P")))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1980"></a><i>or(supervisor(list("Fect", "Cy", "D"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1981"></a> <i>list("Bitdiddle", "Ben")),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1982"></a> <i>supervisor(list("Fect", "Cy", "D"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1983"></a> <i>list("Hacker", "Alyssa", "P")))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1984"></a><i>or(supervisor(list("Tweakit", "Lem", "E"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1985"></a> <i>list("Bitdiddle", "Ben")),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1986"></a> <i>supervisor(list("Tweakit", "Lem", "E"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1987"></a> <i>list("Hacker", "Alyssa", "P")))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-1988"></a><i>or(supervisor(list("Reasoner", "Louis"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1989"></a> <i>list("Bitdiddle", "Ben")),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1990"></a> <i>supervisor(list("Reasoner", "Louis"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-1991"></a> <i>list("Hacker", "Alyssa", "P")))</i></p>
<p class="paracontinue"><a id="c004_c4-para-1992"></a>In general,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1993"></a>or(<span class="KeyTerm2"><i>query</i><sub>1</sub></span>, <span class="KeyTerm2"><i>query</i><sub>2</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>query<sub>n</sub></i></span>)</p>
<p class="paracontinue"><a id="c004_c4-para-1994"></a>is satisfied by all sets of values for the pattern variables that satisfy at least one of <i>query</i><sub>1</sub> <span class="KeyTerm1"><i>. . .</i></span> <i>query<sub>n</sub></i>.</p>
<p><a id="c004_c4-para-1995"></a>Compound queries can also be formed with <span class="KeyTerm1">not</span>. For example,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1996"></a>and(supervisor($x, list("Bitdiddle", "Ben")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-1997"></a>    not(job($x, list("computer", "programmer"))))</p>
<p class="paracontinue"><a id="c004_c4-para-1998"></a>finds all people supervised by Ben Bitdiddle who are not computer programmers. In general,</p>
<p class="Sp-text-1"><a id="c004_c4-para-1999"></a>not(<span class="KeyTerm2"><i>query</i><sub>1</sub></span>)</p>
<p class="paracontinue"><a id="c004_c4-para-2000"></a>is satisfied by all assignments to the pattern variables that do not satisfy <i>query</i><sub>1</sub>.<a id="c004_c4-fn-0057a"></a><a href="#c4-fn-0057"><sup>57</sup></a></p>
<p><a id="c004_c4-para-2001"></a>The final combining form starts with <span class="KeyTerm1">javascript_predicate</span> and contains a JavaScript predicate. In general,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2002"></a>javascript_predicate(<span class="KeyTerm2"><i>predicate</i></span>)</p>
<p class="paracontinue"><a id="c004_c4-para-2003"></a>will be satisfied by assignments to the pattern variables in the <i>predicate</i> for which the instantiated <i>predicate</i> is true. For example, to find all people whose salary is greater than $50,000 we could write<a id="c004_c4-fn-0058a"></a><a href="#c4-fn-0058"><sup>58</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-2004"></a>and(salary($person, $amount), javascript_predicate($amount &gt; 50000))</p>
</section>
<section>
<h5><a id="c004_c4-sec-0118"></a><a id="c004_c4-title-0119"></a>Exercise 4.54</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2005"></a>Formulate compound queries that retrieve the following information:</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0077"></a><span>a. </span>the names of all people who are supervised by Ben Bitdiddle, together with their addresses;</li>
<li><a id="c004_c4-li-0078"></a><span>b. </span>all people whose salary is less than Ben Bitdiddle's, together with their salary and Ben Bitdiddle's salary;</li>
<li><a id="c004_c4-li-0079"></a><span>c. </span>all people who are supervised by someone who is not in the computer division, together with the supervisor's name and job.</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0119"></a><a id="c004_c4-title-0120"></a>Rules</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2009"></a>In addition to primitive queries and compound queries, the query language provides means for abstracting queries. These are given by <i>rules</i>. The rule</p>
<p class="Sp-text-1"><a id="c004_c4-para-2010"></a>rule(lives_near($person_1, $person_2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2011"></a>    and(address($person_1, pair($town, $rest_1)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2012"></a>        address($person_2, pair($town, $rest_2)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2013"></a>        not(same($person_1, $person_2))))</p>
<p class="paracontinue"><a id="c004_c4-para-2014"></a>specifies that two people live near each other if they live in the same town. The final <span class="KeyTerm1">not</span> clause prevents the rule from saying that all people live near themselves. The <span class="KeyTerm1">same</span> relation is defined by a very simple rule:<a id="c004_c4-fn-0059a"></a><a href="#c4-fn-0059"><sup>59</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-2015"></a>rule(same($x, $x))</p>
<p><a id="c004_c4-para-2016"></a>The following rule declares that a person is a “wheel” in an organization if he supervises someone who is in turn a supervisor:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2017"></a>rule(wheel($person),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2018"></a>     and(supervisor($middle_manager, $person),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2019"></a>         supervisor($x, $middle_manager)))</p>
<p><a id="c004_c4-para-2020"></a>The general form of a rule is</p>
<p class="Sp-text-1"><a id="c004_c4-para-2021"></a>rule(<span class="KeyTerm2"><i>conclusion</i></span>, <span class="KeyTerm2"><i>body</i></span>)</p>
<p class="paracontinue"><a id="c004_c4-para-2022"></a>where <i>conclusion</i> is a pattern and <i>body</i> is any query.<a id="c004_c4-fn-0060a"></a><a href="#c4-fn-0060"><sup>60</sup></a> We can think of a rule as representing a large (even infinite) set of assertions, namely all instantiations of the rule conclusion with variable assignments that satisfy the rule body. When we described simple queries (patterns), we said that an assignment to variables satisfies a pattern if the instantiated pattern is in the data base. But the pattern needn't be explicitly in the data base as an assertion. It can be an implicit assertion implied by a rule. For example, the query</p>
<p class="Sp-text-1"><a id="c004_c4-para-2023"></a>lives_near($x, list("Bitdiddle", "Ben"))</p>
<p class="paracontinue"><a id="c004_c4-para-2024"></a>results in</p>
<p class="Sp-text-3"><a id="c004_c4-para-2025"></a><i>lives_near(list("Reasoner", "Louis"), list("Bitdiddle", "Ben"))</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2026"></a><i>lives_near(list("Aull", "DeWitt"), list("Bitdiddle", "Ben"))</i></p>
<p class="paracontinue"><a id="c004_c4-para-2027"></a>To find all computer programmers who live near Ben Bitdiddle, we can ask</p>
<p class="Sp-text-1"><a id="c004_c4-para-2028"></a>and(job($x, list("computer", "programmer")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2029"></a>    lives_near($x, list("Bitdiddle", "Ben")))</p>
<p><a id="c004_c4-para-2030"></a>As in the case of compound functions, rules can be used as parts of other rules (as we saw with the <span class="KeyTerm1">lives_near</span> rule above) or even be defined recursively. For instance, the rule</p>
<p class="Sp-text-1"><a id="c004_c4-para-2031"></a>rule(outranked_by($staff_person, $boss),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2032"></a>     or(supervisor($staff_person, $boss),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2033"></a>        and(supervisor($staff_person, $middle_manager),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2034"></a>            outranked_by($middle_manager, $boss))))</p>
<p class="paracontinue"><a id="c004_c4-para-2035"></a>says that a staff person is outranked by a boss in the organization if the boss is the person's supervisor or (recursively) if the person's supervisor is outranked by the boss.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0120"></a><a id="c004_c4-title-0121"></a>Exercise 4.55</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2036"></a>Define a rule that says that person 1 can replace person 2 if either person 1 does the same job as person 2 or someone who does person 1's job can also do person 2's job, and if person 1 and person 2 are not the same person. Using your rule, give queries that find the following:</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0080"></a><span>a. </span>all people who can replace Cy D. Fect;</li>
<li><a id="c004_c4-li-0081"></a><span>b. </span>all people who can replace someone who is being paid more than they are, together with the two salaries.</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0121"></a><a id="c004_c4-title-0122"></a>Exercise 4.56</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2039"></a>Define a rule that says that a person is a “big shot” in a division if the person works in the division but does not have a supervisor who works in the division.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0122"></a><a id="c004_c4-title-0123"></a>Exercise 4.57</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2040"></a>Ben Bitdiddle has missed one meeting too many. Fearing that his habit of forgetting meetings could cost him his job, Ben decides to do something about it. He adds all the weekly meetings of the firm to the Gargle data base by asserting the following:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2041"></a>meeting("accounting", list("Monday", "9am"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2042"></a>meeting("administration", list("Monday", "10am"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2043"></a>meeting("computer", list("Wednesday", "3pm"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2044"></a>meeting("administration", list("Friday", "1pm"))</p>
<p class="paracontinue"><a id="c004_c4-para-2045"></a>Each of the above assertions is for a meeting of an entire division. Ben also adds an entry for the company-wide meeting that spans all the divisions. All of the company's employees attend this meeting.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2046"></a>meeting("whole-company", list("Wednesday", "4pm"))</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0082"></a><span>a. </span>On Friday morning, Ben wants to query the data base for all the meetings that occur that day. What query should he use?</li>
<li><a id="c004_c4-li-0083"></a><span>b. </span>Alyssa P. Hacker is unimpressed. She thinks it would be much more useful to be able to ask for her meetings by specifying her name. So she designs a rule that says that a person's meetings include all <span class="KeyTerm1">"whole-company"</span> meetings plus all meetings of that person's division. Fill in the body of Alyssa's rule.
<p class="Sp-text-1"><a id="c004_c4-para-2049"></a>rule(meeting_time($person, $day_and_time),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2050"></a> <span class="KeyTerm2"><i>rule</i>-<i>body</i></span>)</p></li>
<li><a id="c004_c4-li-0084"></a><span>c. </span>Alyssa arrives at work on Wednesday morning and wonders what meetings she has to attend that day. Having defined the above rule, what query should she make to find this out?</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0123"></a><a id="c004_c4-title-0124"></a>Exercise 4.58</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2052"></a>By giving the query</p>
<p class="Sp-text-1"><a id="c004_c4-para-2053"></a>lives_near($person, list("Hacker", "Alyssa", "P"))</p>
<p class="paracontinue"><a id="c004_c4-para-2054"></a>Alyssa P. Hacker is able to find people who live near her, with whom she can ride to work. On the other hand, when she tries to find all pairs of people who live near each other by querying</p>
<p class="Sp-text-1"><a id="c004_c4-para-2055"></a>lives_near($person_1, $person_2)</p>
<p class="paracontinue"><a id="c004_c4-para-2056"></a>she notices that each pair of people who live near each other is listed twice; for example,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2057"></a>lives_near(list("Hacker", "Alyssa", "P"), list("Fect", "Cy", "D"))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2058"></a>lives_near(list("Fect", "Cy", "D"), list("Hacker", "Alyssa", "P"))</p>
<p class="paracontinue"><a id="c004_c4-para-2059"></a>Why does this happen? Is there a way to find a list of people who live near each other, in which each pair appears only once? Explain.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0124"></a><a id="c004_c4-title-0125"></a>Logic as programs</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2060"></a>We can regard a rule as a kind of logical implication: <i>If</i> an assignment of values to pattern variables satisfies the body, <i>then</i> it satisfies the conclusion. Consequently, we can regard the query language as having the ability to perform <i>logical deductions</i> based upon the rules. As an example, consider the <span class="KeyTerm1">append</span> operation described at the beginning of section 4.4. As we said, <span class="KeyTerm1">append</span> can be characterized by the following two rules:</p>
<ul style="list-style-type:disc">
<li>For any list <span class="KeyTerm1">y</span>, the empty list and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">y</span>.</li>
<li>For any <span class="KeyTerm1">u</span>, <span class="KeyTerm1">v</span>, <span class="KeyTerm1">y</span>, and <span class="KeyTerm1">z</span>, <span class="KeyTerm1">pair(u, v)</span> and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">pair(u, z)</span> if <span class="KeyTerm1">v</span> and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">z</span>.</li>
</ul>
<p><a id="c004_c4-para-2063"></a>To express this in our query language, we define two rules for a relation</p>
<p class="Sp-text-1"><a id="c004_c4-para-2064"></a>append_to_form(x, y, z)</p>
<p class="paracontinue"><a id="c004_c4-para-2065"></a>which we can interpret to mean “<span class="KeyTerm1">x</span> and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">z</span>”:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2066"></a>rule(append_to_form(<b>null</b>, $y, $y))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-2067"></a>rule(append_to_form(pair($u, $v), $y, pair($u, $z)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2068"></a>     append_to_form($v, $y, $z))</p>
<p class="paracontinue"><a id="c004_c4-para-2069"></a>The first rule has no body, which means that the conclusion holds for any value of <span class="KeyTerm1">$y</span>. Note how the second rule makes use of <span class="KeyTerm1">pair</span> to name the head and tail of a list.</p>
<p><a id="c004_c4-para-2070"></a>Given these two rules, we can formulate queries that compute the <span class="KeyTerm1">append</span> of two lists:</p>
<p class="Sp-text-3"><a id="c004_c4-para-2071"></a><i>Query input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2072"></a>append_to_form(list("a", "b"), list("c", "d"), $z)</p>
<p class="Sp-text-3"><a id="c004_c4-para-2073"></a><i>Query results:</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2074"></a><i>append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))</i></p>
<p class="paracontinue"><a id="c004_c4-para-2075"></a>What is more striking, we can use the same rules to ask the question “Which list, when <span class="KeyTerm1">append</span>ed to <span class="KeyTerm1">list("a", "b")</span>, yields <span class="KeyTerm1">list("a", "b", "c", "d")</span>? ” This is done as follows:</p>
<p class="Sp-text-3"><a id="c004_c4-para-2076"></a><i>Query input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2077"></a>append_to_form(list("a", "b"), $y, list("a", "b", "c", "d"))</p>
<p class="Sp-text-3"><a id="c004_c4-para-2078"></a><i>Query results:</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2079"></a><i>append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))</i></p>
<p class="paracontinue"><a id="c004_c4-para-2080"></a>We can ask for all pairs of lists that <span class="KeyTerm1">append</span> to form <span class="KeyTerm1">list("a", "b", "c", "d")</span>:</p>
<p class="Sp-text-3"><a id="c004_c4-para-2081"></a><i>Query input:</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2082"></a>append_to_form($x, $y, list("a", "b", "c", "d"))</p>
<p class="Sp-text-3"><a id="c004_c4-para-2083"></a><i>Query results:</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2084"></a><i>append_to_form(null, list("a", "b", "c", "d"), list("a", "b", "c", "d"))</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2085"></a><i>append_to_form(list("a"), list("b", "c", "d"), list("a", "b", "c", "d"))</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2086"></a><i>append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2087"></a><i>append_to_form(list("a", "b", "c"), list("d"), list("a", "b", "c", "d"))</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2088"></a><i>append_to_form(list("a", "b", "c", "d"), null, list("a", "b", "c", "d"))</i></p>
<p><a id="c004_c4-para-2089"></a>The query system may seem to exhibit quite a bit of intelligence in using the rules to deduce the answers to the queries above. Actually, as we will see in the next section, the system is following a well-determined algorithm in unraveling the rules. Unfortunately, although the system works impressively in the <span class="KeyTerm1">append</span> case, the general methods may break down in more complex cases, as we will see in section 4.4.3.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0125"></a><a id="c004_c4-title-0126"></a>Exercise 4.59</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2090"></a>The following rules implement a <span class="KeyTerm1">next_to_in</span> relation that finds adjacent elements of a list:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2091"></a>rule(next_to_in($x, $y, pair($x, pair($y, $u))))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-2092"></a>rule(next_to_in($x, $y, pair($v, $z)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2093"></a>     next_to_in($x, $y, $z))</p>
<p class="paracontinue"><a id="c004_c4-para-2094"></a>What will the response be to the following queries?</p>
<p class="Sp-text-1"><a id="c004_c4-para-2095"></a>next_to_in($x, $y, list(1, list(2, 3), 4))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2096"></a>next_to_in($x, 1, list(2, 1, 3, 1))</p>
</section>
<section>
<h5><a id="c004_c4-sec-0126"></a><a id="c004_c4-title-0127"></a>Exercise 4.60</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2097"></a>Define rules to implement the <span class="KeyTerm1">last_pair</span> operation of exercise 2.17, which returns a list containing the last element of a nonempty list. Check your rules on the following queries:</p>
<ul style="list-style-type:disc">
<li>last_pair(list(3), $x)</li>
<li>last_pair(list(1, 2, 3), $x)</li>
<li>last_pair(list(2, $x), list(3))</li>
</ul>
<p class="paracontinue"><a id="c004_c4-para-2101"></a>Do your rules work correctly on queries such as <span class="KeyTerm1">last_pair($x, list(3))</span>?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0127"></a><a id="c004_c4-title-0128"></a>Exercise 4.61</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2102"></a>The following data base (see Genesis 4) traces the genealogy of the descendants of Ada back to Adam, by way of Cain:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2103"></a>son("Adam", "Cain")</p>
<p class="Sp-text-1"><a id="c004_c4-para-2104"></a>son("Cain", "Enoch")</p>
<p class="Sp-text-1"><a id="c004_c4-para-2105"></a>son("Enoch", "Irad")</p>
<p class="Sp-text-1"><a id="c004_c4-para-2106"></a>son("Irad", "Mehujael") son("Mehujael", "Methushael") son("Methushael", "Lamech") wife("Lamech", "Ada")</p>
<p class="Sp-text-1"><a id="c004_c4-para-2107"></a>son("Ada", "Jabal")</p>
<p class="Sp-text-1"><a id="c004_c4-para-2108"></a>son("Ada", "Jubal")</p>
<p class="paracontinue"><a id="c004_c4-para-2109"></a>Formulate rules such as “If <i>S</i> is the son of <i>F</i>, and <i>F</i> is the son of <i>G</i>, then <i>S</i> is the grandson of <i>G</i>” and “If <i>W</i> is the wife of <i>M</i>, and <i>S</i> is the son of <i>W</i>, then <i>S</i> is the son of <i>M</i>” (which was supposedly more true in biblical times than today) that will enable the query system to find the grandson of Cain; the sons of Lamech; the grandsons of Methushael. (See exercise 4.67 for some rules to deduce more complicated relationships.)</p>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0128"></a><span>4.4.2</span> <a id="c004_c4-title-0129"></a>How the Query System Works</h3>
<p class="paraaftertitle"><a id="c004_c4-para-2110"></a>In section 4.4.4 we will present an implementation of the query interpreter as a collection of functions. In this section we give an overview that explains the general structure of the system independent of low-level implementation details. After describing the implementation of the interpreter, we will be in a position to understand some of its limitations and some of the subtle ways in which the query language's logical operations differ from the operations of mathematical logic.</p>
<p><a id="c004_c4-para-2111"></a>It should be apparent that the query evaluator must perform some kind of search in order to match queries against facts and rules in the data base. One way to do this would be to implement the query system as a nondeterministic program, using the <span class="KeyTerm1">amb</span> evaluator of section 4.3 (see exercise 4.75). Another possibility is to manage the search with the aid of streams. Our implementation follows this second approach.</p>
<p><a id="c004_c4-para-2112"></a>The query system is organized around two central operations, called <i>pattern matching</i> and <i>unification</i>. We first describe pattern matching and explain how this operation, together with the organization of information in terms of streams of frames, enables us to implement both simple and compound queries. We next discuss unification, a generalization of pattern matching needed to implement rules. Finally, we show how the entire query interpreter fits together through a function that classifies queries in a manner analogous to the way <span class="KeyTerm1">evaluate</span> classifies expressions for the interpreter described in section 4.1.</p>
<section>
<h5><a id="c004_c4-sec-0129"></a><a id="c004_c4-title-0130"></a>Pattern matching</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2113"></a>A <i>pattern matcher</i> is a program that tests whether some datum fits a specified pattern. For example, the datum <span class="KeyTerm1">list(list("a", "b"), "c", list("a", "b"))</span> matches the pattern <span class="KeyTerm1">list($x, "c", $x)</span> with the pattern variable <span class="KeyTerm1">$x</span> bound to <span class="KeyTerm1">list("a", "b")</span>. The same data list matches the pattern <span class="KeyTerm1">list($x, $y, $z)</span> with <span class="KeyTerm1">$x</span> and <span class="KeyTerm1">$z</span> both bound to <span class="KeyTerm1">list("a", "b")</span> and <span class="KeyTerm1">$y</span> bound to <span class="KeyTerm1">"c"</span>. It also matches the pattern <span class="KeyTerm1">list(list($x, $y), "c", list($x, $y))</span> with <span class="KeyTerm1">$x</span> bound to <span class="KeyTerm1">"a"</span> and <span class="KeyTerm1">$y</span> bound to <span class="KeyTerm1">"b"</span>. However, it does not match the pattern <span class="KeyTerm1">list($x, "a", $y)</span>, since that pattern specifies a list whose second element is the string <span class="KeyTerm1">"a"</span>.</p>
<p><a id="c004_c4-para-2114"></a>The pattern matcher used by the query system takes as inputs a pattern, a datum, and a <i>frame</i> that specifies bindings for various pattern variables. It checks whether the datum matches the pattern in a way that is consistent with the bindings already in the frame. If so, it returns the given frame augmented by any bindings that may have been determined by the match. Otherwise, it indicates that the match has failed.</p>
<p><a id="c004_c4-para-2115"></a>Using the pattern <span class="KeyTerm1">list($x, $y, $x)</span> to match <span class="KeyTerm1">list("a", "b", "a")</span> given an empty frame, for example, will return a frame specifying that <span class="KeyTerm1">$x</span> is bound to <span class="KeyTerm1">"a"</span> and <span class="KeyTerm1">$y</span> is bound to <span class="KeyTerm1">"b"</span>. Trying the match with the same pattern, the same datum, and a frame specifying that <span class="KeyTerm1">$y</span> is bound to <span class="KeyTerm1">"a"</span> will fail. Trying the match with the same pattern, the same datum, and a frame in which <span class="KeyTerm1">$y</span> is bound to <span class="KeyTerm1">"b"</span> and <span class="KeyTerm1">$x</span> is unbound will return the given frame augmented by a binding of <span class="KeyTerm1">$x</span> to <span class="KeyTerm1">"a"</span>.</p>
<p><a id="c004_c4-para-2116"></a>The pattern matcher is all the mechanism that is needed to process simple queries that don't involve rules. For instance, to process the query</p>
<p class="Sp-text-1"><a id="c004_c4-para-2117"></a>job($x, list("computer", "programmer"))</p>
<p class="paracontinue"><a id="c004_c4-para-2118"></a>we scan through all assertions in the data base and select those that match the pattern with respect to an initially empty frame. For each match we find, we use the frame returned by the match to instantiate the pattern with a value for <span class="KeyTerm1">$x</span>.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0130"></a><a id="c004_c4-title-0131"></a>Streams of frames</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2119"></a>The testing of patterns against frames is organized through the use of streams. Given a single frame, the matching process runs through the data-base entries one by one. For each data-base entry, the matcher generates either a special symbol indicating that the match has failed or an extension to the frame. The results for all the database entries are collected into a stream, which is passed through a filter to weed out the failures. The result is a stream of all the frames that extend the given frame via a match to some assertion in the data base.<a id="c004_c4-fn-0061a"></a><a href="#c4-fn-0061"><sup>61</sup></a></p>
<p><a id="c004_c4-para-2120"></a>In our system, a query takes an input stream of frames and performs the above matching operation for every frame in the stream, as indicated in <a id="c004_c4-fig-0005a"></a><a href="#c4-fig-0005">figure 4.5</a>. That is, for each frame in the input stream, the query generates a new stream consisting of all extensions to that frame by matches to assertions in the data base. All these streams are then combined to form one huge stream, which contains all possible extensions of every frame in the input stream. This stream is the output of the query.</p>
<figure id="c004_c4-fig-0005"><img alt="c4-fig-0005.jpg" src="../images/c4-fig-0005.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0005a">Figure 4.5</a></span> <a id="c004_c4-para-2121"></a>A query processes a stream of frames.</p></figcaption></figure>
<p><a id="c004_c4-para-2122"></a>To answer a simple query, we use the query with an input stream consisting of a single empty frame. The resulting output stream contains all extensions to the empty frame (that is, all answers to our query). This stream of frames is then used to generate a stream of copies of the original query pattern with the variables instantiated by the values in each frame, and this is the stream that is finally printed.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0131"></a><a id="c004_c4-title-0132"></a>Compound queries</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2123"></a>The real elegance of the stream-of-frames implementation is evident when we deal with compound queries. The processing of compound queries makes use of the ability of our matcher to demand that a match be consistent with a specified frame. For example, to handle the <span class="KeyTerm1">and</span> of two queries, such as</p>
<p class="Sp-text-1"><a id="c004_c4-para-2124"></a>and(can_do_job($x, list("computer", "programmer", "trainee")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2125"></a>    job($person, $x))</p>
<p class="paracontinue"><a id="c004_c4-para-2126"></a>(informally, “Find all people who can do the job of a computer programmer trainee”), we first find all entries that match the pattern</p>
<p class="Sp-text-1"><a id="c004_c4-para-2127"></a>can_do_job($x, list("computer", "programmer", "trainee"))</p>
<p class="paracontinue"><a id="c004_c4-para-2128"></a>This produces a stream of frames, each of which contains a binding for <span class="KeyTerm1">$x</span>. Then for each frame in the stream we find all entries that match</p>
<p class="Sp-text-1"><a id="c004_c4-para-2129"></a>job($person, $x)</p>
<p class="paracontinue"><a id="c004_c4-para-2130"></a>in a way that is consistent with the given binding for <span class="KeyTerm1">$x</span>. Each such match will produce a frame containing bindings for <span class="KeyTerm1">$x</span> and <span class="KeyTerm1">$person</span>. The <span class="KeyTerm1">and</span> of two queries can be viewed as a series combination of the two component queries, as shown in <a id="c004_c4-fig-0006a"></a><a href="#c4-fig-0006">figure 4.6</a>. The frames that pass through the first query filter are filtered and further extended by the second query.</p>
<figure id="c004_c4-fig-0006"><img alt="c4-fig-0006.jpg" src="../images/c4-fig-0006.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0006a">Figure 4.6</a></span> <a id="c004_c4-para-2131"></a>The <span class="KeyTerm1">and</span> combination of two queries is produced by operating on the stream of frames in series.</p></figcaption></figure>
<p><a id="c004_c4-para-2132"></a><a id="c004_c4-fig-0007a"></a><a href="#c4-fig-0007">Figure 4.7</a> shows the analogous method for computing the <span class="KeyTerm1">or</span> of two queries as a parallel combination of the two component queries. The input stream of frames is extended separately by each query. The two resulting streams are then merged to produce the final output stream.</p>
<figure id="c004_c4-fig-0007"><img alt="c4-fig-0007.jpg" src="../images/c4-fig-0007.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0007a">Figure 4.7</a></span> <a id="c004_c4-para-2133"></a>The <span class="KeyTerm1">or</span> combination of two queries is produced by operating on the stream of frames in parallel and merging the results.</p></figcaption></figure>
<p><a id="c004_c4-para-2134"></a>Even from this high-level description, it is apparent that the processing of compound queries can be slow. For example, since a query may produce more than one output frame for each input frame, and each query in an <span class="KeyTerm1">and</span> gets its input frames from the previous query, an <span class="KeyTerm1">and</span> query could, in the worst case, have to perform a number of matches that is exponential in the number of queries (see exercise 4.73).<a id="c004_c4-fn-0062a"></a><a href="#c4-fn-0062"><sup>62</sup></a> Though systems for handling only simple queries are quite practical, dealing with complex queries is extremely difficult.<a id="c004_c4-fn-0063a"></a><a href="#c4-fn-0063"><sup>63</sup></a></p>
<p><a id="c004_c4-para-2135"></a>From the stream-of-frames viewpoint, the <span class="KeyTerm1">not</span> of some query acts as a filter that removes all frames for which the query can be satisfied. For instance, given the pattern</p>
<p class="Sp-text-1"><a id="c004_c4-para-2136"></a>not(job($x, list("computer", "programmer")))</p>
<p class="paracontinue"><a id="c004_c4-para-2137"></a>we attempt, for each frame in the input stream, to produce extension frames that satisfy <span class="KeyTerm1">job($x, list("computer", "programmer"))</span>. We remove from the input stream all frames for which such extensions exist. The result is a stream consisting of only those frames in which the binding for <span class="KeyTerm1">$x</span> does not satisfy <span class="KeyTerm1">job($x, list("computer", "programmer"))</span>. For example, in processing the query</p>
<p class="Sp-text-1"><a id="c004_c4-para-2138"></a>and(supervisor($x, $y),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2139"></a>    not(job($x, list("computer", "programmer"))))</p>
<p class="paracontinue"><a id="c004_c4-para-2140"></a>the first clause will generate frames with bindings for <span class="KeyTerm1">$x</span> and <span class="KeyTerm1">$y</span>. The <span class="KeyTerm1">not</span> clause will then filter these by removing all frames in which the binding for <span class="KeyTerm1">$x</span> satisfies the restriction that <span class="KeyTerm1">$x</span> is a computer programmer.<a id="c004_c4-fn-0064a"></a><a href="#c4-fn-0064"><sup>64</sup></a></p>
<p><a id="c004_c4-para-2141"></a>The <span class="KeyTerm1">javascript_predicate</span> syntactic form is implemented as a similar filter on frame streams. We use each frame in the stream to instantiate any variables in the pattern, then apply the JavaScript predicate. We remove from the input stream all frames for which the predicate fails.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0132"></a><a id="c004_c4-title-0133"></a>Unification</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2142"></a>In order to handle rules in the query language, we must be able to find the rules whose conclusions match a given query pattern. Rule conclusions are like assertions except that they can contain variables, so we will need a generalization of pattern matching—called <i>unification</i>—in which both the “pattern” and the “datum” may contain variables.</p>
<p><a id="c004_c4-para-2143"></a>A unifier takes two patterns, each containing constants and variables, and determines whether it is possible to assign values to the variables that will make the two patterns equal. If so, it returns a frame containing these bindings. For example, unifying <span class="KeyTerm1">list($x, "a", $y)</span> and <span class="KeyTerm1">list($y, $z, "a")</span> will specify a frame in which <span class="KeyTerm1">$x</span>, <span class="KeyTerm1">$y</span>, and <span class="KeyTerm1">$z</span> must all be bound to <span class="KeyTerm1">"a"</span>. On the other hand, unifying <span class="KeyTerm1">list($x, $y, "a")</span> and <span class="KeyTerm1">list($x, "b", $y)</span> will fail, because there is no value for <span class="KeyTerm1">$y</span> that can make the two patterns equal. (For the second elements of the patterns to be equal, <span class="KeyTerm1">$y</span> would have to be <span class="KeyTerm1">"b"</span>; however, for the third elements to be equal, <span class="KeyTerm1">$y</span> would have to be <span class="KeyTerm1">"a"</span>.) The unifier used in the query system, like the pattern matcher, takes a frame as input and performs unifications that are consistent with this frame.</p>
<p><a id="c004_c4-para-2144"></a>The unification algorithm is the most technically difficult part of the query system. With complex patterns, performing unification may seem to require deduction. To unify</p>
<p class="Sp-text-1"><a id="c004_c4-para-2145"></a>list($x, $x) </p>
<p class="paracontinue"><a id="c004_c4-para-2146"></a>and</p>
<p class="Sp-text-1"><a id="c004_c4-para-2147"></a>list(list("a", $y, "c"), list("a", "b", $z))</p>
<p class="paracontinue"><a id="c004_c4-para-2148"></a>for example, the algorithm must infer that <span class="KeyTerm1">$x</span> should be <span class="KeyTerm1">list("a", "b", "c")</span>, <span class="KeyTerm1">$y</span> should be <span class="KeyTerm1">"b"</span>, and <span class="KeyTerm1">$z</span> should be <span class="KeyTerm1">"c"</span>. We may think of this process as solving a set of equations among the pattern components. In general, these are simultaneous equations, which may require substantial manipulation to solve.<a id="c004_c4-fn-0065a"></a><a href="#c4-fn-0065"><sup>65</sup></a> For example, unifying <span class="KeyTerm1">list($x, $x)</span> and <span class="KeyTerm1">list(list("a", $y, "c"), list("a", "b", $z))</span> may be thought of as specifying the simultaneous equations</p>
<p class="Sp-text-2"><a id="c004_c4-para-2149"></a><span class="KeyTerm1">$x = list("a", $y, "c")</span></p>
<p class="Sp-text-2"><a id="c004_c4-para-2150"></a><span class="KeyTerm1">$x = list("a", "b", $z)</span></p>
<p class="paracontinue"><a id="c004_c4-para-2151"></a>These equations imply that</p>
<p class="Sp-text-2"><a id="c004_c4-para-2152"></a><span class="KeyTerm1">list("a", $y, "c") = list("a", "b", $z)</span></p>
<p class="paracontinue"><a id="c004_c4-para-2153"></a>which in turn implies that</p>
<p class="Sp-text-2"><a id="c004_c4-para-2154"></a><span class="KeyTerm1">"a" = "a"</span>, <span class="KeyTerm1">$y = "b"</span>, <span class="KeyTerm1">"c" = $z</span></p>
<p class="paracontinue"><a id="c004_c4-para-2155"></a>and hence that</p>
<p class="Sp-text-2"><a id="c004_c4-para-2156"></a><span class="KeyTerm2">$x = list("a", "b", "c")</span></p>
<p><a id="c004_c4-para-2157"></a>In a successful pattern match, all pattern variables become bound, and the values to which they are bound contain only constants. This is also true of all the examples of unification we have seen so far. In general, however, a successful unification may not completely determine the variable values; some variables may remain unbound and others may be bound to values that contain variables.</p>
<p><a id="c004_c4-para-2158"></a>Consider the unification of <span class="KeyTerm1">list($x, "a")</span> and <span class="KeyTerm1">list(list("b", $y), $z)</span>. We can deduce that <span class="KeyTerm1">$x</span> = <span class="KeyTerm1">list("b", $y)</span> and <span class="KeyTerm1">"a"</span> = <span class="KeyTerm1">$z</span>, but we cannot further solve for <span class="KeyTerm1">$x</span> or <span class="KeyTerm1">$y</span>. The unification doesn't fail, since it is certainly possible to make the two patterns equal by assigning values to <span class="KeyTerm1">$x</span> and <span class="KeyTerm1">$y</span>. Since this match in no way restricts the values <span class="KeyTerm1">$y</span> can take on, no binding for <span class="KeyTerm1">$y</span> is put into the result frame. The match does, however, restrict the value of <span class="KeyTerm1">$x</span>. Whatever value <span class="KeyTerm1">$y</span> has, <span class="KeyTerm1">$x</span> must be <span class="KeyTerm1">list("b", $y)</span>. A binding of <span class="KeyTerm1">$x</span> to the pattern <span class="KeyTerm1">list("b", $y)</span> is thus put into the frame. If a value for <span class="KeyTerm1">$y</span> is later determined and added to the frame (by a pattern match or unification that is required to be consistent with this frame), the previously bound <span class="KeyTerm1">$x</span> will refer to this value.<a id="c004_c4-fn-0066a"></a><a href="#c4-fn-0066"><sup>66</sup></a></p>
</section>
<section>
<h5><a id="c004_c4-sec-0133"></a><a id="c004_c4-title-0134"></a>Applying rules</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2159"></a>Unification is the key to the component of the query system that makes inferences from rules. To see how this is accomplished, consider processing a query that involves applying a rule, such as</p>
<p class="Sp-text-1"><a id="c004_c4-para-2160"></a>lives_near($x, list("Hacker", "Alyssa", "P"))</p>
<p class="paracontinue"><a id="c004_c4-para-2161"></a>To process this query, we first use the ordinary pattern-match function described above to see if there are any assertions in the data base that match this pattern. (There will not be any in this case, since our data base includes no direct assertions about who lives near whom.) The next step is to attempt to unify the query pattern with the conclusion of each rule. We find that the pattern unifies with the conclusion of the rule</p>
<p class="Sp-text-1"><a id="c004_c4-para-2162"></a>rule(lives_near($person_1, $person_2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2163"></a>     and(address($person_1, pair($town, $rest_1)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2164"></a>         address($person_2, list($town, $rest_2)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2165"></a>         not(same($person_1, $person_2))))</p>
<p class="paracontinue"><a id="c004_c4-para-2166"></a>resulting in a frame specifying that <span class="KeyTerm1">$x</span> should be bound to (have the same value as) <span class="KeyTerm1">$person_1</span> and that <span class="KeyTerm1">$person_2</span> is bound to <span class="KeyTerm1">list("Hacker", "Alyssa", "P")</span>. Now, relative to this frame, we evaluate the compound query given by the body of the rule. Successful matches will extend this frame by providing a binding for <span class="KeyTerm1">$person_1</span>, and consequently a value for <span class="KeyTerm1">$x</span>, which we can use to instantiate the original query pattern.</p>
<p><a id="c004_c4-para-2167"></a>In general, the query evaluator uses the following method to apply a rule when trying to establish a query pattern in a frame that specifies bindings for some of the pattern variables:</p>
<ul style="list-style-type:disc">
<li>Unify the query with the conclusion of the rule to form, if successful, an extension of the original frame.</li>
<li>Relative to the extended frame, evaluate the query formed by the body of the rule.</li>
</ul>
<p><a id="c004_c4-para-2170"></a>Notice how similar this is to the method for applying a function in the <span class="KeyTerm1">evaluate</span>/ <span class="KeyTerm1">apply</span> evaluator for JavaScript:</p>
<ul style="list-style-type:disc">
<li>Bind the function's parameters to its arguments to form a frame that extends the original function environment.</li>
<li>Relative to the extended environment, evaluate the expression formed by the body of the function.</li>
</ul>
<p class="paracontinue"><a id="c004_c4-para-2173"></a>The similarity between the two evaluators should come as no surprise. Just as function definitions are the means of abstraction in JavaScript, rule definitions are the means of abstraction in the query language. In each case, we unwind the abstraction by creating appropriate bindings and evaluating the rule or function body relative to these.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0134"></a><a id="c004_c4-title-0135"></a>Simple queries</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2174"></a>We saw earlier in this section how to evaluate simple queries in the absence of rules. Now that we have seen how to apply rules, we can describe how to evaluate simple queries by using both rules and assertions.</p>
<p><a id="c004_c4-para-2175"></a>Given the query pattern and a stream of frames, we produce, for each frame in the input stream, two streams:</p>
<ul style="list-style-type:disc">
<li>a stream of extended frames obtained by matching the pattern against all assertions in the data base (using the pattern matcher), and</li>
<li>a stream of extended frames obtained by applying all possible rules (using the unifier).<a id="c004_c4-fn-0067a"></a><a href="#c4-fn-0067"><sup>67</sup></a></li>
</ul>
<p class="paracontinue"><a id="c004_c4-para-2178"></a>Appending these two streams produces a stream that consists of all the ways that the given pattern can be satisfied consistent with the original frame. These streams (one for each frame in the input stream) are now all combined to form one large stream, which therefore consists of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0135"></a><a id="c004_c4-title-0136"></a>The query evaluator and the driver loop</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2179"></a>Despite the complexity of the underlying matching operations, the system is organized much like an evaluator for any language. The function that coordinates the matching operations is called <span class="KeyTerm1">evaluate_query</span>, and it plays a role analogous to that of the <span class="KeyTerm1">evaluate</span> function for JavaScript. The function <span class="KeyTerm1">evaluate_query</span> takes as inputs a query and a stream of frames. Its output is a stream of frames, corresponding to successful matches to the query pattern, that extend some frame in the input stream, as indicated in <a href="#c4-fig-0005">figure 4.5</a>. Like <span class="KeyTerm1">evaluate</span>, <span class="KeyTerm1">evaluate_query</span> classifies the different types of expressions (queries) and dispatches to an appropriate function for each. There is a function for each syntactic form (<span class="KeyTerm1">and</span>, <span class="KeyTerm1">or</span>, <span class="KeyTerm1">not</span>, and <span class="KeyTerm1">javascript_predicate</span>) and one for simple queries.</p>
<p><a id="c004_c4-para-2180"></a>The driver loop, which is analogous to the <span class="KeyTerm1">driver_loop</span> function for the other evaluators in this chapter, reads queries typed by the user. For each query, it calls <span class="KeyTerm1">evaluate_query</span> with the query and a stream that consists of a single empty frame. This will produce the stream of all possible matches (all possible extensions to the empty frame). For each frame in the resulting stream, it instantiates the original query using the values of the variables found in the frame. This stream of instantiated queries is then printed.<a id="c004_c4-fn-0068a"></a><a href="#c4-fn-0068"><sup>68</sup></a></p>
<p><a id="c004_c4-para-2181"></a>The driver also checks for the special command <span class="KeyTerm1">assert</span>, which signals that the input is not a query but rather an assertion or rule to be added to the data base. For instance,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2182"></a>assert(job(list("Bitdiddle", "Ben"), list("computer", "wizard")))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-2183"></a>assert(rule(wheel($person),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2184"></a>            and(supervisor($middle_manager, $person),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2185"></a>                supervisor($x, $middle_manager))))</p>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0136"></a><span>4.4.3</span> <a id="c004_c4-title-0137"></a>Is Logic Programming Mathematical Logic?</h3>
<p class="paraaftertitle"><a id="c004_c4-para-2186"></a>The means of combination used in the query language may at first seem identical to the operations <span class="KeyTerm1">and</span>, <span class="KeyTerm1">or</span>, and <span class="KeyTerm1">not</span> of mathematical logic, and the application of querylanguage rules is in fact accomplished through a legitimate method of inference.<a id="c004_c4-fn-0069a"></a><a href="#c4-fn-0069"><sup>69</sup></a> This identification of the query language with mathematical logic is not really valid, though, because the query language provides a <i>control structure</i> that interprets the logical statements procedurally. We can often take advantage of this control structure. For example, to find all of the supervisors of programmers we could formulate a query in either of two logically equivalent forms:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2187"></a>and(job($x, list("computer", "programmer")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2188"></a>    supervisor($x, $y))</p>
<p class="paracontinue"><a id="c004_c4-para-2189"></a>or</p>
<p class="Sp-text-1"><a id="c004_c4-para-2190"></a>and(supervisor($x, $y),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2191"></a>    job($x, list("computer", "programmer")))</p>
<p class="paracontinue"><a id="c004_c4-para-2192"></a>If a company has many more supervisors than programmers, it is better to use the first form rather than the second, because the data base must be scanned for each intermediate result (frame) produced by the first clause of the <span class="KeyTerm1">and</span>.</p>
<p><a id="c004_c4-para-2193"></a>The aim of logic programming is to provide the programmer with techniques for decomposing a computational problem into two separate problems: “what” is to be computed, and “how” this should be computed. This is accomplished by selecting a subset of the statements of mathematical logic that is powerful enough to be able to describe anything one might want to compute, yet weak enough to have a controllable procedural interpretation. The intention here is that, on the one hand, a program specified in a logic programming language should be an effective program that can be carried out by a computer. Control (“how” to compute) is effected by using the order of evaluation of the language. We should be able to arrange the order of clauses and the order of subgoals within each clause so that the computation is done in an order deemed to be effective and efficient. At the same time, we should be able to view the result of the computation (“what” to compute) as a simple consequence of the laws of logic.</p>
<p><a id="c004_c4-para-2194"></a>Our query language can be regarded as just such a procedurally interpretable subset of mathematical logic. An assertion represents a simple fact (an atomic proposition). A rule represents the implication that the rule conclusion holds for those cases where the rule body holds. A rule has a natural procedural interpretation: To establish the conclusion of the rule, establish the body of the rule. Rules, therefore, specify computations. However, because rules can also be regarded as statements of mathematical logic, we can justify any “inference” accomplished by a logic program by asserting that the same result could be obtained by working entirely within mathematical logic.<a id="c004_c4-fn-0070a"></a><a href="#c4-fn-0070"><sup>70</sup></a></p>
<section>
<h5><a id="c004_c4-sec-0137"></a><a id="c004_c4-title-0138"></a>Infinite loops</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2195"></a>A consequence of the procedural interpretation of logic programs is that it is possible to construct hopelessly inefficient programs for solving certain problems. An extreme case of inefficiency occurs when the system falls into infinite loops in making deductions. As a simple example, suppose we are setting up a data base of famous marriages, including</p>
<p class="Sp-text-1"><a id="c004_c4-para-2196"></a>assert(married("Minnie", "Mickey"))</p>
<p class="paracontinue"><a id="c004_c4-para-2197"></a>If we now ask</p>
<p class="Sp-text-1"><a id="c004_c4-para-2198"></a>married("Mickey", $who)</p>
<p class="paracontinue"><a id="c004_c4-para-2199"></a>we will get no response, because the system doesn't know that if <i>A</i> is married to <i>B</i>, then <i>B</i> is married to <i>A</i>. So we assert the rule</p>
<p class="Sp-text-1"><a id="c004_c4-para-2200"></a>assert(rule(married($x, $y),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2201"></a>            married($y, $x)))</p>
<p class="paracontinue"><a id="c004_c4-para-2202"></a>and again query</p>
<p class="Sp-text-1"><a id="c004_c4-para-2203"></a>married("Mickey", $who)</p>
<p class="paracontinue"><a id="c004_c4-para-2204"></a>Unfortunately, this will drive the system into an infinite loop, as follows:</p>
<ul style="list-style-type:disc">
<li>The system finds that the <span class="KeyTerm1">married</span> rule is applicable; that is, the rule conclusion <span class="KeyTerm1">married($x, $y)</span> unifies with the query pattern <span class="KeyTerm1">married("Mickey", $who)</span> to produce a frame in which <span class="KeyTerm1">$x</span> is bound to <span class="KeyTerm1">"Mickey"</span> and <span class="KeyTerm1">$y</span> is bound to <span class="KeyTerm1">$who</span>. So the interpreter proceeds to evaluate the rule body <span class="KeyTerm1">married($y, $x)</span> in this frame—in effect, to process the query <span class="KeyTerm1">married($who, "Mickey")</span>.</li>
<li>One answer, <span class="KeyTerm1">married("Minnie", "Mickey")</span>, appears directly as an assertion in the data base.</li>
<li>The <span class="KeyTerm1">married</span> rule is also applicable, so the interpreter again evaluates the rule body, which this time is equivalent to <span class="KeyTerm1">married("Mickey", $who)</span>.</li>
</ul>
<p class="paracontinue"><a id="c004_c4-para-2208"></a>The system is now in an infinite loop. Indeed, whether the system will find the simple answer <span class="KeyTerm1">married("Minnie", "Mickey")</span> before it goes into the loop depends on implementation details concerning the order in which the system checks the items in the data base. This is a very simple example of the kinds of loops that can occur. Collections of interrelated rules can lead to loops that are much harder to anticipate, and the appearance of a loop can depend on the order of clauses in an <span class="KeyTerm1">and</span> (see exercise 4.62) or on low-level details concerning the order in which the system processes queries.<a id="c004_c4-fn-0071a"></a><a href="#c4-fn-0071"><sup>71</sup></a></p>
</section>
<section>
<h5><a id="c004_c4-sec-0138"></a><a id="c004_c4-title-0139"></a>Problems with <span class="KeyTerm1"><b>not</b></span></h5>
<p class="paraaftertitle"><a id="c004_c4-para-2209"></a>Another quirk in the query system concerns <span class="KeyTerm1">not</span>. Given the data base of section 4.4.1, consider the following two queries:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2210"></a>and(supervisor($x, $y),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2211"></a>    not(job($x, list("computer", "programmer"))))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-2212"></a>and(not(job($x, list("computer", "programmer"))),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2213"></a>    supervisor($x, $y))</p>
<p class="paracontinue"><a id="c004_c4-para-2214"></a>These two queries do not produce the same result. The first query begins by finding all entries in the data base that match <span class="KeyTerm1">supervisor($x, $y)</span>, and then filters the resulting frames by removing the ones in which the value of <span class="KeyTerm1">$x</span> satisfies <span class="KeyTerm1">job($x, list("computer", "programmer"))</span>. The second query begins by filtering the incoming frames to remove those that can satisfy <span class="KeyTerm1">job($x, list("computer", "programmer"))</span>. Since the only incoming frame is empty, it checks the data base for patterns that satisfy <span class="KeyTerm1">job($x, list("computer", "programmer"))</span>. Since there generally are entries of this form, the <span class="KeyTerm1">not</span> clause filters out the empty frame and returns an empty stream of frames. Consequently, the entire compound query returns an empty stream.</p>
<p><a id="c004_c4-para-2215"></a>The trouble is that our implementation of <span class="KeyTerm1">not</span> really is meant to serve as a filter on values for the variables. If a <span class="KeyTerm1">not</span> clause is processed with a frame in which some of the variables remain unbound (as does <span class="KeyTerm1">$x</span> in the example above), the system will produce unexpected results. Similar problems occur with the use of <span class="KeyTerm1">javascript_predicate</span>—the JavaScript predicate can't work if some of its variables are unbound. See exercise 4.74.</p>
<p><a id="c004_c4-para-2216"></a>There is also a much more serious way in which the <span class="KeyTerm1">not</span> of the query language differs from the <span class="KeyTerm1">not</span> of mathematical logic. In logic, we interpret the statement “not <i>P</i>” to mean that <i>P</i> is not true. In the query system, however, “not <i>P</i>” means that <i>P</i> is not deducible from the knowledge in the data base. For example, given the personnel data base of section 4.4.1, the system would happily deduce all sorts of <span class="KeyTerm1">not</span> statements, such as that Ben Bitdiddle is not a baseball fan, that it is not raining outside, and that 2 + 2 is not 4.<a id="c004_c4-fn-0072a"></a><a href="#c4-fn-0072"><sup>72</sup></a> In other words, the <span class="KeyTerm1">not</span> of logic programming languages reflects the so-called <i>closed world assumption</i> that all relevant information has been included in the data base.<a id="c004_c4-fn-0073a"></a><a href="#c4-fn-0073"><sup>73</sup></a></p>
</section>
<section>
<h5><a id="c004_c4-sec-0139"></a><a id="c004_c4-title-0140"></a>Exercise 4.62</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2217"></a>Louis Reasoner mistakenly deletes the <span class="KeyTerm1">outranked_by</span> rule (section 4.4.1) from the data base. When he realizes this, he quickly reinstalls it. Unfortunately, he makes a slight change in the rule, and types it in as</p>
<p class="Sp-text-1"><a id="c004_c4-para-2218"></a>rule(outranked_by($staff_person, $boss),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2219"></a>     or(supervisor($staff_person, $boss),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2220"></a>        and(outranked_by($middle_manager, $boss),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2221"></a>            supervisor($staff_person, $middle_manager))))</p>
<p class="paracontinue"><a id="c004_c4-para-2222"></a>Just after Louis types this information into the system, DeWitt Aull comes by to find out who outranks Ben Bitdiddle. He issues the query</p>
<p class="Sp-text-1"><a id="c004_c4-para-2223"></a>outanked_by(list("Bitdiddle", "Ben"), $who)</p>
<p class="paracontinue"><a id="c004_c4-para-2224"></a>After answering, the system goes into an infinite loop. Explain why.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0140"></a><a id="c004_c4-title-0141"></a>Exercise 4.63</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2225"></a>Cy D. Fect, looking forward to the day when he will rise in the organization, gives a query to find all the wheels (using the <span class="KeyTerm1">wheel</span> rule of section 4.4.1):</p>
<p class="Sp-text-1"><a id="c004_c4-para-2226"></a>wheel($who)</p>
<p class="paracontinue"><a id="c004_c4-para-2227"></a>To his surprise, the system responds</p>
<p class="Sp-text-3"><a id="c004_c4-para-2228"></a><i>Query results:</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2229"></a><i>wheel(list("Warbucks", "Oliver"))</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2230"></a><i>wheel(list("Bitdiddle", "Ben"))</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2231"></a><i>wheel(list("Warbucks", "Oliver"))</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2232"></a><i>wheel(list("Warbucks", "Oliver"))</i></p>
<p class="Sp-text-3"><a id="c004_c4-para-2233"></a><i>wheel(list("Warbucks", "Oliver"))</i></p>
<p class="paracontinue"><a id="c004_c4-para-2234"></a>Why is Oliver Warbucks listed four times?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0141"></a><a id="c004_c4-title-0142"></a>Exercise 4.64</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2235"></a>Ben has been generalizing the query system to provide statistics about the company. For example, to find the total salaries of all the computer programmers one will be able to say</p>
<p class="Sp-text-1"><a id="c004_c4-para-2236"></a>sum($amount,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2237"></a>    and(job($x, list("computer", "programmer")),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2238"></a>        salary($x, $amount)))</p>
<p class="paracontinue"><a id="c004_c4-para-2239"></a>In general, Ben's new system allows expressions of the form</p>
<p class="Sp-text-1"><a id="c004_c4-para-2240"></a>accumulation_function(<span class="KeyTerm2"><i>variable</i></span>,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2241"></a> <span class="KeyTerm2"><i>query</i>-<i>pattern</i></span>)</p>
<p class="paracontinue"><a id="c004_c4-para-2242"></a>where <span class="KeyTerm1">accumulation_function</span> can be things like <span class="KeyTerm1">sum</span>, <span class="KeyTerm1">average</span>, or <span class="KeyTerm1">maximum</span>. Ben reasons that it should be a cinch to implement this. He will simply feed the query pattern to <span class="KeyTerm1">evaluate_query</span>. This will produce a stream of frames. He will then pass this stream through a mapping function that extracts the value of the designated variable from each frame in the stream and feed the resulting stream of values to the accumulation function. Just as Ben completes the implementation and is about to try it out, Cy walks by, still puzzling over the <span class="KeyTerm1">wheel</span> query result in exercise 4.63. When Cy shows Ben the system's response, Ben groans, “Oh, no, my simple accumulation scheme won't work!”</p>
<p><a id="c004_c4-para-2243"></a>What has Ben just realized? Outline a method he can use to salvage the situation.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0142"></a><a id="c004_c4-title-0143"></a>Exercise 4.65</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2244"></a>Devise a way to install a loop detector in the query system so as to avoid the kinds of simple loops illustrated in the text and in exercise 4.62. The general idea is that the system should maintain some sort of history of its current chain of deductions and should not begin processing a query that it is already working on. Describe what kind of information (patterns and frames) is included in this history, and how the check should be made. (After you study the details of the query-system implementation in section 4.4.4, you may want to modify the system to include your loop detector.)</p>
</section>
<section>
<h5><a id="c004_c4-sec-0143"></a><a id="c004_c4-title-0144"></a>Exercise 4.66</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2245"></a>Define rules to implement the <span class="KeyTerm1">reverse</span> operation of exercise 2.18, which returns a list containing the same elements as a given list in reverse order. (Hint: Use <span class="KeyTerm1">append_to_form</span>.) Can your rules answer both the query <span class="KeyTerm1">reverse(list(1, 2, 3), $x)</span> and the query <span class="KeyTerm1">reverse($x, list(1, 2, 3))</span>?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0144"></a><a id="c004_c4-title-0145"></a>Exercise 4.67</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2246"></a>Let us modify the data base and the rules of exercise 4.61 to add “great” to a grandson relationship. This should enable the system to deduce that Irad is the great-grandson of Adam, or that Jabal and Jubal are the great-great-great-great-great-grandsons of Adam.</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0099"></a><span>a. </span>Change the assertions in the data base such that there is only one kind of relationship information, namely <span class="KeyTerm1">related</span>. The first item then describes the relationship. Thus, instead of <span class="KeyTerm1">son("Adam", "Cain")</span>, you would write <span class="KeyTerm1">related("son", "Adam", "Cain")</span>. Represent the fact about Irad, for example, as
<p class="paracontinue"><a id="c004_c4-para-2248"></a>related(list("great", "grandson"), "Adam", "Irad")</p></li>
<li><a id="c004_c4-li-0100"></a><span>b. </span>Write rules that determine if a list ends in the word <span class="KeyTerm1">"grandson"</span>.</li>
<li><a id="c004_c4-li-0101"></a><span>c. </span>Use this to express a rule that allows one to derive the relationship
<p class="paracontinue"><a id="c004_c4-para-2251"></a>list(pair("great", $rel), $x, $y)</p>
<p class="paracontinue"><a id="c004_c4-para-2252"></a>where <span class="KeyTerm1">$rel</span> is a list ending in <span class="KeyTerm1">"grandson"</span>.</p></li>
<li><a id="c004_c4-li-0102"></a><span>d. </span>Check your rules on the queries <span class="KeyTerm1">related(list("great", "grandson"), $g, $ggs)</span> and <span class="KeyTerm1">related($relationship, "Adam", "Irad")</span>.</li>
</ol>
</section>
</section>
<section>
<h3><a id="c004_c4-sec-0145"></a><span>4.4.4</span> <a id="c004_c4-title-0146"></a>Implementing the Query System</h3>
<p class="paraaftertitle"><a id="c004_c4-para-2254"></a>Section 4.4.2 described how the query system works. Now we fill in the details by presenting a complete implementation of the system.</p>
<section>
<h4><a id="c004_c4-sec-0146"></a><span>4.4.4.1</span> <a id="c004_c4-title-0147"></a>The Driver Loop</h4>
<p class="paraaftertitle"><a id="c004_c4-para-2255"></a>The driver loop for the query system repeatedly reads input expressions. If the expression is a rule or assertion to be added to the data base, then the information is added. Otherwise the expression is assumed to be a query. The driver passes this query to <span class="KeyTerm1">evaluate_query</span> together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is displayed:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2256"></a><b>const</b> input_prompt = "Query input:";</p>
<p class="Sp-text-1"><a id="c004_c4-para-2257"></a><b>const</b> output_prompt = "Query results:";</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-2258"></a><b>function</b> query_driver_loop() {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2259"></a> <b>const</b> input = user_read(input_prompt) + ";";</p>
<p class="Sp-text-1"><a id="c004_c4-para-2260"></a> <b>if</b> (is_null(input)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2261"></a>        display("evaluator terminated");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2262"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2263"></a> <b>const</b> expression = parse(input);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2264"></a> <b>const</b> query = convert_to_query_syntax(expression);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2265"></a> <b>if</b> (is_assertion(query)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2266"></a>            add_rule_or_assertion(assertion_body(query));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2267"></a>            display("Assertion added to data base.");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2268"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2269"></a>            display(output_prompt);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2270"></a>            display_stream(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2271"></a>              stream_map(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2272"></a>                 frame =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2273"></a>                   unparse(instantiate_expression(expression, frame)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2274"></a>                 evaluate_query(query, singleton_stream(<b>null</b>))));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2275"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2276"></a> <b>return</b> query_driver_loop();</p>
<p class="Sp-text-1"><a id="c004_c4-para-2277"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2278"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2279"></a>Here, as in the other evaluators in this chapter, we use <span class="KeyTerm1">parse</span> to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because <span class="KeyTerm1">parse</span> expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using <span class="KeyTerm1">convert_to_query_syntax</span>, which is declared in section 4.4.4.7 along with the predicate <span class="KeyTerm1">is_assertion</span> and the selector <span class="KeyTerm1">assertion_body</span>. The function <span class="KeyTerm1">add_rule_or_assertion</span> is declared in section 4.4.4.5. The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions <span class="KeyTerm1">instantiate_expression</span> and <span class="KeyTerm1">unparse</span> are declared in section 4.4.4.7.</p>
</section>
<section>
<h4><a id="c004_c4-sec-0147"></a><span>4.4.4.2</span> <a id="c004_c4-title-0148"></a>The Evaluator</h4>
<p class="paraaftertitle"><a id="c004_c4-para-2280"></a>The <span class="KeyTerm1">evaluate_query</span> function, called by the <span class="KeyTerm1">query_driver_loop</span>, is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies syntactic forms by a data-directed dispatch using <span class="KeyTerm1">get</span> and <span class="KeyTerm1">put</span>, just as we did in implementing generic operations in chapter 2. Any query that is not identified as a syntactic form is assumed to be a simple query, to be processed by <span class="KeyTerm1">simple_query</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2281"></a><b>function</b> evaluate_query(query, frame_stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2282"></a> <b>const</b> qfun = get(type(query), "evaluate_query");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2283"></a> <b>return</b> is_undefined(qfun)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2284"></a>           ? simple_query(query, frame_stream)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2285"></a>           : qfun(contents(query), frame_stream);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2286"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2287"></a>The functions <span class="KeyTerm1">type</span> and <span class="KeyTerm1">contents</span>, defined in section 4.4.4.7, implement the abstract syntax of the syntactic forms.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0148"></a><a id="c004_c4-title-0149"></a>Simple queries</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2288"></a>The <span class="KeyTerm1">simple_query</span> function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2289"></a><b>function</b> simple_query(query_pattern, frame_stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2290"></a> <b>return</b> stream_flatmap(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2291"></a>               frame =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2292"></a>                 stream_append_delayed(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2293"></a>                     find_assertions(query_pattern, frame),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2294"></a>                     () =&gt; apply_rules(query_pattern, frame)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2295"></a>               frame_stream);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2296"></a>}</p>
<p><a id="c004_c4-para-2297"></a>For each frame in the input stream, we use <span class="KeyTerm1">find_assertions</span> (section 4.4.4.3) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use <span class="KeyTerm1">apply_rules</span> (section 4.4.4.4) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using <span class="KeyTerm1">stream_append_delayed</span>, section 4.4.4.6) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise 4.68). The streams for the individual input frames are combined using <span class="KeyTerm1">stream_flatmap</span> (section 4.4.4.6) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0149"></a><a id="c004_c4-title-0150"></a>Compound queries</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2298"></a>We handle <span class="KeyTerm1">and</span> queries as illustrated in <a href="#c4-fig-0006">figure 4.6</a> with the <span class="KeyTerm1">conjoin</span> function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, <span class="KeyTerm1">conjoin</span> processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies <span class="KeyTerm1">conjoin</span> to the rest of the queries.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2299"></a><b>function</b> conjoin(conjuncts, frame_stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2300"></a> <b>return</b> is_empty_conjunction(conjuncts)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2301"></a>           ? frame_stream</p>
<p class="Sp-text-1"><a id="c004_c4-para-2302"></a>           : conjoin(rest_conjuncts(conjuncts),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2303"></a>                     evaluate_query(first_conjunct(conjuncts),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2304"></a>                                    frame_stream));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2305"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2306"></a>The statement</p>
<p class="Sp-text-1"><a id="c004_c4-para-2307"></a>put("and", "evaluate_query", conjoin);</p>
<p class="paracontinue"><a id="c004_c4-para-2308"></a>sets up <span class="KeyTerm1">evaluate_query</span> to dispatch to <span class="KeyTerm1">conjoin</span> when an <span class="KeyTerm1">and</span> is encountered.</p>
<p><a id="c004_c4-para-2309"></a>We handle <span class="KeyTerm1">or</span> queries similarly, as shown in <a href="#c4-fig-0007">figure 4.7</a>. The output streams for the various disjuncts of the <span class="KeyTerm1">or</span> are computed separately and merged using the <span class="KeyTerm1">interleave_delayed</span> function from section 4.4.4.6. (See exercises 4.68 and 4.69.)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2310"></a><b>function</b> disjoin(disjuncts, frame_stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2311"></a> <b>return</b> is_empty_disjunction(disjuncts)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2312"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-2313"></a>           : interleave_delayed(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2314"></a>                evaluate_query(first_disjunct(disjuncts), frame_stream),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2315"></a>                () =&gt; disjoin(rest_disjuncts(disjuncts), frame_stream));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2316"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2317"></a>put("or", "evaluate_query", disjoin);</p>
<p><a id="c004_c4-para-2318"></a>The predicates and selectors for the representation of conjuncts and disjuncts are given in section 4.4.4.7.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0150"></a><a id="c004_c4-title-0151"></a>Filters</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2319"></a>The <span class="KeyTerm1">not</span> syntactic form is handled by the method outlined in section 4.4.2. We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2320"></a><b>function</b> negate(exps, frame_stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2321"></a> <b>return</b> stream_flatmap(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2322"></a>               frame =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2323"></a>                 is_null(evaluate_query(negated_query(exps),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2324"></a>                                        singleton_stream(frame)))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2325"></a>                 ? singleton_stream(frame)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2326"></a>                 : <b>null</b>, frame_stream);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2327"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2328"></a>put("not", "evaluate_query", negate);</p>
<p><a id="c004_c4-para-2329"></a>The <span class="KeyTerm1">javascript_predicate</span> syntactic form is a filter similar to <span class="KeyTerm1">not</span>. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using <span class="KeyTerm1">evaluate</span> from section 4.1 with <span class="KeyTerm1">the_global_environment</span> and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2330"></a><b>function</b> javascript_predicate(exps, frame_stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2331"></a> <b>return</b> stream_flatmap(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2332"></a>               frame =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2333"></a>                 evaluate(instantiate_expression(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2334"></a>                              javascript_predicate_expression(exps),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2335"></a>                              frame),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2336"></a>                          the_global_environment)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2337"></a>                 ? singleton_stream(frame)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2338"></a>                 : <b>null</b>,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2339"></a>               frame_stream);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2340"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2341"></a>put("javascript_predicate", "evaluate_query", javascript_predicate);</p>
<p><a id="c004_c4-para-2342"></a>The <span class="KeyTerm1">always_true</span> syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. The <span class="KeyTerm1">rule_body</span> selector (section 4.4.4.7) uses <span class="KeyTerm1">always_true</span> to provide bodies for rules that were defined without bodies (that is, rules whose bodies are always satisfied).</p>
<p class="Sp-text-1"><a id="c004_c4-para-2343"></a><b>function</b> always_true(ignore, frame_stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2344"></a> <b>return</b> frame_stream;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2345"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2346"></a>put("always_true", "evaluate_query", always_true);</p>
<p class="paracontinue"><a id="c004_c4-para-2347"></a>The selectors that define the syntax of <span class="KeyTerm1">not</span> and <span class="KeyTerm1">javascript_predicate</span> are given in section 4.4.4.7.</p>
</section>
<section>
<h4><a id="c004_c4-sec-0151"></a><span>4.4.4.3</span> <a id="c004_c4-title-0152"></a>Finding Assertions by Pattern Matching</h4>
<p class="paraaftertitle"><a id="c004_c4-para-2348"></a>The function <span class="KeyTerm1">find_assertions</span>, called by <span class="KeyTerm1">simple_query</span> (section 4.4.4.2), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses <span class="KeyTerm1">fetch_assertions</span> (section 4.4.4.5) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for <span class="KeyTerm1">fetch_ assertions</span> here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated <span class="KeyTerm1">fetch_assertions</span> and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2349"></a><b>function</b> find_assertions(pattern, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2350"></a> <b>return</b> stream_flatmap(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2351"></a>                datum =&gt; check_an_assertion(datum, pattern, frame),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2352"></a>                fetch_assertions(pattern, frame));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2353"></a>}</p>
<p><a id="c004_c4-para-2354"></a>The function <span class="KeyTerm1">check_an_assertion</span> takes as arguments a data object (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or <span class="KeyTerm1"><b>null</b></span> if the match fails.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2355"></a><b>function</b> check_an_assertion(assertion, query_pat, query_frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2356"></a> <b>const</b> match_result = pattern_match(query_pat, assertion,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2357"></a>                                       query_frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2358"></a> <b>return</b> match_result === "failed"</p>
<p class="Sp-text-1"><a id="c004_c4-para-2359"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-2360"></a>           : singleton_stream(match_result);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2361"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2362"></a>The basic pattern matcher returns either the string <span class="KeyTerm1">"failed"</span> or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function <span class="KeyTerm1">is_variable</span> declared in section 4.4.4.7) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the head of the pattern against the head of the data to produce a frame; in this frame we then match the tail of the pattern against the tail of the data. If none of these cases are applicable, the match fails and we return the string <span class="KeyTerm1">"failed"</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2363"></a><b>function</b> pattern_match(pattern, data, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2364"></a> <b>return</b> frame === "failed"</p>
<p class="Sp-text-1"><a id="c004_c4-para-2365"></a>           ? "failed"</p>
<p class="Sp-text-1"><a id="c004_c4-para-2366"></a>           : equal(pattern, data)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2367"></a>           ? frame</p>
<p class="Sp-text-1"><a id="c004_c4-para-2368"></a>           : is_variable(pattern)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2369"></a>           ? extend_if_consistent(pattern, data, frame)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2370"></a>           : is_pair(pattern) &amp;&amp; is_pair(data)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2371"></a>           ? pattern_match(tail(pattern),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2372"></a>                           tail(data),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2373"></a>                           pattern_match(head(pattern),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2374"></a>                                         head(data),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2375"></a>                                         frame))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2376"></a>           : "failed";</p>
<p class="Sp-text-1"><a id="c004_c4-para-2377"></a>}</p>
<p><a id="c004_c4-para-2378"></a>Here is the function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2379"></a><b>function</b> extend_if_consistent(variable, data, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2380"></a> <b>const</b> binding = binding_in_frame(variable, frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2381"></a> <b>return</b> is_undefined(binding)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2382"></a>           ? extend(variable, data, frame)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2383"></a>           : pattern_match(binding_value(binding), data, frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2384"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2385"></a>If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by <span class="KeyTerm1">extend_if_consistent</span>, then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section 4.4.4.4). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which <span class="KeyTerm1">$x</span> is bound to <span class="KeyTerm1">list("f", $y)</span> and <span class="KeyTerm1">$y</span> is unbound, and we wish to augment this frame by a binding of <span class="KeyTerm1">$x</span> to <span class="KeyTerm1">list("f", "b")</span>. We look up <span class="KeyTerm1">$x</span> and find that it is bound to <span class="KeyTerm1">list("f", $y)</span>. This leads us to match <span class="KeyTerm1">list("f", $y)</span> against the proposed new value <span class="KeyTerm1">list("f", "b")</span> in the same frame. Eventually this match extends the frame by adding a binding of <span class="KeyTerm1">$y</span> to <span class="KeyTerm1">"b"</span>. The variable <span class="KeyTerm1">$x</span> remains bound to <span class="KeyTerm1">list("f", $y)</span>. We never modify a stored binding and we never store more than one binding for a given variable.</p>
<p><a id="c004_c4-para-2386"></a>The functions used by <span class="KeyTerm1">extend_if_consistent</span> to manipulate bindings are defined in section 4.4.4.8.</p>
</section>
<section>
<h4><a id="c004_c4-sec-0152"></a><span>4.4.4.4</span> <a id="c004_c4-title-0153"></a>Rules and Unification</h4>
<p class="paraaftertitle"><a id="c004_c4-para-2387"></a>The function <span class="KeyTerm1">apply_rules</span> is the rule analog of <span class="KeyTerm1">find_assertions</span> (section 4.4.4.3). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. The function <span class="KeyTerm1">stream_flatmap</span> maps <span class="KeyTerm1">apply_a_ rule</span> down the stream of possibly applicable rules (selected by <span class="KeyTerm1">fetch_rules</span>, section 4.4.4.5) and combines the resulting streams of frames.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2388"></a><b>function</b> apply_rules(pattern, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2389"></a> <b>return</b> stream_flatmap(rule =&gt; apply_a_rule(rule, pattern, frame),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2390"></a>                          fetch_rules(pattern, frame));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2391"></a>}</p>
<p><a id="c004_c4-para-2392"></a>The function <span class="KeyTerm1">apply_a_rule</span> applies a rule using the method outlined in section 4.4.2. It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame.</p>
<p><a id="c004_c4-para-2393"></a>Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named <span class="KeyTerm1">$x</span>, then each one may add a binding for <span class="KeyTerm1">$x</span> to the frame when it is applied. These two <span class="KeyTerm1">$x</span>'s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise 4.76.) Here is the <span class="KeyTerm1">apply_a_rule</span> function:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2394"></a><b>function</b> apply_a_rule(rule, query_pattern, query_frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2395"></a> <b>const</b> clean_rule = rename_variables_in(rule);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2396"></a> <b>const</b> unify_result = unify_match(query_pattern,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2397"></a>                                     conclusion(clean_rule),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2398"></a>                                     query_frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2399"></a> <b>return</b> unify_result === "failed"</p>
<p class="Sp-text-1"><a id="c004_c4-para-2400"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-2401"></a>           : evaluate_query(rule_body(clean_rule),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2402"></a>                            singleton_stream(unify_result));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2403"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2404"></a>The selectors <span class="KeyTerm1">rule_body</span> and <span class="KeyTerm1">conclusion</span> that extract parts of a rule are defined in section 4.4.4.7.</p>
<p><a id="c004_c4-para-2405"></a>We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each <span class="KeyTerm1">$x</span> in the rule to <span class="KeyTerm1">$x_7</span> and each <span class="KeyTerm1">$y</span> in the rule to <span class="KeyTerm1">$y_7</span>. (The functions <span class="KeyTerm1">make_new_variable</span> and <span class="KeyTerm1">new_rule_application_id</span> are included with the syntax functions in section 4.4.4.7.)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2406"></a><b>function</b> rename_variables_in(rule) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2407"></a> <b>const</b> rule_application_id = new_rule_application_id();</p>
<p class="Sp-text-1"><a id="c004_c4-para-2408"></a> <b>function</b> tree_walk(exp) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2409"></a> <b>return</b> is_variable(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2410"></a>               ? make_new_variable(exp, rule_application_id)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2411"></a>               : is_pair(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2412"></a>               ? pair(tree_walk(head(exp)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2413"></a>                      tree_walk(tail(exp)))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2414"></a>               : exp;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2415"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2416"></a> <b>return</b> tree_walk(rule);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2417"></a>}</p>
<p><a id="c004_c4-para-2418"></a>The unification algorithm is implemented as a function that takes as inputs two patterns and a frame and returns either the extended frame or the string <span class="KeyTerm1">"failed"</span>. The unifier is like the pattern matcher except that it is symmetrical—variables are allowed on both sides of the match. The function <span class="KeyTerm1">unify_match</span> is basically the same as <span class="KeyTerm1">pattern_match</span>, except that there is an extra clause (marked “***” below) to handle the case where the object on the right side of the match is a variable.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2419"></a><b>function</b> unify_match(p1, p2, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2420"></a> <b>return</b> frame === "failed"</p>
<p class="Sp-text-1"><a id="c004_c4-para-2421"></a>           ? "failed"</p>
<p class="Sp-text-1"><a id="c004_c4-para-2422"></a>           : equal(p1, p2)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2423"></a>           ? frame</p>
<p class="Sp-text-1"><a id="c004_c4-para-2424"></a>           : is_variable(p1)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2425"></a>           ? extend_if_possible(p1, p2, frame)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2426"></a>           : is_variable(p2) <i>//</i> ***</p>
<p class="Sp-text-1"><a id="c004_c4-para-2427"></a>           ? extend_if_possible(p2, p1, frame) <i>//</i> ***</p>
<p class="Sp-text-1"><a id="c004_c4-para-2428"></a>           : is_pair(p1) &amp;&amp; is_pair(p2)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2429"></a>           ? unify_match(tail(p1),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2430"></a>                         tail(p2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2431"></a>                         unify_match(head(p1),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2432"></a>                                     head(p2),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2433"></a>                                     frame))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2434"></a>           : "failed";</p>
<p class="Sp-text-1"><a id="c004_c4-para-2435"></a>}</p>
<p><a id="c004_c4-para-2436"></a>In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The function <span class="KeyTerm1">extend_if_possible</span> used in unification is the same as the function <span class="KeyTerm1">extend_if_consistent</span> used in pattern matching except for two special checks, marked “***” in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other.</p>
<p><a id="c004_c4-para-2437"></a>The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns <span class="KeyTerm1">list($x, $x)</span> and <span class="KeyTerm1">list($y,</span> <i>expression involving</i> <span class="KeyTerm1">$y )</span> in a frame where both <span class="KeyTerm1">$x</span> and <span class="KeyTerm1">$y</span> are unbound. First <span class="KeyTerm1">$x</span> is matched against <span class="KeyTerm1">$y</span>, making a binding of <span class="KeyTerm1">$x</span> to <span class="KeyTerm1">$y</span>. Next, the same <span class="KeyTerm1">$x</span> is matched against the given expression involving <span class="KeyTerm1">$y</span>. Since <span class="KeyTerm1">$x</span> is already bound to <span class="KeyTerm1">$y</span>, this results in matching <span class="KeyTerm1">$y</span> against the expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a <span class="KeyTerm1">$y</span> such that <span class="KeyTerm1">$y</span> is equal to the expression involving <span class="KeyTerm1">$y</span>. We reject such bindings; these cases are recognized by the predicate <span class="KeyTerm1">depends_on</span>.<a id="c004_c4-fn-0074a"></a><a href="#c4-fn-0074"><sup>74</sup></a> On the other hand, we do not want to reject attempts to bind a variable to itself. For example, consider unifying <span class="KeyTerm1">list($x, $x)</span> and <span class="KeyTerm1">list($y, $y)</span>. The second attempt to bind <span class="KeyTerm1">$x</span> to <span class="KeyTerm1">$y</span> matches <span class="KeyTerm1">$y</span> (the stored value of <span class="KeyTerm1">$x</span> ) against <span class="KeyTerm1">$y</span> (the new value of <span class="KeyTerm1">$x</span>). This is taken care of by the <span class="KeyTerm1">equal</span> clause of <span class="KeyTerm1">unify_match</span>.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2438"></a><b>function</b> extend_if_possible(variable, value, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2439"></a> <b>const</b> binding = binding_in_frame(variable, frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2440"></a> <b>if</b> (! is_undefined(binding)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2441"></a> <b>return</b> unify_match(binding_value(binding),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2442"></a>                            value, frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2443"></a>    } <b>else if</b> (is_variable(value)) { <i>//</i> ***</p>
<p class="Sp-text-1"><a id="c004_c4-para-2444"></a> <b>const</b> binding = binding_in_frame(value, frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2445"></a> <b>return</b> ! is_undefined(binding)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2446"></a>               ? unify_match(variable,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2447"></a>                             binding_value(binding),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2448"></a>                             frame)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2449"></a>               : extend(variable, value, frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2450"></a>    } <b>else if</b> (depends_on(value, variable, frame)) { <i>//</i> ***</p>
<p class="Sp-text-1"><a id="c004_c4-para-2451"></a> <b>return</b> "failed";</p>
<p class="Sp-text-1"><a id="c004_c4-para-2452"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2453"></a> <b>return</b> extend(variable, value, frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2454"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2455"></a>}</p>
<p><a id="c004_c4-para-2456"></a>The function <span class="KeyTerm1">depends_on</span> is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of <span class="KeyTerm1">depends_on</span> is a simple recursive tree walk in which we substitute for the values of variables whenever necessary.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2457"></a><b>function</b> depends_on(expression, variable, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2458"></a> <b>function</b> tree_walk(e) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2459"></a> <b>if</b> (is_variable(e)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2460"></a> <b>if</b> (equal(variable, e)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2461"></a> <b>return true</b>;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2462"></a>            } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2463"></a> <b>const</b> b = binding_in_frame(e, frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2464"></a> <b>return</b> is_undefined(b)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2465"></a>                       ? <b>false</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-2466"></a>                       : tree_walk(binding_value(b));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2467"></a>            }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2468"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2469"></a> <b>return</b> is_pair(e)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2470"></a>                   ? tree_walk(head(e)) || tree_walk(tail(e))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2471"></a>                   : <b>false</b>;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2472"></a>        }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2473"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2474"></a> <b>return</b> tree_walk(expression);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2475"></a>}</p>
</section>
<section>
<h4><a id="c004_c4-sec-0153"></a><span>4.4.4.5</span> <a id="c004_c4-title-0154"></a>Maintaining the Data Base</h4>
<p class="paraaftertitle"><a id="c004_c4-para-2476"></a>One important problem in designing logic programming languages is that of arranging things so that as few irrelevant data-base entries as possible will be examined in checking a given pattern. For this purpose, we will represent an assertion as a list whose head is a string that represents the kind of information of the assertion. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2477"></a><b>function</b> fetch_assertions(pattern, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2478"></a> <b>return</b> get_indexed_assertions(pattern);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2479"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2480"></a><b>function</b> get_indexed_assertions(pattern) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2481"></a> <b>return</b> get_stream(index_key_of(pattern), "assertion-stream");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2482"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2483"></a>The function <span class="KeyTerm1">get_stream</span> looks up a stream in the table and returns an empty stream if nothing is stored there.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2484"></a><b>function</b> get_stream(key1, key2) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2485"></a> <b>const</b> s = get(key1, key2);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2486"></a> <b>return</b> is_undefined(s) ? <b>null</b> : s;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2487"></a>}</p>
<p><a id="c004_c4-para-2488"></a>Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2489"></a><b>function</b> fetch_rules(pattern, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2490"></a> <b>return</b> get_indexed_rules(pattern);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2491"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2492"></a><b>function</b> get_indexed_rules(pattern) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2493"></a> <b>return</b> get_stream(index_key_of(pattern), "rule-stream");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2494"></a>}</p>
<p><a id="c004_c4-para-2495"></a>The function <span class="KeyTerm1">add_rule_or_assertion</span> is used by <span class="KeyTerm1">query_driver_loop</span> to add assertions and rules to the data base. Each item is stored in the index.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2496"></a><b>function</b> add_rule_or_assertion(assertion) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2497"></a> <b>return</b> is_rule(assertion)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2498"></a>           ? add_rule(assertion)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2499"></a>           : add_assertion(assertion);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2500"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2501"></a><b>function</b> add_assertion(assertion) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2502"></a>    store_assertion_in_index(assertion);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2503"></a> <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c004_c4-para-2504"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2505"></a><b>function</b> add_rule(rule) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2506"></a>    store_rule_in_index(rule);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2507"></a> <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c004_c4-para-2508"></a>}</p>
<p><a id="c004_c4-para-2509"></a>To actually store an assertion or a rule, we store it in the appropriate stream.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2510"></a><b>function</b> store_assertion_in_index(assertion) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2511"></a> <b>const</b> key = index_key_of(assertion);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2512"></a> <b>const</b> current_assertion_stream =</p>
<p class="Sp-text-1"><a id="c004_c4-para-2513"></a>                get_stream(key, "assertion-stream");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2514"></a>    put(key, "assertion-stream",</p>
<p class="Sp-text-1"><a id="c004_c4-para-2515"></a>        pair(assertion, () =&gt; current_assertion_stream));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2516"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2517"></a><b>function</b> store_rule_in_index(rule) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2518"></a> <b>const</b> pattern = conclusion(rule);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2519"></a> <b>const</b> key = index_key_of(pattern);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2520"></a> <b>const</b> current_rule_stream =</p>
<p class="Sp-text-1"><a id="c004_c4-para-2521"></a>                get_stream(key, "rule-stream");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2522"></a>    put(key, "rule-stream",</p>
<p class="Sp-text-1"><a id="c004_c4-para-2523"></a>        pair(rule, () =&gt; current_rule_stream));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2524"></a>}</p>
<p><a id="c004_c4-para-2525"></a>The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2526"></a><b>function</b> index_key_of(pattern) { <b>return</b> head(pattern); }</p>
</section>
<section>
<h4><a id="c004_c4-sec-0154"></a><span>4.4.4.6</span> <a id="c004_c4-title-0155"></a>Stream Operations</h4>
<p class="paraaftertitle"><a id="c004_c4-para-2527"></a>The query system uses a few stream operations that were not presented in chapter 3. The functions <span class="KeyTerm1">stream_append_delayed</span> and <span class="KeyTerm1">interleave_delayed</span> are just like <span class="KeyTerm1">stream_append</span> and <span class="KeyTerm1">interleave</span> (section 3.5.3), except that they take a delayed argument (like the <span class="KeyTerm1">integral</span> function in section 3.5.4). This postpones looping in some cases (see exercise 4.68).</p>
<p class="Sp-text-1"><a id="c004_c4-para-2528"></a><b>function</b> stream_append_delayed(s1, delayed_s2) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2529"></a> <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2530"></a>           ? delayed_s2()</p>
<p class="Sp-text-1"><a id="c004_c4-para-2531"></a>           : pair(head(s1),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2532"></a>                  () =&gt; stream_append_delayed(stream_tail(s1),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2533"></a>                                              delayed_s2));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2534"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2535"></a><b>function</b> interleave_delayed(s1, delayed_s2) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2536"></a> <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2537"></a>           ? delayed_s2()</p>
<p class="Sp-text-1"><a id="c004_c4-para-2538"></a>           : pair(head(s1),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2539"></a>                  () =&gt; interleave_delayed(delayed_s2(),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2540"></a>                                           () =&gt; stream_tail(s1)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2541"></a>}</p>
<p><a id="c004_c4-para-2542"></a>The function <span class="KeyTerm1">stream_flatmap</span>, which is used throughout the query evaluator to map a function over a stream of frames and combine the resulting streams of frames, is the stream analog of the <span class="KeyTerm1">flatmap</span> function introduced for ordinary lists in section 2.2.3. Unlike ordinary <span class="KeyTerm1">flatmap</span>, however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises 4.69 and 4.70).</p>
<p class="Sp-text-1"><a id="c004_c4-para-2543"></a><b>function</b> stream_flatmap(fun, s) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2544"></a> <b>return</b> flatten_stream(stream_map(fun, s));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2545"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2546"></a><b>function</b> flatten_stream(stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2547"></a> <b>return</b> is_null(stream)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2548"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-2549"></a>           : interleave_delayed(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2550"></a>                  head(stream),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2551"></a>                  () =&gt; flatten_stream(stream_tail(stream)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2552"></a>}</p>
<p><a id="c004_c4-para-2553"></a>The evaluator also uses the following simple function to generate a stream consisting of a single element:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2554"></a><b>function</b> singleton_stream(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2555"></a> <b>return</b> pair(x, () =&gt; <b>null</b>);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2556"></a>}</p>
</section>
<section>
<h4><a id="c004_c4-sec-0155"></a><span>4.4.4.7</span> <a id="c004_c4-title-0156"></a>Query Syntax Functions and Instantiation</h4>
<p class="paraaftertitle"><a id="c004_c4-para-2557"></a>We saw in section 4.4.4.1 that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the <span class="KeyTerm1">parse</span> function from section 4.1.2 and also to support JavaScript notation in <span class="KeyTerm1">javascript_predicate</span>. For example,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2558"></a>parse('job($x, list("computer", "wizard"));');</p>
<p class="paracontinue"><a id="c004_c4-para-2559"></a>yields</p>
<p class="Sp-text-1"><a id="c004_c4-para-2560"></a><i>list("application",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2561"></a> <i>list("name", "job"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2562"></a> <i>list(list("name", "$x"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2563"></a> <i>list("application",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2564"></a> <i>list("name", "list"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2565"></a> <i>list(list("literal", "computer"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2566"></a> <i>list("literal", "wizard")))))</i></p>
<p class="paracontinue"><a id="c004_c4-para-2567"></a>The tag <span class="KeyTerm1">"application"</span> indicates that syntactically, the query would be treated as a function application in JavaScipt. The function <span class="KeyTerm1">unparse</span> transforms the syntax back into a string:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2568"></a>unparse(parse('job($x, list("computer", "wizard"));'));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2569"></a><i>'job($x, list("computer", "wizard"))'</i></p>
<p class="paracontinue"><a id="c004_c4-para-2570"></a>In the query processor, we assumed a query-language-specific representation of assertions, rules, and queries. The function <span class="KeyTerm1">convert_to_query_syntax</span> transforms the syntax representation into that representation. Using the same example,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2571"></a>convert_to_query_syntax(parse('job($x, list("computer", "wizard"));'));</p>
<p class="paracontinue"><a id="c004_c4-para-2572"></a>yields</p>
<p class="Sp-text-3"><a id="c004_c4-para-2573"></a><i>list("job", list("name", "$x"), list("computer", "wizard"))</i></p>
<p class="paracontinue"><a id="c004_c4-para-2574"></a>Query-system functions such as <span class="KeyTerm1">add_rule_or_assertion</span> in section 4.4.4.5 and <span class="KeyTerm1">evaluate_query</span> in section 4.4.4.2 operate on the query-language-specific representation using selectors and predicates such as <span class="KeyTerm1">type</span>, <span class="KeyTerm1">contents</span>, <span class="KeyTerm1">is_rule</span>, and <span class="KeyTerm1">first_conjunct</span> declared below. <a id="c004_c4-fig-0008a"></a><a href="#c4-fig-0008">Figure 4.8</a> depicts the three abstraction barriers used by the query system and how the transformation functions <span class="KeyTerm1">parse</span>, <span class="KeyTerm1">unparse</span>, and <span class="KeyTerm1">convert_to_query_syntax</span> bridge them.</p>
<figure id="c004_c4-fig-0008"><img alt="c4-fig-0008.jpg" src="../images/c4-fig-0008.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0008a">Figure 4.8</a></span> <a id="c004_c4-para-2575"></a>Syntax abstraction in the query system.</p></figcaption></figure>
</section>
<section>
<h5><a id="c004_c4-sec-0156"></a><a id="c004_c4-title-0157"></a>Handling pattern variables</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2576"></a>The predicate <span class="KeyTerm1">is_variable</span> is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. We assume there is a function <span class="KeyTerm1">char_at</span> that returns a string containing only the character of the given string at the given position.<a id="c004_c4-fn-0075a"></a><a href="#c4-fn-0075"><sup>75</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-2577"></a><b>function</b> is_variable(exp) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2578"></a> <b>return</b> is_name(exp) &amp;&amp; char_at(symbol_of_name(exp), 0) === "$";</p>
<p class="Sp-text-1"><a id="c004_c4-para-2579"></a>}</p>
<p><a id="c004_c4-para-2580"></a>Unique variables are constructed during rule application (in section 4.4.4.4) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied.<a id="c004_c4-fn-0076a"></a><a href="#c4-fn-0076"><sup>76</sup></a></p>
<p class="Sp-text-1"><a id="c004_c4-para-2581"></a><b>let</b> rule_counter = 0;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-2582"></a><b>function</b> new_rule_application_id() { </p>
<p class="Sp-text-1"><a id="c004_c4-para-5582"></a>    rule_counter = rule_counter + 1;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2583"></a> <b>return</b> rule_counter;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2584"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2585"></a><b>function</b> make_new_variable(variable, rule_application_id) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2586"></a> <b>return</b> make_name(symbol_of_name(variable) + "_" +</p>
<p class="Sp-text-1"><a id="c004_c4-para-2587"></a>                     stringify(rule_application_id));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2588"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0157"></a><a id="c004_c4-title-0158"></a>The function <span class="KeyTerm1"><b>convert_to_query_syntax</b></span></h5>
<p class="paraaftertitle"><a id="c004_c4-para-2589"></a>The function <span class="KeyTerm1">convert_to_query_syntax</span> recursively transforms the JavaScript syntax representation into the query-language-specific representation by simplifying assertions, rules, and queries such that the symbol of a name in a function expression of an application becomes a tag, except that if the symbol is <span class="KeyTerm1">"pair"</span> or <span class="KeyTerm1">"list"</span>, an (untagged) JavaScript pair or list is built. This means that <span class="KeyTerm1">convert_to_ query_syntax</span> interprets applications of the constructors <span class="KeyTerm1">pair</span> and <span class="KeyTerm1">list</span> during the transformation, and processing functions such as <span class="KeyTerm1">pattern_match</span> of section 4.4.4.3 and <span class="KeyTerm1">unify_match</span> of section 4.4.4.4 can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) “argument” list of <span class="KeyTerm1">javascript_predicate</span> remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2590"></a><b>function</b> convert_to_query_syntax(exp) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2591"></a> <b>if</b> (is_application(exp)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2592"></a> <b>const</b> function_symbol = symbol_of_name(function_expression(exp));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2593"></a> <b>if</b> (function_symbol === "javascript_predicate") {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2594"></a> <b>return</b> pair(function_symbol, arg_expressions(exp));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2595"></a>     } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2596"></a> <b>const</b> processed_args = map(convert_to_query_syntax,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2597"></a>                                  arg_expressions(exp));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2598"></a> <b>return</b> function_symbol === "pair"</p>
<p class="Sp-text-1"><a id="c004_c4-para-2599"></a>              ? pair(head(processed_args), head(tail(processed_args)))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2600"></a>              : function_symbol === "list"</p>
<p class="Sp-text-1"><a id="c004_c4-para-2601"></a>              ? processed_args</p>
<p class="Sp-text-1"><a id="c004_c4-para-2602"></a>              : pair(function_symbol, processed_args);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2603"></a>     }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2604"></a>   } <b>else if</b> (is_variable(exp)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2605"></a> <b>return</b> exp;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2606"></a>   } <b>else</b> { <i>// exp is literal</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2607"></a> <b>return</b> literal_value(exp);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2608"></a>   }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2609"></a>}</p>
<p><a id="c004_c4-para-2610"></a>An exception to this processing is <span class="KeyTerm1">javascript_predicate</span>. Since the instantiated JavaScript syntax representation of its predicate expression is passed to <span class="KeyTerm1">evaluate</span> of section 4.1.1, the original syntax representation coming from <span class="KeyTerm1">parse</span> needs to remain intact in the query-language-specific representation of the expression. In this example of section 4.4.1</p>
<p class="Sp-text-1"><a id="c004_c4-para-2611"></a>and(salary($person, $amount), javascript_predicate($amount &gt; 50000))</p>
<p class="paracontinue"><a id="c004_c4-para-2612"></a><span class="KeyTerm1">convert_to_query_syntax</span> produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2613"></a><i>list("and",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2614"></a> <i>list("salary", list("name", "$person"), list("name", "$amount")),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2615"></a> <i>list("javascript_predicate",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2616"></a> <i>list("binary_operator_combination",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2617"></a> <i>"&gt;",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2618"></a> <i>list("name", "$amount"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2619"></a> <i>list("literal", 50000))))</i></p>
<p class="paracontinue"><a id="c004_c4-para-2620"></a>In order to evaluate the <span class="KeyTerm1">javascript_predicate</span> subexpression of that processed query, the function <span class="KeyTerm1">javascript_predicate</span> in section 4.4.4.2 calls the function <span class="KeyTerm1">instantiate_expression</span> (below) on the embedded JavaScript syntax representation of <span class="KeyTerm1">$amount &gt; 50000</span> to replace the variable <span class="KeyTerm1">list("name", "$amount")</span> by a literal, for example <span class="KeyTerm1">list("literal", 70000)</span>, that represents the primitive value to which <span class="KeyTerm1">$amount</span> is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents <span class="KeyTerm1">70000 &gt; 50000</span>.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0158"></a><a id="c004_c4-title-0159"></a>Instantiating an expression</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2621"></a>The function <span class="KeyTerm1">javascript_predicate</span> of section 4.4.4.2 and the driver loop of section 4.4.4.1 call <span class="KeyTerm1">instantiate_expression</span> on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2622"></a><b>function</b> instantiate_expression(expression, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2623"></a> <b>return</b> is_variable(expression)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2624"></a>          ? convert(instantiate_term(expression, frame))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2625"></a>          : is_pair(expression)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2626"></a>          ? pair(instantiate_expression(head(expression), frame),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2627"></a>                 instantiate_expression(tail(expression), frame))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2628"></a>          : expression;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2629"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2630"></a>The function <span class="KeyTerm1">instantiate_term</span> takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if <span class="KeyTerm1">$x</span> is bound to the pair [<span class="KeyTerm1">$y</span>, 5] in a frame <i>f</i> as the result of unification, and <span class="KeyTerm1">$y</span> is in turn bound to 3, the result of applying <span class="KeyTerm1">instantiate_term</span> to <span class="KeyTerm1">list("name", "$x")</span> and <i>f</i> is the pair [3, 5].</p>
<p class="Sp-text-1"><a id="c004_c4-para-2631"></a><b>function</b> instantiate_term(term, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2632"></a> <b>if</b> (is_variable(term)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2633"></a> <b>const</b> binding = binding_in_frame(term, frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2634"></a> <b>return</b> is_undefined(binding)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2635"></a>              ? term <i>//</i> <span class="KeyTerm2"><i>leave unbound variable as is</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-2636"></a>           : instantiate_term(binding_value(binding), frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2637"></a>    } <b>else if</b> (is_pair(term)) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2638"></a> <b>return</b> pair(instantiate_term(head(term), frame),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2639"></a>                    instantiate_term(tail(term), frame));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2640"></a>    } <b>else</b> { <i>//</i> term <span class="KeyTerm2"><i>is a primitive value</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-2641"></a> <b>return</b> term;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2642"></a>    }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2643"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2644"></a>The function <span class="KeyTerm1">convert</span> constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by <span class="KeyTerm1">instantiate_term</span>. A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2645"></a><b>function</b> convert(term) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2646"></a> <b>return</b> is_variable(term)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2647"></a>           ? term</p>
<p class="Sp-text-1"><a id="c004_c4-para-2648"></a>           : is_pair(term)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2649"></a>           ? make_application(make_name("pair"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2650"></a>                              list(convert(head(term)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2651"></a>                                   convert(tail(term))))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2652"></a>           : <i>//</i> term <span class="KeyTerm2"><i>is a primitive value</i></span></p>
<p class="Sp-text-1"><a id="c004_c4-para-2653"></a>             make_literal(term);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2654"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2655"></a>To illustrate these three functions, consider what happens when the query</p>
<p class="Sp-text-1"><a id="c004_c4-para-2656"></a>job($x, list("computer", "wizard"))</p>
<p class="paracontinue"><a id="c004_c4-para-2657"></a>whose JavaScript syntax representation is given at the beginning of section 4.4.4.7, is processed by the driver loop. Let's say a frame <i>g</i> of the result stream binds the variable <span class="KeyTerm1">$x</span> to the pair [<span class="KeyTerm1">"Bitdiddle"</span>, <span class="KeyTerm1">$y</span>] and the variable <span class="KeyTerm1">$y</span> to the pair [<span class="KeyTerm1">"Ben"</span>, <span class="KeyTerm1">null</span>]. Then</p>
<p class="Sp-text-1"><a id="c004_c4-para-2658"></a>instantiate_term(list("name", "$x"), <i>g</i>)</p>
<p class="paracontinue"><a id="c004_c4-para-2659"></a>returns the list</p>
<p class="Sp-text-1"><a id="c004_c4-para-2660"></a><i>list("Bitdiddle", "Ben")</i></p>
<p class="paracontinue"><a id="c004_c4-para-2661"></a>which <span class="KeyTerm1">convert</span> transforms into</p>
<p class="Sp-text-1"><a id="c004_c4-para-2662"></a><i>list("application",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2663"></a> <i>list("name", "pair"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2664"></a> <i>list(list("literal", "Bitdiddle"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2665"></a> <i>list("application",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2666"></a> <i>list("name", "pair"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2667"></a> <i>list(list("literal", "Ben"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2668"></a> <i>list("literal", null)))))</i></p>
<p class="paracontinue"><a id="c004_c4-para-2669"></a>The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame <i>g</i> is:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2670"></a><i>list("application",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2671"></a> <i>list("name", "job"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2672"></a> <i>list(list("application",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2673"></a> <i>list("name", "pair"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2674"></a> <i>list(list("literal", "Bitdiddle"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2675"></a> <i>list("application",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2676"></a> <i>list("name", "pair"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2677"></a> <i>list(list("literal", "Ben"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2678"></a> <i>list("literal", null))))),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2679"></a> <i>list("application",</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2680"></a> <i>list("name", "list"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2681"></a> <i>list(list("literal", "computer"),</i></p>
<p class="Sp-text-1"><a id="c004_c4-para-2682"></a> <i>list("literal", "wizard")))))</i></p>
<p class="paracontinue"><a id="c004_c4-para-2683"></a>The driver loop unparses this representation and displays it as:</p>
<p class="Sp-text-3"><a id="c004_c4-para-2684"></a><i>'job(list("Bitdiddle", "Ben"), list("computer", "wizard"))'</i></p>
</section>
<section>
<h5><a id="c004_c4-sec-0159"></a><a id="c004_c4-title-0160"></a>The function <span class="KeyTerm1"><b>unparse</b></span></h5>
<p class="paraaftertitle"><a id="c004_c4-para-2685"></a>The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section 4.1.2. We describe <span class="KeyTerm1">unparse</span> only for those kinds of expressions that appear in the examples of section 4.4.1, leaving statements and the remaining kinds of expressions as exercise 4.2. A literal is transformed by <span class="KeyTerm1">stringifying</span> its value, and a name is transformed into its symbol. An application is formatted by unparsing the function expression, which we can assume to be a name here, followed by the comma-separated argument expression strings enclosed in parentheses. Binary operator combinations are formatted using infix notation.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2686"></a><b>function</b> unparse(exp) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2687"></a> <b>return</b> is_literal(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2688"></a>           ? stringify(literal_value(exp))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2689"></a>           : is_name(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2690"></a>           ? symbol_of_name(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2691"></a>           : is_list_construction(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2692"></a>           ? unparse(make_application(make_name("list"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2693"></a>                                      element_expressions(exp)))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2694"></a>           : is_application(exp) &amp;&amp; is_name(function_expression(exp))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2695"></a>           ? symbol_of_name(function_expression(exp)) +</p>
<p class="Sp-text-1"><a id="c004_c4-para-2696"></a>                 "(" +</p>
<p class="Sp-text-1"><a id="c004_c4-para-2697"></a>                 comma_separated(map(unparse, arg_expressions(exp))) +</p>
<p class="Sp-text-1"><a id="c004_c4-para-2698"></a>                 ")"</p>
<p class="Sp-text-1"><a id="c004_c4-para-2699"></a>           : is_binary_operator_combination(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2700"></a>           ? "(" + unparse(first_operand(exp)) +</p>
<p class="Sp-text-1"><a id="c004_c4-para-2701"></a>             " " + operator_symbol(exp) +</p>
<p class="Sp-text-1"><a id="c004_c4-para-2702"></a>             " " + unparse(second_operand(exp)) +</p>
<p class="Sp-text-1"><a id="c004_c4-para-2703"></a>             ")"</p>
<p class="Sp-text-1"><a id="c004_c4-para-2704"></a>           〈<span class="KeyTerm2"><i>unparsing other kinds of JavaScript components</i></span>〉</p>
<p class="Sp-text-1"><a id="c004_c4-para-2705"></a>           : error(exp, "unknown syntax – unparse");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2706"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2707"></a><b>function</b> comma_separated(strings) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2708"></a> <b>return</b> accumulate((s, acc) =&gt; s + (acc === "" ? "" : ", " + acc),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2709"></a>                      "",</p>
<p class="Sp-text-1"><a id="c004_c4-para-2710"></a>                      strings);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2711"></a>}</p>
<p><a id="c004_c4-para-2712"></a>The function <span class="KeyTerm1">unparse</span> would work fine without the clause</p>
<p class="Sp-text-1"><a id="c004_c4-para-2713"></a>: is_list_construction(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2714"></a>? unparse(make_application(make_name("list"),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2715"></a>                           element_expressions(exp)))</p>
<p class="paracontinue"><a id="c004_c4-para-2716"></a>but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query</p>
<p class="Sp-text-1"><a id="c004_c4-para-2717"></a>job($x, list("computer", "wizard"))</p>
<p class="paracontinue"><a id="c004_c4-para-2718"></a>yields a frame that binds <span class="KeyTerm1">$x</span> to [<span class="KeyTerm1">"Bitdiddle"</span>, [<span class="KeyTerm1">"Ben"</span>, <span class="KeyTerm1">null</span>]], <span class="KeyTerm1">unparse</span> produces</p>
<p class="Sp-text-3"><a id="c004_c4-para-2719"></a><i>'job(list("Bitdiddle", "Ben"), list("computer", "wizard"))'</i></p>
<p class="paracontinue"><a id="c004_c4-para-2720"></a>However, without the clause it would produce</p>
<p class="Sp-text-3"><a id="c004_c4-para-2721"></a><i>'job(pair("Bitdiddle", pair("Ben", null)), list("computer", "wizard"))'</i></p>
<p class="paracontinue"><a id="c004_c4-para-2722"></a>which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section 4.4.1, we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of <span class="KeyTerm1">list</span> to the list of element expressions that we extract from the expression. A list construction is the literal <span class="KeyTerm1"><b>null</b></span> or an application of <span class="KeyTerm1">pair</span> whose second argument is itself a list construction.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2723"></a><b>function</b> is_list_construction(exp) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2724"></a> <b>return</b> (is_literal(exp) &amp;&amp; is_null(literal_value(exp))) ||</p>
<p class="Sp-text-1"><a id="c004_c4-para-2725"></a>           (is_application(exp) &amp;&amp; is_name(function_expression(exp)) &amp;&amp;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2726"></a>            symbol_of_name(function_expression(exp)) === "pair" &amp;&amp;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2727"></a>            is_list_construction(head(tail(arg_expressions(exp)))));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2728"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2729"></a>Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of <span class="KeyTerm1">pair</span> until the literal <span class="KeyTerm1"><b>null</b></span> is reached.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2730"></a><b>function</b> element_expressions(list_constr) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2731"></a> <b>return</b> is_literal(list_constr)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2732"></a>           ? <b>null</b> <i>//</i> list_constr <span class="KeyTerm2"><i>is literal</i></span> null</p>
<p class="Sp-text-1"><a id="c004_c4-para-2733"></a>           :      <i>//</i> list_constr <span class="KeyTerm2"><i>is application of</i></span> pair</p>
<p class="Sp-text-1"><a id="c004_c4-para-2734"></a>             pair(head(arg_expressions(list_constr)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2735"></a>                  element_expressions(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2736"></a>                      head(tail(arg_expressions(list_constr)))));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2737"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0160"></a><a id="c004_c4-title-0161"></a>Predicates and selectors for the query-language-specific representation</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2738"></a>The functions <span class="KeyTerm1">type</span> and <span class="KeyTerm1">contents</span>, used by <span class="KeyTerm1">evaluate_query</span> (section 4.4.4.2), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the <span class="KeyTerm1">type_tag</span> and <span class="KeyTerm1">contents</span> functions in section 2.4.2, except for the error message.</p>
<p class="Sp-text-1"><a id="c004_c4-para-2739"></a><b>function</b> type(exp) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2740"></a> <b>return</b> is_pair(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2741"></a>           ? head(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2742"></a>           : error(exp, "unknown expression type");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2743"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2744"></a><b>function</b> contents(exp) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2745"></a> <b>return</b> is_pair(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2746"></a>           ? tail(exp)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2747"></a>           : error(exp, "unknown expression contents");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2748"></a>}</p>
<p><a id="c004_c4-para-2749"></a>The following functions, used by <span class="KeyTerm1">query_driver_loop</span> (in section 4.4.4.1), specify that rules and assertions are added to the data base by an <span class="KeyTerm1">assert</span> command, which the function <span class="KeyTerm1">convert_to_query_syntax</span> transforms into a pair of the form <span class="KeyTerm1">["assert",</span> <i>rule</i>-<i>or</i>-<i>assertion</i><span class="KeyTerm1">]</span>:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2750"></a><b>function</b> is_assertion(exp) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2751"></a> <b>return</b> type(exp) === "assert";</p>
<p class="Sp-text-1"><a id="c004_c4-para-2752"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2753"></a><b>function</b> assertion_body(exp) { <b>return</b> head(contents(exp)); }</p>
<p><a id="c004_c4-para-2754"></a>Here are the declarations of the predicates and selectors for the <span class="KeyTerm1">and</span>, <span class="KeyTerm1">or</span>, <span class="KeyTerm1">not</span>, and <span class="KeyTerm1">javascript_predicate</span> syntactic forms (section 4.4.4.2):</p>
<p class="Sp-text-1"><a id="c004_c4-para-2755"></a><b>function</b> is_empty_conjunction(exps) { <b>return</b> is_null(exps); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2756"></a><b>function</b> first_conjunct(exps) { <b>return</b> head(exps); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2757"></a><b>function</b> rest_conjuncts(exps) { <b>return</b> tail(exps); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-2758"></a><b>function</b> is_empty_disjunction(exps) { <b>return</b> is_null(exps); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2759"></a><b>function</b> first_disjunct(exps) { <b>return</b> head(exps); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2760"></a><b>function</b> rest_disjuncts(exps) { <b>return</b> tail(exps); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-2761"></a><b>function</b> negated_query(exps) { <b>return</b> head(exps); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c004_c4-para-2762"></a><b>function</b> javascript_predicate_expression(exps) { <b>return</b> head(exps); }</p>
<p><a id="c004_c4-para-2763"></a>The following three functions define the query-language-specific representation of rules:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2764"></a><b>function</b> is_rule(assertion) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2765"></a> <b>return</b> is_tagged_list(assertion, "rule");</p>
<p class="Sp-text-1"><a id="c004_c4-para-2766"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2767"></a><b>function</b> conclusion(rule) { <b>return</b> head(tail(rule)); }</p>
<p class="Sp-text-1"><a id="c004_c4-para-2768"></a><b>function</b> rule_body(rule) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2769"></a> <b>return</b> is_null(tail(tail(rule)))</p>
<p class="Sp-text-1"><a id="c004_c4-para-2770"></a>           ? list("always_true")</p>
<p class="Sp-text-1"><a id="c004_c4-para-2771"></a>           : head(tail(tail(rule)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2772"></a>}</p>
</section>
<section>
<h4><a id="c004_c4-sec-0161"></a><span>4.4.4.8</span> <a id="c004_c4-title-0162"></a>Frames and Bindings</h4>
<p class="paraaftertitle"><a id="c004_c4-para-2773"></a>Frames are represented as lists of bindings, which are variable-value pairs:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2774"></a><b>function</b> make_binding(variable, value) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2775"></a> <b>return</b> pair(variable, value);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2776"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2777"></a><b>function</b> binding_variable(binding) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2778"></a> <b>return</b> head(binding);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2779"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2780"></a><b>function</b> binding_value(binding) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2781"></a> <b>return</b> tail(binding);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2782"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2783"></a><b>function</b> binding_in_frame(variable, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2784"></a> <b>return</b> assoc(variable, frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2785"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2786"></a><b>function</b> extend(variable, value, frame) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2787"></a> <b>return</b> pair(make_binding(variable, value), frame);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2788"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0162"></a><a id="c004_c4-title-0163"></a>Exercise 4.68</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2789"></a>Louis Reasoner wonders why the <span class="KeyTerm1">simple_query</span> and <span class="KeyTerm1">disjoin</span> functions (section 4.4.4.2) are implemented using delayed expressions rather than being defined as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2790"></a><b>function</b> simple_query(query_pattern, frame_stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2791"></a> <b>return</b> stream_flatmap(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2792"></a>               frame =&gt;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2793"></a>                 stream_append(find_assertions(query_pattern, frame),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2794"></a>                               apply_rules(query_pattern, frame)),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2795"></a>               frame_stream);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2796"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2797"></a><b>function</b> disjoin(disjuncts, frame_stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2798"></a> <b>return</b> is_empty_disjunction(disjuncts)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2799"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-2800"></a>           : interleave(</p>
<p class="Sp-text-1"><a id="c004_c4-para-2801"></a>                  evaluate_query(first_disjunct(disjuncts), frame_stream),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2802"></a>                  disjoin(rest_disjuncts(disjuncts), frame_stream));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2803"></a>}</p>
<p class="paracontinue"><a id="c004_c4-para-2804"></a>Can you give examples of queries where these simpler definitions would lead to undesirable behavior?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0163"></a><a id="c004_c4-title-0164"></a>Exercise 4.69</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2805"></a>Why do <span class="KeyTerm1">disjoin</span> and <span class="KeyTerm1">stream_flatmap</span> interleave the streams rather than simply append them? Give examples that illustrate why interleaving works better. (Hint: Why did we use <span class="KeyTerm1">interleave</span> in section 3.5.3?)</p>
</section>
<section>
<h5><a id="c004_c4-sec-0164"></a><a id="c004_c4-title-0165"></a>Exercise 4.70</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2806"></a>Why does <span class="KeyTerm1">flatten_stream</span> use a delayed expression in its body? What would be wrong with defining it as follows:</p>
<p class="Sp-text-1"><a id="c004_c4-para-2807"></a><b>function</b> flatten_stream(stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2808"></a> <b>return</b> is_null(stream)</p>
<p class="Sp-text-1"><a id="c004_c4-para-2809"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c004_c4-para-2810"></a>           : interleave(head(stream),</p>
<p class="Sp-text-1"><a id="c004_c4-para-2811"></a>                        flatten_stream(stream_tail(stream)));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2812"></a>}</p>
</section>
<section>
<h5><a id="c004_c4-sec-0165"></a><a id="c004_c4-title-0166"></a>Exercise 4.71</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2813"></a>Alyssa P. Hacker proposes to use a simpler version of <span class="KeyTerm1">stream_flatmap</span> in <span class="KeyTerm1">negate</span>, <span class="KeyTerm1">javascript_predicate</span>, and <span class="KeyTerm1">find_assertions</span>. She observes that the function that is mapped over the frame stream in these cases always produces either the empty stream or a singleton stream, so no interleaving is needed when combining these streams.</p>
<ol class="BS_NumberListA">
<li><a id="c004_c4-li-0103"></a><span>a. </span>Fill in the missing expressions in Alyssa's program.
<p class="Sp-text-1"><a id="c004_c4-para-2815"></a><b>function</b> simple_stream_flatmap(fun, s) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2816"></a> <b>return</b> simple_flatten(stream_map(fun, s));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2817"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2818"></a><b>function</b> simple_flatten(stream) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2819"></a> <b>return</b> stream_map(〈<span class="KeyTerm2">??</span>〉,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2820"></a>                      stream_filter(〈<span class="KeyTerm2">??</span>〉, stream));</p>
<p class="Sp-text-1"><a id="c004_c4-para-2821"></a><sub>}</sub></p></li>
<li><a id="c004_c4-li-0104"></a><span>b. </span>Does the query system's behavior change if we change it in this way?</li>
</ol>
</section>
<section>
<h5><a id="c004_c4-sec-0166"></a><a id="c004_c4-title-0167"></a>Exercise 4.72</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2823"></a>Implement for the query language a syntactic form called <span class="KeyTerm1">unique</span>. Applictions of <span class="KeyTerm1">unique</span> should succeed if there is precisely one item in the data base satisfying a specified query. For example,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2824"></a>unique(job($x, list("computer", "wizard")))</p>
<p class="paracontinue"><a id="c004_c4-para-2825"></a>should print the one-item stream</p>
<p class="Sp-text-1"><a id="c004_c4-para-2826"></a>unique(job(list("Bitdiddle", "Ben"), list("computer", "wizard")))</p>
<p class="paracontinue"><a id="c004_c4-para-2827"></a>since Ben is the only computer wizard, and</p>
<p class="Sp-text-1"><a id="c004_c4-para-2828"></a>unique(job($x, list("computer", "programmer")))</p>
<p class="paracontinue"><a id="c004_c4-para-2829"></a>should print the empty stream, since there is more than one computer programmer. Moreover,</p>
<p class="Sp-text-1"><a id="c004_c4-para-2830"></a>and(job($x, $j), unique(job($anyone, $j)))</p>
<p class="paracontinue"><a id="c004_c4-para-2831"></a>should list all the jobs that are filled by only one person, and the people who fill them.</p>
<p><a id="c004_c4-para-2832"></a>There are two parts to implementing <span class="KeyTerm1">unique</span>. The first is to write a function that handles this syntactic form, and the second is to make <span class="KeyTerm1">evaluate_query</span> dispatch to that function. The second part is trivial, since <span class="KeyTerm1">evaluate_query</span> does its dispatching in a data-directed way. If your function is called <span class="KeyTerm1">uniquely_asserted</span>, all you need to do is</p>
<p class="Sp-text-1"><a id="c004_c4-para-2833"></a>put("unique", "evaluate_query", uniquely_asserted);</p>
<p class="paracontinue"><a id="c004_c4-para-2834"></a>and <span class="KeyTerm1">evaluate_query</span> will dispatch to this function for every query whose <span class="KeyTerm1">type</span> (head) is the string <span class="KeyTerm1">"unique"</span>.</p>
<p><a id="c004_c4-para-2835"></a>The real problem is to write the function <span class="KeyTerm1">uniquely_asserted</span>. This should take as input the <span class="KeyTerm1">contents</span> (tail) of the <span class="KeyTerm1">unique</span> query, together with a stream of frames. For each frame in the stream, it should use <span class="KeyTerm1">evaluate_query</span> to find the stream of all extensions to the frame that satisfy the given query. Any stream that does not have exactly one item in it should be eliminated. The remaining streams should be passed back to be accumulated into one big stream that is the result of the <span class="KeyTerm1">unique</span> query. This is similar to the implementation of the <span class="KeyTerm1">not</span> syntactic form.</p>
<p><a id="c004_c4-para-2836"></a>Test your implementation by forming a query that lists all people who supervise precisely one person.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0167"></a><a id="c004_c4-title-0168"></a>Exercise 4.73</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2837"></a>Our implementation of <span class="KeyTerm1">and</span> as a series combination of queries (<a href="#c4-fig-0006">figure 4.6</a>) is elegant, but it is inefficient because in processing the second query of the <span class="KeyTerm1">and</span> we must scan the data base for each frame produced by the first query. If the data base has <i>N</i> elements, and a typical query produces a number of output frames proportional to <i>N</i> (say <i>N</i>/<i>k</i>), then scanning the data base for each frame produced by the first query will require <i>N</i><sup>2</sup>/<i>k</i> calls to the pattern matcher. Another approach would be to process the two clauses of the <span class="KeyTerm1">and</span> separately, then look for all pairs of output frames that are compatible. If each query produces <i>N</i>/<i>k</i> output frames, then this means that we must perform <i>N</i><sup>2</sup>/<i>k</i><sup>2</sup> compatibility checks—a factor of <i>k</i> fewer than the number of matches required in our current method.</p>
<p><a id="c004_c4-para-2838"></a>Devise an implementation of <span class="KeyTerm1">and</span> that uses this strategy. You must implement a function that takes two frames as inputs, checks whether the bindings in the frames are compatible, and, if so, produces a frame that merges the two sets of bindings. This operation is similar to unification.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0168"></a><a id="c004_c4-title-0169"></a>Exercise 4.74</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2839"></a>In section 4.4.3 we saw that <span class="KeyTerm1">not</span> and <span class="KeyTerm1">javascript_predicate</span> can cause the query language to give “wrong” answers if these filtering operations are applied to frames in which variables are unbound. Devise a way to fix this shortcoming. One idea is to perform the filtering in a “delayed” manner by appending to the frame a “promise” to filter that is fulfilled only when enough variables have been bound to make the operation possible. We could wait to perform filtering until all other operations have been performed. However, for efficiency's sake, we would like to perform filtering as soon as possible so as to cut down on the number of intermediate frames generated.</p>
</section>
<section>
<h5><a id="c004_c4-sec-0169"></a><a id="c004_c4-title-0170"></a>Exercise 4.75</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2840"></a>Redesign the query language as a nondeterministic program to be implemented using the evaluator of section 4.3, rather than as a stream process. In this approach, each query will produce a single answer (rather than the stream of all answers) and the user can type <span class="KeyTerm1">retry</span> to see more answers. You should find that much of the mechanism we built in this section is subsumed by nondeterministic search and backtracking. You will probably also find, however, that your new query language has subtle differences in behavior from the one implemented here. Can you find examples that illustrate this difference?</p>
</section>
<section>
<h5><a id="c004_c4-sec-0170"></a><a id="c004_c4-title-0171"></a>Exercise 4.76</h5>
<p class="paraaftertitle"><a id="c004_c4-para-2841"></a>When we implemented the JavaScript evaluator in section 4.1, we saw how to use local environments to avoid name conflicts between the parameters of functions. For example, in evaluating</p>
<p class="Sp-text-1"><a id="c004_c4-para-2842"></a><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2843"></a> <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c004_c4-para-2844"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2845"></a><b>function</b> sum_of_squares(x, y) {</p>
<p class="Sp-text-1"><a id="c004_c4-para-2846"></a> <b>return</b> square(x) + square(y);</p>
<p class="Sp-text-1"><a id="c004_c4-para-2847"></a>}</p>
<p class="Sp-text-1"><a id="c004_c4-para-2848"></a>sum_of_squares(3, 4);</p>
<p class="paracontinue"><a id="c004_c4-para-2849"></a>there is no confusion between the <span class="KeyTerm1">x</span> in <span class="KeyTerm1">square</span> and the <span class="KeyTerm1">x</span> in <span class="KeyTerm1">sum_of_squares</span>, because we evaluate the body of each function in an environment that is specially constructed to contain bindings for the local names. In the query system, we used a different strategy to avoid name conflicts in applying rules. Each time we apply a rule we rename the variables with new names that are guaranteed to be unique. The analogous strategy for the JavaScript evaluator would be to do away with local environments and simply rename the variables in the body of a function each time we apply the function.</p>
<p><a id="c004_c4-para-2850"></a>Implement for the query language a rule-application method that uses environments rather than renaming. See if you can build on your environment structure to create constructs in the query language for dealing with large systems, such as the rule analog of block-structured functions. Can you relate any of this to the problem of making deductions in a context (e.g., “If I supposed that <i>P</i> were true, then I would be able to deduce <i>A</i> and <i>B</i>.”) as a method of problem solving? (This problem is open-ended.)</p>
</section>
</section>
</section>
</section>
<section class="BS_enoteSec">
<aside class="noteEntry"><a id="c004_c4-fn-0001"></a><a href="#c4-fn-0001a">1</a> The same idea is pervasive throughout all of engineering. For example, electrical engineers use many different languages for describing circuits. Two of these are the language of electrical <i>networks</i> and the language of electrical <i>systems</i>. The network language emphasizes the physical modeling of devices in terms of discrete electrical elements. The primitive objects of the network language are primitive electrical components such as resistors, capacitors, inductors, and transistors, which are characterized in terms of physical variables called voltage and current. When describing circuits in the network language, the engineer is concerned with the physical characteristics of a design. In contrast, the primitive objects of the system language are signal-processing modules such as filters and amplifiers. Only the functional behavior of the modules is relevant, and signals are manipulated without concern for their physical realization as voltages and currents. The system language is erected on the network language, in the sense that the elements of signal-processing systems are constructed from electrical networks. Here, however, the concerns are with the large-scale organization of electrical devices to solve a given application problem; the physical feasibility of the parts is assumed. This layered collection of languages is another example of the stratified design technique illustrated by the picture language of section 2.2.4.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0002"></a><a href="#c4-fn-0002a">2</a> The most important features that our evaluator leaves out are mechanisms for handling errors and supporting debugging. For a more extensive discussion of evaluators, see Friedman, Wand, and Haynes 1992, which gives an exposition of programming languages that proceeds via a sequence of evaluators written in the Scheme dialect of Lisp.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0003"></a><a href="#c4-fn-0003a">3</a> Even so, there will remain important aspects of the evaluation process that are not elucidated by our evaluator. The most important of these are the detailed mechanisms by which functions call other functions and return values to their callers. We will address these issues in chapter 5, where we take a closer look at the evaluation process by implementing the evaluator as a simple register machine.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0004"></a><a href="#c4-fn-0004a">4</a> If we grant ourselves the ability to apply primitives, then what remains for us to implement in the evaluator? The job of the evaluator is not to specify the primitives of the language, but rather to provide the connective tissue—the means of combination and the means of abstraction—that binds a collection of primitives to form a language. Specifically:<ul style="list-style-type:disc">
<li>The evaluator enables us to deal with nested expressions. For example, although simply applying primitives would suffice for evaluating the expression <span class="KeyTerm1">2 * 6</span>, it is not adequate for handling <span class="KeyTerm1">2 * (1 + 5)</span>. As far as the operator <span class="KeyTerm1">*</span> is concerned, its arguments must be numbers, and it would choke if we passed it the expression <span class="KeyTerm1">1 + 5</span> as an argument. One important role of the evaluator is to choreograph composition so that <span class="KeyTerm1">1 + 5</span> is reduced to 6 before being passed as an argument to <span class="KeyTerm1">*</span>.</li>
<li>The evaluator allows us to use names. For example, the addition operator has no way to deal with expressions such as <span class="KeyTerm1">x + 1</span>. We need an evaluator to keep track of names and obtain their values before invoking the operators.</li>
<li>The evaluator allows us to define compound functions. This involves knowing how to use these functions in evaluating expressions and providing a mechanism that enables functions to accept arguments.</li>
<li>The evaluator provides the other syntactic forms of the language such as conditionals and blocks.</li>
</ul></aside>
<aside class="noteEntry"><a id="c004_c4-fn-0005"></a><a href="#c4-fn-0005a">5</a> There is no need to distinguish between statements and expressions in our evaluator. For example, we do not differentiate between expressions and expression statements; we represent them identically and consequently they are handled in the same way by the <span class="KeyTerm1">evaluate</span> function. Similarly, our evaluator does not enforce JavaScript's syntactic restriction that statements cannot appear inside expressions other than lambda expressions.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0006"></a><a href="#c4-fn-0006a">6</a> This test is a deferred operation, and thus our evaluator will give rise to a recursive process even if the interpreted program should give rise to an iterative process according to the description in section 1.2.1. In other words, our metacircular evaluator implementation of JavaScript is not tail-recursive. Sections 5.4.2 and 5.5.3 show how to achieve tail recursion using a register machine.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0007"></a><a href="#c4-fn-0007a">7</a> We chose to implement <span class="KeyTerm1">list_of_values</span> using the higher-order function <span class="KeyTerm1">map</span>, and we will use <span class="KeyTerm1">map</span> in other places as well. However, the evaluator can be implemented without any use of higher-order functions (and thus could be written in a language that doesn't have higher-order functions), even though the language that it supports will include higher-order functions. For example, <span class="KeyTerm1">list_of_values</span> can be written without <span class="KeyTerm1">map</span> as follows:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> list_of_values(exps, env) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> is_null(exps)</span>
<br/><span class="BS_Sp-text-1_FN">           ? <b>null</b></span>
<br/><span class="BS_Sp-text-1_FN">           : pair(evaluate(head(exps), env),</span>
<br/><span class="BS_Sp-text-1_FN">                  list_of_values(tail(exps), env));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0008"></a><a href="#c4-fn-0008a">8</a> In this case, the language being implemented and the implementation language are the same. Contemplation of the meaning of <span class="KeyTerm1">is_truthy</span> here yields expansion of consciousness without the abuse of substance.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0009"></a><a href="#c4-fn-0009a">9</a> The treatment of return statements in <span class="KeyTerm1">eval_sequence</span> reflects the proper result of evaluating function applications in JavaScript, but the evaluator presented here does not comply with the ECMAScript specification for the value of a program that consists of a sequence of statements <i>outside of</i> any function body. Exercise 4.8 addresses this issue.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0010"></a><a href="#c4-fn-0010a">10</a> The application of the function <span class="KeyTerm1">make_return_value</span> to the result of evaluating the return expression creates a deferred operation, in addition to the deferred operation created by <span class="KeyTerm1">apply</span>. See footnote 6 for details.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0011"></a><a href="#c4-fn-0011a">11</a> These selectors for a list of statements are not intended as a data abstraction. They are introduced as mnemonic names for the basic list operations in order to make it easier to understand the explicit-control evaluator in section 5.4.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0012"></a><a href="#c4-fn-0012a">12</a> A parser implementation may decide to represent a block by just its statement sequence if none of the statements of the sequence are declarations, or to represent a sequence with only one statement by just that statement. The language processors in this chapter and in chapter 5 do not depend on these decisions.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0013"></a><a href="#c4-fn-0013a">13</a> In actual JavaScript, there are subtle differences between the two forms; see footnote 54 in chapter 1. Exercise 4.17 addresses these differences.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0014"></a><a href="#c4-fn-0014a">14</a> Conditionals in full JavaScript accept <i>any</i> value, not just a boolean, as the result of evaluating the “predicate” expression. JavaScript's notion of truthiness and falsiness is captured by the following variants of <span class="KeyTerm1">is_truthy</span> and <span class="KeyTerm1">is_falsy</span>:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> is_truthy(x) { <b>return</b> ! is_falsy(x); }</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> is_falsy(x) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> (is_boolean(x) &amp;&amp; !x )                   ||</span>
<br/><span class="BS_Sp-text-1_FN">            (is_number(x) &amp;&amp; (x === 0 || x !== x )) ||</span>
<br/><span class="BS_Sp-text-1_FN">            (is_string(x) &amp;&amp; x === "")              ||</span>
<br/><span class="BS_Sp-text-1_FN">            is_null(x)                              ||</span>
<br/><span class="BS_Sp-text-1_FN">            is_undefined(x);</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>The test <span class="KeyTerm1">x !== x</span> is not a typo; the only JavaScript value for which <span class="KeyTerm1">x !== x</span> yields true is the value <span class="KeyTerm1">NaN</span> (“Not a Number”), which is considered to be a falsy number (also not a typo), along with 0. The numerical value <span class="KeyTerm1">NaN</span> is the result of certain arithmetic border cases such as <span class="KeyTerm1">0 / 0</span>.<br/>  The terms “truthy” and “falsy” were coined by Douglas Crockford, one of whose books (Crockford 2008) inspired this JavaScript adaptation.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0015"></a><a href="#c4-fn-0015a">15</a> Frames are not really a data abstraction: The function <span class="KeyTerm1">assign_symbol_value</span> below uses <span class="KeyTerm1">set_head</span> to directly modify the values in a frame. The purpose of the frame functions is to make the environment-manipulation functions easy to read.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0016"></a><a href="#c4-fn-0016a">16</a> The drawback of this representation (as well as the variant in exercise 4.9) is that the evaluator may have to search through many frames in order to find the binding for a given variable. (Such an approach is referred to as <i>deep binding</i>.) One way to avoid this inefficiency is to make use of a strategy called <i>lexical addressing</i>, which will be discussed in section 5.5.6.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0017"></a><a href="#c4-fn-0017a">17</a> Any function defined in the underlying JavaScript can be used as a primitive for the metacircular evaluator. The name of a primitive installed in the evaluator need not be the same as the name of its implementation in the underlying JavaScript; the names are the same here because the metacircular evaluator implements JavaScript itself. Thus, for example, we could put <span class="KeyTerm1">list("first", head)</span> or <span class="KeyTerm1">list("square", x =&gt; x * x)</span> in the list of <span class="KeyTerm1">primitive_functions</span>.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0018"></a><a href="#c4-fn-0018a">18</a> JavaScript's <span class="KeyTerm1">apply</span> method expects the function arguments in a <i>vector</i>. (Vectors are called “arrays” in JavaScript.) Thus, the <span class="KeyTerm1">arglist</span> is transformed into a vector—here using a while loop (see exercise 4.7):
<br/><span class="BS_Sp-text-1_FN"><b>function</b> apply_in_underlying_javascript(prim, arglist) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>const</b> arg_vector = []; <span class="KeyTerm2"><i>// empty vector</i></span></span>
<br/><span class="BS_Sp-text-1_FN"> <b>let</b> i = 0;</span>
<br/><span class="BS_Sp-text-1_FN"> <b>while</b> (!is_null(arglist)) {</span>
<br/><span class="BS_Sp-text-1_FN">        arg_vector[i] = head(arglist); <span class="KeyTerm2"><i>// store value at index</i></span> i</span>
<br/><span class="BS_Sp-text-1_FN">         i = i + 1;</span>
<br/><span class="BS_Sp-text-1_FN">        arglist = tail(arglist);</span>
<br/><span class="BS_Sp-text-1_FN">    }</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> prim.apply(prim, arg_vector); <i>//</i> apply <i>is accessed via</i> prim</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>We also made use of <span class="KeyTerm1">apply_in_underlying_javascript</span> to declare the function <span class="KeyTerm1">apply_ generic</span> in section 2.4.3.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0019"></a><a href="#c4-fn-0019a">19</a> The fact that the machines are described in JavaScript is inessential. If we give our evaluator a JavaScript program that behaves as an evaluator for some other language, say C, the JavaScript evaluator will emulate the C evaluator, which in turn can emulate any machine described as a C program. Similarly, writing a JavaScript evaluator in C produces a C program that can execute any JavaScript program. The deep idea here is that any evaluator can emulate any other. Thus, the notion of “what can in principle be computed” (ignoring practicalities of time and memory required) is independent of the language or the computer, and instead reflects an underlying notion of <i>computability</i>. This was first demonstrated in a clear way by Alan M. Turing (1912–1954), whose 1936 paper laid the foundations for theoretical computer science. In the paper, Turing presented a simple computational model—now known as a <i>Turing machine</i>—and argued that any “effective process” can be formulated as a program for such a machine. (This argument is known as the <i>Church–Turing thesis</i>.) Turing then implemented a universal machine, i.e., a Turing machine that behaves as an evaluator for Turing-machine programs. He used this framework to demonstrate that there are well-posed problems that cannot be computed by Turing machines (see exercise 4.15), and so by implication cannot be formulated as “effective processes.” Turing went on to make fundamental contributions to practical computer science as well. For example, he invented the idea of structuring programs using general-purpose subroutines. See Hodges 1983 for a biography of Turing.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0020"></a><a href="#c4-fn-0020a">20</a> Some people find it counterintuitive that an evaluator, which is implemented by a relatively simple function, can emulate programs that are more complex than the evaluator itself. The existence of a universal evaluator machine is a deep and wonderful property of computation. <i>Recursion theory</i>, a branch of mathematical logic, is concerned with logical limits of computation. Douglas Hofstadter's beautiful book <i>Gödel, Escher, Bach</i> (1979) explores some of these ideas.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0021"></a><a href="#c4-fn-0021a">21</a> Note that <span class="KeyTerm1">eval</span> may not be available in the JavaScript environment that you are using, or its use may be restricted for security reasons.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0022"></a><a href="#c4-fn-0022a">22</a> Although we stipulated that <span class="KeyTerm1">halts</span> is given a function object, notice that this reasoning still applies even if <span class="KeyTerm1">halts</span> can gain access to the function's text and its environment. This is Turing's celebrated <i>Halting Theorem</i>, which gave the first clear example of a <i>noncomputable</i> problem, i.e., a well-posed task that cannot be carried out as a computational function.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0023"></a><a href="#c4-fn-0023a">23</a> This example illustrates a programming trick for formulating recursive functions without using assignment. The most general trick of this sort is the <i>Y operator</i>, which can be used to give a “pure <i>λ</i>-calculus” implementation of recursion. (See Stoy 1977 for details on the lambda calculus, and Gabriel 1988 for an exposition of the <i>Y</i> operator in the language Scheme.)</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0024"></a><a href="#c4-fn-0024a">24</a> The designers of JavaScript support Alyssa on the following grounds: Eva is in principle correct—the declarations should be regarded as simultaneous. But it seems difficult to implement a general, efficient mechanism that does what Eva requires. In the absence of such a mechanism, it is better to generate an error in the difficult cases of simultaneous declarations (Alyssa's notion) than to produce an incorrect answer (as Ben would have it).</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0025"></a><a href="#c4-fn-0025a">25</a> This technique is an integral part of the compilation process, which we shall discuss in chapter 5. Jonathan Rees wrote a Scheme interpreter like this in about 1982 for the T project (Rees and Adams 1982). Marc Feeley 1986 (see also Feeley and Lapalme 1987) independently invented this technique in his master's thesis.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0026"></a><a href="#c4-fn-0026a">26</a> There is, however, an important part of the search for a name that <i>can</i> be done as part of the syntactic analysis. As we will show in section 5.5.6, one can determine the position in the environment structure where the value of the variable will be found, thus obviating the need to scan the environment for the entry that matches the variable.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0027"></a><a href="#c4-fn-0027a">27</a> See exercise 4.21 for some insight into the processing of sequences.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0028"></a><a href="#c4-fn-0028a">28</a> Snarf: “To grab, especially a large document or file for the purpose of using it either with or without the owner's permission.” Snarf down: “To snarf, sometimes with the connotation of absorbing, processing, or understanding.” (These definitions were snarfed from Steele et al. 1983. See also Raymond 1996.)</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0029"></a><a href="#c4-fn-0029a">29</a> The difference between the “lazy” terminology and the “normal-order” terminology is somewhat fuzzy. Generally, “lazy” refers to the mechanisms of particular evaluators, while “normal-order” refers to the semantics of languages, independent of any particular evaluation strategy. But this is not a hard-and-fast distinction, and the two terminologies are often used interchangeably.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0030"></a><a href="#c4-fn-0030a">30</a> The “strict” versus “non-strict” terminology means essentially the same as “applicativeorder” versus “normal-order,” except that it refers to individual functions and arguments rather than to the language as a whole. At a conference on programming languages you might hear someone say, “The normal-order language Hassle has certain strict primitives. Other functions take their arguments by lazy evaluation.”</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0031"></a><a href="#c4-fn-0031a">31</a> The word <i>thunk</i> was invented by an informal working group that was discussing the implementation of call-by-name in Algol 60. They observed that most of the analysis of (“thinking about”) the expression could be done at compile time; thus, at run time, the expression would already have been “thunk” about (Ingerman et al. 1960).</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0032"></a><a href="#c4-fn-0032a">32</a> This is analogous to the forcing of the delayed objects that were introduced in chapter 3 to represent streams. The critical difference between what we are doing here and what we did in chapter 3 is that we are building delaying and forcing into the evaluator, and thus making this uniform and automatic throughout the language.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0033"></a><a href="#c4-fn-0033a">33</a> Lazy evaluation combined with memoization is sometimes referred to as <i>call-by-need</i> argument passing, in contrast to <i>call-by-name</i> argument passing. (Call-by-name, introduced in Algol 60, is similar to non-memoized lazy evaluation.) As language designers, we can build our evaluator to memoize, not to memoize, or leave this an option for programmers (exercise 4.29). As you might expect from chapter 3, these choices raise issues that become both subtle and confusing in the presence of assignments. (See exercises 4.25 and 4.27.) An excellent article by Clinger (1982) attempts to clarify the multiple dimensions of confusion that arise here.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0034"></a><a href="#c4-fn-0034a">34</a> Notice that we also erase the <span class="KeyTerm1">env</span> from the thunk once the expression's value has been computed. This makes no difference in the values returned by the interpreter. It does help save space, however, because removing the reference from the thunk to the <span class="KeyTerm1">env</span> once it is no longer needed allows this structure to be <i>garbage-collected</i> and its space recycled, as we will discuss in section 5.3.<br/>  Similarly, we could have allowed unneeded environments in the memoized delayed objects of section 3.5.1 to be garbage-collected, by having <span class="KeyTerm1">memo</span> do something like <span class="KeyTerm1">fun = <b>null</b>;</span> to discard the function <span class="KeyTerm1">fun</span> (which includes the environment in which the lambda expression that makes up the tail of the stream was evaluated) after storing its value.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0035"></a><a href="#c4-fn-0035a">35</a> This exercise demonstrates that the interaction between lazy evaluation and side effects can be very confusing. This is just what you might expect from the discussion in chapter 3.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0036"></a><a href="#c4-fn-0036a">36</a> This is the functional representation described in exercise 2.4. Essentially any functional representation (e.g., a message-passing implementation) would do as well. Notice that we can install these definitions in the lazy evaluator simply by typing them at the driver loop. If we had originally included <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> as primitives in the global environment, they will be redefined. (Also see exercises 4.31 and 4.32.)</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0037"></a><a href="#c4-fn-0037a">37</a> This permits us to create delayed versions of more general kinds of list structures, not just sequences. Hughes 1990 discusses some applications of “lazy trees.”</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0038"></a><a href="#c4-fn-0038a">38</a> We assume that we have previously defined a function <span class="KeyTerm1">is_prime</span> that tests whether numbers are prime. Even with <span class="KeyTerm1">is_prime</span> defined, the <span class="KeyTerm1">prime_sum_pair</span> function may look suspiciously like the unhelpful “pseudo-JavaScript” attempt to define the square-root function, which we described at the beginning of section 1.1.7. In fact, a square-root function along those lines can actually be formulated as a nondeterministic program. By incorporating a search mechanism into the evaluator, we are eroding the distinction between purely declarative descriptions and imperative specifications of how to compute answers. We'll go even farther in this direction in section 4.4.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0039"></a><a href="#c4-fn-0039a">39</a> The idea of <span class="KeyTerm1">amb</span> for nondeterministic programming was first described in 1961 by John McCarthy (see McCarthy 1967).</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0040"></a><a href="#c4-fn-0040a">40</a> In actuality, the distinction between nondeterministically returning a single choice and returning all choices depends somewhat on our point of view. From the perspective of the code that uses the value, the nondeterministic choice returns a single value. From the perspective of the programmer designing the code, the nondeterministic choice potentially returns all possible values, and the computation branches so that each value is investigated separately.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0041"></a><a href="#c4-fn-0041a">41</a> One might object that this is a hopelessly inefficient mechanism. It might require millions of processors to solve some easily stated problem this way, and most of the time most of those processors would be idle. This objection should be taken in the context of history. Memory used to be considered just such an expensive commodity. In 1965 a megabyte of RAM cost about $400,000. Now every personal computer has many gigabytes of RAM, and most of the time most of that RAM is unused. It is hard to underestimate the cost of mass-produced electronics.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0042"></a><a href="#c4-fn-0042a">42</a> Automagically: “Automatically, but in a way which, for some reason (typically because it is too complicated, or too ugly, or perhaps even too trivial), the speaker doesn't feel like explaining.” (Steele 1983, Raymond 1996)</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0043"></a><a href="#c4-fn-0043a">43</a> The integration of automatic search strategies into programming languages has had a long and checkered history. The first suggestions that nondeterministic algorithms might be elegantly encoded in a programming language with search and automatic backtracking came from Robert Floyd (1967). Carl Hewitt (1969) invented a programming language called Planner that explicitly supported automatic chronological backtracking, providing for a built-in depthfirst search strategy. Sussman, Winograd, and Charniak (1971) implemented a subset of this language, called MicroPlanner, which was used to support work in problem solving and robot planning. Similar ideas, arising from logic and theorem proving, led to the genesis in Edinburgh and Marseille of the elegant language Prolog (which we will discuss in section 4.4). After sufficient frustration with automatic search, McDermott and Sussman (1972) developed a language called Conniver, which included mechanisms for placing the search strategy under programmer control. This proved unwieldy, however, and Sussman and Stallman (1975) found a more tractable approach while investigating methods of symbolic analysis for electrical circuits. They developed a nonchronological backtracking scheme that was based on tracing out the logical dependencies connecting facts, a technique that has come to be known as <i>dependencydirected backtracking</i>. Although their method was complex, it produced reasonably efficient programs because it did little redundant search. Doyle (1979) and McAllester (1978, 1980) generalized and clarified the methods of Stallman and Sussman, developing a new paradigm for formulating search that is now called <i>truth maintenance</i>. Many problem-solving systems use some form of truth-maintenance system as a substrate. See Forbus and de Kleer 1993 for a discussion of elegant ways to build truth-maintenance systems and applications using truth maintenance. Zabih, McAllester, and Chapman 1987 describes a nondeterministic extension to Scheme that is based on <span class="KeyTerm1">amb</span>; it is similar to the interpreter described in this section, but more sophisticated, because it uses dependency-directed backtracking rather than chronological backtracking. Winston 1992 gives an introduction to both kinds of backtracking.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0044"></a><a href="#c4-fn-0044a">44</a> Our program uses the following function to determine if the elements of a list are distinct:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> distinct(items) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> is_null(items)</span>
<br/><span class="BS_Sp-text-1_FN">           ? <b>true</b></span>
<br/><span class="BS_Sp-text-1_FN">           : is_null(tail(items))</span>
<br/><span class="BS_Sp-text-1_FN">           ? <b>true</b></span>
<br/><span class="BS_Sp-text-1_FN">           : is_null(member(head(items), tail(items)))</span>
<br/><span class="BS_Sp-text-1_FN">           ? distinct(tail(items))</span>
<br/><span class="BS_Sp-text-1_FN">           : <b>false</b>;</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0045"></a><a href="#c4-fn-0045a">45</a> Here we use the convention that the first element of each list designates the part of speech for the rest of the words in the list.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0046"></a><a href="#c4-fn-0046a">46</a> Notice that <span class="KeyTerm1">parse_word</span> uses assignment to modify the not-yet-parsed input list. For this to work, our <span class="KeyTerm1">amb</span> evaluator must undo the effects of assignments when it backtracks.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0047"></a><a href="#c4-fn-0047a">47</a> Observe that this definition is recursive—a verb may be followed by any number of prepositional phrases.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0048"></a><a href="#c4-fn-0048a">48</a> This kind of grammar can become arbitrarily complex, but it is only a toy as far as real language understanding is concerned. Real natural-language understanding by computer requires an elaborate mixture of syntactic analysis and interpretation of meaning. On the other hand, even toy parsers can be useful in supporting flexible command languages for programs such as information-retrieval systems. Winston 1992 discusses computational approaches to real language understanding and also the applications of simple grammars to command languages.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0049"></a><a href="#c4-fn-0049a">49</a> Although Alyssa's idea works just fine (and is surprisingly simple), the sentences that it generates are a bit boring—they don't sample the possible sentences of this language in a very interesting way. In fact, the grammar is highly recursive in many places, and Alyssa's technique “falls into” one of these recursions and gets stuck. See exercise 4.48 for a way to deal with this.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0050"></a><a href="#c4-fn-0050a">50</a> We chose to implement the lazy evaluator in section 4.2 as a modification of the ordinary metacircular evaluator of section 4.1.1. In contrast, we will base the <span class="KeyTerm1">amb</span> evaluator on the analyzing evaluator of section 4.1.7, because the execution functions in that evaluator provide a convenient framework for implementing backtracking.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0051"></a><a href="#c4-fn-0051a">51</a> With this treatment, <span class="KeyTerm1">amb</span> is no longer a name with proper scoping. To avoid confusion, we must refrain from declaring <span class="KeyTerm1">amb</span> as a name in our nondeterministic programs.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0052"></a><a href="#c4-fn-0052a">52</a> We didn't worry about undoing declarations, since we assume that a name can't be used prior to the evaluation of its declaration, so its previous value doesn't matter.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0053"></a><a href="#c4-fn-0053a">53</a> Logic programming has grown out of a long history of research in automatic theorem proving. Early theorem-proving programs could accomplish very little, because they exhaustively searched the space of possible proofs. The major breakthrough that made such a search plausible was the discovery in the early 1960s of the <i>unification algorithm</i> and the <i>resolution principle</i> (Robinson 1965). Resolution was used, for example, by Green and Raphael (1968) (see also Green 1969) as the basis for a deductive question-answering system. During most of this period, researchers concentrated on algorithms that are guaranteed to find a proof if one exists. Such algorithms were difficult to control and to direct toward a proof. Hewitt (1969) recognized the possibility of merging the control structure of a programming language with the operations of a logic-manipulation system, leading to the work in automatic search mentioned in section 4.3.1 (footnote 43). At the same time that this was being done, Colmerauer, in Marseille, was developing rule-based systems for manipulating natural language (see Colmerauer et al. 1973). He invented a programming language called Prolog for representing those rules. Kowalski (1973; 1979) in Edinburgh, recognized that execution of a Prolog program could be interpreted as proving theorems (using a proof technique called linear Horn-clause resolution). The merging of the last two strands led to the logic-programming movement. Thus, in assigning credit for the development of logic programming, the French can point to Prolog's genesis at the University of Marseille, while the British can highlight the work at the University of Edinburgh. According to people at MIT, logic programming was developed by these groups in an attempt to figure out what Hewitt was talking about in his brilliant but impenetrable Ph.D. thesis. For a history of logic programming, see Robinson 1983.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0054"></a><a href="#c4-fn-0054a">54</a> To see the correspondence between the rules and the function, let <span class="KeyTerm1">x</span> in the function (where <span class="KeyTerm1">x</span> is nonempty) correspond to <span class="KeyTerm1">pair(u, v)</span> in the rule. Then <span class="KeyTerm1">z</span> in the rule corresponds to the <span class="KeyTerm1">append</span> of <span class="KeyTerm1">tail(x)</span> and <span class="KeyTerm1">y</span>.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0055"></a><a href="#c4-fn-0055a">55</a> This certainly does not relieve the user of the entire problem of how to compute the answer. There are many different mathematically equivalent sets of rules for formulating the <span class="KeyTerm1">append</span> relation, only some of which can be turned into effective devices for computing in any direction. In addition, sometimes “what is” information gives no clue “how to” compute an answer. For example, consider the problem of computing the <i>y</i> such that <i>y</i><sup>2</sup> = <i>x</i>.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0056"></a><a href="#c4-fn-0056a">56</a> Interest in logic programming peaked during the early 1980s when the Japanese government began an ambitious project aimed at building superfast computers optimized to run logic programming languages. The speed of such computers was to be measured in LIPS (Logical Inferences Per Second) rather than the usual FLOPS (FLoating-point Operations Per Second). Although the project succeeded in developing hardware and software as originally planned, the international computer industry moved in a different direction. See Feigenbaum and Shrobe 1993 for an overview evaluation of the Japanese project. The logic programming community has also moved on to consider relational programming based on techniques other than simple pattern matching, such as the ability to deal with numerical constraints such as the ones illustrated in the constraint-propagation system of section 3.3.5.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0057"></a><a href="#c4-fn-0057a">57</a> Actually, this description of <span class="KeyTerm1">not</span> is valid only for simple cases. The real behavior of <span class="KeyTerm1">not</span> is more complex. We will examine <span class="KeyTerm1">not</span>'s peculiarities in sections 4.4.2 and 4.4.3.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0058"></a><a href="#c4-fn-0058a">58</a> A query should use <span class="KeyTerm1">javascript_predicate</span> only to perform an operation not provided in the query language. In particular, <span class="KeyTerm1">javascript_predicate</span> should not be used to test equality (since that is what the matching in the query language is designed to do) or inequality (since that can be done with the <span class="KeyTerm1">same</span> rule shown below).</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0059"></a><a href="#c4-fn-0059a">59</a> Notice that we do not need <span class="KeyTerm1">same</span> in order to make two things be the same: We just use the same pattern variable for each—in effect, we have one thing instead of two things in the first place. For example, see <span class="KeyTerm1">$town</span> in the <span class="KeyTerm1">lives_near</span> rule and <span class="KeyTerm1">$middle_manager</span> in the <span class="KeyTerm1">wheel</span> rule below. The <span class="KeyTerm1">same</span> relation is useful when we want to force two things to be different, such as <span class="KeyTerm1">$person_1</span> and <span class="KeyTerm1">$person_2</span> in the <span class="KeyTerm1">lives_near</span> rule. Although using the same pattern variable in two parts of a query forces the same value to appear in both places, using different pattern variables does not force different values to appear. (The values assigned to different pattern variables may be the same or different.)</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0060"></a><a href="#c4-fn-0060a">60</a> We will also allow rules without bodies, as in <span class="KeyTerm1">same</span>, and we will interpret such a rule to mean that the rule conclusion is satisfied by any values of the variables.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0061"></a><a href="#c4-fn-0061a">61</a> Because matching is generally very expensive, we would like to avoid applying the full matcher to every element of the data base. This is usually arranged by breaking up the process into a fast, coarse match and the final match. The coarse match filters the data base to produce a small set of candidates for the final match. With care, we can arrange our data base so that some of the work of coarse matching can be done when the data base is constructed rather then when we want to select the candidates. This is called <i>indexing</i> the data base. There is a vast technology built around data-base-indexing schemes. Our implementation, described in section 4.4.4, contains a simpleminded form of such an optimization.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0062"></a><a href="#c4-fn-0062a">62</a> But this kind of exponential explosion is not common in <span class="KeyTerm1">and</span> queries because the added conditions tend to reduce rather than expand the number of frames produced.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0063"></a><a href="#c4-fn-0063a">63</a> There is a large literature on data-base-management systems that is concerned with how to handle complex queries efficiently.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0064"></a><a href="#c4-fn-0064a">64</a> There is a subtle difference between this filter implementation of <span class="KeyTerm1">not</span> and the usual meaning of <span class="KeyTerm1">not</span> in mathematical logic. See section 4.4.3.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0065"></a><a href="#c4-fn-0065a">65</a> In one-sided pattern matching, all the equations that contain pattern variables are explicit and already solved for the unknown (the pattern variable).</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0066"></a><a href="#c4-fn-0066a">66</a> Another way to think of unification is that it generates the most general pattern that is a specialization of the two input patterns. This means that the unification of <span class="KeyTerm1">list($x, "a")</span> and <span class="KeyTerm1">list(list("b", $y), $z)</span> is <span class="KeyTerm1">list(list("b", $y), "a")</span> and that the unification of <span class="KeyTerm1">list($x, "a", $y)</span> and <span class="KeyTerm1">list($y, $z, "a")</span>, discussed above, is <span class="KeyTerm1">list("a", "a", "a")</span>. For our implementation, it is more convenient to think of the result of unification as a frame rather than a pattern.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0067"></a><a href="#c4-fn-0067a">67</a> Since unification is a generalization of matching, we could simplify the system by using the unifier to produce both streams. Treating the easy case with the simple matcher, however, illustrates how matching (as opposed to full-blown unification) can be useful in its own right.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0068"></a><a href="#c4-fn-0068a">68</a> The reason we use streams (rather than lists) of frames is that the recursive application of rules can generate infinite numbers of values that satisfy a query. The delayed evaluation embodied in streams is crucial here: The system will print responses one by one as they are generated, regardless of whether there are a finite or infinite number of responses.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0069"></a><a href="#c4-fn-0069a">69</a> That a particular method of inference is legitimate is not a trivial assertion. One must prove that if one starts with true premises, only true conclusions can be derived. The method of inference represented by rule applications is <i>modus ponens</i>, the familiar method of inference that says that if <i>A</i> is true and <i>A implies B</i> is true, then we may conclude that <i>B</i> is true.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0070"></a><a href="#c4-fn-0070a">70</a> We must qualify this statement by agreeing that, in speaking of the “inference” accomplished by a logic program, we assume that the computation terminates. Unfortunately, even this qualified statement is false for our implementation of the query language (and also false for programs in Prolog and most other current logic programming languages) because of our use of <span class="KeyTerm1">not</span> and <span class="KeyTerm1">javascript_predicate</span>. As we will describe below, the <span class="KeyTerm1">not</span> implemented in the query language is not always consistent with the <span class="KeyTerm1">not</span> of mathematical logic, and <span class="KeyTerm1">javascript_predicate</span> introduces additional complications. We could implement a language consistent with mathematical logic by simply removing <span class="KeyTerm1">not</span> and <span class="KeyTerm1">javascript_predicate</span> from the language and agreeing to write programs using only simple queries, <span class="KeyTerm1">and</span>, and <span class="KeyTerm1">or</span>. However, this would greatly restrict the expressive power of the language. One of the major concerns of research in logic programming was to find ways to achieve more consistency with mathematical logic without unduly sacrificing expressive power.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0071"></a><a href="#c4-fn-0071a">71</a> This is not a problem of the logic but one of the procedural interpretation of the logic provided by our interpreter. We could write an interpreter that would not fall into a loop here. For example, we could enumerate all the proofs derivable from our assertions and our rules in a breadth-first rather than a depth-first order. However, such a system makes it more difficult to take advantage of the order of deductions in our programs. One attempt to build sophisticated control into such a program is described in de Kleer et al. 1977. Another technique, which does not lead to such serious control problems, is to put in special knowledge, such as detectors for particular kinds of loops (exercise 4.65). However, there can be no general scheme for reliably preventing a system from going down infinite paths in performing deductions. Imagine a diabolical rule of the form “To show <i>P</i>(<i>x</i>) is true, show that <i>P</i>(<i>f</i> (<i>x</i>)) is true,” for some suitably chosen function <i>f</i> .</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0072"></a><a href="#c4-fn-0072a">72</a> Consider the query <span class="KeyTerm1">not(baseball_fan(list("Bitdiddle", "Ben")))</span>. The system finds that <span class="KeyTerm1">baseball_fan(list("Bitdiddle", "Ben"))</span> is not in the data base, so the empty frame does not satisfy the pattern and is not filtered out of the initial stream of frames. The result of the query is thus the empty frame, which is used to instantiate the input query to produce <span class="KeyTerm1">not(baseball_fan(list("Bitdiddle", "Ben")))</span>.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0073"></a><a href="#c4-fn-0073a">73</a> A discussion and justification of this treatment of <span class="KeyTerm1">not</span> can be found in the article “Negation as Failure” by Clark (1978).</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0074"></a><a href="#c4-fn-0074a">74</a> In general, unifying <span class="KeyTerm1">$y</span> with an expression involving <span class="KeyTerm1">$y</span> would require our being able to find a fixed point of the equation <span class="KeyTerm1">$y</span> = <i>expression involving</i> <span class="KeyTerm1">$y</span> . It is sometimes possible to syntactically form an expression that appears to be the solution. For example, <span class="KeyTerm1">$y</span> = <span class="KeyTerm1">list("f", $y)</span> seems to have the fixed point <span class="KeyTerm1">list("f", list("f", list("f",</span> . . . <span class="KeyTerm1">)))</span>, which we can produce by beginning with the expression <span class="KeyTerm1">list("f", $y)</span> and repeatedly substituting <span class="KeyTerm1">list("f", $y)</span> for <span class="KeyTerm1">$y</span>. Unfortunately, not every such equation has a meaningful fixed point. The issues that arise here are similar to the issues of manipulating infinite series in mathematics. For example, we know that 2 is the solution to the equation <i>y</i> = 1 + <i>y</i>/2. Beginning with the expression 1 + <i>y</i>/2 and repeatedly substituting 1 + <i>y</i>/2 for <i>y</i> gives
<br/>  2 = <i>y</i> = 1 + <i>y</i>/2 = 1 + (1 + <i>y</i>/2)/2 = 1 + 1/2 + <i>y</i>/4 = <span class="KeyTerm1"><i>· · ·</i></span> , 
<br/>which leads to
<br/>  2 = 1 + 1/2 + 1/4 + 1/8 + <span class="KeyTerm1"><i>· · ·</i></span> .
<br/>However, if we try the same manipulation beginning with the observation that –1 is the solution to the equation <i>y</i> = 1 + 2<i>y</i>, we obtain
<br/>  –1 = <i>y</i> = 1 + 2<i>y</i> = 1 + 2(1 + 2<i>y</i>) = 1 + 2 + 4<i>y</i> = <span class="KeyTerm1"><i>· · ·</i></span> ,which leads to
<br/>  –1 = 1 + 2 + 4 + 8 + · · · .
<br/>Although the formal manipulations used in deriving these two equations are identical, the first result is a valid assertion about infinite series but the second is not. Similarly, for our unification results, reasoning with an arbitrary syntactically constructed expression may lead to errors.
<br/>  Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using <i>rational trees</i> (Jaffar and Stuckey 1986). Accepting a cyclic data structure allows self-referential data, such as an employee data structure that refers to the employer, which in turn refers to the employee.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0075"></a><a href="#c4-fn-0075a">75</a> The actual way to get the string that contains the first character of a string <span class="KeyTerm1">s</span> in JavaScript is <span class="KeyTerm1">s.charAt(0)</span>.</aside>
<aside class="noteEntry"><a id="c004_c4-fn-0076"></a><a href="#c4-fn-0076a">76</a> Creating new variables with string concatenation and identifying variables by checking their first character during query processing is somewhat wasteful. A more efficient solution would mark pattern variables with a separate tag in the query-language-specific representation and use pair construction rather than string concatenation to create new variables. We chose the less efficient solution to simplify the presentation.</aside>
</section>
</section>
</body><body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<h1><a id="c005_c5-title-0001"></a><span class="chapterNumber">5</span><br/><span class="chapterTitle">Computing with Register Machines</span></h1>
</header>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c005_c5-para-0001"></a>My aim is to show that the heavenly machine is not a kind of divine, live being, but a kind of clockwork (and he who believes that a clock has soul attributes the maker's glory to the work), insofar as nearly all the manifold motions are caused by a most simple and material force, just as all motions of the clock are caused by a single weight.</p>
<p class="quote-epigraphsource">—Johannes Kepler (letter to Herwart von Hohenburg, 1605)</p></blockquote>
<p class="paraaftertitle"><a id="c005_c5-para-0002"></a>We began this book by studying processes and by describing processes in terms of functions written in JavaScript. To explain the meanings of these functions, we used a succession of models of evaluation: the substitution model of chapter 1, the environment model of chapter 3, and the metacircular evaluator of chapter 4. Our examination of the metacircular evaluator, in particular, dispelled much of the mystery of how JavaScript-like languages are interpreted. But even the metacircular evaluator leaves important questions unanswered, because it fails to elucidate the mechanisms of control in a JavaScript system. For instance, the evaluator does not explain how the evaluation of a subexpression manages to return a value to the expression that uses this value. Also, the evaluator does not explain how some recursive functions can generate iterative processes (that is, be evaluated using constant space) whereas other recursive functions will generate recursive processes.<a id="c005_c5-fn-0001a"></a><a href="#c5-fn-0001"><sup>1</sup></a> This chapter addresses both of these issues.</p>
<p><a id="c005_c5-para-0003"></a>We will describe processes in terms of the step-by-step operation of a traditional computer. Such a computer, or <i>register machine</i>, sequentially executes <i>instructions</i> that manipulate the contents of a fixed set of storage elements called <i>registers</i>. A typical register-machine instruction applies a primitive operation to the contents of some registers and assigns the result to another register. Our descriptions of processes executed by register machines will look very much like “machine-language” programs for traditional computers. However, instead of focusing on the machine language of any particular computer, we will examine several JavaScript functions and design a specific register machine to execute each function. Thus, we will approach our task from the perspective of a hardware architect rather than that of a machine-language computer programmer. In designing register machines, we will develop mechanisms for implementing important programming constructs such as recursion. We will also present a language for describing designs for register machines. In section 5.2 we will implement a JavaScript program that uses these descriptions to simulate the machines we design.</p>
<p><a id="c005_c5-para-0004"></a>Most of the primitive operations of our register machines are very simple. For example, an operation might add the numbers fetched from two registers, producing a result to be stored into a third register. Such an operation can be performed by easily described hardware. In order to deal with list structure, however, we will also use the memory operations <span class="KeyTerm1">head</span>, <span class="KeyTerm1">tail</span>, and <span class="KeyTerm1">pair</span>, which require an elaborate storage-allocation mechanism. In section 5.3 we study their implementation in terms of more elementary operations.</p>
<p><a id="c005_c5-para-0005"></a>In section 5.4, after we have accumulated experience formulating simple functions as register machines, we will design a machine that carries out the algorithm described by the metacircular evaluator of section 4.1. This will fill in the gap in our understanding of how JavaScript programs are interpreted, by providing an explicit model for the mechanisms of control in the evaluator. In section 5.5 we will study a simple compiler that translates JavaScript programs into sequences of instructions that can be executed directly with the registers and operations of the evaluator register machine.</p>
<section><a id="c005_c5-title-0002"></a>
<section>
<h2><a id="c005_c5-sec-0002"></a><span>5.1</span> <a id="c005_c5-title-0003"></a>Designing Register Machines</h2>
<p class="paraaftertitle"><a id="c005_c5-para-0006"></a>To design a register machine, we must design its <i>data paths</i> (registers and operations) and the <i>controller</i> that sequences these operations. To illustrate the design of a simple register machine, let us examine Euclid's Algorithm, which is used to compute the greatest common divisor (GCD) of two integers. As we saw in section 1.2.5, Euclid's Algorithm can be carried out by an iterative process, as specified by the following function:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0007"></a><b>function</b> gcd(a, b) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0008"></a> <b>return</b> b === 0 ? a : gcd(b, a % b);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0009"></a>}</p>
<p><a id="c005_c5-para-0010"></a>A machine to carry out this algorithm must keep track of two numbers, <i>a</i> and <i>b</i>, so let us assume that these numbers are stored in two registers with those names. The basic operations required are testing whether the contents of register <span class="KeyTerm1">b</span> is zero and computing the remainder of the contents of register <span class="KeyTerm1">a</span> divided by the contents of register <span class="KeyTerm1">b</span>. The remainder operation is a complex process, but assume for the moment that we have a primitive device that computes remainders. On each cycle of the GCD algorithm, the contents of register <span class="KeyTerm1">a</span> must be replaced by the contents of register <span class="KeyTerm1">b</span>, and the contents of <span class="KeyTerm1">b</span> must be replaced by the remainder of the old contents of <span class="KeyTerm1">a</span> divided by the old contents of <span class="KeyTerm1">b</span>. It would be convenient if these replacements could be done simultaneously, but in our model of register machines we will assume that only one register can be assigned a new value at each step. To accomplish the replacements, our machine will use a third “temporary” register, which we call <span class="KeyTerm1">t</span>. (First the remainder will be placed in <span class="KeyTerm1">t</span>, then the contents of <span class="KeyTerm1">b</span> will be placed in <span class="KeyTerm1">a</span>, and finally the remainder stored in <span class="KeyTerm1">t</span> will be placed in <span class="KeyTerm1">b</span>.)</p>
<p><a id="c005_c5-para-0011"></a>We can illustrate the registers and operations required for this machine by using the data-path diagram shown in <a id="c005_c5-fig-0001a"></a><a href="#c5-fig-0001">figure 5.1</a>. In this diagram, the registers (<span class="KeyTerm1">a</span>, <span class="KeyTerm1">b</span>, and <span class="KeyTerm1">t</span>) are represented by rectangles. Each way to assign a value to a register is indicated by an arrow with a button—drawn as — behind the head, pointing from the source of data to the register. When pushed, the button allows the value at the source to “flow” into the designated register. The label next to each button is the name we will use to refer to the button. The names are arbitrary, and can be chosen to have mnemonic value (for example, <span class="KeyTerm1">a&lt;-b</span> denotes pushing the button that assigns the contents of register <span class="KeyTerm1">b</span> to register <span class="KeyTerm1">a</span>). The source of data for a register can be another register (as in the <span class="KeyTerm1">a&lt;-b</span> assignment), an operation result (as in the <span class="KeyTerm1">t&lt;-r</span> assignment), or a constant (a built-in value that cannot be changed, represented in a data-path diagram by a triangle containing the constant).</p>
<figure id="c005_c5-fig-0001"><img alt="c5-fig-0001.jpg" src="../images/c5-fig-0001.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0001a">Figure 5.1</a></span> <a id="c005_c5-para-0012"></a>Data paths for a GCD machine.</p></figcaption></figure>
<p><a id="c005_c5-para-0013"></a>An operation that computes a value from constants and the contents of registers is represented in a data-path diagram by a trapezoid containing a name for the operation. For example, the box marked <span class="KeyTerm1">rem</span> in <a href="#c5-fig-0001">figure 5.1</a> represents an operation that computes the remainder of the contents of the registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> to which it is attached. Arrows (without buttons) point from the input registers and constants to the box, and arrows connect the operation's output value to registers. A test is represented by a circle containing a name for the test. For example, our GCD machine has an operation that tests whether the contents of register <span class="KeyTerm1">b</span> is zero. A test also has arrows from its input registers and constants, but it has no output arrows; its value is used by the controller rather than by the data paths. Overall, the data-path diagram shows the registers and operations that are required for the machine and how they must be connected. If we view the arrows as wires and the buttons as switches, the datapath diagram is very like the wiring diagram for a machine that could be constructed from electrical components.</p>
<p><a id="c005_c5-para-0014"></a>In order for the data paths to actually compute GCDs, the buttons must be pushed in the correct sequence. We will describe this sequence in terms of a controller diagram, as illustrated in <a id="c005_c5-fig-0002a"></a><a href="#c5-fig-0002">figure 5.2</a>. The elements of the controller diagram indicate how the data-path components should be operated. The rectangular boxes in the controller diagram identify data-path buttons to be pushed, and the arrows describe the sequencing from one step to the next. The diamond in the diagram represents a decision. One of the two sequencing arrows will be followed, depending on the value of the data-path test identified in the diamond. We can interpret the controller in terms of a physical analogy: Think of the diagram as a maze in which a marble is rolling. When the marble rolls into a box, it pushes the data-path button that is named by the box. When the marble rolls into a decision node (such as the test for <span class="KeyTerm1">b</span> = 0), it leaves the node on the path determined by the result of the indicated test.</p>
<figure id="c005_c5-fig-0002"><img alt="c5-fig-0002.jpg" src="../images/c5-fig-0002.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0002a">Figure 5.2</a></span> <a id="c005_c5-para-0015"></a>Controller for a GCD machine.</p></figcaption></figure>
<p class="paracontinue"><a id="c005_c5-para-0016"></a>Taken together, the data paths and the controller completely describe a machine for computing GCDs. We start the controller (the rolling marble) at the place marked <span class="KeyTerm1">start</span>, after placing numbers in registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span>. When the controller reaches <span class="KeyTerm1">done</span>, we will find the value of the GCD in register <span class="KeyTerm1">a</span>.</p>
<section><a id="c005_c5-title-0004"></a>
<section>
<h5><a id="c005_c5-sec-0004"></a><a id="c005_c5-title-0005"></a>Exercise 5.1</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0017"></a>Design a register machine to compute factorials using the iterative algorithm specified by the following function. Draw data-path and controller diagrams for this machine.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0018"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0019"></a> <b>function</b> iter(product, counter) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0020"></a> <b>return</b> counter &gt; n</p>
<p class="Sp-text-1"><a id="c005_c5-para-0021"></a>           ? product</p>
<p class="Sp-text-1"><a id="c005_c5-para-0022"></a>           : iter(counter * product,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0023"></a>                  counter + 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0024"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0025"></a> <b>return</b> iter(1, 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0026"></a>}</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0005"></a><span>5.1.1</span> <a id="c005_c5-title-0006"></a>A Language for Describing Register Machines</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0027"></a>Data-path and controller diagrams are adequate for representing simple machines such as GCD, but they are unwieldy for describing large machines such as a JavaScript interpreter. To make it possible to deal with complex machines, we will create a language that presents, in textual form, all the information given by the datapath and controller diagrams. We will start with a notation that directly mirrors the diagrams.</p>
<p><a id="c005_c5-para-0028"></a>We define the data paths of a machine by describing the registers and the operations. To describe a register, we give it a name and specify the buttons that control assignment to it. We give each of these buttons a name and specify the source of the data that enters the register under the button's control. (The source is a register, a constant, or an operation.) To describe an operation, we give it a name and specify its inputs (registers or constants).</p>
<p><a id="c005_c5-para-0029"></a>We define the controller of a machine as a sequence of <i>instructions</i> together with <i>labels</i> that identify <i>entry points</i> in the sequence. An instruction is one of the following:</p>
<ul style="list-style-type:disc">
<li>The name of a data-path button to push to assign a value to a register. (This corresponds to a box in the controller diagram.)</li>
<li>A <span class="KeyTerm1">test</span> instruction, which performs a specified test.</li>
<li>A conditional branch (<span class="KeyTerm1">branch</span> instruction) to a location indicated by a controller label, based on the result of the previous test. (The test and branch together correspond to a diamond in the controller diagram.) If the test is false, the controller should continue with the next instruction in the sequence. Otherwise, the controller should continue with the instruction after the label.</li>
<li>An unconditional branch (<span class="KeyTerm1">go_to</span> instruction) naming a controller label at which to continue execution.</li>
</ul>
<p class="paracontinue"><a id="c005_c5-para-0034"></a>The machine starts at the beginning of the controller instruction sequence and stops when execution reaches the end of the sequence. Except when a branch changes the flow of control, instructions are executed in the order in which they are listed.</p>
<p><a id="c005_c5-para-0035"></a><a id="c005_c5-fig-0003a"></a><a href="#c5-fig-0003">Figure 5.3</a> shows the GCD machine described in this way. This example only hints at the generality of these descriptions, since the GCD machine is a very simple case: Each register has only one button, and each button and test is used only once in the controller.</p>
<figure id="c005_c5-fig-0003"><img alt="c5-fig-0003.jpg" src="../images/c5-fig-0003.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0003a">Figure 5.3</a></span> <a id="c005_c5-para-0036"></a>A specification of the GCD machine.</p></figcaption></figure>
<p><a id="c005_c5-para-0037"></a>Unfortunately, it is difficult to read such a description. In order to understand the controller instructions we must constantly refer back to the definitions of the button names and the operation names, and to understand what the buttons do we may have to refer to the definitions of the operation names. We will thus transform our notation to combine the information from the data-path and controller descriptions so that we see it all together.</p>
<p><a id="c005_c5-para-0038"></a>To obtain this form of description, we will replace the arbitrary button and operation names by the definitions of their behavior. That is, instead of saying (in the controller) “Push button <span class="KeyTerm1">t&lt;-r</span>” and separately saying (in the data paths) “Button <span class="KeyTerm1">t&lt;-r</span> assigns the value of the <span class="KeyTerm1">rem</span> operation to register <span class="KeyTerm1">t</span>” and “The <span class="KeyTerm1">rem</span> operation's inputs are the contents of registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span>,” we will say (in the controller) “Push the button that assigns to register <span class="KeyTerm1">t</span> the value of the <span class="KeyTerm1">rem</span> operation on the contents of registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span>.” Similarly, instead of saying (in the controller) “Perform the <span class="KeyTerm1">=</span> test” and separately saying (in the data paths) “The <span class="KeyTerm1">=</span> test operates on the contents of register <span class="KeyTerm1">b</span> and the constant 0,” we will say “Perform the <span class="KeyTerm1">=</span> test on the contents of register <span class="KeyTerm1">b</span> and the constant 0.” We will omit the data-path description, leaving only the controller sequence. Thus, the GCD machine is described as follows:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0039"></a>controller(</p>
<p class="Sp-text-1"><a id="c005_c5-para-0040"></a>  list(</p>
<p class="Sp-text-1"><a id="c005_c5-para-0041"></a>    "test_b",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0042"></a>      test(list(op("="), reg("b"), constant(0))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0043"></a>      branch(label("gcd_done")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0044"></a>      assign("t", list(op("rem"), reg("a"), reg("b"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0045"></a>      assign("a", reg("b")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0046"></a>      assign("b", reg("t")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0047"></a>      go_to(label("test_b")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0048"></a>    "gcd_done"))</p>
<p><a id="c005_c5-para-0049"></a>This form of description is easier to read than the kind illustrated in <a href="#c5-fig-0003">figure 5.3</a>, but it also has disadvantages:</p>
<ul style="list-style-type:disc">
<li>It is more verbose for large machines, because complete descriptions of the datapath elements are repeated whenever the elements are mentioned in the controller instruction sequence. (This is not a problem in the GCD example, because each operation and button is used only once.) Moreover, repeating the data-path descriptions obscures the actual data-path structure of the machine; it is not obvious for a large machine how many registers, operations, and buttons there are and how they are interconnected.</li>
<li>Because the controller instructions in a machine definition look like JavaScript expressions, it is easy to forget that they are not arbitrary JavaScript expressions. They can notate only legal machine operations. For example, operations can operate directly only on constants and the contents of registers, not on the results of other operations.</li>
</ul>
<p class="paracontinue"><a id="c005_c5-para-0052"></a>In spite of these disadvantages, we will use this register-machine language throughout this chapter, because we will be more concerned with understanding controllers than with understanding the elements and connections in data paths. We should keep in mind, however, that data-path design is crucial in designing real machines.</p>
<section>
<h5><a id="c005_c5-sec-0006"></a><a id="c005_c5-title-0007"></a>Exercise 5.2</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0053"></a>Use the register-machine language to describe the iterative factorial machine of exercise 5.1.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0007"></a><a id="c005_c5-title-0008"></a>Actions</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0054"></a>Let us modify the GCD machine so that we can type in the numbers whose GCD we want and get the answer printed. We will not discuss how to make a machine that can read and print, but will assume (as we do when we use <span class="KeyTerm1">prompt</span> and <span class="KeyTerm1">display</span> in JavaScript) that they are available as primitive operations.<a id="c005_c5-fn-0002a"></a><a href="#c5-fn-0002"><sup>2</sup></a></p>
<p><a id="c005_c5-para-0055"></a>The operation <span class="KeyTerm1">prompt</span> is like the operations we have been using in that it produces a value that can be stored in a register. But <span class="KeyTerm1">prompt</span> does not take inputs from any registers; its value depends on something that happens outside the parts of the</p>
<p class="paracontinue"><a id="c005_c5-para-0056"></a>machine we are designing. We will allow our machine's operations to have such behavior, and thus will draw and notate the use of <span class="KeyTerm1">prompt</span> just as we do any other operation that computes a value.</p>
<p><a id="c005_c5-para-0057"></a>The operation <span class="KeyTerm1">display</span>, on the other hand, differs from the operations we have been using in a fundamental way: It does not produce an output value to be stored in a register. Though it has an effect, this effect is not on a part of the machine we are designing. We will refer to this kind of operation as an <i>action</i>. We will represent an action in a data-path diagram just as we represent an operation that computes a value—as a trapezoid that contains the name of the action. Arrows point to the action box from any inputs (registers or constants). We also associate a button with the action. Pushing the button makes the action happen. To make a controller push an action button we use a new kind of instruction called <span class="KeyTerm1">perform</span>. Thus, the action of printing the contents of register <span class="KeyTerm1">a</span> is represented in a controller sequence by the instruction</p>
<p class="Sp-text-1"><a id="c005_c5-para-0058"></a>perform(list(op("display"), reg("a")))</p>
<p><a id="c005_c5-para-0059"></a><a id="c005_c5-fig-0004a"></a><a href="#c5-fig-0004">Figure 5.4</a> shows the data paths and controller for the new GCD machine. Instead of having the machine stop after printing the answer, we have made it start over, so that it repeatedly reads a pair of numbers, computes their GCD, and prints the result. This structure is like the driver loops we used in the interpreters of chapter 4.</p>
<figure id="c005_c5-fig-0004"><img alt="c5-fig-0004.jpg" src="../images/c5-fig-0004.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0004a">Figure 5.4</a></span> <a id="c005_c5-para-0060"></a>A GCD machine that reads inputs and prints results.</p></figcaption></figure>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0008"></a><span>5.1.2</span> <a id="c005_c5-title-0009"></a>Abstraction in Machine Design</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0061"></a>We will often define a machine to include “primitive” operations that are actually very complex. For example, in sections 5.4 and 5.5 we will treat JavaScript's environment manipulations as primitive. Such abstraction is valuable because it allows us to ignore the details of parts of a machine so that we can concentrate on other aspects of the design. The fact that we have swept a lot of complexity under the rug, however, does not mean that a machine design is unrealistic. We can always replace the complex “primitives” by simpler primitive operations.</p>
<p><a id="c005_c5-para-0062"></a>Consider the GCD machine. The machine has an instruction that computes the remainder of the contents of registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> and assigns the result to register <span class="KeyTerm1">t</span>. If we want to construct the GCD machine without using a primitive remainder operation, we must specify how to compute remainders in terms of simpler operations, such as subtraction. Indeed, we can write a JavaScript function that finds remainders in this way:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0063"></a><b>function</b> remainder(n, d) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0064"></a> <b>return</b> n &lt; d</p>
<p class="Sp-text-1"><a id="c005_c5-para-0065"></a>           ? n</p>
<p class="Sp-text-1"><a id="c005_c5-para-0066"></a>           : remainder(n - d, d);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0067"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0068"></a>We can thus replace the remainder operation in the GCD machine's data paths with a subtraction operation and a comparison test. <a id="c005_c5-fig-0005a"></a><a href="#c5-fig-0005">Figure 5.5</a> shows the data paths and controller for the elaborated machine. The instruction</p>
<p class="Sp-text-1"><a id="c005_c5-para-0070"></a>assign("t", list(op("rem"), reg("a"), reg("b")))</p>
<p class="paracontinue"><a id="c005_c5-para-0071"></a>in the GCD controller definition is replaced by a sequence of instructions that contains a loop, as shown in <a id="c005_c5-fig-0006a"></a><a href="#c5-fig-0006">figure 5.6</a>.</p>
<figure id="c005_c5-fig-0005"><img alt="c5-fig-0005.jpg" src="../images/c5-fig-0005.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0005a">Figure 5.5</a></span> <a id="c005_c5-para-0069"></a>Data paths and controller for the elaborated GCD machine.</p></figcaption></figure>
<figure id="c005_c5-fig-0006"><img alt="c5-fig-0006.jpg" src="../images/c5-fig-0006.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0006a">Figure 5.6</a></span> <a id="c005_c5-para-0072"></a>Controller instruction sequence for the GCD machine in <a href="#c5-fig-0005">figure 5.5</a>.</p></figcaption></figure>
<section>
<h5><a id="c005_c5-sec-0009"></a><a id="c005_c5-title-0010"></a>Exercise 5.3</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0073"></a>Design a machine to compute square roots using Newton's method, as described in section 1.1.7 and implemented with the following code in section 1.1.8:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0074"></a><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0075"></a> <b>function</b> is_good_enough(guess) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0076"></a> <b>return</b> math_abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0077"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0078"></a> <b>function</b> improve(guess) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0079"></a> <b>return</b> average(guess, x / guess);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0080"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0081"></a> <b>function</b> sqrt_iter(guess) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0082"></a> <b>return</b> is_good_enough(guess)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0083"></a>               ? guess</p>
<p class="Sp-text-1"><a id="c005_c5-para-0084"></a>           : sqrt_iter(improve(guess));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0085"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0086"></a> <b>return</b> sqrt_iter(1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0087"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0088"></a>Begin by assuming that <span class="KeyTerm1">is_good_enough</span> and <span class="KeyTerm1">improve</span> operations are available as primitives. Then show how to expand these in terms of arithmetic operations. Describe each version of the <span class="KeyTerm1">sqrt</span> machine design by drawing a data-path diagram and writing a controller definition in the register-machine language.</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0010"></a><span>5.1.3</span> <a id="c005_c5-title-0011"></a>Subroutines</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0089"></a>When designing a machine to perform a computation, we would often prefer to arrange for components to be shared by different parts of the computation rather than duplicate the components. Consider a machine that includes two GCD computations—one that finds the GCD of the contents of registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> and one that finds the GCD of the contents of registers <span class="KeyTerm1">c</span> and <span class="KeyTerm1">d</span>. We might start by assuming we have a primitive <span class="KeyTerm1">gcd</span> operation, then expand the two instances of <span class="KeyTerm1">gcd</span> in terms of more primitive operations. <a id="c005_c5-fig-0007a"></a><a href="#c5-fig-0007">Figure 5.7</a> shows just the GCD portions of the resulting machine's data paths, without showing how they connect to the rest of the machine. The figure also shows the corresponding portions of the machine's controller sequence.</p>
<figure id="c005_c5-fig-0007"><img alt="c5-fig-0007.jpg" src="../images/c5-fig-0007.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0007a">Figure 5.7</a></span> <a id="c005_c5-para-0090"></a>Portions of the data paths and controller sequence for a machine with two GCD computations.</p></figcaption></figure>
<p><a id="c005_c5-para-0091"></a>This machine has two remainder operation boxes and two boxes for testing equality. If the duplicated components are complicated, as is the remainder box, this will not be an economical way to build the machine. We can avoid duplicating the data-path components by using the same components for both GCD computations, provided that doing so will not affect the rest of the larger machine's computation. If the values in registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> are not needed by the time the controller gets to <span class="KeyTerm1">gcd_2</span> (or if these values can be moved to other registers for safekeeping), we can change the machine so that it uses registers <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span>, rather than registers <span class="KeyTerm1">c</span> and <span class="KeyTerm1">d</span>, in computing the second GCD as well as the first. If we do this, we obtain the controller sequence shown in <a id="c005_c5-fig-0008a"></a><a href="#c5-fig-0008">figure 5.8</a>.</p>
<figure id="c005_c5-fig-0008"><img alt="c5-fig-0008.jpg" src="../images/c5-fig-0008.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0008a">Figure 5.8</a></span> <a id="c005_c5-para-0092"></a>Portions of the controller sequence for a machine that uses the same datapath components for two different GCD computations.</p></figcaption></figure>
<p><a id="c005_c5-para-0093"></a>We have removed the duplicate data-path components (so that the data paths are again as in <a href="#c5-fig-0001">figure 5.1</a>), but the controller now has two GCD sequences that differ only in their entry-point labels. It would be better to replace these two sequences by branches to a single sequence—a <span class="KeyTerm1">gcd</span> <i>subroutine</i>—at the end of which we branch back to the correct place in the main instruction sequence. We can accomplish this as follows: Before branching to <span class="KeyTerm1">gcd</span>, we place a distinguishing value (such as 0 or 1) into a special register, <span class="KeyTerm1">continue</span>. At the end of the <span class="KeyTerm1">gcd</span> subroutine we return either to <span class="KeyTerm1">after_gcd_1</span> or to <span class="KeyTerm1">after_gcd_2</span>, depending on the value of the <span class="KeyTerm1">continue</span> register. <a id="c005_c5-fig-0009a"></a><a href="#c5-fig-0009">Figure 5.9</a> shows the relevant portion of the resulting controller sequence, which includes only a single copy of the <span class="KeyTerm1">gcd</span> instructions.</p>
<figure id="c005_c5-fig-0009"><img alt="c5-fig-0009.jpg" src="../images/c5-fig-0009.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0009a">Figure 5.9</a></span> <a id="c005_c5-para-0094"></a>Using a <span class="KeyTerm1">continue</span> register to avoid the duplicate controller sequence in <a href="#c5-fig-0008">figure 5.8</a>.</p></figcaption></figure>
<p><a id="c005_c5-para-0095"></a>This is a reasonable approach for handling small problems, but it would be awkward if there were many instances of GCD computations in the controller sequence. To decide where to continue executing after the <span class="KeyTerm1">gcd</span> subroutine, we would need tests in the data paths and branch instructions in the controller for all the places that use <span class="KeyTerm1">gcd</span>. A more powerful method for implementing subroutines is to have the <span class="KeyTerm1">continue</span> register hold the label of the entry point in the controller sequence at which execution should continue when the subroutine is finished. Implementing this strategy requires a new kind of connection between the data paths and the controller of a register machine: There must be a way to assign to a register a label in the controller sequence in such a way that this value can be fetched from the register and used to continue execution at the designated entry point.</p>
<p><a id="c005_c5-para-0096"></a>To reflect this ability, we will extend the <span class="KeyTerm1">assign</span> instruction of the registermachine language to allow a register to be assigned as value a label from the controller sequence (as a special kind of constant). We will also extend the <span class="KeyTerm1">go_to</span> instruction to allow execution to continue at the entry point described by the contents of a register rather than only at an entry point described by a constant label. Using these new constructs we can terminate the <span class="KeyTerm1">gcd</span> subroutine with a branch to the location stored in the <span class="KeyTerm1">continue</span> register. This leads to the controller sequence shown in <a id="c005_c5-fig-0010a"></a><a href="#c5-fig-0010">figure 5.10</a>.</p>
<figure id="c005_c5-fig-0010"><img alt="c5-fig-0010.jpg" src="../images/c5-fig-0010.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0010a">Figure 5.10</a></span> <a id="c005_c5-para-0098"></a>Assigning labels to the <span class="KeyTerm1">continue</span> register simplifies and generalizes the strategy shown in <a href="#c5-fig-0009">figure 5.9</a>.</p></figcaption></figure>
<p><a id="c005_c5-para-0099"></a>A machine with more than one subroutine could use multiple continuation registers (e.g., <span class="KeyTerm1">gcd_continue</span>, <span class="KeyTerm1">factorial_continue</span>) or we could have all subroutines share a single <span class="KeyTerm1">continue</span> register. Sharing is more economical, but we must be careful if we have a subroutine (<span class="KeyTerm1">sub1</span>) that calls another subroutine (<span class="KeyTerm1">sub2</span>). Unless <span class="KeyTerm1">sub1</span> saves the contents of <span class="KeyTerm1">continue</span> in some other register before setting up <span class="KeyTerm1">continue</span> for the call to <span class="KeyTerm1">sub2</span>, <span class="KeyTerm1">sub1</span> will not know where to go when it is finished. The mechanism developed in the next section to handle recursion also provides a better solution to this problem of nested subroutine calls.</p>
</section>
<section>
<h3><a id="c005_c5-sec-0011"></a><span>5.1.4</span> <a id="c005_c5-title-0012"></a>Using a Stack to Implement Recursion</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0100"></a>With the ideas illustrated so far, we can implement any iterative process by specifying a register machine that has a register corresponding to each state variable of the process. The machine repeatedly executes a controller loop, changing the contents of the registers, until some termination condition is satisfied. At each point in the controller sequence, the state of the machine (representing the state of the iterative process) is completely determined by the contents of the registers (the values of the state variables).</p>
<p><a id="c005_c5-para-0101"></a>Implementing recursive processes, however, requires an additional mechanism. Consider the following recursive method for computing factorials, which we first examined in section 1.2.1:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0102"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0103"></a> <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-0104"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-0105"></a>           : n * factorial(n - 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0106"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0107"></a>As we see from the function, computing <i>n</i>! requires computing (<i>n</i> – 1)!. Our GCD machine, modeled on the function</p>
<p class="Sp-text-1"><a id="c005_c5-para-0108"></a><b>function</b> gcd(a, b) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0109"></a> <b>return</b> b === 0 ? a : gcd(b, a % b);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0110"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0111"></a>similarly had to compute another GCD. But there is an important difference between the <span class="KeyTerm1">gcd</span> function, which reduces the original computation to a new GCD computation, and <span class="KeyTerm1">factorial</span>, which requires computing another factorial as a subproblem. In GCD, the answer to the new GCD computation is the answer to the original problem. To compute the next GCD, we simply place the new arguments in the input registers of the GCD machine and reuse the machine's data paths by executing the same controller sequence. When the machine is finished solving the final GCD problem, it has completed the entire computation.</p>
<p><a id="c005_c5-para-0112"></a>In the case of factorial (or any recursive process) the answer to the new factorial subproblem is not the answer to the original problem. The value obtained for (<i>n</i> – 1)! must be multiplied by <i>n</i> to get the final answer. If we try to imitate the GCD design, and solve the factorial subproblem by decrementing the <span class="KeyTerm1">n</span> register and rerunning the factorial machine, we will no longer have available the old value of <span class="KeyTerm1">n</span> by which to multiply the result. We thus need a second factorial machine to work on the</p>
<p class="paracontinue"><a id="c005_c5-para-0113"></a>subproblem. This second factorial computation itself has a factorial subproblem, which requires a third factorial machine, and so on. Since each factorial machine contains another factorial machine within it, the total machine contains an infinite nest of similar machines and hence cannot be constructed from a fixed, finite number of parts.</p>
<p><a id="c005_c5-para-0114"></a>Nevertheless, we can implement the factorial process as a register machine if we can arrange to use the same components for each nested instance of the machine. Specifically, the machine that computes <i>n</i>! should use the same components to work on the subproblem of computing (<i>n</i> – 1)!, on the subproblem for (<i>n</i> – 2)!, and so on. This is plausible because, although the factorial process dictates that an unbounded number of copies of the same machine are needed to perform a computation, only one of these copies needs to be active at any given time. When the machine encounters a recursive subproblem, it can suspend work on the main problem, reuse the same physical parts to work on the subproblem, then continue the suspended computation.</p>
<p><a id="c005_c5-para-0115"></a>In the subproblem, the contents of the registers will be different than they were in the main problem. (In this case the <span class="KeyTerm1">n</span> register is decremented.) In order to be able to continue the suspended computation, the machine must save the contents of any registers that will be needed after the subproblem is solved so that these can be restored to continue the suspended computation. In the case of factorial, we will save the old value of <span class="KeyTerm1">n</span>, to be restored when we are finished computing the factorial of the decremented <span class="KeyTerm1">n</span> register.<a id="c005_c5-fn-0003a"></a><a href="#c5-fn-0003"><sup>3</sup></a></p>
<p><a id="c005_c5-para-0116"></a>Since there is no a priori limit on the depth of nested recursive calls, we may need to save an arbitrary number of register values. These values must be restored in the reverse of the order in which they were saved, since in a nest of recursions the last subproblem to be entered is the first to be finished. This dictates the use of a <i>stack</i>, or “last in, first out” data structure, to save register values. We can extend the register-machine language to include a stack by adding two kinds of instructions: Values are placed on the stack using a <span class="KeyTerm1">save</span> instruction and restored from the stack using a <span class="KeyTerm1">restore</span> instruction. After a sequence of values has been <span class="KeyTerm1">save</span>d on the stack, a sequence of <span class="KeyTerm1">restore</span>s will retrieve these values in reverse order.<a id="c005_c5-fn-0004a"></a><a href="#c5-fn-0004"><sup>4</sup></a></p>
<p><a id="c005_c5-para-0117"></a>With the aid of the stack, we can reuse a single copy of the factorial machine's data paths for each factorial subproblem. There is a similar design issue in reusing the controller sequence that operates the data paths. To reexecute the factorial computation, the controller cannot simply loop back to the beginning, as with an iterative process, because after solving the (<i>n</i> – 1)! subproblem the machine must still multiply the result by <i>n</i>. The controller must suspend its computation of <i>n</i>!, solve the (<i>n</i> – 1)! subproblem, then continue its computation of <i>n</i>!. This view of the factorial computation suggests the use of the subroutine mechanism described in section 5.1.3, which has the controller use a <span class="KeyTerm1">continue</span> register to transfer to the part of the sequence that solves a subproblem and then continue where it left off on the main problem. We can thus make a factorial subroutine that returns to the entry point stored in the <span class="KeyTerm1">continue</span> register. Around each subroutine call, we save and restore <span class="KeyTerm1">continue</span> just as we do the <span class="KeyTerm1">n</span> register, since each “level” of the factorial computation will use the same <span class="KeyTerm1">continue</span> register. That is, the factorial subroutine must put a new value in <span class="KeyTerm1">continue</span> when it calls itself for a subproblem, but it will need the old value in order to return to the place that called it to solve a subproblem.</p>
<p><a id="c005_c5-para-0118"></a><a id="c005_c5-fig-0011a"></a><a href="#c5-fig-0011">Figure 5.11</a> shows the data paths and controller for a machine that implements the recursive <span class="KeyTerm1">factorial</span> function. The machine has a stack and three registers, called <span class="KeyTerm1">n</span>, <span class="KeyTerm1">val</span>, and <span class="KeyTerm1">continue</span>. To simplify the data-path diagram, we have not named the register-assignment buttons, only the stack-operation buttons (<span class="KeyTerm1">sc</span> and <span class="KeyTerm1">sn</span> to save registers, <span class="KeyTerm1">rc</span> and <span class="KeyTerm1">rn</span> to restore registers). To operate the machine, we put in register <span class="KeyTerm1">n</span> the number whose factorial we wish to compute and start the machine. When the machine reaches <span class="KeyTerm1">fact_done</span>, the computation is finished and the answer will be found in the <span class="KeyTerm1">val</span> register. In the controller sequence, <span class="KeyTerm1">n</span> and <span class="KeyTerm1">continue</span> are saved before each recursive call and restored upon return from the call. Returning from a call is accomplished by branching to the location stored in <span class="KeyTerm1">continue</span>. The register <span class="KeyTerm1">continue</span> is initialized when the machine starts so that the last return will go to <span class="KeyTerm1">fact_done</span>. The <span class="KeyTerm1">val</span> register, which holds the result of the factorial computation, is not saved before the recursive call, because the old contents of <span class="KeyTerm1">val</span> is not useful after the subroutine returns. Only the new value, which is the value produced by the subcomputation, is needed.</p>
<figure id="c005_c5-fig-0011"><img alt="c5-fig-0011.jpg" src="../images/c5-fig-0011.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0011a">Figure 5.11</a></span> <a id="c005_c5-para-0119"></a>A recursive factorial machine.</p></figcaption></figure>
<p><a id="c005_c5-para-0120"></a>Although in principle the factorial computation requires an infinite machine, the machine in <a href="#c5-fig-0011">figure 5.11</a> is actually finite except for the stack, which is potentially unbounded. Any particular physical implementation of a stack, however, will be of finite size, and this will limit the depth of recursive calls that can be handled by the machine. This implementation of factorial illustrates the general strategy for realizing recursive algorithms as ordinary register machines augmented by stacks. When a recursive subproblem is encountered, we save on the stack the registers whose current values will be required after the subproblem is solved, solve the recursive subproblem, then restore the saved registers and continue execution on the main problem. The <span class="KeyTerm1">continue</span> register must always be saved. Whether there are other registers that need to be saved depends on the particular machine, since not all recursive computations need the original values of registers that are modified during solution of the subproblem (see exercise 5.4).</p>
<section>
<h5><a id="c005_c5-sec-0012"></a><a id="c005_c5-title-0013"></a>A double recursion</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0121"></a>Let us examine a more complex recursive process, the tree-recursive computation of the Fibonacci numbers, which we introduced in section 1.2.2:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0122"></a><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0123"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c005_c5-para-0124"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c005_c5-para-0125"></a>           : n === 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-0126"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-0127"></a>           : fib(n - 1) + fib(n - 2);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0128"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0129"></a>Just as with factorial, we can implement the recursive Fibonacci computation as a register machine with registers <span class="KeyTerm1">n</span>, <span class="KeyTerm1">val</span>, and <span class="KeyTerm1">continue</span>. The machine is more complex than the one for factorial, because there are two places in the controller sequence where we need to perform recursive calls—once to compute Fib(<i>n</i> – 1) and once to compute Fib(<i>n</i> – 2). To set up for each of these calls, we save the registers whose values will be needed later, set the <span class="KeyTerm1">n</span> register to the number whose Fib we need to compute recursively (<i>n</i> – 1 or <i>n</i> – 2), and assign to <span class="KeyTerm1">continue</span> the entry point in the main sequence to which to return (<span class="KeyTerm1">afterfib_n_1</span> or <span class="KeyTerm1">afterfib_n_2</span>, respectively). We then go to <span class="KeyTerm1">fib_loop</span>. When we return from the recursive call, the answer is in <span class="KeyTerm1">val</span>. <a id="c005_c5-fig-0012a"></a><a href="#c5-fig-0012">Figure 5.12</a> shows the controller sequence for this machine.</p>
<figure id="c005_c5-fig-0012"><img alt="c5-fig-0012.jpg" src="../images/c5-fig-0012.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0012a">Figure 5.12</a></span> <a id="c005_c5-para-0130"></a>Controller for a machine to compute Fibonacci numbers.</p></figcaption></figure>
</section>
<section>
<h5><a id="c005_c5-sec-0013"></a><a id="c005_c5-title-0014"></a>Exercise 5.4</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0131"></a>Specify register machines that implement each of the following functions. For each machine, write a controller instruction sequence and draw a diagram showing the data paths.</p>
<ol class="BS_NumberListA">
<li><a id="c005_c5-li-0007"></a><span>a. </span>Recursive exponentiation:
<p class="Sp-text-1"><a id="c005_c5-para-0133"></a><b>function</b> expt(b, n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0134"></a> <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c005_c5-para-0135"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-0136"></a>           : b * expt(b, n - 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0137"></a>}</p></li>
<li><a id="c005_c5-li-0008"></a><span>b. </span>Iterative exponentiation:
<p class="Sp-text-1"><a id="c005_c5-para-0139"></a><b>function</b> expt(b, n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0140"></a> <b>function</b> expt_iter(counter, product) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0141"></a> <b>return</b> counter === 0</p>
<p class="Sp-text-1"><a id="c005_c5-para-0142"></a>               ? product</p>
<p class="Sp-text-1"><a id="c005_c5-para-0143"></a>               : expt_iter(counter - 1, b * product);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0144"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0145"></a> <b>return</b> expt_iter(n, 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0146"></a>}</p></li>
</ol>
</section>
<section>
<h5><a id="c005_c5-sec-0014"></a><a id="c005_c5-title-0015"></a>Exercise 5.5</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0147"></a>Hand-simulate the factorial and Fibonacci machines, using some nontrivial input (requiring execution of at least one recursive call). Show the contents of the stack at each significant point in the execution.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0015"></a><a id="c005_c5-title-0016"></a>Exercise 5.6</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0148"></a>Ben Bitdiddle observes that the Fibonacci machine's controller sequence has an extra <span class="KeyTerm1">save</span> and an extra <span class="KeyTerm1">restore</span>, which can be removed to make a faster machine. Where are these instructions?</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0016"></a><span>5.1.5</span> <a id="c005_c5-title-0017"></a>Instruction Summary</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0149"></a>A controller instruction in our register-machine language has one of the following forms, where each <i>input<sub>i</sub></i> is <span class="KeyTerm1">reg(</span><i>register</i>-<i>name</i><span class="KeyTerm1">)</span> or <span class="KeyTerm1">constant(</span><i>constant</i>-<i>value</i><span class="KeyTerm1">)</span>.</p>
<p><a id="c005_c5-para-0150"></a>These instructions were introduced in section 5.1.1:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0151"></a>assign(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>, reg(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0152"></a>assign(<span class="KeyTerm2"><i>register-name</i></span>, constant(<span class="KeyTerm2"><i>constant-value</i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0153"></a>assign(<span class="KeyTerm2">register-name</span>, list(op(<span class="KeyTerm2"><i>operation-name</i></span>), <span class="KeyTerm2"><i>input</i><sub>1</sub></span>, . . ., <span class="KeyTerm2"><i>input<sub>n</sub></i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0154"></a>perform(list(op(<span class="KeyTerm2"><i>operation-name</i></span>), <span class="KeyTerm2"><i>input</i><sub>1</sub></span>, . . ., <span class="KeyTerm2"><i>input<sub>n</sub></i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0155"></a>test(list(op(<span class="KeyTerm2"><i>operation-name</i></span>), <span class="KeyTerm2"><i>input</i><sub>1</sub></span>, . . ., <span class="KeyTerm2"><i>input<sub>n</sub></i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0156"></a>branch(label(<span class="KeyTerm2"><i>label-name</i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0157"></a>go_to(label(<span class="KeyTerm2"><i>label-name</i></span>))</p>
<p><a id="c005_c5-para-0158"></a>The use of registers to hold labels was introduced in section 5.1.3:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0159"></a>assign(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>, label(<span class="KeyTerm2"><i>label</i>-<i>name</i></span>))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0160"></a>go_to(reg(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>))</p>
<p><a id="c005_c5-para-0161"></a>Instructions to use the stack were introduced in section 5.1.4:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0162"></a>save(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>)</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0163"></a>restore(<span class="KeyTerm2"><i>register</i>-<i>name</i></span>)</p>
<p><a id="c005_c5-para-0164"></a>The only kind of <i>constant</i>-<i>value</i> we have seen so far is a number, but later we will also use strings and lists. For example, <span class="KeyTerm1">constant("abc")</span> is the string <span class="KeyTerm1">"abc"</span>, <span class="KeyTerm1">constant(<b>null</b>)</span> is the empty list, and <span class="KeyTerm1">constant(list("a", "b", "c"))</span> is the list <span class="KeyTerm1">list("a", "b", "c")</span>.</p>
</section>
</section>
<section>
<h2><a id="c005_c5-sec-0017"></a><span>5.2</span> <a id="c005_c5-title-0018"></a>A Register-Machine Simulator</h2>
<p class="paraaftertitle"><a id="c005_c5-para-0165"></a>In order to gain a good understanding of the design of register machines, we must test the machines we design to see if they perform as expected. One way to test a design is to hand-simulate the operation of the controller, as in exercise 5.5. But this is extremely tedious for all but the simplest machines. In this section we construct a simulator for machines described in the register-machine language. The simulator is a JavaScript program with four interface functions. The first uses a description of a register machine to construct a model of the machine (a data structure whose parts correspond to the parts of the machine to be simulated), and the other three allow us to simulate the machine by manipulating the model:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">make_machine(</span><i>register</i>-<i>names</i>, <i>operations</i>, <i>controller</i>)
<p class="paracontinue"><a id="c005_c5-para-0167"></a>constructs and returns a model of the machine with the given registers, operations, and controller.</p></li>
<li><span class="KeyTerm1">set_register_contents</span>(<i>machine</i>-<i>model</i>, <i>register</i>-<i>name</i>, <i>value</i>)
<p class="paracontinue"><a id="c005_c5-para-0169"></a>stores a value in a simulated register in the given machine.</p></li>
<li><span class="KeyTerm1">get_register_contents</span>(<i>machine</i>-<i>model</i>, <i>register</i>-<i>name</i>)
<p class="paracontinue"><a id="c005_c5-para-0171"></a>returns the contents of a simulated register in the given machine.</p></li>
<li><span class="KeyTerm1">start</span>(<i>machine</i>-<i>model</i>)
<p class="paracontinue"><a id="c005_c5-para-0173"></a>simulates the execution of the given machine, starting from the beginning of the controller sequence and stopping when it reaches the end of the sequence.</p></li>
</ul>
<p><a id="c005_c5-para-0174"></a>As an example of how these functions are used, we can define <span class="KeyTerm1">gcd_machine</span> to be a model of the GCD machine of section 5.1.1 as follows:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0175"></a><b>const</b> gcd_machine =</p>
<p class="Sp-text-1"><a id="c005_c5-para-0176"></a>    make_machine(</p>
<p class="Sp-text-1"><a id="c005_c5-para-0177"></a>        list("a", "b", "t"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0178"></a>        list(list("rem", (a, b) =&gt; a % b),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0179"></a>         list("=", (a, b) =&gt; a === b)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0180"></a>        list(</p>
<p class="Sp-text-1"><a id="c005_c5-para-0181"></a>          "test_b",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0182"></a>            test(list(op("="), reg("b"), constant(0))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0183"></a>            branch(label("gcd_done")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0184"></a>            assign("t", list(op("rem"), reg("a"), reg("b"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0185"></a>            assign("a", reg("b")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0186"></a>            assign("b", reg("t")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0187"></a>            go_to(label("test_b")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0188"></a>      "gcd_done"));</p>
<p class="paracontinue"><a id="c005_c5-para-0189"></a>The first argument to <span class="KeyTerm1">make_machine</span> is a list of register names. The next argument is a table (a list of two-element lists) that pairs each operation name with a JavaScript function that implements the operation (that is, produces the same output value given the same input values). The last argument specifies the controller as a list of labels and machine instructions, as in section 5.1.</p>
<p><a id="c005_c5-para-0190"></a>To compute GCDs with this machine, we set the input registers, start the machine, and examine the result when the simulation terminates:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0191"></a>set_register_contents(gcd_machine, "a", 206);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0192"></a><i>"done"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0193"></a>set_register_contents(gcd_machine, "b", 40);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0194"></a><i>"done"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0195"></a>start(gcd_machine);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0196"></a><i>"done"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0197"></a>get_register_contents(gcd_machine, "a");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0198"></a><i>2</i></p>
<p class="paracontinue"><a id="c005_c5-para-0199"></a>This computation will run much more slowly than a <span class="KeyTerm1">gcd</span> function written in JavaScript, because we will simulate low-level machine instructions, such as <span class="KeyTerm1">assign</span>, by much more complex operations.</p>
<section><a id="c005_c5-title-0019"></a>
<section>
<h5><a id="c005_c5-sec-0019"></a><a id="c005_c5-title-0020"></a>Exercise 5.7</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0200"></a>Use the simulator to test the machines you designed in exercise 5.4.</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0020"></a><span>5.2.1</span> <a id="c005_c5-title-0021"></a>The Machine Model</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0201"></a>The machine model generated by <span class="KeyTerm1">make_machine</span> is represented as a function with local state using the message-passing techniques developed in chapter 3. To build this model, <span class="KeyTerm1">make_machine</span> begins by calling the function <span class="KeyTerm1">make_new_machine</span> to construct the parts of the machine model that are common to all register machines. This basic machine model constructed by <span class="KeyTerm1">make_new_machine</span> is essentially a container for some registers and a stack, together with an execution mechanism that processes the controller instructions one by one.</p>
<p><a id="c005_c5-para-0202"></a>The function <span class="KeyTerm1">make_machine</span> then extends this basic model (by sending it messages) to include the registers, operations, and controller of the particular machine being defined. First it allocates a register in the new machine for each of the supplied register names and installs the designated operations in the machine. Then it uses an <i>assembler</i> (described below in section 5.2.2) to transform the controller list into instructions for the new machine and installs these as the machine's instruction sequence. The function <span class="KeyTerm1">make_machine</span> returns as its value the modified machine model.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0203"></a><b>function</b> make_machine(register_names, ops, controller) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0204"></a> <b>const</b> machine = make_new_machine();</p>
<p class="Sp-text-1"><a id="c005_c5-para-0205"></a>    for_each(register_name =&gt;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0206"></a>               machine("allocate_register")(register_name),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0207"></a>             register_names);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0208"></a>    machine("install_operations")(ops);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0209"></a>    machine("install_instruction_sequence")</p>
<p class="Sp-text-1"><a id="c005_c5-para-0210"></a>           (assemble(controller, machine));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0211"></a> <b>return</b> machine;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0212"></a>}</p>
<section>
<h5><a id="c005_c5-sec-0021"></a><a id="c005_c5-title-0022"></a>Registers</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0213"></a>We will represent a register as a function with local state, as in chapter 3. The function <span class="KeyTerm1">make_register</span> creates a register that holds a value that can be accessed or changed:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0214"></a><b>function</b> make_register(name) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0215"></a> <b>let</b> contents = "*unassigned*";</p>
<p class="Sp-text-1"><a id="c005_c5-para-0216"></a> <b>function</b> dispatch(message) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0217"></a> <b>return</b> message === "get"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0218"></a>               ? contents</p>
<p class="Sp-text-1"><a id="c005_c5-para-0219"></a>               : message === "set"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0220"></a>               ? value =&gt; { contents = value; }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0221"></a>               : error(message, "unknown request – make_register");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0222"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0223"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0224"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0225"></a>The following functions are used to access registers:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0226"></a><b>function</b> get_contents(register) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0227"></a> <b>return</b> register("get");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0228"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0229"></a><b>function</b> set_contents(register, value) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0230"></a> <b>return</b> register("set")(value);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0231"></a>}</p>
</section>
<section>
<h5><a id="c005_c5-sec-0022"></a><a id="c005_c5-title-0023"></a>The stack</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0232"></a>We can also represent a stack as a function with local state. The function <span class="KeyTerm1">make_ stack</span> creates a stack whose local state consists of a list of the items on the stack. A stack accepts requests to <span class="KeyTerm1">push</span> an item onto the stack, to <span class="KeyTerm1">pop</span> the top item off the stack and return it, and to <span class="KeyTerm1">initialize</span> the stack to empty.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0233"></a><b>function</b> make_stack() {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0234"></a> <b>let</b> stack = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0235"></a> <b>function</b> push(x) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0236"></a>        stack = pair(x, stack);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0237"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c005_c5-para-0238"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0239"></a> <b>function</b> pop() {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0240"></a> <b>if</b> (is_null(stack)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0241"></a>            error("empty stack – pop");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0242"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0243"></a> <b>const</b> top = head(stack);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0244"></a>            stack = tail(stack);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0245"></a> <b>return</b> top;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0246"></a>        }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0247"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0248"></a> <b>function</b> initialize() {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0249"></a>        stack = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0250"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c005_c5-para-0251"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0252"></a> <b>function</b> dispatch(message) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0253"></a> <b>return</b> message === "push"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0254"></a>               ? push</p>
<p class="Sp-text-1"><a id="c005_c5-para-0255"></a>               : message === "pop"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0256"></a>               ? pop()</p>
<p class="Sp-text-1"><a id="c005_c5-para-0257"></a>               : message === "initialize"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0258"></a>               ? initialize()</p>
<p class="Sp-text-1"><a id="c005_c5-para-0259"></a>               : error(message, "unknown request – stack");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0260"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0261"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0262"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0263"></a>The following functions are used to access stacks:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0264"></a><b>function</b> pop(stack) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0265"></a> <b>return</b> stack("pop");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0266"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0267"></a><b>function</b> push(stack, value) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0268"></a> <b>return</b> stack("push")(value);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0269"></a>}</p>
</section>
<section>
<h5><a id="c005_c5-sec-0023"></a><a id="c005_c5-title-0024"></a>The basic machine</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0270"></a>The <span class="KeyTerm1">make_new_machine</span> function, shown in <a id="c005_c5-fig-0013a"></a><a href="#c5-fig-0013">figure 5.13</a>, constructs an object whose local state consists of a stack, an initially empty instruction sequence, a list of operations that initially contains an operation to initialize the stack, and a <i>register table</i> that initially contains two registers, named <span class="KeyTerm1">flag</span> and <span class="KeyTerm1">pc</span> (for “program counter”). The internal function <span class="KeyTerm1">allocate_register</span> adds new entries to the register table, and the internal function <span class="KeyTerm1">lookup_register</span> looks up registers in the table.</p>
<figure id="c005_c5-fig-0013"><img alt="c5-fig-0013.jpg" src="../images/c5-fig-0013.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0013a">Figure 5.13</a></span> <a id="c005_c5-para-0271"></a>The <span class="KeyTerm1">make_new_machine</span> function implements the basic machine model.</p></figcaption></figure>
<p><a id="c005_c5-para-0272"></a>The <span class="KeyTerm1">flag</span> register is used to control branching in the simulated machine. Our <span class="KeyTerm1">test</span> instructions set the contents of <span class="KeyTerm1">flag</span> to the result of the test (true or false). Our <span class="KeyTerm1">branch</span> instructions decide whether or not to branch by examining the contents of <span class="KeyTerm1">flag</span>.</p>
<p><a id="c005_c5-para-0273"></a>The <span class="KeyTerm1">pc</span> register determines the sequencing of instructions as the machine runs. This sequencing is implemented by the internal function <span class="KeyTerm1">execute</span>. In the simulation model, each machine instruction is a data structure that includes a function of no arguments, called the <i>instruction execution function</i>, such that calling this function simulates executing the instruction. As the simulation runs, <span class="KeyTerm1">pc</span> points to the place in the instruction sequence beginning with the next instruction to be executed. The function <span class="KeyTerm1">execute</span> gets that instruction, executes it by calling the instruction execution function, and repeats this cycle until there are no more instructions to execute (i.e., until <span class="KeyTerm1">pc</span> points to the end of the instruction sequence).</p>
<p><a id="c005_c5-para-0274"></a>As part of its operation, each instruction execution function modifies <span class="KeyTerm1">pc</span> to indicate the next instruction to be executed. The instructions <span class="KeyTerm1">branch</span> and <span class="KeyTerm1">go_to</span> change <span class="KeyTerm1">pc</span> to point to the new destination. All other instructions simply advance <span class="KeyTerm1">pc</span>, making it point to the next instruction in the sequence. Observe that each call to <span class="KeyTerm1">execute</span> calls <span class="KeyTerm1">execute</span> again, but this does not produce an infinite loop because running the instruction execution function changes the contents of <span class="KeyTerm1">pc</span>.</p>
<p><a id="c005_c5-para-0275"></a>The function <span class="KeyTerm1">make_new_machine</span> returns a dispatch function that implements message-passing access to the internal state. Notice that starting the machine is accomplished by setting <span class="KeyTerm1">pc</span> to the beginning of the instruction sequence and calling <span class="KeyTerm1">execute</span>.</p>
<p><a id="c005_c5-para-0276"></a>For convenience, we provide an alternate interface to a machine's <span class="KeyTerm1">start</span> operation, as well as functions to set and examine register contents, as specified at the beginning of section 5.2:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0277"></a><b>function</b> start(machine) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0278"></a> <b>return</b> machine("start");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0279"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0280"></a><b>function</b> get_register_contents(machine, register_name) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0281"></a> <b>return</b> get_contents(get_register(machine, register_name));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0282"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0283"></a><b>function</b> set_register_contents(machine, register_name, value) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0284"></a>    set_contents(get_register(machine, register_name), value);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0285"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c005_c5-para-0286"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0287"></a>These functions (and many functions in sections 5.2.2 and 5.2.3) use the following to look up the register with a given name in a given machine:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0288"></a><b>function</b> get_register(machine, reg_name) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0289"></a> <b>return</b> machine("get_register")(reg_name);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0290"></a>}</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0024"></a><span>5.2.2</span> <a id="c005_c5-title-0025"></a>The Assembler</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0291"></a>The assembler transforms the sequence of controller instructions for a machine into a corresponding list of machine instructions, each with its execution function. Overall, the assembler is much like the evaluators we studied in chapter 4—there is an input language (in this case, the register-machine language) and we must perform an appropriate action for each type of component in the language.</p>
<p><a id="c005_c5-para-0292"></a>The technique of producing an execution function for each instruction is just what we used in section 4.1.7 to speed up the evaluator by separating analysis from runtime execution. As we saw in chapter 4, much useful analysis of JavaScript expressions could be performed without knowing the actual values of names. Here, analogously, much useful analysis of register-machine-language expressions can be performed without knowing the actual contents of machine registers. For example, we can replace references to registers by pointers to the register objects, and we can replace references to labels by pointers to the place in the instruction sequence that the label designates.</p>
<p><a id="c005_c5-para-0293"></a>Before it can generate the instruction execution functions, the assembler must know what all the labels refer to, so it begins by scanning the controller sequence to separate the labels from the instructions. As it scans the controller, it constructs both a list of instructions and a table that associates each label with a pointer into that list. Then the assembler augments the instruction list by inserting the execution function for each instruction.</p>
<p><a id="c005_c5-para-0294"></a>The <span class="KeyTerm1">assemble</span> function is the main entry to the assembler. It takes the controller sequence and the machine model as arguments and returns the instruction sequence to be stored in the model. The function <span class="KeyTerm1">assemble</span> calls <span class="KeyTerm1">extract_labels</span> to build the initial instruction list and label table from the supplied controller. The second argument to <span class="KeyTerm1">extract_labels</span> is a function to be called to process these results: This function uses <span class="KeyTerm1">update_insts</span> to generate the instruction execution functions and insert them into the instruction list, and returns the modified list.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0295"></a><b>function</b> assemble(controller, machine) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0296"></a> <b>return</b> extract_labels(controller,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0297"></a>                          (insts, labels) =&gt; {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0298"></a>                              update_insts(insts, labels, machine);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0299"></a> <b>return</b> insts;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0300"></a>                          });</p>
<p class="Sp-text-1"><a id="c005_c5-para-0301"></a>}</p>
<p><a id="c005_c5-para-0302"></a>The function <span class="KeyTerm1">extract_labels</span> takes a list <span class="KeyTerm1">controller</span> and a function <span class="KeyTerm1">receive</span> as arguments. The function <span class="KeyTerm1">receive</span> will be called with two values: (1) a list <span class="KeyTerm1">insts</span> of instruction data structures, each containing an instruction from <span class="KeyTerm1">controller</span>; and (2) a table called <span class="KeyTerm1">labels</span>, which associates each label from <span class="KeyTerm1">controller</span> with the position in the list <span class="KeyTerm1">insts</span> that the label designates.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0303"></a><b>function</b> extract_labels(controller, receive) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0304"></a> <b>return</b> is_null(controller)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0305"></a>           ? receive(<b>null</b>, <b>null</b>)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0306"></a>           : extract_labels(</p>
<p class="Sp-text-1"><a id="c005_c5-para-0307"></a>                 tail(controller),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0308"></a>                 (insts, labels) =&gt; {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0309"></a> <b>const</b> next_element = head(controller);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0310"></a> <b>return</b> is_string(next_element)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0311"></a>                          ? receive(insts,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0312"></a>                                    pair(make_label_entry(next_element,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0313"></a>                                                          insts),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0314"></a>                                         labels))</p>
<p class="Sp-text-1"><a id="c005_c5-para-0315"></a>                          : receive(pair(make_inst(next_element),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0316"></a>                                         insts),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0317"></a>                                    labels);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0318"></a>                 });</p>
<p class="Sp-text-1"><a id="c005_c5-para-0319"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0320"></a>The function <span class="KeyTerm1">extract_labels</span> works by sequentially scanning the elements of the <span class="KeyTerm1">controller</span> and accumulating the <span class="KeyTerm1">insts</span> and the <span class="KeyTerm1">labels</span>. If an element is a string (and thus a label) an appropriate entry is added to the <span class="KeyTerm1">labels</span> table. Otherwise the element is accumulated onto the <span class="KeyTerm1">insts</span> list.<a id="c005_c5-fn-0005a"></a><a href="#c5-fn-0005"><sup>5</sup></a></p>
<p><a id="c005_c5-para-0344"></a>The function <span class="KeyTerm1">update_insts</span> modifies the instruction list, which initially contains only the controller instructions, to include the corresponding execution functions:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0345"></a><b>function</b> update_insts(insts, labels, machine) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0346"></a> <b>const</b> pc = get_register(machine, "pc");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0347"></a> <b>const</b> flag = get_register(machine, "flag");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0348"></a> <b>const</b> stack = machine("stack");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0349"></a> <b>const</b> ops = machine("operations");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0350"></a> <b>return</b> for_each(inst =&gt; set_inst_execution_fun(</p>
<p class="Sp-text-1"><a id="c005_c5-para-0351"></a>                                inst,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0352"></a>                                make_execution_function(</p>
<p class="Sp-text-1"><a id="c005_c5-para-0353"></a>                                    inst_controller_instruction(inst),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0354"></a>                                    labels, machine, pc,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0355"></a>                                    flag, stack, ops)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0356"></a>                    insts);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0357"></a>}</p>
<p><a id="c005_c5-para-0358"></a>The machine instruction data structure simply pairs the controller instruction with the corresponding execution function. The execution function is not yet available when <span class="KeyTerm1">extract_labels</span> constructs the instruction, and is inserted later by <span class="KeyTerm1">update_insts</span>.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0359"></a><b>function</b> make_inst(inst_controller_instruction) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0360"></a> <b>return</b> pair(inst_controller_instruction, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0361"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0362"></a><b>function</b> inst_controller_instruction(inst) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0363"></a> <b>return</b> head(inst);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0364"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0365"></a><b>function</b> inst_execution_fun(inst) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0366"></a> <b>return</b> tail(inst);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0367"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0368"></a><b>function</b> set_inst_execution_fun(inst, fun) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0369"></a>    set_tail(inst, fun);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0370"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0371"></a>The controller instruction is not used by our simulator, but is handy to keep around for debugging (see exercise 5.15).</p>
<p><a id="c005_c5-para-0372"></a>Elements of the label table are pairs:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0373"></a><b>function</b> make_label_entry(label_name, insts) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0374"></a> <b>return</b> pair(label_name, insts);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0375"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0376"></a>Entries will be looked up in the table with</p>
<p class="Sp-text-1"><a id="c005_c5-para-0377"></a><b>function</b> lookup_label(labels, label_name) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0378"></a> <b>const</b> val = assoc(label_name, labels);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0379"></a> <b>return</b> is_undefined(val)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0380"></a>           ? error(label_name, "undefined label – assemble")</p>
<p class="Sp-text-1"><a id="c005_c5-para-0381"></a>           : tail(val);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0382"></a>}</p>
<section>
<h5><a id="c005_c5-sec-0025"></a><a id="c005_c5-title-0026"></a>Exercise 5.8</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0383"></a>The following register-machine code is ambiguous, because the label <span class="KeyTerm1">here</span> is defined more than once:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0384"></a>"start",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0385"></a>  go_to(label("here")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0386"></a>"here",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0387"></a>  assign("a", constant(3)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0388"></a>  go_to(label("there")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0389"></a>"here",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0390"></a>  assign("a", constant(4)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0391"></a>  go_to(label("there")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0392"></a>"there",</p>
<p class="paracontinue"><a id="c005_c5-para-0393"></a>With the simulator as written, what will the contents of register <span class="KeyTerm1">a</span> be when control reaches <span class="KeyTerm1">there</span>? Modify the <span class="KeyTerm1">extract_labels</span> function so that the assembler will signal an error if the same label name is used to indicate two different locations.</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0026"></a><span>5.2.3</span> <a id="c005_c5-title-0027"></a>Instructions and Their Execution Functions</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0394"></a>The assembler calls <span class="KeyTerm1">make_execution_function</span> to generate the execution function for a controller instruction. Like the <span class="KeyTerm1">analyze</span> function in the evaluator of section 4.1.7, this dispatches on the type of instruction to generate the appropriate execution function. The details of these execution functions determine the meaning of the individual instructions in the register-machine language.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0395"></a><b>function</b> make_execution_function(inst, labels, machine,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0396"></a>                                 pc, flag, stack, ops) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0397"></a> <b>const</b> inst_type = type(inst);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0398"></a> <b>return</b> inst_type === "assign"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0399"></a>           ? make_assign_ef(inst, machine, labels, ops, pc)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0400"></a>           : inst_type === "test"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0401"></a>           ? make_test_ef(inst, machine, labels, ops, flag, pc)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0402"></a>           : inst_type === "branch"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0403"></a>           ? make_branch_ef(inst, machine, labels, flag, pc)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0404"></a>           : inst_type === "go_to"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0405"></a>           ? make_go_to_ef(inst, machine, labels, pc)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0406"></a>           : inst_type === "save"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0407"></a>           ? make_save_ef(inst, machine, stack, pc)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0408"></a>           : inst_type === "restore"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0409"></a>           ? make_restore_ef(inst, machine, stack, pc)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0410"></a>           : inst_type === "perform"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0411"></a>           ? make_perform_ef(inst, machine, labels, ops, pc)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0412"></a>           : error(inst, "unknown instruction type – assemble");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0413"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0414"></a>The elements of the <span class="KeyTerm1">controller</span> sequence received by <span class="KeyTerm1">make_machine</span> and passed to <span class="KeyTerm1">assemble</span> are strings (for labels) and tagged lists (for instructions). The tag in an instruction is a string that identifies the instruction type, such as <span class="KeyTerm1">"go_to"</span>, and the remaining elements of the list contains the arguments, such as the destination of the <span class="KeyTerm1">go_to</span>. The dispatch in <span class="KeyTerm1">make_execution_function</span> uses</p>
<p class="Sp-text-1"><a id="c005_c5-para-0415"></a><b>function</b> type(instruction) { <b>return</b> head(instruction); }</p>
<p><a id="c005_c5-para-0416"></a>The tagged lists are constructed when the <span class="KeyTerm1">list</span> expression that is the third argument to <span class="KeyTerm1">make_machine</span> is evaluated. Each argument to that <span class="KeyTerm1">list</span> is either a string (which evaluates to itself) or a call to a constructor for an instruction tagged list. For example, <span class="KeyTerm1">assign("b", reg("t"))</span> calls the constructor <span class="KeyTerm1">assign</span> with arguments <span class="KeyTerm1">"b"</span> and the result of calling the constructor <span class="KeyTerm1">reg</span> with the argument <span class="KeyTerm1">"t"</span>. The constructors and their arguments determine the syntax of the individual instructions in the register-machine language. The instruction constructors and selectors are shown below, along with the execution-function generators that use the selectors.</p>
<section>
<h5><a id="c005_c5-sec-0027"></a><a id="c005_c5-title-0028"></a>The instruction <span class="KeyTerm1"><b>assign</b></span></h5>
<p class="paraaftertitle"><a id="c005_c5-para-0417"></a>The <span class="KeyTerm1">make_assign_ef</span> function makes execution functions for <span class="KeyTerm1">assign</span> instructions:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0418"></a><b>function</b> make_assign_ef(inst, machine, labels, operations, pc) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0419"></a> <b>const</b> target = get_register(machine, assign_reg_name(inst));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0420"></a> <b>const</b> value_exp = assign_value_exp(inst);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0421"></a> <b>const</b> value_fun =</p>
<p class="Sp-text-1"><a id="c005_c5-para-0422"></a>        is_operation_exp(value_exp)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0423"></a>        ? make_operation_exp_ef(value_exp, machine, labels, operations)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0424"></a>        : make_primitive_exp_ef(value_exp, machine, labels);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0425"></a> <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0426"></a>               set_contents(target, value_fun());</p>
<p class="Sp-text-1"><a id="c005_c5-para-0427"></a>               advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0428"></a>           };</p>
<p class="Sp-text-1"><a id="c005_c5-para-0429"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0430"></a>The function <span class="KeyTerm1">assign</span> constructs <span class="KeyTerm1">assign</span> instructions. The selectors <span class="KeyTerm1">assign_reg_ name</span> and <span class="KeyTerm1">assign_value_exp</span> extract the register name and value expression from an <span class="KeyTerm1">assign</span> instruction.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0431"></a><b>function</b> assign(register_name, source) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0432"></a> <b>return</b> list("assign", register_name, source);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0433"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0434"></a><b>function</b> assign_reg_name(assign_instruction) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0435"></a> <b>return</b> head(tail(assign_instruction));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0436"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0437"></a><b>function</b> assign_value_exp(assign_instruction) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0438"></a> <b>return</b> head(tail(tail(assign_instruction)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0439"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0440"></a>The function <span class="KeyTerm1">make_assign_ef</span> looks up the register name with <span class="KeyTerm1">get_register</span> to produce the target register object. The value expression is passed to <span class="KeyTerm1">make_ operation_exp_ef</span> if the value is the result of an operation, and it is passed to <span class="KeyTerm1">make_primitive_exp_ef</span> otherwise. These functions (shown below) analyze the value expression and produce an execution function for the value. This is a function of no arguments, called <span class="KeyTerm1">value_fun</span>, which will be evaluated during the simulation to produce the actual value to be assigned to the register. Notice that the work of looking up the register name and analyzing the value expression is performed just once, at assembly time, not every time the instruction is simulated. This saving of work is the reason we use execution functions, and corresponds directly to the saving in work we obtained by separating program analysis from execution in the evaluator of section 4.1.7.</p>
<p><a id="c005_c5-para-0441"></a>The result returned by <span class="KeyTerm1">make_assign_ef</span> is the execution function for the <span class="KeyTerm1">assign</span> instruction. When this function is called (by the machine model's <span class="KeyTerm1">execute</span> function), it sets the contents of the target register to the result obtained by executing <span class="KeyTerm1">value_fun</span>. Then it advances the <span class="KeyTerm1">pc</span> to the next instruction by running the function</p>
<p class="Sp-text-1"><a id="c005_c5-para-0442"></a><b>function</b> advance_pc(pc) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0443"></a>    set_contents(pc, tail(get_contents(pc)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0444"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0445"></a>The function <span class="KeyTerm1">advance_pc</span> is the normal termination for all instructions except <span class="KeyTerm1">branch</span> and <span class="KeyTerm1">go_to</span>.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0028"></a><a id="c005_c5-title-0029"></a>The instructions <span class="KeyTerm1"><b>test</b></span>, <span class="KeyTerm1"><b>branch</b></span>, and <span class="KeyTerm1"><b>go_to</b></span></h5>
<p class="paraaftertitle"><a id="c005_c5-para-0446"></a>The function <span class="KeyTerm1">make_test_ef</span> handles <span class="KeyTerm1">test</span> instructions in a similar way. It extracts the expression that specifies the condition to be tested and generates an execution function for it. At simulation time, the function for the condition is called, the result is assigned to the <span class="KeyTerm1">flag</span> register, and the <span class="KeyTerm1">pc</span> is advanced:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0447"></a><b>function</b> make_test_ef(inst, machine, labels, operations, flag, pc) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0448"></a> <b>const</b> condition = test_condition(inst);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0449"></a> <b>if</b> (is_operation_exp(condition)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0450"></a> <b>const</b> condition_fun = make_operation_exp_ef(</p>
<p class="Sp-text-1"><a id="c005_c5-para-0451"></a>                                  condition, machine,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0452"></a>                                  labels, operations);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0453"></a> <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0454"></a>                   set_contents(flag, condition_fun());</p>
<p class="Sp-text-1"><a id="c005_c5-para-0455"></a>                   advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0456"></a>               };</p>
<p class="Sp-text-1"><a id="c005_c5-para-0457"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0458"></a>        error(inst, "bad test instruction – assemble");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0459"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0460"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0461"></a>The function <span class="KeyTerm1">test</span> constructs <span class="KeyTerm1">test</span> instructions. The selector <span class="KeyTerm1">test_condition</span> extracts the condition from a test.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0462"></a><b>function</b> test(condition) { <b>return</b> list("test", condition); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0463"></a><b>function</b> test_condition(test_instruction) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0464"></a> <b>return</b> head(tail(test_instruction));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0465"></a>}</p>
<p><a id="c005_c5-para-0466"></a>The execution function for a <span class="KeyTerm1">branch</span> instruction checks the contents of the <span class="KeyTerm1">flag</span> register and either sets the contents of the <span class="KeyTerm1">pc</span> to the branch destination (if the branch is taken) or else just advances the <span class="KeyTerm1">pc</span> (if the branch is not taken). Notice that the indicated destination in a <span class="KeyTerm1">branch</span> instruction must be a label, and the <span class="KeyTerm1">make_branch_ef</span> function enforces this. Notice also that the label is looked up at assembly time, not each time the <span class="KeyTerm1">branch</span> instruction is simulated.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0467"></a><b>function</b> make_branch_ef(inst, machine, labels, flag, pc) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0468"></a> <b>const</b> dest = branch_dest(inst);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0469"></a> <b>if</b> (is_label_exp(dest)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0470"></a> <b>const</b> insts = lookup_label(labels, label_exp_label(dest));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0471"></a> <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0472"></a> <b>if</b> (get_contents(flag)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0473"></a>                       set_contents(pc, insts);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0474"></a>                   } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0475"></a>                       advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0476"></a>                   }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0477"></a>               };</p>
<p class="Sp-text-1"><a id="c005_c5-para-0478"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0479"></a>        error(inst, "bad branch instruction – assemble");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0480"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0481"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0482"></a>The function <span class="KeyTerm1">branch</span> constructs <span class="KeyTerm1">branch</span> instructions. The selector <span class="KeyTerm1">branch_dest</span> extracts the destination from a branch.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0483"></a><b>function</b> branch(label) { <b>return</b> list("branch", label); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0484"></a><b>function</b> branch_dest(branch_instruction) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0485"></a> <b>return</b> head(tail(branch_instruction));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0486"></a>}</p>
<p><a id="c005_c5-para-0487"></a>A <span class="KeyTerm1">go_to</span> instruction is similar to a branch, except that the destination may be specified either as a label or as a register, and there is no condition to check—the <span class="KeyTerm1">pc</span> is always set to the new destination.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0488"></a><b>function</b> make_go_to_ef(inst, machine, labels, pc) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0489"></a> <b>const</b> dest = go_to_dest(inst);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0490"></a> <b>if</b> (is_label_exp(dest)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0491"></a> <b>const</b> insts = lookup_label(labels, label_exp_label(dest));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0492"></a> <b>return</b> () =&gt; set_contents(pc, insts);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0493"></a>    } <b>else if</b> (is_register_exp(dest)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0494"></a> <b>const</b> reg = get_register(machine, register_exp_reg(dest));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0495"></a> <b>return</b> () =&gt; set_contents(pc, get_contents(reg));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0496"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0497"></a>        error(inst, "bad go_to instruction – assemble");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0498"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0499"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0500"></a>The function <span class="KeyTerm1">go_to</span> constructs <span class="KeyTerm1">go_to</span> instructions. The selector <span class="KeyTerm1">go_to_dest</span> extracts the destination from a <span class="KeyTerm1">go_to</span> instruction.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0501"></a><b>function</b> go_to(label) { <b>return</b> list("go_to", label); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0502"></a><b>function</b> go_to_dest(go_to_instruction) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0503"></a> <b>return</b> head(tail(go_to_instruction));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0504"></a>}</p>
</section>
<section>
<h5><a id="c005_c5-sec-0029"></a><a id="c005_c5-title-0030"></a>Other instructions</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0505"></a>The stack instructions <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> simply use the stack with the designated register and advance the <span class="KeyTerm1">pc</span>:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0506"></a><b>function</b> make_save_ef(inst, machine, stack, pc) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0507"></a> <b>const</b> reg = get_register(machine, stack_inst_reg_name(inst));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0508"></a> <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0509"></a>               push(stack, get_contents(reg));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0510"></a>               advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0511"></a>           };</p>
<p class="Sp-text-1"><a id="c005_c5-para-0512"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0513"></a><b>function</b> make_restore_ef(inst, machine, stack, pc) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0514"></a> <b>const</b> reg = get_register(machine, stack_inst_reg_name(inst));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0515"></a> <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0516"></a>               set_contents(reg, pop(stack));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0517"></a>               advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0518"></a>           };</p>
<p class="Sp-text-1"><a id="c005_c5-para-0519"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0520"></a>The functions <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> construct <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> instructions. The selector <span class="KeyTerm1">stack_inst_reg_name</span> extracts the register name from such instructions.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0521"></a><b>function</b> save(reg) { <b>return</b> list("save", reg); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0522"></a><b>function</b> restore(reg) { <b>return</b> list("restore", reg); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0523"></a><b>function</b> stack_inst_reg_name(stack_instruction) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0524"></a> <b>return</b> head(tail(stack_instruction));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0525"></a>}</p>
<p><a id="c005_c5-para-0526"></a>The final instruction type, handled by <span class="KeyTerm1">make_perform_ef</span>, generates an execution function for the action to be performed. At simulation time, the action function is executed and the <span class="KeyTerm1">pc</span> advanced.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0527"></a><b>function</b> make_perform_ef(inst, machine, labels, operations, pc) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0528"></a> <b>const</b> action = perform_action(inst);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0529"></a> <b>if</b> (is_operation_exp(action)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0530"></a> <b>const</b> action_fun = make_operation_exp_ef(action, machine,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0531"></a>                                                 labels, operations);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0532"></a> <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0533"></a>                   action_fun();</p>
<p class="Sp-text-1"><a id="c005_c5-para-0534"></a>                   advance_pc(pc);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0535"></a>               };</p>
<p class="Sp-text-1"><a id="c005_c5-para-0536"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0537"></a>        error(inst, "bad perform instruction – assemble");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0538"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0539"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0540"></a>The function <span class="KeyTerm1">perform</span> constructs <span class="KeyTerm1">perform</span> instructions. The selector <span class="KeyTerm1">perform_ action</span> extracts the action from a <span class="KeyTerm1">perform</span> instruction.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0541"></a><b>function</b> perform(action) { <b>return</b> list("perform", action); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0542"></a><b>function</b> perform_action(perform_instruction) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0543"></a> <b>return</b> head(tail(perform_instruction));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0544"></a>}</p>
</section>
<section>
<h5><a id="c005_c5-sec-0030"></a><a id="c005_c5-title-0031"></a>Execution functions for subexpressions</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0545"></a>The value of a <span class="KeyTerm1">reg</span>, <span class="KeyTerm1">label</span>, or <span class="KeyTerm1">constant</span> expression may be needed for assignment to a register (<span class="KeyTerm1">make_assign_ef</span>, above) or for input to an operation (<span class="KeyTerm1">make_ operation_exp_ef</span>, below). The following function generates execution functions to produce values for these expressions during the simulation:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0546"></a><b>function</b> make_primitive_exp_ef(exp, machine, labels) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0547"></a> <b>if</b> (is_constant_exp(exp)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0548"></a> <b>const</b> c = constant_exp_value(exp);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0549"></a> <b>return</b> () =&gt; c;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0550"></a>    } <b>else if</b> (is_label_exp(exp)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0551"></a> <b>const</b> insts = lookup_label(labels, label_exp_label(exp));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0552"></a> <b>return</b> () =&gt; insts;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0553"></a>    } <b>else if</b> (is_register_exp(exp)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0554"></a> <b>const</b> r = get_register(machine, register_exp_reg(exp));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0555"></a> <b>return</b> () =&gt; get_contents(r);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0556"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0557"></a>        error(exp, "unknown expression type – assemble");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0558"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0559"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0560"></a>The syntax of <span class="KeyTerm1">reg</span>, <span class="KeyTerm1">label</span>, and <span class="KeyTerm1">constant</span> expressions is determined by the following constructor functions, along with corresponding predicates and selectors.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0561"></a><b>function</b> reg(name) { <b>return</b> list("reg", name); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0562"></a><b>function</b> is_register_exp(exp) { <b>return</b> is_tagged_list(exp, "reg"); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0563"></a><b>function</b> register_exp_reg(exp) { <b>return</b> head(tail(exp)); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0564"></a><b>function</b> constant(value) { <b>return</b> list("constant", value); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0565"></a><b>function</b> is_constant_exp(exp) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0566"></a> <b>return</b> is_tagged_list(exp, "constant");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0567"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0568"></a><b>function</b> constant_exp_value(exp) { <b>return</b> head(tail(exp)); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0569"></a><b>function</b> label(name) { <b>return</b> list("label", name); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0570"></a><b>function</b> is_label_exp(exp) { <b>return</b> is_tagged_list(exp, "label"); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0571"></a><b>function</b> label_exp_label(exp) { <b>return</b> head(tail(exp)); }</p>
<p><a id="c005_c5-para-0572"></a>The instructions <span class="KeyTerm1">assign</span>, <span class="KeyTerm1">perform</span>, and <span class="KeyTerm1">test</span> may include the application of a machine operation (specified by an <span class="KeyTerm1">op</span> expression) to some operands (specified by <span class="KeyTerm1">reg</span> and <span class="KeyTerm1">constant</span> expressions). The following function produces an execution function for an “operation expression”—a list containing the operation and operand expressions from the instruction:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0573"></a><b>function</b> make_operation_exp_ef(exp, machine, labels, operations) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0574"></a> <b>const</b> op = lookup_prim(operation_exp_op(exp), operations);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0575"></a> <b>const</b> afuns = map(e =&gt; make_primitive_exp_ef(e, machine, labels),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0576"></a>                      operation_exp_operands(exp));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0577"></a> <b>return</b> () =&gt; apply_in_underlying_javascript(</p>
<p class="Sp-text-1"><a id="c005_c5-para-0578"></a>                     op, map(f =&gt; f(), afuns));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0579"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-0580"></a>The syntax of operation expressions is determined by</p>
<p class="Sp-text-1"><a id="c005_c5-para-0581"></a><b>function</b> op(name) { <b>return</b> list("op", name); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0582"></a><b>function</b> is_operation_exp(exp) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0583"></a> <b>return</b> is_pair(exp) &amp;&amp; is_tagged_list(head(exp), "op");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0584"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-0585"></a><b>function</b> operation_exp_op(op_exp) { <b>return</b> head(tail(head(op_exp))); }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0586"></a><b>function</b> operation_exp_operands(op_exp) { <b>return</b> tail(op_exp); }</p>
<p class="paracontinue"><a id="c005_c5-para-0587"></a>Observe that the treatment of operation expressions is very much like the treatment of function applications by the <span class="KeyTerm1">analyze_application</span> function in the evaluator of section 4.1.7 in that we generate an execution function for each operand. At simulation time, we call the operand functions and apply the JavaScript function that simulates the operation to the resulting values. We make use of the function <span class="KeyTerm1">apply_in_underlying_javascript</span>, as we did in <span class="KeyTerm1">apply_primitive_function</span> in section 4.1.4. This is needed to apply <span class="KeyTerm1">op</span> to all elements of the argument list <span class="KeyTerm1">afuns</span> produced by the first <span class="KeyTerm1">map</span>, as if they were separate arguments to <span class="KeyTerm1">op</span>. Without this, <span class="KeyTerm1">op</span> would have been restricted to be a unary function.</p>
<p><a id="c005_c5-para-0588"></a>The simulation function is found by looking up the operation name in the operation table for the machine:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0589"></a><b>function</b> lookup_prim(symbol, operations) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0590"></a> <b>const</b> val = assoc(symbol, operations);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0591"></a> <b>return</b> is_undefined(val)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0592"></a>           ? error(symbol, "unknown operation – assemble")</p>
<p class="Sp-text-1"><a id="c005_c5-para-0593"></a>           : head(tail(val));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0594"></a>}</p>
</section>
<section>
<h5><a id="c005_c5-sec-0031"></a><a id="c005_c5-title-0032"></a>Exercise 5.9</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0595"></a>The treatment of machine operations above permits them to operate on labels as well as on constants and the contents of registers. Modify the expression-processing functions to enforce the condition that operations can be used only with registers and constants.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0032"></a><a id="c005_c5-title-0033"></a>Exercise 5.10</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0596"></a>When we introduced <span class="KeyTerm1">save</span> and restore in section 5.1.4, we didn't specify what would happen if you tried to restore a register that was not the last one saved, as in the sequence</p>
<p class="Sp-text-1"><a id="c005_c5-para-0597"></a>save(y);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0598"></a>save(x);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0599"></a>restore(y);</p>
<p class="paracontinue"><a id="c005_c5-para-0600"></a>There are several reasonable possibilities for the meaning of <span class="KeyTerm1">restore</span>:</p>
<ol class="BS_NumberListA">
<li><a id="c005_c5-li-0013"></a><span>a. </span><span class="KeyTerm1">restore(y)</span> puts into <span class="KeyTerm1">y</span> the last value saved on the stack, regardless of what register that value came from. This is the way our simulator behaves. Show how to take advantage of this behavior to eliminate one instruction from the Fibonacci machine of section 5.1.4 (<a href="#c5-fig-0012">figure 5.12</a>).</li>
<li><a id="c005_c5-li-0014"></a><span>b. </span><span class="KeyTerm1">restore(y)</span> puts into <span class="KeyTerm1">y</span> the last value saved on the stack, but only if that value was saved from <span class="KeyTerm1">y</span>; otherwise, it signals an error. Modify the simulator to behave this way. You will have to change <span class="KeyTerm1">save</span> to put the register name on the stack along with the value.</li>
<li><a id="c005_c5-li-0015"></a><span>c. </span><span class="KeyTerm1">restore(y)</span> puts into <span class="KeyTerm1">y</span> the last value saved from <span class="KeyTerm1">y</span> regardless of what other registers were saved after <span class="KeyTerm1">y</span> and not restored. Modify the simulator to behave this way. You will have to associate a separate stack with each register. You should make the <span class="KeyTerm1">initialize_stack</span> operation initialize all the register stacks.</li>
</ol>
</section>
<section>
<h5><a id="c005_c5-sec-0033"></a><a id="c005_c5-title-0034"></a>Exercise 5.11</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0604"></a>The simulator can be used to help determine the data paths required for implementing a machine with a given controller. Extend the assembler to store the following information in the machine model:</p>
<ul style="list-style-type:disc">
<li>a list of all instructions, with duplicates removed, sorted by instruction type (<span class="KeyTerm1">assign</span>, <span class="KeyTerm1">go_to</span>, and so on);</li>
<li>a list (without duplicates) of the registers used to hold entry points (these are the registers referenced by <span class="KeyTerm1">go_to</span> instructions);</li>
<li>a list (without duplicates) of the registers that are <span class="KeyTerm1">save</span>d or <span class="KeyTerm1">restore</span>d;</li>
<li>for each register, a list (without duplicates) of the sources from which it is assigned (for example, the sources for register <span class="KeyTerm1">val</span> in the factorial machine of <a href="#c5-fig-0011">figure 5.11</a> are <span class="KeyTerm1">constant(1)</span> and <span class="KeyTerm1">list(op("*"), reg("n"), reg("val"))</span>).</li>
</ul>
<p class="paracontinue"><a id="c005_c5-para-0609"></a>Extend the message-passing interface to the machine to provide access to this new information. To test your analyzer, define the Fibonacci machine from <a href="#c5-fig-0012">figure 5.12</a> and examine the lists you constructed.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0034"></a><a id="c005_c5-title-0035"></a>Exercise 5.12</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0610"></a>Modify the simulator so that it uses the controller sequence to determine what registers the machine has rather than requiring a list of registers as an argument to <span class="KeyTerm1">make_machine</span>. Instead of preallocating the registers in <span class="KeyTerm1">make_machine</span>, you can allocate them one at a time when they are first seen during assembly of the instructions.</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0035"></a><span>5.2.4</span> <a id="c005_c5-title-0036"></a>Monitoring Machine Performance</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0611"></a>Simulation is useful not only for verifying the correctness of a proposed machine design but also for measuring the machine's performance. For example, we can install in our simulation program a “meter” that measures the number of stack operations used in a computation. To do this, we modify our simulated stack to keep track of the number of times registers are saved on the stack and the maximum depth reached by the stack, and add a message to the stack's interface that prints the statistics, as shown below. We also add an operation to the basic machine model to print the stack statistics, by initializing <span class="KeyTerm1">the_ops</span> in <span class="KeyTerm1">make_new_machine</span> to</p>
<p class="Sp-text-1"><a id="c005_c5-para-0612"></a>list(list("initialize_stack",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0613"></a>          () =&gt; stack("initialize")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0614"></a>     list("print_stack_statistics",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0615"></a>          () =&gt; stack("print_statistics")));</p>
<p class="paracontinue"><a id="c005_c5-para-0616"></a>Here is the new version of <span class="KeyTerm1">make_stack</span>:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0617"></a><b>function</b> make_stack() {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0618"></a> <b>let</b> stack = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0619"></a> <b>let</b> number_pushes = 0;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0620"></a> <b>let</b> max_depth = 0;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0621"></a> <b>let</b> current_depth = 0;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0622"></a> <b>function</b> push(x) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0623"></a>        stack = pair(x, stack);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0624"></a>        number_pushes = number_pushes + 1;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0625"></a>        current_depth = current_depth + 1;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0626"></a>        max_depth = math_max(current_depth, max_depth);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0627"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c005_c5-para-0628"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0629"></a> <b>function</b> pop() {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0630"></a> <b>if</b> (is_null(stack)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0631"></a>            error("empty stack – pop");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0632"></a>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0633"></a> <b>const</b> top = head(stack);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0634"></a>            stack = tail(stack);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0635"></a>            current_depth = current_depth - 1;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0636"></a> <b>return</b> top;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0637"></a>        }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0638"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0639"></a> <b>function</b> initialize() {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0640"></a>        stack = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0641"></a>        number_pushes = 0;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0642"></a>        max_depth = 0;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0643"></a>        current_depth = 0;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0644"></a> <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c005_c5-para-0645"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0646"></a> <b>function</b> print_statistics() {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0647"></a>        display("total pushes = " + stringify(number_pushes));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0648"></a>        display("maximum depth = " + stringify(max_depth));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0649"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0650"></a> <b>function</b> dispatch(message) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0651"></a> <b>return</b> message === "push"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0652"></a>               ? push</p>
<p class="Sp-text-1"><a id="c005_c5-para-0653"></a>               : message === "pop"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0654"></a>               ? pop()</p>
<p class="Sp-text-1"><a id="c005_c5-para-0655"></a>               : message === "initialize"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0656"></a>               ? initialize()</p>
<p class="Sp-text-1"><a id="c005_c5-para-0657"></a>               : message === "print_statistics"</p>
<p class="Sp-text-1"><a id="c005_c5-para-0658"></a>               ? print_statistics()</p>
<p class="Sp-text-1"><a id="c005_c5-para-0659"></a>               : error(message, "unknown request – stack");</p>
<p class="Sp-text-1"><a id="c005_c5-para-0660"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0661"></a> <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c005_c5-para-0662"></a>}</p>
<p><a id="c005_c5-para-0663"></a>Exercises 5.14 through 5.18 describe other useful monitoring and debugging features that can be added to the register-machine simulator.</p>
<section>
<h5><a id="c005_c5-sec-0036"></a><a id="c005_c5-title-0037"></a>Exercise 5.13</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0664"></a>Measure the number of pushes and the maximum stack depth required to compute <i>n</i>! for various small values of <i>n</i> using the factorial machine shown in <a href="#c5-fig-0011">Figure 5.11</a>. From your data determine formulas in terms of <i>n</i> for the total number of push operations and the maximum stack depth used in computing <i>n</i>! for any <i>n</i> &gt; 1. Note that each of these is a linear function of <i>n</i> and is thus determined by two constants. In order to get the statistics printed, you will have to augment the factorial machine with instructions to initialize the stack and print the statistics. You may want to also modify the machine so that it repeatedly reads a value for <i>n</i>, computes the factorial, and prints the result (as we did for the GCD machine in <a href="#c5-fig-0004">figure 5.4</a>), so that you will not have to repeatedly invoke <span class="KeyTerm1">get_register_contents</span>, <span class="KeyTerm1">set_register_contents</span>, and <span class="KeyTerm1">start</span>.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0037"></a><a id="c005_c5-title-0038"></a>Exercise 5.14</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0665"></a>Add <i>instruction counting</i> to the register machine simulation. That is, have the machine model keep track of the number of instructions executed. Extend the machine model's interface to accept a new message that prints the value of the instruction count and resets the count to zero.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0038"></a><a id="c005_c5-title-0039"></a>Exercise 5.15</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0666"></a>Augment the simulator to provide for <i>instruction tracing</i>. That is, before each instruction is executed, the simulator should print the instruction. Make the machine model accept <span class="KeyTerm1">trace_on</span> and <span class="KeyTerm1">trace_off</span> messages to turn tracing on and off.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0039"></a><a id="c005_c5-title-0040"></a>Exercise 5.16</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0667"></a>Extend the instruction tracing of exercise 5.15 so that before printing an instruction, the simulator prints any labels that immediately precede that instruction in the controller sequence. Be careful to do this in a way that does not interfere with instruction counting (exercise 5.14). You will have to make the simulator retain the necessary label information.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0040"></a><a id="c005_c5-title-0041"></a>Exercise 5.17</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0668"></a>Modify the <span class="KeyTerm1">make_register</span> function of section 5.2.1 so that registers can be traced. Registers should accept messages that turn tracing on and off. When a register is traced, assigning a value to the register should print the name of the register, the old contents of the register, and the new contents being assigned. Extend the interface to the machine model to permit you to turn tracing on and off for designated machine registers.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0041"></a><a id="c005_c5-title-0042"></a>Exercise 5.18</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0669"></a>Alyssa P. Hacker wants a <i>breakpoint</i> feature in the simulator to help her debug her machine designs. You have been hired to install this feature for her. She wants to be able to specify a place in the controller sequence where the simulator will stop and allow her to examine the state of the machine. You are to implement a function</p>
<p class="Sp-text-1"><a id="c005_c5-para-0670"></a>set_breakpoint(<span class="KeyTerm2"><i>machine</i></span>, <span class="KeyTerm2"><i>label</i></span>, <span class="KeyTerm2"><i>n</i></span>)</p>
<p class="paracontinue"><a id="c005_c5-para-0671"></a>that sets a breakpoint just before the <i>n</i>th instruction after the given label. For example,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0672"></a>set_breakpoint(gcd_machine, "test_b", 4)</p>
<p class="paracontinue"><a id="c005_c5-para-0673"></a>installs a breakpoint in <span class="KeyTerm1">gcd_machine</span> just before the assignment to register <span class="KeyTerm1">a</span>. When the simulator reaches the breakpoint it should print the label and the offset of the breakpoint and stop executing instructions. Alyssa can then use <span class="KeyTerm1">get_register_contents</span> and <span class="KeyTerm1">set_register_contents</span> to manipulate the state of the simulated machine. She should then be able to continue execution by saying</p>
<p class="Sp-text-1"><a id="c005_c5-para-0674"></a>proceed_machine(<span class="KeyTerm2"><i>machine</i></span>)</p>
<p class="paracontinue"><a id="c005_c5-para-0675"></a>She should also be able to remove a specific breakpoint by means of</p>
<p class="Sp-text-1"><a id="c005_c5-para-0676"></a>cancel_breakpoint(<span class="KeyTerm2"><i>machine</i></span>, <span class="KeyTerm2"><i>label</i></span>, <span class="KeyTerm2"><i>n</i></span>)</p>
<p class="paracontinue"><a id="c005_c5-para-0677"></a>or to remove all breakpoints by means of</p>
<p class="Sp-text-1"><a id="c005_c5-para-0678"></a>cancel_all_breakpoints(<span class="KeyTerm2"><i>machine</i></span>)</p>
</section>
</section>
</section>
<section>
<h2><a id="c005_c5-sec-0042"></a><span>5.3</span> <a id="c005_c5-title-0043"></a>Storage Allocation and Garbage Collection</h2>
<p class="paraaftertitle"><a id="c005_c5-para-0679"></a>In section 5.4, we will show how to implement a JavaScript evaluator as a register machine. In order to simplify the discussion, we will assume that our register machines can be equipped with a <i>list-structured memory</i>, in which the basic operations for manipulating list-structured data are primitive. Postulating the existence of such a memory is a useful abstraction when one is focusing on the mechanisms of control in an interpreter, but this does not reflect a realistic view of the actual primitive data operations of contemporary computers. To obtain a more complete picture of how systems can support list-structured memory efficiently, we must investigate how list structure can be represented in a way that is compatible with conventional computer memories.</p>
<p><a id="c005_c5-para-0680"></a>There are two considerations in implementing list structure. The first is purely an issue of representation: how to represent the “box-and-pointer” structure of pairs, using only the storage and addressing capabilities of typical computer memories. The second issue concerns the management of memory as a computation proceeds. The operation of a JavaScript system depends crucially on the ability to continually create new data objects. These include objects that are explicitly created by the JavaScript functions being interpreted as well as structures created by the interpreter itself, such as environments and argument lists. Although the constant creation of new data objects would pose no problem on a computer with an infinite amount of rapidly addressable memory, computer memories are available only in finite sizes (more's the pity). JavaScript thus provide an <i>automatic storage allocation</i> facility to support the illusion of an infinite memory. When a data object is no longer needed, the memory allocated to it is automatically recycled and used to construct new data objects. There are various techniques for providing such automatic storage allocation. The method we shall discuss in this section is called <i>garbage collection</i>.</p>
<section>
<h3><a id="c005_c5-sec-0043"></a><span>5.3.1</span> <a id="c005_c5-title-0044"></a>Memory as Vectors</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0681"></a>A conventional computer memory can be thought of as an array of cubbyholes, each of which can contain a piece of information. Each cubbyhole has a unique name, called its <i>address</i> or <i>location</i>. Typical memory systems provide two primitive operations: one that fetches the data stored in a specified location and one that assigns new data to a specified location. Memory addresses can be incremented to support sequential access to some set of the cubbyholes. More generally, many important data operations require that memory addresses be treated as data, which can be stored in memory locations and manipulated in machine registers. The representation of list structure is one application of such <i>address arithmetic</i>.</p>
<p><a id="c005_c5-para-0682"></a>To model computer memory, we use a new kind of data structure called a <i>vector</i>. Abstractly, a vector is a compound data object whose individual elements can be accessed by means of an integer index in an amount of time that is independent of the index.<a id="c005_c5-fn-0006a"></a><a href="#c5-fn-0006"><sup>6</sup></a> In order to describe memory operations, we use two functions for manipulating vectors:<a id="c005_c5-fn-0007a"></a><a href="#c5-fn-0007"><sup>7</sup></a></p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">vector_ref</span>(<i>vector</i>, <i>n</i>) returns the <i>n</i>th element of the vector.</li>
<li><span class="KeyTerm1">vector_set</span>(<i>vector</i>, <i>n</i>, <i>value</i>) sets the <i>n</i>th element of the vector to the designated value.</li>
</ul>
<p class="paracontinue"><a id="c005_c5-para-0685"></a>For example, if <span class="KeyTerm1">v</span> is a vector, then <span class="KeyTerm1">vector_ref(v, 5)</span> gets the fifth entry in the vector <span class="KeyTerm1">v</span> and <span class="KeyTerm1">vector_set(v, 5, 7)</span> changes the value of the fifth entry of the vector <span class="KeyTerm1">v</span> to 7.<a id="c005_c5-fn-0008a"></a><a href="#c5-fn-0008"><sup>8</sup></a> For computer memory, this access can be implemented through the use of address arithmetic to combine a <i>base address</i> that specifies the beginning location of a vector in memory with an <i>index</i> that specifies the offset of a particular element of the vector.</p>
<section>
<h5><a id="c005_c5-sec-0044"></a><a id="c005_c5-title-0045"></a>Representing data</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0686"></a>We can use vectors to implement the basic pair structures required for a list-structured memory. Let us imagine that computer memory is divided into two vectors: <span class="KeyTerm1">the_heads</span> and <span class="KeyTerm1">the_tails</span>. We will represent list structure as follows: A pointer to a pair is an index into the two vectors. The <span class="KeyTerm1">head</span> of the pair is the entry in <span class="KeyTerm1">the_heads</span> with the designated index, and the tail of the pair is the entry in <span class="KeyTerm1">the_tails</span> with the designated index. We also need a representation for objects other than pairs (such as numbers and strings) and a way to distinguish one kind of data from another. There are many methods of accomplishing this, but they all reduce to using <i>typed pointers</i>, that is, to extending the notion of “pointer” to include information on data type.<a id="c005_c5-fn-0009a"></a><a href="#c5-fn-0009"><sup>9</sup></a> The data type enables the system to distinguish a pointer to a pair (which consists of the “pair” data type and an index into the memory vectors) from pointers to other kinds of data (which consist of some other data type and whatever is being used to represent data of that type). Two data objects are considered to be the same (<span class="KeyTerm1">===</span>) if their pointers are identical. <a id="c005_c5-fig-0014a"></a><a href="#c5-fig-0014">Figure 5.14</a> illustrates the use of this method to represent <span class="KeyTerm1">list(list(1, 2), 3, 4)</span>, whose box-and-pointer diagram is also shown. We use letter prefixes to denote the data-type information. Thus, a pointer to the pair with index 5 is denoted <span class="KeyTerm1">p5</span>, the empty list is denoted by the pointer <span class="KeyTerm1">e0</span>, and a pointer to the number 4 is denoted <span class="KeyTerm1">n4</span>. In the box-and-pointer diagram, we have indicated at the lower left of each pair the vector index that specifies where the <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> of the pair are stored. The blank locations in <span class="KeyTerm1">the_heads</span> and <span class="KeyTerm1">the_tails</span> may contain parts of other list structures (not of interest here).</p>
<figure id="c005_c5-fig-0014"><img alt="c5-fig-0014.jpg" src="../images/c5-fig-0014.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0014a">Figure 5.14</a></span> <a id="c005_c5-para-0687"></a>Box-and-pointer and memory-vector representations of the list <span class="KeyTerm1">list(list(1, 2), 3, 4)</span>.</p></figcaption></figure>
<p><a id="c005_c5-para-0688"></a>A pointer to a number, such as <span class="KeyTerm1">n4</span>, might consist of a type indicating numeric data together with the actual representation of the number 4.<a id="c005_c5-fn-0010a"></a><a href="#c5-fn-0010"><sup>10</sup></a> To deal with numbers that are too large to be represented in the fixed amount of space allocated for a single pointer, we could use a distinct <i>bignum</i> data type, for which the pointer designates a list in which the parts of the number are stored.<a id="c005_c5-fn-0011a"></a><a href="#c5-fn-0011"><sup>11</sup></a></p>
<p><a id="c005_c5-para-0689"></a>A string might be represented as a typed pointer that designates a sequence of the characters that form the string's printed representation. The parser constructs such a sequence when it encounters a string literal, and the string-concatenation operator <span class="KeyTerm1">+</span> and string-producing primitive functions such as <span class="KeyTerm1">stringify</span> construct such a sequence. Since we want two instances of a string to be recognized as the “same” string by <span class="KeyTerm1">===</span> and we want <span class="KeyTerm1">===</span> to be a simple test for equality of pointers, we must ensure that if the system sees the same string twice, it will use the same pointer (to the same sequence of characters) to represent both occurrences. To accomplish this, the system maintains a table, called the <i>string pool</i>, of all the strings it has ever encountered. When the system is about to construct a string, it checks the string pool to see if it has ever before seen the same string. If it has not, it constructs a new string (a typed pointer to a new character sequence) and enters this pointer in the string pool. If the system has seen the string before, it returns the string pointer stored in the string pool. This process of replacing strings by unique pointers is called <i>string interning</i>.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0045"></a><a id="c005_c5-title-0046"></a>Implementing the primitive list operations</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0690"></a>Given the above representation scheme, we can replace each “primitive” list operation of a register machine with one or more primitive vector operations. We will use two registers, <span class="KeyTerm1">the_heads</span> and <span class="KeyTerm1">the_tails</span>, to identify the memory vectors, and will assume that <span class="KeyTerm1">vector_ref</span> and <span class="KeyTerm1">vector_set</span> are available as primitive operations. We also assume that numeric operations on pointers (such as incrementing a pointer, using a pair pointer to index a vector, or adding two numbers) use only the index portion of the typed pointer.</p>
<p><a id="c005_c5-para-0691"></a>For example, we can make a register machine support the instructions</p>
<p class="Sp-text-1"><a id="c005_c5-para-0692"></a>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, list(op("head"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0693"></a>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, list(op("tail"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="paracontinue"><a id="c005_c5-para-0694"></a>if we implement these, respectively, as</p>
<p class="Sp-text-1"><a id="c005_c5-para-0695"></a>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, list(op("vector_ref"), reg("the_heads"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0696"></a>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, list(op("vector_ref"), reg("the_tails"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="paracontinue"><a id="c005_c5-para-0697"></a>The instructions</p>
<p class="Sp-text-1"><a id="c005_c5-para-0698"></a>perform(list(op("set_head"), reg(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0699"></a>perform(list(op("set_tail"), reg(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="paracontinue"><a id="c005_c5-para-0700"></a>are implemented as</p>
<p class="Sp-text-1"><a id="c005_c5-para-0701"></a>perform(list(op("vector_set"), reg("the_heads"), reg(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0702"></a>perform(list(op("vector_set"), reg("the_tails"), reg(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>)))</p>
<p><a id="c005_c5-para-0703"></a>The operation <span class="KeyTerm1">pair</span> is performed by allocating an unused index and storing the arguments to <span class="KeyTerm1">pair</span> in <span class="KeyTerm1">the_heads</span> and <span class="KeyTerm1">the_tails</span> at that indexed vector position. We presume that there is a special register, <span class="KeyTerm1">free</span>, that always holds a pair pointer containing the next available index, and that we can increment the index part of that pointer to find the next free location.<a id="c005_c5-fn-0012a"></a><a href="#c5-fn-0012"><sup>12</sup></a> For example, the instruction</p>
<p class="Sp-text-1"><a id="c005_c5-para-0704"></a>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, list(op("pair"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>3</sub></span>)))</p>
<p class="paracontinue"><a id="c005_c5-para-0705"></a>is implemented as the following sequence of vector operations:<a id="c005_c5-fn-0013a"></a><a href="#c5-fn-0013"><sup>13</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-0706"></a>perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0707"></a>             reg("the_heads"), reg("free"), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0708"></a>perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0709"></a>             reg("the_tails"), reg("free"), reg(<span class="KeyTerm2"><i>reg</i><sub>3</sub></span>))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0710"></a>assign(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, reg("free")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0711"></a>assign("free", list(op("+"), reg("free"), constant(1)))</p>
<p><a id="c005_c5-para-0712"></a>The <span class="KeyTerm1">===</span> operation</p>
<p class="Sp-text-1"><a id="c005_c5-para-0713"></a>list(op("==="), reg(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>), reg(<span class="KeyTerm2"><i>reg</i><sub>2</sub></span>))</p>
<p class="paracontinue"><a id="c005_c5-para-0714"></a>simply tests the equality of all fields in the registers, and predicates such as <span class="KeyTerm1">is_pair</span>, <span class="KeyTerm1">is_null</span>, <span class="KeyTerm1">is_string</span>, and <span class="KeyTerm1">is_number</span> need only check the type field.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0046"></a><a id="c005_c5-title-0047"></a>Implementing stacks</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0715"></a>Although our register machines use stacks, we need do nothing special here, since stacks can be modeled in terms of lists. The stack can be a list of the saved values, pointed to by a special register <span class="KeyTerm1">the_stack</span>. Thus, <span class="KeyTerm1">save(</span><i>reg</i><span class="KeyTerm1">)</span> can be implemented as</p>
<p class="Sp-text-1"><a id="c005_c5-para-0716"></a>assign("the_stack", list(op("pair"), reg(<span class="KeyTerm2"><i>reg</i></span>), reg("the_stack")))</p>
<p class="paracontinue"><a id="c005_c5-para-0717"></a>Similarly, <span class="KeyTerm1">restore(</span><i>reg</i><span class="KeyTerm1">)</span> can be implemented as</p>
<p class="Sp-text-1"><a id="c005_c5-para-0718"></a>assign(<span class="KeyTerm2"><i>reg</i></span>, list(op("head"), reg("the_stack")))</p>
<p class="Sp-text-1"><a id="c005_c5-para-0719"></a>assign("the_stack", list(op("tail"), reg("the_stack")))</p>
<p class="paracontinue"><a id="c005_c5-para-0720"></a>and <span class="KeyTerm1">perform(list(op("initialize_stack")))</span> can be implemented as</p>
<p class="Sp-text-1"><a id="c005_c5-para-0721"></a>assign("the_stack", constant(<b>null</b>))</p>
<p class="paracontinue"><a id="c005_c5-para-0722"></a>These operations can be further expanded in terms of the vector operations given above. In conventional computer architectures, however, it is usually advantageous to allocate the stack as a separate vector. Then pushing and popping the stack can be accomplished by incrementing or decrementing an index into that vector.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0047"></a><a id="c005_c5-title-0048"></a>Exercise 5.19</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0723"></a>Draw the box-and-pointer representation and the memory-vector representation (as in <a href="#c5-fig-0014">figure 5.14</a>) of the list structure produced by</p>
<p class="Sp-text-1"><a id="c005_c5-para-0724"></a><b>const</b> x = pair(1, 2);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0725"></a><b>const</b> y = list(x, x);</p>
<p class="paracontinue"><a id="c005_c5-para-0726"></a>with the <span class="KeyTerm1">free</span> pointer initially <span class="KeyTerm1">p1</span>. What is the final value of <span class="KeyTerm1">free</span> ? What pointers represent the values of <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span>?</p>
</section>
<section>
<h5><a id="c005_c5-sec-0048"></a><a id="c005_c5-title-0049"></a>Exercise 5.20</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0727"></a>Implement register machines for the following functions. Assume that the list-structure memory operations are available as machine primitives.</p>
<ol class="BS_NumberListA">
<li><a id="c005_c5-li-0022"></a><span>a. </span>Recursive <span class="KeyTerm1">count_leaves</span>:
<p class="Sp-text-1"><a id="c005_c5-para-0729"></a><b>function</b> count_leaves(tree) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0730"></a> <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0731"></a>           ? 0</p>
<p class="Sp-text-1"><a id="c005_c5-para-0732"></a>           : ! is_pair(tree)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0733"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-0734"></a>           : count_leaves(head(tree)) +</p>
<p class="Sp-text-1"><a id="c005_c5-para-0735"></a>             count_leaves(tail(tree));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0736"></a>}</p></li>
<li><a id="c005_c5-li-0023"></a><span>b. </span>Recursive <span class="KeyTerm1">count_leaves</span> with explicit counter:
<p class="Sp-text-1"><a id="c005_c5-para-0738"></a><b>function</b> count_leaves(tree) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0739"></a> <b>function</b> count_iter(tree, n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-0740"></a> <b>return</b> is_null(tree)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0741"></a>               ? n</p>
<p class="Sp-text-1"><a id="c005_c5-para-0742"></a>               : ! is_pair(tree)</p>
<p class="Sp-text-1"><a id="c005_c5-para-0743"></a>               ? n + 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-0744"></a>               : count_iter(tail(tree),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0745"></a>                            count_iter(head(tree), n));</p>
<p class="Sp-text-1"><a id="c005_c5-para-0746"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-0747"></a> <b>return</b> count_iter(tree, 0);</p>
<p class="Sp-text-1"><a id="c005_c5-para-0748"></a>}</p></li>
</ol>
</section>
<section>
<h5><a id="c005_c5-sec-0049"></a><a id="c005_c5-title-0050"></a>Exercise 5.21</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0749"></a>Exercise 3.12 of section 3.3.1 presented an <span class="KeyTerm1">append</span> function that appends two lists to form a new list and an <span class="KeyTerm1">append_mutator</span> function that splices two lists together. Design a register machine to implement each of these functions. Assume that the list-structure memory operations are available as primitive operations.</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0050"></a><span>5.3.2</span> <a id="c005_c5-title-0051"></a>Maintaining the Illusion of Infinite Memory</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0750"></a>The representation method outlined in section 5.3.1 solves the problem of implementing list structure, provided that we have an infinite amount of memory. With a real computer we will eventually run out of free space in which to construct new pairs.<a id="c005_c5-fn-0014a"></a><a href="#c5-fn-0014"><sup>14</sup></a> However, most of the pairs generated in a typical computation are used only to hold intermediate results. After these results are accessed, the pairs are no longer needed—they are <i>garbage</i>. For instance, the computation</p>
<p class="Sp-text-1"><a id="c005_c5-para-0751"></a>accumulate((x, y) =&gt; x + y,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0752"></a>           0,</p>
<p class="Sp-text-1"><a id="c005_c5-para-0753"></a>           filter(is_odd, enumerate_interval(0, n)))</p>
<p class="paracontinue"><a id="c005_c5-para-0754"></a>constructs two lists: the enumeration and the result of filtering the enumeration. When the accumulation is complete, these lists are no longer needed, and the allocated memory can be reclaimed. If we can arrange to collect all the garbage periodically, and if this turns out to recycle memory at about the same rate at which we construct new pairs, we will have preserved the illusion that there is an infinite amount of memory.</p>
<p><a id="c005_c5-para-0755"></a>In order to recycle pairs, we must have a way to determine which allocated pairs are not needed (in the sense that their contents can no longer influence the future of the computation). The method we shall examine for accomplishing this is known as <i>garbage collection</i>. Garbage collection is based on the observation that, at any moment in an interpretation based on list-structured memory, the only objects that can affect the future of the computation are those that can be reached by some succession of <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> operations starting from the pointers that are currently in the machine registers.<a id="c005_c5-fn-0015a"></a><a href="#c5-fn-0015"><sup>15</sup></a> Any memory cell that is not so accessible may be recycled.</p>
<p><a id="c005_c5-para-5755"></a>There are many ways to perform garbage collection. The method we shall examine here is called <i>stop-and-copy</i>. The basic idea is to divide memory into two halves: “working memory” and “free memory.” When <span class="KeyTerm1">pair</span> constructs pairs, it allocates these in working memory. When working memory is full, we perform garbage collection by locating all the useful pairs in working memory and copying these into consecutive locations in free memory. (The useful pairs are located by tracing all the <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> pointers, starting with the machine registers.) Since we do not copy the garbage, there will presumably be additional free memory that we can use to allocate new pairs. In addition, nothing in the working memory is needed, since all the useful pairs in it have been copied. Thus, if we interchange the roles of working memory and free memory, we can continue processing; new pairs will be allocated in the new working memory (which was the old free memory). When this is full, we can copy the useful pairs into the new free memory (which was the old working memory).<a id="c005_c5-fn-0016a"></a><a href="#c5-fn-0016"><sup>16</sup></a></p>
<section>
<h5><a id="c005_c5-sec-0051"></a><a id="c005_c5-title-0052"></a>Implementation of a stop-and-copy garbage collector</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0756"></a>We now use our register-machine language to describe the stop-and-copy algorithm in more detail. We will assume that there is a register called <span class="KeyTerm1">root</span> that contains a pointer to a structure that eventually points at all accessible data. This can be arranged by storing the contents of all the machine registers in a preallocated list pointed at by <span class="KeyTerm1">root</span> just before starting garbage collection.<a id="c005_c5-fn-0017a"></a><a href="#c5-fn-0017"><sup>17</sup></a> We also assume that, in addition to the current working memory, there is free memory available into which we can copy the useful data. The current working memory consists of vectors whose base addresses are in registers called <span class="KeyTerm1">the_heads</span> and <span class="KeyTerm1">the_tails</span>, and the free memory is in registers called <span class="KeyTerm1">new_heads</span> and <span class="KeyTerm1">new_tails</span>.</p>
<p><a id="c005_c5-para-0757"></a>Garbage collection is triggered when we exhaust the free cells in the current working memory, that is, when a <span class="KeyTerm1">pair</span> operation attempts to increment the <span class="KeyTerm1">free</span> pointer beyond the end of the memory vector. When the garbage-collection process is complete, the <span class="KeyTerm1">root</span> pointer will point into the new memory, all objects accessible from the <span class="KeyTerm1">root</span> will have been moved to the new memory, and the <span class="KeyTerm1">free</span> pointer will indicate the next place in the new memory where a new pair can be allocated. In addition, the roles of working memory and new memory will have been interchanged—new pairs will be constructed in the new memory, beginning at the place indicated by <span class="KeyTerm1">free</span>, and the (previous) working memory will be available as the new memory for the next garbage collection. <a id="c005_c5-fig-0015a"></a><a href="#c5-fig-0015">Figure 5.15</a> shows the arrangement of memory just before and just after garbage collection.</p>
<figure id="c005_c5-fig-0015"><img alt="c5-fig-0015.jpg" src="../images/c5-fig-0015.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0015a">Figure 5.15</a></span> <a id="c005_c5-para-0759"></a>Reconfiguration of memory by the garbage-collection process.</p></figcaption></figure>
<p><a id="c005_c5-para-0760"></a>The state of the garbage-collection process is controlled by maintaining two pointers: <span class="KeyTerm1">free</span> and <span class="KeyTerm1">scan</span>. These are initialized to point to the beginning of the new memory. The algorithm begins by relocating the pair pointed at by <span class="KeyTerm1">root</span> to the beginning of the new memory. The pair is copied, the <span class="KeyTerm1">root</span> pointer is adjusted to point to the new location, and the <span class="KeyTerm1">free</span> pointer is incremented. In addition, the old location of the pair is marked to show that its contents have been moved. This marking is done as follows: In the <span class="KeyTerm1">head</span> position, we place a special tag that signals that this is an already-moved object. (Such an object is traditionally called a <i>broken heart</i>.)<a id="c005_c5-fn-0018a"></a><a href="#c5-fn-0018"><sup>18</sup></a> In the <span class="KeyTerm1">tail</span> position we place a <i>forwarding address</i> that points at the location to which the object has been moved.</p>
<p><a id="c005_c5-para-0761"></a>After relocating the root, the garbage collector enters its basic cycle. At each step in the algorithm, the <span class="KeyTerm1">scan</span> pointer (initially pointing at the relocated root) points at a pair that has been moved to the new memory but whose <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> pointers still refer to objects in the old memory. These objects are each relocated, and the <span class="KeyTerm1">scan</span> pointer is incremented. To relocate an object (for example, the object indicated by the <span class="KeyTerm1">head</span> pointer of the pair we are scanning) we check to see if the object has already been moved (as indicated by the presence of a broken-heart tag in the <span class="KeyTerm1">head</span> position of the object). If the object has not already been moved, we copy it to the place indicated by <span class="KeyTerm1">free</span>, update <span class="KeyTerm1">free</span>, set up a broken heart at the object's old location, and update the pointer to the object (in this example, the <span class="KeyTerm1">head</span> pointer of the pair we are scanning) to point to the new location. If the object has already been moved, its forwarding address (found in the <span class="KeyTerm1">tail</span> position of the broken heart) is substituted for the pointer in the pair being scanned. Eventually, all accessible objects will have been moved and scanned, at which point the <span class="KeyTerm1">scan</span> pointer will overtake the <span class="KeyTerm1">free</span> pointer and the process will terminate.</p>
<p><a id="c005_c5-para-0762"></a>We can specify the stop-and-copy algorithm as a sequence of instructions for a register machine. The basic step of relocating an object is accomplished by a subroutine called <span class="KeyTerm1">relocate_old_result_in_new</span>. This subroutine gets its argument, a pointer to the object to be relocated, from a register named <span class="KeyTerm1">old</span>. It relocates the designated object (incrementing <span class="KeyTerm1">free</span> in the process), puts a pointer to the relocated object into a register called <span class="KeyTerm1">new</span>, and returns by branching to the entry point stored in the register <span class="KeyTerm1">relocate_continue</span>. To begin garbage collection, we invoke this subroutine to relocate the <span class="KeyTerm1">root</span> pointer, after initializing <span class="KeyTerm1">free</span> and <span class="KeyTerm1">scan</span>. When the relocation of <span class="KeyTerm1">root</span> has been accomplished, we install the new pointer as the new <span class="KeyTerm1">root</span> and enter the main loop of the garbage collector.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0763"></a>"begin_garbage_collection",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0764"></a>  assign("free", constant(0)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0765"></a>  assign("scan", constant(0)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0766"></a>  assign("old", reg("root")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0767"></a>  assign("relocate_continue", label("reassign_root")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0768"></a>  go_to(label("relocate_old_result_in_new")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0769"></a>"reassign_root",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0770"></a>  assign("root", reg("new")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0771"></a>  go_to(label("gc_loop")),</p>
<p><a id="c005_c5-para-0772"></a>In the main loop of the garbage collector we must determine whether there are any more objects to be scanned. We do this by testing whether the <span class="KeyTerm1">scan</span> pointer is coincident with the <span class="KeyTerm1">free</span> pointer. If the pointers are equal, then all accessible objects have been relocated, and we branch to <span class="KeyTerm1">gc_flip</span>, which cleans things up so that we can continue the interrupted computation. If there are still pairs to be scanned, we call the relocate subroutine to relocate the <span class="KeyTerm1">head</span> of the next pair (by placing the <span class="KeyTerm1">head</span> pointer in <span class="KeyTerm1">old</span>). The <span class="KeyTerm1">relocate_continue</span> register is set up so that the subroutine will return to update the <span class="KeyTerm1">head</span> pointer.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0773"></a>"gc_loop",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0774"></a>  test(list(op("==="), reg("scan"), reg("free"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0775"></a>  branch(label("gc_flip")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0776"></a>  assign("old", list(op("vector_ref"), reg("new_heads"), reg("scan"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0777"></a>  assign("relocate_continue", label("update_head")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0778"></a>  go_to(label("relocate_old_result_in_new")),</p>
<p><a id="c005_c5-para-0779"></a>At <span class="KeyTerm1">update_head</span>, we modify the <span class="KeyTerm1">head</span> pointer of the pair being scanned, then proceed to relocate the <span class="KeyTerm1">tail</span> of the pair. We return to <span class="KeyTerm1">update_tail</span> when that relocation has been accomplished. After relocating and updating the <span class="KeyTerm1">tail</span>, we are finished scanning that pair, so we continue with the main loop.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0780"></a>"update_head",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0781"></a>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0782"></a>               reg("new_heads"), reg("scan"), reg("new"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0783"></a>  assign("old", list(op("vector_ref"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0784"></a>                     reg("new_tails"), reg("scan"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0785"></a>  assign("relocate_continue", label("update_tail")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0786"></a>  go_to(label("relocate_old_result_in_new")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0787"></a>"update_tail",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0788"></a>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0789"></a>               reg("new_tails"), reg("scan"), reg("new"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0790"></a>  assign("scan", list(op("+"), reg("scan"), constant(1))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0791"></a>  go_to(label("gc_loop")),</p>
<p><a id="c005_c5-para-0792"></a>The subroutine <span class="KeyTerm1">relocate_old_result_in_new</span> relocates objects as follows: If the object to be relocated (pointed at by <span class="KeyTerm1">old</span>) is not a pair, then we return the same pointer to the object unchanged (in <span class="KeyTerm1">new</span>). (For example, we may be scanning a pair whose <span class="KeyTerm1">head</span> is the number 4. If we represent the <span class="KeyTerm1">head</span> by <span class="KeyTerm1">n4</span>, as described in section 5.3.1, then we want the “relocated” <span class="KeyTerm1">head</span> pointer to still be <span class="KeyTerm1">n4</span>.) Otherwise, we must perform the relocation. If the <span class="KeyTerm1">head</span> position of the pair to be relocated contains a broken-heart tag, then the pair has in fact already been moved, so we retrieve the forwarding address (from the <span class="KeyTerm1">tail</span> position of the broken heart) and return this in <span class="KeyTerm1">new</span>. If the pointer in <span class="KeyTerm1">old</span> points at a yet-unmoved pair, then we move the pair to the first free cell in new memory (pointed at by <span class="KeyTerm1">free</span>) and set up the broken heart by storing a broken-heart tag and forwarding address at the old location. The subroutine <span class="KeyTerm1">relocate_old_result_in_new</span> uses a register <span class="KeyTerm1">oldht</span> to hold the <span class="KeyTerm1">head</span> or the <span class="KeyTerm1">tail</span> of the object pointed at by <span class="KeyTerm1">old</span>.<a id="c005_c5-fn-0019a"></a><a href="#c5-fn-0019"><sup>19</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-0793"></a>"relocate_old_result_in_new",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0794"></a>  test(list(op("is_pointer_to_pair"), reg("old"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0795"></a>  branch(label("pair")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0796"></a>  assign("new", reg("old")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0797"></a>  go_to(reg("relocate_continue")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0798"></a>"pair",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0799"></a>  assign("oldht", list(op("vector_ref"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0800"></a>                       reg("the_heads"), reg("old"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0801"></a>  test(list(op("is_broken_heart"), reg("oldht"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0802"></a>  branch(label("already_moved")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0803"></a>  assign("new", reg("free")),     <i>//</i> <span class="KeyTerm2"><i>new location for pair</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-0804"></a> <i>//</i> <span class="KeyTerm2"><i>Update</i></span> free <span class="KeyTerm2"><i>pointer</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-0805"></a>  assign("free", list(op("+"), reg("free"), constant(1))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0806"></a> <i>//</i> <span class="KeyTerm2"><i>Copy the head and tail to new memory</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-0807"></a>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0808"></a>               reg("new_heads"), reg("new"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0809"></a>               reg("oldht"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0810"></a>  assign("oldht", list(op("vector_ref"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0811"></a>                      reg("the_tails"), reg("old"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0812"></a>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0813"></a>               reg("new_tails"), reg("new"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0814"></a>               reg("oldht"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0815"></a> <i>//</i> <span class="KeyTerm2"><i>Construct the broken heart</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-0816"></a>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0817"></a>               reg("the_heads"), reg("old"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0818"></a>               constant("broken_heart"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0819"></a>  perform(list(op("vector_set"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0820"></a>               reg("the_tails"), reg("old"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0821"></a>               reg("new"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0822"></a>  go_to(reg("relocate_continue")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0823"></a>"already_moved",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0824"></a>  assign("new", list(op("vector_ref"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0825"></a>                     reg("the_tails"), reg("old"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0826"></a>  go_to(reg("relocate_continue")),</p>
<p><a id="c005_c5-para-0827"></a>At the very end of the garbage collection process, we interchange the role of old and new memories by interchanging pointers: interchanging <span class="KeyTerm1">the_heads</span> with <span class="KeyTerm1">new_heads</span>, and <span class="KeyTerm1">the_tails</span> with <span class="KeyTerm1">new_tails</span>. We will then be ready to perform another garbage collection the next time memory runs out.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0828"></a>"gc_flip",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0829"></a>  assign("temp", reg("the_tails")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0830"></a>  assign("the_tails", reg("new_tails")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0831"></a>  assign("new_tails", reg("temp")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0832"></a>  assign("temp", reg("the_heads")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0833"></a>  assign("the_heads", reg("new_heads")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0834"></a>  assign("new_heads", reg("temp"))</p>
</section>
</section>
</section>
<section>
<h2><a id="c005_c5-sec-0052"></a><span>5.4</span> <a id="c005_c5-title-0053"></a>The Explicit-Control Evaluator</h2>
<p class="paraaftertitle"><a id="c005_c5-para-0835"></a>In section 5.1 we saw how to transform simple JavaScript programs into descriptions of register machines. We will now perform this transformation on a more complex program, the metacircular evaluator of sections 4.1.1–4.1.4, which shows how the behavior of a JavaScript interpreter can be described in terms of the functions <span class="KeyTerm1">evaluate</span> and <span class="KeyTerm1">apply</span>. The <i>explicit-control evaluator</i> that we develop in this section shows how the underlying function-calling and argument-passing mechanisms used in the evaluation process can be described in terms of operations on registers and stacks. In addition, the explicit-control evaluator can serve as an implementation of a JavaScript interpreter, written in a language that is very similar to the native machine language of conventional computers. The evaluator can be executed by the register-machine simulator of section 5.2. Alternatively, it can be used as a starting point for building a machine-language implementation of a JavaScript evaluator, or even a special-purpose machine for evaluating JavaScript programs. <a id="c005_c5-fig-0016a"></a><a href="#c5-fig-0016">Figure 5.16</a> shows such a hardware implementation: a silicon chip that acts as an evaluator for Scheme, the language used in place of JavaScript in the original edition of this book. The chip designers started with the data-path and controller specifications for a register machine similar to the evaluator described in this section and used design automation programs to construct the integrated-circuit layout.<a id="c005_c5-fn-0020a"></a><a href="#c5-fn-0020"><sup>20</sup></a></p>
<figure id="c005_c5-fig-0016"><img alt="c5-fig-0016.jpg" src="../images/c5-fig-0016.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0016a">Figure 5.16</a></span> <a id="c005_c5-para-0836"></a>A silicon-chip implementation of an evaluator for Scheme.</p></figcaption></figure>
<section><a id="c005_c5-title-0054"></a>
<section>
<h5><a id="c005_c5-sec-0054"></a><a id="c005_c5-title-0055"></a>Registers and operations</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0837"></a>In designing the explicit-control evaluator, we must specify the operations to be used in our register machine. We described the metacircular evaluator in terms of abstract syntax, using functions such as <span class="KeyTerm1">is_literal</span> and <span class="KeyTerm1">make_function</span>. In implementing the register machine, we could expand these functions into sequences of elementary list-structure memory operations, and implement these operations on our register machine. However, this would make our evaluator very long, obscuring the basic structure with details. To clarify the presentation, we will include as primitive operations of the register machine the syntax functions given in section 4.1.2 and the functions for representing environments and other runtime data given in sections 4.1.3 and 4.1.4. In order to completely specify an evaluator that could be programmed in a low-level machine language or implemented in hardware, we would replace these operations by more elementary operations, using the list-structure implementation we described in section 5.3.</p>
<p><a id="c005_c5-para-0838"></a>Our JavaScript evaluator register machine includes a stack and seven registers: <span class="KeyTerm1">comp</span>, <span class="KeyTerm1">env</span>, <span class="KeyTerm1">val</span>, <span class="KeyTerm1">continue</span>, <span class="KeyTerm1">fun</span>, <span class="KeyTerm1">argl</span>, and <span class="KeyTerm1">unev</span>. The <span class="KeyTerm1">comp</span> register is used to hold the component to be evaluated, and <span class="KeyTerm1">env</span> contains the environment in which the evaluation is to be performed. At the end of an evaluation, <span class="KeyTerm1">val</span> contains the value obtained by evaluating the component in the designated environment. The <span class="KeyTerm1">continue</span> register is used to implement recursion, as explained in section 5.1.4. (The evaluator needs to call itself recursively, since evaluating a component requires evaluating its subcomponents.) The registers <span class="KeyTerm1">fun</span>, <span class="KeyTerm1">argl</span>, and <span class="KeyTerm1">unev</span> are used in evaluating function applications.</p>
<p><a id="c005_c5-para-0839"></a>We will not provide a data-path diagram to show how the registers and operations of the evaluator are connected, nor will we give the complete list of machine operations. These are implicit in the evaluator's controller, which will be presented in detail.</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0055"></a><span>5.4.1</span> <a id="c005_c5-title-0056"></a>The Dispatcher and Basic Evaluation</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0840"></a>The central element in the evaluator is the sequence of instructions beginning at <span class="KeyTerm1">eval_dispatch</span>. This corresponds to the <span class="KeyTerm1">evaluate</span> function of the metacircular evaluator described in section 4.1.1. When the controller starts at <span class="KeyTerm1">eval_dispatch</span>, it evaluates the component specified by <span class="KeyTerm1">comp</span> in the environment specified by <span class="KeyTerm1">env</span>. When evaluation is complete, the controller will go to the entry point stored in <span class="KeyTerm1">continue</span>, and the <span class="KeyTerm1">val</span> register will hold the value of the component. As with the metacircular <span class="KeyTerm1">evaluate</span>, the structure of <span class="KeyTerm1">eval_dispatch</span> is a case analysis on the syntactic type of the component to be evaluated.<a id="c005_c5-fn-0021a"></a><a href="#c5-fn-0021"><sup>21</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-0841"></a>"eval_dispatch",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0842"></a>  test(list(op("is_literal"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0843"></a>  branch(label("ev_literal")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0844"></a>  test(list(op("is_name"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0845"></a>  branch(label("ev_name")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0846"></a>  test(list(op("is_application"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0847"></a>  branch(label("ev_application")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0848"></a>  test(list(op("is_operator_combination"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0849"></a>  branch(label("ev_operator_combination")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0850"></a>  test(list(op("is_conditional"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0851"></a>  branch(label("ev_conditional")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0852"></a>  test(list(op("is_lambda_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0853"></a>  branch(label("ev_lambda")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0854"></a>  test(list(op("is_sequence"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0855"></a>  branch(label("ev_sequence")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0856"></a>  test(list(op("is_block"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0857"></a>  branch(label("ev_block")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0858"></a>  test(list(op("is_return_statement"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0859"></a>  branch(label("ev_return")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0860"></a>  test(list(op("is_function_declaration"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0861"></a>  branch(label("ev_function_declaration")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0862"></a>  test(list(op("is_declaration"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0863"></a>  branch(label("ev_declaration")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0864"></a>  test(list(op("is_assignment"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0865"></a>  branch(label("ev_assignment")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0866"></a>  go_to(label("unknown_component_type")),</p>
<section>
<h5><a id="c005_c5-sec-0056"></a><a id="c005_c5-title-0057"></a>Evaluating simple expressions</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0867"></a>Numbers and strings, names, and lambda expressions have no subexpressions to be evaluated. For these, the evaluator simply places the correct value in the <span class="KeyTerm1">val</span> register and continues execution at the entry point specified by <span class="KeyTerm1">continue</span>. Evaluation of simple expressions is performed by the following controller code:</p>
<p class="Sp-text-1"><a id="c005_c5-para-0868"></a>"ev_literal",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0869"></a>  assign("val", list(op("literal_value"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0870"></a>  go_to(reg("continue")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0871"></a>"ev_name",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0872"></a>  assign("val", list(op("symbol_of_name"), reg("comp"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0873"></a>  assign("val", list(op("lookup_symbol_value"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0874"></a>                     reg("val"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0875"></a>  go_to(reg("continue")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0876"></a>"ev_lambda",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0877"></a>  assign("unev", list(op("lambda_parameter_symbols"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0878"></a>  assign("comp", list(op("lambda_body"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0879"></a>  assign("val", list(op("make_function"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0880"></a>                     reg("unev"), reg("comp"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0881"></a>  go_to(reg("continue")),</p>
<p class="paracontinue"><a id="c005_c5-para-0882"></a>Observe how <span class="KeyTerm1">ev_lambda</span> uses the <span class="KeyTerm1">unev</span> and <span class="KeyTerm1">comp</span> registers to hold the parameters and body of the lambda expression so that they can be passed to the <span class="KeyTerm1">make_function</span> operation, along with the environment in <span class="KeyTerm1">env</span>.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0057"></a><a id="c005_c5-title-0058"></a>Conditionals</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0883"></a>As with the metacircular evaluator, syntactic forms are handled by selectively evaluating fragments of the component. For a conditional, we must evaluate the predicate and decide, based on the value of predicate, whether to evaluate the consequent or the alternative.</p>
<p><a id="c005_c5-para-0884"></a>Before evaluating the predicate, we save the conditional itself, which is in <span class="KeyTerm1">comp</span>, so that we can later extract the consequent or alternative. To evaluate the predicate expression, we move it to the <span class="KeyTerm1">comp</span> register and go to <span class="KeyTerm1">eval_dispatch</span>. The environment in the <span class="KeyTerm1">env</span> register is already the correct one in which to evaluate the predicate. However, we save <span class="KeyTerm1">env</span> because we will need it later to evaluate the consequent or the alternative. We set up <span class="KeyTerm1">continue</span> so that evaluation will resume at <span class="KeyTerm1">ev_conditional_decide</span> after the predicate has been evaluated. First, however, we save the old value of <span class="KeyTerm1">continue</span>, which we will need later in order to return to the evaluation of the statement that is waiting for the value of the conditional.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0885"></a>"ev_conditional",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0886"></a>  save("comp"), <i>//</i> <span class="KeyTerm2"><i>save conditional for later</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-0887"></a>save("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0888"></a>save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0889"></a>assign("continue", label("ev_conditional_decide")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0890"></a>assign("comp", list(op("conditional_predicate"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0891"></a>  go_to(label("eval_dispatch")), <i>//</i> <span class="KeyTerm2"><i>evaluate the predicate</i></span></p>
<p><a id="c005_c5-para-0892"></a>When we resume at <span class="KeyTerm1">ev_conditional_decide</span> after evaluating the predicate, we test whether it was true or false and, depending on the result, place either the consequent or the alternative in <span class="KeyTerm1">comp</span> before going to <span class="KeyTerm1">eval_dispatch</span>.<a id="c005_c5-fn-0022a"></a><a href="#c5-fn-0022"><sup>22</sup></a> Notice that restoring <span class="KeyTerm1">env</span> and <span class="KeyTerm1">continue</span> here sets up <span class="KeyTerm1">eval_dispatch</span> to have the correct environment and to continue at the right place to receive the value of the conditional.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0893"></a>"ev_conditional_decide",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0894"></a>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0895"></a>  restore("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0896"></a>  restore("comp"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0897"></a>  test(list(op("is_falsy"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0898"></a>  branch(label("ev_conditional_alternative")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0899"></a>"ev_conditional_consequent",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0900"></a>  assign("comp", list(op("conditional_consequent"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0901"></a>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0902"></a>"ev_conditional_alternative",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0903"></a>  assign("comp", list(op("conditional_alternative"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0904"></a>  go_to(label("eval_dispatch")),</p>
</section>
<section>
<h5><a id="c005_c5-sec-0058"></a><a id="c005_c5-title-0059"></a>Sequence Evaluation</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0905"></a>The portion of the explicit-control evaluator beginning at <span class="KeyTerm1">ev_sequence</span>, which handles sequences of statements, is analogous to the metacircular evaluator's <span class="KeyTerm1">eval_ sequence</span> function.</p>
<p><a id="c005_c5-para-0906"></a>The entries at <span class="KeyTerm1">ev_sequence_next</span> and <span class="KeyTerm1">ev_sequence_continue</span> form a loop that successively evaluates each statement in a sequence. The list of unevaluated statements is kept in <span class="KeyTerm1">unev</span>. At <span class="KeyTerm1">ev_sequence</span> we place the sequence of statements to be evaluated in <span class="KeyTerm1">unev</span>. If the sequence is empty, we set <span class="KeyTerm1">val</span> to <span class="KeyTerm1">undefined</span> and jump to <span class="KeyTerm1">continue</span> via <span class="KeyTerm1">ev_sequence_empty</span>. Otherwise we start the sequence-evaluation loop, first saving the value of <span class="KeyTerm1">continue</span> on the stack, because the <span class="KeyTerm1">continue</span> register will be used for local flow of control in the loop, and the original value is needed for continuing after the statement sequence. Before evaluating each statement, we check to see if there are additional statements to be evaluated in the sequence. If so, we save the rest of the unevaluated statements (held in <span class="KeyTerm1">unev</span>) and the environment in which these must be evaluated (held in <span class="KeyTerm1">env</span>) and call <span class="KeyTerm1">eval_dispatch</span> to evaluate the statement, which has been placed in <span class="KeyTerm1">comp</span>. The two saved registers are restored after this evaluation, at <span class="KeyTerm1">ev_sequence_continue</span>.</p>
<p><a id="c005_c5-para-0907"></a>The final statement in the sequence is handled differently, at the entry point <span class="KeyTerm1">ev_sequence_last_statement</span>. Since there are no more statements to be evaluated after this one, we need not save <span class="KeyTerm1">unev</span> or <span class="KeyTerm1">env</span> before going to <span class="KeyTerm1">eval_dispatch</span>. The value of the whole sequence is the value of the last statement, so after the evaluation of the last statement there is nothing left to do except continue at the entry point that was saved at <span class="KeyTerm1">ev_sequence</span>. Rather than setting up <span class="KeyTerm1">continue</span> to arrange for <span class="KeyTerm1">eval_dispatch</span> to return here and then restoring <span class="KeyTerm1">continue</span> from the stack and continuing at that entry point, we restore <span class="KeyTerm1">continue</span> from the stack before going to <span class="KeyTerm1">eval_dispatch</span>, so that <span class="KeyTerm1">eval_dispatch</span> will continue at that entry point after evaluating the statement.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0908"></a>"ev_sequence",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0909"></a>  assign("unev", list(op("sequence_statements"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0910"></a>  test(list(op("is_empty_sequence"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0911"></a>  branch(label("ev_sequence_empty")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0912"></a>  save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0913"></a>"ev_sequence_next",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0914"></a>  assign("comp", list(op("first_statement"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0915"></a>  test(list(op("is_last_statement"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0916"></a>  branch(label("ev_sequence_last_statement")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0917"></a>  save("unev"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0918"></a>  save("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0919"></a>  assign("continue", label("ev_sequence_continue")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0920"></a>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0921"></a>"ev_sequence_continue",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0922"></a>  restore("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0923"></a>  restore("unev"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0924"></a>  assign("unev", list(op("rest_statements"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0925"></a>  go_to(label("ev_sequence_next")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0926"></a>"ev_sequence_last_statement",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0927"></a>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0928"></a>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-0929"></a>"ev_sequence_empty",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0930"></a>  assign("val", constant(undefined)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0931"></a>  go_to(reg("continue")),</p>
<p><a id="c005_c5-para-0932"></a>Unlike <span class="KeyTerm1">eval_sequence</span> in the metacircular evaluator, <span class="KeyTerm1">ev_sequence</span> does not need to check whether a return statement was evaluated so as to terminate the sequence evaluation. The “explicit control” in this evaluator allows a return statement to jump directly to the continuation of the current function application without resuming the sequence evaluation. Thus sequence evaluation does not need to be concerned with returns, or even be aware of the existence of return statements in the language. Because a return statement jumps out of the sequence-evaluation code, the restores of saved registers at <span class="KeyTerm1">ev_sequence_continue</span> won't be executed. We will see later how the return statement removes these values from the stack.</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0059"></a><span>5.4.2</span> <a id="c005_c5-title-0060"></a>Evaluating Function Applications</h3>
<p class="paraaftertitle"><a id="c005_c5-para-0933"></a>A function application is specified by a combination containing a function expression and argument expressions. The function expression is a subexpression whose value is a function, and the argument expressions are subexpressions whose values are the arguments to which the function should be applied. The metacircular <span class="KeyTerm1">evaluate</span> handles applications by calling itself recursively to evaluate each element of the combination, and then passing the results to <span class="KeyTerm1">apply</span>, which performs the actual function application. The explicit-control evaluator does the same thing; these recursive calls are implemented by <span class="KeyTerm1">go_to</span> instructions, together with use of the stack to save registers that will be restored after the recursive call returns. Before each call we will be careful to identify which registers must be saved (because their values will be needed later).<a id="c005_c5-fn-0023a"></a><a href="#c5-fn-0023"><sup>23</sup></a></p>
<p><a id="c005_c5-para-0934"></a>As in the metacircular evaluator, operator combinations are transformed into applications of primitive functions corresponding to the operators. This takes place at <span class="KeyTerm1">ev_operator_combination</span>, which performs this transformation in place in <span class="KeyTerm1">comp</span> and falls through to <span class="KeyTerm1">ev_application</span>.<a id="c005_c5-fn-0024a"></a><a href="#c5-fn-0024"><sup>24</sup></a></p>
<p><a id="c005_c5-para-0935"></a>We begin the evaluation of an application by evaluating the function expression to produce a function, which will later be applied to the evaluated argument expressions. To evaluate the function expression, we move it to the <span class="KeyTerm1">comp</span> register and go to <span class="KeyTerm1">eval_dispatch</span>. The environment in the <span class="KeyTerm1">env</span> register is already the correct one in which to evaluate the function expression. However, we save <span class="KeyTerm1">env</span> because we will need it later to evaluate the argument expressions. We also extract the argument expressions into <span class="KeyTerm1">unev</span> and save this on the stack. We set up <span class="KeyTerm1">continue</span> so that <span class="KeyTerm1">eval_dispatch</span> will resume at <span class="KeyTerm1">ev_appl_did_function_expression</span> after the function expression has been evaluated. First, however, we save the old value of <span class="KeyTerm1">continue</span>, which tells the controller where to continue after the application.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0936"></a>"ev_operator_combination",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0937"></a>  assign("comp", list(op("operator_combination_to_application"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0938"></a>                      reg("comp"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0939"></a>"ev_application",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0940"></a>  save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0941"></a>  save("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0942"></a>  assign("unev", list(op("arg_expressions"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0943"></a>  save("unev"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0944"></a>  assign("comp", list(op("function_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0945"></a>  assign("continue", label("ev_appl_did_function_expression")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0946"></a>  go_to(label("eval_dispatch")),</p>
<p><a id="c005_c5-para-0947"></a>Upon returning from evaluating the function expression, we proceed to evaluate the argument expressions of the application and to accumulate the resulting arguments in a list, held in <span class="KeyTerm1">argl</span>. (This is like the evaluation of a sequence of statements, except that we collect the values.) First we restore the unevaluated argument expressions and the environment. We initialize <span class="KeyTerm1">argl</span> to an empty list. Then we assign to the <span class="KeyTerm1">fun</span> register the function that was produced by evaluating the function expression. If there are no argument expressions, we go directly to <span class="KeyTerm1">apply_dispatch</span>. Otherwise we save <span class="KeyTerm1">fun</span> on the stack and start the argument-evaluation loop:<a id="c005_c5-fn-0025a"></a><a href="#c5-fn-0025"><sup>25</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-0948"></a>"ev_appl_did_function_expression",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0949"></a>  restore("unev"), <i>//</i> <span class="KeyTerm2"><i>the argument expressions</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-0950"></a>  restore("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0951"></a>  assign("argl", list(op("empty_arglist"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0952"></a>  assign("fun", reg("val")), <i>//</i> <span class="KeyTerm2"><i>the function</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-0953"></a>  test(list(op("is_null"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0954"></a>  branch(label("apply_dispatch")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0955"></a>  save("fun"),</p>
<p><a id="c005_c5-para-0956"></a>Each cycle of the argument-evaluation loop evaluates an argument expression from the list in <span class="KeyTerm1">unev</span> and accumulates the result into <span class="KeyTerm1">argl</span>. To evaluate an argument expression, we place it in the <span class="KeyTerm1">comp</span> register and go to <span class="KeyTerm1">eval_dispatch</span>, after setting <span class="KeyTerm1">continue</span> so that execution will resume with the argument-accumulation phase. But first we save the arguments accumulated so far (held in <span class="KeyTerm1">argl</span>), the environment (held in <span class="KeyTerm1">env</span>), and the remaining argument expressions to be evaluated (held in <span class="KeyTerm1">unev</span>). A special case is made for the evaluation of the last argument expression, which is handled at <span class="KeyTerm1">ev_appl_last_arg</span>.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0965"></a>"ev_appl_argument_expression_loop",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0966"></a>  save("argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0967"></a>  assign("comp", list(op("head"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0968"></a>  test(list(op("is_last_argument_expression"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0969"></a>  branch(label("ev_appl_last_arg")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0970"></a>  save("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0971"></a>  save("unev"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0972"></a>  assign("continue", label("ev_appl_accumulate_arg")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0973"></a>  go_to(label("eval_dispatch")),</p>
<p><a id="c005_c5-para-0974"></a>When an argument expression has been evaluated, the value is accumulated into the list held in <span class="KeyTerm1">argl</span>. The argument expression is then removed from the list of unevaluated argument expressions in <span class="KeyTerm1">unev</span>, and the argument-evaluation loop continues.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0975"></a>"ev_appl_accumulate_arg",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0976"></a>  restore("unev"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0977"></a>  restore("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0978"></a>  restore("argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0979"></a>  assign("argl", list(op("adjoin_arg"), reg("val"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0980"></a>  assign("unev", list(op("tail"), reg("unev"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0981"></a>  go_to(label("ev_appl_argument_expression_loop")),</p>
<p><a id="c005_c5-para-0982"></a>Evaluation of the last argument expression is handled differently, as is the last statement in a sequence. There is no need to save the environment or the list of unevaluated argument expressions before going to <span class="KeyTerm1">eval_dispatch</span>, since they will not be required after the last argument expression is evaluated. Thus, we return from the evaluation to a special entry point <span class="KeyTerm1">ev_appl_accum_last_arg</span>, which restores the argument list, accumulates the new argument, restores the saved function, and goes off to perform the application.<a id="c005_c5-fn-0026a"></a><a href="#c5-fn-0026"><sup>26</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-0983"></a>"ev_appl_last_arg",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0984"></a>  assign("continue", label("ev_appl_accum_last_arg")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0985"></a>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0986"></a>"ev_appl_accum_last_arg",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0987"></a>  restore("argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0988"></a>  assign("argl", list(op("adjoin_arg"), reg("val"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0989"></a>  restore("fun"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0990"></a>  go_to(label("apply_dispatch")),</p>
<p><a id="c005_c5-para-0991"></a>The details of the argument-evaluation loop determine the order in which the interpreter evaluates the argument expressions of a combination (e.g., left to right or right to left—see exercise 3.8). This order is not determined by the metacircular evaluator, which inherits its control structure from the underlying JavaScript in which it is implemented.<a id="c005_c5-fn-0027a"></a><a href="#c5-fn-0027"><sup>27</sup></a> Because we use <span class="KeyTerm1">head</span> in <span class="KeyTerm1">ev_appl_argument_expression_loop</span> to extract successive argument expressions from <span class="KeyTerm1">unev</span> and <span class="KeyTerm1">tail</span> at <span class="KeyTerm1">ev_appl_ accumulate_arg</span> to extract the rest of the argument expressions, the explicitcontrol evaluator will evaluate the argument expressions of a combination in left-to-right order, as required by the ECMAScript specification.</p>
<section>
<h5><a id="c005_c5-sec-0060"></a><a id="c005_c5-title-0061"></a>Function Application</h5>
<p class="paraaftertitle"><a id="c005_c5-para-0992"></a>The entry point <span class="KeyTerm1">apply_dispatch</span> corresponds to the <span class="KeyTerm1">apply</span> function of the metacircular evaluator. By the time we get to <span class="KeyTerm1">apply_dispatch</span>, the <span class="KeyTerm1">fun</span> register contains the function to apply and <span class="KeyTerm1">argl</span> contains the list of evaluated arguments to which it must be applied. The saved value of <span class="KeyTerm1">continue</span> (originally passed to <span class="KeyTerm1">eval_dispatch</span> and saved at <span class="KeyTerm1">ev_application</span>), which tells where to return with the result of the function application, is on the stack. When the application is complete, the controller transfers to the entry point specified by the saved <span class="KeyTerm1">continue</span>, with the result of the application in <span class="KeyTerm1">val</span>. As with the metacircular <span class="KeyTerm1">apply</span>, there are two cases to consider. Either the function to be applied is a primitive or it is a compound function.</p>
<p class="Sp-text-1"><a id="c005_c5-para-0993"></a>"apply_dispatch",</p>
<p class="Sp-text-1"><a id="c005_c5-para-0994"></a>  test(list(op("is_primitive_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0995"></a>  branch(label("primitive_apply")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0996"></a>  test(list(op("is_compound_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0997"></a>  branch(label("compound_apply")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-0998"></a>  go_to(label("unknown_function_type")),</p>
<p><a id="c005_c5-para-0999"></a>We assume that each primitive is implemented so as to obtain its arguments from <span class="KeyTerm1">argl</span> and place its result in <span class="KeyTerm1">val</span>. To specify how the machine handles primitives, we would have to provide a sequence of controller instructions to implement each primitive and arrange for <span class="KeyTerm1">primitive_apply</span> to dispatch to the instructions for the primitive identified by the contents of <span class="KeyTerm1">fun</span>. Since we are interested in the structure of the evaluation process rather than the details of the primitives, we will instead just use an <span class="KeyTerm1">apply_primitive_function</span> operation that applies the function in fun to the arguments in <span class="KeyTerm1">argl</span>. For the purpose of simulating the evaluator with the simulator of section 5.2 we use the function <span class="KeyTerm1">apply_primitive_function</span>, which calls on the underlying JavaScript system to perform the application, just as we did for the metacircular evaluator in section 4.1.1. After computing the value of the primitive application, we restore <span class="KeyTerm1">continue</span> and go to the designated entry point.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1000"></a>"primitive_apply",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1001"></a>  assign("val", list(op("apply_primitive_function"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1002"></a>                     reg("fun"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1003"></a>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1004"></a>  go_to(reg("continue")),</p>
<p><a id="c005_c5-para-1005"></a>The sequence of instructions labeled <span class="KeyTerm1">compound_apply</span> specifies the application of compound functions. To apply a compound function, we proceed in a way similar to what we did in the metacircular evaluator. We construct a frame that binds the function's parameters to the arguments, use this frame to extend the environment carried by the function, and evaluate in this extended environment the body of the function.</p>
<p><a id="c005_c5-para-1006"></a>At this point the compound function is in register <span class="KeyTerm1">fun</span> and its arguments are in <span class="KeyTerm1">argl</span>. We extract the function's parameters into <span class="KeyTerm1">unev</span> and its environment into <span class="KeyTerm1">env</span>. We then replace the environment in <span class="KeyTerm1">env</span> with the environment constructed by extending it with bindings of the parameters to the given arguments. We then extract the body of the function into <span class="KeyTerm1">comp</span>. The natural next step would be to restore the saved <span class="KeyTerm1">continue</span> and proceed to <span class="KeyTerm1">eval_dispatch</span> to evaluate the body and go to the restored continuation with the result in <span class="KeyTerm1">val</span>, as is done for the last statement of a sequence. But there is a complication!</p>
<p><a id="c005_c5-para-1007"></a>The complication has two aspects. One is that at any point in the evaluation of the body, a return statement may require the function to return the value of the return expression as the value of the body. But a return statement may be nested arbitrarily deeply in the body; so the stack at the moment the return statement is encountered is not necessarily the stack that is needed for a return from the function. One way to make it possible to adjust the stack for the return is to put a <i>marker</i> on the stack that can be found by the return code. This is implemented by the <span class="KeyTerm1">push_marker_to_stack</span> instruction. The return code can then use the <span class="KeyTerm1">revert_stack_to_marker</span> instruction to restore the stack to the place indicated by the marker before evaluating the return expression.<a id="c005_c5-fn-0028a"></a><a href="#c5-fn-0028"><sup>28</sup></a></p>
<p><a id="c005_c5-para-1008"></a>The other aspect of the complication is that if the evaluation of the body terminates without executing a return statement, the value of the body must be <span class="KeyTerm1">undefined</span>. To handle this, we set up the <span class="KeyTerm1">continue</span> register to point to the entry point <span class="KeyTerm1">return_undefined</span> before going off to <span class="KeyTerm1">eval_dispatch</span> to evaluate the body. If a return statement is not encountered during evaluation of the body, evaluation of the body will continue at <span class="KeyTerm1">return_undefined</span>.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1009"></a>"compound_apply",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1010"></a>  assign("unev", list(op("function_parameters"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1011"></a>  assign("env", list(op("function_environment"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1012"></a>  assign("env", list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1013"></a>                     reg("unev"), reg("argl"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1014"></a>  assign("comp", list(op("function_body"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1015"></a>  push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1016"></a>  assign("continue", label("return_undefined")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1017"></a>  go_to(label("eval_dispatch")),</p>
<p><a id="c005_c5-para-1018"></a>The only places in the interpreter where the <span class="KeyTerm1">env</span> register is assigned a new value are <span class="KeyTerm1">compound_apply</span> and <span class="KeyTerm1">ev_block</span> (section 5.4.3). Just as in the metacircular evaluator, the new environment for evaluation of a function body is constructed from the environment carried by the function, together with the argument list and the corresponding list of names to be bound.</p>
<p><a id="c005_c5-para-1019"></a>When a return statement is evaluated at <span class="KeyTerm1">ev_return</span>, we use the <span class="KeyTerm1">revert_stack_</span> <span class="KeyTerm1">to_marker</span> instruction to restore the stack to its state at the beginning of the function call by removing all values from the stack down to and including the marker. As a consequence, <span class="KeyTerm1">restore("continue")</span> will restore the continuation of the function call, which was saved at <span class="KeyTerm1">ev_application</span>. We then proceed to evaluate the return expression, whose result will be placed in <span class="KeyTerm1">val</span> and thus be the value returned from the function when we continue after the evaluation of the return expression.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1020"></a>"ev_return",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1021"></a>  revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1022"></a>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1023"></a>  assign("comp", list(op("return_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1024"></a>  go_to(label("eval_dispatch")),</p>
<p><a id="c005_c5-para-1025"></a>If no return statement is encountered during evaluation of the function body, evaluation continues at <span class="KeyTerm1">return_undefined</span>, the continuation that was set up at <span class="KeyTerm1">compound_apply</span>. To return <span class="KeyTerm1">undefined</span> from the function, we put <span class="KeyTerm1">undefined</span> into <span class="KeyTerm1">val</span> and go to the entry point that was put onto the stack at <span class="KeyTerm1">ev_application</span>. Before we can restore that continuation from the stack, however, we must remove the marker that was saved at <span class="KeyTerm1">compound_apply</span>.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1026"></a>"return_undefined",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1027"></a>  revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1028"></a>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1029"></a>  assign("val", constant(undefined)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1030"></a>  go_to(reg("continue")),</p>
</section>
<section>
<h5><a id="c005_c5-sec-0061"></a><a id="c005_c5-title-0062"></a>Return Statements and Tail Recursion</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1031"></a>In chapter 1 we said that the process described by a function such as</p>
<p class="Sp-text-1"><a id="c005_c5-para-1032"></a><b>function</b> sqrt_iter(guess, x) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1033"></a> <b>return</b> is_good_enough(guess, x)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1034"></a>           ? guess</p>
<p class="Sp-text-1"><a id="c005_c5-para-1035"></a>           : sqrt_iter(improve(guess, x), x);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1036"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1037"></a>is an iterative process. Even though the function is syntactically recursive (defined in terms of itself), it is not logically necessary for an evaluator to save information in passing from one call to <span class="KeyTerm1">sqrt_iter</span> to the next.<a id="c005_c5-fn-0029a"></a><a href="#c5-fn-0029"><sup>29</sup></a> An evaluator that can execute a function such as <span class="KeyTerm1">sqrt_iter</span> without requiring increasing storage as the function continues to call itself is called a <i>tail-recursive</i> evaluator.</p>
<p><a id="c005_c5-para-1038"></a>The metacircular implementation of the evaluator in chapter 4 isn't tail-recursive. It implements a return statement as a constructor of a return value object containing the value to be returned and inspects the result of a function call to see whether it is such an object. If the evaluation of a function body produces a return value object, the return value of the function is the contents of that object; otherwise, the return value is <span class="KeyTerm1">undefined</span>. Both the construction of the return value object and the eventual inspection of the result of the function call are deferred operations, which lead to an accumulation of information on the stack.</p>
<p><a id="c005_c5-para-1039"></a>Our explicit-control evaluator <i>is</i> tail-recursive, because it does not need to wrap up return values for inspection and thus avoids the buildup of stack from deferred operations. At <span class="KeyTerm1">ev_return</span>, in order to evaluate the expression that computes the return value of a function, we transfer directly to <span class="KeyTerm1">eval_dispatch</span> with nothing more on the stack than right before the function call. We accomplish this by undoing any saves to the stack by the function (which are useless because we are returning) using <span class="KeyTerm1">revert_stack_to_marker</span>. Then, rather than arranging for <span class="KeyTerm1">eval_dispatch</span> to come back here and <i>then</i> restoring <span class="KeyTerm1">continue</span> from the stack and continuing at that entry point, we restore <span class="KeyTerm1">continue</span> from the stack <i>before</i> going to <span class="KeyTerm1">eval_dispatch</span> so that <span class="KeyTerm1">eval_dispatch</span> will continue at that entry point after evaluating the expression. Finally, we transfer to <span class="KeyTerm1">eval_dispatch</span> without saving any information on the stack. Thus, when we proceed to evaluate a return expression, the stack is the same as just before the call to the function whose return value we are about to compute. Hence, evaluating a return expression—even if it is a function call (as in <span class="KeyTerm1">sqrt_iter</span>, where the conditional expression reduces to a call to <span class="KeyTerm1">sqrt_iter</span>)—will not cause any information to accumulate on the stack.<a id="c005_c5-fn-0030a"></a><a href="#c5-fn-0030"><sup>30</sup></a></p>
<p><a id="c005_c5-para-1040"></a>If we did not think to take advantage of the fact that it is unnecessary to hold on to the useless information on the stack while evaluating a return expression, we might have taken the straightforward approach of evaluating the return expression, coming back to restore the stack, and finally continuing at the entry point that is waiting for the result of the function call:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1041"></a>"ev_return",  <i>//</i> <span class="KeyTerm2"><i>alternative implementation: not tail-recursive</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1042"></a>  assign("comp", list(op("return_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1043"></a>  assign("continue", label("ev_restore_stack")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1044"></a>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1045"></a>"ev_restore_stack",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1046"></a>revert_stack_to_marker(),     <i>//</i> <span class="KeyTerm2"><i>undo saves in current function</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1047"></a>restore("continue"),          <i>//</i> <span class="KeyTerm2"><i>undo save at</i></span> ev_application</p>
<p class="Sp-text-1"><a id="c005_c5-para-1048"></a>  go_to(reg("continue")),</p>
<p><a id="c005_c5-para-1049"></a>This may seem like a minor change to our previous code for evaluation of return statements: The only difference is that we delay undoing any register saves to the stack until after the evaluation of the return expression. The interpreter will still give the same value for any expression. But this change is fatal to the tail-recursive implementation, because we must now come back after evaluating the return expression in order to undo the (useless) register saves. These extra saves will accumulate during a nest of function calls. Consequently, processes such as <span class="KeyTerm1">sqrt_iter</span> will require space proportional to the number of iterations rather than requiring constant space. This difference can be significant. For example, with tail recursion, an infinite loop can be expressed using only the function-call and return mechanisms:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1050"></a><b>function</b> count(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1051"></a>    display(n);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1052"></a> <b>return</b> count(n + 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1053"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1054"></a>Without tail recursion, such a function would eventually run out of stack space, and expressing a true iteration would require some control mechanism other than function call.</p>
<p><a id="c005_c5-para-1055"></a>Note that our JavaScript implementation requires the use of <span class="KeyTerm1"><b>return</b></span> in order to be tail-recursive. Because the undoing of the register saves takes place at <span class="KeyTerm1">ev_return</span>, removing <span class="KeyTerm1"><b>return</b></span> from the <span class="KeyTerm1">count</span> function above will cause it to eventually run out of stack space. This explains the use of <span class="KeyTerm1"><b>return</b></span> in the infinite driver loops in chapter 4.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0062"></a><a id="c005_c5-title-0063"></a>Exercise 5.22</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1056"></a>Explain how the stack builds up if <span class="KeyTerm1"><b>return</b></span> is removed from <span class="KeyTerm1">count</span>:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1057"></a><b>function</b> count(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1058"></a>    display(n);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1059"></a>    count(n + 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1060"></a>}</p>
</section>
<section>
<h5><a id="c005_c5-sec-0063"></a><a id="c005_c5-title-0064"></a>Exercise 5.23</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1061"></a>Implement the equivalent of <span class="KeyTerm1">push_marker_to_stack</span> by using <span class="KeyTerm1">save</span> at <span class="KeyTerm1">compound_apply</span> to store a special marker value on the stack. Implement the equivalent of <span class="KeyTerm1">revert_stack_ to_marker</span> at <span class="KeyTerm1">ev_return</span> and <span class="KeyTerm1">return_undefined</span> as a loop that repeatedly performs a <span class="KeyTerm1">restore</span> until it hits the marker. Note that this will require restoring a value to a register other than the one it was saved from. (Although we are careful to avoid that in our evaluator, our stack implementation actually allows it. See exercise 5.10.) This is necessary because the only way to pop from the stack is by restoring to a register. Hint: You will need to create a unique constant to serve as the marker, for example with <span class="KeyTerm1"><b>const</b> marker = list("marker")</span>. Because <span class="KeyTerm1">list</span> creates a new pair, it cannot be <span class="KeyTerm1">===</span> to anything else on the stack.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0064"></a><a id="c005_c5-title-0065"></a>Exercise 5.24</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1062"></a>Implement <span class="KeyTerm1">push_marker_to_stack</span> and <span class="KeyTerm1">revert_stack_to_marker</span> as register-machine instructions, following the implementation of <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> in section 5.2.3. Add functions <span class="KeyTerm1">push_marker</span> and <span class="KeyTerm1">pop_marker</span> to access stacks, mirroring the implementation of <span class="KeyTerm1">push</span> and <span class="KeyTerm1">pop</span> in section 5.2.1. Note that you do not need to actually insert a marker into the stack. Instead, you can add a local state variable to the stack model to keep track of the position of the last <span class="KeyTerm1">save</span> before each <span class="KeyTerm1">push_marker_to_stack</span>. If you choose to put a marker on the stack, see the hint in exercise 5.23.</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0065"></a><span>5.4.3</span> <a id="c005_c5-title-0066"></a>Blocks, Assignments, and Declarations</h3>
<section>
<h5><a id="c005_c5-sec-0066"></a><a id="c005_c5-title-0067"></a>Blocks</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1063"></a>The body of a block is evaluated with respect to the current environment extended by a frame that binds all local names to the value <span class="KeyTerm1">"*unassigned*"</span>. We temporarily make use of the <span class="KeyTerm1">val</span> register to hold the list of all variables declared in the block, which is obtained by <span class="KeyTerm1">scan_out_declarations</span> from section 4.1.1. The functions <span class="KeyTerm1">scan_out_declarations</span> and <span class="KeyTerm1">list_of_unassigned</span> are assumed to be available as machine operations.<a id="c005_c5-fn-0031a"></a><a href="#c5-fn-0031"><sup>31</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-1064"></a>"ev_block",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1065"></a>  assign("comp", list(op("block_body"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1066"></a>  assign("val", list(op("scan_out_declarations"), reg("comp"))),</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-1067"></a>save("comp"), <i>//</i> <span class="KeyTerm2"><i>so we can use it to temporarily hold</i></span> *unassigned* <span class="KeyTerm2"><i>values</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1068"></a>  assign("comp", list(op("list_of_unassigned"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1069"></a>  assign("env", list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1070"></a>                     reg("val"), reg("comp"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1071"></a>  restore("comp"), <i>//</i> <span class="KeyTerm2"><i>the block body</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1072"></a>  go_to(label("eval_dispatch")),</p>
</section>
<section>
<h5><a id="c005_c5-sec-0067"></a><a id="c005_c5-title-0068"></a>Assignments and declarations</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1073"></a>Assignments are handled by <span class="KeyTerm1">ev_assignment</span>, reached from <span class="KeyTerm1">eval_dispatch</span> with the assignment expression in <span class="KeyTerm1">comp</span>. The code at <span class="KeyTerm1">ev_assignment</span> first evaluates the value part of the expression and then installs the new value in the environment. The function <span class="KeyTerm1">assign_symbol_value</span> is assumed to be available as a machine operation.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1074"></a>"ev_assignment",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1075"></a>  assign("unev", list(op("assignment_symbol"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1076"></a>  save("unev"), <i>//</i> <span class="KeyTerm2"><i>save variable for later</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1077"></a>  assign("comp", list(op("assignment_value_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1078"></a>  save("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1079"></a>  save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1080"></a>  assign("continue", label("ev_assignment_install")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1081"></a>  go_to(label("eval_dispatch")), <i>//</i> <span class="KeyTerm2"><i>evaluate assignment value</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1082"></a>"ev_assignment_install",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1083"></a>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1084"></a>  restore("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1085"></a>  restore("unev"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1086"></a>  perform(list(op("assign_symbol_value"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1087"></a>               reg("unev"), reg("val"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1088"></a>  go_to(reg("continue")),</p>
<p><a id="c005_c5-para-1089"></a>Declarations of variables and constants are handled in a similar way. Note that whereas the value of an assignment is the value that was assigned, the value of a declaration is <span class="KeyTerm1">undefined</span>. This is handled by setting <span class="KeyTerm1">val</span> to <span class="KeyTerm1">undefined</span> before continuing. As in the metacircular evaluator, we transform a function declaration into a constant declaration whose value expression is a lambda expression. This happens at <span class="KeyTerm1">ev_function_declaration</span>, which makes the transformation in place in <span class="KeyTerm1">comp</span> and falls through to <span class="KeyTerm1">ev_declaration</span>.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1090"></a>"ev_function_declaration",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1091"></a>  assign("comp",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1092"></a>         list(op("function_decl_to_constant_decl"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1093"></a>"ev_declaration",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1094"></a>  assign("unev", list(op("declaration_symbol"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1095"></a>  save("unev"), <i>//</i> <span class="KeyTerm2"><i>save declared name</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1096"></a>  assign("comp",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1097"></a>         list(op("declaration_value_expression"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1098"></a>  save("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1099"></a>  save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1100"></a>  assign("continue", label("ev_declaration_assign")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1101"></a>  go_to(label("eval_dispatch")), <i>//</i> <span class="KeyTerm2"><i>evaluate declaration value</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1102"></a>"ev_declaration_assign",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1103"></a>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1104"></a>  restore("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1105"></a>  restore("unev"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1106"></a>  perform(list(op("assign_symbol_value"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1107"></a>               reg("unev"), reg("val"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1108"></a>  assign("val", constant(undefined)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1109"></a>  go_to(reg("continue")),</p>
</section>
<section>
<h5><a id="c005_c5-sec-0068"></a><a id="c005_c5-title-0069"></a>Exercise 5.25</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1110"></a>Extend the evaluator to handle while loops, by translating them to applications of a function <span class="KeyTerm1">while_loop</span>, as shown in exercise 4.7. You can paste the declaration of the function <span class="KeyTerm1">while_loop</span> in front of user programs. You may “cheat” by assuming that the syntax transformer <span class="KeyTerm1">while_to_application</span> is available as a machine operation. Refer to exercise 4.7 to discuss whether this approach works if return, break, and continue statements are allowed inside the while loop. If not, how can you modify the explicit-control evaluator to run programs with while loops that include these statements?</p>
</section>
<section>
<h5><a id="c005_c5-sec-0069"></a><a id="c005_c5-title-0070"></a>Exercise 5.26</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1111"></a>Modify the evaluator so that it uses normal-order evaluation, based on the lazy evaluator of section 4.2.</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0070"></a><span>5.4.4</span> <a id="c005_c5-title-0071"></a>Running the Evaluator</h3>
<p class="paraaftertitle"><a id="c005_c5-para-1112"></a>With the implementation of the explicit-control evaluator we come to the end of a development, begun in chapter 1, in which we have explored successively more precise models of the evaluation process. We started with the relatively informal substitution model, then extended this in chapter 3 to the environment model, which enabled us to deal with state and change. In the metacircular evaluator of chapter 4, we used JavaScript itself as a language for making more explicit the environment structure constructed during evaluation of an component. Now, with register machines, we have taken a close look at the evaluator's mechanisms for storage management, argument passing, and control. At each new level of description, we have had to raise issues and resolve ambiguities that were not apparent at the previous, less precise treatment of evaluation. To understand the behavior of the explicit-control evaluator, we can simulate it and monitor its performance.</p>
<p><a id="c005_c5-para-1113"></a>We will install a driver loop in our evaluator machine. This plays the role of the <span class="KeyTerm1">driver_loop</span> function of section 4.1.4. The evaluator will repeatedly print a prompt, read a program, evaluate the program by going to <span class="KeyTerm1">eval_dispatch</span>, and print the result. If nothing is entered at the prompt, we jump to the label <span class="KeyTerm1">evaluator_done</span>, which is the last entry point in the controller. The following instructions form the beginning of the explicit-control evaluator's controller sequence:<a id="c005_c5-fn-0032a"></a><a href="#c5-fn-0032"><sup>32</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-1114"></a>"read_evaluate_print_loop",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1115"></a>  perform(list(op("initialize_stack"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1116"></a>  assign("comp", list(op("user_read"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1117"></a>                      constant("EC-evaluate input:"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1118"></a>  assign("comp", list(op("parse"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1119"></a>  test(list(op("is_null"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1120"></a>  branch(label("evaluator_done")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1121"></a>  assign("env", list(op("get_current_environment"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1122"></a>  assign("val", list(op("scan_out_declarations"), reg("comp"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1123"></a>  save("comp"),    <i>//</i> <span class="KeyTerm2"><i>so we can use it to temporarily hold</i></span> *unassigned* <span class="KeyTerm2"><i>values</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1124"></a>  assign("comp", list(op("list_of_unassigned"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1125"></a>  assign("env", list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1126"></a>                     reg("val"), reg("comp"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1127"></a>  perform(list(op("set_current_environment"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1128"></a>  restore("comp"), <i>//</i> <span class="KeyTerm2"><i>the program</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1129"></a>  assign("continue", label("print_result")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1130"></a>  go_to(label("eval_dispatch")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1131"></a>"print_result",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1132"></a>  perform(list(op("user_print"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1133"></a>               constant("EC-evaluate value:"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1134"></a>  go_to(label("read_evaluate_print_loop")),</p>
<p class="paracontinue"><a id="c005_c5-para-1135"></a>We store the current environment, initially the global environment, in the variable <span class="KeyTerm1">current_environment</span> and update it each time around the loop to remember past declarations. The operations <span class="KeyTerm1">get_current_environment</span> and <span class="KeyTerm1">set_current_ environment</span> simply get and set this variable.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1136"></a><b>let</b> current_environment = the_global_environment;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1137"></a><b>function</b> get_current_environment() {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1138"></a> <b>return</b> current_environment;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1139"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1140"></a><b>function</b> set_current_environment(env) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1141"></a>    current_environment = env;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1142"></a>}</p>
<p><a id="c005_c5-para-1143"></a>When we encounter an error in a function (such as the “unknown function type” error indicated at <span class="KeyTerm1">apply_dispatch</span>), we print an error message and return to the driver loop.<a id="c005_c5-fn-0033a"></a><a href="#c5-fn-0033"><sup>33</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-1144"></a>"unknown_component_type",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1145"></a>  assign("val", constant("unknown syntax")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1146"></a>  go_to(label("signal_error")),</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-1147"></a>"unknown_function_type",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1148"></a>  restore("continue"), <i>//</i> <span class="KeyTerm2"><i>clean up stack (from</i></span> apply_dispatch<span class="KeyTerm2"><i>)</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1149"></a>  assign("val", constant("unknown function type")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1150"></a>  go_to(label("signal_error")),</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-1151"></a>"signal_error",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1152"></a>  perform(list(op("user_print"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1153"></a>               constant("EC-evaluator error:"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1154"></a>  go_to(label("read_evaluate_print_loop")),</p>
<p><a id="c005_c5-para-1155"></a>For the purposes of the simulation, we initialize the stack each time through the driver loop, since it might not be empty after an error (such as an undeclared name) interrupts an evaluation.<a id="c005_c5-fn-0034a"></a><a href="#c5-fn-0034"><sup>34</sup></a></p>
<p><a id="c005_c5-para-1156"></a>If we combine all the code fragments presented in sections 5.4.1–5.4.4, we can create an evaluator machine model that we can run using the register-machine simulator of section 5.2.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1157"></a><b>const</b> eceval = make_machine(list("comp", "env", "val", "fun",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1158"></a>                                 "argl", "continue", "unev"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1159"></a>                            eceval_operations,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1160"></a>                            list("read_evaluate_print_loop",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1161"></a>                                 〈<i>entire machine controller as given above</i>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1162"></a>                                 "evaluator_done"));</p>
<p class="paracontinue"><a id="c005_c5-para-1163"></a>We must define JavaScript functions to simulate the operations used as primitives by the evaluator. These are the same functions we used for the metacircular evaluator in section 4.1, together with the few additional ones defined in footnotes throughout section 5.4.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1164"></a><b>const</b> eceval_operations = list(list("is_literal", is_literal),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1165"></a>                               〈<i>complete list of operations for eceval machine</i>〉);</p>
<p><a id="c005_c5-para-1166"></a>Finally, we can initialize the global environment and run the evaluator:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1167"></a><b>const</b> the_global_environment = setup_environment();</p>
<p class="Sp-text-1"><a id="c005_c5-para-1168"></a>start(eceval);</p>
<p class="Sp-text-3"><a id="c005_c5-para-1169"></a><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-1170"></a><b>function</b> append(x, y) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1171"></a> <b>return</b> is_null(x)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1172"></a>           ? y</p>
<p class="Sp-text-1"><a id="c005_c5-para-1173"></a>           : pair(head(x), append(tail(x), y));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1174"></a>}</p>
<p class="Sp-text-3"><a id="c005_c5-para-1175"></a><i>EC-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-1176"></a><i>undefined</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-1177"></a><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-1178"></a>append(list("a", "b", "c"), list("d", "e", "f"));</p>
<p class="Sp-text-3"><a id="c005_c5-para-1179"></a><i>EC-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-1180"></a><i>["a", ["b", ["c", ["d", ["e", ["f", null]]]]]]</i></p>
<p><a id="c005_c5-para-1181"></a>Of course, evaluating programs in this way will take much longer than if we had directly typed them into JavaScript, because of the multiple levels of simulation involved. Our programs are evaluated by the explicit-control-evaluator machine, which is being simulated by a JavaScript program, which is itself being evaluated by the JavaScript interpreter.</p>
<section>
<h5><a id="c005_c5-sec-0071"></a><a id="c005_c5-title-0072"></a>Monitoring the performance of the evaluator</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1182"></a>Simulation can be a powerful tool to guide the implementation of evaluators. Simulations make it easy not only to explore variations of the register-machine design but also to monitor the performance of the simulated evaluator. For example, one important factor in performance is how efficiently the evaluator uses the stack. We can observe the number of stack operations required to evaluate various programs by defining the evaluator register machine with the version of the simulator that collects statistics on stack use (section 5.2.4), and adding an instruction at the evaluator's <span class="KeyTerm1">print_result</span> entry point to print the statistics:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1183"></a>"print_result",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1184"></a>  perform(list(op("print_stack_statistics"))), <i>//</i> <span class="KeyTerm2"><i>added instruction</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1185"></a> <i>//</i> <span class="KeyTerm2"><i>rest is same as before</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1186"></a>  perform(list(op("user_print"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1187"></a>               constant("EC-evaluate value:"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1188"></a>  go_to(label("read_evaluate_print_loop")),</p>
<p class="paracontinue"><a id="c005_c5-para-1189"></a>Interactions with the evaluator now look like this:</p>
<p class="Sp-text-3"><a id="c005_c5-para-1190"></a><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-1191"></a><b>function</b> factorial (n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1192"></a> <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1193"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1194"></a>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1195"></a>}</p>
<p class="Sp-text-3"><a id="c005_c5-para-1196"></a><i>total pushes = 4</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-1197"></a><i>maximum depth = 3</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-1198"></a><i>EC-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-1199"></a><i>undefined</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-1200"></a><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-1201"></a>factorial(5);</p>
<p class="Sp-text-3"><a id="c005_c5-para-1202"></a><i>total pushes = 151</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-1203"></a><i>maximum depth = 28</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-1204"></a><i>EC-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-1205"></a><i>120</i></p>
<p class="paracontinue"><a id="c005_c5-para-1206"></a>Note that the driver loop of the evaluator reinitializes the stack at the start of each interaction, so that the statistics printed will refer only to stack operations used to evaluate the previous program.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0072"></a><a id="c005_c5-title-0073"></a>Exercise 5.27</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1207"></a>Use the monitored stack to explore the tail-recursive property of the evaluator (section 5.4.2). Start the evaluator and define the iterative <span class="KeyTerm1">factorial</span> function from section 1.2.1:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1208"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1209"></a> <b>function</b> iter(product, counter) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1210"></a> <b>return</b> counter &gt; n</p>
<p class="Sp-text-1"><a id="c005_c5-para-1211"></a>           ? product</p>
<p class="Sp-text-1"><a id="c005_c5-para-1212"></a>           : iter(counter * product,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1213"></a>                  counter + 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1214"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-1215"></a> <b>return</b> iter(1, 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1216"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1217"></a>Run the function with some small values of <i>n</i>. Record the maximum stack depth and the number of pushes required to compute <i>n</i>! for each of these values.</p>
<ol class="BS_NumberListA">
<li><a id="c005_c5-li-0024"></a><span>a. </span>You will find that the maximum depth required to evaluate <i>n</i>! is independent of <i>n</i>. What is that depth?</li>
<li><a id="c005_c5-li-0025"></a><span>b. </span>Determine from your data a formula in terms of <i>n</i> for the total number of push operations used in evaluating <i>n</i>! for any <i>n</i> 1. Note that the number of operations used is a linear function of <i>n</i> and is thus determined by two constants.</li>
</ol>
</section>
<section>
<h5><a id="c005_c5-sec-0073"></a><a id="c005_c5-title-0074"></a>Exercise 5.28</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1220"></a>For comparison with exercise 5.27, explore the behavior of the following function for computing factorials recursively:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1221"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1222"></a> <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1223"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1224"></a>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1225"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1226"></a>By running this function with the monitored stack, determine, as a function of <i>n</i>, the maximum depth of the stack and the total number of pushes used in evaluating <i>n</i>! for <i>n</i> 1. (Again, these functions will be linear.) Summarize your experiments by filling in the following table with the appropriate expressions in terms of <i>n</i>:</p>
<figure><figcaption class="tablecaption"><a id="c005_c5-tbl-0001"></a></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr style="border-bottom: 1px solid #000000;">
<td style="border-right: 1px solid #000000;"></td>
<td style="border-right: 1px solid #000000;"><a id="c005_c5-para-1227"></a>Maximum depth</td>
<td><a id="c005_c5-para-1228"></a>Number of pushes</td></tr>
<tr style="border-bottom: 1px solid #000000;">
<td style="border-right: 1px solid #000000;"><a id="c005_c5-para-1229"></a>Recursive factorial</td>
<td style="border-right: 1px solid #000000;"></td>
<td></td></tr>
<tr style="border-bottom: 1px solid #000000;">
<td style="border-right: 1px solid #000000;"><a id="c005_c5-para-1230"></a>Iterative factorial</td>
<td style="border-right: 1px solid #000000;"></td>
<td></td></tr></tbody></table></div></figure>
<p class="paracontinue"><a id="c005_c5-para-1231"></a>The maximum depth is a measure of the amount of space used by the evaluator in carrying out the computation, and the number of pushes correlates well with the time required.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0074"></a><a id="c005_c5-title-0075"></a>Exercise 5.29</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1232"></a>Modify the definition of the evaluator by changing <span class="KeyTerm1">ev_return</span> as described in section 5.4.2 so that the evaluator is no longer tail-recursive. Rerun your experiments from exercises 5.27 and 5.28 to demonstrate that both versions of the <span class="KeyTerm1">factorial</span> function now require space that grows linearly with their input.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0075"></a><a id="c005_c5-title-0076"></a>Exercise 5.30</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1233"></a>Monitor the stack operations in the tree-recursive Fibonacci computation:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1234"></a><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1235"></a> <b>return</b> n &lt; 2 ? n : fib(n - 1) + fib(n - 2);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1236"></a>}</p>
<ol class="BS_NumberListA">
<li><a id="c005_c5-li-0026"></a><span>a. </span>Give a formula in terms of <i>n</i> for the maximum depth of the stack required to compute Fib(<i>n</i>) for <i>n ≥</i> 2. Hint: In section 1.2.2 we argued that the space used by this process grows linearly with <i>n</i>.</li>
<li><a id="c005_c5-li-0027"></a><span>b. </span>Give a formula for the total number of pushes used to compute Fib(<i>n</i>) for <i>n ≥</i> 2. You should find that the number of pushes (which correlates well with the time used) grows exponentially with <i>n</i>. Hint: Let <i>S</i>(<i>n</i>) be the number of pushes used in computing Fib(<i>n</i>). You should be able to argue that there is a formula that expresses <i>S</i>(<i>n</i>) in terms of <i>S</i>(<i>n</i> – 1), <i>S</i>(<i>n</i> – 2), and some fixed “overhead” constant <i>k</i> that is independent of <i>n</i>. Give the formula, and say what <i>k</i> is. Then show that <i>S</i>(<i>n</i>) can be expressed as <i>a</i>Fib(<i>n</i> + 1) + <i>b</i> and give the values of <i>a</i> and <i>b</i>.</li>
</ol>
</section>
<section>
<h5><a id="c005_c5-sec-0076"></a><a id="c005_c5-title-0077"></a>Exercise 5.31</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1239"></a>Our evaluator currently catches and signals only two kinds of errors—unknown component types and unknown function types. Other errors will take us out of the evaluator read-evaluate-print loop. When we run the evaluator using the register-machine simulator, these errors are caught by the underlying JavaScript system. This is analogous to the computer crashing when a user program makes an error.<a id="c005_c5-fn-0035a"></a><a href="#c5-fn-0035"><sup>35</sup></a> It is a large project to make a real error system work, but it is well worth the effort to understand what is involved here.</p>
<ol class="BS_NumberListA">
<li><a id="c005_c5-li-0028"></a><span>a. </span>Errors that occur in the evaluation process, such as an attempt to access an unbound name, could be caught by changing the lookup operation to make it return a distinguished condition code, which cannot be a possible value of any user name. The evaluator can test for this condition code and then do what is necessary to go to <span class="KeyTerm1">signal_error</span>. Find all of the places in the evaluator where such a change is necessary and fix them. This is lots of work.</li>
<li><a id="c005_c5-li-0029"></a><span>b. </span>Much worse is the problem of handling errors that are signaled by applying primitive functions such as an attempt to divide by zero or an attempt to extract the <span class="KeyTerm1">head</span> of a string. In a professionally written high-quality system, each primitive application is checked for safety as part of the primitive. For example, every call to <span class="KeyTerm1">head</span> could first check that the argument is a pair. If the argument is not a pair, the application would return a distinguished condition code to the evaluator, which would then report the failure. We could arrange for this in our register-machine simulator by making each primitive function check for applicability and returning an appropriate distinguished condition code on failure. Then the <span class="KeyTerm1">primitive_apply</span> code in the evaluator can check for the condition code and go to <span class="KeyTerm1">signal_error</span> if necessary. Build this structure and make it work. This is a major project.</li>
</ol>
</section>
</section>
</section>
<section>
<h2><a id="c005_c5-sec-0077"></a><span>5.5</span> <a id="c005_c5-title-0078"></a>Compilation</h2>
<p class="paraaftertitle"><a id="c005_c5-para-1242"></a>The explicit-control evaluator of section 5.4 is a register machine whose controller interprets JavaScript programs. In this section we will see how to run JavaScript programs on a register machine whose controller is not a JavaScript interpreter.</p>
<p><a id="c005_c5-para-1243"></a>The explicit-control evaluator machine is universal—it can carry out any computational process that can be described in JavaScript. The evaluator's controller orchestrates the use of its data paths to perform the desired computation. Thus, the evaluator's data paths are universal: They are sufficient to perform any computation we desire, given an appropriate controller.<a id="c005_c5-fn-0036a"></a><a href="#c5-fn-0036"><sup>36</sup></a></p>
<p><a id="c005_c5-para-1244"></a>Commercial general-purpose computers are register machines organized around a collection of registers and operations that constitute an efficient and convenient universal set of data paths. The controller for a general-purpose machine is an interpreter for a register-machine language like the one we have been using. This language is called the <i>native language</i> of the machine, or simply <i>machine language</i>. Programs written in machine language are sequences of instructions that use the machine's data paths. For example, the explicit-control evaluator's instruction sequence can be thought of as a machine-language program for a general-purpose computer rather than as the controller for a specialized interpreter machine.</p>
<p><a id="c005_c5-para-1245"></a>There are two common strategies for bridging the gap between higher-level languages and register-machine languages. The explicit-control evaluator illustrates the strategy of interpretation. An interpreter written in the native language of a machine configures the machine to execute programs written in a language (called the <i>source language</i>) that may differ from the native language of the machine performing the evaluation. The primitive functions of the source language are implemented as a library of subroutines written in the native language of the given machine. A program to be interpreted (called the <i>source program</i>) is represented as a data structure. The interpreter traverses this data structure, analyzing the source program. As it does so, it simulates the intended behavior of the source program by calling appropriate primitive subroutines from the library.</p>
<p><a id="c005_c5-para-1246"></a>In this section, we explore the alternative strategy of <i>compilation</i>. A compiler for a given source language and machine translates a source program into an equivalent program (called the <i>object program</i>) written in the machine's native language. The compiler that we implement in this section translates programs written in JavaScript into sequences of instructions to be executed using the explicit-control evaluator machine's data paths.<a id="c005_c5-fn-0037a"></a><a href="#c5-fn-0037"><sup>37</sup></a></p>
<p><a id="c005_c5-para-1247"></a>Compared with interpretation, compilation can provide a great increase in the efficiency of program execution, as we will explain below in the overview of the compiler. On the other hand, an interpreter provides a more powerful environment for interactive program development and debugging, because the source program being executed is available at run time to be examined and modified. In addition, because the entire library of primitives is present, new programs can be constructed and added to the system during debugging.</p>
<p><a id="c005_c5-para-1248"></a>In view of the complementary advantages of compilation and interpretation, modern program-development environments pursue a mixed strategy. These systems are generally organized so that interpreted functions and compiled functions can call each other. This enables a programmer to compile those parts of a program that are assumed to be debugged, thus gaining the efficiency advantage of compilation, while retaining the interpretive mode of execution for those parts of the program that are in the flux of interactive development and debugging.<a id="c005_c5-fn-0038a"></a><a href="#c5-fn-0038"><sup>38</sup></a> In section 5.5.7, after we have implemented the compiler, we will show how to interface it with our interpreter to produce an integrated interpreter-compiler system.</p>
<section><a id="c005_c5-title-0079"></a>
<section>
<h5><a id="c005_c5-sec-0079"></a><a id="c005_c5-title-0080"></a>An overview of the compiler</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1249"></a>Our compiler is much like our interpreter, both in its structure and in the function it performs. Accordingly, the mechanisms used by the compiler for analyzing components will be similar to those used by the interpreter. Moreover, to make it easy to interface compiled and interpreted code, we will design the compiler to generate code that obeys the same conventions of register usage as the interpreter: The environment will be kept in the <span class="KeyTerm1">env</span> register, argument lists will be accumulated in <span class="KeyTerm1">argl</span>, a function to be applied will be in <span class="KeyTerm1">fun</span>, functions will return their answers in <span class="KeyTerm1">val</span>, and the location to which a function should return will be kept in <span class="KeyTerm1">continue</span>. In general, the compiler translates a source program into an object program that performs essentially the same register operations as would the interpreter in evaluating the same source program.</p>
<p><a id="c005_c5-para-1250"></a>This description suggests a strategy for implementing a rudimentary compiler: We traverse the component in the same way the interpreter does. When we encounter a register instruction that the interpreter would perform in evaluating the component, we do not execute the instruction but instead accumulate it into a sequence. The resulting sequence of instructions will be the object code. Observe the efficiency advantage of compilation over interpretation. Each time the interpreter evaluates a component—for example, <span class="KeyTerm1">f(96, 22)</span>—it performs the work of classifying the component (discovering that this is a function application) and testing for the end of the list of argument expressions (discovering that there are two argument expressions). With a compiler, the component is analyzed only once, when the instruction sequence is generated at compile time. The object code produced by the compiler contains only the instructions that evaluate the function expression and the two argument expressions, assemble the argument list, and apply the function (in <span class="KeyTerm1">fun</span>) to the arguments (in <span class="KeyTerm1">argl</span>).</p>
<p><a id="c005_c5-para-1251"></a>This is the same kind of optimization we implemented in the analyzing evaluator of section 4.1.7. But there are further opportunities to gain efficiency in compiled code. As the interpreter runs, it follows a process that must be applicable to any component in the language. In contrast, a given segment of compiled code is meant to execute some particular component. This can make a big difference, for example in the use of the stack to save registers. When the interpreter evaluates a component, it must be prepared for any contingency. Before evaluating a subcomponent, the interpreter saves all registers that will be needed later, because the subcomponent might require an arbitrary evaluation. A compiler, on the other hand, can exploit the structure of the particular component it is processing to generate code that avoids unnecessary stack operations.</p>
<p><a id="c005_c5-para-1252"></a>As a case in point, consider the application <span class="KeyTerm1">f(96, 22)</span>. Before the interpreter evaluates the function expression of the application, it prepares for this evaluation by saving the registers containing the argument expressions and the environment, whose values will be needed later. The interpreter then evaluates the function expression to obtain the result in <span class="KeyTerm1">val</span>, restores the saved registers, and finally moves the result from <span class="KeyTerm1">val</span> to <span class="KeyTerm1">fun</span>. However, in the particular expression we are dealing with, the function expression is the name <span class="KeyTerm1">f</span>, whose evaluation is accomplished by the machine operation <span class="KeyTerm1">lookup_symbol_value</span>, which does not alter any registers. The compiler that we implement in this section will take advantage of this fact and generate code that evaluates the function expression using the instruction</p>
<p class="Sp-text-1"><a id="c005_c5-para-1253"></a>assign("fun",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1254"></a>       list(op("lookup_symbol_value"), constant("f"), reg("env")))</p>
<p class="paracontinue"><a id="c005_c5-para-1255"></a>where the argument to <span class="KeyTerm1">lookup_symbol_value</span> is extracted at compile time from the parser's representation of <span class="KeyTerm1">f(96, 22)</span>. This code not only avoids the unnecessary saves and restores but also assigns the value of the lookup directly to <span class="KeyTerm1">fun</span>, whereas the interpreter would obtain the result in <span class="KeyTerm1">val</span> and then move this to <span class="KeyTerm1">fun</span>.</p>
<p><a id="c005_c5-para-1256"></a>A compiler can also optimize access to the environment. Having analyzed the code, the compiler can know in which frame the value of a particular name will be located and access that frame directly, rather than performing the <span class="KeyTerm1">lookup_ symbol_value</span> search. We will discuss how to implement such lexical addressing in section 5.5.6. Until then, however, we will focus on the kind of register and stack optimizations described above. There are many other optimizations that can be performed by a compiler, such as coding primitive operations “in line” instead of using a general <span class="KeyTerm1">apply</span> mechanism (see exercise 5.41); but we will not emphasize these here. Our main goal in this section is to illustrate the compilation process in a simplified (but still interesting) context.</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0080"></a><span>5.5.1</span> <a id="c005_c5-title-0081"></a>Structure of the Compiler</h3>
<p class="paraaftertitle"><a id="c005_c5-para-1257"></a>In section 4.1.7 we modified our original metacircular interpreter to separate analysis from execution. We analyzed each component to produce an execution function that took an environment as argument and performed the required operations. In our compiler, we will do essentially the same analysis. Instead of producing execution functions, however, we will generate sequences of instructions to be run by our register machine.</p>
<p><a id="c005_c5-para-1258"></a>The function <span class="KeyTerm1">compile</span> is the top-level dispatch in the compiler. It corresponds to the <span class="KeyTerm1">evaluate</span> function of section 4.1.1, the <span class="KeyTerm1">analyze</span> function of section 4.1.7, and the <span class="KeyTerm1">eval_dispatch</span> entry point of the explicit-control-evaluator in section 5.4.1. The compiler, like the interpreters, uses the component-syntax functions defined in section 4.1.2.<a id="c005_c5-fn-0039a"></a><a href="#c5-fn-0039"><sup>39</sup></a> The function <span class="KeyTerm1">compile</span> performs a case analysis on the syntactic type of the component to be compiled. For each type of component, it dispatches to a specialized <i>code generator</i>:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1259"></a><b>function</b> compile(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1260"></a> <b>return</b> is_literal(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1261"></a>           ? compile_literal(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1262"></a>           : is_name(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1263"></a>           ? compile_name(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1264"></a>           : is_application(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1265"></a>           ? compile_application(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1266"></a>           : is_operator_combination(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1267"></a>           ? compile(operator_combination_to_application(component),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1268"></a>                     target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1269"></a>           : is_conditional(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1270"></a>           ? compile_conditional(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1271"></a>           : is_lambda_expression(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1272"></a>           ? compile_lambda_expression(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1273"></a>           : is_sequence(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1274"></a>           ? compile_sequence(sequence_statements(component),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1275"></a>                              target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1276"></a>           : is_block(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1277"></a>           ? compile_block(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1278"></a>           : is_return_statement(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1279"></a>           ? compile_return_statement(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1280"></a>           : is_function_declaration(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1281"></a>           ? compile(function_decl_to_constant_decl(component),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1282"></a>                     target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1283"></a>           : is_declaration(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1284"></a>           ? compile_declaration(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1285"></a>           : is_assignment(component)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1286"></a>           ? compile_assignment(component, target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1287"></a>           : error(component, "unknown component type – compile");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1288"></a>}</p>
<section>
<h5><a id="c005_c5-sec-0081"></a><a id="c005_c5-title-0082"></a>Targets and linkages</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1289"></a>The function <span class="KeyTerm1">compile</span> and the code generators that it calls take two arguments in addition to the component to compile. There is a <i>target</i>, which specifies the register in which the compiled code is to return the value of the component. There is also a <i>linkage descriptor</i>, which describes how the code resulting from the compilation of the component should proceed when it has finished its execution. The linkage descriptor can require the code to do one of the following three things:</p>
<ul style="list-style-type:disc">
<li>proceed to the next instruction in sequence (this is specified by the linkage descriptor <span class="KeyTerm1">"next"</span>),</li>
<li>jump to the current value of the <span class="KeyTerm1">continue</span> register as part of returning from a function call (this is specified by the linkage descriptor <span class="KeyTerm1">"return"</span>), or</li>
<li>jump to a named entry point (this is specified by using the designated label as the linkage descriptor).</li>
</ul>
<p><a id="c005_c5-para-1293"></a>For example, compiling the literal <span class="KeyTerm1">5</span> with a target of the <span class="KeyTerm1">val</span> register and a linkage of <span class="KeyTerm1">"next"</span> should produce the instruction</p>
<p class="Sp-text-1"><a id="c005_c5-para-1294"></a>assign("val", constant(5))</p>
<p class="paracontinue"><a id="c005_c5-para-1295"></a>Compiling the same expression with a linkage of <span class="KeyTerm1">"return"</span> should produce the instructions</p>
<p class="Sp-text-1"><a id="c005_c5-para-1296"></a>assign("val", constant(5)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1297"></a>go_to(reg("continue"))</p>
<p class="paracontinue"><a id="c005_c5-para-1298"></a>In the first case, execution will continue with the next instruction in the sequence. In the second case, we will jump to whatever entry point is stored in the <span class="KeyTerm1">continue</span> register. In both cases, the value of the expression will be placed into the target <span class="KeyTerm1">val</span> register. Our compiler uses the <span class="KeyTerm1">"return"</span> linkage when compiling the return expression of a return statement. Just as in the explicit-control evaluator, returning from a function call happens in three steps:</p>
<ol class="BS_NumberList1">
<li><a id="c005_c5-li-0033"></a><span>1. </span>reverting the stack to the marker and restoring <span class="KeyTerm1">continue</span> (which holds a continuation set up at the beginning of the function call)</li>
<li><a id="c005_c5-li-0034"></a><span>2. </span>computing the return value and placing it in <span class="KeyTerm1">val</span></li>
<li><a id="c005_c5-li-0035"></a><span>3. </span>jumping to the entry point in <span class="KeyTerm1">continue</span></li>
</ol>
<p class="paracontinue"><a id="c005_c5-para-1302"></a>Compilation of a return statement explicitly generates code for reverting the stack and restoring <span class="KeyTerm1">continue</span>. The return expression is compiled with target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"return"</span> so that the generated code for computing the return value places the return value in <span class="KeyTerm1">val</span> and ends by jumping to <span class="KeyTerm1">continue</span>.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0082"></a><a id="c005_c5-title-0083"></a>Instruction sequences and stack usage</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1303"></a>Each code generator returns an <i>instruction sequence</i> containing the object code it has generated for the component. Code generation for a compound component is accomplished by combining the output from simpler code generators for subcomponents, just as evaluation of a compound component is accomplished by evaluating the subcomponents.</p>
<p><a id="c005_c5-para-1304"></a>The simplest method for combining instruction sequences is a function called <span class="KeyTerm1">append_instruction_sequences</span>, which takes as arguments two instruction sequences that are to be executed sequentially. It appends them and returns the combined sequence. That is, if <i>seq</i><sub>1</sub> and <i>seq</i><sub>2</sub> are sequences of instructions, then evaluating</p>
<p class="Sp-text-1"><a id="c005_c5-para-1305"></a>append_instruction_sequences(<span class="KeyTerm2"><i>seq</i><sub>1</sub></span>, <span class="KeyTerm2"><i>seq</i><sub>2</sub></span>)</p>
<p class="paracontinue"><a id="c005_c5-para-1306"></a>produces the sequence</p>
<p class="Sp-text-1"><a id="c005_c5-para-1307"></a><span class="KeyTerm2"><i>seq<sub>1</sub></i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1308"></a><span class="KeyTerm2"><i>seq<sub>2</sub></i></span></p>
<p><a id="c005_c5-para-1309"></a>Whenever registers might need to be saved, the compiler's code generators use <span class="KeyTerm1">preserving</span>, which is a more subtle method for combining instruction sequences. The function <span class="KeyTerm1">preserving</span> takes three arguments: a set of registers and two instruction sequences that are to be executed sequentially. It appends the sequences in such a way that the contents of each register in the set is preserved over the execution of the first sequence, if this is needed for the execution of the second sequence. That is, if the first sequence modifies the register and the second sequence actually needs the register's original contents, then <span class="KeyTerm1">preserving</span> wraps a <span class="KeyTerm1">save</span> and a <span class="KeyTerm1">restore</span> of the register around the first sequence before appending the sequences. Otherwise, <span class="KeyTerm1">preserving</span> simply returns the appended instruction sequences. Thus, for example,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1310"></a>preserving(list(<span class="KeyTerm2"><i>reg</i><sub>1</sub></span>, <span class="KeyTerm2"><i>reg</i><sub>2</sub></span>), <span class="KeyTerm2"><i>seq</i><sub>1</sub></span>, <span class="KeyTerm2"><i>seq</i><sub>2</sub></span>)</p>
<p class="paracontinue"><a id="c005_c5-para-1311"></a>produces one of the following four sequences of instructions, depending on how <i>seq</i><sub>1</sub> and <i>seq</i><sub>2</sub> use <i>reg</i><sub>1</sub> and <i>reg</i><sub>2</sub>:</p>
<figure><figcaption class="tablecaption"><a id="c005_c5-tbl-0002"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td style="border-right:1px solid #000000;"><a id="c005_c5-para-1312"></a>seq<sub>1</sub></td>
<td style="border-right:1px solid #000000;"><a id="c005_c5-para-1313"></a><span class="KeyTerm1">save</span>(reg<sub>1</sub>),</td>
<td style="border-right:1px solid #000000;"><a id="c005_c5-para-1314"></a><span class="KeyTerm1">save</span>(reg<sub>2</sub>),</td>
<td><a id="c005_c5-para-1315"></a><span class="KeyTerm1">save</span>(reg<sub>2</sub>),</td></tr>
<tr>
<td style="border-right:1px solid #000000;"><a id="c005_c5-para-1316"></a>seq<sub>2</sub></td>
<td style="border-right:1px solid #000000;"><a id="c005_c5-para-1317"></a>seq<sub>1</sub></td>
<td style="border-right:1px solid #000000;"><a id="c005_c5-para-1318"></a>seq<sub>1</sub></td>
<td><a id="c005_c5-para-1319"></a><span class="KeyTerm1">save</span>(reg<sub>1</sub>),</td></tr>
<tr>
<td style="border-right:1px solid #000000;"></td>
<td style="border-right:1px solid #000000;"><a id="c005_c5-para-1320"></a><span class="KeyTerm1">restore</span>(reg<sub>1</sub>),</td>
<td style="border-right:1px solid #000000;"><a id="c005_c5-para-1321"></a><span class="KeyTerm1">restore</span>(reg<sub>2</sub>),</td>
<td><a id="c005_c5-para-1322"></a>seq<sub>1</sub></td></tr>
<tr>
<td style="border-right:1px solid #000000;"></td>
<td style="border-right:1px solid #000000;"><a id="c005_c5-para-1323"></a>seq<sub>2</sub></td>
<td style="border-right:1px solid #000000;"><a id="c005_c5-para-1324"></a>seq<sub>2</sub></td>
<td><a id="c005_c5-para-1325"></a><span class="KeyTerm1">restore</span>(reg<sub>1</sub>),</td></tr>
<tr>
<td style="border-right:1px solid #000000;"></td>
<td style="border-right:1px solid #000000;"></td>
<td style="border-right:1px solid #000000;"></td>
<td><a id="c005_c5-para-1326"></a><span class="KeyTerm1">restore</span>(reg<sub>2</sub>),</td></tr>
<tr>
<td style="border-right:1px solid #000000;"></td>
<td style="border-right:1px solid #000000;"></td>
<td style="border-right:1px solid #000000;"></td>
<td><a id="c005_c5-para-1327"></a>seq<sub>2</sub></td></tr></tbody></table></div>
</figure>
<p><a id="c005_c5-para-1328"></a>By using <span class="KeyTerm1">preserving</span> to combine instruction sequences the compiler avoids unnecessary stack operations. This also isolates the details of whether or not to generate <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> instructions within the <span class="KeyTerm1">preserving</span> function, separating them from the concerns that arise in writing each of the individual code generators. In fact no <span class="KeyTerm1">save</span> or <span class="KeyTerm1">restore</span> instructions are explicitly produced by the code generators, except that the code for calling a function saves <span class="KeyTerm1">continue</span> and the code for returning from a function restores it: These corresponding <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> instructions are explicitly generated by different calls to <span class="KeyTerm1">compile</span>, not as a matched pair by <span class="KeyTerm1">preserving</span> (as we will see in section 5.5.3).</p>
<p><a id="c005_c5-para-1329"></a>In principle, we could represent an instruction sequence simply as a list of instructions. The function <span class="KeyTerm1">append_instruction_sequences</span> could then combine instruction sequences by performing an ordinary list <span class="KeyTerm1">append</span>. However, <span class="KeyTerm1">preserving</span> would then be a complex operation, because it would have to analyze each instruction sequence to determine how the sequence uses its registers. The function <span class="KeyTerm1">preserving</span> would be inefficient as well as complex, because it would have to analyze each of its instruction sequence arguments, even though these sequences might themselves have been constructed by calls to <span class="KeyTerm1">preserving</span>, in which case their parts would have already been analyzed. To avoid such repetitious analysis we will associate with each instruction sequence some information about its register use. When we construct a basic instruction sequence we will provide this information explicitly, and the functions that combine instruction sequences will derive registeruse information for the combined sequence from the information associated with the sequences being combined.</p>
<p><a id="c005_c5-para-1330"></a>An instruction sequence will contain three pieces of information:</p>
<ul style="list-style-type:disc">
<li>the set of registers that must be initialized before the instructions in the sequence are executed (these registers are said to be <i>needed</i> by the sequence),</li>
<li>the set of registers whose values are modified by the instructions in the sequence, and</li>
<li>the actual instructions in the sequence.</li>
</ul>
<p class="paracontinue"><a id="c005_c5-para-1334"></a>We will represent an instruction sequence as a list of its three parts. The constructor for instruction sequences is thus</p>
<p class="Sp-text-1"><a id="c005_c5-para-1335"></a><b>function</b> make_instruction_sequence(needs, modifies, instructions) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1336"></a> <b>return</b> list(needs, modifies, instructions);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1337"></a>}</p>
<p><a id="c005_c5-para-1338"></a>For example, the two-instruction sequence that looks up the value of the symbol <span class="KeyTerm1">"x"</span> in the current environment, assigns the result to <span class="KeyTerm1">val</span>, and then proceeds to the continuation, requires registers <span class="KeyTerm1">env</span> and <span class="KeyTerm1">continue</span> to have been initialized, and modifies register <span class="KeyTerm1">val</span>. This sequence would therefore be constructed as</p>
<p class="Sp-text-1"><a id="c005_c5-para-1339"></a>make_instruction_sequence</p>
<p class="Sp-text-1"><a id="c005_c5-para-1340"></a>    list("env", "continue"), list("val"), list(assign("val",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1341"></a>                list(op("lookup_symbol_value"), constant("x"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1342"></a>                     reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1343"></a>         go_to(reg("continue"))));</p>
<p><a id="c005_c5-para-1344"></a>The functions for combining instruction sequences are shown in section 5.5.4.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0083"></a><a id="c005_c5-title-0084"></a>Exercise 5.32</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1345"></a>In evaluating a function application, the explicit-control evaluator always saves and restores the <span class="KeyTerm1">env</span> register around the evaluation of the function expression, saves and restores <span class="KeyTerm1">env</span> around the evaluation of each argument expression (except the final one), saves and restores <span class="KeyTerm1">argl</span> around the evaluation of each argument expression, and saves and restores <span class="KeyTerm1">fun</span> around the evaluation of the argument-expression sequence. For each of the following applications, say which of these <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> operations are superfluous and thus could be eliminated by the compiler's <span class="KeyTerm1">preserving</span> mechanism:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1346"></a>f("x", "y")</p>
<p class="Sp-text-1"><a id="c005_c5-para-1347"></a>f()("x", "y")</p>
<p class="Sp-text-1"><a id="c005_c5-para-1348"></a>f(g("x"), y)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1349"></a>f(g("x"), "y")</p>
</section>
<section>
<h5><a id="c005_c5-sec-0084"></a><a id="c005_c5-title-0085"></a>Exercise 5.33</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1350"></a>Using the <span class="KeyTerm1">preserving</span> mechanism, the compiler will avoid saving and restoring <span class="KeyTerm1">env</span> around the evaluation of the function expression of an application in the case where the function expression is a name. We could also build such optimizations into the evaluator. Indeed, the explicit-control evaluator of section 5.4 already performs a similar optimization, by treating applications with no arguments as a special case.</p>
<ol class="BS_NumberListA">
<li><a id="c005_c5-li-0039"></a><span>a. </span>Extend the explicit-control evaluator to recognize as a separate class of components applications whose function expression is a name, and to take advantage of this fact in evaluating such components.</li>
<li><a id="c005_c5-li-0040"></a><span>b. </span>Alyssa P. Hacker suggests that by extending the evaluator to recognize more and more special cases we could incorporate all the compiler's optimizations, and that this would eliminate the advantage of compilation altogether. What do you think of this idea?</li>
</ol>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0085"></a><span>5.5.2</span> <a id="c005_c5-title-0086"></a>Compiling Components</h3>
<p class="paraaftertitle"><a id="c005_c5-para-1353"></a>In this section and the next we implement the code generators to which the <span class="KeyTerm1">compile</span> function dispatches.</p>
<section>
<h5><a id="c005_c5-sec-0086"></a><a id="c005_c5-title-0087"></a>Compiling linkage code</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1354"></a>In general, the output of each code generator will end with instructions—generated by the function <span class="KeyTerm1">compile_linkage</span>—that implement the required linkage. If the linkage is <span class="KeyTerm1">"return"</span> then we must generate the instruction <span class="KeyTerm1">go_to(reg("continue"))</span>. This needs the <span class="KeyTerm1">continue</span> register and does not modify any registers. If the linkage is <span class="KeyTerm1">"next"</span>, then we needn't include any additional instructions. Otherwise, the linkage is a label, and we generate a <span class="KeyTerm1">go_to</span> to that label, an instruction that does not need or modify any registers.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1355"></a><b>function</b> compile_linkage(linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1356"></a> <b>return</b> linkage === "return"</p>
<p class="Sp-text-1"><a id="c005_c5-para-1357"></a>           ? make_instruction_sequence(list("continue"), <b>null</b>,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1358"></a>                                       list(go_to(reg("continue"))))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1359"></a>           : linkage === "next"</p>
<p class="Sp-text-1"><a id="c005_c5-para-1360"></a>           ? make_instruction_sequence(<b>null</b>, <b>null</b>, <b>null</b>)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1361"></a>           : make_instruction_sequence(<b>null</b>, <b>null</b>,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1362"></a>                                       list(go_to(label(linkage))));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1363"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1364"></a>The linkage code is appended to an instruction sequence by <span class="KeyTerm1">preserving</span> the <span class="KeyTerm1">continue</span> register, since a <span class="KeyTerm1">"return"</span> linkage will require the <span class="KeyTerm1">continue</span> register: If the given instruction sequence modifies <span class="KeyTerm1">continue</span> and the linkage code needs it, <span class="KeyTerm1">continue</span> will be saved and restored.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1365"></a><b>function</b> end_with_linkage(linkage, instruction_sequence) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1366"></a> <b>return</b> preserving(list("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1367"></a>                      instruction_sequence,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1368"></a>                      compile_linkage(linkage));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1369"></a>}</p>
</section>
<section>
<h5><a id="c005_c5-sec-0087"></a><a id="c005_c5-title-0088"></a>Compiling simple components</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1370"></a>The code generators for literal expressions and names construct instruction sequences that assign the required value to the target register and then proceed as specified by the linkage descriptor.</p>
<p><a id="c005_c5-para-1371"></a>The literal value is extracted at compile time from the component being compiled and put into the constant part of the <span class="KeyTerm1">assign</span> instruction. For a name, an instruction is generated to use the <span class="KeyTerm1">lookup_symbol_value</span> operation when the compiled program is run, to look up the value associated with a symbol in the current environment. Like a literal value, the symbol is extracted at compile time from the component being compiled. Thus <span class="KeyTerm1">symbol_of_name(component)</span> is executed only once, when the program is being compiled, and the symbol appears as a constant in the <span class="KeyTerm1">assign</span> instruction.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1372"></a><b>function</b> compile_literal(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1373"></a> <b>const</b> literal = literal_value(component);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1374"></a> <b>return</b> end_with_linkage(linkage,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1375"></a>               make_instruction_sequence(<b>null</b>, list(target),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1376"></a>                   list(assign(target, constant(literal)))));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1377"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1378"></a><b>function</b> compile_name(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1379"></a> <b>const</b> symbol = symbol_of_name(component);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1380"></a> <b>return</b> end_with_linkage(linkage,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1381"></a>               make_instruction_sequence(list("env"), list(target),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1382"></a>                   list(assign(target,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1383"></a>                               list(op("lookup_symbol_value"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1384"></a>                                    constant(symbol),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1385"></a>                                    reg("env"))))));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1386"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1387"></a>These assignment instructions modify the target register, and the one that looks up a symbol needs the <span class="KeyTerm1">env</span> register.</p>
<p><a id="c005_c5-para-1388"></a>Assignments and declarations are handled much as they are in the interpreter. The function <span class="KeyTerm1">compile_assignment_declaration</span> recursively generates code that computes the value to be associated with the symbol and appends to it a twoinstruction sequence that updates the value associated with the symbol in the environment and assigns the value of the whole component (the assigned value for an assignment or <span class="KeyTerm1">undefined</span> for a declaration) to the target register. The recursive compilation has target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"next"</span> so that the code will put its result into <span class="KeyTerm1">val</span> and continue with the code that is appended after it. The appending is done preserving <span class="KeyTerm1">env</span>, since the environment is needed for updating the symbol–value association and the code for computing the value could be the compilation of a complex expression that might modify the registers in arbitrary ways.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1389"></a><b>function</b> compile_assignment(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1390"></a> <b>return</b> compile_assignment_declaration(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1391"></a>               assignment_symbol(component),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1392"></a>               assignment_value_expression(component),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1393"></a>               reg("val"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1394"></a>               target, linkage);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1395"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1396"></a><b>function</b> compile_declaration(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1397"></a> <b>return</b> compile_assignment_declaration(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1398"></a>               declaration_symbol(component),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1399"></a>               declaration_value_expression(component),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1400"></a>               constant(undefined),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1401"></a>               target, linkage);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1402"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1403"></a><b>function</b> compile_assignment_declaration(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1404"></a>             symbol, value_expression, final_value,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1405"></a>             target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1406"></a> <b>const</b> get_value_code = compile(value_expression, "val", "next");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1407"></a> <b>return</b> end_with_linkage(linkage,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1408"></a>               preserving(list("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1409"></a>                   get_value_code,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1410"></a>                   make_instruction_sequence(list("env", "val"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1411"></a>                                             list(target),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1412"></a>                        list(perform(list(op("assign_symbol_value"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1413"></a>                                          constant(symbol),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1414"></a>                                          reg("val"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1415"></a>                                          reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1416"></a>                             assign(target, final_value)))));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1417"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1418"></a>The appended two-instruction sequence requires <span class="KeyTerm1">env</span> and <span class="KeyTerm1">val</span> and modifies the target. Note that although we preserve <span class="KeyTerm1">env</span> for this sequence, we do not preserve <span class="KeyTerm1">val</span>, because the <span class="KeyTerm1">get_value_code</span> is designed to explicitly place its result in <span class="KeyTerm1">val</span> for use by this sequence. (In fact, if we did preserve <span class="KeyTerm1">val</span>, we would have a bug, because this would cause the previous contents of <span class="KeyTerm1">val</span> to be restored right after the <span class="KeyTerm1">get_value_code</span> is run.)</p>
</section>
<section>
<h5><a id="c005_c5-sec-0088"></a><a id="c005_c5-title-0089"></a>Compiling conditionals</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1419"></a>The code for a conditional compiled with a given target and linkage has the form</p>
<p class="Sp-text-1"><a id="c005_c5-para-1420"></a>〈<span class="KeyTerm2"><i>compilation of predicate</i>, <i>target</i></span> val, <span class="KeyTerm2"><i>linkage</i></span> "next"〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1421"></a>  test(list(op("is_falsy"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1422"></a>  branch(label("false_branch")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1423"></a>"true_branch",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1424"></a>  〈<span class="KeyTerm2"><i>compilation of consequent with given target and given linkage or</i></span> after_cond〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1425"></a>"false_branch",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1426"></a>  〈<span class="KeyTerm2"><i>compilation of alternative with given target and linkage</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1427"></a>"after_cond"</p>
<p><a id="c005_c5-para-1428"></a>To generate this code, we compile the predicate, consequent, and alternative, and combine the resulting code with instructions to test the predicate result and with newly generated labels to mark the true and false branches and the end of the conditional.<a id="c005_c5-fn-0040a"></a><a href="#c5-fn-0040"><sup>40</sup></a> In this arrangement of code, we must branch around the true branch if the test is false. The only slight complication is in how the linkage for the true branch should be handled. If the linkage for the conditional is <span class="KeyTerm1">"return"</span> or a label, then the true and false branches will both use this same linkage. If the linkage is <span class="KeyTerm1">"next"</span>, the true branch ends with a jump around the code for the false branch to the label at the end of the conditional.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1429"></a><b>function</b> compile_conditional(component, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1430"></a> <b>const</b> t_branch = make_label("true_branch");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1431"></a> <b>const</b> f_branch = make_label("false_branch");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1432"></a> <b>const</b> after_cond = make_label("after_cond");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1433"></a> <b>const</b> consequent_linkage =</p>
<p class="Sp-text-1"><a id="c005_c5-para-1434"></a>            linkage === "next" ? after_cond : linkage;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1435"></a> <b>const</b> p_code = compile(conditional_predicate(component),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1436"></a>                           "val", "next");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1437"></a> <b>const</b> c_code = compile(conditional_consequent(component),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1438"></a>                           target, consequent_linkage);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1439"></a> <b>const</b> a_code = compile(conditional_alternative(component),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1440"></a>                           target, linkage);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1441"></a> <b>return</b> preserving(list("env", "continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1442"></a>             p_code,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1443"></a>             append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1444"></a>               make_instruction_sequence(list("val"), <b>null</b>,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1445"></a>                 list(test(list(op("is_falsy"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1446"></a>                      branch(label(f_branch)))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1447"></a>               append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1448"></a>                 parallel_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1449"></a>                   append_instruction_sequences(t_branch, c_code),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1450"></a>                   append_instruction_sequences(f_branch, a_code)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1451"></a>                 after_cond)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1452"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1462"></a>The <span class="KeyTerm1">env</span> register is preserved around the predicate code because it could be needed by the true and false branches, and <span class="KeyTerm1">continue</span> is preserved because it could be needed by the linkage code in those branches. The code for the true and false branches (which are not executed sequentially) is appended using a special combiner <span class="KeyTerm1">parallel_instruction_sequences</span> described in section 5.5.4.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0089"></a><a id="c005_c5-title-0090"></a>Compiling sequences</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1463"></a>The compilation of statement sequences parallels their evaluation in the explicitcontrol evaluator with one exception: If a return statement appears anywhere in a sequence, we treat it as if it were the last statement. Each statement of the sequence is compiled—the last statement (or a return statement) with the linkage specified for the sequence, and the other statements with linkage <span class="KeyTerm1">"next"</span> (to execute the rest of the sequence). The instruction sequences for the individual statements are appended to form a single instruction sequence, such that <span class="KeyTerm1">env</span> (needed for the rest of the sequence) and <span class="KeyTerm1">continue</span> (possibly needed for the linkage at the end of the sequence) are preserved.<a id="c005_c5-fn-0041a"></a><a href="#c5-fn-0041"><sup>41</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-1464"></a><b>function</b> compile_sequence(seq, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1465"></a> <b>return</b> is_empty_sequence(seq)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1466"></a>           ? compile_literal(make_literal(undefined), target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1467"></a>           : is_last_statement(seq) ||</p>
<p class="Sp-text-1"><a id="c005_c5-para-1468"></a>                 is_return_statement(first_statement(seq))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1469"></a>           ? compile(first_statement(seq), target, linkage)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1470"></a>           : preserving(list("env", "continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1471"></a>                 compile(first_statement(seq), target, "next"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1472"></a>                 compile_sequence(rest_statements(seq),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1473"></a>                                  target, linkage));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1474"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1475"></a>Treating a return statement as if it were the last statement in a sequence avoids compiling any “dead code” after the return statement that can never be executed. Removing the <span class="KeyTerm1">is_return_statement</span> check does not change the behavior of the object program; however, there are many reasons not to compile dead code, which are beyond the scope of this book (security, compilation time, size of the object code, etc.), and many compilers give warnings for dead code.<a id="c005_c5-fn-0042a"></a><a href="#c5-fn-0042"><sup>42</sup></a></p>
</section>
<section>
<h5><a id="c005_c5-sec-0090"></a><a id="c005_c5-title-0091"></a>Compiling blocks</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1476"></a>A block is compiled by prepending an <span class="KeyTerm1">assign</span> instruction to the compiled body of the block. The assignment extends the current environment by a frame that binds the names declared in the block to the value <span class="KeyTerm1">"*unassigned*"</span>. This operation both needs and modifies the <span class="KeyTerm1">env</span> register.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1477"></a><b>function</b> compile_block(stmt, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1478"></a> <b>const</b> body = block_body(stmt);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1479"></a> <b>const</b> locals = scan_out_declarations(body);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1480"></a> <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1481"></a> <b>return</b> append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1482"></a>               make_instruction_sequence(list("env"), list("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1483"></a>                   list(assign("env", list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1484"></a>                                           constant(locals),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1485"></a>                                           constant(unassigneds),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1486"></a>                                           reg("env"))))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1487"></a>               compile(body, target, linkage));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1488"></a>}</p>
</section>
<section>
<h5><a id="c005_c5-sec-0091"></a><a id="c005_c5-title-0092"></a>Compiling lambda expressions</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1489"></a>Lambda expressions construct functions. The object code for a lambda expression must have the form</p>
<p class="Sp-text-1"><a id="c005_c5-para-1490"></a>〈<span class="KeyTerm2"><i>construct function object and assign it to target register</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1491"></a>〈<span class="KeyTerm2"><i>linkage</i></span>〉</p>
<p class="paracontinue"><a id="c005_c5-para-1492"></a>When we compile the lambda expression, we also generate the code for the function body. Although the body won't be executed at the time of function construction, it is convenient to insert it into the object code right after the code for the lambda expression. If the linkage for the lambda expression is a label or <span class="KeyTerm1">"return"</span>, this is fine. But if the linkage is <span class="KeyTerm1">"next"</span>, we will need to skip around the code for the function body by using a linkage that jumps to a label that is inserted after the body. The object code thus has the form</p>
<p class="Sp-text-1"><a id="c005_c5-para-1493"></a>〈<span class="KeyTerm2"><i>construct function object and assign it to target register</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1494"></a>〈<span class="KeyTerm2"><i>code for given linkage</i></span>〉 <span class="KeyTerm2"><i>or</i></span> go_to(label("after_lambda"))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1495"></a>〈<span class="KeyTerm2"><i>compilation of function body</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1496"></a>"after_lambda"</p>
<p><a id="c005_c5-para-1497"></a>The function <span class="KeyTerm1">compile_lambda_expression</span> generates the code for constructing the function object followed by the code for the function body. The function object will be constructed at run time by combining the current environment (the environment at the point of declaration) with the entry point to the compiled function body (a newly generated label).<a id="c005_c5-fn-0043a"></a><a href="#c5-fn-0043"><sup>43</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-1511"></a><b>function</b> compile_lambda_expression(exp, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1512"></a> <b>const</b> fun_entry = make_label("entry");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1513"></a> <b>const</b> after_lambda = make_label("after_lambda");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1514"></a> <b>const</b> lambda_linkage =</p>
<p class="Sp-text-1"><a id="c005_c5-para-1515"></a>            linkage === "next" ? after_lambda : linkage;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1516"></a> <b>return</b> append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1517"></a>               tack_on_instruction_sequence(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1518"></a>                   end_with_linkage(lambda_linkage,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1519"></a>                       make_instruction_sequence(list("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1520"></a>                                                 list(target),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1521"></a>                           list(assign(target,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1522"></a>                                    list(op("make_compiled_function"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1523"></a>                                         label(fun_entry),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1524"></a>                                         reg("env")))))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1525"></a>                   compile_lambda_body(exp, fun_entry)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1526"></a>               after_lambda);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1527"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1528"></a>The function <span class="KeyTerm1">compile_lambda_expression</span> uses the special combiner <span class="KeyTerm1">tack_on_ instruction_sequence</span> (from section 5.5.4) rather than <span class="KeyTerm1">append_instruction_ sequences</span> to append the function body to the lambda expression code, because the body is not part of the sequence of instructions that will be executed when the combined sequence is entered; rather, it is in the sequence only because that was a convenient place to put it.</p>
<p><a id="c005_c5-para-1529"></a>The function <span class="KeyTerm1">compile_lambda_body</span> constructs the code for the body of the function. This code begins with a label for the entry point. Next come instructions that will cause the runtime evaluation environment to switch to the correct environment for evaluating the function body—namely, the environment of the function, extended to include the bindings of the parameters to the arguments with which the function is called. After this comes the code for the function body, augmented to ensure that it ends with a return statement. The augmented body is compiled with target <span class="KeyTerm1">val</span> so that its return value will be placed in <span class="KeyTerm1">val</span>. The linkage descriptor passed to this compilation is irrelevant, as it will be ignored.<a id="c005_c5-fn-0044a"></a><a href="#c5-fn-0044"><sup>44</sup></a> Since a linkage argument is required, we arbitrarily pick <span class="KeyTerm1">"next"</span>.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1530"></a><b>function</b> compile_lambda_body(exp, fun_entry) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1531"></a> <b>const</b> params  = lambda_parameter_symbols(exp);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1532"></a> <b>return</b> append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1533"></a>        make_instruction_sequence(list("env", "fun", "argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1534"></a>                                  list("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1535"></a>            list(fun_entry,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1536"></a>                 assign("env",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1537"></a>                        list(op("compiled_function_env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1538"></a>                             reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1539"></a>                 assign("env",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1540"></a>                        list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1541"></a>                             constant(params),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1542"></a>                             reg("argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1543"></a>                             reg("env"))))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1544"></a>        compile(append_return_undefined(lambda_body(exp)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1545"></a>                "val", "next"));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1546"></a>}</p>
<p><a id="c005_c5-para-1547"></a>To ensure that all functions end by executing a return statement, <span class="KeyTerm1">compile_</span> <span class="KeyTerm1">lambda_body</span> appends to the lambda body a return statement whose return expression is the literal <span class="KeyTerm1">undefined</span>. To do so, it uses the function <span class="KeyTerm1">append_return_ undefined</span>, which constructs the parser's tagged-list representation (from section 4.1.2) of a sequence consisting of the body and a <span class="KeyTerm1"><b>return</b> undefined;</span> statement.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1548"></a><b>function</b> append_return_undefined(body) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1549"></a> <b>return</b> list("sequence", list(body,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1550"></a>                                 list("return_statement",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1551"></a>                                      list("literal", undefined))));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1552"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1553"></a>This simple transformation of lambda bodies is a third way to ensure that a function that does not return explicitly has the return value <span class="KeyTerm1">undefined</span>. In the metacircular evaluator, we used a return-value object, which also played a role in stopping a sequence evaluation. In the explicit-control evaluator, functions that did not return explicitly continued to an entry point that stored <span class="KeyTerm1">undefined</span> in <span class="KeyTerm1">val</span>. See exercise 5.35 for a more elegant way to handle insertion of return statements.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0092"></a><a id="c005_c5-title-0093"></a>Exercise 5.34</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1554"></a>Footnote 42 pointed out that the compiler does not identify all instances of dead code. What would be required of a compiler to detect all instances of dead code?</p>
<p><a id="c005_c5-para-1555"></a>Hint: The answer depends on how we define dead code. One possible (and useful) definition is “code following a return statement in a sequence”—but what about code in the consequent branch of <span class="KeyTerm1"><b>if</b> (<b>false</b>)</span> <span class="KeyTerm1"><i>. . .</i></span> or code following a call to <span class="KeyTerm1">run_forever()</span> in exercise 4.15?</p>
</section>
<section>
<h5><a id="c005_c5-sec-0093"></a><a id="c005_c5-title-0094"></a>Exercise 5.35</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1556"></a>The current design of <span class="KeyTerm1">append_return_undefined</span> is a bit crude: It always appends a <span class="KeyTerm1"><b>return</b> undefined;</span> to a lambda body, even if there is already a return statement in every execution path of the body. Rewrite <span class="KeyTerm1">append_return_undefined</span> so that it inserts <span class="KeyTerm1"><b>return</b> undefined;</span> at the end of only those paths that do not contain a return statement. Test your solution on the functions below, substituting any expressions for <i>e</i><sub>1</sub> and <i>e</i><sub>2</sub> and any (non-return) statements for <i>s</i><sub>1</sub> and <i>s</i><sub>2</sub>. In <span class="KeyTerm1">t</span>, a return statement should be added either at both <span class="KeyTerm1">(*)</span>'s or just at <span class="KeyTerm1">(**)</span>. In <span class="KeyTerm1">w</span> and <span class="KeyTerm1">h</span>, a return statement should be added at one of the <span class="KeyTerm1">(*)</span>'s. In <span class="KeyTerm1">m</span>, no return statement should be added.</p>
<p><a id="c005_c5-para-1557"></a></p>
<figure id="c005_c5-fig-0017"><img alt="c5-fig-5001.jpg" src="../images/c5-fig-5001.jpg"/><figcaption class="figurecaption">
</figcaption></figure>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0094"></a><span>5.5.3</span> <a id="c005_c5-title-0095"></a>Compiling Applications and Return Statements</h3>
<p class="paraaftertitle"><a id="c005_c5-para-1558"></a>The essence of the compilation process is the compilation of function applications. The code for an application compiled with a given target and linkage has the form</p>
<p class="Sp-text-1"><a id="c005_c5-para-1559"></a>〈<span class="KeyTerm2"><i>compilation of function expression</i>, <i>target</i></span> fun, <span class="KeyTerm2"><i>linkage</i></span> "next"〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1560"></a>〈<span class="KeyTerm2"><i>evaluate argument expressions and construct argument list in</i></span> argl〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1561"></a>〈<span class="KeyTerm2"><i>compilation of function call with given target and linkage</i></span>〉</p>
<p class="paracontinue"><a id="c005_c5-para-1562"></a>The registers <span class="KeyTerm1">env</span>, <span class="KeyTerm1">fun</span>, and <span class="KeyTerm1">argl</span> may have to be saved and restored during evaluation of the function and argument expressions. Note that this is the only place in the compiler where a target other than <span class="KeyTerm1">val</span> is specified.</p>
<p><a id="c005_c5-para-1563"></a>The required code is generated by <span class="KeyTerm1">compile_application</span>. This recursively compiles the function expression, to produce code that puts the function to be applied into <span class="KeyTerm1">fun</span>, and compiles the argument expressions, to produce code that evaluates the individual argument expressions of the application. The instruction sequences for the argument expressions are combined (by <span class="KeyTerm1">construct_arglist</span>) with code that constructs the list of arguments in <span class="KeyTerm1">argl</span>, and the resulting argumentlist code is combined with the function code and the code that performs the function call (produced by <span class="KeyTerm1">compile_function_call</span>). In appending the code sequences, the <span class="KeyTerm1">env</span> register must be preserved around the evaluation of the function expression (since evaluating the function expression might modify <span class="KeyTerm1">env</span>, which will be needed to evaluate the argument expressions), and the <span class="KeyTerm1">fun</span> register must be preserved around the construction of the argument list (since evaluating the argument expressions might modify <span class="KeyTerm1">fun</span>, which will be needed for the actual function application). The <span class="KeyTerm1">continue</span> register must also be preserved throughout, since it is needed for the linkage in the function call.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1564"></a><b>function</b> compile_application(exp, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1565"></a> <b>const</b> fun_code = compile(function_expression(exp), "fun", "next");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1566"></a> <b>const</b> argument_codes = map(arg =&gt; compile(arg, "val", "next"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1567"></a>                               arg_expressions(exp));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1568"></a> <b>return</b> preserving(list("env", "continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1569"></a>                      fun_code,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1570"></a>                      preserving(list("fun", "continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1571"></a>                          construct_arglist(argument_codes),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1572"></a>                          compile_function_call(target, linkage)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1573"></a>}</p>
<p><a id="c005_c5-para-1574"></a>The code to construct the argument list will evaluate each argument expression into <span class="KeyTerm1">val</span> and then combine that value with the argument list being accumulated in <span class="KeyTerm1">argl</span> using <span class="KeyTerm1">pair</span>. Since we adjoin the arguments to the front of <span class="KeyTerm1">argl</span> in sequence, we must start with the last argument and end with the first, so that the arguments will appear in order from first to last in the resulting list. Rather than waste an instruction by initializing <span class="KeyTerm1">argl</span> to the empty list to set up for this sequence of evaluations, we make the first code sequence construct the initial <span class="KeyTerm1">argl</span>. The general form of the argument-list construction is thus as follows:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1575"></a>〈<span class="KeyTerm2"><i>compilation of last argument</i>, <i>targeted to</i></span> val〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1576"></a>〈assign("argl", list(op("list"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1577"></a>〈<span class="KeyTerm2"><i>compilation of next argument</i>, <i>targeted to</i></span> val〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1578"></a>〈assign("argl", list(op("pair"), reg("val"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1579"></a><i>. . .</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-1580"></a>〈<span class="KeyTerm2"><i>compilation of first argument</i>, <i>targeted to</i></span> val〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1581"></a>assign("argl", list(op("pair"), reg("val"), reg("argl"))),</p>
<p class="paracontinue"><a id="c005_c5-para-1582"></a>The <span class="KeyTerm1">argl</span> register must be preserved around each argument evaluation except the first (so that arguments accumulated so far won't be lost), and <span class="KeyTerm1">env</span> must be preserved around each argument evaluation except the last (for use by subsequent argument evaluations).</p>
<p><a id="c005_c5-para-1583"></a>Compiling this argument code is a bit tricky, because of the special treatment of the first argument expression to be evaluated and the need to preserve <span class="KeyTerm1">argl</span> and <span class="KeyTerm1">env</span> in different places. The <span class="KeyTerm1">construct_arglist</span> function takes as arguments the code that evaluates the individual argument expressions. If there are no argument expressions at all, it simply emits the instruction</p>
<p class="Sp-text-1"><a id="c005_c5-para-1584"></a>assign(argl, constant(<b>null</b>))</p>
<p class="paracontinue"><a id="c005_c5-para-1585"></a>Otherwise, <span class="KeyTerm1">construct_arglist</span> creates code that initializes <span class="KeyTerm1">argl</span> with the last argument, and appends code that evaluates the rest of the arguments and adjoins them to <span class="KeyTerm1">argl</span> in succession. In order to process the arguments from last to first, we must reverse the list of argument code sequences from the order supplied by <span class="KeyTerm1">compile_application</span>.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1586"></a><b>function</b> construct_arglist(arg_codes) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1587"></a> <b>if</b> (is_null(arg_codes)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1588"></a> <b>return</b> make_instruction_sequence(<b>null</b>, list("argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1589"></a>                   list(assign("argl", constant(<b>null</b>))));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1590"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1591"></a> <b>const</b> rev_arg_codes = reverse(arg_codes);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1592"></a> <b>const</b> code_to_get_last_arg =</p>
<p class="Sp-text-1"><a id="c005_c5-para-1593"></a>            append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1594"></a>                head(rev_arg_codes),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1595"></a>                make_instruction_sequence(list("val"), list("argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1596"></a>                    list(assign("argl",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1597"></a>                                list(op("list"), reg("val"))))));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1598"></a> <b>return</b> is_null(tail(rev_arg_codes))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1599"></a>               ? code_to_get_last_arg</p>
<p class="Sp-text-1"><a id="c005_c5-para-1600"></a>               : preserving(list("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1601"></a>                     code_to_get_last_arg,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1602"></a>                     code_to_get_rest_args(tail(rev_arg_codes)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1603"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-1604"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1605"></a><b>function</b> code_to_get_rest_args(arg_codes) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1606"></a> <b>const</b> code_for_next_arg =</p>
<p class="Sp-text-1"><a id="c005_c5-para-1607"></a>        preserving(list("argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1608"></a>            head(arg_codes),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1609"></a>            make_instruction_sequence(list("val", "argl"), list("argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1610"></a>                list(assign("argl", list(op("pair"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1611"></a>                                         reg("val"), reg("argl"))))));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1612"></a> <b>return</b> is_null(tail(arg_codes))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1613"></a>           ? code_for_next_arg</p>
<p class="Sp-text-1"><a id="c005_c5-para-1614"></a>           : preserving(list("env"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1615"></a>                        code_for_next_arg,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1616"></a>                        code_to_get_rest_args(tail(arg_codes)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1617"></a>}</p>
<section>
<h5><a id="c005_c5-sec-0095"></a><a id="c005_c5-title-0096"></a>Applying functions</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1618"></a>After evaluating the elements of a function application, the compiled code must apply the function in <span class="KeyTerm1">fun</span> to the arguments in <span class="KeyTerm1">argl</span>. The code performs essentially the same dispatch as the <span class="KeyTerm1">apply</span> function in the metacircular evaluator of section 4.1.1 or the <span class="KeyTerm1">apply_dispatch</span> entry point in the explicit-control evaluator of section 5.4.2. It checks whether the function to be applied is a primitive function or a compiled function. For a primitive function, it uses <span class="KeyTerm1">apply_primitive_function</span>; we will see shortly how it handles compiled functions. The function-application code has the following form:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1619"></a>  test(list(op("primitive_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1620"></a>  branch(label("primitive_branch")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1621"></a>"compiled_branch",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1622"></a> 〈<span class="KeyTerm2"><i>code to apply compiled function with given target and appropriate linkage</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1623"></a>"primitive_branch",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1624"></a>  assign(<i>target</i>,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1625"></a>         list(op("apply_primitive_function"), reg("fun"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1626"></a> 〈<span class="KeyTerm2"><i>linkage</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1627"></a>"after_call"</p>
<p class="paracontinue"><a id="c005_c5-para-1628"></a>Observe that the compiled branch must skip around the primitive branch. Therefore, if the linkage for the original function call was <span class="KeyTerm1">"next"</span>, the compound branch must use a linkage that jumps to a label that is inserted after the primitive branch. (This is similar to the linkage used for the true branch in <span class="KeyTerm1">compile_conditional</span>.)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1629"></a><b>function</b> compile_function_call(target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1630"></a> <b>const</b> primitive_branch = make_label("primitive_branch");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1631"></a> <b>const</b> compiled_branch = make_label("compiled_branch");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1632"></a> <b>const</b> after_call = make_label("after_call");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1633"></a> <b>const</b> compiled_linkage = linkage === "next" ? after_call : linkage;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1634"></a> <b>return</b> append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1635"></a>        make_instruction_sequence(list("fun"), <b>null</b>,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1636"></a>            list(test(list(op("is_primitive_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1637"></a>                 branch(label(primitive_branch)))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1638"></a>            append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1639"></a>                parallel_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1640"></a>                    append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1641"></a>                        compiled_branch,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1642"></a>                        compile_fun_appl(target, compiled_linkage)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1643"></a>                    append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1644"></a>                        primitive_branch,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1645"></a>                        end_with_linkage(linkage,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1646"></a>                            make_instruction_sequence(list("fun", "argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1647"></a>                                                      list(target),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1648"></a>                                list(assign(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1649"></a>                                       target,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1650"></a>                                       list(op("apply_primitive_function"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1651"></a>                                            reg("fun"), reg("argl")))))))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1652"></a>            after_call));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1653"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1654"></a>The primitive and compound branches, like the true and false branches in <span class="KeyTerm1">compile_ conditional</span>, are appended using <span class="KeyTerm1">parallel_instruction_sequences</span> rather than the ordinary <span class="KeyTerm1">append_instruction_sequences</span>, because they will not be executed sequentially.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0096"></a><a id="c005_c5-title-0097"></a>Applying compiled functions</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1655"></a>The handling of function application and return is the most subtle part of the compiler. A compiled function (as constructed by <span class="KeyTerm1">compile_lambda_expression</span>) has an entry point, which is a label that designates where the code for the function starts. The code at this entry point computes a result in <span class="KeyTerm1">val</span> and ends by executing the instructions from a compiled return statement.</p>
<p><a id="c005_c5-para-1656"></a>The code for a compiled-function application uses the stack in the same way as the explicit-control evaluator (section 5.4.2): before jumping to the compiled function's entry point, it saves the continuation of the function call to the stack, followed by a mark that allows reverting the stack to the state right before the call with the continuation on top.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1657"></a> <i>//</i> <span class="KeyTerm2"><i>set up for return from function</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1658"></a>  save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1659"></a>  push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1660"></a> <i>//</i> <span class="KeyTerm2"><i>jump to the function's entry point</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1661"></a>  assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1662"></a>  go_to(reg("val")),</p>
<p class="paracontinue"><a id="c005_c5-para-1663"></a>Compiling a return statement (with <span class="KeyTerm1">compile_return_statement</span>) generates corresponding code for reverting the stack and restoring and jumping to <span class="KeyTerm1">continue</span>.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1664"></a>  revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1665"></a>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1666"></a>  〈<span class="KeyTerm2"><i>evaluate the return expression and store the result in</i></span> val〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1667"></a>  go_to(reg("continue")), <i>//</i> "return"<i>-</i><span class="KeyTerm2"><i>linkage code</i></span></p>
<p class="paracontinue"><a id="c005_c5-para-1668"></a>Unless a function enters an infinite loop, it will end by executing the above return code, resulting from either a return statement in the program or one inserted by <span class="KeyTerm1">compile_lambda_body</span> to return <span class="KeyTerm1">undefined</span>.<a id="c005_c5-fn-0045a"></a><a href="#c5-fn-0045"><sup>45</sup></a></p>
<p><a id="c005_c5-para-1669"></a>Straightforward code for a compiled-function application with a given target and linkage would set up <span class="KeyTerm1">continue</span> to make the function return to a local label instead of to the final linkage, to copy the function value from <span class="KeyTerm1">val</span> to the target register if necessary. It would look like this if the linkage is a label:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1670"></a>  assign("continue", label("fun_return")), <i>//</i> <span class="KeyTerm2"><i>where function should return to</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1671"></a>  save("continue"),       <i>//</i> <span class="KeyTerm2"><i>will be restored by the function</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1672"></a>  push_marker_to_stack(), <i>//</i> <span class="KeyTerm2"><i>allows the function to revert stack to find</i></span> fun_return</p>
<p class="Sp-text-1"><a id="c005_c5-para-1673"></a>  assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1674"></a>  go_to(reg("val")),    <i>//</i> <span class="KeyTerm2"><i>eventually reverts stack, restores and jumps to</i></span> continue</p>
<p class="Sp-text-1"><a id="c005_c5-para-1675"></a>"fun_return",             <i>//</i> <span class="KeyTerm2"><i>the function returns to here</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1676"></a>  assign(<span class="KeyTerm2"><i>target</i></span>, reg("val")), <i>//</i> <span class="KeyTerm2"><i>included if target is not</i></span> val</p>
<p class="Sp-text-1"><a id="c005_c5-para-1677"></a>  go_to(label(<span class="KeyTerm2"><i>linkage</i></span>)),   <i>//</i> <span class="KeyTerm2"><i>linkage code</i></span></p>
<p class="paracontinue"><a id="c005_c5-para-1678"></a>or like this—saving the caller's continuation at the start in order to restore and go to it at the end—if the linkage is <span class="KeyTerm1">"return"</span> (that is, if the application is in a return statement and its value is the result to be returned):</p>
<p class="Sp-text-1"><a id="c005_c5-para-1679"></a>  save("continue"), <i>//</i> <span class="KeyTerm2"><i>save the caller's continuation</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1680"></a>  assign("continue", label("fun_return")), <i>//</i> <span class="KeyTerm2"><i>where function should return to</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1681"></a>  save("continue"), <i>//</i> <span class="KeyTerm2"><i>will be restored by the function</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1682"></a>push_marker_to_stack(), <i>//</i> <span class="KeyTerm2"><i>allows the function to revert stack to find</i></span> fun_return</p>
<p class="Sp-text-1"><a id="c005_c5-para-1683"></a>  assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1684"></a>  go_to(reg("val")), <i>//</i> <span class="KeyTerm2"><i>eventually reverts stack, restores and jumps to</i></span> continue</p>
<p class="Sp-text-1"><a id="c005_c5-para-1685"></a>"fun_return", <i>//</i> <span class="KeyTerm2"><i>the function returns to here</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1686"></a>  assign(<span class="KeyTerm2"><i>target</i></span>, reg("val")), <i>//</i> <span class="KeyTerm2"><i>included if target is not</i></span> val</p>
<p class="Sp-text-1"><a id="c005_c5-para-1687"></a>  restore("continue"), <i>//</i> <span class="KeyTerm2"><i>restore the caller's continuation</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-1688"></a>  go_to(reg("continue")), <i>//</i> <span class="KeyTerm2"><i>linkage code</i></span></p>
<p class="paracontinue"><a id="c005_c5-para-1689"></a>This code sets up <span class="KeyTerm1">continue</span> so that the function will return to a label <span class="KeyTerm1">fun_return</span> and jumps to the function's entry point. The code at <span class="KeyTerm1">fun_return</span> transfers the function's result from <span class="KeyTerm1">val</span> to the target register (if necessary) and then jumps to the location specified by the linkage. (The linkage is always <span class="KeyTerm1">"return"</span> or a label, because <span class="KeyTerm1">compile_function_call</span> replaces a <span class="KeyTerm1">"next"</span> linkage for the compound-function branch by an <span class="KeyTerm1">after_call</span> label.) Before jumping to the function's entry point, we save <span class="KeyTerm1">continue</span> and execute <span class="KeyTerm1">push_marker_to_stack()</span> to enable the function to return to the intended location in the program with the expected stack. Matching <span class="KeyTerm1">revert_stack_to_marker()</span> and <span class="KeyTerm1">restore("continue")</span> instructions are generated by <span class="KeyTerm1">compile_return_statement</span> for each return statement in the body of the function.<a id="c005_c5-fn-0046a"></a><a href="#c5-fn-0046"><sup>46</sup></a></p>
<p><a id="c005_c5-para-1690"></a>In fact, if the target is not <span class="KeyTerm1">val</span>, the above is exactly the code our compiler will generate.<a id="c005_c5-fn-0047a"></a><a href="#c5-fn-0047"><sup>47</sup></a> Usually, however, the target is <span class="KeyTerm1">val</span> (the only time the compiler specifies a different register is when targeting the evaluation of a function expression to <span class="KeyTerm1">fun</span>), so the function result is put directly into the target register and there is no need to jump to a special location that copies it. Instead we simplify the code by setting up <span class="KeyTerm1">continue</span> so that the called function will “return” directly to the place specified by the caller's linkage:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1691"></a>〈<span class="KeyTerm2"><i>set up continue for linkage and push the marker</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1692"></a>assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1693"></a>go_to(reg("val")),</p>
<p class="paracontinue"><a id="c005_c5-para-1694"></a>If the linkage is a label, we set up <span class="KeyTerm1">continue</span> so that the function will continue at that label. (That is, the <span class="KeyTerm1">go_to(reg("continue"))</span> the called function ends with becomes equivalent to the <span class="KeyTerm1">go_to(label(</span><i>linkage</i><span class="KeyTerm1">))</span> at <span class="KeyTerm1">fun_return</span> above.)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1695"></a>assign("continue", label(<span class="KeyTerm2"><i>linkage</i></span>)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1696"></a>save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1697"></a>push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1698"></a>assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1699"></a>go_to(reg("val")),</p>
<p class="paracontinue"><a id="c005_c5-para-1700"></a>If the linkage is <span class="KeyTerm1">"return"</span>, we don't need to assign <span class="KeyTerm1">continue</span>: It already holds the desired location. (That is, the <span class="KeyTerm1">go_to(reg("continue"))</span> the called function ends with goes directly to the place where the <span class="KeyTerm1">go_to(reg("continue"))</span> at <span class="KeyTerm1">fun_ return</span> would have gone.)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1701"></a>save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1702"></a>push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1703"></a>assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1704"></a>go_to(reg("val")),</p>
<p class="paracontinue"><a id="c005_c5-para-1705"></a>With this implementation of the <span class="KeyTerm1">"return"</span> linkage, the compiler generates tailrecursive code. A function call in a return statement whose value is the result to be returned does a direct transfer, without saving unnecessary information on the stack.</p>
<p><a id="c005_c5-para-1706"></a>Suppose instead that we had handled the case of a function call with a linkage of <span class="KeyTerm1">"return"</span> and a target of <span class="KeyTerm1">val</span> in the same way as for a non-<span class="KeyTerm1">val</span> target. This would destroy tail recursion. Our system would still return the same value for any function call. But each time we called a function, we would save <span class="KeyTerm1">continue</span> and return after the call to undo the (useless) save. These extra saves would accumulate during a nest of function calls.<a id="c005_c5-fn-0048a"></a><a href="#c5-fn-0048"><sup>48</sup></a></p>
<p><a id="c005_c5-para-1707"></a>The function <span class="KeyTerm1">compile_fun_appl</span> generates the above function-application code by considering four cases, depending on whether the target for the call is <span class="KeyTerm1">val</span> and whether the linkage is <span class="KeyTerm1">"return"</span>. Observe that the instruction sequences are declared to modify all the registers, since executing the function body can change the registers in arbitrary ways.<a id="c005_c5-fn-0049a"></a><a href="#c5-fn-0049"><sup>49</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-1708"></a><b>function</b> compile_fun_appl(target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1709"></a> <b>const</b> fun_return = make_label("fun_return");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1710"></a> <b>return</b> target === "val" &amp;&amp; linkage !== "return"</p>
<p class="Sp-text-1"><a id="c005_c5-para-1711"></a>           ? make_instruction_sequence(list("fun"), all_regs,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1712"></a>                 list(assign("continue", label(linkage)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1713"></a>                      save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1714"></a>                      push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1715"></a>                      assign("val", list(op("compiled_function_entry"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1716"></a>                                         reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1717"></a>                      go_to(reg("val"))))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1718"></a>           : target !== "val" &amp;&amp; linkage !== "return"</p>
<p class="Sp-text-1"><a id="c005_c5-para-1719"></a>           ? make_instruction_sequence(list("fun"), all_regs,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1720"></a>                 list(assign("continue", label(fun_return)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1721"></a>                      save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1722"></a>                      push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1723"></a>                      assign("val", list(op("compiled_function_entry"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1724"></a>                                         reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1725"></a>                      go_to(reg("val")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1726"></a>                      fun_return,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1727"></a>                      assign(target, reg("val")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1728"></a>                      go_to(label(linkage))))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1729"></a>           : target === "val" &amp;&amp; linkage === "return"</p>
<p class="Sp-text-1"><a id="c005_c5-para-1730"></a>           ? make_instruction_sequence(list("fun", "continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1731"></a>                                       all_regs,</p>
<p class="Sp-text-1"><a id="c005_c5-para-1732"></a>                 list(save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1733"></a>                      push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1734"></a>                      assign("val", list(op("compiled_function_entry"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1735"></a>                                         reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1736"></a>                      go_to(reg("val"))))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1737"></a>           : <i>//</i> target !== "val" &amp;&amp; linkage === "return"</p>
<p class="Sp-text-1"><a id="c005_c5-para-1738"></a>             error(target, "return linkage, target not val – compile");</p>
<p class="Sp-text-1"><a id="c005_c5-para-1739"></a>}</p>
<p><a id="c005_c5-para-1740"></a>We have shown how to generate tail-recursive linkage code for a function application when the linkage is <span class="KeyTerm1">"return"</span>—that is, when the application is in a return statement and its value is the result to be returned. Similarly, as explained in section 5.4.2, the stack-marker mechanism used here (and in the explicit-control evaluator) for the call and return produces tail-recursive behavior only in that situation. These two aspects of the code generated for function application combine to ensure that when a function ends by returning the value of a function call, no stack accumulates.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0097"></a><a id="c005_c5-title-0098"></a>Compiling return statements</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1742"></a>The code for a return statement takes the following form, regardless of the given linkage and target:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1743"></a>revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1744"></a>restore("continue"),   <i>//</i> <span class="KeyTerm2"><i>saved by</i></span> compile_fun_appl</p>
<p class="Sp-text-1"><a id="c005_c5-para-1745"></a>〈<span class="KeyTerm2"><i>evaluate the return expression and store the result in</i></span> val〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1746"></a>go_to(reg("continue")) <i>//</i> "return"<i>-</i><span class="KeyTerm2"><i>linkage code</i></span></p>
<p class="paracontinue"><a id="c005_c5-para-1747"></a>The instructions to revert the stack using the marker and then restore <span class="KeyTerm1">continue</span> correspond to the instructions generated by <span class="KeyTerm1">compile_fun_appl</span> to save <span class="KeyTerm1">continue</span> and mark the stack. The final jump to <span class="KeyTerm1">continue</span> is generated by the use of the <span class="KeyTerm1">"return"</span> linkage when compiling the return expression. The function <span class="KeyTerm1">compile_ return_statement</span> is different from all other code generators in that it ignores the target and linkage arguments—it always compiles the return expression with target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"return"</span>.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1748"></a><b>function</b> compile_return_statement(stmt, target, linkage) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1749"></a> <b>return</b> append_instruction_sequences(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1750"></a>               make_instruction_sequence(<b>null</b>, list("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1751"></a>                   list(revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1752"></a>                        restore("continue"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1753"></a>               compile(return_expression(stmt), "val", "return"));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1754"></a>}</p>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0098"></a><span>5.5.4</span> <a id="c005_c5-title-0099"></a>Combining Instruction Sequences</h3>
<p class="paraaftertitle"><a id="c005_c5-para-1755"></a>This section describes the details on how instruction sequences are represented and combined. Recall from section 5.5.1 that an instruction sequence is represented as a list of the registers needed, the registers modified, and the actual instructions. We will also consider a label (string) to be a degenerate case of an instruction sequence, which doesn't need or modify any registers. So to determine the registers needed and modified by instruction sequences we use the selectors</p>
<p class="Sp-text-1"><a id="c005_c5-para-1756"></a><b>function</b> registers_needed(s) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1757"></a> <b>return</b> is_string(s) ? <b>null</b> : head(s);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1758"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1759"></a><b>function</b> registers_modified(s) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1760"></a> <b>return</b> is_string(s) ? <b>null</b> : head(tail(s));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1761"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1762"></a><b>function</b> instructions(s) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1763"></a> <b>return</b> is_string(s) ? list(s) : head(tail(tail(s)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1764"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1765"></a>and to determine whether a given sequence needs or modifies a given register we use the predicates</p>
<p class="Sp-text-1"><a id="c005_c5-para-1766"></a><b>function</b> needs_register(seq, reg) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1767"></a> <b>return</b> ! is_null(member(reg, registers_needed(seq)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1768"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1769"></a><b>function</b> modifies_register(seq, reg) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1770"></a> <b>return</b> ! is_null(member(reg, registers_modified(seq)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1771"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1772"></a>In terms of these predicates and selectors, we can implement the various instruction sequence combiners used throughout the compiler.</p>
<p><a id="c005_c5-para-1773"></a>The basic combiner is <span class="KeyTerm1">append_instruction_sequences</span>. This takes as arguments two instruction sequences that are to be executed sequentially and returns an instruction sequence whose statements are the statements of the two sequences appended together. The subtle point is to determine the registers that are needed and modified by the resulting sequence. It modifies those registers that are modified by either sequence; it needs those registers that must be initialized before the first sequence can be run (the registers needed by the first sequence), together with those registers needed by the second sequence that are not initialized (modified) by the first sequence.</p>
<p><a id="c005_c5-para-1774"></a>The function <span class="KeyTerm1">append_instruction_sequences</span> is given two instruction sequences <span class="KeyTerm1">seq1</span> and <span class="KeyTerm1">seq2</span> and returns the instruction sequence whose instructions are the instructions of <span class="KeyTerm1">seq1</span> followed by the instructions of <span class="KeyTerm1">seq2</span>, whose modified registers are those registers that are modified by either <span class="KeyTerm1">seq1</span> or <span class="KeyTerm1">seq2</span>, and whose needed registers are the registers needed by <span class="KeyTerm1">seq1</span> together with those registers needed by <span class="KeyTerm1">seq2</span> that are not modified by <span class="KeyTerm1">seq1</span>. (In terms of set operations, the new set of needed registers is the union of the set of registers needed by <span class="KeyTerm1">seq1</span> with the set difference of the registers needed by <span class="KeyTerm1">seq2</span> and the registers modified by <span class="KeyTerm1">seq1</span>.) Thus, <span class="KeyTerm1">append_instruction_sequences</span> is implemented as follows:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1775"></a><b>function</b> append_instruction_sequences(seq1, seq2) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1776"></a> <b>return</b> make_instruction_sequence(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1777"></a>               list_union(registers_needed(seq1),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1778"></a>                          list_difference(registers_needed(seq2),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1779"></a>                                         registers_modified(seq1))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1780"></a>               list_union(registers_modified(seq1),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1781"></a>                          registers_modified(seq2)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1782"></a>               append(instructions(seq1), instructions(seq2)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1783"></a>}</p>
<p><a id="c005_c5-para-1784"></a>This function uses some simple operations for manipulating sets represented as lists, similar to the (unordered) set representation described in section 2.3.3:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1785"></a><b>function</b> list_union(s1, s2) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1786"></a> <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1787"></a>           ? s2</p>
<p class="Sp-text-1"><a id="c005_c5-para-1788"></a>           : is_null(member(head(s1), s2))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1789"></a>           ? pair(head(s1), list_union(tail(s1), s2))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1790"></a>           : list_union(tail(s1), s2);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1791"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1792"></a><b>function</b> list_difference(s1, s2) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1793"></a> <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1794"></a>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c005_c5-para-1795"></a>           : is_null(member(head(s1), s2))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1796"></a>           ? pair(head(s1), list_difference(tail(s1), s2))</p>
<p class="Sp-text-1"><a id="c005_c5-para-1797"></a>           : list_difference(tail(s1), s2);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1798"></a>}</p>
<p><a id="c005_c5-para-1799"></a>The function <span class="KeyTerm1">preserving</span>, the second major instruction sequence combiner, takes a list of registers <span class="KeyTerm1">regs</span> and two instruction sequences <span class="KeyTerm1">seq1</span> and <span class="KeyTerm1">seq2</span> that are to be executed sequentially. It returns an instruction sequence whose instructions are the instructions of <span class="KeyTerm1">seq1</span> followed by the instructions of <span class="KeyTerm1">seq2</span>, with appropriate <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> instructions around <span class="KeyTerm1">seq1</span> to protect the registers in <span class="KeyTerm1">regs</span> that are modified by <span class="KeyTerm1">seq1</span> but needed by <span class="KeyTerm1">seq2</span>. To accomplish this, <span class="KeyTerm1">preserving</span> first creates a sequence that has the required <span class="KeyTerm1">save</span>s followed by the instructions of <span class="KeyTerm1">seq1</span> followed by the required <span class="KeyTerm1">restore</span>s. This sequence needs the registers being saved and restored in addition to the registers needed by <span class="KeyTerm1">seq1</span>, and modifies the registers modified by <span class="KeyTerm1">seq1</span> except for the ones being saved and restored. This augmented sequence and <span class="KeyTerm1">seq2</span> are then appended in the usual way. The following function implements this strategy recursively, walking down the list of registers to be preserved:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1800"></a><b>function</b> preserving(regs, seq1, seq2) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1801"></a> <b>if</b> (is_null(regs)) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1802"></a> <b>return</b> append_instruction_sequences(seq1, seq2);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1803"></a>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1804"></a> <b>const</b> first_reg = head(regs);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1805"></a> <b>return</b> needs_register(seq2, first_reg) &amp;&amp;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1806"></a>               modifies_register(seq1, first_reg)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1807"></a>               ? preserving(tail(regs),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1808"></a>                     make_instruction_sequence(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1809"></a>                         list_union(list(first_reg),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1810"></a>                                    registers_needed(seq1)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1811"></a>                         list_difference(registers_modified(seq1),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1812"></a>                                         list(first_reg)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1813"></a>                         append(list(save(first_reg)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1814"></a>                                append(instructions(seq1),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1815"></a>                                       list(restore(first_reg))))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1816"></a>                     seq2)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1817"></a>               : preserving(tail(regs), seq1, seq2);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1818"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-1819"></a>}</p>
<p><a id="c005_c5-para-1820"></a>Another sequence combiner, <span class="KeyTerm1">tack_on_instruction_sequence</span>, is used by <span class="KeyTerm1">compile_lambda_expression</span> to append a function body to another sequence. Because the function body is not “in line” to be executed as part of the combined sequence, its register use has no impact on the register use of the sequence in which it is embedded. We thus ignore the function body's sets of needed and modified registers when we tack it onto the other sequence.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1821"></a><b>function</b> tack_on_instruction_sequence(seq, body_seq) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1822"></a> <b>return</b> make_instruction_sequence(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1823"></a>               registers_needed(seq),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1824"></a>               registers_modified(seq),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1825"></a>               append(instructions(seq), instructions(body_seq)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1826"></a>}</p>
<p><a id="c005_c5-para-1827"></a>The functions <span class="KeyTerm1">compile_conditional</span> and <span class="KeyTerm1">compile_function_call</span> use a special combiner called <span class="KeyTerm1">parallel_instruction_sequences</span> to append the two alternative branches that follow a test. The two branches will never be executed sequentially; for any particular evaluation of the test, one branch or the other will be entered. Because of this, the registers needed by the second branch are still needed by the combined sequence, even if these are modified by the first branch.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1828"></a><b>function</b> parallel_instruction_sequences(seq1, seq2) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1829"></a> <b>return</b> make_instruction_sequence(</p>
<p class="Sp-text-1"><a id="c005_c5-para-1830"></a>               list_union(registers_needed(seq1),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1831"></a>                          registers_needed(seq2)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1832"></a>               list_union(registers_modified(seq1),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1833"></a>                          registers_modified(seq2)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1834"></a>               append(instructions(seq1), instructions(seq2)));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1835"></a>}</p>
</section>
<section>
<h3><a id="c005_c5-sec-0099"></a><span>5.5.5</span> <a id="c005_c5-title-0100"></a>An Example of Compiled Code</h3>
<p class="paraaftertitle"><a id="c005_c5-para-1836"></a>Now that we have seen all the elements of the compiler, let us examine an example of compiled code to see how things fit together. We will compile the declaration of a recursive <span class="KeyTerm1">factorial</span> function by passing as first argument to <span class="KeyTerm1">compile</span> the result of applying <span class="KeyTerm1">parse</span> to a string representation of the program (here using back quotes <span class="KeyTerm1">ˋ<i>. . .</i>ˋ</span>, which work like single and double quotation marks but allow the string to span multiple lines):</p>
<p class="Sp-text-1"><a id="c005_c5-para-1838"></a>compile(parse(ˋ</p>
<p class="Sp-text-1"><a id="c005_c5-para-1839"></a>function factorial(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1840"></a>    return n === 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1841"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1842"></a>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1843"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1844"></a>              ˋ),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1845"></a>        "val",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1846"></a>        "next");</p>
<p class="paracontinue"><a id="c005_c5-para-1847"></a>We have specified that the value of the declaration should be placed in the <span class="KeyTerm1">val</span> register. We don't care what the compiled code does after executing the declaration, so our choice of <span class="KeyTerm1">"next"</span> as the linkage descriptor is arbitrary.</p>
<p><a id="c005_c5-para-1848"></a>The function <span class="KeyTerm1">compile</span> determines that it was given a function declaration, so it transforms it to a constant declaration and then calls <span class="KeyTerm1">compile_declaration</span>. This compiles code to compute the value to be assigned (targeted to <span class="KeyTerm1">val</span>), followed by code to install the declaration, followed by code to put the value of the declaration (which is the value <span class="KeyTerm1">undefined</span>) into the target register, followed finally by the linkage code. The <span class="KeyTerm1">env</span> register is preserved around the computation of the value, because it is needed in order to install the declaration. Because the linkage is <span class="KeyTerm1">"next"</span>, there is no linkage code in this case. The skeleton of the compiled code is thus</p>
<p class="Sp-text-1"><a id="c005_c5-para-1849"></a>〈<span class="KeyTerm2"><i>save</i></span> env <span class="KeyTerm2"><i>if modified by code to compute value</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1850"></a>〈<span class="KeyTerm2"><i>compilation of declaration value</i>, <i>target</i></span> val, <span class="KeyTerm2"><i>linkage</i></span> "next"〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1851"></a>〈<span class="KeyTerm2"><i>restore</i></span> env <span class="KeyTerm2"><i>if saved above</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1852"></a>perform(list(op("assign_symbol_value"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1853"></a>             constant("factorial"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1854"></a>             reg("val"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1855"></a>             reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1856"></a>assign("val", constant(undefined))</p>
<p><a id="c005_c5-para-1857"></a>The expression that is compiled to produce the value for the name <span class="KeyTerm1">factorial</span> is a lambda expression whose value is the function that computes factorials. The function <span class="KeyTerm1">compile</span> handles this by calling <span class="KeyTerm1">compile_lambda_expression</span>, which compiles the function body, labels it as a new entry point, and generates the instruction that will combine the function body at the new entry point with the runtime environment and assign the result to <span class="KeyTerm1">val</span>. The sequence then skips around the compiled function code, which is inserted at this point. The function code itself begins by extending the function's declaration environment by a frame that binds the parameter <span class="KeyTerm1">n</span> to the function argument. Then comes the actual function body. Since this code for the value of the name doesn't modify the <span class="KeyTerm1">env</span> register, the optional <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> shown above aren't generated. (The function code at <span class="KeyTerm1">entry1</span> isn't executed at this point, so its use of <span class="KeyTerm1">env</span> is irrelevant.) Therefore, the skeleton for the compiled code becomes</p>
<p class="Sp-text-1"><a id="c005_c5-para-1858"></a>  assign("val", list(op("make_compiled_function"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1859"></a>                     label("entry1"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1860"></a>                     reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1861"></a>  go_to(label("after_lambda2")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1862"></a>"entry1",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1863"></a>  assign("env", list(op("compiled_function_env"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1864"></a>  assign("env", list(op("extend_environment"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1865"></a>                     constant(list("n")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1866"></a>                     reg("argl"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1867"></a>                     reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1868"></a>  〈<span class="KeyTerm2"><i>compilation of function body</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1869"></a>"after_lambda2",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1870"></a>  perform(list(op("assign_symbol_value"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1871"></a>               constant("factorial"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1872"></a>               reg("val"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1873"></a>               reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1874"></a>  assign("val", constant(undefined))</p>
<p><a id="c005_c5-para-1875"></a>A function body is always compiled (by <span class="KeyTerm1">compile_lambda_body</span>) with target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"next"</span>. The body in this case consists of a single return statement:<a id="c005_c5-fn-0050a"></a><a href="#c5-fn-0050"><sup>50</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-1876"></a><b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1877"></a>       ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1878"></a>       : factorial(n - 1) * n;</p>
<p class="paracontinue"><a id="c005_c5-para-1879"></a>The function <span class="KeyTerm1">compile_return_statement</span> generates code to revert the stack using the marker and to restore the <span class="KeyTerm1">continue</span> register, and then compiles the return expression with target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"return"</span>, because its value is to be returned from the function. The return expression is a conditional expression, for which <span class="KeyTerm1">compile_conditional</span> generates code that first computes the predicate (targeted to <span class="KeyTerm1">val</span>), then checks the result and branches around the true branch if the predicate is false. Registers <span class="KeyTerm1">env</span> and <span class="KeyTerm1">continue</span> are preserved around the predicate code, since they may be needed for the rest of the conditional expression. The true and false branches are both compiled with target <span class="KeyTerm1">val</span> and linkage <span class="KeyTerm1">"return"</span>. (That is, the value of the conditional, which is the value computed by either of its branches, is the value of the function.)</p>
<p class="Sp-text-1"><a id="c005_c5-para-1880"></a>  revert_stack_to_marker(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1881"></a>  restore("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1882"></a>  〈<span class="KeyTerm2"><i>save</i></span> continue, env <span class="KeyTerm2"><i>if modified by predicate and needed by branches</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1883"></a>  〈<span class="KeyTerm2"><i>compilation of predicate</i>, <i>target</i></span> val, <span class="KeyTerm2"><i>linkage</i></span> "next"〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1884"></a>  〈<span class="KeyTerm2"><i>restore</i></span> continue, env <span class="KeyTerm2"><i>if saved above</i></span>〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1885"></a>  test(list(op("is_falsy"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1886"></a>  branch(label("false_branch4")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1887"></a>"true_branch3",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1888"></a>  〈<span class="KeyTerm2"><i>compilation of true branch</i>, <i>target</i></span> val, <span class="KeyTerm2"><i>linkage</i></span> "return"〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1889"></a>"false_branch4",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1890"></a>  〈<span class="KeyTerm2"><i>compilation of false branch</i>, <i>target</i></span> val, <span class="KeyTerm2"><i>linkage</i></span> "return"〉</p>
<p class="Sp-text-1"><a id="c005_c5-para-1891"></a>"after_cond5",</p>
<p><a id="c005_c5-para-1892"></a>The predicate <span class="KeyTerm1">n === 1</span> is a function application (after transformation of the operator combination). This looks up the function expression (the symbol <span class="KeyTerm1">"==="</span>) and places this value in <span class="KeyTerm1">fun</span>. It then assembles the arguments <span class="KeyTerm1">1</span> and the value of <span class="KeyTerm1">n</span> into <span class="KeyTerm1">argl</span>. Then it tests whether <span class="KeyTerm1">fun</span> contains a primitive or a compound function, and dispatches to a primitive branch or a compound branch accordingly. Both branches resume at the <span class="KeyTerm1">after_call</span> label. The compound branch must set up <span class="KeyTerm1">continue</span> to jump past the primitive branch and push a marker to the stack to match the revert operation in the compiled return statement of the function. The requirements to preserve registers around the evaluation of the function and argument expressions don't result in any saving of registers, because in this case those evaluations don't modify the registers in question.</p>
<p class="Sp-text-1"><a id="c005_c5-para-1893"></a>  assign("fun", list(op("lookup_symbol_value"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1894"></a>                     constant("==="), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1895"></a>  assign("val", constant(1)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1896"></a>  assign("argl", list(op("list"), reg("val"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1897"></a>  assign("val", list(op("lookup_symbol_value"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1898"></a>                     constant("n"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1899"></a>  assign("argl", list(op("pair"), reg("val"), reg("argl"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1900"></a>  test(list(op("is_primitive_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1901"></a>  branch(label("primitive_branch6")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1902"></a>"compiled_branch7",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1903"></a>  assign("continue", label("after_call8")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1904"></a>  save("continue"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1905"></a>  push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1906"></a>  assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1907"></a>  go_to(reg("val")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1908"></a>"primitive_branch6",</p>
<p class="Sp-text-1"><a id="c005_c5-para-1909"></a>  assign("val", list(op("apply_primitive_function"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1910"></a>                     reg("fun"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1911"></a>                     reg("argl"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1912"></a>"after_call8",</p>
<p><a id="c005_c5-para-1913"></a>The true branch, which is the constant 1, compiles (with target val and linkage "<span class="KeyTerm1">return</span>") to</p>
<p class="Sp-text-1"><a id="c005_c5-para-1914"></a>  assign("val", constant(1)),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1915"></a>  go_to(reg("continue")),</p>
<p class="paracontinue"><a id="c005_c5-para-1916"></a>The code for the false branch is another function call, where the function is the value of the symbol <span class="KeyTerm1">"*"</span>, and the arguments are <span class="KeyTerm1">n</span> and the result of another function call (a call to <span class="KeyTerm1">factorial</span>). Each of these calls sets up <span class="KeyTerm1">fun</span> and <span class="KeyTerm1">argl</span> and its own primitive and compound branches. <a id="c005_c5-fig-0018a"></a><a href="#c5-fig-0018">Figure 5.17</a> shows the complete compilation of the declaration of the <span class="KeyTerm1">factorial</span> function. Notice that the possible <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> of <span class="KeyTerm1">continue</span> and <span class="KeyTerm1">env</span> around the predicate, shown above, are in fact generated, because these registers are modified by the function call in the predicate and needed for the function call and the <span class="KeyTerm1">"return"</span> linkage in the branches.</p>
<figure id="c005_c5-fig-0018"><img alt="c5-fig-0017a.jpg" src="../images/c5-fig-0017a.jpg"/><br/><img alt="c5-fig-0017b.jpg" src="../images/c5-fig-0017b.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0018a">Figure 5.17</a></span> <a id="c005_c5-para-1917"></a>Compilation of the declaration of the <span class="KeyTerm1">factorial</span> function.</p></figcaption></figure>
<section>
<h5><a id="c005_c5-sec-0100"></a><a id="c005_c5-title-0101"></a>Exercise 5.36</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1920"></a>Consider the following declaration of a factorial function, which is slightly different from the one given above:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1921"></a><b>function</b> factorial_alt(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1922"></a> <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1923"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1924"></a>           : n * factorial_alt(n - 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1925"></a>}</p>
<p><a id="c005_c5-para-1926"></a>Compile this function and compare the resulting code with that produced for <span class="KeyTerm1">factorial</span>. Explain any differences you find. Does either program execute more efficiently than the other?</p>
</section>
<section>
<h5><a id="c005_c5-sec-0101"></a><a id="c005_c5-title-0102"></a>Exercise 5.37</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1927"></a>Compile the iterative factorial function</p>
<p class="Sp-text-1"><a id="c005_c5-para-1928"></a><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1929"></a> <b>function</b> iter(product, counter) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-1930"></a> <b>return</b> counter &gt; n</p>
<p class="Sp-text-1"><a id="c005_c5-para-1931"></a>               ? product</p>
<p class="Sp-text-1"><a id="c005_c5-para-1932"></a>               : iter(product * counter, counter + 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1933"></a>    }</p>
<p class="Sp-text-1"><a id="c005_c5-para-1934"></a> <b>return</b> iter(1, 1);</p>
<p class="Sp-text-1"><a id="c005_c5-para-1935"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-1936"></a>Annotate the resulting code, showing the essential difference between the code for iterative and recursive versions of <span class="KeyTerm1">factorial</span> that makes one process build up stack space and the other run in constant stack space.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0102"></a><a id="c005_c5-title-0103"></a>Exercise 5.38</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1937"></a>What program was compiled to produce the code shown in <a id="c005_c5-fig-0021a"></a><a href="#c5-fig-0021">figure 5.18</a>?</p>
<figure id="c005_c5-fig-0021"><img alt="c5-fig-0018a.jpg" src="../images/c5-fig-0018a.jpg"/><br/><img alt="c5-fig-0018b.jpg" src="../images/c5-fig-0018b.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c5-fig-0021a">Figure 5.18</a></span> <a id="c005_c5-para-1938"></a>An example of compiler output. See exercise 5.38.</p></figcaption></figure>
</section>
<section>
<h5><a id="c005_c5-sec-0103"></a><a id="c005_c5-title-0104"></a>Exercise 5.39</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1941"></a>What order of evaluation does our compiler produce for arguments of an application? Is it left-to-right (as mandated by the ECMAScript specification), right-to-left, or some other order? Where in the compiler is this order determined? Modify the compiler so that it produces some other order of evaluation. (See the discussion of order of evaluation for the explicit-control evaluator in section 5.4.1.) How does changing the order of argument evaluation affect the efficiency of the code that constructs the argument list?</p>
</section>
<section>
<h5><a id="c005_c5-sec-0104"></a><a id="c005_c5-title-0105"></a>Exercise 5.40</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1942"></a>One way to understand the compiler's <span class="KeyTerm1">preserving</span> mechanism for optimizing stack usage is to see what extra operations would be generated if we did not use this idea. Modify <span class="KeyTerm1">preserving</span> so that it always generates the <span class="KeyTerm1">save</span> and <span class="KeyTerm1">restore</span> operations. Compile some simple expressions and identify the unnecessary stack operations that are generated. Compare the code to that generated with the <span class="KeyTerm1">preserving</span> mechanism intact.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0105"></a><a id="c005_c5-title-0106"></a>Exercise 5.41</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1943"></a>Our compiler is clever about avoiding unnecessary stack operations, but it is not clever at all when it comes to compiling calls to the primitive functions of the language in terms of the primitive operations supplied by the machine. For example, consider how much code is compiled to compute <span class="KeyTerm1">a + 1</span>: The code sets up an argument list in <span class="KeyTerm1">argl</span>, puts the primitive addition function (which it finds by looking up the symbol <span class="KeyTerm1">"+"</span> in the environment) into <span class="KeyTerm1">fun</span>, and tests whether the function is primitive or compound. The compiler always generates code to perform the test, as well as code for primitive and compound branches (only one of which will be executed). We have not shown the part of the controller that implements primitives, but we presume that these instructions make use of primitive arithmetic operations in the machine's data paths. Consider how much less code would be generated if the compiler could <i>open-code</i> primitives—that is, if it could generate code to directly use these primitive machine operations. The expression <span class="KeyTerm1">a + 1</span> might be compiled into something as simple as<a id="c005_c5-fn-0051a"></a><a href="#c5-fn-0051"><sup>51</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-1944"></a>assign("val", list(op("lookup_symbol_value"), constant("a"), reg("env"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1945"></a>assign("val", list(op("+"), reg("val"), constant(1)))</p>
<p class="paracontinue"><a id="c005_c5-para-1946"></a>In this exercise we will extend our compiler to support open coding of selected primitives. Special-purpose code will be generated for calls to these primitive functions instead of the general function-application code. In order to support this, we will augment our machine with special argument registers <span class="KeyTerm1">arg1</span> and <span class="KeyTerm1">arg2</span>. The primitive arithmetic operations of the machine will take their inputs from <span class="KeyTerm1">arg1</span> and <span class="KeyTerm1">arg2</span>. The results may be put into <span class="KeyTerm1">val</span>, <span class="KeyTerm1">arg1</span>, or <span class="KeyTerm1">arg2</span>.</p>
<p><a id="c005_c5-para-1947"></a>The compiler must be able to recognize the application of an open-coded primitive in the source program. We will augment the dispatch in the <span class="KeyTerm1">compile</span> function to recognize the names of these primitives in addition to the syntactic forms it currently recognizes. For each syntactic form our compiler has a code generator. In this exercise we will construct a family of code generators for the open-coded primitives.</p>
<ol class="BS_NumberListA">
<li><a id="c005_c5-li-0041"></a><span>a. </span>The open-coded primitives, unlike the syntactic forms, all need their argument expressions evaluated. Write a code generator <span class="KeyTerm1">spread_arguments</span> for use by all the open-coding code generators. The function <span class="KeyTerm1">spread_arguments</span> should take a list of argument expressions and compile the given argument expressions targeted to successive argument registers. Note that an argument expression may contain a call to an open-coded primitive, so argument registers will have to be preserved during argument-expression evaluation.</li>
<li><a id="c005_c5-li-0042"></a><span>b. </span>The JavaScript operators <span class="KeyTerm1">===</span>, <span class="KeyTerm1">*</span>, <span class="KeyTerm1">-</span>, and <span class="KeyTerm1">+</span>, among others, are implemented in the register machine as primitive functions and are referred to in the global environment with the symbols <span class="KeyTerm1">"==="</span>, <span class="KeyTerm1">"*"</span>, <span class="KeyTerm1">"-"</span>, and <span class="KeyTerm1">"+"</span>. In JavaScript, it is not possible to redeclare these names, because they do not meet the syntactic restrictions for names. This means it is safe to open-code them. For each of the primitive functions <span class="KeyTerm1">===</span>, <span class="KeyTerm1">*</span>, <span class="KeyTerm1">-</span>, and <span class="KeyTerm1">+</span>, write a code generator that takes an application with a function expression that names that function, together with a target and a linkage descriptor, and produces code to spread the arguments into the registers and then perform the operation targeted to the given target with the given linkage. Make <span class="KeyTerm1">compile</span> dispatch to these code generators.</li>
<li><a id="c005_c5-li-0043"></a><span>c. </span>Try your new compiler on the <span class="KeyTerm1">factorial</span> example. Compare the resulting code with the result produced without open coding.</li>
</ol>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0106"></a><span>5.5.6</span> <a id="c005_c5-title-0107"></a>Lexical Addressing</h3>
<p class="paraaftertitle"><a id="c005_c5-para-1951"></a>One of the most common optimizations performed by compilers is the optimization of name lookup. Our compiler, as we have implemented it so far, generates code that uses the <span class="KeyTerm1">lookup_symbol_value</span> operation of the evaluator machine. This searches for a name by comparing it with each name that is currently bound, working frame by frame outward through the runtime environment. This search can be expensive if the frames are deeply nested or if there are many names. For example, consider the problem of looking up the value of <span class="KeyTerm1">x</span> while evaluating the expression <span class="KeyTerm1">x * y * z</span> in an application of the function of five arguments that is returned by</p>
<p class="Sp-text-1"><a id="c005_c5-para-1952"></a>((x, y) =&gt;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1953"></a>   (a, b, c, d, e) =&gt;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1954"></a>     ((y, z) =&gt; x * y * z)(a * b * x, c + d + x))(3, 4)</p>
<p class="paracontinue"><a id="c005_c5-para-1955"></a>Each time <span class="KeyTerm1">lookup_symbol_value</span> searches for <span class="KeyTerm1">x</span>, it must determine that the symbol <span class="KeyTerm1">"x"</span> is not equal to <span class="KeyTerm1">"y"</span> or <span class="KeyTerm1">"z"</span> (in the first frame), nor to <span class="KeyTerm1">"a"</span>, <span class="KeyTerm1">"b"</span>, <span class="KeyTerm1">"c"</span>, <span class="KeyTerm1">"d"</span>, or <span class="KeyTerm1">"e"</span> (in the second frame). Because our language is lexically scoped, the runtime environment for any component will have a structure that parallels the lexical structure of the program in which the component appears. Thus, the compiler can know, when it analyzes the above expression, that each time the function is applied the binding for <span class="KeyTerm1">x</span> in <span class="KeyTerm1">x * y * z</span> will be found two frames out from the current frame and will be the first binding in that frame.</p>
<p><a id="c005_c5-para-1956"></a>We can exploit this fact by inventing a new kind of name-lookup operation, <span class="KeyTerm1">lexical_address_lookup</span>, that takes as arguments an environment and a <i>lexi-cal address</i> that consists of two numbers: a <i>frame number</i>, which specifies how many frames to pass over, and a <i>displacement number</i>, which specifies how many bindings to pass over in that frame. The operation <span class="KeyTerm1">lexical_address_lookup</span> will produce the value of the name stored at that lexical address relative to the current environment. If we add the <span class="KeyTerm1">lexical_address_lookup</span> operation to our machine, we can make the compiler generate code that references names using this operation, rather than <span class="KeyTerm1">lookup_symbol_value</span>. Similarly, our compiled code can use a new <span class="KeyTerm1">lexical_address_assign</span> operation instead of <span class="KeyTerm1">assign_symbol_value</span>. With lexical addressing, there is no need to include any symbolic references to names in the object code, and frames do not need to include symbols at run time.</p>
<p><a id="c005_c5-para-1957"></a>In order to generate such code, the compiler must be able to determine the lexical address of a name it is about to compile a reference to. The lexical address of a name in a program depends on where one is in the code. For example, in the following program, the address of <span class="KeyTerm1">x</span> in expression <i>e</i><sub>1</sub> is (2,0)—two frames back and the first name in the frame. At that point <span class="KeyTerm1">y</span> is at address (0,0) and <span class="KeyTerm1">c</span> is at address (1,2). In expression <i>e</i><sub>2</sub>, <span class="KeyTerm1">x</span> is at (1,0), <span class="KeyTerm1">y</span> is at (1,1), and <span class="KeyTerm1">c</span> is at (0,2).</p>
<p class="Sp-text-1"><a id="c005_c5-para-1958"></a>((x, y) =&gt;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1959"></a>   (a, b, c, d, e) =&gt;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1960"></a>     ((y, z) =&gt; <i>e</i><sub>1</sub>)(<i>e</i><sub>2</sub>, c + d + x))(3, 4);</p>
<p><a id="c005_c5-para-1961"></a>One way for the compiler to produce code that uses lexical addressing is to maintain a data structure called a <i>compile-time environment</i>. This keeps track of which bindings will be at which positions in which frames in the runtime environment when a particular name-access operation is executed. The compile-time environment is a list of frames, each containing a list of symbols. There will be no values associated with the symbols, since values are not computed at compile time. (Exercise 5.47 will change this, as an optimization for constants.) The compile-time environment becomes an additional argument to <span class="KeyTerm1">compile</span> and is passed along to each code generator. The top-level call to <span class="KeyTerm1">compile</span> uses a compile-time-environment that includes the names of all primitive functions and primitive values. When the body of a lambda expression is compiled, <span class="KeyTerm1">compile_lambda_body</span> extends the compiletime environment by a frame containing the function's parameters, so that the body is compiled with that extended environment. Similarly, when the body of a block is compiled, <span class="KeyTerm1">compile_block</span> extends the compile-time environment by a frame containing the scanned-out local names of the body. At each point in the compilation, <span class="KeyTerm1">compile_name</span> and <span class="KeyTerm1">compile_assignment_declaration</span> use the compile-time environment in order to generate the appropriate lexical addresses.</p>
<p><a id="c005_c5-para-1962"></a>Exercises 5.42 through 5.45 describe how to complete this sketch of the lexical-addressing strategy in order to incorporate lexical lookup into the compiler. Exercises 5.46 and 5.47 describe other uses for the compile-time environment.</p>
<section>
<h5><a id="c005_c5-sec-0107"></a><a id="c005_c5-title-0108"></a>Exercise 5.42</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1963"></a>Write a function <span class="KeyTerm1">lexical_address_lookup</span> that implements the new lookup operation. It should take two arguments—a lexical address and a runtime environment—and return the value of the name stored at the specified lexical address. The function <span class="KeyTerm1">lexical_address_ lookup</span> should signal an error if the value of the name is the string <span class="KeyTerm1">"*unassigned*"</span>. Also write a function <span class="KeyTerm1">lexical_address_assign</span> that implements the operation that changes the value of the name at a specified lexical address.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0108"></a><a id="c005_c5-title-0109"></a>Exercise 5.43</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1964"></a>Modify the compiler to maintain the compile-time environment as described above. That is, add a compile-time-environment argument to <span class="KeyTerm1">compile</span> and the various code generators, and extend it in <span class="KeyTerm1">compile_lambda_body</span> and <span class="KeyTerm1">compile_block</span>.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0109"></a><a id="c005_c5-title-0110"></a>Exercise 5.44</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1965"></a>Write a function <span class="KeyTerm1">find_symbol</span> that takes as arguments a symbol and a compile-time environment and returns the lexical address of the symbol with respect to that environment. For example, in the program fragment that is shown above, the compile-time environment during the compilation of expression <i>e</i><sub>1</sub> is</p>
<p class="Sp-text-1"><a id="c005_c5-para-1966"></a>list(list("y", "z"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1967"></a>     list("a", "b", "c", "d", "e"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-5967"></a>     list("x", "y"))</p>
<p class="paracontinue"><a id="c005_c5-para-1968"></a>The function <span class="KeyTerm1">find_symbol</span> should produce</p>
<p class="Sp-text-1"><a id="c005_c5-para-1969"></a>find_symbol("c", list(list("y", "z"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1970"></a>                      list("a", "b", "c", "d", "e"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1971"></a>                      list("x", "y")));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1972"></a><i>list(1, 2)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-1973"></a>find_symbol("x", list(list("y", "z"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1974"></a>                      list("a", "b", "c", "d", "e"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1975"></a>                      list("x", "y")));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1976"></a><i>list(2, 0)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-1977"></a>find_symbol("w", list(list("y", "z"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1978"></a>                      list("a", "b", "c", "d", "e"),</p>
<p class="Sp-text-1"><a id="c005_c5-para-1979"></a>                      list("x", "y")));</p>
<p class="Sp-text-1"><a id="c005_c5-para-1980"></a><i>"not found"</i></p>
</section>
<section>
<h5><a id="c005_c5-sec-0110"></a><a id="c005_c5-title-0111"></a>Exercise 5.45</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1981"></a>Using <span class="KeyTerm1">find_symbol</span> from exercise 5.44, rewrite <span class="KeyTerm1">compile_assignment_declaration</span> and <span class="KeyTerm1">compile_name</span> to output lexical-address instructions. In cases where <span class="KeyTerm1">find_symbol</span> returns <span class="KeyTerm1">"not found"</span> (that is, where the name is not in the compile-time environment), you should report a compile-time error. Test the modified compiler on a few simple cases, such as the nested lambda combination at the beginning of this section.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0111"></a><a id="c005_c5-title-0112"></a>Exercise 5.46</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1982"></a>In JavaScript, an attempt to assign a new value to a name that is declared as a constant leads to an error. Exercise 4.11 shows how to detect such errors at run time. With the techniques presented in this section, we can detect attempts to assign a new value to a constant <i>at compile time</i>. For this purpose, extend the functions <span class="KeyTerm1">compile_lambda_body</span> and <span class="KeyTerm1">compile_block</span> to record in the compile-time environment whether a name is declared as a variable (using <span class="KeyTerm1"><b>let</b></span> or as a parameter), or as a constant (using <span class="KeyTerm1"><b>const</b></span> or <span class="KeyTerm1"><b>function</b></span>). Modify <span class="KeyTerm1">compile_assignment</span> to report an appropriate error when it detects an assignment to a constant.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0112"></a><a id="c005_c5-title-0113"></a>Exercise 5.47</h5>
<p class="paraaftertitle"><a id="c005_c5-para-1983"></a>Knowledge about constants at compile time opens the door to many optimizations that allow us to generate more efficient object code. In addition to the extension of the compiletime environment in exercise 5.46 to indicate names declared as constants, we may store the value of a constant if it is known at compile time, or other information that can help us optimize the code.</p>
<ol class="BS_NumberListA">
<li><a id="c005_c5-li-0044"></a><span>a. </span>A constant declaration such as <span class="KeyTerm1"><b>const</b></span> <i>name</i> <span class="KeyTerm1">=</span> <i>literal</i><span class="KeyTerm1">;</span> allows us to replace all occurrences of <i>name</i> within the scope of the declaration by <i>literal</i> so that <i>name</i> doesn't have to be looked up in the runtime environment. This optimization is called <i>constant propagation</i>. Use an extended compile-time environment to store literal constants, and modify <span class="KeyTerm1">compile_name</span> to use the stored constant in the generated <span class="KeyTerm1">assign</span> instruction instead of the <span class="KeyTerm1">lookup_symbol_value</span> operation.</li>
<li><a id="c005_c5-li-0045"></a><span>b. </span>Function declaration is a derived component that expands to constant declaration. Let us assume that the names of primitive functions in the global environment are also considered constants. If we further extend our compile-time environment to keep track of which names refer to compiled functions and which ones to primitive functions, we can move the test that checks whether a function is compiled or primitive from run time to compile time. This makes the object code more efficient because it replaces a test that must be performed once per function application in the generated code by one that is performed by the compiler. Using such an extended compile-time environment, modify <span class="KeyTerm1">compile_function_call</span> so that if it can be determined at compile time whether the called function is compiled or primitive, only the instructions in the <span class="KeyTerm1">compiled_branch</span> or the <span class="KeyTerm1">primitive_branch</span> are generated.</li>
<li><a id="c005_c5-li-0046"></a><span>c. </span>Replacing constant names with their literal values as in part (a) paves the way for another optimization, namely replacing applications of primitive functions to literal values with the compile-time computed result. This optimization, called <i>constant folding</i>, replaces expressions such as <span class="KeyTerm1">40 + 2</span> by <span class="KeyTerm1">42</span> by performing the addition in the compiler. Extend the compiler to perform constant folding for arithmetic operations on numbers and for string concatenation.</li>
</ol>
</section>
</section>
<section>
<h3><a id="c005_c5-sec-0113"></a><span>5.5.7</span> <a id="c005_c5-title-0114"></a>Interfacing Compiled Code to the Evaluator</h3>
<p class="paraaftertitle"><a id="c005_c5-para-1987"></a>We have not yet explained how to load compiled code into the evaluator machine or how to run it. We will assume that the explicit-control-evaluator machine has been defined as in section 5.4.4, with the additional operations specified in footnote 43 (section 5.5.2). We will implement a function <span class="KeyTerm1">compile_and_go</span> that compiles a JavaScript program, loads the resulting object code into the evaluator machine, and causes the machine to run the code in the evaluator global environment, print the result, and enter the evaluator's driver loop. We will also modify the evaluator so that interpreted components can call compiled functions as well as interpreted ones. We can then put a compiled function into the machine and use the evaluator to call it:</p>
<p class="Sp-text-1"><a id="c005_c5-para-1988"></a>compile_and_go(parse(ˋ</p>
<p class="Sp-text-1"><a id="c005_c5-para-1989"></a>function factorial(n) { </p>
<p class="Sp-text-1"><a id="c005_c5-para-1990"></a>    return n === 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1991"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-1992"></a>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c005_c5-para-1993"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-1994"></a>                     ˋ));</p>
<p class="Sp-text-3"><a id="c005_c5-para-1995"></a><i>EC-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-1996"></a><i>undefined</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-1997"></a><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-1998"></a>factorial(5);</p>
<p class="Sp-text-3"><a id="c005_c5-para-1999"></a><i>EC-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-2000"></a><i>120</i></p>
<p><a id="c005_c5-para-2001"></a>To allow the evaluator to handle compiled functions (for example, to evaluate the call to <span class="KeyTerm1">factorial</span> above), we need to change the code at <span class="KeyTerm1">apply_dispatch</span> (section 5.4.2) so that it recognizes compiled functions (as distinct from compound or primitive functions) and transfers control directly to the entry point of the compiled code:<a id="c005_c5-fn-0052a"></a><a href="#c5-fn-0052"><sup>52</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-2002"></a>"apply_dispatch",</p>
<p class="Sp-text-1"><a id="c005_c5-para-2003"></a>  test(list(op("is_primitive_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2004"></a>  branch(label("primitive_apply")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2005"></a>  test(list(op("is_compound_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2006"></a>  branch(label("compound_apply")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2007"></a>  test(list(op("is_compiled_function"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2008"></a>  branch(label("compiled_apply")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2009"></a>  go_to(label("unknown_function_type")),</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c005_c5-para-2011"></a>"compiled_apply",</p>
<p class="Sp-text-1"><a id="c005_c5-para-2012"></a>  push_marker_to_stack(),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2013"></a>  assign("val", list(op("compiled_function_entry"), reg("fun"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2014"></a>  go_to(reg("val")),</p>
<p class="paracontinue"><a id="c005_c5-para-2015"></a>At <span class="KeyTerm1">compiled_apply</span>, as at <span class="KeyTerm1">compound_apply</span>, we push a marker to the stack so that a return statement in the compiled function can revert the stack to this state. Note that there is no save of <span class="KeyTerm1">continue</span> at <span class="KeyTerm1">compiled_apply</span> before the marking of the stack, because the evaluator was arranged so that at <span class="KeyTerm1">apply_dispatch</span>, the continuation would be at the top of the stack.</p>
<p><a id="c005_c5-para-2016"></a>To enable us to run some compiled code when we start the evaluator machine, we add a <span class="KeyTerm1">branch</span> instruction at the beginning of the evaluator machine, which causes the machine to go to a new entry point if the <span class="KeyTerm1">flag</span> register is set.<a id="c005_c5-fn-0053a"></a><a href="#c5-fn-0053"><sup>53</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-2017"></a>  branch(label("external_entry")), <i>//</i> <span class="KeyTerm2"><i>branches if flag is set</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-2018"></a>"read_evaluate_print_loop",</p>
<p class="Sp-text-1"><a id="c005_c5-para-2019"></a>  perform(list(op("initialize_stack"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2020"></a> <i>. . .</i></p>
<p class="paracontinue"><a id="c005_c5-para-2021"></a>The code at <span class="KeyTerm1">external_entry</span> assumes that the machine is started with <span class="KeyTerm1">val</span> containing the location of an instruction sequence that puts a result into <span class="KeyTerm1">val</span> and ends with <span class="KeyTerm1">go_to(reg("continue"))</span>. Starting at this entry point jumps to the location designated by <span class="KeyTerm1">val</span>, but first assigns <span class="KeyTerm1">continue</span> so that execution will return to <span class="KeyTerm1">print_result</span>, which prints the value in <span class="KeyTerm1">val</span> and then goes to the beginning of the evaluator's read-evaluate-print loop.<a id="c005_c5-fn-0054a"></a><a href="#c5-fn-0054"><sup>54</sup></a></p>
<p class="Sp-text-1"><a id="c005_c5-para-2022"></a>"external_entry",</p>
<p class="Sp-text-1"><a id="c005_c5-para-2023"></a>  perform(list(op("initialize_stack"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2024"></a>  assign("env", list(op("get_current_environment"))),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2025"></a>  assign("continue", label("print_result")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2026"></a>  go_to(reg("val")),</p>
<p><a id="c005_c5-para-2027"></a>Now we can use the following function to compile a function declaration, execute the compiled code, and run the read-evaluate-print loop so we can try the function. Because we want the compiled code to proceed to the location in <span class="KeyTerm1">continue</span> with its result in <span class="KeyTerm1">val</span>, we compile the program with a target of <span class="KeyTerm1">val</span> and a linkage of <span class="KeyTerm1">"return"</span>. In order to transform the object code produced by the compiler into executable instructions for the evaluator register machine, we use the function <span class="KeyTerm1">assemble</span> from the register-machine simulator (section 5.2.2). For the interpreted program to refer to the names that are declared at top level in the compiled program, we scan out the top-level names and extend the global environment by binding these names to <span class="KeyTerm1">"*unassigned*"</span>, knowing that the compiled code will assign them the correct values. We then initialize the <span class="KeyTerm1">val</span> register to point to the list of instructions, set the <span class="KeyTerm1">flag</span> so that the evaluator will go to <span class="KeyTerm1">external_entry</span>, and start the evaluator.</p>
<p class="Sp-text-1"><a id="c005_c5-para-2049"></a><b>function</b> compile_and_go(program) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-2050"></a> <b>const</b> instrs = assemble(instructions(compile(program,</p>
<p class="Sp-text-1"><a id="c005_c5-para-2051"></a>                                                 "val", "return")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2052"></a>                            eceval);</p>
<p class="Sp-text-1"><a id="c005_c5-para-2053"></a> <b>const</b> toplevel_names = scan_out_declarations(program);</p>
<p class="Sp-text-1"><a id="c005_c5-para-2054"></a> <b>const</b> unassigneds = list_of_unassigned(toplevel_names);</p>
<p class="Sp-text-1"><a id="c005_c5-para-2055"></a>    set_current_environment(extend_environment(</p>
<p class="Sp-text-1"><a id="c005_c5-para-2056"></a>                               toplevel_names,</p>
<p class="Sp-text-1"><a id="c005_c5-para-2057"></a>                               unassigneds,</p>
<p class="Sp-text-1"><a id="c005_c5-para-2058"></a>                               the_global_environment));</p>
<p class="Sp-text-1"><a id="c005_c5-para-2059"></a>    set_register_contents(eceval, "val", instrs);</p>
<p class="Sp-text-1"><a id="c005_c5-para-2060"></a>    set_register_contents(eceval, "flag", <b>true</b>);</p>
<p class="Sp-text-1"><a id="c005_c5-para-2061"></a> <b>return</b> start(eceval);</p>
<p class="Sp-text-1"><a id="c005_c5-para-2062"></a>}</p>
<p><a id="c005_c5-para-2063"></a>If we have set up stack monitoring, as at the end of section 5.4.4, we can examine the stack usage of compiled code:</p>
<p class="Sp-text-1"><a id="c005_c5-para-2064"></a>compile_and_go(parse(ˋ</p>
<p class="Sp-text-1"><a id="c005_c5-para-2065"></a>function factorial(n) { </p>
<p class="Sp-text-1"><a id="c005_c5-para-2066"></a>    return n === 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-2067"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-2068"></a>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c005_c5-para-2069"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-2070"></a>                     ˋ));</p>
<p class="Sp-text-3"><a id="c005_c5-para-2071"></a><i>total pushes = 0</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-2072"></a><i>maximum depth = 0</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-2073"></a><i>EC-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-2074"></a><i>undefined</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-2075"></a><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-2076"></a>factorial(5);</p>
<p class="Sp-text-3"><a id="c005_c5-para-2077"></a><i>total pushes = 36</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-2078"></a><i>maximum depth = 14</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-2079"></a><i>EC-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-2080"></a><i>120</i></p>
<p class="paracontinue"><a id="c005_c5-para-2081"></a>Compare this example with the evaluation of <span class="KeyTerm1">factorial(5)</span> using the interpreted version of the same function, shown at the end of section 5.4.4. The interpreted version required 151 pushes and a maximum stack depth of 28. This illustrates the optimization that results from our compilation strategy.</p>
<section>
<h5><a id="c005_c5-sec-0114"></a><a id="c005_c5-title-0115"></a>Interpretation and compilation</h5>
<p class="paraaftertitle"><a id="c005_c5-para-2082"></a>With the programs in this section, we can now experiment with the alternative execution strategies of interpretation and compilation.<a id="c005_c5-fn-0055a"></a><a href="#c5-fn-0055"><sup>55</sup></a> An interpreter raises the machine to the level of the user program; a compiler lowers the user program to the level of the machine language. We can regard the JavaScript language (or any programming language) as a coherent family of abstractions erected on the machine language. Interpreters are good for interactive program development and debugging because the steps of program execution are organized in terms of these abstractions, and are therefore more intelligible to the programmer. Compiled code can execute faster, because the steps of program execution are organized in terms of the machine language, and the compiler is free to make optimizations that cut across the higher-level abstractions.<a id="c005_c5-fn-0056a"></a><a href="#c5-fn-0056"><sup>56</sup></a></p>
<p><a id="c005_c5-para-2083"></a>The alternatives of interpretation and compilation also lead to different strategies for porting languages to new computers. Suppose that we wish to implement JavaScript for a new machine. One strategy is to begin with the explicit-control evaluator of section 5.4 and translate its instructions to instructions for the new machine. A different strategy is to begin with the compiler and change the code generators so that they generate code for the new machine. The second strategy allows us to run any JavaScript program on the new machine by first compiling it with the compiler running on our original JavaScript system, and linking it with a compiled version of the runtime library.<a id="c005_c5-fn-0057a"></a><a href="#c5-fn-0057"><sup>57</sup></a> Better yet, we can compile the compiler itself, and run this on the new machine to compile other JavaScript programs.<a id="c005_c5-fn-0058a"></a><a href="#c5-fn-0058"><sup>58</sup></a> Or we can compile one of the interpreters of section 4.1 to produce an interpreter that runs on the new machine.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0115"></a><a id="c005_c5-title-0116"></a>Exercise 5.48</h5>
<p class="paraaftertitle"><a id="c005_c5-para-2084"></a>By comparing the stack operations used by compiled code to the stack operations used by the evaluator for the same computation, we can determine the extent to which the compiler optimizes use of the stack, both in speed (reducing the total number of stack operations) and in space (reducing the maximum stack depth). Comparing this optimized stack use to the performance of a special-purpose machine for the same computation gives some indication of the quality of the compiler.</p>
<ol class="BS_NumberListA">
<li><a id="c005_c5-li-0047"></a><span>a. </span>Exercise 5.28 asked you to determine, as a function of <i>n</i>, the number of pushes and the maximum stack depth needed by the evaluator to compute <i>n</i>! using the recursive factorial function given above. Exercise 5.13 asked you to do the same measurements for the special-purpose factorial machine shown in <a href="#c5-fig-0011">figure 5.11</a>. Now perform the same analysis using the compiled <span class="KeyTerm1">factorial</span> function.
<p><a id="c005_c5-para-2086"></a>Take the ratio of the number of pushes in the compiled version to the number of pushes in the interpreted version, and do the same for the maximum stack depth. Since the number of operations and the stack depth used to compute <i>n</i>! are linear in <i>n</i>, these ratios should approach constants as <i>n</i> becomes large. What are these constants? Similarly, find the ratios of the stack usage in the special-purpose machine to the usage in the interpreted version.</p>
<p><a id="c005_c5-para-2087"></a>Compare the ratios for special-purpose versus interpreted code to the ratios for compiled versus interpreted code. You should find that the special-purpose machine is much more efficient than the compiled code, since the hand-tailored controller code should be much better than what is produced by our rudimentary general-purpose compiler.</p></li>
<li><a id="c005_c5-li-0048"></a><span>b. </span>Can you suggest improvements to the compiler that would help it generate code that would come closer in performance to the hand-tailored version?</li>
</ol>
</section>
<section>
<h5><a id="c005_c5-sec-0116"></a><a id="c005_c5-title-0117"></a>Exercise 5.49</h5>
<p class="paraaftertitle"><a id="c005_c5-para-2089"></a>Carry out an analysis like the one in exercise 5.48 to determine the effectiveness of compiling the tree-recursive Fibonacci function</p>
<p class="Sp-text-1"><a id="c005_c5-para-2090"></a><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-2091"></a> <b>return</b> n &lt; 2 ? n : fib(n - 1) + fib(n - 2);</p>
<p class="Sp-text-1"><a id="c005_c5-para-2092"></a>}</p>
<p class="paracontinue"><a id="c005_c5-para-2093"></a>compared to the effectiveness of using the special-purpose Fibonacci machine of <a href="#c5-fig-0012">figure 5.12</a>. (For measurement of the interpreted performance, see exercise 5.30.) For Fibonacci, the time resource used is not linear in <i>n</i>; hence the ratios of stack operations will not approach a limiting value that is independent of <i>n</i>.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0117"></a><a id="c005_c5-title-0118"></a>Exercise 5.50</h5>
<p class="paraaftertitle"><a id="c005_c5-para-2094"></a>This section described how to modify the explicit-control evaluator so that interpreted code can call compiled functions. Show how to modify the compiler so that compiled functions can call not only primitive functions and compiled functions, but interpreted functions as well. This requires modifying <span class="KeyTerm1">compile_function_call</span> to handle the case of compound (interpreted) functions. Be sure to handle all the same <span class="KeyTerm1">target</span> and <span class="KeyTerm1">linkage</span> combinations as in <span class="KeyTerm1">compile_fun_appl</span>. To do the actual function application, the code needs to jump to the evaluator's <span class="KeyTerm1">compound_apply</span> entry point. This label cannot be directly referenced in object code (since the assembler requires that all labels referenced by the code it is assembling be defined there), so we will add a register called <span class="KeyTerm1">compapp</span> to the evaluator machine to hold this entry point, and add an instruction to initialize it:</p>
<p class="Sp-text-1"><a id="c005_c5-para-2095"></a>  assign("compapp", label("compound_apply")),</p>
<p class="Sp-text-1"><a id="c005_c5-para-2096"></a>  branch(label("external_entry")),     <i>//</i> <span class="KeyTerm2"><i>branches if flag is set</i></span></p>
<p class="Sp-text-1"><a id="c005_c5-para-2097"></a>"read_evaluate_print_loop",</p>
<p class="Sp-text-1"><a id="c005_c5-para-2098"></a> <i>. . .</i></p>
<p class="paracontinue"><a id="c005_c5-para-2099"></a>To test your code, start by declaring a function <span class="KeyTerm1">f</span> that calls a function <span class="KeyTerm1">g</span>. Use <span class="KeyTerm1">compile_ and_go</span> to compile the declaration of <span class="KeyTerm1">f</span> and start the evaluator. Now, typing at the evaluator, declare <span class="KeyTerm1">g</span> and try to call <span class="KeyTerm1">f</span>.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0118"></a><a id="c005_c5-title-0119"></a>Exercise 5.51</h5>
<p class="paraaftertitle"><a id="c005_c5-para-2100"></a>The <span class="KeyTerm1">compile_and_go</span> interface implemented in this section is awkward, since the compiler can be called only once (when the evaluator machine is started). Augment the compiler– interpreter interface by providing a <span class="KeyTerm1">compile_and_run</span> primitive that can be called from within the explicit-control evaluator as follows:</p>
<p class="Sp-text-3"><a id="c005_c5-para-2101"></a><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-2102"></a>compile_and_run(parse(ˋ</p>
<p class="Sp-text-1"><a id="c005_c5-para-2103"></a>function factorial(n) {</p>
<p class="Sp-text-1"><a id="c005_c5-para-2104"></a>    return n === 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-2105"></a>           ? 1</p>
<p class="Sp-text-1"><a id="c005_c5-para-2106"></a>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c005_c5-para-2107"></a>}</p>
<p class="Sp-text-1"><a id="c005_c5-para-2108"></a>                      ˋ));</p>
<p class="Sp-text-3"><a id="c005_c5-para-2109"></a><i>EC-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-2110"></a><i>undefined</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-2111"></a><i>EC-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c005_c5-para-2112"></a>factorial(5)</p>
<p class="Sp-text-3"><a id="c005_c5-para-2113"></a><i>EC-Eval value:</i></p>
<p class="Sp-text-3"><a id="c005_c5-para-2114"></a><i>120</i></p>
</section>
<section>
<h5><a id="c005_c5-sec-0119"></a><a id="c005_c5-title-0120"></a>Exercise 5.52</h5>
<p class="paraaftertitle"><a id="c005_c5-para-2115"></a>As an alternative to using the explicit-control evaluator's read-evaluate-print loop, design a register machine that performs a read-compile-execute-print loop. That is, the machine should run a loop that reads a program, compiles it, assembles and executes the resulting code, and prints the result. This is easy to run in our simulated setup, since we can arrange to call the functions <span class="KeyTerm1">compile</span> and <span class="KeyTerm1">assemble</span> as “register-machine operations.”</p>
</section>
<section>
<h5><a id="c005_c5-sec-0120"></a><a id="c005_c5-title-0121"></a>Exercise 5.53</h5>
<p class="paraaftertitle"><a id="c005_c5-para-2116"></a>Use the compiler to compile the metacircular evaluator of section 4.1 and run this program using the register-machine simulator. Because the parser takes a string as input, you will need to convert the program into a string. The simplest way to do this is to use the back quotes (<span class="KeyTerm1">-</span>), as we have done for the example inputs to <span class="KeyTerm1">compile_and_go</span> and <span class="KeyTerm1">compile_and_run</span>. The resulting interpreter will run very slowly because of the multiple levels of interpretation, but getting all the details to work is an instructive exercise.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0121"></a><a id="c005_c5-title-0122"></a>Exercise 5.54</h5>
<p class="paraaftertitle"><a id="c005_c5-para-2117"></a>Develop a rudimentary implementation of JavaScript in C (or some other low-level language of your choice) by translating the explicit-control evaluator of section 5.4 into C. In order to run this code you will need to also provide appropriate storage-allocation routines and other runtime support.</p>
</section>
<section>
<h5><a id="c005_c5-sec-0122"></a><a id="c005_c5-title-0123"></a>Exercise 5.55</h5>
<p class="paraaftertitle"><a id="c005_c5-para-2118"></a>As a counterpoint to exercise 5.54, modify the compiler so that it compiles JavaScript functions into sequences of C instructions. Compile the metacircular evaluator of section 4.1 to produce a JavaScript interpreter written in C.</p>
</section>
</section>
</section>
</section>
<section class="BS_enoteSec">
<aside class="noteEntry"><a id="c005_c5-fn-0001"></a><a href="#c5-fn-0001a">1</a> With our metacircular evaluator, a recursive function always gives rise to a recursive process, even when the process should be iterative according to the distinction of section 1.2.1. See footnote 6 in section 4.1.1.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0002"></a><a href="#c5-fn-0002a">2</a> This assumption glosses over a great deal of complexity. Implementation of reading and printing requires significant effort, for example to handle character encodings for different languages.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0003"></a><a href="#c5-fn-0003a">3</a> One might argue that we don't need to save the old <span class="KeyTerm1">n</span>; after we decrement it and solve the subproblem, we could simply increment it to recover the old value. Although this strategy works for factorial, it cannot work in general, since the old value of a register cannot always be computed from the new one.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0004"></a><a href="#c5-fn-0004a">4</a> In section 5.3 we will see how to implement a stack in terms of more primitive operations.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0005"></a><a href="#c5-fn-0005a">5</a> Using the <span class="KeyTerm1">receive</span> function here is a way to get <span class="KeyTerm1">extract_labels</span> to effectively return two values—<span class="KeyTerm1">labels</span> and <span class="KeyTerm1">insts</span>—without explicitly making a compound data structure to hold them. An alternative implementation, which returns an explicit pair of values, is
<br/><span class="BS_Sp-text-1_FN"><b>function</b> extract_labels(controller) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>if</b> (is_null(controller)) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> pair(<b>null</b>, <b>null</b>);</span>
<br/><span class="BS_Sp-text-1_FN">    } <b>else</b> {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>const</b> result = extract_labels(tail(controller));</span>
<br/><span class="BS_Sp-text-1_FN"> <b>const</b> insts = head(result);</span>
<br/><span class="BS_Sp-text-1_FN"> <b>const</b> labels = tail(result);</span>
<br/><span class="BS_Sp-text-1_FN"> <b>const</b> next_element = head(controller);</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> is_string(next_element)</span>
<br/><span class="BS_Sp-text-1_FN">               ? pair(insts,</span>
<br/><span class="BS_Sp-text-1_FN">                      pair(make_label_entry(next_element, insts), labels))</span>
<br/><span class="BS_Sp-text-1_FN">               : pair(pair(make_inst(next_element), insts),</span>
<br/><span class="BS_Sp-text-1_FN">                      labels);</span>
<br/><span class="BS_Sp-text-1_FN">    }</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>which would be called by <span class="KeyTerm1">assemble</span> as follows:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> assemble(controller, machine) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>const</b> result = extract_labels(controller);</span>
<br/><span class="BS_Sp-text-1_FN"> <b>const</b> insts = head(result);</span>
<br/><span class="BS_Sp-text-1_FN"> <b>const</b> labels = tail(result);</span>
<br/><span class="BS_Sp-text-1_FN">    update_insts(insts, labels, machine);</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> insts;</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>You can consider our use of <span class="KeyTerm1">receive</span> as demonstrating an elegant way to return multiple values, or simply an excuse to show off a programming trick. An argument like <span class="KeyTerm1">receive</span> that is the next function to be invoked is called a “continuation.” Recall that we also used continuations to implement the backtracking control structure in the <span class="KeyTerm1">amb</span> evaluator in section 4.3.3.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0006"></a><a href="#c5-fn-0006a">6</a> We could represent memory as lists of items. However, the access time would then not be independent of the index, since accessing the <i>n</i>th element of a list requires <i>n</i> – 1 <span class="KeyTerm1">tail</span> operations.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0007"></a><a href="#c5-fn-0007a">7</a> As mentioned in section 4.1.4 (footnote 18), JavaScript supports vectors as data structures and calls them “arrays.” We use the term <i>vector</i> in this book, as it is the more common terminology. The vector functions above are easily implemented using JavaScript's primitive array support.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0008"></a><a href="#c5-fn-0008a">8</a> For completeness, we should specify a <span class="KeyTerm1">make_vector</span> operation that constructs vectors. However, in the present application we will use vectors only to model fixed divisions of the computer memory.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0009"></a><a href="#c5-fn-0009a">9</a> This is precisely the same “tagged data” idea we introduced in chapter 2 for dealing with generic operations. Here, however, the data types are included at the primitive machine level rather than constructed through the use of lists.
<br/>  Type information may be encoded in a variety of ways, depending on the details of the machine on which the JavaScript system is to be implemented. The execution efficiency of JavaScript programs will be strongly dependent on how cleverly this choice is made, but it is difficult to formulate general design rules for good choices. The most straightforward way to implement typed pointers is to allocate a fixed set of bits in each pointer to be a <i>type field</i> that encodes the data type. Important questions to be addressed in designing such a representation include the following: How many type bits are required? How large must the vector indices be? How efficiently can the primitive machine instructions be used to manipulate the type fields of pointers? Machines that include special hardware for the efficient handling of type fields are said to have <i>tagged architectures</i>.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0010"></a><a href="#c5-fn-0010a">10</a> This decision on the representation of numbers determines whether <span class="KeyTerm1">===</span>, which tests equality of pointers, can be used to test for equality of numbers. If the pointer contains the number itself, then equal numbers will have the same pointer. But if the pointer contains the index of a location where the number is stored, equal numbers will be guaranteed to have equal pointers only if we are careful never to store the same number in more than one location.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0011"></a><a href="#c5-fn-0011a">11</a> This is just like writing a number as a sequence of digits, except that each “digit” is a number between 0 and the largest number that can be stored in a single pointer.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0012"></a><a href="#c5-fn-0012a">12</a> There are other ways of finding free storage. For example, we could link together all the unused pairs into a <i>free list</i>. Our free locations are consecutive (and hence can be accessed by incrementing a pointer) because we are using a compacting garbage collector, as we will see in section 5.3.2.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0013"></a><a href="#c5-fn-0013a">13</a> This is essentially the implementation of <span class="KeyTerm1">pair</span> in terms of <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span>, as described in section 3.3.1. The operation <span class="KeyTerm1">get_new_pair</span> used in that implementation is realized here by the <span class="KeyTerm1">free</span> pointer.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0014"></a><a href="#c5-fn-0014a">14</a> This may not be true eventually, because memories may get large enough so that it would be impossible to run out of free memory in the lifetime of the computer. For example, there are about 3 10<sup>16</sup> nanoseconds in a year, so if we were to <span class="KeyTerm1">pair</span> once per nanosecond we would need about 10<sup>18</sup> cells of memory to build a machine that could operate for 30 years without running out of memory. That much memory seems absurdly large by today's standards, but it is not physically impossible. On the other hand, processors are getting faster and modern computers have increasingly large numbers of processors operating in parallel on a single memory, so it may be possible to use up memory much faster than we have postulated.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0015"></a><a href="#c5-fn-0015a">15</a> We assume here that the stack is represented as a list as described in section 5.3.1, so that items on the stack are accessible via the pointer in the stack register.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0016"></a><a href="#c5-fn-0016a">16</a> This idea was invented and first implemented by Minsky, as part of the implementation of Lisp for the PDP-1 at the MIT Research Laboratory of Electronics. It was further developed by Fenichel and Yochelson (1969) for use in the Lisp implementation for the Multics timesharing system. Later, Baker (1978) developed a “real-time” version of the method, which does not require the computation to stop during garbage collection. Baker's idea was extended by Hewitt, Lieberman, and Moon (see Lieberman and Hewitt 1983) to take advantage of the fact that some structure is more volatile and other structure is more permanent.
<br/>  An alternative commonly used garbage-collection technique is the <i>mark-sweep</i> method. This consists of tracing all the structure accessible from the machine registers and marking each pair we reach. We then scan all of memory, and any location that is unmarked is “swept up” as garbage and made available for reuse. A full discussion of the mark-sweep method can be found in Allen 1978.
<br/>  The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in use for largememory systems because it examines only the useful part of memory. This is in contrast to mark-sweep, in which the sweep phase must check all of memory. A second advantage of stop-and-copy is that it is a <i>compacting</i> garbage collector. That is, at the end of the garbagecollection phase the useful data will have been moved to consecutive memory locations, with all garbage pairs compressed out. This can be an extremely important performance consideration in machines with virtual memory, in which accesses to widely separated memory addresses may require extra paging operations.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0017"></a><a href="#c5-fn-0017a">17</a> This list of registers does not include the registers used by the storage-allocation system: <span class="KeyTerm1">root</span>, <span class="KeyTerm1">the_heads</span>, <span class="KeyTerm1">the_tails</span>, and the other registers that will be introduced in this section.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0018"></a><a href="#c5-fn-0018a">18</a> The term <i>broken heart</i> was coined by David Cressey, who wrote a garbage collector for MDL, a dialect of Lisp developed at MIT during the early 1970s.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0019"></a><a href="#c5-fn-0019a">19</a> The garbage collector uses the low-level predicate <span class="KeyTerm1">is_pointer_to_pair</span> instead of the liststructure <span class="KeyTerm1">is_pair</span> operation because in a real system there might be various things that are treated as pairs for garbage-collection purposes. For example, a function object may be implemented as a special kind of “pair” that doesn't satisfy the <span class="KeyTerm1">is_pair</span> predicate. For simulation purposes, <span class="KeyTerm1">is_pointer_to_pair</span> can be implemented as <span class="KeyTerm1">is_pair</span>.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0020"></a><a href="#c5-fn-0020a">20</a> See Batali et al. 1982 for more information on the chip and the method by which it was designed.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0021"></a><a href="#c5-fn-0021a">21</a> In our controller, the dispatch is written as a sequence of <span class="KeyTerm1">test</span> and <span class="KeyTerm1">branch</span> instructions. Alternatively, it could have been written in a data-directed style, which avoids the need to perform sequential tests and facilitates the definition of new component types.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0022"></a><a href="#c5-fn-0022a">22</a> In this chapter, we will use the function <span class="KeyTerm1">is_falsy</span> to test the value of the predicate. This allows us to write the consequent and alternative branches in the same order as in a conditional, and simply fall through to the consequent branch when the predicate holds. The function <span class="KeyTerm1">is_falsy</span> is declared as the opposite of the <span class="KeyTerm1">is_truthy</span> function used to test predicates of conditionals in section 4.1.1.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0023"></a><a href="#c5-fn-0023a">23</a> This is an important but subtle point in translating algorithms from a procedural language, such as JavaScript, to a register-machine language. As an alternative to saving only what is needed, we could save all the registers (except <span class="KeyTerm1">val</span>) before each recursive call. This is called a <i>framed-stack</i> discipline. This would work but might save more registers than necessary; this could be an important consideration in a system where stack operations are expensive. Saving registers whose contents will not be needed later may also hold on to useless data that could otherwise be garbage-collected, freeing space to be reused.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0024"></a><a href="#c5-fn-0024a">24</a> We assume that the syntax transformer <span class="KeyTerm1">operator_combination_to_application</span> is available as a machine operation. In an actual implementation built from scratch, we would use our explicit-control evaluator to interpret a JavaScript program that performs source-level transformations like this one and <span class="KeyTerm1">function_decl_to_constant_decl</span> in a syntax phase that runs before execution.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0025"></a><a href="#c5-fn-0025a">25</a> We add to the evaluator data-structure functions in section 4.1.3 the following two functions for manipulating argument lists:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> empty_arglist() { <b>return null</b>; }</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> adjoin_arg(arg, arglist) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> append(arglist, list(arg));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>We also make use of an additional syntax function to test for the last argument expression in an application:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> is_last_argument_expression(arg_expression) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> is_null(tail(arg_expression));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0026"></a><a href="#c5-fn-0026a">26</a> The optimization of treating the last argument expression specially is known as <i>evlis tail recursion</i> (see Wand 1980). We could be somewhat more efficient in the argument evaluation loop if we made evaluation of the first argument expression a special case too. This would permit us to postpone initializing <span class="KeyTerm1">argl</span> until after evaluating the first argument expression, so as to avoid saving <span class="KeyTerm1">argl</span> in this case. The compiler in section 5.5 performs this optimization. (Compare the <span class="KeyTerm1">construct_arglist</span> function of section 5.5.3.)</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0027"></a><a href="#c5-fn-0027a">27</a> The order of argument-expression evaluation by the function <span class="KeyTerm1">list_of_values</span> in the metacircular evaluator is determined by the order of evaluation of the arguments to <span class="KeyTerm1">pair</span>, which is used to construct the argument list. The version of <span class="KeyTerm1">list_of_values</span> in footnote 7 of section 4.1 calls <span class="KeyTerm1">pair</span> directly; the version in the text uses <span class="KeyTerm1">map</span>, which calls <span class="KeyTerm1">pair</span>. (See exercise 4.1.)</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0028"></a><a href="#c5-fn-0028a">28</a> The special instructions <span class="KeyTerm1">push_marker_to_stack</span> and <span class="KeyTerm1">revert_stack_to_marker</span> are not strictly necessary and could be implemented by explicitly pushing and popping a marker value onto and off the stack. Anything that could not be confused with a value in the program can be used as a marker. See exercise 5.23.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0029"></a><a href="#c5-fn-0029a">29</a> We saw in section 5.1 how to implement such a process with a register machine that had no stack; the state of the process was stored in a fixed set of registers.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0030"></a><a href="#c5-fn-0030a">30</a> This implementation of tail recursion is one variety of a well-known optimization technique used by many compilers. In compiling a function that ends with a function call, one can replace the call by a jump to the called function's entry point. Building this strategy into the interpreter, as we have done in this section, provides the optimization uniformly throughout the language.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0031"></a><a href="#c5-fn-0031a">31</a> Footnote 24 suggests that an actual implementation would perform syntax transformations before program execution. In the same vein, names declared in blocks should be scanned out in a preprocessing step rather than each time a block is evaluated.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0032"></a><a href="#c5-fn-0032a">32</a> We assume here that <span class="KeyTerm1">user_read</span>, <span class="KeyTerm1">parse</span>, and the various printing operations are available as primitive machine operations, which is useful for our simulation, but completely unrealistic in practice. These are actually extremely complex operations. In practice, reading and printing would be implemented using low-level input-output operations such as transferring single characters to and from a device.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0033"></a><a href="#c5-fn-0033a">33</a> There are other errors that we would like the interpreter to handle, but these are not so simple. See exercise 5.31.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0034"></a><a href="#c5-fn-0034a">34</a> We could perform the stack initialization only after errors, but doing it in the driver loop will be convenient for monitoring the evaluator's performance, as described below.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0035"></a><a href="#c5-fn-0035a">35</a> This manifests itself as, for example, a “kernel panic” or a “blue screen of death” or even a reboot. Automatic rebooting is an approach typically used on phones and tablets. Most modern operating systems do a decent job of preventing user programs from causing an entire machine to crash.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0036"></a><a href="#c5-fn-0036a">36</a> This is a theoretical statement. We are not claiming that the evaluator's data paths are a particularly convenient or efficient set of data paths for a general-purpose computer. For example, they are not very good for implementing high-performance floating-point calculations or calculations that intensively manipulate bit vectors.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0037"></a><a href="#c5-fn-0037a">37</a> Actually, the machine that runs compiled code can be simpler than the interpreter machine, because we won't use the <span class="KeyTerm1">comp</span> and <span class="KeyTerm1">unev</span> registers. The interpreter used these to hold pieces of unevaluated components. With the compiler, however, these components get built into the compiled code that the register machine will run. For the same reason, we don't need the machine operations that deal with component syntax. But compiled code will use a few additional machine operations (to represent compiled function objects) that didn't appear in the explicit-control evaluator machine.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0038"></a><a href="#c5-fn-0038a">38</a> Language implementations often delay the compilation of program parts even when they are assumed to be debugged, until there is enough evidence that compiling them would lead to an overall efficiency advantage. The evidence is obtained at run time by monitoring the number of times the program parts are being interpreted. This technique is called <i>just-in-time compilation</i>.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0039"></a><a href="#c5-fn-0039a">39</a> Notice, however, that our compiler is a JavaScript program, and the syntax functions that it uses to manipulate expressions are the actual JavaScript functions used with the metacircular evaluator. For the explicit-control evaluator, in contrast, we assumed that equivalent syntax operations were available as operations for the register machine. (Of course, when we simulated the register machine in JavaScript, we used the actual JavaScript functions in our register machine simulation.)</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0040"></a><a href="#c5-fn-0040a">40</a> We can't just use the labels <span class="KeyTerm1">true_branch</span>, <span class="KeyTerm1">false_branch</span>, and <span class="KeyTerm1">after_cond</span> as shown above, because there might be more than one conditional in the program. The compiler uses the function <span class="KeyTerm1">make_label</span> to generate labels. The function <span class="KeyTerm1">make_label</span> takes a string as argument and returns a new string that begins with the given string. For example, successive calls to <span class="KeyTerm1">make_label("a")</span> would return <span class="KeyTerm1">"a1"</span>, <span class="KeyTerm1">"a2"</span>, and so on. The function <span class="KeyTerm1">make_label</span> can be implemented similarly to the generation of unique variable names in the query language, as follows
<br/><span class="BS_Sp-text-1_FN"><b>let</b> label_counter = 0;</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> new_label_number() {</span>
<br/><span class="BS_Sp-text-1_FN">    label_counter = label_counter + 1;</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> label_counter;</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> make_label(string) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> string + stringify(new_label_number());</span>
<br/><span class="BS_Sp-text-1_FN">}:</span>
</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0041"></a><a href="#c5-fn-0041a">41</a> The <span class="KeyTerm1">continue</span> register would be needed for a <span class="KeyTerm1">"return"</span> linkage, which can result from a compilation by <span class="KeyTerm1">compile_and_go</span> (section 5.5.7).</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0042"></a><a href="#c5-fn-0042a">42</a> Our compiler does not detect all dead code. For example, a conditional statement whose consequent and alternative branches both end in a return statement will not stop subsequent statements from being compiled. See exercises 5.34 and 5.35.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0043"></a><a href="#c5-fn-0043a">43</a> We need machine operations to implement a data structure for representing compiled functions, analogous to the structure for compound functions described in section 4.1.3:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> make_compiled_function(entry, env) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> list("compiled_function", entry, env);</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> is_compiled_function(fun) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> is_tagged_list(fun, "compiled_function");</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> compiled_function_entry(c_fun) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> head(tail(c_fun));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> compiled_function_env(c_fun) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> head(tail(tail(c_fun)));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0044"></a><a href="#c5-fn-0044a">44</a> The augmented function body is a sequence ending with a return statement. Compilation of a sequence of statements uses the linkage <span class="KeyTerm1">"next"</span> for all its component statements except the last, for which it uses the given linkage. In this case, the last statement is a return statement, and as we will see in section 5.5.3, a return statement always uses the <span class="KeyTerm1">"return"</span> linkage descriptor for its return expression. Thus all function bodies will end with a <span class="KeyTerm1">"return"</span> linkage, not the <span class="KeyTerm1">"next"</span> we pass as the linkage argument to <span class="KeyTerm1">compile</span> in <span class="KeyTerm1">compile_lambda_body</span>.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0045"></a><a href="#c5-fn-0045a">45</a> Because the execution of a function body always ends with a return, there is no need here for a mechanism like the <span class="KeyTerm1">return_undefined</span> entry point from section 5.4.2.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0046"></a><a href="#c5-fn-0046a">46</a> Elsewhere in the compiler, all saves and restores of registers are generated by <span class="KeyTerm1">preserving</span> to preserve a register's value across a sequence of instructions by saving it before those instructions and restoring it after—for example over the evaluation of the predicate of a conditional. But this mechanism cannot generate instructions to save and restore <span class="KeyTerm1">continue</span> for a function application and the corresponding return, because these are compiled separately and are not contiguous. Instead, these saves and restores must be explicitly generated by <span class="KeyTerm1">compile_fun_appl</span> and <span class="KeyTerm1">compile_return_statement</span>.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0047"></a><a href="#c5-fn-0047a">47</a> Actually, we signal an error when the target is not <span class="KeyTerm1">val</span> and the linkage is <span class="KeyTerm1">"return"</span>, since the only place we request a <span class="KeyTerm1">"return"</span> linkage is in compiling return expressions, and our convention is that functions return their values in <span class="KeyTerm1">val</span>.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0048"></a><a href="#c5-fn-0048a">48</a> Making a compiler generate tail-recursive code is desirable, especially in the functional paradigm. However, compilers for common languages, including C and C++, do not always do this, and therefore these languages cannot represent iterative processes in terms of function call alone. The difficulty with tail recursion in these languages is that their implementations use the stack to store function arguments and local names as well as return addresses. The JavaScript implementations described in this book store arguments and names in memory to be garbage-collected. The reason for using the stack for names and arguments is that it avoids the need for garbage collection in languages that would not otherwise require it, and is generally believed to be more efficient. Sophisticated compilers can, in fact, use the stack for arguments without destroying tail recursion. (See Hanson 1990 for a description.) There is also some debate about whether stack allocation is actually more efficient than garbage collection in the first place, but the details seem to hinge on fine points of computer architecture. (See Appel 1987 and Miller and Rozas 1994 for opposing views on this issue.)</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0049"></a><a href="#c5-fn-0049a">49</a> The constant <span class="KeyTerm1">all_regs</span> is bound to the list of names of all the registers:
<br/><span class="BS_Sp-text-1_FN"><b>const</b> all_regs = list("env", "fun", "val", "argl", "continue");</span>
</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0050"></a><a href="#c5-fn-0050a">50</a> Because of the <span class="KeyTerm1">append_return_undefined</span> in <span class="KeyTerm1">compile_lambda_body</span>, the body actually consists of a sequence with two return statements. However, the dead-code check in <span class="KeyTerm1">compile_ sequence</span> will stop after the compilation of the first return statement, so the body effectively consists of only a single return statement.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0051"></a><a href="#c5-fn-0051a">51</a> We have used the same symbol <span class="KeyTerm1">+</span> here to denote both the source-language function and the machine operation. In general there will not be a one-to-one correspondence between primitives of the source language and primitives of the machine.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0052"></a><a href="#c5-fn-0052a">52</a> Of course, compiled functions as well as interpreted functions are compound (nonprimitive). For compatibility with the terminology used in the explicit-control evaluator, in this section we will use “compound” to mean interpreted (as opposed to compiled).</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0053"></a><a href="#c5-fn-0053a">53</a> Now that the evaluator machine starts with a <span class="KeyTerm1">branch</span>, we must always initialize the <span class="KeyTerm1">flag</span> register before starting the evaluator machine. To start the machine at its ordinary read-evaluate-print loop, we could use
<br/><span class="BS_Sp-text-1_FN"><b>function</b> start_eceval() {</span>
<br/><span class="BS_Sp-text-1_FN">    set_register_contents(eceval, "flag", <b>false</b>);</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> start(eceval);</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0054"></a><a href="#c5-fn-0054a">54</a> Since a compiled function is an object that the system may try to print, we also modify the system print operation <span class="KeyTerm1">user_print</span> (from section 4.1.4) so that it will not attempt to print the components of a compiled function:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> user_print(string, object) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>function</b> prepare(object) {</span>
<br/><span class="BS_Sp-text-1_FN"> <b>return</b> is_compound_function(object)</span>
<br/><span class="BS_Sp-text-1_FN">           ? "&lt; compound function &gt;"</span>
<br/><span class="BS_Sp-text-1_FN">           : is_primitive_function(object)</span>
<br/><span class="BS_Sp-text-1_FN">           ? "&lt; primitive function &gt;"</span>
<br/><span class="BS_Sp-text-1_FN">           : is_compiled_function(object)</span>
<br/><span class="BS_Sp-text-1_FN">           ? "&lt; compiled function &gt;"</span>
<br/><span class="BS_Sp-text-1_FN">           : is_pair(object)</span>
<br/><span class="BS_Sp-text-1_FN">           ? pair(prepare(head(object)),</span>
<br/><span class="BS_Sp-text-1_FN">                  prepare(tail(object)))</span>
<br/><span class="BS_Sp-text-1_FN">           : object;</span>
<br/><span class="BS_Sp-text-1_FN">    }</span>
<br/><span class="BS_Sp-text-1_FN">    display(string + " " + stringify(prepare(object)));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0055"></a><a href="#c5-fn-0055a">55</a> We can do even better by extending the compiler to allow compiled code to call interpreted functions. See exercise 5.50.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0056"></a><a href="#c5-fn-0056a">56</a> Independent of the strategy of execution, we incur significant overhead if we insist that errors encountered in execution of a user program be detected and signaled, rather than being allowed to kill the system or produce wrong answers. For example, an out-of-bounds array reference can be detected by checking the validity of the reference before performing it. The overhead of checking, however, can be many times the cost of the array reference itself, and a programmer should weigh speed against safety in determining whether such a check is desirable. A good compiler should be able to produce code with such checks, should avoid redundant checks, and should allow programmers to control the extent and type of error checking in the compiled code.
<br/>  Compilers for popular languages, such as C and C++, put hardly any error-checking operations into running code, so as to make things run as fast as possible. As a result, it falls to programmers to explicitly provide error checking. Unfortunately, people often neglect to do this, even in critical applications where speed is not a constraint. Their programs lead fast and dangerous lives. For example, the notorious “Worm” that paralyzed the Internet in 1988 exploited the UNIX<sup>TM</sup> operating system's failure to check whether the input buffer has overflowed in the finger daemon. (See Spafford 1989.)</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0057"></a><a href="#c5-fn-0057a">57</a> Of course, with either the interpretation or the compilation strategy we must also implement for the new machine storage allocation, input and output, and all the various operations that we took as “primitive” in our discussion of the evaluator and compiler. One strategy for minimizing work here is to write as many of these operations as possible in JavaScript and then compile them for the new machine. Ultimately, everything reduces to a small kernel (such as garbage collection and the mechanism for applying actual machine primitives) that is hand-coded for the new machine.</aside>
<aside class="noteEntry"><a id="c005_c5-fn-0058"></a><a href="#c5-fn-0058a">58</a> This strategy leads to amusing tests of correctness of the compiler, such as checking whether the compilation of a program on the new machine, using the compiled compiler, is identical with the compilation of the program on the original JavaScript system. Tracking down the source of differences is fun but often frustrating, because the results are extremely sensitive to minuscule details.</aside>
</section>
</section>
</body><body>
<section>
<header>
<h1><a id="c444_b1-title-0001"></a><span class="chapterTitle">References</span></h1>
</header>
<section class="biblioDiv"><a id="c444_b1-ref-0001"></a>
<h2><a id="c444_b1-title-0002"></a></h2>
<ol class="biblioEntryList">
<li class="bibliographyEntry"><a id="c444_b1-bib-0001"></a>Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister, Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992. The Supercomputer Toolkit: A general framework for special-purpose computing. <i>International Journal of High-Speed Electronics</i> 3(3):337–361.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0002"></a>Allen, John. 1978. <i>Anatomy of Lisp</i>. New York: McGraw-Hill.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0003"></a>Appel, Andrew W. 1987. Garbage collection can be faster than stack allocation. <i>Information Processing Letters</i> 25(4):275–279.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0004"></a>Backus, John. 1978. Can programming be liberated from the von Neumann style? <i>Communications of the ACM</i> 21(8):613–641.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0005"></a>Baker, Henry G., Jr. 1978. List processing in real time on a serial computer. <i>Communications of the ACM</i> 21(4):280–293.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0006"></a>Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise. 1982. The Scheme-81 architecture—System and chip. In <i>Proceedings of the MIT Conference on Advanced Research in VLSI</i>, edited by Paul Penfield, Jr. Dedham, MA: Artech House.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0007"></a>Borning, Alan. 1977. ThingLab—An object-oriented system for building simulations using constraints. In <i>Proceedings of the 5th International Joint Conference on Artificial Intelligence</i>.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0008"></a>Borodin, Alan, and Ian Munro. 1975. <i>The Computational Complexity of Algebraic and Numeric Problems</i>. New York: American Elsevier.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0009"></a>Chaitin, Gregory J. 1975. Randomness and mathematical proof. <i>Scientific American</i> 232(5): 47–52.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0010"></a>Church, Alonzo. 1941. <i>The Calculi of Lambda-Conversion</i>. Princeton, N.J.: Princeton University Press.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0011"></a>Clark, Keith L. 1978. Negation as failure. In <i>Logic and Data Bases</i>. New York: Plenum Press, pp. 293–322.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0012"></a>Clinger, William. 1982. Nondeterministic call by need is neither lazy nor by name. In <i>Proceedings of the ACM Symposium on Lisp and Functional Programming</i>, pp. 226–234.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0013"></a>Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel. 1973. Un système de communication homme-machine en français. Technical report, Groupe d’Intelligence Artificielle, Université d’Aix-Marseille II, Luminy.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0014"></a>Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2022. <i>Introduction to Algorithms</i>. 4th edition. Cambridge, MA: MIT Press.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0015"></a>Crockford, Douglas. 2008. <i>JavaScript: The Good Parts</i>. Sebastopol, CA: O’Reilly Media.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0016"></a>Darlington, John, Peter Henderson, and David Turner. 1982. <i>Functional Programming and Its Applications</i>. New York: Cambridge University Press.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0017"></a>Dijkstra, Edsger W. 1968a. The structure of the “THE” multiprogramming system. <i>Communications of the ACM</i> 11(5):341–346.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0018"></a>Dijkstra, Edsger W. 1968b. Cooperating sequential processes. In <i>Programming Languages</i>, edited by F. Genuys. New York: Academic Press, pp. 43–112.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0019"></a>Dinesman, Howard P. 1968. <i>Superior Mathematical Puzzles</i>. New York: Simon and Schuster.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0020"></a>de Kleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman. 1977. AMORD: Explicit control of reasoning. In <i>Proceedings of the ACM Symposium on Artificial Intelligence and Programming Languages</i>, pp. 116–125.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0021"></a>Doyle, Jon. 1979. A truth maintenance system. <i>Artificial Intelligence</i> 12:231–272.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0022"></a>ECMA. 1997. ECMAScript: A general purpose, cross-platform programming language. 1st edition, edited by Guy L. Steele Jr. <i>Ecma International</i>.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0023"></a>ECMA. 2015. ECMAScript: A general purpose, cross-platform programming language. 6th edition, edited by Allen Wirfs-Brock. <i>Ecma International</i>.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0024"></a>ECMA. 2020. <i>ECMAScript: A general purpose, cross-platform programming language</i>. 11th edition, edited by Jordan Harband. <i>Ecma International</i>.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0025"></a>Edwards, A. W. F. 2019. <i>Pascal's Arithmetical Triangle. Mineola</i>, New York: Dover Publications.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0026"></a>Feeley, Marc. 1986. Deux approches à l’implantation du language Scheme. Masters thesis, Université de Montréal.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0027"></a>Feeley, Marc and Guy Lapalme. 1987. Using closures for code generation. <i>Journal of Computer Languages</i> 12(1):47–66.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0028"></a>Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National Fifth Generation Project: Introduction, survey, and evaluation. In <i>Future Generation Computer Systems</i>, vol. 9, pp. 105–117.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0029"></a>Feller, William. 1957. <i>An Introduction to Probability Theory and Its Applications</i>, volume 1. <i>New York</i>: John Wiley &amp; Sons.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0030"></a>Fenichel, R., and J. Yochelson. 1969. A Lisp garbage collector for virtual memory computer systems. <i>Communications of the ACM</i> 12(11):611–612.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0031"></a>Floyd, Robert. 1967. Nondeterministic algorithms. <i>JACM</i>, 14(4):636–644.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0032"></a>Forbus, Kenneth D., and Johan de Kleer. 1993. <i>Building Problem Solvers</i>. Cambridge, MA: MIT Press.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0033"></a>Friedman, Daniel P., and David S. Wise. 1976. CONS should not evaluate its arguments. In <i>Automata, Languages, and Programming: Third International Colloquium</i>, edited by S. Michaelson and R. Milner, pp. 257–284.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0034"></a>Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992. <i>Essentials of Programming Languages</i>. Cambridge, MA: MIT Press/McGraw-Hill.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0035"></a>Gabriel, Richard P. 1988. The Why of <i>Y</i>. <i>Lisp Pointers</i> 2(2):15–25.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0036"></a>Goldberg, Adele, and David Robson. 1983. <i>Smalltalk-80: The Language and Its Implementation</i>. Reading, MA: Addison-Wesley.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0037"></a>Gordon, Michael, Robin Milner, and Christopher Wadsworth. 1979. <i>Edinburgh LCF. Lecture Notes in Computer Science</i>, volume 78. New York: Springer-Verlag.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0038"></a>Gray, Jim, and Andreas Reuter. 1993. <i>Transaction Processing: Concepts and Models</i>. San Mateo, CA: Morgan-Kaufman.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0039"></a>Green, Cordell. 1969. Application of theorem proving to problem solving. In <i>Proceedings of the International Joint Conference on Artificial Intelligence</i>, pp. 219–240.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0040"></a>Green, Cordell, and Bertram Raphael. 1968. The use of theorem-proving techniques in question-answering systems. In <i>Proceedings of the ACM National Conference</i>, pp. 169–181.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0041"></a>Guttag, John V. 1977. Abstract data types and the development of data structures. <i>Communications of the ACM</i> 20(6):397–404.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0042"></a>Hamming, Richard W. 1980. <i>Coding and Information Theory</i>. Englewood Cliffs, N.J.: Prentice-Hall.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0043"></a>Hanson, Christopher P. 1990. Efficient stack allocation for tail-recursive languages. In <i>Proceedings of ACM Conference on Lisp and Functional Programming</i>, pp. 106–118.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0044"></a>Hanson, Christopher P. 1991. A syntactic closures macro facility. <i>Lisp Pointers</i>, 4(4):9–16.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0045"></a>Hardy, Godfrey H. 1921. Srinivasa Ramanujan. <i>Proceedings of the London Mathematical Society</i> XIX(2).</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0046"></a>Hardy, Godfrey H., and E. M. Wright. 1960. <i>An Introduction to the Theory of Numbers</i>. 4th edition. New York: Oxford University Press.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0047"></a>Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. <i>IBM Systems Journal</i> 7(2):74–84.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0048"></a>Henderson, Peter. 1980. <i>Functional Programming: Application and Implementation</i>. Englewood Cliffs, N.J.: Prentice-Hall.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0049"></a>Henderson. Peter. 1982. Functional Geometry. In <i>Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming</i>, pp. 179–187.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0050"></a>Hewitt, Carl E. 1969. PLANNER: A language for proving theorems in robots. In <i>Proceedings of the International Joint Conference on Artificial Intelligence</i>, pp. 295–301.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0051"></a>Hewitt, Carl E. 1977. Viewing control structures as patterns of passing messages. <i>Journal of Artificial Intelligence</i> 8(3):323–364.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0052"></a>Hoare, C. A. R. 1972. Proof of correctness of data representations. <i>Acta Informatica</i> 1(1):271–281.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0053"></a>Hodges, Andrew. 1983. <i>Alan Turing: The Enigma</i>. New York: Simon and Schuster.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0054"></a>Hofstadter, Douglas R. 1979. <i>Gödel, Escher, Bach: An Eternal Golden Braid</i>. New York: Basic Books.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0055"></a>Hughes, R. J. M. 1990. Why functional programming matters. In <i>Research Topics in Functional Programming</i>, edited by David Turner. Reading, MA: Addison-Wesley, pp. 17–42.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0056"></a>IEEE Std 1178-1990. 1990. IEEE Standard for the Scheme Programming Language.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0057"></a>Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted by M. Lind, Herbert Kanner, and Robert Floyd. 1960. THUNKS: A way of compiling procedure statements, with some comments on procedure declarations. Unpublished manuscript. (Also, private communication from Wallace Feurzeig.)</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0058"></a>Jaffar, Joxan, and Peter J. Stuckey. 1986. Semantics of infinite tree logic programming. <i>Theoretical Computer Science</i> 46:141–158.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0059"></a>Kaldewaij, Anne. 1990. <i>Programming: The Derivation of Algorithms</i>. New York: PrenticeHall.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0060"></a>Knuth, Donald E. 1997a. <i>Fundamental Algorithms</i>. Volume 1 of The Art of Computer Programming. 3rd edition. Reading, MA: Addison-Wesley.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0061"></a>Knuth, Donald E. 1997b. <i>Seminumerical Algorithms</i>. Volume 2 of The Art of Computer Programming. 3rd edition. Reading, MA: Addison-Wesley.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0062"></a>Konopasek, Milos, and Sundaresan Jayaraman. 1984. <i>The TK!Solver Book: A Guide to Problem-Solving in Science, Engineering, Business, and Education</i><i>.</i> Berkeley, CA: Osborne/McGraw-Hill.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0063"></a>Kowalski, Robert. 1973. Predicate logic as a programming language. Technical report 70, Department of Computational Logic, School of Artificial Intelligence, University of Edinburgh.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0064"></a>Kowalski, Robert. 1979. <i>Logic for Problem Solving</i><i>.</i> New York: North-Holland.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0065"></a>Lamport, Leslie. 1978. Time, clocks, and the ordering of events in a distributed system. <i>Communications of the ACM</i> 21(7):558–565.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0066"></a>Lampson, Butler, J. J. Horning, R. London, J. G. Mitchell, and G. K. Popek. 1981. Report on the programming language Euclid. Technical report, Computer Systems Research Group, University of Toronto.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0067"></a>Landin, Peter. 1965. A correspondence between Algol 60 and Church's lambda notation: Part I. <i>Communications of the ACM</i> 8(2):89–101.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0068"></a>Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage collector based on the lifetimes of objects. <i>Communications of the ACM</i> 26(6):419–429.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0069"></a>Liskov, Barbara H., and Stephen N. Zilles. 1975. Specification techniques for data abstractions. <i>IEEE Transactions on Software Engineering</i> 1(1):7–19.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0070"></a>McAllester, David Allen. 1978. A three-valued truth-maintenance system. Memo 473, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0071"></a>McAllester, David Allen. 1980. An outlook on truth maintenance. Memo 551, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0072"></a>McCarthy, John. 1967. A basis for a mathematical theory of computation. In <i>Computer Programing and Formal Systems</i>, edited by P. Braffort and D. Hirschberg. North-Holland, pp. 33–70.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0073"></a>McDermott, Drew, and Gerald Jay Sussman. 1972. Conniver reference manual. Memo 259, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0074"></a>Miller, Gary L. 1976. Riemann's Hypothesis and tests for primality. <i>Journal of Computer and System Sciences</i> 13(3):300–317.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0075"></a>Miller, James S., and Guillermo J. Rozas. 1994. Garbage collection is fast, but a stack is faster. Memo 1462, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0076"></a>Moon, David. 1978. MacLisp reference manual, Version 0. Technical report, MIT Laboratory for Computer Science.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0077"></a>Morris, J. H., Eric Schmidt, and Philip Wadler. 1980. Experience with an applicative string processing language. In <i>Proceedings of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of Programming Languages</i><i>.</i></li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0078"></a>Phillips, Hubert. 1934. <i>The Sphinx Problem Book</i>. London: Faber and Faber.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0079"></a>Phillips, Hubert. 1961. <i>My Best Puzzles in Logic and Reasoning</i>. New York: Dover Publications.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0080"></a>Rabin, Michael O. 1980. Probabilistic algorithm for testing primality. <i>Journal of Number Theory</i> 12:128–138.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0081"></a>Raymond, Eric. 1996. <i>The New Hacker's Dictionary</i><i>.</i> 3rd edition. Cambridge, MA: MIT Press.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0082"></a>Raynal, Michel. 1986. <i>Algorithms for Mutual Exclusion</i><i>.</i> Cambridge, MA: MIT Press.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0083"></a>Rees, Jonathan A., and Norman I. Adams IV. 1982. T: A dialect of Lisp or, lambda: The ultimate software tool. In <i>Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming</i><i>,</i> pp. 114–122.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0084"></a>Rivest, Ronald L., Adi Shamir, and Leonard M. Adleman. 1978. A method for obtaining digital signatures and public-key cryptosystems. <i>Communications of the ACM</i><i>,</i> 21(2):120–126.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0085"></a>Robinson, J. A. 1965. A machine-oriented logic based on the resolution principle. <i>Journal of the ACM</i> 12(1):23.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0086"></a>Robinson, J. A. 1983. Logic programming—Past, present, and future. <i>New Generation Computing</i> 1:107–124.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0087"></a>Spafford, Eugene H. 1989. The Internet Worm: Crisis and aftermath. <i>Communications of the ACM</i> 32(6):678–688.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0088"></a>Steele, Guy Lewis, Jr. 1977. Debunking the “expensive procedure call” myth. In <i>Proceedings of the National Conference of the ACM</i><i>,</i> pp. 153–162.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0089"></a>Steele, Guy Lewis, Jr., and Gerald Jay Sussman. 1975. Scheme: An interpreter for the extended lambda calculus. Memo 349, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0090"></a>Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R. Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow. 1983. <i>The Hacker's Dictionary</i><i>.</i> New York: Harper &amp; Row.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0091"></a>Stoy, Joseph E. 1977. <i>Denotational Semantics</i><i>.</i> Cambridge, MA: MIT Press.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0092"></a>Sussman, Gerald Jay, and Richard M. Stallman. 1975. Heuristic techniques in computeraided circuit analysis. <i>IEEE Transactions on Circuits and Systems</i> CAS-22(11):857–865.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0093"></a>Sussman, Gerald Jay, and Guy Lewis Steele Jr. 1980. Constraints—A language for expressing almost-hierarchical descriptions. <i>AI Journal</i> 14:1–39.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0094"></a>Sussman, Gerald Jay, and Jack Wisdom. 1992. Chaotic evolution of the solar system. <i>Science</i> 257:256–262.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0095"></a>Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak. 1971. Microplanner reference manual. Memo 203A, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0096"></a>Sutherland, Ivan E. 1963. SKETCHPAD: A man-machine graphical communication system. Technical report 296, MIT Lincoln Laboratory.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0097"></a>Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978. Data type specification: Parameterization and the power of specification techniques. In <i>Conference Record of the Tenth Annual ACM Symposium on Theory of Computing</i>, pp. 119–132.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0098"></a>Turner, David. 1981. The future of applicative languages. In <i>Proceedings of the 3rd European Conference on Informatics</i>, Lecture Notes in Computer Science, volume 123. New York: Springer-Verlag, pp. 334–348.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0099"></a>Wand, Mitchell. 1980. Continuation-based program transformation strategies. <i>Journal of the ACM</i> 27(1):164–180.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0100"></a>Waters, Richard C. 1979. A method for analyzing loop programs. <i>IEEE Transactions on Software Engineering</i> 5(3):237–247.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0101"></a>Winston, Patrick. 1992. <i>Artificial Intelligence</i>. 3rd edition. Reading, MA: Addison-Wesley.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0102"></a>Zabih, Ramin, David McAllester, and David Chapman. 1987. Non-deterministic Lisp with dependency-directed backtracking. <i>AAAI-87</i>, pp. 59–64.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0103"></a>Zippel, Richard. 1979. Probabilistic algorithms for sparse polynomials. Ph.D. dissertation, Department of Electrical Engineering and Computer Science, MIT.</li>
<li class="bibliographyEntry"><a id="c444_b1-bib-0104"></a>Zippel, Richard. 1993. <i>Effective Polynomial Computation</i><i>.</i> Boston, MA: Kluwer Academic Publishers.</li>
</ol>
</section>
</section>
</body><body epub:type="backmatter">
<section epub:type="index" role="doc-index">
<header>
<h1><a id="c555_b2-title-0001"></a><span class="chapterTitle">Index</span></h1>
</header>
<section>
<p class="paraaftertitle"><a id="c555_b2-para-0001"></a>Page numbers for JavaScript declarations are in <i>italics</i>.</p>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-para-0002"></a>Page numbers followed by <i>n</i> indicate footnotes.</li>
<li><a id="c555_b2-para-0003"></a><span class="KeyTerm1">"</span> (double quote), 124, 125 (ex. 2.55)</li>
<li><a id="c555_b2-para-0004"></a><span class="KeyTerm1">'</span> (single quote), 126 (ex. 2.55)</li>
<li><a id="c555_b2-para-0005"></a><span class="KeyTerm1">ˋ</span> (back quote), 546</li>
<li><a id="c555_b2-para-0006"></a><span class="KeyTerm1">+</span></li>
<li><a id="c555_b2-para-0007"></a>as numeric addition operator, 4</li>
<li><a id="c555_b2-para-0008"></a>as string concatenation operator, 75</li>
<li><a id="c555_b2-para-0009"></a><span class="KeyTerm1">-</span></li>
<li><a id="c555_b2-para-0010"></a>as numeric negation operator, 15</li>
<li><a id="c555_b2-para-0011"></a>as numeric subtraction operator, 5</li>
<li><a id="c555_b2-para-0012"></a><span class="KeyTerm1">*</span> (multiplication operator), 4</li>
<li><a id="c555_b2-para-0013"></a><span class="KeyTerm1">/</span> (division operator), 4</li>
<li><a id="c555_b2-para-0014"></a><span class="KeyTerm1">%</span> (remainder operator), 39</li>
<li><a id="c555_b2-para-0015"></a><span class="KeyTerm1">&amp;&amp;</span> (logical conjunction), 15</li>
<li><a id="c555_b2-para-0016"></a>as derived component, 336 (ex. 4.4)</li>
<li><a id="c555_b2-para-0017"></a>evaluation of, 15</li>
<li><a id="c555_b2-para-0018"></a>implementing in metacircular evaluator, 336 (ex. 4.4)</li>
<li><a id="c555_b2-para-0019"></a>parsing of, 336 (ex. 4.4)</li>
<li><a id="c555_b2-para-0020"></a>why a syntactic form, 15</li>
<li><a id="c555_b2-para-0021"></a><span class="KeyTerm1">||</span> (logical disjunction), 15</li>
<li><a id="c555_b2-para-0022"></a>as derived component, 336 (ex. 4.4)</li>
<li><a id="c555_b2-para-0023"></a>evaluation of, 15</li>
<li><a id="c555_b2-para-0024"></a>implementing in metacircular evaluator, 336 (ex. 4.4)</li>
<li><a id="c555_b2-para-0025"></a>parsing of, 336 (ex. 4.4)</li>
<li><a id="c555_b2-para-0026"></a>why a syntactic form, 15</li>
<li><a id="c555_b2-para-0027"></a><span class="KeyTerm1">? :</span>, 14, <i>see also</i> conditional expression</li>
<li><a id="c555_b2-para-0028"></a><span class="KeyTerm1">!</span> (logical negation operator), 15</li>
<li><a id="c555_b2-para-0029"></a><span class="KeyTerm1">!==</span></li>
<li><a id="c555_b2-para-0030"></a>as numeric comparison operator, 15</li>
<li><a id="c555_b2-para-0031"></a>as string comparison operator, 124</li>
<li><a id="c555_b2-para-0032"></a><span class="KeyTerm1">=</span>, 192, <i>see also</i> assignment</li>
<li><a id="c555_b2-para-0033"></a><span class="KeyTerm1">===</span></li>
<li><a id="c555_b2-para-0034"></a>as equality of pointers, 228, 489</li>
<li><a id="c555_b2-para-0035"></a>as general comparison operator, 228</li>
<li><a id="c555_b2-para-0036"></a>as numeric equality operator, 15, 490<i>n</i></li>
<li><a id="c555_b2-para-0037"></a>as string comparison operator, 124, 490</li>
<li><a id="c555_b2-para-0038"></a><span class="KeyTerm1">&gt;</span> (numeric comparison operator), 15</li>
<li><a id="c555_b2-para-0039"></a><span class="KeyTerm1">&gt;=</span> (numeric comparison operator), 14</li>
<li><a id="c555_b2-para-0040"></a><span class="KeyTerm1">&lt;</span> (numeric comparison operator), 15</li>
<li><a id="c555_b2-para-0041"></a><span class="KeyTerm1">&lt;=</span> (numeric comparison operator), 15</li>
<li><a id="c555_b2-para-0042"></a><span class="KeyTerm1">=&gt;</span>, 54, <i>see also</i> lambda expression</li>
<li><a id="c555_b2-para-0043"></a>↦notation for mathematical function, 61<i>n</i></li>
<li><a id="c555_b2-para-0044"></a><span class="KeyTerm1">[ , ]</span> (box notation for pairs), 86</li>
<li><a id="c555_b2-para-0045"></a><span class="KeyTerm1">;</span>, <i>see</i> semicolon</li>
<li><a id="c555_b2-para-0046"></a><span class="KeyTerm1">…</span> (rest parameter and spread syntax), 276</li>
<li><a id="c555_b2-para-0047"></a>$, pattern variables starting with, 403</li>
<li><a id="c555_b2-para-0048"></a><i>//</i> (for comments in programs), 108<i>n</i></li>
<li><a id="c555_b2-para-0049"></a><i>θ</i>(<i>f</i> (<i>n</i>)) (theta of <i>f</i> (<i>n</i>)), 37</li>
<li><a id="c555_b2-para-0050"></a>λ calculus (lambda calculus), 55<i>n</i></li>
<li><a id="c555_b2-para-0051"></a><i>π</i>, <i>see</i> pi</li>
<li><a id="c555_b2-para-0052"></a>Σ (sigma) notation, 50</li></ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-0001"></a><span class="KeyTerm1">abs</span>, <i>14</i></li>
<li><a id="c555_b2-li-0002"></a>absolute value, 13</li>
<li><a id="c555_b2-li-0003"></a>abstract data, 72, <i>see also</i> data abstraction</li>
<li><a id="c555_b2-li-0004"></a>abstraction, <i>see also</i> data abstraction; higher-order functions; means of abstraction<ul class="none">
<li><a id="c555_b2-li-0005"></a>common pattern and, 50</li>
<li><a id="c555_b2-li-0006"></a>functional, 22</li>
<li><a id="c555_b2-li-0007"></a>metalinguistic, 318</li>
<li><a id="c555_b2-li-0008"></a>in register-machine design, 456–457</li>
<li><a id="c555_b2-li-0009"></a>of search in nondeterministic programming, 378</li>
</ul></li>
<li><a id="c555_b2-li-0010"></a>abstraction barriers, 71, 76–78, 147<ul class="none">
<li><a id="c555_b2-li-0011"></a>in complex-number system, 148</li>
<li><a id="c555_b2-li-0012"></a>in generic arithmetic system, 164</li>
<li><a id="c555_b2-li-0013"></a>in query language, 437</li>
<li><a id="c555_b2-li-0014"></a>in representing JavaScript syntax, 329</li>
</ul></li>
<li><a id="c555_b2-li-0015"></a>abstract models for data, 78<i>n</i></li>
<li><a id="c555_b2-li-0016"></a>abstract syntax<ul class="none">
<li><a id="c555_b2-li-0017"></a>in metacircular evaluator, 322</li>
<li><a id="c555_b2-li-0018"></a>in query interpreter, 425</li>
</ul></li>
<li><a id="c555_b2-li-0019"></a><span class="KeyTerm1">accelerated_sequence</span>, <i>297</i></li>
<li><a id="c555_b2-li-0020"></a><span class="KeyTerm1">accumulate</span>, 53 (ex. 1.32), <i>100</i>
<ul class="none">
<li><a id="c555_b2-li-0021"></a>same as <span class="KeyTerm1">fold_right</span>, 105 (ex. 2.38)</li>
</ul></li>
<li><a id="c555_b2-li-0022"></a><span class="KeyTerm1">accumulate_n</span>, 104 (ex. 2.36)</li>
<li><a id="c555_b2-li-0023"></a>accumulator, 100, 196 (ex. 3.1)</li>
<li><a id="c555_b2-li-0024"></a>Ackermann's function, 31 (ex. 1.10)</li>
<li><a id="c555_b2-li-0025"></a>acquire a mutex, 276</li>
<li><a id="c555_b2-li-0026"></a>actions, in register machine, 454–455</li>
<li><a id="c555_b2-li-0027"></a><span class="KeyTerm1">actual_value</span>, <i>364</i></li>
<li><a id="c555_b2-li-0028"></a>Ada, 411 (ex. 4.61)</li>
<li><a id="c555_b2-li-0029"></a>Adams, Norman I., IV, 356<i>n</i></li>
<li><a id="c555_b2-li-0030"></a><span class="KeyTerm1">add</span> (generic), <i>165</i>
<ul class="none">
<li><a id="c555_b2-li-0031"></a>used for polynomial coefficients, 179, 180</li>
</ul></li>
<li><a id="c555_b2-li-0032"></a><span class="KeyTerm1">add_action</span>, 244, <i>247</i></li>
<li><a id="c555_b2-li-0033"></a><span class="KeyTerm1">add_complex</span>, <i>150</i></li>
<li><a id="c555_b2-li-0034"></a><span class="KeyTerm1">add_complex_to_javascript_num</span>, <i>169</i></li>
<li><a id="c555_b2-li-0035"></a><span class="KeyTerm1">addend</span>, <i>128</i></li>
<li><a id="c555_b2-li-0036"></a><span class="KeyTerm1">adder</span> (primitive constraint), <i>256</i></li>
<li><a id="c555_b2-li-0037"></a>adder<ul class="none">
<li><a id="c555_b2-li-0038"></a>full, 243</li>
<li><a id="c555_b2-li-0039"></a>half, 242</li>
<li><a id="c555_b2-li-0040"></a>ripple-carry, 245 (ex. 3.30)</li>
</ul></li>
<li><a id="c555_b2-li-0041"></a><span class="KeyTerm1">add_interval</span>, <i>81</i></li>
<li><a id="c555_b2-li-0042"></a>additivity, 72, 147, 156–162, 166</li>
<li><a id="c555_b2-li-0043"></a><span class="KeyTerm1">add_lists</span>, <i>371</i></li>
<li><a id="c555_b2-li-0044"></a><span class="KeyTerm1">add_poly</span>, <i>178</i></li>
<li><a id="c555_b2-li-0045"></a><span class="KeyTerm1">add_rat</span>, <i>73</i></li>
<li><a id="c555_b2-li-0046"></a>address, 488</li>
<li><a id="c555_b2-li-0047"></a>address arithmetic, 488</li>
<li><a id="c555_b2-li-0048"></a><span class="KeyTerm1">add_rule_or_assertion</span>, <i>434</i></li>
<li><a id="c555_b2-li-0049"></a><span class="KeyTerm1">add_streams</span>, <i>290</i></li>
<li><a id="c555_b2-li-0050"></a><span class="KeyTerm1">add_terms</span>, <i>179</i></li>
<li><a id="c555_b2-li-0051"></a><span class="KeyTerm1">add_to_agenda</span>, 248, <i>251</i></li>
<li><a id="c555_b2-li-0052"></a><span class="KeyTerm1">add_vect</span>, 118 (ex. 2.46)</li>
<li><a id="c555_b2-li-0053"></a><span class="KeyTerm1">adjoin_arg</span>, <i>505n</i></li>
<li><a id="c555_b2-li-0054"></a>adjoining to a list with <span class="KeyTerm1">pair</span>, 88</li>
<li><a id="c555_b2-li-0055"></a><span class="KeyTerm1">adjoin_set</span>, 131<ul class="none">
<li><a id="c555_b2-li-0056"></a>binary-tree representation, <i>136</i></li>
<li><a id="c555_b2-li-0057"></a>ordered-list representation, 135 (ex. 2.61)</li>
<li><a id="c555_b2-li-0058"></a>unordered-list representation, <i>132</i></li>
<li><a id="c555_b2-li-0059"></a>for weighted sets, <i>145</i></li>
</ul></li>
<li><a id="c555_b2-li-0060"></a><span class="KeyTerm1">adjoin_term</span>, 179, <i>182</i></li>
</ul>
</section>
<section>
<h2>Adleman, Leonard, 46<i>n</i></h2>
<ul class="none">
<li><a id="c555_b2-li-0061"></a>administrative assistant, importance of, 403</li>
<li><a id="c555_b2-li-0062"></a><span class="KeyTerm1">advance_pc</span>, <i>479</i></li>
<li><a id="c555_b2-li-0063"></a><span class="KeyTerm1">after_delay</span>, 244, <i>248</i></li>
<li><a id="c555_b2-li-0064"></a>agenda, <i>see</i> digital-circuit simulation A’h-mose, 40<i>n</i></li>
<li><a id="c555_b2-li-0065"></a>algebra, symbolic, <i>see</i> symbolic algebra</li>
<li><a id="c555_b2-li-0066"></a>algebraic expression, 176<ul class="none">
<li><a id="c555_b2-li-0067"></a>differentiating, 126–131</li>
<li><a id="c555_b2-li-0068"></a>representing, 128–131</li>
<li><a id="c555_b2-li-0069"></a>simplifying, 129–130</li>
</ul></li>
<li><a id="c555_b2-li-0070"></a>algebraic specification for data, 79<i>n</i></li>
<li><a id="c555_b2-li-0071"></a>Algol<ul class="none">
<li><a id="c555_b2-li-0072"></a>block structure, 26</li>
<li><a id="c555_b2-li-0073"></a>call-by-name argument passing, 286<i>n</i>, 363<i>n</i></li>
<li><a id="c555_b2-li-0074"></a>thunks, 286<i>n</i>, 363<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0075"></a>algorithm<ul class="none">
<li><a id="c555_b2-li-0076"></a>optimal, 104<i>n</i></li>
<li><a id="c555_b2-li-0077"></a>probabilistic, 45–46, 188<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0078"></a>aliasing, 204<i>n</i></li>
<li><a id="c555_b2-li-0079"></a>Al-Karaji, 36<i>n</i></li>
<li><a id="c555_b2-li-0080"></a>Allen, John, 494<i>n</i></li>
<li><a id="c555_b2-li-0081"></a><span class="KeyTerm1">all_regs</span> (compiler), <i>542n</i></li>
<li><a id="c555_b2-li-0082"></a>alternative<ul class="none">
<li><a id="c555_b2-li-0083"></a>of conditional expression, 14</li>
<li><a id="c555_b2-li-0084"></a>of conditional statement, 57</li>
</ul></li>
<li><a id="c555_b2-li-0085"></a><span class="KeyTerm1">always_true</span>, <i>428</i></li>
<li><a id="c555_b2-li-0086"></a><span class="KeyTerm1">amb</span>, <i>374</i></li>
<li><a id="c555_b2-li-0087"></a><span class="KeyTerm1">amb</span> evaluator, <i>see</i> nondeterministic evaluator</li>
<li><a id="c555_b2-li-0088"></a><span class="KeyTerm1">ambeval</span>, <i>388</i></li>
<li><a id="c555_b2-li-0089"></a>analog computer, 306 (fig. 3.34)</li>
<li><a id="c555_b2-li-0090"></a><span class="KeyTerm1">analyze</span>
<ul class="none">
<li><a id="c555_b2-li-0091"></a>metacircular, <i>356</i></li>
<li><a id="c555_b2-li-0092"></a>nondeterministic, 387</li>
</ul></li>
<li><a id="c555_b2-li-0093"></a><span class="KeyTerm1">analyze_…</span>
<ul class="none">
<li><a id="c555_b2-li-0094"></a>metacircular, 356–359, 360 (ex. 4.21)</li>
<li><a id="c555_b2-li-0095"></a>nondeterministic, 389–392</li>
</ul></li>
<li><a id="c555_b2-li-0096"></a><span class="KeyTerm1">analyze_amb</span>, <i>394</i></li>
<li><a id="c555_b2-li-0097"></a>analyzing evaluator, 355–360<ul class="none">
<li><a id="c555_b2-li-0098"></a>as basis for nondeterministic evaluator, 386</li>
</ul></li>
<li><a id="c555_b2-li-0099"></a><span class="KeyTerm1">and</span> (query language), 405<ul class="none">
<li><a id="c555_b2-li-0100"></a>evaluation of, 413, 426, 446 (ex. 4.73)</li>
</ul></li>
<li><a id="c555_b2-li-0101"></a>and-gate, 241<ul class="none">
<li><a id="c555_b2-li-0102"></a><span class="KeyTerm1">and_gate</span>, <i>245</i></li>
</ul></li>
<li><a id="c555_b2-li-0103"></a><span class="KeyTerm1">an_element_of</span>, <i>375</i></li>
<li><a id="c555_b2-li-0104"></a><span class="KeyTerm1">angle</span>
<ul class="none">
<li><a id="c555_b2-li-0105"></a>data-directed, <i>160</i></li>
<li><a id="c555_b2-li-0106"></a>polar representation, <i>152</i></li>
<li><a id="c555_b2-li-0107"></a>rectangular representation, <i>151</i></li>
<li><a id="c555_b2-li-0108"></a>with tagged data, <i>154</i></li>
</ul></li>
<li><a id="c555_b2-li-0109"></a><span class="KeyTerm1">angle_polar</span>, <i>154</i></li>
<li><a id="c555_b2-li-0110"></a><span class="KeyTerm1">angle_rectangular</span>, <i>153</i></li>
<li><a id="c555_b2-li-0111"></a><span class="KeyTerm1">an_integer_starting_from</span>, <i>375</i></li>
<li><a id="c555_b2-li-0112"></a>Appel, Andrew W., 541<i>n</i></li>
<li><a id="c555_b2-li-0113"></a><span class="KeyTerm1">append</span>, <i>88</i>, <i>225</i> (ex. 3.12)<ul class="none">
<li><a id="c555_b2-li-0114"></a>as accumulation, 103 (ex. 2.33)</li>
<li><a id="c555_b2-li-0115"></a><span class="KeyTerm1">append_mutator</span> vs., 225 (ex. 3.12)</li>
<li><a id="c555_b2-li-0116"></a>as register machine, 492 (ex. 5.21)</li>
<li><a id="c555_b2-li-0117"></a>“what is” (rules) vs. “how to” (function), 399–400</li>
</ul></li>
<li><a id="c555_b2-li-0118"></a><span class="KeyTerm1">append_instruction_sequences</span>, 524, <i>544</i></li>
<li><a id="c555_b2-li-0119"></a><span class="KeyTerm1">append_mutator</span>, <i>225</i> (ex. 3.12)<ul class="none">
<li><a id="c555_b2-li-0120"></a>as register machine, 492 (ex. 5.21)</li>
</ul></li>
<li><a id="c555_b2-li-0121"></a><span class="KeyTerm1">append_to_form</span> (rules), <i>410</i></li>
<li><a id="c555_b2-li-0122"></a>applicative-order evaluation, 13<ul class="none">
<li><a id="c555_b2-li-0123"></a>in JavaScript, 13</li>
<li><a id="c555_b2-li-0124"></a>normal order vs., 17 (ex. 1.5), 43 (ex. 1.20), 361–362</li>
</ul></li>
<li><a id="c555_b2-li-0125"></a><span class="KeyTerm1">apply</span> (lazy), <i>364</i></li>
<li><a id="c555_b2-li-0126"></a><span class="KeyTerm1">apply</span> (metacircular), <i>324</i>
<ul class="none">
<li><a id="c555_b2-li-0127"></a>tail recursion and, 324<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0128"></a><span class="KeyTerm1">apply</span> (primitive method), 346<i>n</i></li>
<li><a id="c555_b2-li-0129"></a><span class="KeyTerm1">apply_a_rule</span>, <i>430</i></li>
<li><a id="c555_b2-li-0130"></a><span class="KeyTerm1">apply_dispatch</span>, <i>507</i>
<ul class="none">
<li><a id="c555_b2-li-0131"></a>modified for compiled code, <i>558</i></li>
</ul></li>
<li><a id="c555_b2-li-0132"></a><span class="KeyTerm1">apply_generic</span>, <i>160</i>
<ul class="none">
<li><a id="c555_b2-li-0133"></a>with coercion, <i>171</i>, 174 (ex. 2.81)</li>
<li><a id="c555_b2-li-0134"></a>with coercion by raising, 175 (ex. 2.84)</li>
<li><a id="c555_b2-li-0135"></a>with coercion of multiple arguments, 175 (ex. 2.82)</li>
<li><a id="c555_b2-li-0136"></a>with coercion to simplify, 176 (ex. 2.85)</li>
<li><a id="c555_b2-li-0137"></a>with message passing, <i>163</i></li>
<li><a id="c555_b2-li-0138"></a>with tower of types, 173</li>
</ul></li>
<li><a id="c555_b2-li-0139"></a><span class="KeyTerm1">apply_in_underlying_javascript</span>, 159<i>n</i>, <i>346n</i></li>
<li><a id="c555_b2-li-0140"></a><span class="KeyTerm1">apply_primitive_function</span>, 324, 340, <i>346</i></li>
<li><a id="c555_b2-li-0141"></a><span class="KeyTerm1">apply_rules</span>, <i>430</i></li>
<li><a id="c555_b2-li-0142"></a>arbiter, 278<i>n</i></li>
<li><a id="c555_b2-li-0143"></a>arctangent, 151<i>n</i></li>
<li><a id="c555_b2-li-0144"></a><span class="KeyTerm1">arg_expressions</span>, 331</li>
<li><a id="c555_b2-li-0145"></a><span class="KeyTerm1">argl</span> register, 500</li>
<li><a id="c555_b2-li-0146"></a>argument(s), 9<ul class="none">
<li><a id="c555_b2-li-0147"></a>arbitrary number of, 276</li>
<li><a id="c555_b2-li-0148"></a>delayed, 306</li>
</ul></li>
<li><a id="c555_b2-li-0149"></a>argument passing, <i>see</i> call-by-name argument passing; call-by-need argument passing</li>
<li><a id="c555_b2-li-0150"></a>Aristotle's <i>De caelo</i> (Buridan's commentary on), 278<i>n</i></li>
<li><a id="c555_b2-li-0151"></a>arithmetic<ul class="none">
<li><a id="c555_b2-li-0152"></a>address arithmetic, 488</li>
<li><a id="c555_b2-li-0153"></a>generic, 163, <i>see also</i> generic arithmetic operations</li>
<li><a id="c555_b2-li-0154"></a>on complex numbers, 148</li>
<li><a id="c555_b2-li-0155"></a>on intervals, 81–84</li>
<li><a id="c555_b2-li-0156"></a>on polynomials, <i>see</i> polynomial arithmetic</li>
<li><a id="c555_b2-li-0157"></a>on power series, 294 (ex. 3.60), 295 (ex. 3.62)</li>
<li><a id="c555_b2-li-0158"></a>on rational numbers, 72–76</li>
<li><a id="c555_b2-li-0159"></a>operators for, 4</li>
</ul></li>
<li><a id="c555_b2-li-0160"></a>array, <i>see</i> vector (data structure)</li>
<li><a id="c555_b2-li-0161"></a>arrow function, <i>see</i> lambda expression</li>
<li><a id="c555_b2-li-0162"></a><span class="KeyTerm1">articles</span>, <i>381</i></li>
<li><a id="c555_b2-li-0163"></a>ASCII code, 140</li>
<li><a id="c555_b2-li-0164"></a><span class="KeyTerm1">assemble</span>, <i>474</i>, <i>475n</i></li>
<li><a id="c555_b2-li-0165"></a>assembler, 470, 474–477</li>
<li><a id="c555_b2-li-0166"></a><span class="KeyTerm1">assert</span> (query interpreter), 419</li>
<li><a id="c555_b2-li-0167"></a>assertion, 401<ul class="none">
<li><a id="c555_b2-li-0168"></a>implicit, 407</li>
</ul></li>
<li><a id="c555_b2-li-0169"></a><span class="KeyTerm1">assertion_body</span>, <i>443</i></li>
<li><a id="c555_b2-li-0170"></a><span class="KeyTerm1">assign</span> (in register machine), 453<ul class="none">
<li><a id="c555_b2-li-0171"></a>instruction constructor, <i>478</i></li>
<li><a id="c555_b2-li-0172"></a>simulating, 478</li>
<li><a id="c555_b2-li-0173"></a>storing label in register, 459</li>
</ul></li>
<li><a id="c555_b2-li-0174"></a>assignment, 190–206<ul class="none">
<li><a id="c555_b2-li-0175"></a>assignment expression, 192</li>
<li><a id="c555_b2-li-0176"></a>assignment operation, 190</li>
<li><a id="c555_b2-li-0177"></a>benefits of, 197–200</li>
<li><a id="c555_b2-li-0178"></a>bugs associated with, 204<i>n</i>, 205</li>
<li><a id="c555_b2-li-0179"></a>constant/variable declaration vs., 192<i>n</i></li>
<li><a id="c555_b2-li-0180"></a>costs of, 200–206</li>
<li><a id="c555_b2-li-0181"></a>equality test vs., 192<i>n</i></li>
<li><a id="c555_b2-li-0182"></a>evaluation of, 210</li>
<li><a id="c555_b2-li-0183"></a>parsing of, 333</li>
<li><a id="c555_b2-li-0184"></a>value of, 192<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0185"></a><span class="KeyTerm1">assignment_symbol</span>, <i>333</i></li>
<li><a id="c555_b2-li-0186"></a><span class="KeyTerm1">assignment_value_expression</span>, 333</li>
<li><a id="c555_b2-li-0187"></a><span class="KeyTerm1">assign_reg_name</span>, <i>478</i></li>
<li><a id="c555_b2-li-0188"></a><span class="KeyTerm1">assign_symbol_value</span>, 341, <i>342</i></li>
<li><a id="c555_b2-li-0189"></a><span class="KeyTerm1">assign_value_exp</span>, <i>478</i></li>
<li><a id="c555_b2-li-0190"></a><span class="KeyTerm1">assoc</span>, <i>236</i></li>
<li><a id="c555_b2-li-0191"></a>associativity<ul class="none">
<li><a id="c555_b2-li-0192"></a>of conditional expression, 14</li>
<li><a id="c555_b2-li-0193"></a>of operators, 5</li>
</ul></li>
<li><a id="c555_b2-li-0194"></a>atomic operations supported in hardware, 278<i>n</i></li>
<li><a id="c555_b2-li-0195"></a>atomic requirement for test_and_set, 277</li>
<li><a id="c555_b2-li-0196"></a><span class="KeyTerm1">attach_tag</span>, <i>152</i>
<ul class="none">
<li><a id="c555_b2-li-0197"></a>using JavaScript data types, 168 (ex. 2.78)</li>
</ul></li>
<li><a id="c555_b2-li-0198"></a><span class="KeyTerm1">augend</span>, <i>128</i></li>
<li><a id="c555_b2-li-0199"></a>automagically, 376</li>
<li><a id="c555_b2-li-0200"></a>automatic search, 373, <i>see also</i> search history of, 376<i>n</i></li>
<li><a id="c555_b2-li-0201"></a>automatic storage allocation, 487</li>
<li><a id="c555_b2-li-0202"></a><span class="KeyTerm1">average</span>, <i>19</i></li>
<li><a id="c555_b2-li-0203"></a><span class="KeyTerm1">average_damp</span>, <i>63</i></li>
<li><a id="c555_b2-li-0204"></a>average damping, 61</li>
<li><a id="c555_b2-li-0205"></a><span class="KeyTerm1">averager</span> (constraint), 261 (ex. 3.33)</li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-0206"></a>back quotes, 546</li>
<li><a id="c555_b2-li-0207"></a>backtracking, 376, <i>see also</i> nondeterministic computing</li>
<li><a id="c555_b2-li-0208"></a>Backus, John, 314<i>n</i></li>
<li><a id="c555_b2-li-0209"></a>Baker, Henry G., Jr., 494<i>n</i></li>
<li><a id="c555_b2-li-0210"></a>balanced binary tree, 137, <i>see also</i> binary tree</li>
<li><a id="c555_b2-li-0211"></a>balanced mobile, 96 (ex. 2.29)</li>
<li><a id="c555_b2-li-0212"></a>bank account, 190, 220 (ex. 3.11)<ul class="none">
<li><a id="c555_b2-li-0213"></a>exchanging balances, 272</li>
<li><a id="c555_b2-li-0214"></a>joint, 203, 205 (ex. 3.7)</li>
<li><a id="c555_b2-li-0215"></a>joint, modeled with streams, 315 (fig. 3.38)</li>
<li><a id="c555_b2-li-0216"></a>joint, with concurrent access, 264</li>
<li><a id="c555_b2-li-0217"></a>password-protected, 196 (ex. 3.3)</li>
<li><a id="c555_b2-li-0218"></a>serialized, 269</li>
<li><a id="c555_b2-li-0219"></a>stream model, 313</li>
<li><a id="c555_b2-li-0220"></a>transferring money, 274 (ex. 3.44)</li>
</ul></li>
<li><a id="c555_b2-li-0221"></a>barrier synchronization, 279<i>n</i></li>
<li><a id="c555_b2-li-0222"></a>Barth, John, 317</li>
<li><a id="c555_b2-li-0223"></a>Batali, John Dean, 499<i>n</i></li>
<li><a id="c555_b2-li-0224"></a><span class="KeyTerm1">below</span>, 112, 122 (ex. 2.51)</li>
<li><a id="c555_b2-li-0225"></a>Bertrand's Hypothesis, 292<i>n</i></li>
<li><a id="c555_b2-li-0226"></a><span class="KeyTerm1">beside</span>, 112, <i>122</i></li>
<li><a id="c555_b2-li-0227"></a>Bhaskara, 36<i>n</i></li>
<li><a id="c555_b2-li-0228"></a>bignum, 490</li>
<li><a id="c555_b2-li-0229"></a>binary numbers, addition of, <i>see</i> adder binary operator, 15</li>
<li><a id="c555_b2-li-0230"></a>binary search, 135</li>
<li><a id="c555_b2-li-0231"></a>binary tree, 135<ul class="none">
<li><a id="c555_b2-li-0232"></a>balanced, 137</li>
<li><a id="c555_b2-li-0233"></a>converting a list to a, 137 (ex. 2.64)</li>
<li><a id="c555_b2-li-0234"></a>converting to a list, 137 (ex. 2.63)</li>
<li><a id="c555_b2-li-0235"></a>for Huffman encoding, 141</li>
<li><a id="c555_b2-li-0236"></a>represented with lists, 136</li>
<li><a id="c555_b2-li-0237"></a>set represented as, 135–138</li>
<li><a id="c555_b2-li-0238"></a>table structured as, 240 (ex. 3.26)</li>
</ul></li>
<li><a id="c555_b2-li-0239"></a>bind, 23</li>
<li><a id="c555_b2-li-0240"></a>binding, 206<ul class="none">
<li><a id="c555_b2-li-0241"></a>deep, 343<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0242"></a><span class="KeyTerm1">binding_in_frame</span>, <i>444</i></li>
<li><a id="c555_b2-li-0243"></a><span class="KeyTerm1">binding_value</span>, <i>444</i></li>
<li><a id="c555_b2-li-0244"></a><span class="KeyTerm1">binding_variable</span>, <i>444</i></li>
<li><a id="c555_b2-li-0245"></a>binomial coefficients, 36<i>n</i></li>
<li><a id="c555_b2-li-0246"></a>black box, 22</li>
<li><a id="c555_b2-li-0247"></a>block, 25<ul class="none">
<li><a id="c555_b2-li-0248"></a>empty, 251<i>n</i></li>
<li><a id="c555_b2-li-0249"></a>parsing of, 333</li>
</ul></li>
<li><a id="c555_b2-li-0250"></a><span class="KeyTerm1">block_body</span>, 333</li>
<li><a id="c555_b2-li-0251"></a>blocked process, 277<i>n</i></li>
<li><a id="c555_b2-li-0252"></a>block structure, 25–26, 351–355<ul class="none">
<li><a id="c555_b2-li-0253"></a>in environment model, 218–222</li>
<li><a id="c555_b2-li-0254"></a>in query language, 447 (ex. 4.76)</li>
<li><a id="c555_b2-li-0255"></a>body of a function, 9</li>
</ul></li>
<li><a id="c555_b2-li-0256"></a>boolean values (true, false), 14</li>
<li><a id="c555_b2-li-0257"></a>Borning, Alan, 252<i>n</i></li>
<li><a id="c555_b2-li-0258"></a>Borodin, Alan, 104<i>n</i></li>
<li><a id="c555_b2-li-0259"></a>bound name, 23</li>
<li><a id="c555_b2-li-0260"></a>box-and-pointer notation, 84<ul class="none">
<li><a id="c555_b2-li-0261"></a>end-of-list marker, 85</li>
</ul></li>
<li><a id="c555_b2-li-0262"></a>box notation for pairs, 86</li>
<li><a id="c555_b2-li-0263"></a><span class="KeyTerm1">branch</span> (in register machine), 452<ul class="none">
<li><a id="c555_b2-li-0264"></a>instruction constructor, <i>480</i></li>
<li><a id="c555_b2-li-0265"></a>simulating, 479</li>
</ul></li>
<li><a id="c555_b2-li-0266"></a><span class="KeyTerm1">branch_dest</span>, <i>480</i></li>
<li><a id="c555_b2-li-0267"></a>branch of a tree, 7</li>
<li><a id="c555_b2-li-0268"></a><span class="KeyTerm1"><b>break</b></span> (keyword), 338 (ex. 4.7), <i>see also</i> while loop breakpoint, 486 (ex. 5.18)</li>
<li><a id="c555_b2-li-0269"></a>broken heart, 495</li>
<li><a id="c555_b2-li-0270"></a>B-tree, 137<i>n</i></li>
<li><a id="c555_b2-li-0271"></a>bug, 1<ul class="none">
<li><a id="c555_b2-li-0272"></a>capturing a free name, 24</li>
<li><a id="c555_b2-li-0273"></a>order of assignments, 205</li>
<li><a id="c555_b2-li-0274"></a>side effect with aliasing, 204<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0275"></a>bureaucracy, 419</li>
<li><a id="c555_b2-li-0276"></a>Buridan, Jean, 278<i>n</i></li>
<li><a id="c555_b2-li-0277"></a>busy-waiting, 277<i>n</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-0278"></a>C<ul class="none">
<li><a id="c555_b2-li-0279"></a>compiling JavaScript into, 564 (ex. 5.55)</li>
<li><a id="c555_b2-li-0280"></a>error handling, 561<i>n</i></li>
<li><a id="c555_b2-li-0281"></a>JavaScript interpreter written in, 564 (ex. 5.54), 564 (ex. 5.55)</li>
<li><a id="c555_b2-li-0282"></a>recursive functions in, 30</li>
</ul></li>
<li><a id="c555_b2-li-0283"></a>cache-coherence protocols, 265<i>n</i></li>
<li><a id="c555_b2-li-0284"></a> calculator, fixed points with, 61<i>n</i></li>
<li><a id="c555_b2-li-0285"></a>call-by-name argument passing, 286<i>n</i>, 363<i>n</i></li>
<li><a id="c555_b2-li-0286"></a>call-by-need argument passing, 286<i>n</i>, 363<i>n</i>
<ul class="none">
<li><a id="c555_b2-li-0287"></a>memoization and, 293<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0288"></a><span class="KeyTerm1">call_each</span>, <i>247</i></li>
<li><a id="c555_b2-li-0289"></a>camel case, 10<i>n</i></li>
<li><a id="c555_b2-li-0290"></a>canonical form, for polynomials, 184</li>
<li><a id="c555_b2-li-0291"></a>capturing a free name, 24</li>
<li><a id="c555_b2-li-0292"></a>Carmichael numbers, 45<i>n</i>, 48 (ex. 1.27)</li>
<li><a id="c555_b2-li-0293"></a>case analysis, 13, <i>see also</i> conditional expression<ul class="none">
<li><a id="c555_b2-li-0294"></a>data-directed programming vs., 323</li>
<li><a id="c555_b2-li-0295"></a>general, 14</li>
<li><a id="c555_b2-li-0296"></a>as sequence of clauses, 15</li>
</ul></li>
<li><a id="c555_b2-li-0297"></a>cell, in serializer implementation, 276</li>
<li><a id="c555_b2-li-0298"></a><span class="KeyTerm1">celsius_fahrenheit_converter</span>, <i>254</i>
<ul class="none">
<li><a id="c555_b2-li-0299"></a>expression-oriented, <i>262</i> (ex. 3.37)</li>
</ul></li>
<li><a id="c555_b2-li-0300"></a><span class="KeyTerm1">center</span>, <i>83</i></li>
<li><a id="c555_b2-li-0301"></a>Chaitin, Gregory, 197<i>n</i> </li>
<li><a id="c555_b2-li-0302"></a>Chandah-sutra, 40<i>n</i></li>
<li><a id="c555_b2-li-0303"></a>change and sameness<ul class="none">
<li><a id="c555_b2-li-0304"></a>meaning of, 202–204</li>
<li><a id="c555_b2-li-0305"></a>shared data and, 226</li>
</ul></li>
<li><a id="c555_b2-li-0306"></a>changing money, <i>see</i> counting change Chapman, David, 376<i>n</i></li>
<li><a id="c555_b2-li-0307"></a>character, ASCII encoding, 140</li>
<li><a id="c555_b2-li-0308"></a>Charniak, Eugene, 376<i>n</i></li>
<li><a id="c555_b2-li-0309"></a>Chebyshev, Pafnutii L’vovich, 292<i>n</i></li>
<li><a id="c555_b2-li-0310"></a><span class="KeyTerm1">check_an_assertion</span>, <i>428</i></li>
<li><a id="c555_b2-li-0311"></a>chess, eight-queens puzzle, 108 (ex. 2.42), 380 (ex. 4.42)</li>
<li><a id="c555_b2-li-0312"></a>chip implementation of Scheme, 499</li>
<li><a id="c555_b2-li-0313"></a>chronological backtracking, 376</li>
<li><a id="c555_b2-li-0314"></a>Church, Alonzo, 55<i>n</i>, 80 (ex. 2.6)</li>
<li><a id="c555_b2-li-0315"></a>Church numerals, 80 (ex. 2.6) Church–Turing thesis, 349<i>n</i></li>
<li><a id="c555_b2-li-0316"></a>circuit<ul class="none">
<li><a id="c555_b2-li-0317"></a>digital, <i>see</i> digital-circuit simulation</li>
<li><a id="c555_b2-li-0318"></a>modeled with streams, 303 (ex. 3.73), 308 (ex. 3.80)</li>
</ul></li>
<li><a id="c555_b2-li-0319"></a>Clark, Keith L., 422<i>n</i></li>
<li><a id="c555_b2-li-0320"></a>clause of a case analysis, 15</li>
<li><a id="c555_b2-li-0321"></a>Clinger, William, 363<i>n</i></li>
<li><a id="c555_b2-li-0322"></a>closed world assumption, 422</li>
<li><a id="c555_b2-li-0323"></a>closure, 71<ul class="none">
<li><a id="c555_b2-li-0324"></a>in abstract algebra, 85<i>n</i></li>
<li><a id="c555_b2-li-0325"></a>closure property of picture-language operations, 110, 113</li>
<li><a id="c555_b2-li-0326"></a>closure property of <span class="KeyTerm1">pair</span>, 84</li>
</ul></li>
<li><a id="c555_b2-li-0327"></a>coal, bituminous, 112<i>n</i></li>
<li><a id="c555_b2-li-0328"></a>code<ul class="none">
<li><a id="c555_b2-li-0329"></a>ASCII, 140</li>
<li><a id="c555_b2-li-0330"></a>fixed-length, 140</li>
<li><a id="c555_b2-li-0331"></a>Huffman, <i>see</i> Huffman code Morse, 140</li>
<li><a id="c555_b2-li-0332"></a>prefix, 140</li>
<li><a id="c555_b2-li-0333"></a>variable-length, 140</li>
</ul></li>
<li><a id="c555_b2-li-0334"></a>code generator, 523<ul class="none">
<li><a id="c555_b2-li-0335"></a>arguments of, 523</li>
<li><a id="c555_b2-li-0336"></a>value of, 524</li>
</ul></li>
<li><a id="c555_b2-li-0337"></a><span class="KeyTerm1">coeff</span>, 179, <i>182</i></li>
<li><a id="c555_b2-li-0338"></a>coercion, 170–176<ul class="none">
<li><a id="c555_b2-li-0339"></a>function, 170</li>
<li><a id="c555_b2-li-0340"></a>in algebraic manipulation, 184</li>
<li><a id="c555_b2-li-0341"></a>in polynomial arithmetic, 180</li>
<li><a id="c555_b2-li-0342"></a>table, 170</li>
</ul></li>
<li><a id="c555_b2-li-0343"></a>Colmerauer, Alain, 399<i>n</i></li>
<li><a id="c555_b2-li-0344"></a>combination, 4, <i>see also</i> function application; operator combination</li>
<li><a id="c555_b2-li-0345"></a>combination, means of, 3, <i>see also</i> closure</li>
<li><a id="c555_b2-li-0346"></a>comments in programs, 108<i>n</i></li>
<li><a id="c555_b2-li-0347"></a><span class="KeyTerm1">comp</span> register, 500</li>
<li><a id="c555_b2-li-0348"></a>compacting garbage collector, 494<i>n</i></li>
<li><a id="c555_b2-li-0349"></a>compilation, <i>see</i> compiler</li>
<li><a id="c555_b2-li-0350"></a><span class="KeyTerm1">compile</span>, <i>523</i></li>
<li><a id="c555_b2-li-0351"></a><span class="KeyTerm1">compile_and_go</span>, 558, <i>560</i></li>
<li><a id="c555_b2-li-0352"></a><span class="KeyTerm1">compile_and_run</span>, 563 (ex. 5.51)</li>
<li><a id="c555_b2-li-0353"></a><span class="KeyTerm1">compile_application</span>, <i>536</i></li>
<li><a id="c555_b2-li-0354"></a><span class="KeyTerm1">compile_assignment</span>, <i>529</i></li>
<li><a id="c555_b2-li-0355"></a><span class="KeyTerm1">compile_block</span>, <i>532</i></li>
<li><a id="c555_b2-li-0356"></a><span class="KeyTerm1">compile_conditional</span>, <i>530</i></li>
<li><a id="c555_b2-li-0357"></a><span class="KeyTerm1">compiled_apply</span>, <i>558</i></li>
<li><a id="c555_b2-li-0358"></a><span class="KeyTerm1">compile_declaration</span>, <i>529</i></li>
<li><a id="c555_b2-li-0359"></a><span class="KeyTerm1">compiled_function_entry</span>, <i>532n</i></li>
<li><a id="c555_b2-li-0360"></a><span class="KeyTerm1">compiled_function_env</span>, <i>532n</i></li>
<li><a id="c555_b2-li-0361"></a><span class="KeyTerm1">compile_fun_appl</span>, <i>542</i></li>
<li><a id="c555_b2-li-0362"></a><span class="KeyTerm1">compile_function_call</span>, <i>538</i></li>
<li><a id="c555_b2-li-0363"></a><span class="KeyTerm1">compile_lambda_body</span>, <i>534</i></li>
<li><a id="c555_b2-li-0364"></a><span class="KeyTerm1">compile_lambda_expression</span>, <i>533</i></li>
<li><a id="c555_b2-li-0365"></a><span class="KeyTerm1">compile_linkage</span>, <i>527</i></li>
<li><a id="c555_b2-li-0366"></a><span class="KeyTerm1">compile_literal</span>, <i>528</i></li>
<li><a id="c555_b2-li-0367"></a><span class="KeyTerm1">compile_name</span>, <i>528</i></li>
<li><a id="c555_b2-li-0368"></a>compiler, 519–521<ul class="none">
<li><a id="c555_b2-li-0369"></a>interpreter vs., 520–521, 561</li>
<li><a id="c555_b2-li-0370"></a>tail recursion, stack allocation, and garbage-collection, 541<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0371"></a><span class="KeyTerm1">compile_return_statement</span>, <i>543</i></li>
<li><a id="c555_b2-li-0372"></a>compiler for JavaScript, 521–564, <i>see also</i> code generator; compile-time environment; instruction sequence; linkage descriptor; target register<ul class="none">
<li><a id="c555_b2-li-0373"></a>analyzing evaluator vs., 521, 522</li>
<li><a id="c555_b2-li-0374"></a>assignments, 528</li>
<li><a id="c555_b2-li-0375"></a>blocks, 531</li>
<li><a id="c555_b2-li-0376"></a>code generators, <i>see</i> <span class="KeyTerm1">compile_<i>. . .</i></span></li>
<li><a id="c555_b2-li-0377"></a>combinations, 535–542</li>
<li><a id="c555_b2-li-0378"></a>conditionals, 529</li>
<li><a id="c555_b2-li-0379"></a>dead code analysis, 534 (ex. 5.34)</li>
<li><a id="c555_b2-li-0380"></a>declarations, 528</li>
<li><a id="c555_b2-li-0381"></a>efficiency, 521–522</li>
<li><a id="c555_b2-li-0382"></a>example compilation, 546–549</li>
<li><a id="c555_b2-li-0383"></a>explicit-control evaluator vs., 521–522, 526 (ex. 5.33), 560</li>
<li><a id="c555_b2-li-0384"></a>expression-syntax functions, 522</li>
<li><a id="c555_b2-li-0385"></a>function applications, 535–542</li>
<li><a id="c555_b2-li-0386"></a>interfacing to evaluator, 557–564</li>
<li><a id="c555_b2-li-0387"></a>label generation, 530<i>n</i></li>
<li><a id="c555_b2-li-0388"></a>lambda expressions, 532</li>
<li><a id="c555_b2-li-0389"></a>lexical addressing, 554–555</li>
<li><a id="c555_b2-li-0390"></a>linkage code, 527</li>
<li><a id="c555_b2-li-0391"></a>literals, 528</li>
<li><a id="c555_b2-li-0392"></a>machine-operation use, 520<i>n</i></li>
<li><a id="c555_b2-li-0393"></a>monitoring performance (stack use) of compiled code, 560, 562 (ex. 5.48), 562 (ex. 5.49)</li>
<li><a id="c555_b2-li-0394"></a>names, 528</li>
<li><a id="c555_b2-li-0395"></a>open coding of primitives, 553 (ex. 5.41)</li>
<li><a id="c555_b2-li-0396"></a>order of argument evaluation, 549 (ex. 5.39)</li>
<li><a id="c555_b2-li-0397"></a>register use, 520<i>n</i>, 521, 542<i>n</i></li>
<li><a id="c555_b2-li-0398"></a>return statements, 543</li>
<li><a id="c555_b2-li-0399"></a>running compiled code, 557–564</li>
<li><a id="c555_b2-li-0400"></a>scanning out internal declarations, 555</li>
<li><a id="c555_b2-li-0401"></a>sequences of statements, 531</li>
<li><a id="c555_b2-li-0402"></a>stack usage, 525, 526 (ex. 5.32), 553 (ex. 5.40)</li>
<li><a id="c555_b2-li-0403"></a>structure of, 522–526</li>
<li><a id="c555_b2-li-0404"></a>tail-recursive code generated by, 541</li>
</ul></li>
<li><a id="c555_b2-li-0405"></a><span class="KeyTerm1">compile_sequence</span>, <i>531</i></li>
<li><a id="c555_b2-li-0406"></a>compile-time environment, 555, 556 (ex. 5.43), 556 (ex. 5.44), 557 (ex. 5.47)</li>
<li><a id="c555_b2-li-0407"></a><span class="KeyTerm1">complex</span> package, 167</li>
<li><a id="c555_b2-li-0408"></a>complex-number arithmetic, 148<ul class="none">
<li><a id="c555_b2-li-0409"></a>interfaced to generic arithmetic system, 167</li>
<li><a id="c555_b2-li-0410"></a>structure of system, 155 (fig. 2.21)</li>
</ul></li>
<li><a id="c555_b2-li-0411"></a>complex numbers<ul class="none">
<li><a id="c555_b2-li-0412"></a>polar representation, 151</li>
<li><a id="c555_b2-li-0413"></a>rectangular representation, 151</li>
<li><a id="c555_b2-li-0414"></a>rectangular vs. polar form, 149</li>
<li><a id="c555_b2-li-0415"></a>represented as tagged data, 152–155</li>
</ul></li>
<li><a id="c555_b2-li-0416"></a><span class="KeyTerm1">complex_to_complex</span>, <i>175</i> (ex. 2.81)</li>
<li><a id="c555_b2-li-0417"></a>composition of functions, 67 (ex. 1.42)</li>
<li><a id="c555_b2-li-0418"></a><span class="KeyTerm1">compound_apply</span>, <i>508</i></li>
<li><a id="c555_b2-li-0419"></a>compound data, need for, 69–71</li>
<li><a id="c555_b2-li-0420"></a>compound expression, 4, <i>see also</i> function application; operator combination; syntactic form<ul class="none">
<li><a id="c555_b2-li-0421"></a>as function expression of application, 17 (ex. 1.4)</li>
</ul></li>
<li><a id="c555_b2-li-0422"></a>compound function, 8, <i>see also</i> function used like primitive function, 10</li>
<li><a id="c555_b2-li-0423"></a>compound query, 405–406<ul class="none">
<li><a id="c555_b2-li-0424"></a>processing, 413–415, 426–428, 445 (ex. 4.72), 446 (ex. 4.73), 446 (ex. 4.74)</li>
</ul></li>
<li><a id="c555_b2-li-0425"></a>computability, 349<i>n</i>, 351<i>n</i></li>
<li><a id="c555_b2-li-0426"></a>computational process, 1, <i>see also</i> process</li>
<li><a id="c555_b2-li-0427"></a>computer science, 318, 349<i>n</i>
<ul class="none">
<li><a id="c555_b2-li-0428"></a>mathematics vs., 18, 398</li>
</ul></li>
<li><a id="c555_b2-li-0429"></a>concatenating strings, 75</li>
<li><a id="c555_b2-li-0430"></a><span class="KeyTerm1">conclusion</span>, <i>444</i></li>
<li><a id="c555_b2-li-0431"></a>concrete data representation, 72</li>
<li><a id="c555_b2-li-0432"></a>concurrency, 263–280<ul class="none">
<li><a id="c555_b2-li-0433"></a>correctness of concurrent programs, 266–268</li>
<li><a id="c555_b2-li-0434"></a>deadlock, 278–279</li>
<li><a id="c555_b2-li-0435"></a>functional programming and, 314</li>
<li><a id="c555_b2-li-0436"></a>mechanisms for controlling, 268–280</li>
</ul></li>
<li><a id="c555_b2-li-0437"></a><span class="KeyTerm1">concurrent_execute</span>, 269</li>
<li><a id="c555_b2-li-0438"></a><span class="KeyTerm1">conditional_alternative</span>, 331</li>
<li><a id="c555_b2-li-0439"></a><span class="KeyTerm1">conditional_consequent</span>, 331</li>
<li><a id="c555_b2-li-0440"></a>conditional expression, 14, <i>see also</i> case analysis<ul class="none">
<li><a id="c555_b2-li-0441"></a>as alternative of conditional expression, 14</li>
<li><a id="c555_b2-li-0442"></a>evaluation of, 14</li>
<li><a id="c555_b2-li-0443"></a>non-boolean value as predicate, 14<i>n</i></li>
<li><a id="c555_b2-li-0444"></a>normal-order evaluation of, 17 (ex. 1.5)</li>
<li><a id="c555_b2-li-0445"></a> as operand of operator combination, 17 (ex. 1.1)</li>
<li><a id="c555_b2-li-0446"></a>parsing of, 331</li>
<li><a id="c555_b2-li-0447"></a>precedence of, 17 (ex. 1.1)</li>
<li><a id="c555_b2-li-0448"></a>right-associativity of, 14</li>
<li><a id="c555_b2-li-0449"></a>why a syntactic form, 20 (ex. 1.6)</li>
</ul></li>
<li><a id="c555_b2-li-0450"></a><span class="KeyTerm1">conditional_predicate</span>, 331</li>
<li><a id="c555_b2-li-0451"></a>conditional statement, 57<ul class="none">
<li><a id="c555_b2-li-0452"></a>alternative statements of, 57</li>
<li><a id="c555_b2-li-0453"></a>conditional instead of alternative block, 179</li>
<li><a id="c555_b2-li-0454"></a>consequent statements of, 57</li>
<li><a id="c555_b2-li-0455"></a>need for, 57</li>
<li><a id="c555_b2-li-0456"></a>one-armed (without alternative), 251<i>n</i></li>
<li><a id="c555_b2-li-0457"></a>parsing of, 331</li>
<li><a id="c555_b2-li-0458"></a>predicate, consequent, and alternative of, 57</li>
</ul></li>
<li><a id="c555_b2-li-0459"></a>congruent modulo <i>n</i>, 44</li>
<li><a id="c555_b2-li-0460"></a><span class="KeyTerm1">conjoin</span>, <i>426</i></li>
<li><a id="c555_b2-li-0461"></a>conjunction, 15, <i>see also</i> <span class="KeyTerm1">&amp;&amp;</span> (logical conjunction)</li>
<li><a id="c555_b2-li-0462"></a><span class="KeyTerm1">connect</span>, 255, <i>261</i></li>
<li><a id="c555_b2-li-0463"></a>connector(s), in constraint system, 253<ul class="none">
<li><a id="c555_b2-li-0464"></a>operations on, 255</li>
<li><a id="c555_b2-li-0465"></a>representing, 258</li>
</ul></li>
<li><a id="c555_b2-li-0466"></a>Conniver, 376<i>n</i></li>
<li><a id="c555_b2-li-0467"></a>consciousness, expansion of, 325<i>n</i></li>
<li><a id="c555_b2-li-0468"></a>consequent<ul class="none">
<li><a id="c555_b2-li-0469"></a>of clause, 15</li>
<li><a id="c555_b2-li-0470"></a>of conditional expression, 14</li>
<li><a id="c555_b2-li-0471"></a>of conditional statement, 57</li>
</ul></li>
<li><a id="c555_b2-li-0472"></a><span class="KeyTerm1"><b>const</b></span> (keyword), 5, <i>see also</i> constant declaration</li>
<li><a id="c555_b2-li-0473"></a><span class="KeyTerm1">constant</span> (in register machine), 453, <i>482</i>
<ul class="none">
<li><a id="c555_b2-li-0474"></a>simulating, 482</li>
<li><a id="c555_b2-li-0475"></a>syntax of, 468</li>
</ul></li>
<li><a id="c555_b2-li-0476"></a><span class="KeyTerm1">constant</span> (primitive constraint), <i>258</i></li>
<li><a id="c555_b2-li-0477"></a>constant (in JavaScript), 5<ul class="none">
<li><a id="c555_b2-li-0478"></a>detecting assignment to, 343 (ex. 4.11), 557 (ex. 5.46)</li>
<li><a id="c555_b2-li-0479"></a>value of, 5</li>
</ul></li>
<li><a id="c555_b2-li-0480"></a>constant declaration, 5<ul class="none">
<li><a id="c555_b2-li-0481"></a>parsing of, 333</li>
<li><a id="c555_b2-li-0482"></a>why a syntactic form, 8</li>
</ul></li>
<li><a id="c555_b2-li-0483"></a><span class="KeyTerm1">constant_exp_value</span>, <i>482</i></li>
<li><a id="c555_b2-li-0484"></a>constraint(s)<ul class="none">
<li><a id="c555_b2-li-0485"></a>primitive, 253</li>
<li><a id="c555_b2-li-0486"></a>propagation of, 252–262</li>
</ul></li>
<li><a id="c555_b2-li-0487"></a>constraint network, 253</li>
<li><a id="c555_b2-li-0488"></a><span class="KeyTerm1">construct_arglist</span>, <i>537</i></li>
<li><a id="c555_b2-li-0489"></a>constructing a list with <span class="KeyTerm1">pair</span>, 88</li>
<li><a id="c555_b2-li-0490"></a>constructor, 72<ul class="none">
<li><a id="c555_b2-li-0491"></a>as abstraction barrier, 76</li>
</ul></li>
<li><a id="c555_b2-li-0492"></a><span class="KeyTerm1">contents</span>, <i>152</i>, <i>443</i>
<ul class="none">
<li><a id="c555_b2-li-0493"></a>using JavaScript data types, 168 (ex. 2.78)</li>
</ul></li>
<li><a id="c555_b2-li-0494"></a>continuation<ul class="none">
<li><a id="c555_b2-li-0495"></a>in nondeterministic evaluator, 386–388, <i>see also</i> failure continuation; success continuation</li>
<li><a id="c555_b2-li-0496"></a>in register-machine simulator, 475<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0497"></a><span class="KeyTerm1"><b>continue</b></span> (keyword), 338 (ex. 4.7), <i>see also</i> while loop</li>
<li><a id="c555_b2-li-0498"></a><span class="KeyTerm1">continue</span> register, 459<ul class="none">
<li><a id="c555_b2-li-0499"></a>in explicit-control evaluator, 500</li>
<li><a id="c555_b2-li-0500"></a>recursion and, 464</li>
</ul></li>
<li><a id="c555_b2-li-0501"></a>continued fraction, 62 (ex. 1.37)<ul class="none">
<li><a id="c555_b2-li-0502"></a><i>e</i> as, 62 (ex. 1.38)</li>
<li><a id="c555_b2-li-0503"></a>golden ratio as, 62 (ex. 1.37)</li>
<li><a id="c555_b2-li-0504"></a>tangent as, 63 (ex. 1.39)</li>
</ul></li>
<li><a id="c555_b2-li-0505"></a>controller for register machine, 450–452, <i>see also</i> register-machine language controller diagram, 451<ul class="none">
<li><a id="c555_b2-li-0506"></a>control structure, 419</li>
</ul></li>
<li><a id="c555_b2-li-0507"></a>conventional interface, 71<ul class="none">
<li><a id="c555_b2-li-0508"></a>sequence as, 98–110</li>
</ul></li>
<li><a id="c555_b2-li-0509"></a><span class="KeyTerm1">convert</span>, <i>440</i></li>
<li><a id="c555_b2-li-0510"></a><span class="KeyTerm1">convert_to_query_syntax</span>, <i>438</i></li>
<li><a id="c555_b2-li-0511"></a>Cormen, Thomas H., 137<i>n</i></li>
<li><a id="c555_b2-li-0512"></a><span class="KeyTerm1">corner_split</span>, <i>115</i></li>
<li><a id="c555_b2-li-0513"></a>correctness of a program, 18<i>n</i></li>
<li><a id="c555_b2-li-0514"></a>cosine<ul class="none">
<li><a id="c555_b2-li-0515"></a>fixed point of, 61</li>
<li><a id="c555_b2-li-0516"></a>power series for, 294 (ex. 3.59)</li>
</ul></li>
<li><a id="c555_b2-li-0517"></a>cosmic radiation, 45<i>n</i></li>
<li><a id="c555_b2-li-0518"></a><span class="KeyTerm1">count_change</span>, <i>35</i></li>
<li><a id="c555_b2-li-0519"></a>counting change, 34–35, 89 (ex. 2.19)</li>
<li><a id="c555_b2-li-0520"></a><span class="KeyTerm1">count_leaves</span>, 93, <i>94</i>
<ul class="none">
<li><a id="c555_b2-li-0521"></a>as accumulation, 104 (ex. 2.35)</li>
<li><a id="c555_b2-li-0522"></a>as register machine, 492 (ex. 5.20)</li>
</ul></li>
<li><a id="c555_b2-li-0523"></a><span class="KeyTerm1">count_pairs</span>, <i>229</i> (ex. 3.16)</li>
<li><a id="c555_b2-li-0524"></a>credit-card accounts, international, 280<i>n</i></li>
<li><a id="c555_b2-li-0525"></a>Cressey, David, 495<i>n</i></li>
<li><a id="c555_b2-li-0526"></a>Crockford, Douglas, 339<i>n</i></li>
<li><a id="c555_b2-li-0527"></a>cross-type operations, 169</li>
<li><a id="c555_b2-li-0528"></a>cryptography, 46<i>n</i></li>
<li><a id="c555_b2-li-0529"></a><span class="KeyTerm1">cube</span>, <i>38</i> (ex. 1.15), <i>48</i>, <i>65</i></li>
<li><a id="c555_b2-li-0530"></a><span class="KeyTerm1">cube_root</span>, <i>64</i></li>
<li><a id="c555_b2-li-0531"></a>cube root<ul class="none">
<li><a id="c555_b2-li-0532"></a>as fixed point, 64</li>
<li><a id="c555_b2-li-0533"></a>by Newton's method, 21 (ex. 1.8)</li>
</ul></li>
<li><a id="c555_b2-li-0534"></a><span class="KeyTerm1">current_time</span>, 248, <i>250</i></li>
<li><a id="c555_b2-li-0535"></a>current time, for simulation agenda, 250</li>
<li><a id="c555_b2-li-0536"></a>Curry, Haskell Brooks, 90 (ex. 2.20)</li>
<li><a id="c555_b2-li-0537"></a>currying, 90 (ex. 2.20)</li>
<li><a id="c555_b2-li-0538"></a>cycle in list, 226 (ex. 3.13)<ul class="none">
<li><a id="c555_b2-li-0539"></a>detecting, 229 (ex. 3.18)</li>
</ul></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-0540"></a>Darlington, John, 314<i>n</i></li>
<li><a id="c555_b2-li-0541"></a>data, 1, 3<ul class="none">
<li><a id="c555_b2-li-0542"></a>abstract, 72, <i>see also</i> data abstraction abstract models for, 78<i>n</i></li>
<li><a id="c555_b2-li-0543"></a>algebraic specification for, 79<i>n</i></li>
<li><a id="c555_b2-li-0544"></a>compound, 69–71</li>
<li><a id="c555_b2-li-0545"></a>concrete representation of, 72</li>
<li><a id="c555_b2-li-0546"></a>functional representation of, 78–80</li>
<li><a id="c555_b2-li-0547"></a>hierarchical, 85, 93–96</li>
<li><a id="c555_b2-li-0548"></a>list-structured, 74</li>
<li><a id="c555_b2-li-0549"></a>meaning of, 78–80</li>
<li><a id="c555_b2-li-0550"></a>mutable, <i>see</i> mutable data objects numerical, 3</li>
<li><a id="c555_b2-li-0551"></a>as program, 348–350</li>
<li><a id="c555_b2-li-0552"></a>shared, 226–229</li>
<li><a id="c555_b2-li-0553"></a>symbolic, 124</li>
<li><a id="c555_b2-li-0554"></a>tagged, 152–155, 489<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0555"></a>data abstraction, 70, 72, 147, 149, 329, <i>see also</i> metacircular evaluator for queue, 231</li>
<li><a id="c555_b2-li-0556"></a>data base<ul class="none">
<li><a id="c555_b2-li-0557"></a>data-directed programming and, 162 (ex. 2.74)</li>
<li><a id="c555_b2-li-0558"></a>Gargle personnel, 401–403</li>
<li><a id="c555_b2-li-0559"></a>indexing, 413<i>n</i>, 434</li>
<li><a id="c555_b2-li-0560"></a>Insatiable Enterprises personnel, 161 (ex. 2.74)</li>
<li><a id="c555_b2-li-0561"></a>logic programming and, 401</li>
<li><a id="c555_b2-li-0562"></a>as set of records, 139</li>
</ul></li>
<li><a id="c555_b2-li-0563"></a>data-directed programming, 148, 156–162<ul class="none">
<li><a id="c555_b2-li-0564"></a>case analysis vs., 323</li>
<li><a id="c555_b2-li-0565"></a>in metacircular evaluator, 336 (ex. 4.3)</li>
<li><a id="c555_b2-li-0566"></a>in query interpreter, 425</li>
</ul></li>
<li><a id="c555_b2-li-0567"></a>data-directed recursion, 180</li>
<li><a id="c555_b2-li-0568"></a>data paths for register machine, 450–452</li>
<li><a id="c555_b2-li-0569"></a>data-path diagram, 450</li>
<li><a id="c555_b2-li-0570"></a>data types<ul class="none">
<li><a id="c555_b2-li-0571"></a>in JavaScript, 168 (ex. 2.78)</li>
<li><a id="c555_b2-li-0572"></a>in statically typed languages, 310<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0573"></a>deadlock, 278–279<ul class="none">
<li><a id="c555_b2-li-0574"></a>avoidance, 278</li>
<li><a id="c555_b2-li-0575"></a>recovery, 279<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0576"></a>debug, 1</li>
<li><a id="c555_b2-li-0577"></a>declaration, <i>see also</i> internal declaration<ul class="none">
<li><a id="c555_b2-li-0578"></a>of constant (<span class="KeyTerm1"><b>const</b></span>), 5</li>
<li><a id="c555_b2-li-0579"></a>environment model of, 208</li>
<li><a id="c555_b2-li-0580"></a>of function (<span class="KeyTerm1"><b>function</b></span>), 8</li>
<li><a id="c555_b2-li-0581"></a>use of name before, 56<i>n</i>, 222</li>
<li><a id="c555_b2-li-0582"></a>of variable (<span class="KeyTerm1"><b>let</b></span>), 191</li>
</ul></li>
<li><a id="c555_b2-li-0583"></a><span class="KeyTerm1">declaration_symbol</span>, <i>333</i></li>
<li><a id="c555_b2-li-0584"></a><span class="KeyTerm1">declaration_value_expression</span>, <i>333</i></li>
<li><a id="c555_b2-li-0585"></a>declarative vs. imperative knowledge, 18, 398<ul class="none">
<li><a id="c555_b2-li-0586"></a>logic programming and, 399–400, 419</li>
<li><a id="c555_b2-li-0587"></a>nondeterministic computing and, 373<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0588"></a><span class="KeyTerm1">decode</span>, <i>144</i></li>
<li><a id="c555_b2-li-0589"></a>decomposition of program into parts, 22</li>
<li><a id="c555_b2-li-0590"></a>deep binding, 343<i>n</i></li>
<li><a id="c555_b2-li-0591"></a><span class="KeyTerm1">deep_reverse</span>, 95 (ex. 2.27)</li>
<li><a id="c555_b2-li-0592"></a>deferred operations, 29</li>
<li><a id="c555_b2-li-0593"></a>definite integral, 51–52<ul class="none">
<li><a id="c555_b2-li-0594"></a>estimated with Monte Carlo simulation, 200 (ex. 3.5), 312 (ex. 3.82)</li>
</ul></li>
<li><a id="c555_b2-li-0595"></a>de Kleer, Johan, 376<i>n</i>, 421<i>n</i></li>
<li><a id="c555_b2-li-0596"></a>delay, in digital circuit, 241</li>
<li><a id="c555_b2-li-0597"></a>delayed argument, 306</li>
<li><a id="c555_b2-li-0598"></a>delayed evaluation, 190, 281<ul class="none">
<li><a id="c555_b2-li-0599"></a>assignment and, 288 (ex. 3.52)</li>
<li><a id="c555_b2-li-0600"></a>explicit vs. automatic, 372</li>
<li><a id="c555_b2-li-0601"></a>in lazy evaluator, 360–372</li>
<li><a id="c555_b2-li-0602"></a>normal-order evaluation and, 310</li>
<li><a id="c555_b2-li-0603"></a>printing and, 287<i>n</i></li>
<li><a id="c555_b2-li-0604"></a>streams and, 305–309</li>
</ul></li>
<li><a id="c555_b2-li-0605"></a>delayed expression, 283<ul class="none">
<li><a id="c555_b2-li-0606"></a>explicit, 306</li>
<li><a id="c555_b2-li-0607"></a>explicit vs. automatic, 372</li>
<li><a id="c555_b2-li-0608"></a>lazy evaluation and, 370</li>
<li><a id="c555_b2-li-0609"></a>memoized, 286, 293<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0610"></a><span class="KeyTerm1">delay_it</span>, <i>366</i></li>
<li><a id="c555_b2-li-0611"></a><span class="KeyTerm1">delete_queue</span>, 232, <i>234</i></li>
<li><a id="c555_b2-li-0612"></a><span class="KeyTerm1">denom</span>, 72, <i>74</i>
<ul class="none">
<li><a id="c555_b2-li-0613"></a>axiom for, 78</li>
<li><a id="c555_b2-li-0614"></a>reducing to lowest terms, <i>77</i></li>
</ul></li>
<li><a id="c555_b2-li-0615"></a>dense polynomial, 181</li>
<li><a id="c555_b2-li-0616"></a>dependency-directed backtracking, 376<i>n</i></li>
<li><a id="c555_b2-li-0617"></a><span class="KeyTerm1">depends_on</span>, <i>433</i></li>
<li><a id="c555_b2-li-0618"></a><span class="KeyTerm1">deposit</span> message for bank account, <i>194</i></li>
<li><a id="c555_b2-li-0619"></a><span class="KeyTerm1">deposit</span>, with external serializer, <i>274</i></li>
<li><a id="c555_b2-li-0620"></a>depth-first search, 376</li>
<li><a id="c555_b2-li-0621"></a>deque, 235 (ex. 3.23)</li>
<li><a id="c555_b2-li-0622"></a><span class="KeyTerm1">deriv</span> (numerical), <i>65</i></li>
<li><a id="c555_b2-li-0623"></a><span class="KeyTerm1">deriv</span> (symbolic), <i>127</i>
<ul class="none">
<li><a id="c555_b2-li-0624"></a>data-directed, <i>161</i> (ex. 2.73)</li>
</ul></li>
<li><a id="c555_b2-li-0625"></a>derivative of a function, 64</li>
<li><a id="c555_b2-li-0626"></a>derived component, 335<ul class="none">
<li><a id="c555_b2-li-0627"></a>adding to explicit-control evaluator, 513 (ex. 5.25)</li>
</ul></li>
<li><a id="c555_b2-li-0628"></a>derived components in evaluator, 334–335<ul class="none">
<li><a id="c555_b2-li-0629"></a>function declaration, 334</li>
<li><a id="c555_b2-li-0630"></a>operator combination, 335</li>
</ul></li>
<li><a id="c555_b2-li-0631"></a>design, stratified, 123</li>
<li><a id="c555_b2-li-0632"></a>differential equation, 306, <i>see also</i> <span class="KeyTerm1">solve</span>
<ul class="none">
<li><a id="c555_b2-li-0633"></a>second-order, 308 (ex. 3.78), 308 (ex. 3.79)</li>
</ul></li>
<li><a id="c555_b2-li-0634"></a>differentiation<ul class="none">
<li><a id="c555_b2-li-0635"></a>numerical, 64</li>
<li><a id="c555_b2-li-0636"></a>rules for, 126, 130 (ex. 2.56)</li>
<li><a id="c555_b2-li-0637"></a>symbolic, 126–131, 160 (ex. 2.73)</li>
</ul></li>
<li><a id="c555_b2-li-0638"></a>diffusion, simulation of, 267</li>
<li><a id="c555_b2-li-0639"></a>digital-circuit simulation, 241–252<ul class="none">
<li><a id="c555_b2-li-0640"></a>agenda, 247–248</li>
<li><a id="c555_b2-li-0641"></a>agenda implementation, 250–252</li>
<li><a id="c555_b2-li-0642"></a>primitive function boxes, 244–245</li>
<li><a id="c555_b2-li-0643"></a>representing wires, 246–247</li>
<li><a id="c555_b2-li-0644"></a>sample simulation, 248–249</li>
</ul></li>
<li><a id="c555_b2-li-0645"></a>digital signal, 241</li>
<li><a id="c555_b2-li-0646"></a>Dijkstra, Edsger Wybe, 276<i>n</i></li>
<li><a id="c555_b2-li-0647"></a>Dinesman, Howard P., 378</li>
<li><a id="c555_b2-li-0648"></a>Diophantus's <i>Arithmetic</i>, Fermat's copy of, 44<i>n</i></li>
<li><a id="c555_b2-li-0649"></a>Dirichlet, Peter Gustav Lejeune, 198<i>n</i></li>
<li><a id="c555_b2-li-0650"></a><span class="KeyTerm1">dirichlet_stream</span>, <i>312</i></li>
<li><a id="c555_b2-li-0651"></a><span class="KeyTerm1">dirichlet_test</span>, <i>198</i></li>
<li><a id="c555_b2-li-0652"></a><span class="KeyTerm1">disjoin</span>, <i>427</i>
<ul class="none">
<li><a id="c555_b2-li-0653"></a>without delayed expression, <i>444</i> (ex. 4.68)</li>
</ul></li>
<li><a id="c555_b2-li-0654"></a>disjunction, 15, <i>see also</i> <span class="KeyTerm1">||</span> (logical disjunction)</li>
<li><a id="c555_b2-li-0655"></a>dispatching<ul class="none">
<li><a id="c555_b2-li-0656"></a>comparing different styles, 163 (ex. 2.76)</li>
<li><a id="c555_b2-li-0657"></a>on type, 156, <i>see also</i> data-directed programming</li>
</ul></li>
<li><a id="c555_b2-li-0658"></a><span class="KeyTerm1">display</span> (primitive function), 46 (ex. 1.22), 75<i>n</i></li>
<li><a id="c555_b2-li-0659"></a><span class="KeyTerm1">display</span> operation in register machine, 455</li>
<li><a id="c555_b2-li-0660"></a><span class="KeyTerm1">display_stream</span>, <i>284</i></li>
<li><a id="c555_b2-li-0661"></a><span class="KeyTerm1">distinct</span>, <i>379n</i></li>
<li><a id="c555_b2-li-0662"></a><span class="KeyTerm1">div</span> (generic), <i>165</i></li>
<li><a id="c555_b2-li-0663"></a><span class="KeyTerm1">div_complex</span>, <i>150</i></li>
<li><a id="c555_b2-li-0664"></a><span class="KeyTerm1">divides</span>, <i>43</i></li>
<li><a id="c555_b2-li-0665"></a><span class="KeyTerm1">div_interval</span>, <i>82</i>
<ul class="none">
<li><a id="c555_b2-li-0666"></a>division by zero, 82 (ex. 2.10)</li>
</ul></li>
<li><a id="c555_b2-li-0667"></a><span class="KeyTerm1">div_poly</span>, 183 (ex. 2.91)</li>
<li><a id="c555_b2-li-0668"></a><span class="KeyTerm1">div_rat</span>, <i>73</i></li>
<li><a id="c555_b2-li-0669"></a><span class="KeyTerm1">div_series</span>, 295 (ex. 3.62)</li>
<li><a id="c555_b2-li-0670"></a><span class="KeyTerm1">div_terms</span>, <i>183</i> (ex. 2.91)</li>
<li><a id="c555_b2-li-0671"></a>dog, perfectly rational behavior of, 278<i>n</i></li>
<li><a id="c555_b2-li-0672"></a><span class="KeyTerm1">dot_product</span>, <i>105</i> (ex. 2.37)</li>
<li><a id="c555_b2-li-0673"></a>Doyle, Jon, 376<i>n</i> <span class="KeyTerm1">draw_line</span>, 119</li>
<li><a id="c555_b2-li-0674"></a><span class="KeyTerm1">driver_loop</span>
<ul class="none">
<li><a id="c555_b2-li-0675"></a>for lazy evaluator, <i>365</i></li>
<li><a id="c555_b2-li-0676"></a>for metacircular evaluator, <i>347</i></li>
<li><a id="c555_b2-li-0677"></a>for nondeterministic evaluator, <i>395</i></li>
</ul></li>
<li><a id="c555_b2-li-0678"></a>driver loop<ul class="none">
<li><a id="c555_b2-li-0679"></a>in explicit-control evaluator, 514</li>
<li><a id="c555_b2-li-0680"></a>in lazy evaluator, 365</li>
<li><a id="c555_b2-li-0681"></a>in metacircular evaluator, 346</li>
<li><a id="c555_b2-li-0682"></a>in nondeterministic evaluator, 377, 394</li>
<li><a id="c555_b2-li-0683"></a>in query interpreter, 418, 424</li>
</ul></li>
<li><a id="c555_b2-li-0684"></a>duplicate parameters, 336 (ex. 4.5)</li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-0685"></a><i>e</i>
<ul class="none">
<li><a id="c555_b2-li-0686"></a>as continued fraction, 62 (ex. 1.38)</li>
<li><a id="c555_b2-li-0687"></a>as solution to differential equation, 307</li>
</ul></li>
<li><a id="c555_b2-li-0688"></a><i>e<sup>x</sup></i>, power series for, 294 (ex. 3.59)</li>
<li><a id="c555_b2-li-0689"></a>Earth, measuring circumference of, 289<i>n</i></li>
<li><a id="c555_b2-li-0690"></a><span class="KeyTerm1">eceval</span>, <i>515</i></li>
<li><a id="c555_b2-li-0691"></a>ECMAScript, 2<ul class="none">
<li><a id="c555_b2-li-0692"></a><span class="KeyTerm1">Math</span> object, 10<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0693"></a><span class="KeyTerm1">edge1_frame</span>, 117</li>
<li><a id="c555_b2-li-0694"></a><span class="KeyTerm1">edge2_frame</span>, 117</li>
<li><a id="c555_b2-li-0695"></a>Edwards, Anthony William Fairbank, 36<i>n</i></li>
<li><a id="c555_b2-li-0696"></a>efficiency, <i>see also</i> order of growth of compilation, 521<ul class="none">
<li><a id="c555_b2-li-0697"></a>of data-base access, 413<i>n</i></li>
<li><a id="c555_b2-li-0698"></a>of evaluation, 355</li>
<li><a id="c555_b2-li-0699"></a>of query processing, 414</li>
<li><a id="c555_b2-li-0700"></a>of tree-recursive process, 35</li>
</ul></li>
<li><a id="c555_b2-li-0701"></a>Eich, Brendan, 2</li>
<li><a id="c555_b2-li-0702"></a>EIEIO, 279<i>n</i></li>
<li><a id="c555_b2-li-0703"></a>eight-queens puzzle, 108 (ex. 2.42), 380 (ex. 4.42)</li>
<li><a id="c555_b2-li-0704"></a>electrical circuits, modeled with streams, 303 (ex. 3.73), 308 (ex. 3.80)</li>
<li><a id="c555_b2-li-0705"></a><span class="KeyTerm1">element_expressions</span>, <i>442</i></li>
<li><a id="c555_b2-li-0706"></a><span class="KeyTerm1"><b>else</b></span> (keyword), 57, <i>see also</i> conditional statement</li>
<li><a id="c555_b2-li-0707"></a>embedded language, language design using, 360</li>
<li><a id="c555_b2-li-0708"></a><span class="KeyTerm1">empty_arglist</span>, <i>505n</i></li>
<li><a id="c555_b2-li-0709"></a>empty list, 87, <i>see also</i> <span class="KeyTerm1"><b>null</b></span>
<ul class="none">
<li><a id="c555_b2-li-0710"></a>recognizing with <span class="KeyTerm1">is_null</span>, 87</li>
</ul></li>
<li><a id="c555_b2-li-0711"></a>empty stream, 283</li>
<li><a id="c555_b2-li-0712"></a>encapsulated name, 193<i>n</i></li>
<li><a id="c555_b2-li-0713"></a><span class="KeyTerm1">enclosing_environment</span>, <i>341</i></li>
<li><a id="c555_b2-li-0714"></a>enclosing environment, 206</li>
<li><a id="c555_b2-li-0715"></a><span class="KeyTerm1">encode</span>, <i>145</i> (ex. 2.68)</li>
<li><a id="c555_b2-li-0716"></a>end-of-list marker, 85</li>
<li><a id="c555_b2-li-0717"></a><span class="KeyTerm1">end_segment</span>, 77 (ex. 2.2), 120 (ex. 2.48)</li>
<li><a id="c555_b2-li-0718"></a><span class="KeyTerm1">end_with_linkage</span>, <i>527</i></li>
<li><a id="c555_b2-li-0719"></a>engineering vs. mathematics, 45<i>n</i></li>
<li><a id="c555_b2-li-0720"></a> <span class="KeyTerm1">entry</span>, <i>136</i></li>
<li><a id="c555_b2-li-0721"></a><span class="KeyTerm1">enumerate_interval</span>, <i>101</i></li>
<li><a id="c555_b2-li-0722"></a><span class="KeyTerm1">enumerate_tree</span>, <i>101</i></li>
<li><a id="c555_b2-li-0723"></a>enumerator, 99</li>
<li><a id="c555_b2-li-0724"></a><span class="KeyTerm1">env</span> register, 500</li>
<li><a id="c555_b2-li-0725"></a>environment, 6, 206<ul class="none">
<li><a id="c555_b2-li-0726"></a>compile-time, <i>see</i> compile-time environment</li>
<li><a id="c555_b2-li-0727"></a>as context for evaluation, 7</li>
<li><a id="c555_b2-li-0728"></a>enclosing, 206</li>
<li><a id="c555_b2-li-0729"></a>global, <i>see</i> global environment</li>
<li><a id="c555_b2-li-0730"></a>lexical scoping and, 25<i>n</i></li>
<li><a id="c555_b2-li-0731"></a>program, <i>see</i> program environment</li>
<li><a id="c555_b2-li-0732"></a>in query interpreter, 447 (ex. 4.76)</li>
<li><a id="c555_b2-li-0733"></a>renaming vs., 447 (ex. 4.76)</li>
</ul></li>
<li><a id="c555_b2-li-0734"></a>environment model of evaluation, 190, 206–222<ul class="none">
<li><a id="c555_b2-li-0735"></a>environment structure, 207 (fig. 3.1)</li>
<li><a id="c555_b2-li-0736"></a>function application, 207</li>
<li><a id="c555_b2-li-0737"></a>function-application example, 210–213</li>
<li><a id="c555_b2-li-0738"></a>internal declarations, 218–222</li>
<li><a id="c555_b2-li-0739"></a>local state, 213–218</li>
<li><a id="c555_b2-li-0740"></a>message passing, 220 (ex. 3.11)</li>
<li><a id="c555_b2-li-0741"></a>metacircular evaluator and, 320</li>
<li><a id="c555_b2-li-0742"></a>rules for evaluation, 207–210</li>
<li><a id="c555_b2-li-0743"></a>tail recursion and, 213<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0744"></a><span class="KeyTerm1">equal</span>, 125 (ex. 2.54)</li>
<li><a id="c555_b2-li-0745"></a>equality<ul class="none">
<li><a id="c555_b2-li-0746"></a>in generic arithmetic system, 169 (ex. 2.79)</li>
<li><a id="c555_b2-li-0747"></a>of lists, 125 (ex. 2.54)</li>
<li><a id="c555_b2-li-0748"></a>of numbers, 15, 125 (ex. 2.54), 490<i>n</i></li>
<li><a id="c555_b2-li-0749"></a>referential transparency and, 203</li>
<li><a id="c555_b2-li-0750"></a>of strings, 124, 125 (ex. 2.54), 490</li>
</ul></li>
<li><a id="c555_b2-li-0751"></a><span class="KeyTerm1">equal_rat</span>, <i>73</i></li>
<li><a id="c555_b2-li-0752"></a>equation, solving, <i>see</i> half-interval method; Newton's method; <span class="KeyTerm1">solve</span></li>
<li><a id="c555_b2-li-0753"></a>Eratosthenes, 289<i>n</i></li>
<li><a id="c555_b2-li-0754"></a><span class="KeyTerm1">error</span> (primitive function), 60<i>n</i>
<ul class="none">
<li><a id="c555_b2-li-0755"></a>optional second argument, 79<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0756"></a>error handling<ul class="none">
<li><a id="c555_b2-li-0757"></a>in compiled code, 561<i>n</i></li>
<li><a id="c555_b2-li-0758"></a>in explicit-control evaluator, 515, 518 (ex. 5.31)</li>
</ul></li>
<li><a id="c555_b2-li-0759"></a>Escher, Maurits Cornelis, 110<i>n</i></li>
<li><a id="c555_b2-li-0760"></a><span class="KeyTerm1">estimate_integral</span>, 200 (ex. 3.5)</li>
<li><a id="c555_b2-li-0761"></a><span class="KeyTerm1">estimate_pi</span>, <i>198, 199</i></li>
<li><a id="c555_b2-li-0762"></a>Euclid's Algorithm, 41–42, 450, <i>see also</i> greatest common divisor<ul class="none">
<li><a id="c555_b2-li-0763"></a>order of growth, 42</li>
<li><a id="c555_b2-li-0764"></a>for polynomials, 185<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0765"></a>Euclid's <i>Elements</i>, 42<i>n</i></li>
<li><a id="c555_b2-li-0766"></a>Euclid's proof of infinite number of primes, 292<i>n</i></li>
<li><a id="c555_b2-li-0767"></a>Euclidean ring, 185<i>n</i></li>
<li><a id="c555_b2-li-0768"></a>Euler, Leonhard, 62 (ex. 1.38)<ul class="none">
<li><a id="c555_b2-li-0769"></a>proof of Fermat's Little Theorem, 44<i>n</i></li>
<li><a id="c555_b2-li-0770"></a>series accelerator, 297</li>
</ul></li>
<li><a id="c555_b2-li-0771"></a><span class="KeyTerm1">euler_transform</span>, <i>297</i></li>
<li><a id="c555_b2-li-0772"></a><span class="KeyTerm1">eval</span> (primitive function in JavaScript), 350</li>
<li><a id="c555_b2-li-0773"></a><span class="KeyTerm1">eval_assignment</span>, <i>327</i></li>
<li><a id="c555_b2-li-0774"></a><span class="KeyTerm1">eval_block</span>, <i>326</i></li>
<li><a id="c555_b2-li-0775"></a><span class="KeyTerm1">eval_conditional</span> (lazy), <i>365</i></li>
<li><a id="c555_b2-li-0776"></a><span class="KeyTerm1">eval_conditional</span> (metacircular), <i>325</i></li>
<li><a id="c555_b2-li-0777"></a><span class="KeyTerm1">eval_declaration</span>, <i>328</i></li>
<li><a id="c555_b2-li-0778"></a><span class="KeyTerm1">eval_dispatch</span>, <i>501</i></li>
<li><a id="c555_b2-li-0779"></a><span class="KeyTerm1">eval_return_statement</span>, <i>327</i></li>
<li><a id="c555_b2-li-0780"></a><span class="KeyTerm1">eval_sequence</span>, <i>326</i></li>
<li><a id="c555_b2-li-0781"></a><span class="KeyTerm1">evaluate</span> (lazy), 363</li>
<li><a id="c555_b2-li-0782"></a><span class="KeyTerm1">evaluate</span> (metacircular), <i>323</i>
<ul class="none">
<li><a id="c555_b2-li-0783"></a>analyzing version, <i>356</i></li>
<li><a id="c555_b2-li-0784"></a>data-directed, 336 (ex. 4.3)</li>
</ul></li>
<li><a id="c555_b2-li-0785"></a><span class="KeyTerm1">evaluate_query</span>, 418, <i>426</i></li>
<li><a id="c555_b2-li-0786"></a>evaluation<ul class="none">
<li><a id="c555_b2-li-0787"></a>applicative-order, <i>see</i> applicative-order evaluation</li>
<li><a id="c555_b2-li-0788"></a>delayed, <i>see</i> delayed evaluation environment model of, <i>see</i></li>
<li><a id="c555_b2-li-0789"></a>environment model of evaluation models of, 513</li>
<li><a id="c555_b2-li-0790"></a>normal-order, <i>see</i> normal-order evaluation</li>
<li><a id="c555_b2-li-0791"></a>of <span class="KeyTerm1">&amp;&amp;</span>, 15</li>
<li><a id="c555_b2-li-0792"></a>of <span class="KeyTerm1">||</span>, 15</li>
<li><a id="c555_b2-li-0793"></a>of conditional expression, 14</li>
<li><a id="c555_b2-li-0794"></a>of function application, 9</li>
<li><a id="c555_b2-li-0795"></a>of operator combination, 6–8</li>
<li><a id="c555_b2-li-0796"></a>of primitive expression, 7</li>
<li><a id="c555_b2-li-0797"></a>order of subexpression evaluation, <i>see</i></li>
<li><a id="c555_b2-li-0798"></a>order of evaluation</li>
<li><a id="c555_b2-li-0799"></a>substitution model of, <i>see</i> substitution model of function application</li>
</ul></li>
<li><a id="c555_b2-li-0800"></a>evaluator, 318, <i>see also</i> interpreter<ul class="none">
<li><a id="c555_b2-li-0801"></a>as abstract machine, 349</li>
<li><a id="c555_b2-li-0802"></a>metacircular, 320</li>
<li><a id="c555_b2-li-0803"></a>as universal machine, 349</li>
</ul></li>
<li><a id="c555_b2-li-0804"></a>evaluators, <i>see</i> metacircular evaluator; analyzing evaluator; lazy evaluator; nondeterministic evaluator; query interpreter; explicit-control evaluator</li>
<li><a id="c555_b2-li-0805"></a><span class="KeyTerm1">ev_application</span>, <i>505</i></li>
<li><a id="c555_b2-li-0806"></a><span class="KeyTerm1">ev_assignment</span>, <i>512</i></li>
<li><a id="c555_b2-li-0807"></a><span class="KeyTerm1">ev_block</span>, <i>512</i></li>
<li><a id="c555_b2-li-0808"></a><span class="KeyTerm1">ev_conditional</span>,  <i>502</i></li>
<li><a id="c555_b2-li-0809"></a><span class="KeyTerm1">ev_declaration</span>, <i>513</i></li>
<li><a id="c555_b2-li-0810"></a><span class="KeyTerm1">even_fibs</span>, <i>99</i>, <i>102</i></li>
<li><a id="c555_b2-li-0811"></a>event-driven simulation, 241</li>
<li><a id="c555_b2-li-0812"></a><span class="KeyTerm1">ev_function_declaration</span>, <i>513</i></li>
<li><a id="c555_b2-li-0813"></a><span class="KeyTerm1">ev_lambda</span>, <i>501</i></li>
<li><a id="c555_b2-li-0814"></a>evlis tail recursion, 506<i>n</i></li>
<li><a id="c555_b2-li-0815"></a><span class="KeyTerm1">ev_literal</span>, <i>501</i></li>
<li><a id="c555_b2-li-0816"></a><span class="KeyTerm1">ev_name</span>, <i>501</i></li>
<li><a id="c555_b2-li-0817"></a><span class="KeyTerm1">ev_operator_combination</span>, <i>505</i></li>
<li><a id="c555_b2-li-0818"></a><span class="KeyTerm1">ev_return</span>, <i>509</i></li>
<li><a id="c555_b2-li-0819"></a><span class="KeyTerm1">ev_sequence</span>, <i>503</i></li>
<li><a id="c555_b2-li-0820"></a><span class="KeyTerm1">exchange</span>, <i>272</i></li>
<li><a id="c555_b2-li-0821"></a><span class="KeyTerm1">execute</span>, 472</li>
<li><a id="c555_b2-li-0822"></a><span class="KeyTerm1">execute_application</span>
<ul class="none">
<li><a id="c555_b2-li-0823"></a>metacircular, <i>357</i></li>
<li><a id="c555_b2-li-0824"></a>nondeterministic, <i>393</i></li>
</ul></li>
<li><a id="c555_b2-li-0825"></a>execution function<ul class="none">
<li><a id="c555_b2-li-0826"></a>in analyzing evaluator, 356</li>
<li><a id="c555_b2-li-0827"></a>in nondeterministic evaluator, 386, 388</li>
<li><a id="c555_b2-li-0828"></a>in register-machine simulator, 472, 477–484</li>
</ul></li>
<li><a id="c555_b2-li-0829"></a>explicit-control evaluator for JavaScript, 499–519<ul class="none">
<li><a id="c555_b2-li-0830"></a>argument evaluation, 505–507</li>
<li><a id="c555_b2-li-0831"></a>assignments, 512</li>
<li><a id="c555_b2-li-0832"></a>blocks, 512</li>
<li><a id="c555_b2-li-0833"></a>combinations, 504–509</li>
<li><a id="c555_b2-li-0834"></a>compound functions, 508</li>
<li><a id="c555_b2-li-0835"></a>conditionals, 502</li>
<li><a id="c555_b2-li-0836"></a>controller, 500–515</li>
<li><a id="c555_b2-li-0837"></a>data paths, 500</li>
<li><a id="c555_b2-li-0838"></a>declarations, 512</li>
<li><a id="c555_b2-li-0839"></a>derived components, 513 (ex. 5.25)</li>
<li><a id="c555_b2-li-0840"></a>driver loop, 514</li>
<li><a id="c555_b2-li-0841"></a>error handling, 515, 518 (ex. 5.31)</li>
<li><a id="c555_b2-li-0842"></a>expressions with no subexpressions to evaluate, 501</li>
<li><a id="c555_b2-li-0843"></a>function application, 504–509</li>
<li><a id="c555_b2-li-0844"></a>as machine-language program, 520</li>
<li><a id="c555_b2-li-0845"></a>machine model, 515</li>
<li><a id="c555_b2-li-0846"></a>modified for compiled code, 557–559</li>
<li><a id="c555_b2-li-0847"></a>monitoring performance (stack use), 516–518</li>
<li><a id="c555_b2-li-0848"></a>normal-order evaluation, 513 (ex. 5.26)</li>
<li><a id="c555_b2-li-0849"></a>operations, 500</li>
<li><a id="c555_b2-li-0850"></a>optimizations (additional), 526 (ex. 5.33)</li>
<li><a id="c555_b2-li-0851"></a>primitive functions, 507</li>
<li><a id="c555_b2-li-0852"></a>registers, 500</li>
<li><a id="c555_b2-li-0853"></a>return statements, 508–511</li>
<li><a id="c555_b2-li-0854"></a>running, 513–516</li>
<li><a id="c555_b2-li-0855"></a>sequences of statements, 502–504</li>
<li><a id="c555_b2-li-0856"></a>stack usage, 504</li>
<li><a id="c555_b2-li-0857"></a>syntactic forms (additional), 513 (ex. 5.25)</li>
<li><a id="c555_b2-li-0858"></a>tail recursion, 511 (ex. 5.22), 509–511, 517 (ex. 5.27), 518 (ex. 5.29)</li>
<li><a id="c555_b2-li-0859"></a>as universal machine, 519</li>
</ul></li>
<li><a id="c555_b2-li-0860"></a><span class="KeyTerm1">expmod</span>, <i>44</i>, <i>47</i> (ex. 1.25), <i>47</i> (ex. 1.26)</li>
<li><a id="c555_b2-li-0861"></a>exponential growth, 37<ul class="none">
<li><a id="c555_b2-li-0862"></a>of tree-recursive Fibonacci-number computation, 33</li>
</ul></li>
<li><a id="c555_b2-li-0863"></a>exponentiation, 38–40<ul class="none">
<li><a id="c555_b2-li-0864"></a>modulo <i>n</i>, 44</li>
</ul></li>
<li><a id="c555_b2-li-0865"></a>expression, 3, <i>see also</i> compound expression; primitive expression<ul class="none">
<li><a id="c555_b2-li-0866"></a>algebraic, <i>see</i> algebraic expressions</li>
<li><a id="c555_b2-li-0867"></a>literal, 322</li>
<li><a id="c555_b2-li-0868"></a>primitive boolean, 14</li>
<li><a id="c555_b2-li-0869"></a>symbolic, 71, <i>see also</i> string(s); symbol(s)</li>
</ul></li>
<li><a id="c555_b2-li-0870"></a>expression-oriented vs. imperative programming style, 262<i>n</i></li>
<li><a id="c555_b2-li-0871"></a>expression statement, 3<ul class="none">
<li><a id="c555_b2-li-0872"></a>parsing of, 331</li>
</ul></li>
<li><a id="c555_b2-li-0873"></a><span class="KeyTerm1">expt</span>
<ul class="none">
<li><a id="c555_b2-li-0874"></a>linear iterative version, <i>38</i></li>
<li><a id="c555_b2-li-0875"></a>linear recursive version, <i>38</i></li>
<li><a id="c555_b2-li-0876"></a>register machine for, 466 (ex. 5.4)</li>
</ul></li>
<li><a id="c555_b2-li-0877"></a><span class="KeyTerm1">extend</span>, <i>444</i></li>
<li><a id="c555_b2-li-0878"></a><span class="KeyTerm1">extend_environment</span>, 341, <i>341</i></li>
<li><a id="c555_b2-li-0879"></a><span class="KeyTerm1">extend_if_consistent</span>, <i>429</i></li>
<li><a id="c555_b2-li-0880"></a><span class="KeyTerm1">extend_if_possible</span>, <i>433</i></li>
<li><a id="c555_b2-li-0881"></a><span class="KeyTerm1">external_entry</span>, <i>559</i></li>
<li><a id="c555_b2-li-0882"></a><span class="KeyTerm1">extract_labels</span>, <i>475</i>, <i>475n</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-0883"></a><span class="KeyTerm1">factorial</span>
<ul class="none">
<li><a id="c555_b2-li-0884"></a>as an abstract machine, 349</li>
<li><a id="c555_b2-li-0885"></a>compilation of, 546–549</li>
<li><a id="c555_b2-li-0886"></a>environment structure in evaluating, 212 (ex. 3.9)</li>
<li><a id="c555_b2-li-0887"></a>linear iterative version, <i>28</i></li>
<li><a id="c555_b2-li-0888"></a>linear recursive version, <i>27</i></li>
<li><a id="c555_b2-li-0889"></a>register machine for (iterative), 452 (ex. 5.1), 454 (ex. 5.2)</li>
<li><a id="c555_b2-li-0890"></a>register machine for (recursive), 462–464, 465 (fig. 5.11)</li>
<li><a id="c555_b2-li-0891"></a>stack usage, compiled, 562 (ex. 5.48)</li>
<li><a id="c555_b2-li-0892"></a>stack usage, interpreted, 517 (ex. 5.27), 517 (ex. 5.28)</li>
<li><a id="c555_b2-li-0893"></a>stack usage, register machine, 486 (ex. 5.13)</li>
<li><a id="c555_b2-li-0894"></a>with assignment, <i>205</i></li>
<li><a id="c555_b2-li-0895"></a>with higher-order functions, 52 (ex. 1.31)</li>
<li><a id="c555_b2-li-0896"></a>with while loop, <i>338</i> (ex. 4.7)</li>
</ul></li>
<li><a id="c555_b2-li-0897"></a>factorial, 27, <i>see also</i> <span class="KeyTerm1">factorial</span>
<ul class="none">
<li><a id="c555_b2-li-0898"></a>without declaration or assignment, 353 (ex. 4.18)</li>
<li><a id="c555_b2-li-0899"></a>infinite stream, 292 (ex. 3.54)</li>
</ul></li>
<li><a id="c555_b2-li-0900"></a>failure, in nondeterministic computation, 374<ul class="none">
<li><a id="c555_b2-li-0901"></a>bug vs., 389</li>
<li><a id="c555_b2-li-0902"></a>searching and, 376</li>
</ul></li>
<li><a id="c555_b2-li-0903"></a>failure continuation (nondeterministic evaluator), 386, 388<ul class="none">
<li><a id="c555_b2-li-0904"></a>constructed by <span class="KeyTerm1">amb</span>, 394</li>
<li><a id="c555_b2-li-0905"></a>constructed by assignment, 390</li>
<li><a id="c555_b2-li-0906"></a>constructed by driver loop, 394</li>
</ul></li>
<li><a id="c555_b2-li-0907"></a><span class="KeyTerm1"><b>false</b></span> (keyword), 14</li>
<li><a id="c555_b2-li-0908"></a>falsiness, 339<i>n</i></li>
<li><a id="c555_b2-li-0909"></a><span class="KeyTerm1">fast_expt</span>, <i>39</i></li>
<li><a id="c555_b2-li-0910"></a><span class="KeyTerm1">fast_is_prime</span>, <i>45</i></li>
<li><a id="c555_b2-li-0911"></a>feedback loop, modeled with streams, 305</li>
<li><a id="c555_b2-li-0912"></a>Feeley, Marc, 356<i>n</i></li>
<li><a id="c555_b2-li-0913"></a>Feigenbaum, Edward, 400<i>n</i></li>
<li><a id="c555_b2-li-0914"></a>Fenichel, Robert, 494<i>n</i></li>
<li><a id="c555_b2-li-0915"></a>Fermat, Pierre de, 44<i>n</i></li>
<li><a id="c555_b2-li-0916"></a>Fermat's Little Theorem, 44<ul class="none">
<li><a id="c555_b2-li-0917"></a>alternate form, 48 (ex. 1.28)</li>
<li><a id="c555_b2-li-0918"></a>proof, 44<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0919"></a><span class="KeyTerm1">fermat_test</span>, <i>45</i></li>
<li><a id="c555_b2-li-0920"></a>Fermat test for primality, 44–45<ul class="none">
<li><a id="c555_b2-li-0921"></a>variant of, 48 (ex. 1.28)</li>
</ul></li>
<li><a id="c555_b2-li-0922"></a><span class="KeyTerm1">fetch_assertions</span>, <i>434</i></li>
<li><a id="c555_b2-li-0923"></a><span class="KeyTerm1">fetch_rules</span>, <i>434</i></li>
<li><a id="c555_b2-li-0924"></a><span class="KeyTerm1">fib</span>
<ul class="none">
<li><a id="c555_b2-li-0925"></a>linear iterative version, <i>33</i></li>
<li><a id="c555_b2-li-0926"></a>logarithmic version, <i>40</i> (ex. 1.19)</li>
<li><a id="c555_b2-li-0927"></a>register machine for (tree-recursive), 466, 467 (fig. 5.12)</li>
<li><a id="c555_b2-li-0928"></a>stack usage, compiled, 562 (ex. 5.49)</li>
<li><a id="c555_b2-li-0929"></a>stack usage, interpreted, 518 (ex. 5.30)</li>
<li><a id="c555_b2-li-0930"></a>tree-recursive version, <i>32</i>, <i>518</i> (ex. 5.30)</li>
<li><a id="c555_b2-li-0931"></a>with memoization, <i>240</i> (ex. 3.27)</li>
</ul></li>
<li><a id="c555_b2-li-0932"></a>Fibonacci numbers, 32, <i>see also</i> <span class="KeyTerm1">fib</span>
<ul class="none">
<li><a id="c555_b2-li-0933"></a>Euclid's GCD algorithm and, 42</li>
<li><a id="c555_b2-li-0934"></a>infinite stream of, <i>see</i> <span class="KeyTerm1">fibs</span></li>
</ul></li>
<li><a id="c555_b2-li-0935"></a><span class="KeyTerm1">fibs</span> (infinite stream), <i>289</i>
<ul class="none">
<li><a id="c555_b2-li-0936"></a>implicit definition, <i>291</i></li>
</ul></li>
<li><a id="c555_b2-li-0937"></a>FIFO buffer, 231</li>
<li><a id="c555_b2-li-0938"></a><span class="KeyTerm1">filter</span>, <i>100</i></li>
<li><a id="c555_b2-li-0939"></a>filter, 53 (ex. 1.33), 100</li>
<li><a id="c555_b2-li-0940"></a><span class="KeyTerm1">filtered_accumulate</span>, 53 (ex. 1.33)</li>
<li><a id="c555_b2-li-0941"></a><span class="KeyTerm1">find_assertions</span>, <i>428</i></li>
<li><a id="c555_b2-li-0942"></a><span class="KeyTerm1">find_divisor</span>, <i>43</i></li>
<li><a id="c555_b2-li-0943"></a><span class="KeyTerm1">first_agenda_item</span>, 248, <i>252</i></li>
<li><a id="c555_b2-li-0944"></a>first-class elements in language, 67</li>
<li><a id="c555_b2-li-0945"></a> <span class="KeyTerm1">first_conjunct</span>, <i>443</i></li>
<li><a id="c555_b2-li-0946"></a><span class="KeyTerm1">first_disjunct</span>,  <i>443</i></li>
<li><a id="c555_b2-li-0947"></a><span class="KeyTerm1">first_frame</span>, <i>341</i></li>
<li><a id="c555_b2-li-0948"></a><span class="KeyTerm1">first_segment</span>, <i>250</i></li>
<li><a id="c555_b2-li-0949"></a><span class="KeyTerm1">first_statement</span>, <i>332</i></li>
<li><a id="c555_b2-li-0950"></a><span class="KeyTerm1">first_term</span>, 179, <i>182</i></li>
<li><a id="c555_b2-li-0951"></a>fixed-length code, 140</li>
<li><a id="c555_b2-li-0952"></a><span class="KeyTerm1">fixed_point</span>, <i>60</i>
<ul class="none">
<li><a id="c555_b2-li-0953"></a>as iterative improvement, 68 (ex. 1.46)</li>
</ul></li>
<li><a id="c555_b2-li-0954"></a>fixed point, 60–61<ul class="none">
<li><a id="c555_b2-li-0955"></a>computing with calculator, 61<i>n</i></li>
<li><a id="c555_b2-li-0956"></a>of cosine, 61</li>
<li><a id="c555_b2-li-0957"></a>cube root as, 64</li>
<li><a id="c555_b2-li-0958"></a>fourth root as, 68 (ex. 1.45)</li>
<li><a id="c555_b2-li-0959"></a>golden ratio as, 62 (ex. 1.35)</li>
<li><a id="c555_b2-li-0960"></a>as iterative improvement, 68 (ex. 1.46)</li>
<li><a id="c555_b2-li-0961"></a>in Newton's method, 64</li>
<li><a id="c555_b2-li-0962"></a><i>n</i>th root as, 68 (ex. 1.45)</li>
<li><a id="c555_b2-li-0963"></a>square root as, 61, 63, 66</li>
<li><a id="c555_b2-li-0964"></a>of transformed function, 66</li>
<li><a id="c555_b2-li-0965"></a>unification and, 432<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0966"></a><span class="KeyTerm1">fixed_point_of_transform</span>, <i>66</i></li>
<li><a id="c555_b2-li-0967"></a><span class="KeyTerm1">flag</span> register, 472</li>
<li><a id="c555_b2-li-0968"></a><span class="KeyTerm1">flatmap</span>, <i>107</i></li>
<li><a id="c555_b2-li-0969"></a><span class="KeyTerm1">flatten_stream</span>, <i>436</i></li>
<li><a id="c555_b2-li-0970"></a><span class="KeyTerm1">flip_horiz</span>, 112, 122 (ex. 2.50)</li>
<li><a id="c555_b2-li-0971"></a><span class="KeyTerm1">flipped_pairs</span>, <i>114</i>, <i>117</i>, <i>117n</i></li>
<li><a id="c555_b2-li-0972"></a><span class="KeyTerm1">flip_vert</span>, 112, <i>121</i></li>
<li><a id="c555_b2-li-0973"></a>Floyd, Robert, 376<i>n</i></li>
<li><a id="c555_b2-li-0974"></a><span class="KeyTerm1">fold_left</span>, <i>106</i> (ex. 2.38)</li>
<li><a id="c555_b2-li-0975"></a><span class="KeyTerm1">fold_right</span>, 105 (ex. 2.38)</li>
<li><a id="c555_b2-li-0976"></a>Forbus, Kenneth D., 376<i>n</i></li>
<li><a id="c555_b2-li-0977"></a><span class="KeyTerm1">force_it</span>, <i>366</i>
<ul class="none">
<li><a id="c555_b2-li-0978"></a>memoized version, <i>367</i></li>
</ul></li>
<li><a id="c555_b2-li-0979"></a>forcing<ul class="none">
<li><a id="c555_b2-li-0980"></a>tail of stream, 283</li>
<li><a id="c555_b2-li-0981"></a>of thunk, 363</li>
</ul></li>
<li><a id="c555_b2-li-0982"></a><span class="KeyTerm1">for_each</span>, 92 (ex. 2.23), <i>369</i> (ex. 4.28)</li>
<li><a id="c555_b2-li-0983"></a><span class="KeyTerm1">for_each_except</span>, <i>260</i></li>
<li><a id="c555_b2-li-0984"></a><span class="KeyTerm1">forget_value</span>, 255, <i>261</i></li>
<li><a id="c555_b2-li-0985"></a>formal parameters, <i>see</i> parameters Fortran, 103<i>n</i>
<ul class="none">
<li><a id="c555_b2-li-0986"></a>inventor of, 314<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-0987"></a>forwarding address, 495</li>
<li><a id="c555_b2-li-0988"></a>fourth root, as fixed point, 68 (ex. 1.45)</li>
<li><a id="c555_b2-li-0989"></a>fraction, <i>see</i> rational number(s)</li>
<li><a id="c555_b2-li-0990"></a>frame (environment model), 206<ul class="none">
<li><a id="c555_b2-li-0991"></a>as repository of local state, 213–218</li>
<li><a id="c555_b2-li-0992"></a>global, 206</li>
</ul></li>
<li><a id="c555_b2-li-0993"></a>frame (picture language), 110, 117<ul class="none">
<li><a id="c555_b2-li-0994"></a>coordinate map, 117</li>
</ul></li>
<li><a id="c555_b2-li-0995"></a>frame (query interpreter), 412, <i>see also</i> pattern matching; unification<ul class="none">
<li><a id="c555_b2-li-0996"></a>representation, 444</li>
</ul></li>
<li><a id="c555_b2-li-0997"></a><span class="KeyTerm1">frame_coord_map</span>, <i>118</i></li>
<li><a id="c555_b2-li-0998"></a>framed-stack discipline, 504<i>n</i></li>
<li><a id="c555_b2-li-0999"></a><span class="KeyTerm1">frame_symbols</span>, <i>341</i></li>
<li><a id="c555_b2-li-1000"></a><span class="KeyTerm1">frame_values</span>, <i>341</i></li>
<li><a id="c555_b2-li-1001"></a><span class="KeyTerm1">free</span> register, 491, 495</li>
<li><a id="c555_b2-li-1002"></a>free list, 491<i>n</i></li>
<li><a id="c555_b2-li-1003"></a>free name, 23<ul class="none">
<li><a id="c555_b2-li-1004"></a>capturing, 24</li>
<li><a id="c555_b2-li-1005"></a>in internal declaration, 25</li>
</ul></li>
<li><a id="c555_b2-li-1006"></a>Friedman, Daniel P., 286<i>n</i>, 319<i>n</i></li>
<li><a id="c555_b2-li-1007"></a><span class="KeyTerm1">fringe</span>, 95 (ex. 2.28)<ul class="none">
<li><a id="c555_b2-li-1008"></a>as a tree enumeration, 101<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1009"></a><span class="KeyTerm1">front_ptr</span>, <i>232</i></li>
<li><a id="c555_b2-li-1010"></a><span class="KeyTerm1">front_queue</span>, 231, <i>233</i></li>
<li><a id="c555_b2-li-1011"></a>full-adder, 243<ul class="none">
<li><a id="c555_b2-li-1012"></a><span class="KeyTerm1">full_adder</span>, <i>243</i></li>
</ul></li>
<li><a id="c555_b2-li-1013"></a><span class="KeyTerm1">fun</span> register, 500</li>
<li><a id="c555_b2-li-1014"></a><span class="KeyTerm1"><b>function</b></span> (keyword), 8, <i>see also</i> function declaration</li>
<li><a id="c555_b2-li-1015"></a>function (JavaScript), 3, 8<ul class="none">
<li><a id="c555_b2-li-1016"></a>anonymous, 54</li>
<li><a id="c555_b2-li-1017"></a>as argument, 49–53</li>
<li><a id="c555_b2-li-1018"></a>as black box, 22–23</li>
<li><a id="c555_b2-li-1019"></a>body of, 9</li>
<li><a id="c555_b2-li-1020"></a>compound, 8</li>
<li><a id="c555_b2-li-1021"></a>creating with function declaration, 8</li>
<li><a id="c555_b2-li-1022"></a>creating with lambda expression, 54, 208, 210</li>
<li><a id="c555_b2-li-1023"></a>declaration of, 8–9</li>
<li><a id="c555_b2-li-1024"></a>first-class, 67</li>
<li><a id="c555_b2-li-1025"></a>as general method, 58–63</li>
<li><a id="c555_b2-li-1026"></a>generic, 143, 148</li>
<li><a id="c555_b2-li-1027"></a>higher-order, <i>see</i> higher-order function</li>
<li><a id="c555_b2-li-1028"></a>mathematical function vs., 18</li>
<li><a id="c555_b2-li-1029"></a>memoized, 240 (ex. 3.27)</li>
<li><a id="c555_b2-li-1030"></a>monitored, 196 (ex. 3.2)</li>
<li><a id="c555_b2-li-1031"></a>name of, 9</li>
<li><a id="c555_b2-li-1032"></a>naming (with function declaration), 8</li>
<li><a id="c555_b2-li-1033"></a>parameters of, 9</li>
<li><a id="c555_b2-li-1034"></a>as pattern for local evolution of a process, 26</li>
<li><a id="c555_b2-li-1035"></a>primitive, 10</li>
<li><a id="c555_b2-li-1036"></a>as returned value, 63–68</li>
<li><a id="c555_b2-li-1037"></a>returning multiple values, 475<i>n</i></li>
<li><a id="c555_b2-li-1038"></a>scope of parameters, 24</li>
<li><a id="c555_b2-li-1039"></a>syntactic form vs., 362 (ex. 4.24)</li>
</ul></li>
<li><a id="c555_b2-li-1040"></a>with any number of arguments, 276</li>
<li><a id="c555_b2-li-1041"></a>function (mathematical)<ul class="none">
<li><a id="c555_b2-li-1042"></a>↦ notation for, 61<i>n</i></li>
<li><a id="c555_b2-li-1043"></a>Ackermann's, 31 (ex. 1.10)</li>
<li><a id="c555_b2-li-1044"></a>composition of, 67 (ex. 1.42)</li>
<li><a id="c555_b2-li-1045"></a>derivative of, 64</li>
<li><a id="c555_b2-li-1046"></a>fixed point of, 60–61</li>
<li><a id="c555_b2-li-1047"></a>JavaScript function vs., 18</li>
<li><a id="c555_b2-li-1048"></a>rational, 184–188</li>
<li><a id="c555_b2-li-1049"></a>repeated application of, 68 (ex. 1.43)</li>
<li><a id="c555_b2-li-1050"></a>smoothing of, 68 (ex. 1.44)</li>
</ul></li>
<li><a id="c555_b2-li-1051"></a>functional abstraction, 22</li>
<li><a id="c555_b2-li-1052"></a>functional programming, 200, 311–315<ul class="none">
<li><a id="c555_b2-li-1053"></a>concurrency and, 314</li>
<li><a id="c555_b2-li-1054"></a>functional programming languages, 314</li>
<li><a id="c555_b2-li-1055"></a>time and, 313–315</li>
</ul></li>
<li><a id="c555_b2-li-1056"></a>functional representation of data, 78–80<ul class="none">
<li><a id="c555_b2-li-1057"></a>mutable data, 229–230</li>
</ul></li>
<li><a id="c555_b2-li-1058"></a>function application<ul class="none">
<li><a id="c555_b2-li-1059"></a>compound expression as function expression of, 17 (ex. 1.4)</li>
<li><a id="c555_b2-li-1060"></a>environment model of, 207, 210–213</li>
<li><a id="c555_b2-li-1061"></a>evaluation of, 9</li>
<li><a id="c555_b2-li-1062"></a>as function expression of application, 63<i>n</i></li>
<li><a id="c555_b2-li-1063"></a>parsing of, 331</li>
<li><a id="c555_b2-li-1064"></a>substitution model of, <i>see</i> substitution</li>
<li><a id="c555_b2-li-1065"></a>model of function application</li>
</ul></li>
<li><a id="c555_b2-li-1066"></a><span class="KeyTerm1">function_body</span>, <i>340</i></li>
<li><a id="c555_b2-li-1067"></a>function box, in digital circuit, 241</li>
<li><a id="c555_b2-li-1068"></a>function declaration, 8<ul class="none">
<li><a id="c555_b2-li-1069"></a>as derived component, 334</li>
<li><a id="c555_b2-li-1070"></a>hoisting of, 54<i>n</i>, 352 (ex. 4.17)</li>
<li><a id="c555_b2-li-1071"></a>lambda expression vs., 54</li>
<li><a id="c555_b2-li-1072"></a>parsing of, 334</li>
</ul></li>
<li><a id="c555_b2-li-1073"></a><span class="KeyTerm1">function_declaration_body</span>,  334</li>
<li><a id="c555_b2-li-1074"></a><span class="KeyTerm1">function_declaration_name</span>, 334</li>
<li><a id="c555_b2-li-1075"></a><span class="KeyTerm1">function_declaration_parameters</span>, 334</li>
<li><a id="c555_b2-li-1076"></a><span class="KeyTerm1">function_decl_to_constant_decl</span>, <i>334</i></li>
<li><a id="c555_b2-li-1077"></a><span class="KeyTerm1">function_environment</span>, <i>340</i></li>
<li><a id="c555_b2-li-1078"></a><span class="KeyTerm1">function_expression</span>, 331</li>
<li><a id="c555_b2-li-1079"></a>function expression, 9<ul class="none">
<li><a id="c555_b2-li-1080"></a>application as, 63<i>n</i></li>
<li><a id="c555_b2-li-1081"></a>compound expression as, 17 (ex. 1.4)</li>
<li><a id="c555_b2-li-1082"></a>lambda expression as, 55</li>
</ul></li>
<li><a id="c555_b2-li-1083"></a><span class="KeyTerm1">function_parameters</span>, <i>340</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-1084"></a>Gabriel, Richard P., 353<i>n</i></li>
<li><a id="c555_b2-li-1085"></a>garbage collection, 493–498<ul class="none">
<li><a id="c555_b2-li-1086"></a>memoization and, 366<i>n</i></li>
<li><a id="c555_b2-li-1087"></a>mutation and, 223<i>n</i></li>
<li><a id="c555_b2-li-1088"></a>tail recursion and, 541<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1089"></a>garbage collector<ul class="none">
<li><a id="c555_b2-li-1090"></a>compacting, 494<i>n</i></li>
<li><a id="c555_b2-li-1091"></a>mark-sweep, 494<i>n</i></li>
<li><a id="c555_b2-li-1092"></a>stop-and-copy, 493–498</li>
</ul></li>
<li><a id="c555_b2-li-1093"></a>Gargle, 378, 401</li>
<li><a id="c555_b2-li-1094"></a>GCD, <i>see</i> greatest common divisor</li>
<li><a id="c555_b2-li-1095"></a><span class="KeyTerm1">gcd</span>, <i>42</i>
<ul class="none">
<li><a id="c555_b2-li-1096"></a>register machine for, 450–452, 469</li>
</ul></li>
<li><a id="c555_b2-li-1097"></a><span class="KeyTerm1">gcd_machine</span>, <i>469</i></li>
<li><a id="c555_b2-li-1098"></a><span class="KeyTerm1">gcd_terms</span>, <i>186</i></li>
<li><a id="c555_b2-li-1099"></a>general-purpose computer, as universal machine, 519</li>
<li><a id="c555_b2-li-1100"></a><span class="KeyTerm1">generate_huffman_tree</span>, <i>146</i> (ex. 2.69)</li>
<li><a id="c555_b2-li-1101"></a>generating sentences, 385 (ex. 4.47)</li>
<li><a id="c555_b2-li-1102"></a>generic arithmetic operations, 164–169<ul class="none">
<li><a id="c555_b2-li-1103"></a>structure of system, 164 (fig. 2.23)</li>
</ul></li>
<li><a id="c555_b2-li-1104"></a>generic function, 143, 148<ul class="none">
<li><a id="c555_b2-li-1105"></a>generic selector, 154, 155</li>
</ul></li>
<li><a id="c555_b2-li-1106"></a>generic operation, 71</li>
<li><a id="c555_b2-li-1107"></a>generic types, <i>see</i> polymorphic types</li>
<li><a id="c555_b2-li-1108"></a>Genesis, 411 (ex. 4.61)</li>
<li><a id="c555_b2-li-1109"></a><span class="KeyTerm1">get</span>, 157, <i>239</i></li>
<li><a id="c555_b2-li-1110"></a><span class="KeyTerm1">get_contents</span>, <i>471</i></li>
<li><a id="c555_b2-li-1111"></a><span class="KeyTerm1">get_current_environment</span>, <i>514</i></li>
<li><a id="c555_b2-li-1112"></a><span class="KeyTerm1">get_register</span>, <i>472</i></li>
<li><a id="c555_b2-li-1113"></a><span class="KeyTerm1">get_register_contents</span>, 469, <i>472</i></li>
<li><a id="c555_b2-li-1114"></a><span class="KeyTerm1">get_signal</span>, 244, <i>247</i></li>
<li><a id="c555_b2-li-1115"></a><span class="KeyTerm1">get_time</span> (primitive function), 46 (ex. 1.22)</li>
<li><a id="c555_b2-li-1116"></a><span class="KeyTerm1">get_value</span>, 255, <i>261</i></li>
<li><a id="c555_b2-li-1117"></a>global environment, 207<ul class="none">
<li><a id="c555_b2-li-1118"></a>in metacircular evaluator, 344</li>
</ul></li>
<li><a id="c555_b2-li-1119"></a>global frame, 206</li>
<li><a id="c555_b2-li-1120"></a>Goguen, Joseph, 78<i>n</i></li>
<li><a id="c555_b2-li-1121"></a>golden ratio, 33<ul class="none">
<li><a id="c555_b2-li-1122"></a>as continued fraction, 62 (ex. 1.37)</li>
<li><a id="c555_b2-li-1123"></a>as fixed point, 62 (ex. 1.35)</li>
</ul></li>
<li><a id="c555_b2-li-1124"></a>good parts of JavaScript, 339<i>n</i></li>
<li><a id="c555_b2-li-1125"></a> Gordon, Michael, 310<i>n</i></li>
<li><a id="c555_b2-li-1126"></a><span class="KeyTerm1">go_to</span> (in register machine), 452<ul class="none">
<li><a id="c555_b2-li-1127"></a>destination in register, 459</li>
<li><a id="c555_b2-li-1128"></a>instruction constructor, <i>480</i></li>
<li><a id="c555_b2-li-1129"></a>simulating, 480</li>
</ul></li>
<li><a id="c555_b2-li-1130"></a><span class="KeyTerm1">go_to_dest</span>, <i>480</i></li>
<li><a id="c555_b2-li-1131"></a>grammar, 381</li>
<li><a id="c555_b2-li-1132"></a>graphics, <i>see</i> picture language</li>
<li><a id="c555_b2-li-1133"></a>Gray, Jim, 279<i>n</i></li>
<li><a id="c555_b2-li-1134"></a>greatest common divisor, 41–42, <i>see also</i> <span class="KeyTerm1">gcd</span>
<ul class="none">
<li><a id="c555_b2-li-1135"></a>generic, 186 (ex. 2.94)</li>
<li><a id="c555_b2-li-1136"></a>of polynomials, 185</li>
<li><a id="c555_b2-li-1137"></a>used to estimate <i>π</i>, 198</li>
<li><a id="c555_b2-li-1138"></a>used in rational-number arithmetic, 75</li>
<li><a id="c555_b2-li-1139"></a>Green, Cordell, 399<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1140"></a>Guttag, John Vogel, 79<i>n</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-1141"></a>half-adder, 242<ul class="none">
<li><a id="c555_b2-li-1142"></a><span class="KeyTerm1">half_adder</span>, <i>243</i></li>
<li><a id="c555_b2-li-1143"></a>simulation of, 248–249</li>
</ul></li>
<li><a id="c555_b2-li-1144"></a>half-interval method, 58–60<ul class="none">
<li><a id="c555_b2-li-1145"></a><span class="KeyTerm1">half_interval_method</span>, 60</li>
<li><a id="c555_b2-li-1146"></a>Newton's method vs., 64<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1147"></a>halting problem, 350 (ex. 4.15)</li>
<li><a id="c555_b2-li-1148"></a>Halting Theorem, 351<i>n</i></li>
<li><a id="c555_b2-li-1149"></a>Hamming, Richard Wesley, 142<i>n</i>, 292 (ex. 3.56)</li>
<li><a id="c555_b2-li-1150"></a>Hanson, Christopher P., 541<i>n</i></li>
<li><a id="c555_b2-li-1151"></a>Hardy, Godfrey Harold, 292<i>n</i>, 302<i>n</i></li>
<li><a id="c555_b2-li-1152"></a>Haskell, 90 (ex. 2.20), 310<i>n</i></li>
<li><a id="c555_b2-li-1153"></a>Hassle, 362<i>n</i></li>
<li><a id="c555_b2-li-1154"></a><span class="KeyTerm1">has_value</span>, 255, <i>261</i></li>
<li><a id="c555_b2-li-1155"></a>Havender, J., 279<i>n</i></li>
<li><a id="c555_b2-li-1156"></a>Haynes, Christopher T., 319<i>n</i></li>
<li><a id="c555_b2-li-1157"></a><span class="KeyTerm1">head</span> (primitive function), 73<ul class="none">
<li><a id="c555_b2-li-1158"></a>axiom for, 79</li>
<li><a id="c555_b2-li-1159"></a>functional implementation of, <i>79</i>, <i>80</i> (ex. 2.4), <i>229, 230</i>, <i>371</i></li>
<li><a id="c555_b2-li-1160"></a>implemented with vectors, 490</li>
<li><a id="c555_b2-li-1161"></a>as list operation, 86</li>
</ul></li>
<li><a id="c555_b2-li-1162"></a>headed list, 235, 250<i>n</i></li>
<li><a id="c555_b2-li-1163"></a>Henderson, Peter, 110<i>n</i>, 290<i>n</i>, 314<i>n</i>
<ul class="none">
<li><a id="c555_b2-li-1164"></a>Henderson diagram, 290</li>
</ul></li>
<li><a id="c555_b2-li-1165"></a>Henz, Martin, children of, 124</li>
<li><a id="c555_b2-li-1166"></a>Heraclitus, 189</li>
<li><a id="c555_b2-li-1167"></a>Heron of Alexandria, 19<i>n</i></li>
<li><a id="c555_b2-li-1168"></a>Hewitt, Carl Eddie, 30<i>n</i>, 376<i>n</i>, 399<i>n</i>, 494<i>n</i></li>
<li><a id="c555_b2-li-1169"></a>hiding principle, 193<i>n</i></li>
<li><a id="c555_b2-li-1170"></a>hierarchical data structures, 85, 93–96</li>
<li><a id="c555_b2-li-1171"></a>hierarchy of types, 172–176<ul class="none">
<li><a id="c555_b2-li-1172"></a>inadequacy of, 173</li>
<li><a id="c555_b2-li-1173"></a>in symbolic algebra, 184</li>
</ul></li>
<li><a id="c555_b2-li-1174"></a>higher-order functions, 49<ul class="none">
<li><a id="c555_b2-li-1175"></a>function as argument, 49–53</li>
<li><a id="c555_b2-li-1176"></a>function as general method, 58–63</li>
<li><a id="c555_b2-li-1177"></a>function as returned value, 63–68</li>
<li><a id="c555_b2-li-1178"></a>in metacircular evaluator, 325<i>n</i></li>
<li><a id="c555_b2-li-1179"></a>static typing and, 310<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1180"></a>high-level language, machine language vs., 318</li>
<li><a id="c555_b2-li-1181"></a>Hilfinger, Paul, 138<i>n</i></li>
<li><a id="c555_b2-li-1182"></a>Hoare, Charles Antony Richard, 78<i>n</i></li>
<li><a id="c555_b2-li-1183"></a>Hodges, Andrew, 349<i>n</i></li>
<li><a id="c555_b2-li-1184"></a>Hofstadter, Douglas R., 350<i>n</i></li>
<li><a id="c555_b2-li-1185"></a>hoisting of function declarations, 54<i>n</i>, 352 (ex. 4.17)</li>
<li><a id="c555_b2-li-1186"></a>Horner, W. G., 104<i>n</i></li>
<li><a id="c555_b2-li-1187"></a>Horner's rule, 103 (ex. 2.34)</li>
<li><a id="c555_b2-li-1188"></a>“how to” vs. “what is” description, <i>see</i> imperative vs. declarative knowledge</li>
<li><a id="c555_b2-li-1189"></a>Huffman, David, 141</li>
<li><a id="c555_b2-li-1190"></a>Huffman code, 140–147<ul class="none">
<li><a id="c555_b2-li-1191"></a>optimality of, 142</li>
<li><a id="c555_b2-li-1192"></a>order of growth of encoding, 147 (ex. 2.72)</li>
</ul></li>
<li><a id="c555_b2-li-1193"></a>Hughes, R. J. M., 371<i>n</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-1194"></a><span class="KeyTerm1">identity</span>, <i>50</i></li>
<li><a id="c555_b2-li-1195"></a><span class="KeyTerm1"><b>if</b></span> (keyword), 57, <i>see also</i> conditional statement</li>
<li><a id="c555_b2-li-1196"></a><span class="KeyTerm1">imag_part</span>
<ul class="none">
<li><a id="c555_b2-li-1197"></a>data-directed, <i>160</i></li>
<li><a id="c555_b2-li-1198"></a>polar representation, <i>152</i></li>
<li><a id="c555_b2-li-1199"></a>rectangular representation, <i>151</i></li>
<li><a id="c555_b2-li-1200"></a>with tagged data, <i>154</i></li>
</ul></li>
<li><a id="c555_b2-li-1201"></a><span class="KeyTerm1">imag_part_polar</span>, <i>154</i></li>
<li><a id="c555_b2-li-1202"></a><span class="KeyTerm1">imag_part_rectangular</span>, <i>153</i></li>
<li><a id="c555_b2-li-1203"></a>immediately invoked lambda expression, 217 (ex. 3.10)</li>
<li><a id="c555_b2-li-1204"></a>imperative programming, 204</li>
<li><a id="c555_b2-li-1205"></a>imperative vs. declarative knowledge, 18, 398<ul class="none">
<li><a id="c555_b2-li-1206"></a>logic programming and, 399–400, 419</li>
<li><a id="c555_b2-li-1207"></a>nondeterministic computing and, 373<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1208"></a>imperative vs. expression-oriented programming style, 262<i>n</i></li>
<li><a id="c555_b2-li-1209"></a><span class="KeyTerm1">inc</span>, <i>50</i></li>
<li><a id="c555_b2-li-1210"></a>incremental development of programs, 6</li>
<li><a id="c555_b2-li-1211"></a>indentation, 335 (ex. 4.2)</li>
<li><a id="c555_b2-li-1212"></a>indeterminate of a polynomial, 177</li>
<li><a id="c555_b2-li-1213"></a>indexing a data base, 413<i>n</i>, 434</li>
<li><a id="c555_b2-li-1214"></a>inference, method of, 419</li>
<li><a id="c555_b2-li-1215"></a>infinite series, 432<i>n</i></li>
<li><a id="c555_b2-li-1216"></a>infinite stream(s), 288–295<ul class="none">
<li><a id="c555_b2-li-1217"></a>merging, 293 (ex. 3.56), 300, 302 (ex. 3.70), 315</li>
<li><a id="c555_b2-li-1218"></a>merging as a relation, 315<i>n</i></li>
<li><a id="c555_b2-li-1219"></a>of factorials, 292 (ex. 3.54)</li>
<li><a id="c555_b2-li-1220"></a>of Fibonacci numbers, <i>see</i> <span class="KeyTerm1">fibs</span></li>
<li><a id="c555_b2-li-1221"></a>of integers, <i>see</i> <span class="KeyTerm1">integers</span></li>
<li><a id="c555_b2-li-1222"></a>of pairs, 299–302</li>
<li><a id="c555_b2-li-1223"></a>of prime numbers, <i>see</i> <span class="KeyTerm1">primes</span></li>
<li><a id="c555_b2-li-1224"></a>of random numbers, 312</li>
<li><a id="c555_b2-li-1225"></a>representing power series, 294 (ex. 3.59)</li>
<li><a id="c555_b2-li-1226"></a>to model signals, 302–305</li>
<li><a id="c555_b2-li-1227"></a>to sum a series, 296</li>
</ul></li>
<li><a id="c555_b2-li-1228"></a>infix notation, 4<ul class="none">
<li><a id="c555_b2-li-1229"></a>prefix notation vs., 131 (ex. 2.58)</li>
</ul></li>
<li><a id="c555_b2-li-1230"></a>infix operator, 4</li>
<li><a id="c555_b2-li-1231"></a><span class="KeyTerm1">inform_about_no_value</span>, <i>256</i></li>
<li><a id="c555_b2-li-1232"></a><span class="KeyTerm1">inform_about_value</span>, <i>256</i></li>
<li><a id="c555_b2-li-1233"></a>information retrieval, <i>see</i> data base</li>
<li><a id="c555_b2-li-1234"></a>Ingerman, Peter, 363<i>n</i></li>
<li><a id="c555_b2-li-1235"></a><span class="KeyTerm1">initialize_stack</span> operation in register machine, 472, 484</li>
<li><a id="c555_b2-li-1236"></a><span class="KeyTerm1">insert</span>
<ul class="none">
<li><a id="c555_b2-li-1237"></a>in one-dimensional table, <i>237</i></li>
<li><a id="c555_b2-li-1238"></a>in two-dimensional table, <i>238</i></li>
</ul></li>
<li><a id="c555_b2-li-1239"></a><span class="KeyTerm1">insert_queue</span>, 231, <i>233</i></li>
<li><a id="c555_b2-li-1240"></a><span class="KeyTerm1">install_complex_package</span>, <i>167</i></li>
<li><a id="c555_b2-li-1241"></a><span class="KeyTerm1">install_javascript_number_package</span>, <i>165</i></li>
<li><a id="c555_b2-li-1242"></a><span class="KeyTerm1">install_polar_package</span>, <i>159</i></li>
<li><a id="c555_b2-li-1243"></a><span class="KeyTerm1">install_polynomial_package</span>, <i>178</i></li>
<li><a id="c555_b2-li-1244"></a><span class="KeyTerm1">install_rational_package</span>, <i>166</i></li>
<li><a id="c555_b2-li-1245"></a><span class="KeyTerm1">install_rectangular_package</span>, <i>158</i></li>
<li><a id="c555_b2-li-1246"></a>instantiate a pattern, 404</li>
<li><a id="c555_b2-li-1247"></a><span class="KeyTerm1">instantiate_expression</span>, 425, <i>439</i></li>
<li><a id="c555_b2-li-1248"></a><span class="KeyTerm1">instantiate_term</span>, <i>440</i></li>
<li><a id="c555_b2-li-1249"></a><span class="KeyTerm1">inst_controller_instruction</span>, <i>476</i></li>
<li><a id="c555_b2-li-1250"></a><span class="KeyTerm1">inst_execution_fun</span>, <i>476</i></li>
<li><a id="c555_b2-li-1251"></a>instruction counting, 486 (ex. 5.14)</li>
<li><a id="c555_b2-li-1252"></a>instruction execution function, 472</li>
<li><a id="c555_b2-li-1253"></a><span class="KeyTerm1">instructions</span>, <i>543</i></li>
<li><a id="c555_b2-li-1254"></a>instruction sequence, 524–526, 543–546</li>
<li><a id="c555_b2-li-1255"></a>instruction tracing, 486 (ex. 5.15)</li>
<li><a id="c555_b2-li-1256"></a>integer(s), 3<i>n</i></li>
<li><a id="c555_b2-li-1257"></a>integerizing factor, 187</li>
<li><a id="c555_b2-li-1258"></a><span class="KeyTerm1">integers</span> (infinite stream), <i>288</i>
<ul class="none">
<li><a id="c555_b2-li-1259"></a>implicit definition, <i>290</i></li>
<li><a id="c555_b2-li-1260"></a>lazy-list version, <i>371</i></li>
</ul></li>
<li><a id="c555_b2-li-1261"></a><span class="KeyTerm1">integers_starting_from</span>, <i>288</i></li>
<li><a id="c555_b2-li-1262"></a><span class="KeyTerm1">integral</span>, <i>51</i>, <i>303</i>, <i>307</i> (ex. 3.77)<ul class="none">
<li><a id="c555_b2-li-1263"></a>with delayed argument, <i>307</i></li>
<li><a id="c555_b2-li-1264"></a>with lambda expression, <i>54</i></li>
<li><a id="c555_b2-li-1265"></a>lazy-list version, <i>372</i></li>
<li><a id="c555_b2-li-1266"></a>need for delayed evaluation, 305</li>
</ul></li>
<li><a id="c555_b2-li-1267"></a>integral, <i>see also</i> definite integral; Monte Carlo integration<ul class="none">
<li><a id="c555_b2-li-1268"></a>of a power series, 294 (ex. 3.59)</li>
</ul></li>
<li><a id="c555_b2-li-1269"></a>integrated-circuit implementation of Scheme, 499</li>
<li><a id="c555_b2-li-1270"></a><span class="KeyTerm1">integrate_series</span>, 294 (ex. 3.59)</li>
<li><a id="c555_b2-li-1271"></a>integrator, for signals, 303</li>
<li><a id="c555_b2-li-1272"></a><span class="KeyTerm1">interleave</span>, <i>301</i></li>
<li><a id="c555_b2-li-1273"></a><span class="KeyTerm1">interleave_delayed</span>, <i>435</i></li>
<li><a id="c555_b2-li-1274"></a>internal declaration, 25–26<ul class="none">
<li><a id="c555_b2-li-1275"></a>in environment model, 218–222</li>
<li><a id="c555_b2-li-1276"></a>free name in, 25</li>
<li><a id="c555_b2-li-1277"></a>names distinct from parameters, 336 (ex. 4.5)</li>
<li><a id="c555_b2-li-1278"></a>in nondeterministic evaluator, 391<i>n</i></li>
<li><a id="c555_b2-li-1279"></a>position of, 26<i>n</i></li>
<li><a id="c555_b2-li-1280"></a>restrictions on, 354</li>
<li><a id="c555_b2-li-1281"></a>scanning out, 352</li>
<li><a id="c555_b2-li-1282"></a>scope of name, 351–355</li>
</ul></li>
<li><a id="c555_b2-li-1283"></a>Internet “Worm”, 561<i>n</i></li>
<li><a id="c555_b2-li-1284"></a>interning strings, 490</li>
<li><a id="c555_b2-li-1285"></a>interpreter, 2, <i>see also</i> evaluator<ul class="none">
<li><a id="c555_b2-li-1286"></a>compiler vs., 520–521, 561</li>
<li><a id="c555_b2-li-1287"></a>read-evaluate-print loop, 5</li>
</ul></li>
<li><a id="c555_b2-li-1288"></a><span class="KeyTerm1">intersection_set</span>, 131<ul class="none">
<li><a id="c555_b2-li-1289"></a>binary-tree representation, 138 (ex. 2.65)</li>
<li><a id="c555_b2-li-1290"></a>ordered-list representation, <i>134</i></li>
<li><a id="c555_b2-li-1291"></a>unordered-list representation, <i>132</i></li>
</ul></li>
<li><a id="c555_b2-li-1292"></a>interval arithmetic, 81–84</li>
<li><a id="c555_b2-li-1293"></a>invariant quantity of an iterative process, 40 (ex. 1.16)</li>
<li><a id="c555_b2-li-1294"></a>inverter, 241<ul class="none">
<li><a id="c555_b2-li-1295"></a><span class="KeyTerm1">inverter</span>, <i>244</i></li>
</ul></li>
<li><a id="c555_b2-li-1296"></a><span class="KeyTerm1">is_</span>, in predicate names, 20<i>n</i></li>
<li><a id="c555_b2-li-1297"></a><span class="KeyTerm1">is_amb</span>, <i>387</i></li>
<li><a id="c555_b2-li-1298"></a><span class="KeyTerm1">is_application</span>, 331</li>
<li><a id="c555_b2-li-1299"></a><span class="KeyTerm1">is_assertion</span>, <i>443</i></li>
<li><a id="c555_b2-li-1300"></a><span class="KeyTerm1">is_assignment</span>, 333</li>
<li><a id="c555_b2-li-1301"></a><span class="KeyTerm1">is_block</span>, 333</li>
<li><a id="c555_b2-li-1302"></a><span class="KeyTerm1">is_boolean</span>, 339<i>n</i></li>
<li><a id="c555_b2-li-1303"></a><span class="KeyTerm1">is_compiled_function</span>, <i>532n</i></li>
<li><a id="c555_b2-li-1304"></a><span class="KeyTerm1">is_compound_function</span>, <i>340</i></li>
<li><a id="c555_b2-li-1305"></a><span class="KeyTerm1">is_conditional</span>, 331</li>
<li><a id="c555_b2-li-1306"></a><span class="KeyTerm1">is_constant_exp</span>, <i>482</i></li>
<li><a id="c555_b2-li-1307"></a><span class="KeyTerm1">is_declaration</span>, <i>334</i></li>
<li><a id="c555_b2-li-1308"></a><span class="KeyTerm1">is_divisible</span>, <i>288</i></li>
<li><a id="c555_b2-li-1309"></a><span class="KeyTerm1">is_element_of_set</span>, 131<ul class="none">
<li><a id="c555_b2-li-1310"></a>binary-tree representation, <i>136</i></li>
<li><a id="c555_b2-li-1311"></a>ordered-list representation, <i>134</i></li>
<li><a id="c555_b2-li-1312"></a>unordered-list representation, <i>132</i></li>
</ul></li>
<li><a id="c555_b2-li-1313"></a><span class="KeyTerm1">is_empty_agenda</span>, 248, <i>250</i></li>
<li><a id="c555_b2-li-1314"></a><span class="KeyTerm1">is_empty_conjunction</span>, <i>443</i></li>
<li><a id="c555_b2-li-1315"></a><span class="KeyTerm1">is_empty_disjunction</span>,  <i>443</i></li>
<li><a id="c555_b2-li-1316"></a><span class="KeyTerm1">is_empty_queue</span>, 231, <i>232</i></li>
<li><a id="c555_b2-li-1317"></a><span class="KeyTerm1">is_empty_sequence</span>, <i>332</i></li>
<li><a id="c555_b2-li-1318"></a><span class="KeyTerm1">is_empty_termlist</span>, 179, <i>182</i></li>
<li><a id="c555_b2-li-1319"></a><span class="KeyTerm1">is_equal</span> (generic predicate), 169 (ex. 2.79)</li>
<li><a id="c555_b2-li-1320"></a><span class="KeyTerm1">is_equal_to_zero</span> (generic), 169 (ex. 2.80)<ul class="none">
<li><a id="c555_b2-li-1321"></a>for polynomials, 182 (ex. 2.87)</li>
</ul></li>
<li><a id="c555_b2-li-1322"></a><span class="KeyTerm1">is_even</span>, <i>39</i></li>
<li><a id="c555_b2-li-1323"></a><span class="KeyTerm1">is_falsy</span>, <i>340</i>
<ul class="none">
<li><a id="c555_b2-li-1324"></a>full JavaScript version, <i>339n</i></li>
<li><a id="c555_b2-li-1325"></a>why used in explicit-control evaluator, <i>502n</i></li>
</ul></li>
<li><a id="c555_b2-li-1326"></a><span class="KeyTerm1">is_function_declaration</span>, 334</li>
<li><a id="c555_b2-li-1327"></a><span class="KeyTerm1">is_label_exp</span>, <i>482</i></li>
<li><a id="c555_b2-li-1328"></a><span class="KeyTerm1">is_lambda_expression</span>, 332</li>
<li><a id="c555_b2-li-1329"></a><span class="KeyTerm1">is_last_argument_expression</span>, <i>505n</i></li>
<li><a id="c555_b2-li-1330"></a><span class="KeyTerm1">is_last_statement</span>, <i>332</i></li>
<li><a id="c555_b2-li-1331"></a><span class="KeyTerm1">is_leaf</span>, <i>143</i></li>
<li><a id="c555_b2-li-1332"></a><span class="KeyTerm1">is_list_construction</span>, <i>442</i></li>
<li><a id="c555_b2-li-1333"></a><span class="KeyTerm1">is_literal</span>, <i>330</i></li>
<li><a id="c555_b2-li-1334"></a><span class="KeyTerm1">is_name</span>, 331</li>
<li><a id="c555_b2-li-1335"></a><span class="KeyTerm1">is_null</span> (primitive function), 87<ul class="none">
<li><a id="c555_b2-li-1336"></a>implemented with typed pointers, 491</li>
</ul></li>
<li><a id="c555_b2-li-1337"></a><span class="KeyTerm1">is_number</span> (primitive function), 127<ul class="none">
<li><a id="c555_b2-li-1338"></a>data types and, 168 (ex. 2.78)</li>
<li><a id="c555_b2-li-1339"></a>implemented with typed pointers, 491</li>
</ul></li>
<li><a id="c555_b2-li-1340"></a><span class="KeyTerm1">is_operation_exp</span>, <i>483</i></li>
<li><a id="c555_b2-li-1341"></a><span class="KeyTerm1">is_pair</span> (primitive function), 94<ul class="none">
<li><a id="c555_b2-li-1342"></a>implemented with typed pointers, 491</li>
</ul></li>
<li><a id="c555_b2-li-1343"></a><span class="KeyTerm1">is_polar</span>, <i>153</i></li>
<li><a id="c555_b2-li-1344"></a><span class="KeyTerm1">is_prime</span>, <i>43</i>, <i>291</i></li>
<li><a id="c555_b2-li-1345"></a><span class="KeyTerm1">is_primitive_function</span>, 340, <i>345</i></li>
<li><a id="c555_b2-li-1346"></a><span class="KeyTerm1">is_product</span>, <i>128</i></li>
<li><a id="c555_b2-li-1347"></a><span class="KeyTerm1">is_rectangular</span>, <i>153</i></li>
<li><a id="c555_b2-li-1348"></a><span class="KeyTerm1">is_register_exp</span>, <i>482</i></li>
<li><a id="c555_b2-li-1349"></a><span class="KeyTerm1">is_return_statement</span>, 333</li>
<li><a id="c555_b2-li-1350"></a><span class="KeyTerm1">is_return_value</span>, <i>340</i></li>
<li><a id="c555_b2-li-1351"></a><span class="KeyTerm1">is_rule</span>, <i>444</i></li>
<li><a id="c555_b2-li-1352"></a><span class="KeyTerm1">is_same_variable</span>, <i>128</i>, 178</li>
<li><a id="c555_b2-li-1353"></a><span class="KeyTerm1">is_sequence</span>, 332</li>
<li><a id="c555_b2-li-1354"></a><span class="KeyTerm1">is_string</span> (primitive function), 128<ul class="none">
<li><a id="c555_b2-li-1355"></a>data types and, 168 (ex. 2.78)</li>
<li><a id="c555_b2-li-1356"></a>implemented with typed pointers, 491</li>
</ul></li>
<li><a id="c555_b2-li-1357"></a><span class="KeyTerm1">is_sum</span>, <i>128</i></li>
<li><a id="c555_b2-li-1358"></a><span class="KeyTerm1">is_tagged_list</span>, <i>330</i></li>
<li><a id="c555_b2-li-1359"></a><span class="KeyTerm1">is_truthy</span>, 325, <i>340</i>
<ul class="none">
<li><a id="c555_b2-li-1360"></a>full JavaScript version, <i>339n</i></li>
</ul></li>
<li><a id="c555_b2-li-1361"></a><span class="KeyTerm1">is_undefined</span> (primitive function), 157</li>
<li><a id="c555_b2-li-1362"></a><span class="KeyTerm1">is_variable</span>
<ul class="none">
<li><a id="c555_b2-li-1363"></a>for algebraic expressions, <i>128</i></li>
<li><a id="c555_b2-li-1364"></a>in query system, <i>437</i></li>
</ul></li>
<li><a id="c555_b2-li-1365"></a>iteration contructs, <i>see</i> looping constructs</li>
<li><a id="c555_b2-li-1366"></a>iterative improvement, 68 (ex. 1.46)</li>
<li><a id="c555_b2-li-1367"></a>iterative process, 29<ul class="none">
<li><a id="c555_b2-li-1368"></a>as a stream process, 295–299</li>
<li><a id="c555_b2-li-1369"></a>design of algorithm, 40 (ex. 1.16)</li>
<li><a id="c555_b2-li-1370"></a>implemented by function call, 20, 30, 511, <i>see also</i> tail recursion</li>
<li><a id="c555_b2-li-1371"></a>linear, 29, 37</li>
<li><a id="c555_b2-li-1372"></a>recursive process vs., 27–30, 212 (ex. 3.9), 462, 549 (ex. 5.37)</li>
</ul></li>
<li><a id="c555_b2-li-1373"></a>register machine for, 462</li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-1374"></a>Jaffar, Joxan, 432<i>n</i></li>
<li><a id="c555_b2-li-1375"></a>Java, recursive functions in, 30</li>
<li><a id="c555_b2-li-1376"></a>JavaScript<ul class="none">
<li><a id="c555_b2-li-1377"></a>applicative-order evaluation in, 13</li>
<li><a id="c555_b2-li-1378"></a><span class="KeyTerm1">eval</span> in, <i>350</i></li>
<li><a id="c555_b2-li-1379"></a>first-class functions in, 67</li>
<li><a id="c555_b2-li-1380"></a>good parts, 339<i>n</i></li>
<li><a id="c555_b2-li-1381"></a>history of, 2</li>
<li><a id="c555_b2-li-1382"></a>internal type system, 168 (ex. 2.78)</li>
<li><a id="c555_b2-li-1383"></a>tail recursion in, 30<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1384"></a>JavaScript environment used in this book, 10</li>
<li><a id="c555_b2-li-1385"></a><span class="KeyTerm1">javascript_number</span> package, 165</li>
<li><a id="c555_b2-li-1386"></a><span class="KeyTerm1">javascript_number_to_complex</span>, <i>170</i></li>
<li><a id="c555_b2-li-1387"></a><span class="KeyTerm1">javascript_number_to_javascript_number</span>, <i>175</i> (ex. 2.81)</li>
<li><a id="c555_b2-li-1388"></a>JavaScript package <span class="KeyTerm1">sicp</span>, 10<i>n</i></li>
<li><a id="c555_b2-li-1389"></a><span class="KeyTerm1">javascript_predicate</span> (query interpreter), <i>427</i></li>
<li><a id="c555_b2-li-1390"></a><span class="KeyTerm1">javascript_predicate</span> (query language), 406, 422<ul class="none">
<li><a id="c555_b2-li-1391"></a>evaluation of, 415, 427, 446 (ex. 4.74)</li>
</ul></li>
<li><a id="c555_b2-li-1392"></a><span class="KeyTerm1">javascript_predicate_expression</span>, <i>443</i></li>
<li><a id="c555_b2-li-1393"></a>Jayaraman, Sundaresan, 252<i>n</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-1394"></a>Kaldewaij, Anne, 41<i>n</i></li>
<li><a id="c555_b2-li-1395"></a>Karr, Alphonse, 189</li>
<li><a id="c555_b2-li-1396"></a>Kepler, Johannes, 449</li>
<li><a id="c555_b2-li-1397"></a><span class="KeyTerm1">key</span>, 139</li>
<li><a id="c555_b2-li-1398"></a>key of a record<ul class="none">
<li><a id="c555_b2-li-1399"></a>in a data base, 139</li>
<li><a id="c555_b2-li-1400"></a>in a table, 235</li>
<li><a id="c555_b2-li-1401"></a>testing equality of, 240 (ex. 3.24)</li>
</ul></li>
<li><a id="c555_b2-li-1402"></a>keyword, 8</li>
<li><a id="c555_b2-li-1403"></a>keywords<ul class="none">
<li><a id="c555_b2-li-1404"></a><span class="KeyTerm1"><b>break</b></span>, 338 (ex. 4.7)</li>
<li><a id="c555_b2-li-1405"></a><span class="KeyTerm1"><b>const</b></span>, 5</li>
<li><a id="c555_b2-li-1406"></a><span class="KeyTerm1"><b>continue</b></span>, 338 (ex. 4.7)</li>
<li><a id="c555_b2-li-1407"></a><span class="KeyTerm1"><b>else</b></span>, 57</li>
<li><a id="c555_b2-li-1408"></a><span class="KeyTerm1"><b>false</b></span>, 14</li>
<li><a id="c555_b2-li-1409"></a><span class="KeyTerm1"><b>function</b></span>, 8</li>
<li><a id="c555_b2-li-1410"></a><span class="KeyTerm1"><b>if</b></span>, 57</li>
<li><a id="c555_b2-li-1411"></a><span class="KeyTerm1"><b>let</b></span>, 191</li>
<li><a id="c555_b2-li-1412"></a><span class="KeyTerm1"><b>null</b></span>, 85</li>
<li><a id="c555_b2-li-1413"></a><span class="KeyTerm1"><b>return</b></span>, 9</li>
<li><a id="c555_b2-li-1414"></a><span class="KeyTerm1"><b>true</b></span>, 14</li>
<li><a id="c555_b2-li-1415"></a><span class="KeyTerm1"><b>while</b></span>, 337 (ex. 4.7)</li>
</ul></li>
<li><a id="c555_b2-li-1416"></a>Knuth, Donald E., 40<i>n</i>, 42<i>n</i>, 104<i>n</i>, 197, 198<i>n</i></li>
<li><a id="c555_b2-li-1417"></a>Kolmogorov, A. N., 197<i>n</i></li>
<li><a id="c555_b2-li-1418"></a>Konopasek, Milos, 252<i>n</i></li>
<li><a id="c555_b2-li-1419"></a>Kowalski, Robert, 399<i>n</i></li>
<li><a id="c555_b2-li-1420"></a>KRC, 106<i>n</i>, 300<i>n</i></li>
<li><a id="c555_b2-li-1421"></a><span class="KeyTerm1">label</span> (in register machine), 452, <i>482</i>
<ul class="none">
<li><a id="c555_b2-li-1422"></a>simulating, 482</li>
</ul></li>
<li><a id="c555_b2-li-1423"></a><span class="KeyTerm1">label_exp_label</span>, <i>482</i></li>
<li><a id="c555_b2-li-1424"></a>Lagrange interpolation formula, 177<i>n</i></li>
<li><a id="c555_b2-li-1425"></a><i>λ</i> (lambda calculus), 55<i>n</i></li>
<li><a id="c555_b2-li-1426"></a><span class="KeyTerm1">lambda_body</span>, 332</li>
<li><a id="c555_b2-li-1427"></a>lambda expression, 54<ul class="none">
<li><a id="c555_b2-li-1428"></a>block as body of, 116<i>n</i></li>
<li><a id="c555_b2-li-1429"></a>as function expression of application, 55</li>
<li><a id="c555_b2-li-1430"></a>function declaration vs., 54</li>
<li><a id="c555_b2-li-1431"></a>immediately invoked, 217 (ex. 3.10)</li>
<li><a id="c555_b2-li-1432"></a>lazy evaluation and, 370</li>
<li><a id="c555_b2-li-1433"></a>parsing of, 332</li>
<li><a id="c555_b2-li-1434"></a>precedence of, 55</li>
<li><a id="c555_b2-li-1435"></a>value of, 210</li>
</ul></li>
<li><a id="c555_b2-li-1436"></a><span class="KeyTerm1">lambda_parameter_symbols</span>, <i>332</i></li>
<li><a id="c555_b2-li-1437"></a>Lambert, J.H., 63 (ex. 1.39)</li>
<li><a id="c555_b2-li-1438"></a>Lamé, Gabriel, 42<i>n</i></li>
<li><a id="c555_b2-li-1439"></a>Lamé's Theorem, 42</li>
<li><a id="c555_b2-li-1440"></a>Lamport, Leslie, 280<i>n</i></li>
<li><a id="c555_b2-li-1441"></a>Lampson, Butler, 204<i>n</i></li>
<li><a id="c555_b2-li-1442"></a>Landin, Peter, 15<i>n</i>, 286<i>n</i></li>
<li><a id="c555_b2-li-1443"></a>language, <i>see</i> parsing natural language; programming language</li>
<li><a id="c555_b2-li-1444"></a>Lapalme, Guy, 356<i>n</i></li>
<li><a id="c555_b2-li-1445"></a><span class="KeyTerm1">last_pair</span>, 89 (ex. 2.17), <i>225</i> (ex. 3.12)<ul class="none">
<li><a id="c555_b2-li-1446"></a>rules, 411 (ex. 4.60)</li>
</ul></li>
<li><a id="c555_b2-li-1447"></a>lazy evaluation, 361</li>
<li><a id="c555_b2-li-1448"></a>lazy evaluator, 360–370</li>
<li><a id="c555_b2-li-1449"></a>lazy list, 370–372</li>
<li><a id="c555_b2-li-1450"></a>lazy pair, 370–372</li>
<li><a id="c555_b2-li-1451"></a>lazy tree, 371<i>n</i></li>
<li><a id="c555_b2-li-1452"></a>least commitment, principle of, 152</li>
<li><a id="c555_b2-li-1453"></a>left-associative, 5</li>
<li><a id="c555_b2-li-1454"></a><span class="KeyTerm1">left_branch</span>, <i>136</i>, <i>143</i></li>
<li><a id="c555_b2-li-1455"></a>Leibniz, Baron Gottfried Wilhelm von proof of Fermat's Little Theorem, 44<i>n</i>
<ul class="none">
<li><a id="c555_b2-li-1456"></a>series for <i>π</i>, 49<i>n</i>, 296</li>
</ul></li>
<li><a id="c555_b2-li-1457"></a>Leiserson, Charles E., 137<i>n</i>, 302<i>n</i></li>
<li><a id="c555_b2-li-1458"></a><span class="KeyTerm1">length</span>, 87<ul class="none">
<li><a id="c555_b2-li-1459"></a>as accumulation, 103 (ex. 2.33)</li>
<li><a id="c555_b2-li-1460"></a>iterative version, <i>88</i></li>
<li><a id="c555_b2-li-1461"></a>recursive version, <i>88</i></li>
</ul></li>
<li><a id="c555_b2-li-1462"></a><span class="KeyTerm1"><b>let</b></span> (keyword), 191, <i>see also</i> variable, declaration</li>
<li><a id="c555_b2-li-1463"></a><span class="KeyTerm1"><b>let</b>*</span> (Scheme variant of <span class="KeyTerm1"><b>let</b></span>), 336 (ex. 4.6)</li>
<li><a id="c555_b2-li-1464"></a><span class="KeyTerm1">lexical_address_assign</span>, 555, 556 (ex. 5.42)</li>
<li><a id="c555_b2-li-1465"></a>lexical addressing, 554–555<ul class="none">
<li><a id="c555_b2-li-1466"></a>lexical address, 555</li>
</ul></li>
<li><a id="c555_b2-li-1467"></a><span class="KeyTerm1">lexical_address_lookup</span>, 555, 556 (ex. 5.42)</li>
<li><a id="c555_b2-li-1468"></a>lexical scoping, 25, <i>see also</i> scope of a name<ul class="none">
<li><a id="c555_b2-li-1469"></a>environment structure and, 554</li>
</ul></li>
<li><a id="c555_b2-li-1470"></a>Lieberman, Henry, 494<i>n</i></li>
<li><a id="c555_b2-li-1471"></a>LIFO buffer, <i>see</i> stack</li>
<li><a id="c555_b2-li-1472"></a>linear growth, 29, 37</li>
<li><a id="c555_b2-li-1473"></a>linear iterative process, 29<ul class="none">
<li><a id="c555_b2-li-1474"></a>order of growth, 37</li>
</ul></li>
<li><a id="c555_b2-li-1475"></a>linear recursive process, 29<ul class="none">
<li><a id="c555_b2-li-1476"></a>order of growth, 37</li>
</ul></li>
<li><a id="c555_b2-li-1477"></a>line segment<ul class="none">
<li><a id="c555_b2-li-1478"></a>represented as pair of points, 77 (ex. 2.2)</li>
<li><a id="c555_b2-li-1479"></a>represented as pair of vectors, 120 (ex. 2.48)</li>
</ul></li>
<li><a id="c555_b2-li-1480"></a>linkage descriptor, 523</li>
<li><a id="c555_b2-li-1481"></a>Liskov, Barbara Huberman, 79<i>n</i></li>
<li><a id="c555_b2-li-1482"></a>Lisp, <i>see also</i> Scheme<ul class="none">
<li><a id="c555_b2-li-1483"></a>as ancestor of JavaScript, 2</li>
<li><a id="c555_b2-li-1484"></a>on DEC PDP-1, 494<i>n</i></li>
<li><a id="c555_b2-li-1485"></a>efficiency of, 5<i>n</i></li>
<li><a id="c555_b2-li-1486"></a>MDL dialect of, 495<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1487"></a><span class="KeyTerm1">list</span> (primitive function), 86</li>
<li><a id="c555_b2-li-1488"></a>list(s), 86, <i>see also</i> list structure<ul class="none">
<li><a id="c555_b2-li-1489"></a>adjoining to with <span class="KeyTerm1">pair</span>, 88</li>
<li><a id="c555_b2-li-1490"></a>combining with <span class="KeyTerm1">append</span>, 88</li>
<li><a id="c555_b2-li-1491"></a>constructing with <span class="KeyTerm1">pair</span>, 88</li>
<li><a id="c555_b2-li-1492"></a>converting a binary tree to a, 137 (ex. 2.63)</li>
<li><a id="c555_b2-li-1493"></a>converting to a binary tree, 137 (ex. 2.64)</li>
<li><a id="c555_b2-li-1494"></a>empty, <i>see</i> empty list equality of, 125 (ex. 2.54)</li>
<li><a id="c555_b2-li-1495"></a>headed, 235, 250<i>n</i></li>
<li><a id="c555_b2-li-1496"></a>last pair of, 89 (ex. 2.17)</li>
<li><a id="c555_b2-li-1497"></a>lazy, 370–372</li>
<li><a id="c555_b2-li-1498"></a>length of, 87</li>
<li><a id="c555_b2-li-1499"></a>list structure vs., 86<i>n</i></li>
<li><a id="c555_b2-li-1500"></a>manipulation with <span class="KeyTerm1">head</span>, <span class="KeyTerm1">tail</span>, and <span class="KeyTerm1">pair</span>, 86</li>
<li><a id="c555_b2-li-1501"></a>mapping over, 90–92</li>
<li><a id="c555_b2-li-1502"></a><i>n</i>th element of, 87</li>
<li><a id="c555_b2-li-1503"></a>operations on, 87–90</li>
<li><a id="c555_b2-li-1504"></a>printed representation of, 86</li>
<li><a id="c555_b2-li-1505"></a>reversing, 89 (ex. 2.18)</li>
<li><a id="c555_b2-li-1506"></a>techniques for manipulating, 87–90</li>
<li><a id="c555_b2-li-1507"></a>walking down with <span class="KeyTerm1">tail</span>, 87</li>
</ul></li>
<li><a id="c555_b2-li-1508"></a><span class="KeyTerm1">list_difference</span>,  <i>544</i></li>
<li><a id="c555_b2-li-1509"></a>list notation for data, 87</li>
<li><a id="c555_b2-li-1510"></a><span class="KeyTerm1">list_of_arg_values</span>, <i>364</i></li>
<li><a id="c555_b2-li-1511"></a><span class="KeyTerm1">list_of_delayed_args</span>, <i>364</i></li>
<li><a id="c555_b2-li-1512"></a><span class="KeyTerm1">list_of_values</span>, <i>325</i>
<ul class="none">
<li><a id="c555_b2-li-1513"></a>without higher-order functions, <i>325n</i></li>
</ul></li>
<li><a id="c555_b2-li-1514"></a><span class="KeyTerm1">list_ref</span>, <i>87</i>, <i>371</i></li>
<li><a id="c555_b2-li-1515"></a>list structure, 74, <i>see also</i> list(s)<ul class="none">
<li><a id="c555_b2-li-1516"></a>list vs., 86<i>n</i></li>
<li><a id="c555_b2-li-1517"></a>mutable, 222–226</li>
<li><a id="c555_b2-li-1518"></a>represented using vectors, 488–492</li>
</ul></li>
<li><a id="c555_b2-li-1519"></a>list-structured memory, 487–498</li>
<li><a id="c555_b2-li-1520"></a><span class="KeyTerm1">list_to_tree</span>, <i>138</i> (ex. 2.64)</li>
<li><a id="c555_b2-li-1521"></a><span class="KeyTerm1">list_union</span>, <i>544</i></li>
<li><a id="c555_b2-li-1522"></a>literal expression, 322<ul class="none">
<li><a id="c555_b2-li-1523"></a>parsing of, 330</li>
</ul></li>
<li><a id="c555_b2-li-1524"></a><span class="KeyTerm1">literal_value</span>, <i>330</i></li>
<li><a id="c555_b2-li-1525"></a><span class="KeyTerm1">lives_near</span> (rule), <i>407</i>, 409 (ex. 4.58)</li>
<li><a id="c555_b2-li-1526"></a>local evolution of a process, 26</li>
<li><a id="c555_b2-li-1527"></a>local name, 23–24, 55–56</li>
<li><a id="c555_b2-li-1528"></a>local state, 190–206<ul class="none">
<li><a id="c555_b2-li-1529"></a>maintained in frames, 213–218</li>
</ul></li>
<li><a id="c555_b2-li-1530"></a>local state variable, 190–197</li>
<li><a id="c555_b2-li-1531"></a>location, 488</li>
<li><a id="c555_b2-li-1532"></a>Locke, John, 1</li>
<li><a id="c555_b2-li-1533"></a>logarithm, approximating ln 2, 299 (ex. 3.65)</li>
<li><a id="c555_b2-li-1534"></a>logarithmic growth, 37, 39, 135<i>n</i></li>
<li><a id="c555_b2-li-1535"></a>logical and (digital logic), 241</li>
<li><a id="c555_b2-li-1536"></a>logical conjunction, 15, <i>see also</i> <span class="KeyTerm1">&amp;&amp;</span> (logical conjunction)</li>
<li><a id="c555_b2-li-1537"></a>logical disjunction, 15, <i>see also</i> <span class="KeyTerm1">||</span> (logical disjunction)</li>
<li><a id="c555_b2-li-1538"></a><span class="KeyTerm1">logical_not</span>, <i>244</i></li>
<li><a id="c555_b2-li-1539"></a>logical or (digital logic), 241</li>
<li><a id="c555_b2-li-1540"></a>logic programming, 398–400, <i>see also</i> query interpreter; query language<ul class="none">
<li><a id="c555_b2-li-1541"></a>computers for, 400<i>n</i></li>
<li><a id="c555_b2-li-1542"></a>history of, 398<i>n</i>, 400<i>n</i></li>
<li><a id="c555_b2-li-1543"></a>in Japan, 400<i>n</i></li>
<li><a id="c555_b2-li-1544"></a>logic programming languages, 400</li>
<li><a id="c555_b2-li-1545"></a>mathematical logic vs., 419–424</li>
</ul></li>
<li><a id="c555_b2-li-1546"></a>logic puzzles, 378–380</li>
<li><a id="c555_b2-li-1547"></a><span class="KeyTerm1">lookup</span>
<ul class="none">
<li><a id="c555_b2-li-1548"></a>in one-dimensional table, <i>236</i></li>
<li><a id="c555_b2-li-1549"></a>in set of records, <i>139</i></li>
<li><a id="c555_b2-li-1550"></a>in two-dimensional table, <i>237</i></li>
</ul></li>
<li><a id="c555_b2-li-1551"></a><span class="KeyTerm1">lookup_label</span>, <i>476</i></li>
<li><a id="c555_b2-li-1552"></a><span class="KeyTerm1">lookup_prim</span>, <i>483</i></li>
<li><a id="c555_b2-li-1553"></a><span class="KeyTerm1">lookup_symbol_value</span>, 341, <i>342</i>
<ul class="none">
<li><a id="c555_b2-li-1554"></a>for scanned-out declarations, 344 (ex. 4.12)</li>
</ul></li>
<li><a id="c555_b2-li-1555"></a>looping constructs, 20, 30, <i>see also</i> while loop</li>
<li><a id="c555_b2-li-1556"></a><span class="KeyTerm1">lower_bound</span>, 82 (ex. 2.7)</li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-1557"></a>machine language, 520<ul class="none">
<li><a id="c555_b2-li-1558"></a>high-level language vs., 318</li>
</ul></li>
<li><a id="c555_b2-li-1559"></a>magician, <i>see</i> numerical analyst</li>
<li><a id="c555_b2-li-1560"></a><span class="KeyTerm1">magnitude</span>
<ul class="none">
<li><a id="c555_b2-li-1561"></a>data-directed, <i>160</i></li>
<li><a id="c555_b2-li-1562"></a>polar representation, <i>152</i></li>
<li><a id="c555_b2-li-1563"></a>rectangular representation, <i>151</i></li>
<li><a id="c555_b2-li-1564"></a>with tagged data, <i>154</i></li>
</ul></li>
<li><a id="c555_b2-li-1565"></a><span class="KeyTerm1">magnitude_polar</span>, <i>154</i></li>
<li><a id="c555_b2-li-1566"></a><span class="KeyTerm1">magnitude_rectangular</span>, <i>153</i></li>
<li><a id="c555_b2-li-1567"></a><span class="KeyTerm1">make_account</span>, <i>195</i>
<ul class="none">
<li><a id="c555_b2-li-1568"></a>in environment model, 220 (ex. 3.11)</li>
<li><a id="c555_b2-li-1569"></a>with serialization, <i>270</i>, <i>271</i> (ex. 3.41), <i>272</i> (ex. 3.42)</li>
</ul></li>
<li><a id="c555_b2-li-1570"></a><span class="KeyTerm1">make_account_and_serializer</span>, <i>273</i></li>
<li><a id="c555_b2-li-1571"></a><span class="KeyTerm1">make_accumulator</span>, 196 (ex. 3.1)</li>
<li><a id="c555_b2-li-1572"></a><span class="KeyTerm1">make_agenda</span>, 248, <i>250</i></li>
<li><a id="c555_b2-li-1573"></a><span class="KeyTerm1">make_application</span>, <i>331</i></li>
<li><a id="c555_b2-li-1574"></a><span class="KeyTerm1">make_assign_ef</span>, <i>478</i></li>
<li><a id="c555_b2-li-1575"></a><span class="KeyTerm1">make_binding</span>, <i>444</i></li>
<li><a id="c555_b2-li-1576"></a><span class="KeyTerm1">make_branch_ef</span>, <i>480</i></li>
<li><a id="c555_b2-li-1577"></a><span class="KeyTerm1">make_center_percent</span>, 83 (ex. 2.12)</li>
<li><a id="c555_b2-li-1578"></a><span class="KeyTerm1">make_center_width</span>, <i>83</i></li>
<li><a id="c555_b2-li-1579"></a><span class="KeyTerm1">make_code_tree</span>, <i>143</i></li>
<li><a id="c555_b2-li-1580"></a><span class="KeyTerm1">make_compiled_function</span>, <i>532n</i></li>
<li><a id="c555_b2-li-1581"></a><span class="KeyTerm1">make_complex_from_mag_ang</span>, <i>167</i></li>
<li><a id="c555_b2-li-1582"></a><span class="KeyTerm1">make_complex_from_real_imag</span>, <i>167</i></li>
<li><a id="c555_b2-li-1583"></a><span class="KeyTerm1">make_connector</span>, <i>259</i></li>
<li><a id="c555_b2-li-1584"></a><span class="KeyTerm1">make_constant_declaration</span>, <i>334</i></li>
<li><a id="c555_b2-li-1585"></a><span class="KeyTerm1">make_cycle</span>, <i>226</i> (ex. 3.13)</li>
<li><a id="c555_b2-li-1586"></a><span class="KeyTerm1">make_decrementer</span>, <i>201</i></li>
<li><a id="c555_b2-li-1587"></a><span class="KeyTerm1">make_execution_function</span>, <i>477</i></li>
<li><a id="c555_b2-li-1588"></a><span class="KeyTerm1">make_frame</span>, 117, <i>119</i> (ex. 2.47), <i>341</i></li>
<li><a id="c555_b2-li-1589"></a><span class="KeyTerm1">make_from_mag_ang</span>, <i>155</i>, <i>160</i>
<ul class="none">
<li><a id="c555_b2-li-1590"></a>message-passing, 163 (ex. 2.75)</li>
<li><a id="c555_b2-li-1591"></a>polar representation, <i>152</i></li>
<li><a id="c555_b2-li-1592"></a>rectangular representation, <i>151</i></li>
</ul></li>
<li><a id="c555_b2-li-1593"></a><span class="KeyTerm1">make_from_mag_ang_polar</span>, <i>154</i></li>
<li><a id="c555_b2-li-1594"></a><span class="KeyTerm1">make_from_mag_ang_rectangular</span>, <i>153</i></li>
<li><a id="c555_b2-li-1595"></a><span class="KeyTerm1">make_from_real_imag</span>, <i>155</i>, <i>160</i>
<ul class="none">
<li><a id="c555_b2-li-1596"></a>message-passing, <i>162</i></li>
<li><a id="c555_b2-li-1597"></a>polar representation, <i>152</i></li>
<li><a id="c555_b2-li-1598"></a>rectangular representation, <i>151</i></li>
</ul></li>
<li><a id="c555_b2-li-1599"></a><span class="KeyTerm1">make_from_real_imag_polar</span>, <i>154</i></li>
<li><a id="c555_b2-li-1600"></a><span class="KeyTerm1">make_from_real_imag_rectangular</span>, <i>153</i></li>
<li><a id="c555_b2-li-1601"></a><span class="KeyTerm1">make_function</span>, <i>340</i></li>
<li><a id="c555_b2-li-1602"></a><span class="KeyTerm1">make_go_to_ef</span>, <i>480</i></li>
<li><a id="c555_b2-li-1603"></a><span class="KeyTerm1">make_inst</span>, <i>476</i></li>
<li><a id="c555_b2-li-1604"></a><span class="KeyTerm1">make_instruction_sequence</span>, <i>526</i></li>
<li><a id="c555_b2-li-1605"></a><span class="KeyTerm1">make_interval</span>, 81, <i>82</i> (ex. 2.7)</li>
<li><a id="c555_b2-li-1606"></a><span class="KeyTerm1">make_javascript_number</span>, <i>165</i></li>
<li><a id="c555_b2-li-1607"></a><span class="KeyTerm1">make_joint</span>, 205 (ex. 3.7)</li>
<li><a id="c555_b2-li-1608"></a><span class="KeyTerm1">make_label</span>, <i>530n</i></li>
<li><a id="c555_b2-li-1609"></a><span class="KeyTerm1">make_label_entry</span>, <i>476</i></li>
<li><a id="c555_b2-li-1610"></a><span class="KeyTerm1">make_lambda_expression</span>, <i>332</i></li>
<li><a id="c555_b2-li-1611"></a><span class="KeyTerm1">make_leaf</span>, <i>143</i></li>
<li><a id="c555_b2-li-1612"></a><span class="KeyTerm1">make_leaf_set</span>, <i>145</i></li>
<li><a id="c555_b2-li-1613"></a><span class="KeyTerm1">make_literal</span>, <i>330</i></li>
<li><a id="c555_b2-li-1614"></a><span class="KeyTerm1">make_machine</span>, 468, <i>470</i></li>
<li><a id="c555_b2-li-1615"></a><span class="KeyTerm1">make_monitored</span>, 196 (ex. 3.2)</li>
<li><a id="c555_b2-li-1616"></a><span class="KeyTerm1">make_mutex</span>, <i>277</i></li>
<li><a id="c555_b2-li-1617"></a><span class="KeyTerm1">make_name</span>, <i>331</i></li>
<li><a id="c555_b2-li-1618"></a><span class="KeyTerm1">make_new_machine</span>, 473 (fig. 5.13)</li>
<li><a id="c555_b2-li-1619"></a><span class="KeyTerm1">make_new_variable</span>, <i>438</i></li>
<li><a id="c555_b2-li-1620"></a><span class="KeyTerm1">make_operation_exp_ef</span>, <i>482</i></li>
<li><a id="c555_b2-li-1621"></a><span class="KeyTerm1">make_perform_ef</span>, <i>481</i></li>
<li><a id="c555_b2-li-1622"></a><span class="KeyTerm1">make_point</span>, 77 (ex. 2.2)</li>
<li><a id="c555_b2-li-1623"></a><span class="KeyTerm1">make_poly</span>, <i>178</i></li>
<li><a id="c555_b2-li-1624"></a><span class="KeyTerm1">make_polynomial</span>, <i>182</i></li>
<li><a id="c555_b2-li-1625"></a><span class="KeyTerm1">make_primitive_exp_ef</span>, <i>482</i></li>
<li><a id="c555_b2-li-1626"></a><span class="KeyTerm1">make_product</span>, <i>128</i>, <i>130</i></li>
<li><a id="c555_b2-li-1627"></a><span class="KeyTerm1">make_queue</span>, 231, <i>233</i></li>
<li><a id="c555_b2-li-1628"></a><span class="KeyTerm1">make_rat</span>, 72, <i>74</i>, <i>77</i>
<ul class="none">
<li><a id="c555_b2-li-1629"></a>axiom for, 78</li>
<li><a id="c555_b2-li-1630"></a>reducing to lowest terms, <i>75</i></li>
</ul></li>
<li><a id="c555_b2-li-1631"></a><span class="KeyTerm1">make_rational</span>, <i>166</i></li>
<li><a id="c555_b2-li-1632"></a><span class="KeyTerm1">make_register</span>, <i>470</i></li>
<li><a id="c555_b2-li-1633"></a><span class="KeyTerm1">make_restore_ef</span>, <i>481</i></li>
<li><a id="c555_b2-li-1634"></a><span class="KeyTerm1">make_return_value</span>, <i>340</i></li>
<li><a id="c555_b2-li-1635"></a><span class="KeyTerm1">make_save_ef</span>, <i>481</i></li>
<li><a id="c555_b2-li-1636"></a><span class="KeyTerm1">make_segment</span>, 77 (ex. 2.2), 120 (ex. 2.48)</li>
<li><a id="c555_b2-li-1637"></a><span class="KeyTerm1">make_serializer</span>, <i>276</i></li>
<li><a id="c555_b2-li-1638"></a><span class="KeyTerm1">make_simplified_withdraw</span>, <i>201</i>, <i>313</i></li>
<li><a id="c555_b2-li-1639"></a><span class="KeyTerm1">make_stack</span>, <i>471</i>
<ul class="none">
<li><a id="c555_b2-li-1640"></a>with monitored stack, <i>485</i> <span class="KeyTerm1">make_sum</span>, <i>128, 129</i></li>
</ul></li>
<li><a id="c555_b2-li-1641"></a><span class="KeyTerm1">make_table</span>
<ul class="none">
<li><a id="c555_b2-li-1642"></a>message-passing implementation, <i>239</i></li>
<li><a id="c555_b2-li-1643"></a>one-dimensional table, <i>237</i></li>
</ul></li>
<li><a id="c555_b2-li-1644"></a><span class="KeyTerm1">make_tableau</span>, <i>297</i></li>
<li><a id="c555_b2-li-1645"></a><span class="KeyTerm1">make_term</span>, 179, <i>182</i></li>
<li><a id="c555_b2-li-1646"></a><span class="KeyTerm1">make_test_ef</span>, <i>479</i></li>
<li><a id="c555_b2-li-1647"></a><span class="KeyTerm1">make_time_segment</span>, <i>250</i></li>
<li><a id="c555_b2-li-1648"></a><span class="KeyTerm1">make_tree</span>, <i>136</i></li>
<li><a id="c555_b2-li-1649"></a><span class="KeyTerm1">make_vect</span>, 118 (ex. 2.46)</li>
<li><a id="c555_b2-li-1650"></a><span class="KeyTerm1">make_wire</span>, 242, <i>246</i>, 249 (ex. 3.31)</li>
<li><a id="c555_b2-li-1651"></a><span class="KeyTerm1">make_withdraw</span>, <i>194</i>
<ul class="none">
<li><a id="c555_b2-li-1652"></a>in environment model, 213–218</li>
<li><a id="c555_b2-li-1653"></a>using immediately invoked lambda expression, <i>217</i> (ex. 3.10)</li>
</ul></li>
<li><a id="c555_b2-li-1654"></a>making change, <i>see</i> counting change</li>
<li><a id="c555_b2-li-1655"></a><span class="KeyTerm1">map</span>, <i>91</i>, <i>371</i>
<ul class="none">
<li><a id="c555_b2-li-1656"></a>as accumulation, 103 (ex. 2.33)</li>
</ul></li>
<li><a id="c555_b2-li-1657"></a>mapping<ul class="none">
<li><a id="c555_b2-li-1658"></a>over lists, 90–92</li>
<li><a id="c555_b2-li-1659"></a>nested, 106–110, 299–302</li>
<li><a id="c555_b2-li-1660"></a>as a transducer, 100</li>
<li><a id="c555_b2-li-1661"></a>over trees, 96–98</li>
</ul></li>
<li><a id="c555_b2-li-1662"></a><span class="KeyTerm1">map_successive_pairs</span>, <i>312</i></li>
<li><a id="c555_b2-li-1663"></a>mark-sweep garbage collector, 494<i>n</i> <span class="KeyTerm1">math_atan2</span> (primitive function), 151<i>n</i> <span class="KeyTerm1">math_cos</span> (primitive function), 61</li>
<li><a id="c555_b2-li-1664"></a>mathematical function, <i>see</i> function (mathematical)</li>
<li><a id="c555_b2-li-1665"></a>mathematics<ul class="none">
<li><a id="c555_b2-li-1666"></a>computer science vs., 18, 398</li>
<li><a id="c555_b2-li-1667"></a>engineering vs., 45<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1668"></a><span class="KeyTerm1">math_floor</span> (primitive function), 45</li>
<li><a id="c555_b2-li-1669"></a><span class="KeyTerm1">math_log</span> (primitive function), 10, 62 (ex. 1.36)</li>
<li><a id="c555_b2-li-1670"></a><span class="KeyTerm1">math_max</span> (primitive function), 81</li>
<li><a id="c555_b2-li-1671"></a><span class="KeyTerm1">math_min</span> (primitive function), 81</li>
<li><a id="c555_b2-li-1672"></a><span class="KeyTerm1">math_random</span> (primitive function), 44<ul class="none">
<li><a id="c555_b2-li-1673"></a>assignment needed for, 191<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1674"></a><span class="KeyTerm1">math_round</span> (primitive function), 176<i>n</i></li>
<li><a id="c555_b2-li-1675"></a><span class="KeyTerm1">math_sin</span> (primitive function), 61</li>
<li><a id="c555_b2-li-1676"></a><span class="KeyTerm1">math_trunc</span> (primitive function), 293 (ex. 3.58)</li>
<li><a id="c555_b2-li-1677"></a>matrix, represented as sequence, 105 (ex. 2.37)</li>
<li><a id="c555_b2-li-1678"></a><span class="KeyTerm1">matrix_times_matrix</span>, 105 (ex. 2.37)</li>
<li><a id="c555_b2-li-1679"></a><span class="KeyTerm1">matrix_times_vector</span>, 105 (ex. 2.37)</li>
<li><a id="c555_b2-li-1680"></a>McAllester, David Allen, 376<i>n</i></li>
<li><a id="c555_b2-li-1681"></a>McCarthy, John, 374<i>n</i></li>
<li><a id="c555_b2-li-1682"></a>McDermott, Drew, 376<i>n</i></li>
<li><a id="c555_b2-li-1683"></a>MDL, 495<i>n</i></li>
<li><a id="c555_b2-li-1684"></a>means of abstraction, 3<ul class="none">
<li><a id="c555_b2-li-1685"></a>constant declaration as, 6</li>
</ul></li>
<li><a id="c555_b2-li-1686"></a>means of combination, 3, <i>see also</i> closure</li>
<li><a id="c555_b2-li-1687"></a>measure in a Euclidean ring, 185<i>n</i></li>
<li><a id="c555_b2-li-1688"></a><span class="KeyTerm1">member</span>, <i>125</i>
<ul class="none">
<li><a id="c555_b2-li-1689"></a>extended to use pointer equality, 260<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1690"></a><span class="KeyTerm1">memo</span>, <i>286</i></li>
<li><a id="c555_b2-li-1691"></a><span class="KeyTerm1">memo_fib</span>, <i>240</i> (ex. 3.27)</li>
<li><a id="c555_b2-li-1692"></a>memoization, 35<i>n</i>, 240 (ex. 3.27)<ul class="none">
<li><a id="c555_b2-li-1693"></a>call-by-need and, 293<i>n</i></li>
<li><a id="c555_b2-li-1694"></a>garbage collection and, 366<i>n</i></li>
<li><a id="c555_b2-li-1695"></a>in stream tail, 286</li>
<li><a id="c555_b2-li-1696"></a>of thunks, 363</li>
</ul></li>
<li><a id="c555_b2-li-1697"></a><span class="KeyTerm1">memoize</span>, <i>241</i> (ex. 3.27)</li>
<li><a id="c555_b2-li-1698"></a>memory<ul class="none">
<li><a id="c555_b2-li-1699"></a>in 1965, 375<i>n</i></li>
<li><a id="c555_b2-li-1700"></a>list-structured, 487–498</li>
</ul></li>
<li><a id="c555_b2-li-1701"></a><span class="KeyTerm1">merge</span>, <i>293</i> (ex. 3.56)</li>
<li><a id="c555_b2-li-1702"></a><span class="KeyTerm1">merge_weighted</span>, 302 (ex. 3.70)</li>
<li><a id="c555_b2-li-1703"></a>merging infinite streams, <i>see</i> infinite stream(s)</li>
<li><a id="c555_b2-li-1704"></a>message passing, 80, 162–164<ul class="none">
<li><a id="c555_b2-li-1705"></a>environment model and, 220 (ex. 3.11)</li>
<li><a id="c555_b2-li-1706"></a>in bank account, 195</li>
<li><a id="c555_b2-li-1707"></a>in digital-circuit simulation, 246</li>
<li><a id="c555_b2-li-1708"></a>tail recursion and, 30<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1709"></a>metacircular evaluator, 320</li>
<li><a id="c555_b2-li-1710"></a>metacircular evaluator for JavaScript, 319–351<ul class="none">
<li><a id="c555_b2-li-1711"></a><span class="KeyTerm1">&amp;&amp;</span> (logical conjunction), 336 (ex. 4.4)</li>
<li><a id="c555_b2-li-1712"></a><span class="KeyTerm1">||</span> (logical disjunction), 336 (ex. 4.4)</li>
<li><a id="c555_b2-li-1713"></a>analyzing version, 355–360</li>
<li><a id="c555_b2-li-1714"></a>compilation of, 564 (ex. 5.53), 564 (ex. 5.55)</li>
<li><a id="c555_b2-li-1715"></a>component representation, 322, 328–335</li>
<li><a id="c555_b2-li-1716"></a>data abstraction in, 321, 322, 342</li>
<li><a id="c555_b2-li-1717"></a>data-directed <span class="KeyTerm1">evaluate</span>, 336 (ex. 4.3)</li>
<li><a id="c555_b2-li-1718"></a>derived components, 334–335</li>
<li><a id="c555_b2-li-1719"></a>driver loop, 346</li>
<li><a id="c555_b2-li-1720"></a>efficiency of, 355</li>
<li><a id="c555_b2-li-1721"></a>environment model of evaluation in, 320</li>
<li><a id="c555_b2-li-1722"></a>environment operations, 341</li>
<li><a id="c555_b2-li-1723"></a><span class="KeyTerm1">evaluate</span> and <span class="KeyTerm1">apply</span>, 321–328</li>
<li><a id="c555_b2-li-1724"></a><span class="KeyTerm1">evaluate</span>–<span class="KeyTerm1">apply</span> cycle, 320, 321 (fig. 4.1)</li>
<li><a id="c555_b2-li-1725"></a>global environment, 344</li>
<li><a id="c555_b2-li-1726"></a>higher-order functions in, 325<i>n</i></li>
<li><a id="c555_b2-li-1727"></a>implemented language vs. implementation language, 325</li>
<li><a id="c555_b2-li-1728"></a>job of, 320<i>n</i></li>
<li><a id="c555_b2-li-1729"></a><span class="KeyTerm1"><b>let</b>*</span> (Scheme variant of <span class="KeyTerm1"><b>let</b></span>), 336 (ex. 4.6)</li>
<li><a id="c555_b2-li-1730"></a>order of argument evaluation, 328 (ex. 4.1)</li>
<li><a id="c555_b2-li-1731"></a>parameters distinct from local names, 336 (ex. 4.5)</li>
<li><a id="c555_b2-li-1732"></a>preventing duplicate parameters, 336 (ex. 4.5)</li>
<li><a id="c555_b2-li-1733"></a>primitive functions, 344–346</li>
<li><a id="c555_b2-li-1734"></a>representation of environments, 341–343</li>
<li><a id="c555_b2-li-1735"></a>representation of functions, 340</li>
<li><a id="c555_b2-li-1736"></a>representation of true and false, 339</li>
<li><a id="c555_b2-li-1737"></a>return value, 324</li>
<li><a id="c555_b2-li-1738"></a>running, 344–348</li>
<li><a id="c555_b2-li-1739"></a>symbolic differentiation and, 329</li>
<li><a id="c555_b2-li-1740"></a>syntactic forms (additional), 336 (ex. 4.4), 336 (ex. 4.6), 337 (ex. 4.7)</li>
<li><a id="c555_b2-li-1741"></a>syntactic forms as derived components, 334–335</li>
<li><a id="c555_b2-li-1742"></a>syntax of evaluated language, 328–335</li>
<li><a id="c555_b2-li-1743"></a>tail recursion and, 324<i>n</i>, 327<i>n</i>, 509</li>
<li><a id="c555_b2-li-1744"></a><span class="KeyTerm1">undefined</span>, 344</li>
<li><a id="c555_b2-li-1745"></a>value of program at top level, 338 (ex. 4.8)</li>
<li><a id="c555_b2-li-1746"></a>while loop, 337 (ex. 4.7)</li>
</ul></li>
<li><a id="c555_b2-li-1747"></a>metalinguistic abstraction, 318</li>
<li><a id="c555_b2-li-1748"></a>MicroPlanner, 376<i>n</i></li>
<li><a id="c555_b2-li-1749"></a><span class="KeyTerm1">midpoint_segment</span>, 77 (ex. 2.2)</li>
<li><a id="c555_b2-li-1750"></a>Miller, Gary L., 48 (ex. 1.28)</li>
<li><a id="c555_b2-li-1751"></a>Miller, James S., 541<i>n</i></li>
<li><a id="c555_b2-li-1752"></a>Miller–Rabin test for primality, 48 (ex. 1.28)</li>
<li><a id="c555_b2-li-1753"></a>Milner, Robin, 310<i>n</i></li>
<li><a id="c555_b2-li-1754"></a>Minsky, Marvin Lee, xxiv, 494<i>n</i></li>
<li><a id="c555_b2-li-1755"></a>Miranda, 106<i>n</i></li>
<li><a id="c555_b2-li-1756"></a>MIT, 399<i>n</i>
<ul class="none">
<li><a id="c555_b2-li-1757"></a>early history of, 112<i>n</i></li>
<li><a id="c555_b2-li-1758"></a>Research Laboratory of Electronics, 494<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1759"></a>ML, 310<i>n</i></li>
<li><a id="c555_b2-li-1760"></a>mobile, 96 (ex. 2.29)</li>
<li><a id="c555_b2-li-1761"></a>Mocha, 2</li>
<li><a id="c555_b2-li-1762"></a>modeling<ul class="none">
<li><a id="c555_b2-li-1763"></a>as a design strategy, 189</li>
<li><a id="c555_b2-li-1764"></a>in science and engineering, 12</li>
</ul></li>
<li><a id="c555_b2-li-1765"></a>models of evaluation, 513</li>
<li><a id="c555_b2-li-1766"></a>modified registers, <i>see</i> instruction sequence</li>
<li><a id="c555_b2-li-1767"></a><span class="KeyTerm1">modifies_register</span>, <i>543</i></li>
<li><a id="c555_b2-li-1768"></a>modularity, 102, 189<ul class="none">
<li><a id="c555_b2-li-1769"></a>along object boundaries, 315<i>n</i></li>
<li><a id="c555_b2-li-1770"></a>functional programs vs. objects, 311–315</li>
<li><a id="c555_b2-li-1771"></a>hiding principle, 193<i>n</i></li>
<li><a id="c555_b2-li-1772"></a>streams and, 295</li>
<li><a id="c555_b2-li-1773"></a>through dispatching on type, 156</li>
<li><a id="c555_b2-li-1774"></a>through infinite streams, 312</li>
<li><a id="c555_b2-li-1775"></a>through modeling with objects, 197</li>
</ul></li>
<li><a id="c555_b2-li-1776"></a>modulo <i>n</i>, 44</li>
<li><a id="c555_b2-li-1777"></a><i>modus ponens</i>, 419<i>n</i></li>
<li><a id="c555_b2-li-1778"></a>money, changing, <i>see</i> counting change</li>
<li><a id="c555_b2-li-1779"></a>monitored function, 196 (ex. 3.2)</li>
<li><a id="c555_b2-li-1780"></a><span class="KeyTerm1">monte_carlo</span>, <i>198</i>
<ul class="none">
<li><a id="c555_b2-li-1781"></a>infinite stream, <i>312</i></li>
</ul></li>
<li><a id="c555_b2-li-1782"></a>Monte Carlo integration, 200 (ex. 3.5)<ul class="none">
<li><a id="c555_b2-li-1783"></a>stream formulation, 312 (ex. 3.82)</li>
</ul></li>
<li><a id="c555_b2-li-1784"></a>Monte Carlo simulation, 198<ul class="none">
<li><a id="c555_b2-li-1785"></a>stream formulation, 311</li>
</ul></li>
<li><a id="c555_b2-li-1786"></a>Moon, David A., 494<i>n</i></li>
<li><a id="c555_b2-li-1787"></a>Morris, J. H., 204<i>n</i></li>
<li><a id="c555_b2-li-1788"></a>Morse code, 140</li>
<li><a id="c555_b2-li-1789"></a>Mouse, Minnie and Mickey, 420</li>
<li><a id="c555_b2-li-1790"></a><span class="KeyTerm1">mul</span> (generic), <i>165</i>
<ul class="none">
<li><a id="c555_b2-li-1791"></a>used for polynomial coefficients, 180</li>
</ul></li>
<li><a id="c555_b2-li-1792"></a><span class="KeyTerm1">mul_complex</span>, <i>150</i></li>
<li><a id="c555_b2-li-1793"></a><span class="KeyTerm1">mul_interval</span>, <i>81</i>
<ul class="none">
<li><a id="c555_b2-li-1794"></a>more efficient version, 82 (ex. 2.11)</li>
</ul></li>
<li><a id="c555_b2-li-1795"></a><span class="KeyTerm1">mul_poly</span>, <i>178</i></li>
<li><a id="c555_b2-li-1796"></a><span class="KeyTerm1">mul_rat</span>, <i>73</i></li>
<li><a id="c555_b2-li-1797"></a><span class="KeyTerm1">mul_series</span>, 294 (ex. 3.60)</li>
<li><a id="c555_b2-li-1798"></a><span class="KeyTerm1">mul_streams</span>, 292 (ex. 3.54)</li>
<li><a id="c555_b2-li-1799"></a><span class="KeyTerm1">mul_terms</span>, <i>180</i></li>
<li><a id="c555_b2-li-1800"></a>Multics time-sharing system, 494<i>n</i></li>
<li><a id="c555_b2-li-1801"></a><span class="KeyTerm1">multiplicand</span>, <i>129</i></li>
<li><a id="c555_b2-li-1802"></a>multiplication by Russian peasant method, 40<i>n</i></li>
<li><a id="c555_b2-li-1803"></a><span class="KeyTerm1">multiplier</span>
<ul class="none">
<li><a id="c555_b2-li-1804"></a>primitive constraint, <i>257</i></li>
<li><a id="c555_b2-li-1805"></a>selector, <i>129</i></li>
</ul></li>
<li><a id="c555_b2-li-1806"></a>Munro, Ian, 104<i>n</i></li>
<li><a id="c555_b2-li-1807"></a>mutable data objects, 222–230, <i>see also</i> queue; table<ul class="none">
<li><a id="c555_b2-li-1808"></a>functional representation of, 229–230</li>
<li><a id="c555_b2-li-1809"></a>implemented with assignment, 229–230</li>
<li><a id="c555_b2-li-1810"></a>list structure, 222–226</li>
<li><a id="c555_b2-li-1811"></a>pairs, 222–226</li>
<li><a id="c555_b2-li-1812"></a>shared data, 228</li>
</ul></li>
<li><a id="c555_b2-li-1813"></a>mutator, 222</li>
<li><a id="c555_b2-li-1814"></a>mutex, 276</li>
<li><a id="c555_b2-li-1815"></a>mutual exclusion, 276<i>n</i></li>
<li><a id="c555_b2-li-1816"></a>mutual recursion, 221</li>
<li><a id="c555_b2-li-1817"></a><span class="KeyTerm1">mystery</span>, <i>226</i> (ex. 3.14)</li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-1818"></a>name, <i>see</i> constant; local name; variable<ul class="none">
<li><a id="c555_b2-li-1819"></a>bound, 23</li>
<li><a id="c555_b2-li-1820"></a>encapsulated, 193<i>n</i></li>
<li><a id="c555_b2-li-1821"></a>free, 23</li>
<li><a id="c555_b2-li-1822"></a>of a function, 9</li>
<li><a id="c555_b2-li-1823"></a>of a parameter, 23</li>
<li><a id="c555_b2-li-1824"></a>parsing of, 330</li>
<li><a id="c555_b2-li-1825"></a>scope of, 23, <i>see also</i> scope of a name</li>
<li><a id="c555_b2-li-1826"></a>unbound, 206</li>
<li><a id="c555_b2-li-1827"></a>value of, 206</li>
</ul></li>
<li><a id="c555_b2-li-1828"></a>naming<ul class="none">
<li><a id="c555_b2-li-1829"></a>of computational objects, 5</li>
<li><a id="c555_b2-li-1830"></a>of functions, 8</li>
</ul></li>
<li><a id="c555_b2-li-1831"></a>naming conventions<ul class="none">
<li><a id="c555_b2-li-1832"></a>$ for pattern variables, 403</li>
<li><a id="c555_b2-li-1833"></a><span class="KeyTerm1">is_</span> for predicates, 20<i>n</i></li>
<li><a id="c555_b2-li-1834"></a>snake case, 10<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1835"></a>NaN, not a typo, 339<i>n</i></li>
<li><a id="c555_b2-li-1836"></a>native language of machine, 520</li>
<li><a id="c555_b2-li-1837"></a>natural language parsing, <i>see</i> parsing natural language</li>
<li><a id="c555_b2-li-1838"></a>needed registers, <i>see</i> instruction sequence</li>
<li><a id="c555_b2-li-1839"></a><span class="KeyTerm1">needs_register</span>, <i>543</i></li>
<li><a id="c555_b2-li-1840"></a><span class="KeyTerm1">negate</span>, <i>427</i></li>
<li><a id="c555_b2-li-1841"></a><span class="KeyTerm1">negated_query</span>, <i>443</i></li>
<li><a id="c555_b2-li-1842"></a>negation<ul class="none">
<li><a id="c555_b2-li-1843"></a>logical (<span class="KeyTerm1">!</span>), 15</li>
<li><a id="c555_b2-li-1844"></a>numeric (<span class="KeyTerm1">-</span>), 15</li>
</ul></li>
<li><a id="c555_b2-li-1845"></a>negation as failure, 422<i>n</i></li>
<li><a id="c555_b2-li-1846"></a>nested declaration(s), <i>see</i> internal declaration</li>
<li><a id="c555_b2-li-1847"></a>nested mapping(s), <i>see</i> mapping</li>
<li><a id="c555_b2-li-1848"></a>nested operator combinations, 4</li>
<li><a id="c555_b2-li-1849"></a>Netscape Communications Corporation, 2</li>
<li><a id="c555_b2-li-1850"></a>Netscape Navigator, 2</li>
<li><a id="c555_b2-li-1851"></a><span class="KeyTerm1">new</span> register, 496</li>
<li><a id="c555_b2-li-1852"></a><span class="KeyTerm1">new_heads</span> register, 494</li>
<li><a id="c555_b2-li-1853"></a><span class="KeyTerm1">new_tails</span> register, 494</li>
<li><a id="c555_b2-li-1854"></a>Newton's method<ul class="none">
<li><a id="c555_b2-li-1855"></a>for cube roots, 21 (ex. 1.8)</li>
<li><a id="c555_b2-li-1856"></a>for differentiable functions, 64–65</li>
<li><a id="c555_b2-li-1857"></a>half-interval method vs., 64<i>n</i></li>
<li><a id="c555_b2-li-1858"></a>for square roots, 18–20, 65, 66</li>
</ul></li>
<li><a id="c555_b2-li-1859"></a><span class="KeyTerm1">newtons_method</span>, <i>65</i></li>
<li><a id="c555_b2-li-1860"></a><span class="KeyTerm1">newton_transform</span>, <i>65</i></li>
<li><a id="c555_b2-li-1861"></a><span class="KeyTerm1">new_withdraw</span>, <i>193</i></li>
<li><a id="c555_b2-li-1862"></a><span class="KeyTerm1">next</span> (linkage descriptor), 523</li>
<li><a id="c555_b2-li-1863"></a><span class="KeyTerm1">next_to_in</span> (rules), <i>410</i> (ex. 4.59)</li>
<li><a id="c555_b2-li-1864"></a>node of a tree, 7</li>
<li><a id="c555_b2-li-1865"></a>noncomputable, 351<i>n</i></li>
<li><a id="c555_b2-li-1866"></a>nondeterminism, in behavior of concurrent programs, 267<i>n</i>, 315<i>n</i></li>
<li><a id="c555_b2-li-1867"></a>nondeterministic choice point, 375</li>
<li><a id="c555_b2-li-1868"></a>nondeterministic computing, 373–385</li>
<li><a id="c555_b2-li-1869"></a>nondeterministic evaluator, 386–398<ul class="none">
<li><a id="c555_b2-li-1870"></a>order of argument evaluation, 385 (ex. 4.44)</li>
</ul></li>
<li><a id="c555_b2-li-1871"></a>nondeterministic programming vs. JavaScript programming, 373, 380 (ex. 4.39), 380 (ex. 4.42)</li>
<li><a id="c555_b2-li-1872"></a>nondeterministic programs<ul class="none">
<li><a id="c555_b2-li-1873"></a>logic puzzles, 378–380</li>
<li><a id="c555_b2-li-1874"></a>pairs with prime sums, 373</li>
<li><a id="c555_b2-li-1875"></a>parsing natural language, 381–384</li>
<li><a id="c555_b2-li-1876"></a>Pythagorean triples, 377 (ex. 4.33), 378 (ex. 4.34), 378 (ex. 4.35)</li>
</ul></li>
<li><a id="c555_b2-li-1877"></a>non-strict, 362</li>
<li><a id="c555_b2-li-1878"></a>normal-order evaluation, 13<ul class="none">
<li><a id="c555_b2-li-1879"></a>applicative order vs., 17 (ex. 1.5), 43 (ex. 1.20), 361–362</li>
<li><a id="c555_b2-li-1880"></a>of conditional expressions, 17 (ex. 1.5)</li>
<li><a id="c555_b2-li-1881"></a>delayed evaluation and, 310</li>
<li><a id="c555_b2-li-1882"></a>in explicit-control evaluator, 513 (ex. 5.26)</li>
</ul></li>
<li><a id="c555_b2-li-1883"></a>normal-order evaluator, <i>see</i> lazy evaluator</li>
<li><a id="c555_b2-li-1884"></a><span class="KeyTerm1">not</span> (query language), 406, 421<ul class="none">
<li><a id="c555_b2-li-1885"></a>evaluation of, 415, 427, 446 (ex. 4.74)</li>
</ul></li>
<li><a id="c555_b2-li-1886"></a>notation in this book<ul class="none">
<li><a id="c555_b2-li-1887"></a>box notation for data, 86</li>
<li><a id="c555_b2-li-1888"></a>italic symbols in expression syntax, 9<i>n</i></li>
<li><a id="c555_b2-li-1889"></a>list notation for data, 87</li>
<li><a id="c555_b2-li-1890"></a>slanted characters for interpreter response, 4<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-1891"></a><span class="KeyTerm1">nouns</span>, <i>381</i></li>
<li><a id="c555_b2-li-1892"></a><i>n</i>th root, as fixed point, 68 (ex. 1.45)</li>
<li><a id="c555_b2-li-1893"></a><span class="KeyTerm1"><b>null</b></span> (keyword)<ul class="none">
<li><a id="c555_b2-li-1894"></a>as empty list, 87</li>
<li><a id="c555_b2-li-1895"></a>as end-of-list marker, 85</li>
<li><a id="c555_b2-li-1896"></a>recognizing with <span class="KeyTerm1">is_null</span>, 87</li>
</ul></li>
<li><a id="c555_b2-li-1897"></a>number(s)<ul class="none">
<li><a id="c555_b2-li-1898"></a>bignum, 490</li>
<li><a id="c555_b2-li-1899"></a>comparison of, 14</li>
<li><a id="c555_b2-li-1900"></a>equality of, 14, 125 (ex. 2.54), 490<i>n</i></li>
<li><a id="c555_b2-li-1901"></a>in generic arithmetic system, 165</li>
<li><a id="c555_b2-li-1902"></a>integer vs. real number, 3<i>n</i></li>
<li><a id="c555_b2-li-1903"></a>in JavaScript, 3</li>
</ul></li>
<li><a id="c555_b2-li-1904"></a><span class="KeyTerm1">number_equal</span>, <i>130</i></li>
<li><a id="c555_b2-li-1905"></a>number theory, 44<i>n</i></li>
<li><a id="c555_b2-li-1906"></a><span class="KeyTerm1">numer</span>, 72, <i>74</i>
<ul class="none">
<li><a id="c555_b2-li-1907"></a>axiom for, 78</li>
<li><a id="c555_b2-li-1908"></a>reducing to lowest terms, <i>77</i></li>
</ul></li>
<li><a id="c555_b2-li-1909"></a>numerical analysis, 3<i>n</i></li>
<li><a id="c555_b2-li-1910"></a>numerical analyst, 59<i>n</i></li>
<li><a id="c555_b2-li-1911"></a>numerical data, 3</li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-1912"></a>object(s), 189<ul class="none">
<li><a id="c555_b2-li-1913"></a>benefits of modeling with, 197</li>
<li><a id="c555_b2-li-1914"></a>with time-varying state, 190</li>
</ul></li>
<li><a id="c555_b2-li-1915"></a>object-oriented programming languages, 174<i>n</i></li>
<li><a id="c555_b2-li-1916"></a>object program, 520</li>
<li><a id="c555_b2-li-1917"></a>Ocaml, 90 (ex. 2.20)</li>
<li><a id="c555_b2-li-1918"></a><span class="KeyTerm1">office_move</span>, <i>379</i></li>
<li><a id="c555_b2-li-1919"></a><span class="KeyTerm1">old</span> register, 496</li>
<li><a id="c555_b2-li-1920"></a><span class="KeyTerm1">oldht</span> register, 497</li>
<li><a id="c555_b2-li-1921"></a><span class="KeyTerm1">ones</span> (infinite stream), <i>290</i>
<ul class="none">
<li><a id="c555_b2-li-1922"></a>lazy-list version, <i>371</i></li>
</ul></li>
<li><a id="c555_b2-li-1923"></a><span class="KeyTerm1">op</span> (in register machine), 453<ul class="none">
<li><a id="c555_b2-li-1924"></a>simulating, 482, <i>483</i></li>
</ul></li>
<li><a id="c555_b2-li-1925"></a>open coding of primitives, 553 (ex. 5.41)</li>
<li><a id="c555_b2-li-1926"></a>operands of a combination, 4</li>
<li><a id="c555_b2-li-1927"></a>operation<ul class="none">
<li><a id="c555_b2-li-1928"></a>cross-type, 169</li>
<li><a id="c555_b2-li-1929"></a>generic, 71</li>
<li><a id="c555_b2-li-1930"></a>in register machine, 450–452</li>
</ul></li>
<li><a id="c555_b2-li-1931"></a>operation-and-type table, 157<ul class="none">
<li><a id="c555_b2-li-1932"></a>assignment needed for, 191<i>n</i></li>
<li><a id="c555_b2-li-1933"></a>implementing, 239</li>
</ul></li>
<li><a id="c555_b2-li-1934"></a><span class="KeyTerm1">operation_exp_op</span>, <i>483</i></li>
<li><a id="c555_b2-li-1935"></a><span class="KeyTerm1">operation_exp_operands</span>, <i>483</i></li>
<li><a id="c555_b2-li-1936"></a>operator combination, 4<ul class="none">
<li><a id="c555_b2-li-1937"></a>as function application, 335</li>
<li><a id="c555_b2-li-1938"></a>as derived component, 335</li>
<li><a id="c555_b2-li-1939"></a>evaluation of, 6–8</li>
<li><a id="c555_b2-li-1940"></a>parsing of, 334</li>
<li><a id="c555_b2-li-1941"></a>as a tree, 7</li>
</ul></li>
<li><a id="c555_b2-li-1942"></a><span class="KeyTerm1">operator_combination_to_application</span>, <i>335</i></li>
<li><a id="c555_b2-li-1943"></a>operator of a combination, 4</li>
<li><a id="c555_b2-li-1944"></a>operator precedence, <i>see</i> precedence operators (ECMAScript may allow<ul class="none">
<li><a id="c555_b2-li-1945"></a>additional operand type combinations)</li>
<li><a id="c555_b2-li-1946"></a><span class="KeyTerm1">+</span> (for numeric addition), 4</li>
<li><a id="c555_b2-li-1947"></a><span class="KeyTerm1">+</span> (for string concatenation), 75</li>
<li><a id="c555_b2-li-1948"></a>- (numeric negation operator), 15</li>
<li><a id="c555_b2-li-1949"></a>- (numeric subtraction operator), 5</li>
<li><a id="c555_b2-li-1950"></a><span class="KeyTerm1">*</span> (multiplication), 4</li>
<li><a id="c555_b2-li-1951"></a><span class="KeyTerm1">/</span> (division), 4</li>
<li><a id="c555_b2-li-1952"></a><span class="KeyTerm1">%</span> (remainder), 39</li>
<li><a id="c555_b2-li-1953"></a><span class="KeyTerm1">!</span> (logical negation), 15</li>
<li><a id="c555_b2-li-1954"></a><span class="KeyTerm1">!==</span> (for numeric comparison), 15</li>
<li><a id="c555_b2-li-1955"></a><span class="KeyTerm1">!==</span> (for string comparison), 124</li>
<li><a id="c555_b2-li-1956"></a><span class="KeyTerm1">===</span> (for nonprimitive values), 228</li>
<li><a id="c555_b2-li-1957"></a><span class="KeyTerm1">===</span> (for numeric comparison), 15</li>
<li><a id="c555_b2-li-1958"></a><span class="KeyTerm1">===</span> (for string comparison), 124</li>
<li><a id="c555_b2-li-1959"></a><span class="KeyTerm1">&lt;</span> (numeric comparison), 15</li>
<li><a id="c555_b2-li-1960"></a><span class="KeyTerm1">&lt;=</span> (numeric comparison), 15</li>
<li><a id="c555_b2-li-1961"></a><span class="KeyTerm1">&gt;</span> (numeric comparison), 15</li>
<li><a id="c555_b2-li-1962"></a><span class="KeyTerm1">&gt;=</span> (numeric comparison), 14</li>
</ul></li>
<li><a id="c555_b2-li-1963"></a>optimality<ul class="none">
<li><a id="c555_b2-li-1964"></a>of Horner's rule, 104<i>n</i></li>
<li><a id="c555_b2-li-1965"></a>of Huffman code, 142</li>
</ul></li>
<li><a id="c555_b2-li-1966"></a><span class="KeyTerm1">or</span> (query language), 405<ul class="none">
<li><a id="c555_b2-li-1967"></a>evaluation of, 414, 427</li>
</ul></li>
<li><a id="c555_b2-li-1968"></a>Oracle Corporation, 2</li>
<li><a id="c555_b2-li-1969"></a><span class="KeyTerm1">order</span>, 179, <i>182</i></li>
<li><a id="c555_b2-li-1970"></a>ordered-list representation of sets, 133–135</li>
<li><a id="c555_b2-li-1971"></a>order notation, 37</li>
<li><a id="c555_b2-li-1972"></a>order of evaluation<ul class="none">
<li><a id="c555_b2-li-1973"></a>assignment and, 206 (ex. 3.8)</li>
<li><a id="c555_b2-li-1974"></a>in compiler, 549 (ex. 5.39)</li>
<li><a id="c555_b2-li-1975"></a>in explicit-control evaluator, 506</li>
<li><a id="c555_b2-li-1976"></a>in metacircular evaluator, 507<i>n</i></li>
<li><a id="c555_b2-li-1977"></a>in JavaScript, 206 (ex. 3.8), 207<i>n</i></li>
<li><a id="c555_b2-li-1978"></a>in metacircular evaluator, 328 (ex. 4.1)</li>
</ul></li>
<li><a id="c555_b2-li-1979"></a>order of events<ul class="none">
<li><a id="c555_b2-li-1980"></a>decoupling apparent from actual, 286</li>
<li><a id="c555_b2-li-1981"></a>indeterminacy in concurrent systems, 264</li>
</ul></li>
<li><a id="c555_b2-li-1982"></a>order of growth, 36–37<ul class="none">
<li><a id="c555_b2-li-1983"></a>linear iterative process, 37</li>
<li><a id="c555_b2-li-1984"></a>linear recursive process, 37</li>
<li><a id="c555_b2-li-1985"></a>logarithmic, 39</li>
<li><a id="c555_b2-li-1986"></a>tree-recursive process, 37</li>
</ul></li>
<li><a id="c555_b2-li-1987"></a>order of subexpression evaluation, <i>see</i> order of evaluation</li>
<li><a id="c555_b2-li-1988"></a>ordinary numbers (in generic arithmetic system), 165</li>
<li><a id="c555_b2-li-1989"></a>or-gate, 241<ul class="none">
<li><a id="c555_b2-li-1990"></a><span class="KeyTerm1">or_gate</span>, 245 (ex. 3.28), 245 (ex. 3.29)</li>
</ul></li>
<li><a id="c555_b2-li-1991"></a><span class="KeyTerm1">origin_frame</span>, 117</li>
<li><a id="c555_b2-li-1992"></a>Ostrowski, A. M., 104<i>n</i></li>
<li><a id="c555_b2-li-1993"></a><span class="KeyTerm1">outranked_by</span> (rule), <i>408</i>, 422 (ex. 4.62) overloaded operator <span class="KeyTerm1">+</span>, 75</li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-1994"></a>P operation on semaphore, 276<i>n</i></li>
<li><a id="c555_b2-li-1995"></a>package, 157<ul class="none">
<li><a id="c555_b2-li-1996"></a>complex-number, 167</li>
<li><a id="c555_b2-li-1997"></a>JavaScript-number, 165</li>
<li><a id="c555_b2-li-1998"></a>polar representation, 159</li>
<li><a id="c555_b2-li-1999"></a>polynomial, 178</li>
<li><a id="c555_b2-li-2000"></a>rational-number, 166</li>
<li><a id="c555_b2-li-2001"></a>rectangular representation, 157</li>
</ul></li>
<li><a id="c555_b2-li-2002"></a>painter(s), 110<ul class="none">
<li><a id="c555_b2-li-2003"></a>higher-order operations, 115</li>
<li><a id="c555_b2-li-2004"></a>operations, 112</li>
<li><a id="c555_b2-li-2005"></a>represented as functions, 119</li>
<li><a id="c555_b2-li-2006"></a>transforming and combining, 120</li>
</ul></li>
<li><a id="c555_b2-li-2007"></a><span class="KeyTerm1">pair</span> (primitive function), 73<ul class="none">
<li><a id="c555_b2-li-2008"></a>axiom for, 79</li>
<li><a id="c555_b2-li-2009"></a>closure property of, 84</li>
<li><a id="c555_b2-li-2010"></a>functional implementation of, <i>79</i>, <i>80</i> (ex. 2.4), <i>229, 230</i>, <i>371</i></li>
<li><a id="c555_b2-li-2011"></a>implemented with mutators, 224, <i>225</i></li>
<li><a id="c555_b2-li-2012"></a>implemented with vectors, 491</li>
<li><a id="c555_b2-li-2013"></a>as list operation, 86</li>
</ul></li>
<li><a id="c555_b2-li-2014"></a>pair(s), 73<ul class="none">
<li><a id="c555_b2-li-2015"></a>axiomatic definition of, 79</li>
<li><a id="c555_b2-li-2016"></a>box-and-pointer notation for, 84</li>
<li><a id="c555_b2-li-2017"></a>box notation for, 86</li>
<li><a id="c555_b2-li-2018"></a>functional representation of, 79–80, 229–230, 370</li>
<li><a id="c555_b2-li-2019"></a>infinite stream of, 299–302</li>
<li><a id="c555_b2-li-2020"></a>lazy, 370–372</li>
<li><a id="c555_b2-li-2021"></a>mutable, 222–226</li>
<li><a id="c555_b2-li-2022"></a>represented using vectors, 488–492</li>
<li><a id="c555_b2-li-2023"></a>used to represent sequence, 85</li>
<li><a id="c555_b2-li-2024"></a>used to represent tree, 93–96</li>
</ul></li>
<li><a id="c555_b2-li-2025"></a><span class="KeyTerm1">pairs</span>, <i>301</i></li>
<li><a id="c555_b2-li-2026"></a>Pan, V. Y., 104<i>n</i></li>
<li><a id="c555_b2-li-2027"></a><span class="KeyTerm1">parallel_instruction_sequences</span>, <i>546</i></li>
<li><a id="c555_b2-li-2028"></a>parameter passing, <i>see</i> call-by-name<ul class="none">
<li><a id="c555_b2-li-2029"></a>argument passing; call-by-need</li>
<li><a id="c555_b2-li-2030"></a>argument passing</li>
</ul></li>
<li><a id="c555_b2-li-2031"></a>parameters, 9<ul class="none">
<li><a id="c555_b2-li-2032"></a>distinct from local names, 336 (ex. 4.5)</li>
<li><a id="c555_b2-li-2033"></a>duplicate, 336 (ex. 4.5)</li>
<li><a id="c555_b2-li-2034"></a>names of, 23</li>
<li><a id="c555_b2-li-2035"></a>scope of, 24</li>
<li><a id="c555_b2-li-2036"></a>as variables, 192, 194</li>
</ul></li>
<li><a id="c555_b2-li-2037"></a>parentheses<ul class="none">
<li><a id="c555_b2-li-2038"></a>in function declaration, 9</li>
<li><a id="c555_b2-li-2039"></a>to group operator combinations, 4</li>
<li><a id="c555_b2-li-2040"></a>around lambda expression, 55</li>
<li><a id="c555_b2-li-2041"></a>around parameters of lambda expression, 54</li>
<li><a id="c555_b2-li-2042"></a>around predicate of conditional statement, 57</li>
</ul></li>
<li><a id="c555_b2-li-2043"></a><span class="KeyTerm1">parse</span>, 328, <i>see also</i> parsing JavaScript<ul class="none">
<li><a id="c555_b2-li-2044"></a>in query interpreter, 425</li>
</ul></li>
<li><a id="c555_b2-li-2045"></a><span class="KeyTerm1">parse_…</span>, 381–383</li>
<li><a id="c555_b2-li-2046"></a>parsing JavaScript, 328–329<ul class="none">
<li><a id="c555_b2-li-2047"></a><span class="KeyTerm1">&amp;&amp;</span> (logical conjunction), 336 (ex. 4.4)</li>
<li><a id="c555_b2-li-2048"></a><span class="KeyTerm1">||</span> (logical disjunction), 336 (ex. 4.4)</li>
<li><a id="c555_b2-li-2049"></a>assignment, 333</li>
<li><a id="c555_b2-li-2050"></a>block, 333</li>
<li><a id="c555_b2-li-2051"></a>conditional expression, 331</li>
<li><a id="c555_b2-li-2052"></a>conditional statement, 331</li>
<li><a id="c555_b2-li-2053"></a>constant declaration, 333</li>
<li><a id="c555_b2-li-2054"></a>expression statement, 331</li>
<li><a id="c555_b2-li-2055"></a>function application, 331</li>
<li><a id="c555_b2-li-2056"></a>function declaration, 334</li>
<li><a id="c555_b2-li-2057"></a>lambda expression, 332</li>
<li><a id="c555_b2-li-2058"></a>literal expression, 330</li>
<li><a id="c555_b2-li-2059"></a>name, 330</li>
<li><a id="c555_b2-li-2060"></a>operator combination, 334</li>
<li><a id="c555_b2-li-2061"></a>return statement, 333</li>
<li><a id="c555_b2-li-2062"></a>sequence of statements, 332</li>
<li><a id="c555_b2-li-2063"></a>variable declaration, 333</li>
</ul></li>
<li><a id="c555_b2-li-2064"></a>parsing natural language, 381–385<ul class="none">
<li><a id="c555_b2-li-2065"></a>real language understanding vs. toy parser, 385<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2066"></a><span class="KeyTerm1">partial_sums</span>, 292 (ex. 3.55) Pascal, Blaise, 36<i>n</i></li>
<li><a id="c555_b2-li-2067"></a>Pascal's triangle, 36 (ex. 1.12)</li>
<li><a id="c555_b2-li-2068"></a>Pascal, lack of higher-order functions in, 310<i>n</i></li>
<li><a id="c555_b2-li-2069"></a>password-protected bank account, 196 (ex. 3.3)</li>
<li><a id="c555_b2-li-2070"></a>pattern, 403–404</li>
<li><a id="c555_b2-li-2071"></a><span class="KeyTerm1">pattern_match</span>, <i>429</i></li>
<li><a id="c555_b2-li-2072"></a>pattern matching, 412<ul class="none">
<li><a id="c555_b2-li-2073"></a>implementation, 428–429</li>
<li><a id="c555_b2-li-2074"></a>unification vs., 416, 418<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2075"></a>pattern variable, 403<ul class="none">
<li><a id="c555_b2-li-2076"></a>representation of, 437</li>
</ul></li>
<li><a id="c555_b2-li-2077"></a><span class="KeyTerm1">pc</span> register, 472</li>
<li><a id="c555_b2-li-2078"></a><span class="KeyTerm1">perform</span> (in register machine), 455<ul class="none">
<li><a id="c555_b2-li-2079"></a>instruction constructor, <i>481</i></li>
<li><a id="c555_b2-li-2080"></a>simulating, 481</li>
</ul></li>
<li><a id="c555_b2-li-2081"></a><span class="KeyTerm1">perform_action</span>, <i>481</i></li>
<li><a id="c555_b2-li-2082"></a>Perlis, Alan J., xxiii<ul class="none">
<li><a id="c555_b2-li-2083"></a>quips by, 5<i>n</i>, 30<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2084"></a>permutations of a set, 108<ul class="none">
<li><a id="c555_b2-li-2085"></a><span class="KeyTerm1">permutations</span>, <i>108</i></li>
</ul></li>
<li><a id="c555_b2-li-2086"></a>Peter, Paul and Mary, 267 (ex. 3.38)</li>
<li><a id="c555_b2-li-2087"></a>Phillips, Hubert, 380 (ex. 4.40), 380 (ex. 4.41)</li>
<li><a id="c555_b2-li-2088"></a><i>π</i> (pi)<ul class="none">
<li><a id="c555_b2-li-2089"></a>approximation with half-interval method, 60</li>
<li><a id="c555_b2-li-2090"></a>approximation with Monte Carlo integration, 200 (ex. 3.5), 312 (ex. 3.82)</li>
<li><a id="c555_b2-li-2091"></a>Dirichlet estimate for, 198, 311</li>
<li><a id="c555_b2-li-2092"></a>Leibniz's series for, 49<i>n</i>, 296</li>
<li><a id="c555_b2-li-2093"></a>stream of approximations, 296–298</li>
<li><a id="c555_b2-li-2094"></a>Wallis's formula for, 52 (ex. 1.31)</li>
</ul></li>
<li><a id="c555_b2-li-2095"></a>picture language, 110–123</li>
<li><a id="c555_b2-li-2096"></a>Pingala, Áchárya, 40<i>n</i></li>
<li><a id="c555_b2-li-2097"></a>pipelining, 263<i>n</i></li>
<li><a id="c555_b2-li-2098"></a><span class="KeyTerm1">pi_stream</span>, <i>296</i></li>
<li><a id="c555_b2-li-2099"></a><span class="KeyTerm1">pi_sum</span>, <i>49</i>
<ul class="none">
<li><a id="c555_b2-li-2100"></a>with higher-order functions, <i>51</i></li>
<li><a id="c555_b2-li-2101"></a>with lambda expression, <i>54</i></li>
</ul></li>
<li><a id="c555_b2-li-2102"></a>Planner, 376<i>n</i></li>
<li><a id="c555_b2-li-2103"></a>point, represented as a pair, 77 (ex. 2.2)</li>
<li><a id="c555_b2-li-2104"></a>pointer<ul class="none">
<li><a id="c555_b2-li-2105"></a>in box-and-pointer notation, 84</li>
<li><a id="c555_b2-li-2106"></a>typed, 489</li>
</ul></li>
<li><a id="c555_b2-li-2107"></a><span class="KeyTerm1">polar</span> package, 159</li>
<li><a id="c555_b2-li-2108"></a>poly, 177</li>
<li><a id="c555_b2-li-2109"></a>polymorphic types, 310<i>n</i></li>
<li><a id="c555_b2-li-2110"></a><span class="KeyTerm1">polynomial</span> package, 178</li>
<li><a id="c555_b2-li-2111"></a>polynomial(s), 177–188<ul class="none">
<li><a id="c555_b2-li-2112"></a>canonical form, 184</li>
<li><a id="c555_b2-li-2113"></a>dense, 181</li>
<li><a id="c555_b2-li-2114"></a>evaluating with Horner's rule, 103 (ex. 2.34)</li>
<li><a id="c555_b2-li-2115"></a>hierarchy of types, 184</li>
<li><a id="c555_b2-li-2116"></a>indeterminate of, 177</li>
<li><a id="c555_b2-li-2117"></a>sparse, 181</li>
<li><a id="c555_b2-li-2118"></a>univariate, 177</li>
</ul></li>
<li><a id="c555_b2-li-2119"></a>polynomial arithmetic, 177–188<ul class="none">
<li><a id="c555_b2-li-2120"></a>addition, 178–181</li>
<li><a id="c555_b2-li-2121"></a>division, 183 (ex. 2.91)</li>
<li><a id="c555_b2-li-2122"></a>Euclid's Algorithm, 185<i>n</i></li>
<li><a id="c555_b2-li-2123"></a>greatest common divisor, 185–187, 188<i>n</i></li>
<li><a id="c555_b2-li-2124"></a>interfaced to generic arithmetic system, 178</li>
<li><a id="c555_b2-li-2125"></a>multiplication, 178–181</li>
<li><a id="c555_b2-li-2126"></a>probabilistic algorithm for GCD, 188<i>n</i></li>
<li><a id="c555_b2-li-2127"></a>rational functions, 184–188</li>
<li><a id="c555_b2-li-2128"></a>subtraction, 182 (ex. 2.88)</li>
</ul></li>
<li><a id="c555_b2-li-2129"></a><span class="KeyTerm1">pop</span>, <i>471</i></li>
<li><a id="c555_b2-li-2130"></a>porting a language, 561</li>
<li><a id="c555_b2-li-2131"></a>PowerPC, 279<i>n</i></li>
<li><a id="c555_b2-li-2132"></a>power series, as stream, 294 (ex. 3.59)<ul class="none">
<li><a id="c555_b2-li-2133"></a>adding, 294 (ex. 3.60)</li>
<li><a id="c555_b2-li-2134"></a>dividing, 295 (ex. 3.62)</li>
<li><a id="c555_b2-li-2135"></a>integrating, 294 (ex. 3.59)</li>
<li><a id="c555_b2-li-2136"></a>multiplying, 294 (ex. 3.60)</li>
</ul></li>
<li><a id="c555_b2-li-2137"></a>precedence<ul class="none">
<li><a id="c555_b2-li-2138"></a>of conditional expression, 17 (ex. 1.1)</li>
<li><a id="c555_b2-li-2139"></a>of lambda expression, 55</li>
<li><a id="c555_b2-li-2140"></a>of operators, 5</li>
<li><a id="c555_b2-li-2141"></a>of unary operators, 16</li>
</ul></li>
<li><a id="c555_b2-li-2142"></a>predicate, 14<ul class="none">
<li><a id="c555_b2-li-2143"></a>of clause, 15</li>
<li><a id="c555_b2-li-2144"></a>of conditional expression, 14 </li>
<li><a id="c555_b2-li-2145"></a>of conditional statement, 57</li>
<li><a id="c555_b2-li-2146"></a>naming convention for, 20<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2147"></a>prefix code, 140</li>
<li><a id="c555_b2-li-2148"></a>prefix notation, 128<ul class="none">
<li><a id="c555_b2-li-2149"></a>infix notation vs., 131 (ex. 2.58)</li>
</ul></li>
<li><a id="c555_b2-li-2150"></a>prefix operator, 15</li>
<li><a id="c555_b2-li-2151"></a><span class="KeyTerm1">prepositions</span>, <i>382</i></li>
<li><a id="c555_b2-li-2152"></a><span class="KeyTerm1">preserving</span>, 524, 526 (ex. 5.32), <i>545</i>, 553 (ex. 5.40)</li>
<li><a id="c555_b2-li-2153"></a>pretty-printing, 335 (ex. 4.2)</li>
<li><a id="c555_b2-li-2154"></a>prime number(s), 43–46<ul class="none">
<li><a id="c555_b2-li-2155"></a>cryptography and, 46<i>n</i></li>
<li><a id="c555_b2-li-2156"></a>Eratosthenes's sieve for, 289</li>
<li><a id="c555_b2-li-2157"></a>Fermat test for, 44–45</li>
<li><a id="c555_b2-li-2158"></a>infinite stream of, <i>see</i> <span class="KeyTerm1">primes</span></li>
<li><a id="c555_b2-li-2159"></a>Miller–Rabin test for, 48 (ex. 1.28)</li>
<li><a id="c555_b2-li-2160"></a>testing for, 43–48</li>
</ul></li>
<li><a id="c555_b2-li-2161"></a><span class="KeyTerm1">primes</span> (infinite stream), <i>289</i>
<ul class="none">
<li><a id="c555_b2-li-2162"></a>implicit definition, <i>291</i></li>
</ul></li>
<li><a id="c555_b2-li-2163"></a><span class="KeyTerm1">prime_sum_pair</span>, <i>373</i></li>
<li><a id="c555_b2-li-2164"></a><span class="KeyTerm1">prime_sum_pairs</span>, <i>107</i>
<ul class="none">
<li><a id="c555_b2-li-2165"></a>infinite stream, 299</li>
</ul></li>
<li><a id="c555_b2-li-2166"></a><span class="KeyTerm1">primitive_apply</span>, <i>507</i></li>
<li><a id="c555_b2-li-2167"></a>primitive constraints, 253</li>
<li><a id="c555_b2-li-2168"></a>primitive expression, 3<ul class="none">
<li><a id="c555_b2-li-2169"></a>evaluation of, 7</li>
<li><a id="c555_b2-li-2170"></a>name of constant, 5</li>
<li><a id="c555_b2-li-2171"></a>number, 3</li>
</ul></li>
<li><a id="c555_b2-li-2172"></a>primitive function, 10</li>
<li><a id="c555_b2-li-2173"></a><span class="KeyTerm1">primitive_function_objects</span>, <i>345</i></li>
<li><a id="c555_b2-li-2174"></a>primitive functions (ECMAScript equivalent in parentheses; those marked <i>ns</i> are not in the ECMAScript standard)<ul class="none">
<li><a id="c555_b2-li-2175"></a><span class="KeyTerm1">apply</span> (<span class="KeyTerm1">apply</span>), 346<i>n</i></li>
<li><a id="c555_b2-li-2176"></a><span class="KeyTerm1">display</span> (<i>ns</i>), 75<i>n</i></li>
<li><a id="c555_b2-li-2177"></a><span class="KeyTerm1">error</span> (<i>ns</i>), 60<i>n</i></li>
<li><a id="c555_b2-li-2178"></a><span class="KeyTerm1">eval</span>, 350</li>
<li><a id="c555_b2-li-2179"></a><span class="KeyTerm1">get_time</span> (<span class="KeyTerm1">new Date().getTime</span>), 46 (ex. 1.22)</li>
<li><a id="c555_b2-li-2180"></a><span class="KeyTerm1">head</span> (<i>ns</i>), 73</li>
<li><a id="c555_b2-li-2181"></a><span class="KeyTerm1">is_null</span> (<i>ns</i>), 87</li>
<li><a id="c555_b2-li-2182"></a><span class="KeyTerm1">is_number</span> (<i>ns</i>), 127</li>
<li><a id="c555_b2-li-2183"></a><span class="KeyTerm1">is_pair</span> (<i>ns</i>), 94</li>
<li><a id="c555_b2-li-2184"></a><span class="KeyTerm1">is_string</span> (<i>ns</i>), 128</li>
<li><a id="c555_b2-li-2185"></a><span class="KeyTerm1">is_undefined</span>, 157</li>
<li><a id="c555_b2-li-2186"></a><span class="KeyTerm1">list</span> (<i>ns</i>), 86</li>
<li><a id="c555_b2-li-2187"></a><span class="KeyTerm1">math_atan2</span> (<span class="KeyTerm1">Math.atan2</span>), 151<i>n</i></li>
<li><a id="c555_b2-li-2188"></a><span class="KeyTerm1">math_cos</span> (<span class="KeyTerm1">Math.cos</span>), 61</li>
<li><a id="c555_b2-li-2189"></a><span class="KeyTerm1">math_floor</span> (<span class="KeyTerm1">Math.floor</span>), 45</li>
<li><a id="c555_b2-li-2190"></a><span class="KeyTerm1">math_log</span> (<span class="KeyTerm1">Math.log</span>), 10, 62 (ex. 1.36)</li>
<li><a id="c555_b2-li-2191"></a><span class="KeyTerm1">math_max</span> (<span class="KeyTerm1">Math.max</span>), 81</li>
<li><a id="c555_b2-li-2192"></a><span class="KeyTerm1">math_min</span> (<span class="KeyTerm1">Math.min</span>), 81</li>
<li><a id="c555_b2-li-2193"></a><span class="KeyTerm1">math_random</span> (<span class="KeyTerm1">Math.random</span>), 44</li>
<li><a id="c555_b2-li-2194"></a><span class="KeyTerm1">math_round</span> (<span class="KeyTerm1">Math.round</span>), 176<i>n</i></li>
<li><a id="c555_b2-li-2195"></a><span class="KeyTerm1">math_sin</span> (<span class="KeyTerm1">Math.sin</span>), 61</li>
<li><a id="c555_b2-li-2196"></a><span class="KeyTerm1">math_trunc</span> (<span class="KeyTerm1">Math.trunc</span>), 293 (ex. 3.58)</li>
<li><a id="c555_b2-li-2197"></a><span class="KeyTerm1">pair</span> (<i>ns</i>), 73</li>
<li><a id="c555_b2-li-2198"></a><span class="KeyTerm1">prompt</span> (<i>ns</i>), 347</li>
<li><a id="c555_b2-li-2199"></a><span class="KeyTerm1">set_head</span> (<i>ns</i>), 223</li>
<li><a id="c555_b2-li-2200"></a><span class="KeyTerm1">set_tail</span> (<i>ns</i>), 223</li>
<li><a id="c555_b2-li-2201"></a><span class="KeyTerm1">stringify</span> (<span class="KeyTerm1">JSON.stringify</span>), 75</li>
<li><a id="c555_b2-li-2202"></a><span class="KeyTerm1">tail</span> (<i>ns</i>), 73</li>
<li><a id="c555_b2-li-2203"></a><span class="KeyTerm1">vector_ref</span> (<i>ns</i>), 488</li>
<li><a id="c555_b2-li-2204"></a><span class="KeyTerm1">vector_set</span> (<i>ns</i>), 488</li>
<li><a id="c555_b2-li-2205"></a><span class="KeyTerm1">primitive_function_symbols</span>, <i>345</i></li>
</ul></li>
<li><a id="c555_b2-li-2206"></a><span class="KeyTerm1">primitive_implementation</span>, <i>345</i></li>
<li><a id="c555_b2-li-2207"></a>primitive query, <i>see</i> simple query principle of least commitment, 152</li>
<li><a id="c555_b2-li-2208"></a><span class="KeyTerm1">print_point</span>, <i>78</i> (ex. 2.2)</li>
<li><a id="c555_b2-li-2209"></a><span class="KeyTerm1">print_queue</span>, 234 (ex. 3.21)</li>
<li><a id="c555_b2-li-2210"></a><span class="KeyTerm1">print_rat</span>, <i>75</i></li>
<li><a id="c555_b2-li-2211"></a><span class="KeyTerm1">print_result</span>, <i>514</i>
<ul class="none">
<li><a id="c555_b2-li-2212"></a>monitored-stack version, <i>516</i></li>
</ul></li>
<li><a id="c555_b2-li-2213"></a><span class="KeyTerm1">print_stack_statistics</span> operation in register machine, 484</li>
<li><a id="c555_b2-li-2214"></a>probabilistic algorithm, 45–46, 188<i>n</i>, 289<i>n</i></li>
<li><a id="c555_b2-li-2215"></a><span class="KeyTerm1">probe</span>
<ul class="none">
<li><a id="c555_b2-li-2216"></a>in constraint system, <i>258</i></li>
<li><a id="c555_b2-li-2217"></a>in digital-circuit simulator, <i>248</i></li>
</ul></li>
<li><a id="c555_b2-li-2218"></a>process, 1<ul class="none">
<li><a id="c555_b2-li-2219"></a>iterative, 29</li>
<li><a id="c555_b2-li-2220"></a>linear iterative, 29</li>
<li><a id="c555_b2-li-2221"></a>linear recursive, 29</li>
<li><a id="c555_b2-li-2222"></a>local evolution of, 26</li>
<li><a id="c555_b2-li-2223"></a>order of growth of, 36</li>
<li><a id="c555_b2-li-2224"></a>recursive, 29</li>
<li><a id="c555_b2-li-2225"></a>resources required by, 36</li>
<li><a id="c555_b2-li-2226"></a>shape of, 28</li>
<li><a id="c555_b2-li-2227"></a>tree-recursive, 32–35</li>
</ul></li>
<li><a id="c555_b2-li-2228"></a><span class="KeyTerm1">product</span>, 52 (ex. 1.31)<ul class="none">
<li><a id="c555_b2-li-2229"></a>as accumulation, 53 (ex. 1.32)</li>
</ul></li>
<li><a id="c555_b2-li-2230"></a>program, 1<ul class="none">
<li><a id="c555_b2-li-2231"></a>as abstract machine, 348</li>
<li><a id="c555_b2-li-2232"></a>comments in, 108<i>n</i></li>
<li><a id="c555_b2-li-2233"></a>as data, 348–350</li>
<li><a id="c555_b2-li-2234"></a>incremental development of, 6</li>
<li><a id="c555_b2-li-2235"></a>structured with subroutines, 349<i>n</i></li>
<li><a id="c555_b2-li-2236"></a>structure of, 6, 22, 24–26, <i>see also</i> abstraction barriers</li>
<li><a id="c555_b2-li-2237"></a>value of, 338 (ex. 4.8)</li>
</ul></li>
<li><a id="c555_b2-li-2238"></a>program counter, 472</li>
<li><a id="c555_b2-li-2239"></a>program environment, 6, 207, 221</li>
<li><a id="c555_b2-li-2240"></a>programming<ul class="none">
<li><a id="c555_b2-li-2241"></a>data-directed, <i>see</i> data-directed programming</li>
<li><a id="c555_b2-li-2242"></a>demand-driven, 286</li>
<li><a id="c555_b2-li-2243"></a>elements of, 3</li>
<li><a id="c555_b2-li-2244"></a>functional, <i>see</i> functional programming</li>
<li><a id="c555_b2-li-2245"></a>imperative, 204</li>
<li><a id="c555_b2-li-2246"></a>odious style, 287<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2247"></a>programming language, 1<ul class="none">
<li><a id="c555_b2-li-2248"></a>design of, 360</li>
<li><a id="c555_b2-li-2249"></a>functional, 314</li>
<li><a id="c555_b2-li-2250"></a>logic, 400</li>
<li><a id="c555_b2-li-2251"></a>object-oriented, 174<i>n</i></li>
<li><a id="c555_b2-li-2252"></a>statically typed, 310<i>n</i></li>
<li><a id="c555_b2-li-2253"></a>very high-level, 18<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2254"></a>Prolog, 376<i>n</i>, 399<i>n</i></li>
<li><a id="c555_b2-li-2255"></a>promise to evaluate, 283<ul class="none">
<li><a id="c555_b2-li-2256"></a>lazy evaluation and, 370</li>
</ul></li>
<li><a id="c555_b2-li-2257"></a><span class="KeyTerm1">prompt</span> (primitive function), 347</li>
<li><a id="c555_b2-li-2258"></a><span class="KeyTerm1">prompt</span> operation in register machine, 454</li>
<li><a id="c555_b2-li-2259"></a>prompts, 346<ul class="none">
<li><a id="c555_b2-li-2260"></a>explicit-control evaluator, 514</li>
<li><a id="c555_b2-li-2261"></a>lazy evaluator, 365</li>
<li><a id="c555_b2-li-2262"></a>metacircular evaluator, 346</li>
<li><a id="c555_b2-li-2263"></a>nondeterministic evaluator, 395</li>
<li><a id="c555_b2-li-2264"></a>query interpreter, 425</li>
</ul></li>
<li><a id="c555_b2-li-2265"></a><span class="KeyTerm1">propagate</span>, <i>248</i></li>
<li><a id="c555_b2-li-2266"></a>propagation of constraints, 252–262</li>
<li><a id="c555_b2-li-2267"></a>proving programs correct, 18<i>n</i></li>
<li><a id="c555_b2-li-2268"></a>pseudodivision of polynomials, 187</li>
<li><a id="c555_b2-li-2269"></a>pseudo-random sequence, 197<i>n</i></li>
<li><a id="c555_b2-li-2270"></a>pseudoremainder of polynomials, 187 <span class="KeyTerm1">push</span>, <i>471</i></li>
<li><a id="c555_b2-li-2271"></a><span class="KeyTerm1">push_marker_to_stack</span> (in register machine), 508, 511 (ex. 5.24)</li>
<li><a id="c555_b2-li-2272"></a><span class="KeyTerm1">put</span>, 157, <i>239</i></li>
<li><a id="c555_b2-li-2273"></a>puzzles<ul class="none">
<li><a id="c555_b2-li-2274"></a>eight-queens puzzle, 108 (ex. 2.42), 380 (ex. 4.42)</li>
<li><a id="c555_b2-li-2275"></a>logic puzzles, 378–380</li>
</ul></li>
<li><a id="c555_b2-li-2276"></a>Pythagorean triples<ul class="none">
<li><a id="c555_b2-li-2277"></a>with nondeterministic programs, 377 (ex. 4.33), 378 (ex. 4.34), 378 (ex. 4.35)</li>
<li><a id="c555_b2-li-2278"></a>with streams, 301 (ex. 3.69)</li>
</ul></li>
<li><a id="c555_b2-li-2279"></a>Python, recursive functions in, 30</li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-2280"></a>quantum mechanics, 315<i>n</i></li>
<li><a id="c555_b2-li-2281"></a><span class="KeyTerm1">queens</span>, <i>109</i> (ex. 2.42)</li>
<li><a id="c555_b2-li-2282"></a>query, 400, <i>see also</i> compound query; simple query</li>
<li><a id="c555_b2-li-2283"></a><span class="KeyTerm1">query_driver_loop</span>, <i>425</i></li>
<li><a id="c555_b2-li-2284"></a>query interpreter, 400<ul class="none">
<li><a id="c555_b2-li-2285"></a>adding rule or assertion, 419</li>
<li><a id="c555_b2-li-2286"></a>compound query, <i>see</i> compound query</li>
<li><a id="c555_b2-li-2287"></a>data base, 434–435</li>
<li><a id="c555_b2-li-2288"></a>driver loop, 418, 424–425</li>
<li><a id="c555_b2-li-2289"></a>environment structure in, 447 (ex. 4.76)</li>
<li><a id="c555_b2-li-2290"></a>frame, 412, 444</li>
<li><a id="c555_b2-li-2291"></a>improvements to, 423 (ex. 4.65), 446 (ex. 4.73), 446 (ex. 4.74)</li>
<li><a id="c555_b2-li-2292"></a>infinite loops, 420–421, 423 (ex. 4.65)</li>
<li><a id="c555_b2-li-2293"></a>instantiation, 425, 439–441</li>
<li><a id="c555_b2-li-2294"></a>JavaScript interpreter vs., 417, 418, 447 (ex. 4.76)</li>
<li><a id="c555_b2-li-2295"></a>as nondeterministic program, 447 (ex. 4.75)</li>
<li><a id="c555_b2-li-2296"></a>overview, 411–419</li>
<li><a id="c555_b2-li-2297"></a>pattern matching, 412, 428–429</li>
<li><a id="c555_b2-li-2298"></a>pattern-variable representation, 437</li>
<li><a id="c555_b2-li-2299"></a>problems with <span class="KeyTerm1">not</span> and <span class="KeyTerm1">javascript_predicate</span>, 421–422, 446 (ex. 4.74)</li>
<li><a id="c555_b2-li-2300"></a>query evaluator, 418, 425–428</li>
<li><a id="c555_b2-li-2301"></a>rule, <i>see</i> rule</li>
<li><a id="c555_b2-li-2302"></a>simple query, <i>see</i> simple query stream operations, 435–436</li>
<li><a id="c555_b2-li-2303"></a>streams of frames, 412, 419<i>n</i></li>
<li><a id="c555_b2-li-2304"></a>syntax of query language, 436–444</li>
<li><a id="c555_b2-li-2305"></a>unification, 415–417, 431–433</li>
</ul></li>
<li><a id="c555_b2-li-2306"></a>query language, 400–411<ul class="none">
<li><a id="c555_b2-li-2307"></a>abstraction in, 407</li>
<li><a id="c555_b2-li-2308"></a>compound query, <i>see</i> compound query</li>
<li><a id="c555_b2-li-2309"></a>data base, 401–403</li>
<li><a id="c555_b2-li-2310"></a>equality testing in, 406<i>n</i></li>
<li><a id="c555_b2-li-2311"></a>extensions to, 423 (ex. 4.64), 445 (ex. 4.72)</li>
<li><a id="c555_b2-li-2312"></a>logical deductions, 409–411</li>
<li><a id="c555_b2-li-2313"></a>mathematical logic vs., 419–424</li>
<li><a id="c555_b2-li-2314"></a>rule, <i>see</i> rule</li>
<li><a id="c555_b2-li-2315"></a>simple query, <i>see</i> simple query</li>
</ul></li>
<li><a id="c555_b2-li-2316"></a>query-language-specific representation, 436–444<ul class="none">
<li><a id="c555_b2-li-2317"></a>transforming JavaScript syntax into, 438</li>
</ul></li>
<li><a id="c555_b2-li-2318"></a>queue, 231–235<ul class="none">
<li><a id="c555_b2-li-2319"></a>double-ended, 235 (ex. 3.23)</li>
<li><a id="c555_b2-li-2320"></a>front of, 231</li>
<li><a id="c555_b2-li-2321"></a>functional implementation of, 235 (ex. 3.22)</li>
<li><a id="c555_b2-li-2322"></a>operations on, 231</li>
<li><a id="c555_b2-li-2323"></a>rear of, 231</li>
<li><a id="c555_b2-li-2324"></a>in simulation agenda, 250</li>
</ul></li>
<li><a id="c555_b2-li-2325"></a>quotation marks<ul class="none">
<li><a id="c555_b2-li-2326"></a>back quotes, 546</li>
<li><a id="c555_b2-li-2327"></a>double, 124</li>
<li><a id="c555_b2-li-2328"></a>single, 126 (ex. 2.55)</li>
</ul></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-2329"></a>Rabin, Michael O., 48 (ex. 1.28)</li>
<li><a id="c555_b2-li-2330"></a>radicand, 19</li>
<li><a id="c555_b2-li-2331"></a>Ramanujan, Srinivasa, 302<i>n</i></li>
<li><a id="c555_b2-li-2332"></a>Ramanujan numbers, 302 (ex. 3.71)</li>
<li><a id="c555_b2-li-2333"></a><span class="KeyTerm1">rand</span>, <i>197</i>
<ul class="none">
<li><a id="c555_b2-li-2334"></a>with reset, 200 (ex. 3.6)</li>
</ul></li>
<li><a id="c555_b2-li-2335"></a><span class="KeyTerm1">random_in_range</span>, <i>200</i> (ex. 3.5)</li>
<li><a id="c555_b2-li-2336"></a>random-number generator, 191<i>n</i>, 197<ul class="none">
<li><a id="c555_b2-li-2337"></a>in Monte Carlo simulation, 198</li>
<li><a id="c555_b2-li-2338"></a>in primality testing, 44</li>
<li><a id="c555_b2-li-2339"></a>with reset, 200 (ex. 3.6)</li>
<li><a id="c555_b2-li-2340"></a>with reset, stream version, 312 (ex. 3.81)</li>
</ul></li>
<li><a id="c555_b2-li-2341"></a><span class="KeyTerm1">random_numbers</span> (infinite stream), <i>312</i></li>
<li><a id="c555_b2-li-2342"></a>Raphael, Bertram, 399<i>n</i></li>
<li><a id="c555_b2-li-2343"></a><span class="KeyTerm1">rational</span> package, 166</li>
<li><a id="c555_b2-li-2344"></a>rational function, 184–188<ul class="none">
<li><a id="c555_b2-li-2345"></a>reducing to lowest terms, 187–188</li>
</ul></li>
<li><a id="c555_b2-li-2346"></a>rational number(s)<ul class="none">
<li><a id="c555_b2-li-2347"></a>arithmetic operations on, 72–76</li>
<li><a id="c555_b2-li-2348"></a>printing, 75</li>
<li><a id="c555_b2-li-2349"></a>reducing to lowest terms, 75, 77</li>
<li><a id="c555_b2-li-2350"></a>represented as pairs, 74</li>
</ul></li>
<li><a id="c555_b2-li-2351"></a>rational-number arithmetic, 72–76<ul class="none">
<li><a id="c555_b2-li-2352"></a>interfaced to generic arithmetic system, 166</li>
<li><a id="c555_b2-li-2353"></a>need for compound data, 69</li>
<li><a id="c555_b2-li-2354"></a>rational tree, 432<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2355"></a>Raymond, Eric, 361<i>n</i>, 376<i>n</i></li>
<li><a id="c555_b2-li-2356"></a>RC circuit, 303 (ex. 3.73)</li>
<li><a id="c555_b2-li-2357"></a><span class="KeyTerm1">read_evaluate_print_loop</span>, <i>514</i></li>
<li><a id="c555_b2-li-2358"></a>read-evaluate-print loop, 5, <i>see also</i> driver loop real number, 3<i>n</i> </li>
<li><a id="c555_b2-li-2359"></a><span class="KeyTerm1">real_part</span>
<ul class="none">
<li><a id="c555_b2-li-2360"></a>data-directed, <i>160</i></li>
<li><a id="c555_b2-li-2361"></a>polar representation, <i>152</i></li>
<li><a id="c555_b2-li-2362"></a>rectangular representation, <i>151</i></li>
<li><a id="c555_b2-li-2363"></a>with tagged data, <i>154</i></li>
</ul></li>
<li><a id="c555_b2-li-2364"></a><span class="KeyTerm1">real_part_polar</span>, <i>154</i></li>
<li><a id="c555_b2-li-2365"></a><span class="KeyTerm1">real_part_rectangular</span>, <i>153</i></li>
<li><a id="c555_b2-li-2366"></a><span class="KeyTerm1">rear_ptr</span>, <i>232</i></li>
<li><a id="c555_b2-li-2367"></a><span class="KeyTerm1">receive</span> function, 475<i>n</i></li>
<li><a id="c555_b2-li-2368"></a>record, in a data base, 139</li>
<li><a id="c555_b2-li-2369"></a>rectangle, representing, 78 (ex. 2.3)</li>
<li><a id="c555_b2-li-2370"></a><span class="KeyTerm1">rectangular</span> package, 157</li>
<li><a id="c555_b2-li-2371"></a>recursion, 7<ul class="none">
<li><a id="c555_b2-li-2372"></a>data-directed, 180</li>
<li><a id="c555_b2-li-2373"></a>expressing complicated process, 7</li>
<li><a id="c555_b2-li-2374"></a>mutual, 221</li>
<li><a id="c555_b2-li-2375"></a>in rules, 408</li>
<li><a id="c555_b2-li-2376"></a>in working with trees, 93</li>
</ul></li>
<li><a id="c555_b2-li-2377"></a>recursion theory, 350<i>n</i></li>
<li><a id="c555_b2-li-2378"></a>recursive function<ul class="none">
<li><a id="c555_b2-li-2379"></a>recursive function declaration, 21</li>
<li><a id="c555_b2-li-2380"></a>recursive process vs., 30</li>
<li><a id="c555_b2-li-2381"></a>specifying without declaration, 352 (ex. 4.18)</li>
</ul></li>
<li><a id="c555_b2-li-2382"></a>recursive process, 29<ul class="none">
<li><a id="c555_b2-li-2383"></a>iterative process vs., 27–30, 212 (ex. 3.9), 462, 549 (ex. 5.37)</li>
<li><a id="c555_b2-li-2384"></a>linear, 29, 37</li>
<li><a id="c555_b2-li-2385"></a>recursive function vs., 30</li>
<li><a id="c555_b2-li-2386"></a>register machine for, 462–467</li>
<li><a id="c555_b2-li-2387"></a>tree, 32–35, 37</li>
</ul></li>
<li><a id="c555_b2-li-2388"></a>red-black tree, 137<i>n</i></li>
<li><a id="c555_b2-li-2389"></a>reducing to lowest terms, 75, 77, 187–188</li>
<li><a id="c555_b2-li-2390"></a>Rees, Jonathan A., 356<i>n</i></li>
<li><a id="c555_b2-li-2391"></a>referential transparency, 203</li>
<li><a id="c555_b2-li-2392"></a><span class="KeyTerm1">reg</span> (in register machine), 453, <i>482</i>
<ul class="none">
<li><a id="c555_b2-li-2393"></a>simulating, 482</li>
</ul></li>
<li><a id="c555_b2-li-2394"></a>register(s), 449<ul class="none">
<li><a id="c555_b2-li-2395"></a>representing, 470</li>
<li><a id="c555_b2-li-2396"></a>tracing, 486 (ex. 5.17)</li>
</ul></li>
<li><a id="c555_b2-li-2397"></a><span class="KeyTerm1">register_exp_reg</span>, <i>482</i></li>
<li><a id="c555_b2-li-2398"></a>register machine, 449<ul class="none">
<li><a id="c555_b2-li-2399"></a>actions, 454–455</li>
<li><a id="c555_b2-li-2400"></a>controller, 450–452</li>
<li><a id="c555_b2-li-2401"></a>controller diagram, 451</li>
<li><a id="c555_b2-li-2402"></a>data-path diagram, 450</li>
<li><a id="c555_b2-li-2403"></a>data paths, 450–452</li>
<li><a id="c555_b2-li-2404"></a>design of, 450–468</li>
<li><a id="c555_b2-li-2405"></a>language for describing, 452–455</li>
<li><a id="c555_b2-li-2406"></a>monitoring performance, 484–487</li>
<li><a id="c555_b2-li-2407"></a>simulator, 468–487</li>
<li><a id="c555_b2-li-2408"></a>stack, 462–467</li>
<li><a id="c555_b2-li-2409"></a>subroutine, 457–460</li>
<li><a id="c555_b2-li-2410"></a>test operation, 451</li>
</ul></li>
<li><a id="c555_b2-li-2411"></a>register-machine language, 468<ul class="none">
<li><a id="c555_b2-li-2412"></a><span class="KeyTerm1">assign</span>, 453, 468, <i>478</i></li>
<li><a id="c555_b2-li-2413"></a><span class="KeyTerm1">branch</span>, 452, 468, <i>480</i></li>
<li><a id="c555_b2-li-2414"></a><span class="KeyTerm1">constant</span>, 453, 468, <i>482</i></li>
<li><a id="c555_b2-li-2415"></a>entry point, 452</li>
<li><a id="c555_b2-li-2416"></a><span class="KeyTerm1">go_to</span>, 452, 468, <i>480</i></li>
<li><a id="c555_b2-li-2417"></a>instructions, 452, 468, 477–484</li>
</ul></li>
<li><a id="c555_b2-li-2418"></a><span class="KeyTerm1">label</span>, 452, 468, <i>482</i>
<ul class="none">
<li><a id="c555_b2-li-2419"></a>label, 452</li>
<li><a id="c555_b2-li-2420"></a><span class="KeyTerm1">op</span>, 453, 468, <i>483</i></li>
<li><a id="c555_b2-li-2421"></a><span class="KeyTerm1">perform</span>, 455, 468, <i>481</i></li>
<li><a id="c555_b2-li-2422"></a><span class="KeyTerm1">push_marker_to_stack</span>, 508, 511 (ex. 5.24)</li>
<li><a id="c555_b2-li-2423"></a><span class="KeyTerm1">reg</span>, 453, 468, <i>482</i></li>
<li><a id="c555_b2-li-2424"></a><span class="KeyTerm1">restore</span>, 464, 468, <i>481</i></li>
<li><a id="c555_b2-li-2425"></a><span class="KeyTerm1">revert_stack_to_marker</span>, 508, 511 (ex. 5.24)</li>
<li><a id="c555_b2-li-2426"></a><span class="KeyTerm1">save</span>, 464, 468, <i>481</i></li>
<li><a id="c555_b2-li-2427"></a><span class="KeyTerm1">test</span>, 452, 468, <i>479</i></li>
</ul></li>
<li><a id="c555_b2-li-2428"></a>register-machine simulator, 468–487</li>
<li><a id="c555_b2-li-2429"></a><span class="KeyTerm1">registers_modified</span>, <i>543</i></li>
<li><a id="c555_b2-li-2430"></a><span class="KeyTerm1">registers_needed</span>, <i>543</i></li>
<li><a id="c555_b2-li-2431"></a>register table, in simulator, 472</li>
<li><a id="c555_b2-li-2432"></a>relations, computing in terms of, 253, 398</li>
<li><a id="c555_b2-li-2433"></a>relatively prime, 53 (ex. 1.33)</li>
<li><a id="c555_b2-li-2434"></a>relativity, theory of, 280</li>
<li><a id="c555_b2-li-2435"></a>release a mutex, 276</li>
<li><a id="c555_b2-li-2436"></a>remainder<ul class="none">
<li><a id="c555_b2-li-2437"></a>after integer division, 39</li>
<li><a id="c555_b2-li-2438"></a>modulo <i>n</i>, 44</li>
</ul></li>
<li><a id="c555_b2-li-2439"></a><span class="KeyTerm1">remainder_terms</span>, 186 (ex. 2.94)</li>
<li><a id="c555_b2-li-2440"></a><span class="KeyTerm1">remove</span>, <i>108</i></li>
<li><a id="c555_b2-li-2441"></a><span class="KeyTerm1">remove_first_agenda_item</span>, 248, <i>251</i></li>
<li><a id="c555_b2-li-2442"></a><span class="KeyTerm1">rename_variables_in</span>, <i>431</i></li>
<li><a id="c555_b2-li-2443"></a><span class="KeyTerm1">require</span>, <i>375</i>
<ul class="none">
<li><a id="c555_b2-li-2444"></a>as a syntactic form, 397 (ex. 4.52)</li>
</ul></li>
<li><a id="c555_b2-li-2445"></a>resistance<ul class="none">
<li><a id="c555_b2-li-2446"></a>formula for parallel resistors, 81, 83</li>
<li><a id="c555_b2-li-2447"></a>tolerance of resistors, 81</li>
</ul></li>
<li><a id="c555_b2-li-2448"></a>resolution, Horn-clause, 399<i>n</i></li>
<li><a id="c555_b2-li-2449"></a>resolution principle, 398<i>n</i></li>
<li><a id="c555_b2-li-2450"></a><span class="KeyTerm1">rest_conjuncts</span>, <i>443</i></li>
<li><a id="c555_b2-li-2451"></a><span class="KeyTerm1">rest_disjuncts</span>, <i>443</i></li>
<li><a id="c555_b2-li-2452"></a><span class="KeyTerm1">restore</span> (in register machine), 464, 483 (ex. 5.10)<ul class="none">
<li><a id="c555_b2-li-2453"></a>implementing, 491</li>
<li><a id="c555_b2-li-2454"></a>instruction constructor, <i>481</i></li>
<li><a id="c555_b2-li-2455"></a>simulating, 481</li>
</ul></li>
<li><a id="c555_b2-li-2456"></a>rest parameter and spread syntax, 276</li>
<li><a id="c555_b2-li-2457"></a><span class="KeyTerm1">rest_segments</span>, <i>250</i></li>
<li><a id="c555_b2-li-2458"></a><span class="KeyTerm1">rest_statements</span>, <i>332</i></li>
<li><a id="c555_b2-li-2459"></a><span class="KeyTerm1">rest_terms</span>, 179, <i>182</i></li>
<li><a id="c555_b2-li-2460"></a><span class="KeyTerm1">retry</span>, <i>377</i></li>
<li><a id="c555_b2-li-2461"></a><span class="KeyTerm1">return</span> (linkage descriptor), 523</li>
<li><a id="c555_b2-li-2462"></a><span class="KeyTerm1"><b>return</b></span> (keyword), 9, <i>see also</i> return statement</li>
<li><a id="c555_b2-li-2463"></a><span class="KeyTerm1">return_expression</span>, 333</li>
<li><a id="c555_b2-li-2464"></a>returning multiple values, 475<i>n</i></li>
<li><a id="c555_b2-li-2465"></a>return statement, 9<ul class="none">
<li><a id="c555_b2-li-2466"></a>handling in compiler, 543</li>
<li><a id="c555_b2-li-2467"></a>handling in explicit-control evaluator, 509</li>
<li><a id="c555_b2-li-2468"></a>handling in metacircular evaluator, 327</li>
<li><a id="c555_b2-li-2469"></a>parsing of, 333</li>
<li><a id="c555_b2-li-2470"></a>tail recursion and, 509, 541, 542</li>
</ul></li>
<li><a id="c555_b2-li-2471"></a><span class="KeyTerm1">return_undefined</span>, <i>509</i></li>
<li><a id="c555_b2-li-2472"></a>return value, 9<ul class="none">
<li><a id="c555_b2-li-2473"></a>representation in metacircular evaluator, 324, 340</li>
<li><a id="c555_b2-li-2474"></a><span class="KeyTerm1">undefined</span> as, 324, 509, 534, 539</li>
</ul></li>
<li><a id="c555_b2-li-2475"></a><span class="KeyTerm1">return_value_content</span>, <i>340</i></li>
<li><a id="c555_b2-li-2476"></a>Reuter, Andreas, 279<i>n</i></li>
<li><a id="c555_b2-li-2477"></a>Reuter, Andreas<span class="KeyTerm1">reverse</span>, 89 (ex. 2.18)<ul class="none">
<li><a id="c555_b2-li-2478"></a>as folding, 106 (ex. 2.39)</li>
<li><a id="c555_b2-li-2479"></a>rules, 424 (ex. 4.66)</li>
</ul></li>
<li><a id="c555_b2-li-2480"></a><span class="KeyTerm1">revert_stack_to_marker</span> (in register machine), 508, 511 (ex. 5.24)</li>
<li><a id="c555_b2-li-2481"></a>Rhind Papyrus, 40<i>n</i></li>
<li><a id="c555_b2-li-2482"></a>right-associative, 14</li>
<li><a id="c555_b2-li-2483"></a><span class="KeyTerm1">right_branch</span>, <i>136</i>, <i>143</i></li>
<li><a id="c555_b2-li-2484"></a><span class="KeyTerm1">right_split</span>, <i>115</i></li>
<li><a id="c555_b2-li-2485"></a>ripple-carry adder, 245 (ex. 3.30)</li>
<li><a id="c555_b2-li-2486"></a>Rivest, Ronald L., 46<i>n</i>, 137<i>n</i></li>
<li><a id="c555_b2-li-2487"></a>RLC circuit, 308 (ex. 3.80)</li>
<li><a id="c555_b2-li-2488"></a>Robinson, J. A., 399<i>n</i></li>
<li><a id="c555_b2-li-2489"></a>robustness, 123</li>
<li><a id="c555_b2-li-2490"></a>rock songs, 1950s, 146 (ex. 2.70)</li>
<li><a id="c555_b2-li-2491"></a>Rogers, William Barton, 112<i>n</i></li>
<li><a id="c555_b2-li-2492"></a><span class="KeyTerm1">root</span> register, 494</li>
<li><a id="c555_b2-li-2493"></a>roots of equation, <i>see</i> half-interval method; Newton's method</li>
<li><a id="c555_b2-li-2494"></a><span class="KeyTerm1">rotate90</span>, <i>121</i></li>
<li><a id="c555_b2-li-2495"></a>roundoff error, 3<i>n</i>, 149<i>n</i></li>
<li><a id="c555_b2-li-2496"></a>Rozas, Guillermo Juan, 541<i>n</i></li>
<li><a id="c555_b2-li-2497"></a>RSA algorithm, 46<i>n</i></li>
<li><a id="c555_b2-li-2498"></a>rule (query language), 407–411<ul class="none">
<li><a id="c555_b2-li-2499"></a>applying, 417–418, 430–431, 447 (ex. 4.76)</li>
<li><a id="c555_b2-li-2500"></a>without body, 407<i>n</i>, 410, 428</li>
</ul></li>
<li><a id="c555_b2-li-2501"></a><span class="KeyTerm1">rule_body</span>, <i>444</i></li>
<li><a id="c555_b2-li-2502"></a>Runkle, John Daniel, 112<i>n</i></li>
<li><a id="c555_b2-li-2503"></a>Russian peasant method of multiplication, 40<i>n</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-2504"></a><span class="KeyTerm1">same</span> (rule), <i>407</i></li>
<li><a id="c555_b2-li-2505"></a>sameness and change<ul class="none">
<li><a id="c555_b2-li-2506"></a>meaning of, 202–204</li>
<li><a id="c555_b2-li-2507"></a>shared data and, 226</li>
</ul></li>
<li><a id="c555_b2-li-2508"></a>satisfy a compound query, 405–406</li>
<li><a id="c555_b2-li-2509"></a>satisfy a pattern (simple query), 404</li>
<li><a id="c555_b2-li-2510"></a><span class="KeyTerm1">save</span> (in register machine), 464, 483 (ex. 5.10)<ul class="none">
<li><a id="c555_b2-li-2511"></a>implementing, 491</li>
<li><a id="c555_b2-li-2512"></a>instruction constructor, <i>481</i></li>
<li><a id="c555_b2-li-2513"></a>simulating, 481</li>
</ul></li>
<li><a id="c555_b2-li-2514"></a><span class="KeyTerm1">scale_list</span>, <i>90, 91</i>, <i>371</i></li>
<li><a id="c555_b2-li-2515"></a><span class="KeyTerm1">scale_stream</span>, <i>291</i></li>
<li><a id="c555_b2-li-2516"></a><span class="KeyTerm1">scale_tree</span>, <i>97</i></li>
<li><a id="c555_b2-li-2517"></a><span class="KeyTerm1">scale_vect</span>, 119 (ex. 2.46)</li>
<li><a id="c555_b2-li-2518"></a><span class="KeyTerm1">scan</span> register, 495</li>
<li><a id="c555_b2-li-2519"></a>scanning out declarations<ul class="none">
<li><a id="c555_b2-li-2520"></a>in compiler, 532, 560</li>
<li><a id="c555_b2-li-2521"></a>in explicit-control evaluator, 512</li>
<li><a id="c555_b2-li-2522"></a>in metacircular evaluator, 326, 352</li>
<li><a id="c555_b2-li-2523"></a>sequential declaration processing vs., 353–354</li>
</ul></li>
<li><a id="c555_b2-li-2524"></a><span class="KeyTerm1">scan_out_declarations</span>, <i>327</i></li>
<li><a id="c555_b2-li-2525"></a>Scheme<ul class="none">
<li><a id="c555_b2-li-2526"></a>evaluators written in, 319<i>n</i></li>
<li><a id="c555_b2-li-2527"></a>integrated-circuit implementation of, 499</li>
<li><a id="c555_b2-li-2528"></a>as JavaScript precursor, 2</li>
<li><a id="c555_b2-li-2529"></a><span class="KeyTerm1"><b>let</b>*</span> in, 336 (ex. 4.6)</li>
<li><a id="c555_b2-li-2530"></a>nondeterministic extension of, 376<i>n</i></li>
<li><a id="c555_b2-li-2531"></a>tail recursion in, 30<i>n</i></li>
<li><a id="c555_b2-li-2532"></a>use of “lambda” in, 55<i>n</i></li>
<li><a id="c555_b2-li-2533"></a><i>Y</i> operator written in, 353<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2534"></a>Scheme chip, 499</li>
<li><a id="c555_b2-li-2535"></a>Schmidt, Eric, 204<i>n</i></li>
<li><a id="c555_b2-li-2536"></a>scope of a name, 23, <i>see also</i> lexical scoping<ul class="none">
<li><a id="c555_b2-li-2537"></a>function's parameters, 24</li>
<li><a id="c555_b2-li-2538"></a>internal declaration, 351–355</li>
</ul></li>
<li><a id="c555_b2-li-2539"></a><span class="KeyTerm1">search</span>, <i>59</i></li>
<li><a id="c555_b2-li-2540"></a>search<ul class="none">
<li><a id="c555_b2-li-2541"></a>of binary tree, 135</li>
<li><a id="c555_b2-li-2542"></a>depth-first, 376</li>
<li><a id="c555_b2-li-2543"></a>systematic, 376</li>
</ul></li>
<li><a id="c555_b2-li-2544"></a><span class="KeyTerm1">segment_queue</span>, <i>250</i></li>
<li><a id="c555_b2-li-2545"></a><span class="KeyTerm1">segments</span>, <i>250</i></li>
<li><a id="c555_b2-li-2546"></a><span class="KeyTerm1">segments_to_painter</span>, <i>119</i></li>
<li><a id="c555_b2-li-2547"></a><span class="KeyTerm1">segment_time</span>, <i>250</i></li>
<li><a id="c555_b2-li-2548"></a>selector, 72<ul class="none">
<li><a id="c555_b2-li-2549"></a>as abstraction barrier, 76</li>
<li><a id="c555_b2-li-2550"></a>generic, 154, 155</li>
</ul></li>
<li><a id="c555_b2-li-2551"></a>Self, 2</li>
<li><a id="c555_b2-li-2552"></a>semaphore, 276<i>n</i></li>
<li><a id="c555_b2-li-2553"></a>of size <i>n</i>, 278 (ex. 3.47)</li>
<li><a id="c555_b2-li-2554"></a>semicolon (<span class="KeyTerm1">;</span>)<ul class="none">
<li><a id="c555_b2-li-2555"></a>cancer of, 30<i>n</i></li>
<li><a id="c555_b2-li-2556"></a>ending statement, 3, 5, 9</li>
</ul></li>
<li><a id="c555_b2-li-2557"></a>separator code, 140</li>
<li><a id="c555_b2-li-2558"></a>sequence(s), 85<ul class="none">
<li><a id="c555_b2-li-2559"></a>as conventional interface, 98–110</li>
<li><a id="c555_b2-li-2560"></a>as source of modularity, 102</li>
<li><a id="c555_b2-li-2561"></a>operations on, 100–106</li>
<li><a id="c555_b2-li-2562"></a>represented by pairs, 85</li>
</ul></li>
<li><a id="c555_b2-li-2563"></a>sequence accelerator, 296</li>
<li><a id="c555_b2-li-2564"></a>sequence of statements, 192<ul class="none">
<li><a id="c555_b2-li-2565"></a>in block, 192<i>n</i></li>
<li><a id="c555_b2-li-2566"></a>in conditional statement, 57</li>
<li><a id="c555_b2-li-2567"></a>in function body, 9<i>n</i></li>
<li><a id="c555_b2-li-2568"></a>as body of lambda expression, 116<i>n</i></li>
<li><a id="c555_b2-li-2569"></a>parsing of, 332</li>
</ul></li>
<li><a id="c555_b2-li-2570"></a>sequential declaration processing vs. scanning out, 353–354</li>
<li><a id="c555_b2-li-2571"></a><span class="KeyTerm1">serialized_exchange</span>, <i>274</i>
<ul class="none">
<li><a id="c555_b2-li-2572"></a>with deadlock avoidance, 279 (ex. 3.48)</li>
</ul></li>
<li><a id="c555_b2-li-2573"></a>serializer, 268–272<ul class="none">
<li><a id="c555_b2-li-2574"></a>implementing, 276–278</li>
<li><a id="c555_b2-li-2575"></a>with multiple shared resources, 272–275</li>
</ul></li>
<li><a id="c555_b2-li-2576"></a>series, summation of, 50<ul class="none">
<li><a id="c555_b2-li-2577"></a>accelerating sequence of</li>
<li><a id="c555_b2-li-2578"></a>approximations, 296</li>
<li><a id="c555_b2-li-2579"></a>with streams, 296</li>
</ul></li>
<li><a id="c555_b2-li-2580"></a>set, 131<ul class="none">
<li><a id="c555_b2-li-2581"></a>data base as, 139</li>
<li><a id="c555_b2-li-2582"></a>operations on, 131–132</li>
<li><a id="c555_b2-li-2583"></a>permutations of, 108</li>
<li><a id="c555_b2-li-2584"></a>represented as binary tree, 135–138</li>
<li><a id="c555_b2-li-2585"></a>represented as ordered list, 133–135</li>
<li><a id="c555_b2-li-2586"></a>represented as unordered list, 132–133</li>
<li><a id="c555_b2-li-2587"></a>subsets of, 98 (ex. 2.32)</li>
</ul></li>
<li><a id="c555_b2-li-2588"></a><span class="KeyTerm1">set_contents</span>, <i>471</i></li>
<li><a id="c555_b2-li-2589"></a><span class="KeyTerm1">set_current_environment</span>, <i>514</i></li>
<li><a id="c555_b2-li-2590"></a><span class="KeyTerm1">set_current_time</span>, <i>250</i></li>
<li><a id="c555_b2-li-2591"></a><span class="KeyTerm1">set_front_ptr</span>, <i>232</i></li>
<li><a id="c555_b2-li-2592"></a><span class="KeyTerm1">set_head</span> (primitive function), 223<ul class="none">
<li><a id="c555_b2-li-2593"></a>functional implementation of, <i>230</i></li>
<li><a id="c555_b2-li-2594"></a>implemented with vectors, 491</li>
<li><a id="c555_b2-li-2595"></a>value of, 223<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2596"></a><span class="KeyTerm1">set_inst_execution_fun</span>, <i>476</i></li>
<li><a id="c555_b2-li-2597"></a><span class="KeyTerm1">set_rear_ptr</span>, <i>232</i></li>
<li><a id="c555_b2-li-2598"></a><span class="KeyTerm1">set_register_contents</span>, 468, <i>472</i></li>
<li><a id="c555_b2-li-2599"></a><span class="KeyTerm1">set_segments</span>, <i>250</i></li>
<li><a id="c555_b2-li-2600"></a><span class="KeyTerm1">set_signal</span>, 244, <i>247</i></li>
<li><a id="c555_b2-li-2601"></a><span class="KeyTerm1">set_tail</span> (primitive function), 223<ul class="none">
<li><a id="c555_b2-li-2602"></a>functional implementation of, <i>230</i></li>
<li><a id="c555_b2-li-2603"></a>implemented with vectors, 491</li>
<li><a id="c555_b2-li-2604"></a>value of, 223<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2605"></a><span class="KeyTerm1">setup_environment</span>, <i>345</i></li>
<li><a id="c555_b2-li-2606"></a><span class="KeyTerm1">set_value</span>, 255, <i>261</i></li>
<li><a id="c555_b2-li-2607"></a>shadow a binding, 207</li>
<li><a id="c555_b2-li-2608"></a>Shamir, Adi, 46<i>n</i></li>
<li><a id="c555_b2-li-2609"></a>shape of a process, 28</li>
<li><a id="c555_b2-li-2610"></a>shared data, 226–229</li>
<li><a id="c555_b2-li-2611"></a>shared resources, 272–275</li>
<li><a id="c555_b2-li-2612"></a>shared state, 265</li>
<li><a id="c555_b2-li-2613"></a><span class="KeyTerm1">shrink_to_upper_right</span>, <i>121</i></li>
<li><a id="c555_b2-li-2614"></a>Shrobe, Howard E., 400<i>n</i></li>
<li><a id="c555_b2-li-2615"></a>SICP, xxi</li>
<li><a id="c555_b2-li-2616"></a><span class="KeyTerm1">sicp</span> JavaScript package, 10<i>n</i></li>
<li><a id="c555_b2-li-2617"></a>SICP JS, xxi</li>
<li><a id="c555_b2-li-2618"></a>side-effect bug, 204<i>n</i></li>
<li><a id="c555_b2-li-2619"></a>sieve of Eratosthenes, 289<ul class="none">
<li><a id="c555_b2-li-2620"></a><span class="KeyTerm1">sieve</span>, <i>289</i></li>
</ul></li>
<li><a id="c555_b2-li-2621"></a><span class="KeyTerm1">Σ</span> (sigma) notation, 50 </li>
<li><a id="c555_b2-li-2622"></a>signal, digital, 241</li>
<li><a id="c555_b2-li-2623"></a><span class="KeyTerm1">signal_error</span>, <i>515</i></li>
<li><a id="c555_b2-li-2624"></a>signal-flow diagram, 99, 305 (fig. 3.33)</li>
<li><a id="c555_b2-li-2625"></a>signal processing<ul class="none">
<li><a id="c555_b2-li-2626"></a>smoothing a function, 68 (ex. 1.44)</li>
<li><a id="c555_b2-li-2627"></a>smoothing a signal, 304 (ex. 3.75), 305 (ex. 3.76)</li>
<li><a id="c555_b2-li-2628"></a>stream model of, 302–305</li>
<li><a id="c555_b2-li-2629"></a>zero crossings of a signal, 304 (ex. 3.74), 304 (ex. 3.75), 305 (ex. 3.76)</li>
</ul></li>
<li><a id="c555_b2-li-2630"></a>signal-processing view of computation, 99</li>
<li><a id="c555_b2-li-2631"></a><span class="KeyTerm1">simple_query</span>, <i>426</i>
<ul class="none">
<li><a id="c555_b2-li-2632"></a>without delayed expression, <i>444</i> (ex. 4.68)</li>
</ul></li>
<li><a id="c555_b2-li-2633"></a>simple query, 403–404<ul class="none">
<li><a id="c555_b2-li-2634"></a>processing, 412, 413, 418, 426</li>
</ul></li>
<li><a id="c555_b2-li-2635"></a>simplification of algebraic expressions, 129</li>
<li><a id="c555_b2-li-2636"></a>Simpson's Rule for numerical integration, 52 (ex. 1.29)</li>
<li><a id="c555_b2-li-2637"></a>simulation<ul class="none">
<li><a id="c555_b2-li-2638"></a>of digital circuit, <i>see</i> digital-circuit simulation</li>
<li><a id="c555_b2-li-2639"></a>event-driven, 241</li>
<li><a id="c555_b2-li-2640"></a>as machine-design tool, 516</li>
<li><a id="c555_b2-li-2641"></a>for monitoring performance of register machine, 484</li>
<li><a id="c555_b2-li-2642"></a>Monte Carlo, <i>see</i> Monte Carlo simulation</li>
<li><a id="c555_b2-li-2643"></a>of register machine, 468–487</li>
</ul></li>
<li><a id="c555_b2-li-2644"></a>sine<ul class="none">
<li><a id="c555_b2-li-2645"></a>approximation for small angle, 37 (ex. 1.15)</li>
<li><a id="c555_b2-li-2646"></a>power series for, 294 (ex. 3.59)</li>
</ul></li>
<li><a id="c555_b2-li-2647"></a><span class="KeyTerm1">singleton_stream</span>, <i>436</i></li>
<li><a id="c555_b2-li-2648"></a>SKETCHPAD, 252<i>n</i></li>
<li><a id="c555_b2-li-2649"></a>slash (double slash <i>//</i> for comments in programs), 108<i>n</i></li>
<li><a id="c555_b2-li-2650"></a><span class="KeyTerm1">smallest_divisor</span>, <i>43</i>
<ul class="none">
<li><a id="c555_b2-li-2651"></a>more efficient version, 47 (ex. 1.23)</li>
</ul></li>
<li><a id="c555_b2-li-2652"></a>Smalltalk, 252<i>n</i></li>
<li><a id="c555_b2-li-2653"></a>smoothing a function, 68 (ex. 1.44)</li>
<li><a id="c555_b2-li-2654"></a>smoothing a signal, 304 (ex. 3.75), 305 (ex. 3.76)</li>
<li><a id="c555_b2-li-2655"></a>snake case, 10<i>n</i></li>
<li><a id="c555_b2-li-2656"></a>snarf, 361<i>n</i></li>
<li><a id="c555_b2-li-2657"></a>Solomonoff, Ray, 197<i>n</i></li>
<li><a id="c555_b2-li-2658"></a><span class="KeyTerm1">solve</span> differential equation, <i>306, 307</i>
<ul class="none">
<li><a id="c555_b2-li-2659"></a>lazy-list version, <i>372</i></li>
</ul></li>
<li><a id="c555_b2-li-2660"></a>solving equation, <i>see</i> half-interval method; Newton's method; <span class="KeyTerm1">solve</span></li>
<li><a id="c555_b2-li-2661"></a>source language, 520</li>
<li><a id="c555_b2-li-2662"></a>source program, 520</li>
<li><a id="c555_b2-li-2663"></a>Spafford, Eugene H., 561<i>n</i></li>
<li><a id="c555_b2-li-2664"></a>sparse polynomial, 181</li>
<li><a id="c555_b2-li-2665"></a><span class="KeyTerm1">split</span>, 117 (ex. 2.45)</li>
<li><a id="c555_b2-li-2666"></a>spread and rest parameter syntax, 276</li>
<li><a id="c555_b2-li-2667"></a><span class="KeyTerm1">sqrt</span>, <i>20</i>
<ul class="none">
<li><a id="c555_b2-li-2668"></a>block structured, <i>25</i></li>
<li><a id="c555_b2-li-2669"></a>in environment model, 218–220</li>
<li><a id="c555_b2-li-2670"></a>as fixed point, <i>61</i>, <i>64–66</i></li>
<li><a id="c555_b2-li-2671"></a>as iterative improvement, 68 (ex. 1.46)</li>
<li><a id="c555_b2-li-2672"></a>with Newton's method, <i>65, 66</i></li>
<li><a id="c555_b2-li-2673"></a>register machine for, 457 (ex. 5.3)</li>
<li><a id="c555_b2-li-2674"></a>as stream limit, <i>299</i> (ex. 3.64)</li>
</ul></li>
<li><a id="c555_b2-li-2675"></a><span class="KeyTerm1">sqrt_stream</span>, <i>296</i></li>
<li><a id="c555_b2-li-2676"></a><span class="KeyTerm1">square</span>, <i>8</i>
<ul class="none">
<li><a id="c555_b2-li-2677"></a>in environment model, 208–209</li>
</ul></li>
<li><a id="c555_b2-li-2678"></a><span class="KeyTerm1">square_limit</span>, <i>115</i>, <i>117</i>, 123 (ex. 2.52)</li>
<li><a id="c555_b2-li-2679"></a><span class="KeyTerm1">square_of_four</span>, <i>116</i>, 123 (ex. 2.52)</li>
<li><a id="c555_b2-li-2680"></a><span class="KeyTerm1">squarer</span> (constraint), 261 (ex. 3.34), 261 (ex. 3.35)</li>
<li><a id="c555_b2-li-2681"></a>square root, 18–20, <i>see also</i> <span class="KeyTerm1">sqrt</span>
<ul class="none">
<li><a id="c555_b2-li-2682"></a>stream of approximations, 296</li>
</ul></li>
<li><a id="c555_b2-li-2683"></a><span class="KeyTerm1">squash_inwards</span>, <i>121</i></li>
<li><a id="c555_b2-li-2684"></a>stack, 29<i>n</i>
<ul class="none">
<li><a id="c555_b2-li-2685"></a>framed, 504<i>n</i></li>
<li><a id="c555_b2-li-2686"></a>for recursion in register machine, 462–467</li>
<li><a id="c555_b2-li-2687"></a>representing, 471, 491</li>
</ul></li>
<li><a id="c555_b2-li-2688"></a>stack allocation and tail recursion, 541<i>n</i></li>
<li><a id="c555_b2-li-2689"></a><span class="KeyTerm1">stack_inst_reg_name</span>, <i>481</i></li>
<li><a id="c555_b2-li-2690"></a>Stallman, Richard M., 252<i>n</i>, 376<i>n</i></li>
<li><a id="c555_b2-li-2691"></a><span class="KeyTerm1">start</span> register machine, 469, <i>472</i></li>
<li><a id="c555_b2-li-2692"></a><span class="KeyTerm1">start_eceval</span>, <i>559n</i></li>
<li><a id="c555_b2-li-2693"></a><span class="KeyTerm1">start_segment</span>, 77 (ex. 2.2), 120 (ex. 2.48)</li>
<li><a id="c555_b2-li-2694"></a>state<ul class="none">
<li><a id="c555_b2-li-2695"></a>local, <i>see</i> local state</li>
<li><a id="c555_b2-li-2696"></a>shared, 265</li>
<li><a id="c555_b2-li-2697"></a>vanishes in stream formulation, 313</li>
</ul></li>
<li><a id="c555_b2-li-2698"></a>statement, 3<ul class="none">
<li><a id="c555_b2-li-2699"></a>value-producing and non-value-producing, 338 (ex. 4.8)</li>
<li><a id="c555_b2-li-2700"></a>statement sequence, <i>see</i> sequence of statements</li>
</ul></li>
<li><a id="c555_b2-li-2701"></a>state variable, 29, 190<ul class="none">
<li><a id="c555_b2-li-2702"></a>local, 190–197</li>
</ul></li>
<li><a id="c555_b2-li-2703"></a>statically typed language, 310<i>n</i></li>
<li><a id="c555_b2-li-2704"></a>Steele, Guy Lewis Jr., 30<i>n</i>, 205<i>n</i>, 252<i>n</i>, 361<i>n</i>, 376<i>n</i></li>
<li><a id="c555_b2-li-2705"></a>Stein, Clifford, 137<i>n</i></li>
<li><a id="c555_b2-li-2706"></a>stop-and-copy garbage collector, 493–498</li>
<li><a id="c555_b2-li-2707"></a>Stoy, Joseph E., 12<i>n</i>, 41<i>n</i>, 353<i>n</i></li>
<li><a id="c555_b2-li-2708"></a>Strachey, Christopher, 67<i>n</i></li>
<li><a id="c555_b2-li-2709"></a>stratified design, 123</li>
<li><a id="c555_b2-li-2710"></a>stream(s), 189, 280–315<ul class="none">
<li><a id="c555_b2-li-2711"></a>delayed evaluation and, 305–309</li>
<li><a id="c555_b2-li-2712"></a>empty, 283</li>
<li><a id="c555_b2-li-2713"></a>implemented as delayed lists, 281–283</li>
<li><a id="c555_b2-li-2714"></a>implemented as lazy lists, 370–372</li>
<li><a id="c555_b2-li-2715"></a>implicit definition, 290–292</li>
</ul></li>
<li><a id="c555_b2-li-2716"></a>infinite, <i>see</i> infinite streams</li>
<li><a id="c555_b2-li-2717"></a>used in query interpreter, 412, 419<i>n</i></li>
<li><a id="c555_b2-li-2718"></a><span class="KeyTerm1">stream_append</span>, <i>300</i></li>
<li><a id="c555_b2-li-2719"></a><span class="KeyTerm1">stream_append_delayed</span>, <i>435</i></li>
<li><a id="c555_b2-li-2720"></a><span class="KeyTerm1">stream_enumerate_interval</span>, <i>284</i></li>
<li><a id="c555_b2-li-2721"></a><span class="KeyTerm1">stream_filter</span>, <i>285</i></li>
<li><a id="c555_b2-li-2722"></a><span class="KeyTerm1">stream_flatmap</span>, <i>436</i>, 445 (ex. 4.71)</li>
<li><a id="c555_b2-li-2723"></a><span class="KeyTerm1">stream_for_each</span>, <i>283</i></li>
<li><a id="c555_b2-li-2724"></a><span class="KeyTerm1">stream_limit</span>, 298 (ex. 3.64)</li>
<li><a id="c555_b2-li-2725"></a><span class="KeyTerm1">stream_map</span>, <i>283</i>, <i>287</i></li>
<li><a id="c555_b2-li-2726"></a><span class="KeyTerm1">stream_map_2</span>, 287 (ex. 3.50)</li>
<li><a id="c555_b2-li-2727"></a><span class="KeyTerm1">stream_map_optimized</span>, <i>287</i></li>
<li><a id="c555_b2-li-2728"></a><span class="KeyTerm1">stream_ref</span>, <i>283</i></li>
<li><a id="c555_b2-li-2729"></a><span class="KeyTerm1">stream_tail</span>, <i>283</i></li>
<li><a id="c555_b2-li-2730"></a><span class="KeyTerm1">stream_withdraw</span>, <i>313</i></li>
<li><a id="c555_b2-li-2731"></a>strict, 362</li>
<li><a id="c555_b2-li-2732"></a>string(s), 124–126<ul class="none">
<li><a id="c555_b2-li-2733"></a>concatenation, 75</li>
<li><a id="c555_b2-li-2734"></a>equality of, 125 (ex. 2.54)</li>
<li><a id="c555_b2-li-2735"></a>interning, 490</li>
<li><a id="c555_b2-li-2736"></a>quotation marks for, <i>see</i> quotation marks</li>
<li><a id="c555_b2-li-2737"></a>representation of, 490</li>
<li><a id="c555_b2-li-2738"></a>typed over multiple lines, 546</li>
<li><a id="c555_b2-li-2739"></a>uniqueness of, 227<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2740"></a><span class="KeyTerm1">stringify</span> (primitive function), 75</li>
<li><a id="c555_b2-li-2741"></a>string pool, 490</li>
<li><a id="c555_b2-li-2742"></a>Stuckey, Peter J., 432<i>n</i></li>
<li><a id="c555_b2-li-2743"></a><span class="KeyTerm1">sub</span> (generic), <i>165</i></li>
<li><a id="c555_b2-li-2744"></a><span class="KeyTerm1">sub_complex</span>, <i>150</i></li>
<li><a id="c555_b2-li-2745"></a><span class="KeyTerm1">sub_interval</span>, 82 (ex. 2.8)</li>
<li><a id="c555_b2-li-2746"></a><span class="KeyTerm1">sub_rat</span>, <i>73</i></li>
<li><a id="c555_b2-li-2747"></a>subroutine in register machine, 457–460 <span class="KeyTerm1">subsets</span> of a set, <i>98</i> (ex. 2.32)</li>
<li><a id="c555_b2-li-2748"></a>substitution model of function application, 11–13, 206<ul class="none">
<li><a id="c555_b2-li-2749"></a>inadequacy of, 200–202</li>
<li><a id="c555_b2-li-2750"></a>shape of process, 27–29</li>
</ul></li>
<li><a id="c555_b2-li-2751"></a>subtype, 172<ul class="none">
<li><a id="c555_b2-li-2752"></a>multiple, 173</li>
</ul></li>
<li><a id="c555_b2-li-2753"></a><span class="KeyTerm1">sub_vect</span>, 119 (ex. 2.46)</li>
<li><a id="c555_b2-li-2754"></a>success continuation (nondeterministic evaluator), 386, 388</li>
<li><a id="c555_b2-li-2755"></a>successive squaring, 38</li>
<li><a id="c555_b2-li-2756"></a><span class="KeyTerm1">sum</span>, <i>50</i>
<ul class="none">
<li><a id="c555_b2-li-2757"></a>as accumulation, 53 (ex. 1.32)</li>
<li><a id="c555_b2-li-2758"></a>iterative version, 52 (ex. 1.30)</li>
</ul></li>
<li><a id="c555_b2-li-2759"></a><span class="KeyTerm1">sum_cubes</span>, <i>49</i>
<ul class="none">
<li><a id="c555_b2-li-2760"></a>with higher-order functions, <i>50</i></li>
</ul></li>
<li><a id="c555_b2-li-2761"></a><span class="KeyTerm1">sum_integers</span>, <i>49</i>
<ul class="none">
<li><a id="c555_b2-li-2762"></a>with higher-order functions, <i>50</i></li>
</ul></li>
<li><a id="c555_b2-li-2763"></a>summation of a series, 50<ul class="none">
<li><a id="c555_b2-li-2764"></a>with streams, 296</li>
</ul></li>
<li><a id="c555_b2-li-2765"></a><span class="KeyTerm1">sum_odd_squares</span>, <i>98</i>, <i>101</i></li>
<li><a id="c555_b2-li-2766"></a><span class="KeyTerm1">sum_of_squares</span>, <i>10</i>
<ul class="none">
<li><a id="c555_b2-li-2767"></a>in environment model, 210–212</li>
</ul></li>
<li><a id="c555_b2-li-2768"></a><span class="KeyTerm1">sum_primes</span>, <i>282</i></li>
<li><a id="c555_b2-li-2769"></a>supertype, 172<ul class="none">
<li><a id="c555_b2-li-2770"></a>multiple, 173</li>
</ul></li>
<li><a id="c555_b2-li-2771"></a>Sussman, Gerald Jay, 30<i>n</i>, 252<i>n</i>, 376<i>n</i></li>
<li><a id="c555_b2-li-2772"></a>Sutherland, Ivan, 252<i>n</i></li>
<li><a id="c555_b2-li-2773"></a>symbol(s)<ul class="none">
<li><a id="c555_b2-li-2774"></a>in environment operations, 341</li>
<li><a id="c555_b2-li-2775"></a>in global environment, 344</li>
<li><a id="c555_b2-li-2776"></a>in parsing of names, 330</li>
<li><a id="c555_b2-li-2777"></a>representing names in metacircular evaluator, 323</li>
<li><a id="c555_b2-li-2778"></a>in <span class="KeyTerm1">unparse</span>, 441</li>
</ul></li>
<li><a id="c555_b2-li-2779"></a>symbolic algebra, 176–188</li>
<li><a id="c555_b2-li-2780"></a>symbolic differentiation, 126–131, 160 (ex. 2.73)</li>
<li><a id="c555_b2-li-2781"></a>symbolic expression, 71, <i>see also</i> string(s); symbol(s)</li>
<li><a id="c555_b2-li-2782"></a><span class="KeyTerm1">symbol_leaf</span>, <i>143</i></li>
<li><a id="c555_b2-li-2783"></a><span class="KeyTerm1">symbol_of_name</span>, 331</li>
<li><a id="c555_b2-li-2784"></a><span class="KeyTerm1">symbols</span>, <i>143</i></li>
<li><a id="c555_b2-li-2785"></a>SYNC, 279<i>n</i></li>
<li><a id="c555_b2-li-2786"></a>synchronization, <i>see</i> concurrency</li>
<li><a id="c555_b2-li-2787"></a>syntactic analysis, separated from execution<ul class="none">
<li><a id="c555_b2-li-2788"></a>in metacircular evaluator, 355–360</li>
<li><a id="c555_b2-li-2789"></a>in register-machine simulator, 474, 478</li>
</ul></li>
<li><a id="c555_b2-li-2790"></a>syntactic form, 8<ul class="none">
<li><a id="c555_b2-li-2791"></a>as derived component, 334–335</li>
<li><a id="c555_b2-li-2792"></a>function vs., 362 (ex. 4.24)</li>
<li><a id="c555_b2-li-2793"></a>need for, 20 (ex. 1.6)</li>
</ul></li>
<li><a id="c555_b2-li-2794"></a>syntactic forms<ul class="none">
<li><a id="c555_b2-li-2795"></a>assignment, 192</li>
<li><a id="c555_b2-li-2796"></a>block, 25</li>
<li><a id="c555_b2-li-2797"></a>break statement, 338 (ex. 4.7)</li>
<li><a id="c555_b2-li-2798"></a>conditional expression, 14</li>
<li><a id="c555_b2-li-2799"></a>conditional statement, 57</li>
<li><a id="c555_b2-li-2800"></a>constant declaration, 5</li>
<li><a id="c555_b2-li-2801"></a>continue statement, 338 (ex. 4.7)</li>
<li><a id="c555_b2-li-2802"></a>function declaration, 8</li>
<li><a id="c555_b2-li-2803"></a>lambda expression, 54</li>
<li><a id="c555_b2-li-2804"></a>logical conjunction (<span class="KeyTerm1">&amp;&amp;</span>), 15</li>
<li><a id="c555_b2-li-2805"></a>logical disjunction (<span class="KeyTerm1">||</span>), 15</li>
<li><a id="c555_b2-li-2806"></a>return statement, 9</li>
<li><a id="c555_b2-li-2807"></a>variable declaration, 191</li>
<li><a id="c555_b2-li-2808"></a>while loop, 337 (ex. 4.7)</li>
</ul></li>
<li><a id="c555_b2-li-2809"></a>syntactic sugar, 15<i>n</i>, 30<i>n</i>
<ul class="none">
<li><a id="c555_b2-li-2810"></a><span class="KeyTerm1">&amp;&amp;</span> and <span class="KeyTerm1">||</span> as, 15</li>
<li><a id="c555_b2-li-2811"></a>function vs. data as, 247<i>n</i></li>
<li><a id="c555_b2-li-2812"></a>looping constructs as, 30</li>
</ul></li>
<li><a id="c555_b2-li-2813"></a>syntax, <i>see also</i> syntactic form<ul class="none">
<li><a id="c555_b2-li-2814"></a>abstract, <i>see</i> abstract syntax</li>
<li><a id="c555_b2-li-2815"></a>of expressions, describing, 9<i>n</i></li>
<li><a id="c555_b2-li-2816"></a>of a programming language, 8</li>
</ul></li>
<li><a id="c555_b2-li-2817"></a>syntax interface, 247<i>n</i></li>
<li><a id="c555_b2-li-2818"></a>systematic search, 376</li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-2819"></a>table, 235–241<ul class="none">
<li><a id="c555_b2-li-2820"></a>backbone of, 235</li>
<li><a id="c555_b2-li-2821"></a>for coercion, 170</li>
<li><a id="c555_b2-li-2822"></a>for data-directed programming, 157</li>
<li><a id="c555_b2-li-2823"></a>local, 238–239</li>
<li><a id="c555_b2-li-2824"></a><i>n</i>-dimensional, 240 (ex. 3.25)</li>
<li><a id="c555_b2-li-2825"></a>one-dimensional, 235–237</li>
<li><a id="c555_b2-li-2826"></a>operation-and-type, <i>see</i> operation-and-type table </li>
<li><a id="c555_b2-li-2827"></a>represented as binary tree vs. unordered list, 240 (ex. 3.26)</li>
<li><a id="c555_b2-li-2828"></a>testing equality of keys, 240 (ex. 3.24)</li>
<li><a id="c555_b2-li-2829"></a>two-dimensional, 237–238</li>
<li><a id="c555_b2-li-2830"></a>used in simulation agenda, 250</li>
<li><a id="c555_b2-li-2831"></a>used to store computed values, 240 (ex. 3.27)</li>
</ul></li>
<li><a id="c555_b2-li-2832"></a>tableau, 297</li>
<li><a id="c555_b2-li-2833"></a>tabulation, 35<i>n</i>, 240 (ex. 3.27)</li>
<li><a id="c555_b2-li-2834"></a><span class="KeyTerm1">tack_on_instruction_sequence</span>, <i>545</i></li>
<li><a id="c555_b2-li-2835"></a>tagged architecture, 489<i>n</i></li>
<li><a id="c555_b2-li-2836"></a>tagged data, 152–155, 489<i>n</i></li>
<li><a id="c555_b2-li-2837"></a><span class="KeyTerm1">tail</span> (primitive function), 73<ul class="none">
<li><a id="c555_b2-li-2838"></a>axiom for, 79</li>
<li><a id="c555_b2-li-2839"></a>functional implementation of, <i>79</i>, 80 (ex. 2.4), <i>229, 230</i>, <i>371</i></li>
<li><a id="c555_b2-li-2840"></a>implemented with vectors, 490</li>
<li><a id="c555_b2-li-2841"></a>as list operation, 86</li>
</ul></li>
<li><a id="c555_b2-li-2842"></a>tail recursion, 30<ul class="none">
<li><a id="c555_b2-li-2843"></a>compiler and, 541</li>
<li><a id="c555_b2-li-2844"></a>environment model of evaluation and, 213<i>n</i></li>
<li><a id="c555_b2-li-2845"></a>explicit-control evaluator and, 511 (ex. 5.22), 509–511, 517 (ex. 5.27), 518 (ex. 5.29)</li>
<li><a id="c555_b2-li-2846"></a>garbage collection and, 541<i>n</i></li>
<li><a id="c555_b2-li-2847"></a>in JavaScript, 30<i>n</i></li>
<li><a id="c555_b2-li-2848"></a>metacircular evaluator and, 324<i>n</i>, 327<i>n</i>, 509</li>
<li><a id="c555_b2-li-2849"></a>return statement necessary for, 511, 542</li>
<li><a id="c555_b2-li-2850"></a>in Scheme, 30<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2851"></a>tail-recursive evaluator, 509</li>
<li><a id="c555_b2-li-2852"></a>tangent<ul class="none">
<li><a id="c555_b2-li-2853"></a>as continued fraction, 63 (ex. 1.39)</li>
<li><a id="c555_b2-li-2854"></a>power series for, 295 (ex. 3.62)</li>
</ul></li>
<li><a id="c555_b2-li-2855"></a>target register, 523</li>
<li><a id="c555_b2-li-2856"></a>TDZ (temporal dead zone), 222<i>n</i>, <i>see also</i> declaration, use of name before</li>
<li><a id="c555_b2-li-2857"></a>Technological University of Eindhoven, 276<i>n</i></li>
<li><a id="c555_b2-li-2858"></a>temporal dead zone (TDZ), 222<i>n</i>, <i>see also</i> declaration, use of name before</li>
<li><a id="c555_b2-li-2859"></a>terminal node of a tree, 7</li>
<li><a id="c555_b2-li-2860"></a><span class="KeyTerm1">term_list</span>, <i>178</i></li>
<li><a id="c555_b2-li-2861"></a>term list of polynomial, 177<ul class="none">
<li><a id="c555_b2-li-2862"></a>representing, 181–183</li>
</ul></li>
<li><a id="c555_b2-li-2863"></a>ternary operator, <i>see</i> conditional expression</li>
<li><a id="c555_b2-li-2864"></a><span class="KeyTerm1">test</span> (in register machine), 452<ul class="none">
<li><a id="c555_b2-li-2865"></a>instruction constructor, <i>479</i></li>
<li><a id="c555_b2-li-2866"></a>simulating, 479</li>
</ul></li>
<li><a id="c555_b2-li-2867"></a><span class="KeyTerm1">test_and_set</span>, <i>277</i></li>
<li><a id="c555_b2-li-2868"></a><span class="KeyTerm1">test_condition</span>, <i>479</i></li>
<li><a id="c555_b2-li-2869"></a>test operation in register machine, 451</li>
<li><a id="c555_b2-li-2870"></a>Thatcher, James W., 79<i>n</i></li>
<li><a id="c555_b2-li-2871"></a><span class="KeyTerm1">the_empty_environment</span>, <i>341</i></li>
<li><a id="c555_b2-li-2872"></a><span class="KeyTerm1">the_empty_termlist</span>, 179, <i>182</i></li>
<li><a id="c555_b2-li-2873"></a><span class="KeyTerm1">the_global_environment</span>, <i>345</i>, <i>515</i></li>
<li><a id="c555_b2-li-2874"></a><span class="KeyTerm1">the_heads</span>
<ul class="none">
<li><a id="c555_b2-li-2875"></a>register, 490, 494</li>
<li><a id="c555_b2-li-2876"></a>vector, 488</li>
</ul></li>
<li><a id="c555_b2-li-2877"></a>THE Multiprogramming System, 276<i>n</i></li>
<li><a id="c555_b2-li-2878"></a>theorem proving (automatic), 398<i>n</i></li>
<li><a id="c555_b2-li-2879"></a><i>θ</i>(<i>f</i> (<i>n</i>)) (theta of <i>f</i> (<i>n</i>)), 37</li>
<li><a id="c555_b2-li-2880"></a><span class="KeyTerm1">the_tails</span>
<ul class="none">
<li><a id="c555_b2-li-2881"></a>register, 490, 494</li>
<li><a id="c555_b2-li-2882"></a>vector, 488</li>
</ul></li>
<li><a id="c555_b2-li-2883"></a>thread, 263</li>
<li><a id="c555_b2-li-2884"></a>thunk, 363<ul class="none">
<li><a id="c555_b2-li-2885"></a>call-by-name, 286<i>n</i></li>
<li><a id="c555_b2-li-2886"></a>call-by-need, 286<i>n</i></li>
<li><a id="c555_b2-li-2887"></a>forcing, 363</li>
<li><a id="c555_b2-li-2888"></a>implementation of, 366–367</li>
<li><a id="c555_b2-li-2889"></a>origin of name, 363<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2890"></a>time<ul class="none">
<li><a id="c555_b2-li-2891"></a>assignment and, 263</li>
<li><a id="c555_b2-li-2892"></a>communication and, 280</li>
<li><a id="c555_b2-li-2893"></a>in concurrent systems, 264–268</li>
<li><a id="c555_b2-li-2894"></a>functional programming and, 313–315</li>
<li><a id="c555_b2-li-2895"></a>in nondeterministic computing, 374, 375</li>
<li><a id="c555_b2-li-2896"></a>purpose of, 264<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2897"></a><span class="KeyTerm1">timed_prime_test</span>, 46 (ex. 1.22)</li>
<li><a id="c555_b2-li-2898"></a>time segment, in agenda, 250</li>
<li><a id="c555_b2-li-2899"></a>time slicing, 277</li>
<li><a id="c555_b2-li-2900"></a>timing diagram, 265 (fig. 3.29)</li>
<li><a id="c555_b2-li-2901"></a>TK!Solver, 252<i>n</i></li>
<li><a id="c555_b2-li-2902"></a>tower of types, 172 (fig. 2.25)</li>
<li><a id="c555_b2-li-2903"></a>tracing<ul class="none">
<li><a id="c555_b2-li-2904"></a>instruction execution, 486 (ex. 5.15)</li>
<li><a id="c555_b2-li-2905"></a>register assignment, 486 (ex. 5.17)</li>
</ul></li>
<li><a id="c555_b2-li-2906"></a><span class="KeyTerm1">transform_painter</span>, <i>121</i></li>
<li><a id="c555_b2-li-2907"></a>transparency, referential, 203</li>
<li><a id="c555_b2-li-2908"></a><span class="KeyTerm1">transpose</span> a matrix, 105 (ex. 2.37)</li>
<li><a id="c555_b2-li-2909"></a>tree<ul class="none">
<li><a id="c555_b2-li-2910"></a>binary, 135, <i>see also</i> binary tree</li>
<li><a id="c555_b2-li-2911"></a>B-tree, 137<i>n</i></li>
<li><a id="c555_b2-li-2912"></a>combination viewed as, 7</li>
<li><a id="c555_b2-li-2913"></a>counting leaves of, 93</li>
<li><a id="c555_b2-li-2914"></a>enumerating leaves of, 101</li>
<li><a id="c555_b2-li-2915"></a>fringe of, 95 (ex. 2.28)</li>
<li><a id="c555_b2-li-2916"></a>Huffman, 141</li>
<li><a id="c555_b2-li-2917"></a>lazy, 371<i>n</i></li>
<li><a id="c555_b2-li-2918"></a>mapping over, 96–98</li>
<li><a id="c555_b2-li-2919"></a>rational, 432<i>n</i></li>
<li><a id="c555_b2-li-2920"></a>red-black, 137<i>n</i></li>
<li><a id="c555_b2-li-2921"></a>represented as pairs, 93–96</li>
<li><a id="c555_b2-li-2922"></a>reversing at all levels, 95 (ex. 2.27)</li>
</ul></li>
<li><a id="c555_b2-li-2923"></a>tree accumulation, 7</li>
<li><a id="c555_b2-li-2924"></a><span class="KeyTerm1">tree_map</span>, 97 (ex. 2.31)</li>
<li><a id="c555_b2-li-2925"></a>tree-recursive process, 32–35<ul class="none">
<li><a id="c555_b2-li-2926"></a>order of growth, 37</li>
</ul></li>
<li><a id="c555_b2-li-2927"></a><span class="KeyTerm1">tree_to_list_<i>. . .</i></span>, <i>137</i> (ex. 2.63)</li>
<li><a id="c555_b2-li-2928"></a>trigonometric relations, 151</li>
<li><a id="c555_b2-li-2929"></a><span class="KeyTerm1"><b>true</b></span> (keyword), 14</li>
<li><a id="c555_b2-li-2930"></a>truncation error, 3<i>n</i></li>
<li><a id="c555_b2-li-2931"></a>truthiness, 325, 339<i>n</i></li>
<li><a id="c555_b2-li-2932"></a>truth maintenance, 376<i>n</i></li>
<li><a id="c555_b2-li-2933"></a>Turing, Alan M., 349<i>n</i>, 351<i>n</i></li>
<li><a id="c555_b2-li-2934"></a>Turing machine, 349<i>n</i></li>
<li><a id="c555_b2-li-2935"></a>Turner, David, 106<i>n</i>, 300<i>n</i>, 314<i>n</i></li>
<li><a id="c555_b2-li-2936"></a><span class="KeyTerm1">type</span> in query system, <i>443</i></li>
<li><a id="c555_b2-li-2937"></a><span class="KeyTerm1">type</span> in register machine, <i>477</i></li>
<li><a id="c555_b2-li-2938"></a>type(s)<ul class="none">
<li><a id="c555_b2-li-2939"></a>cross-type operations, 169</li>
<li><a id="c555_b2-li-2940"></a>dispatching on, 156</li>
<li><a id="c555_b2-li-2941"></a>hierarchy in symbolic algebra, 184</li>
<li><a id="c555_b2-li-2942"></a>hierarchy of, 172–176</li>
<li><a id="c555_b2-li-2943"></a>lowering, 173, 176 (ex. 2.85)</li>
<li><a id="c555_b2-li-2944"></a>multiple subtype and supertype, 173</li>
<li><a id="c555_b2-li-2945"></a>polymorphic, 310<i>n</i></li>
<li><a id="c555_b2-li-2946"></a>raising, 173, 175 (ex. 2.83)</li>
<li><a id="c555_b2-li-2947"></a>subtype, 172</li>
<li><a id="c555_b2-li-2948"></a>supertype, 172</li>
<li><a id="c555_b2-li-2949"></a>tower of, 172 (fig. 2.25)</li>
</ul></li>
<li><a id="c555_b2-li-2950"></a>typed pointer, 489</li>
<li><a id="c555_b2-li-2951"></a>type field, 489<i>n</i></li>
<li><a id="c555_b2-li-2952"></a>type-inferencing mechanism, 310<i>n</i></li>
<li><a id="c555_b2-li-2953"></a><span class="KeyTerm1">type_tag</span>, <i>152</i>
<ul class="none">
<li><a id="c555_b2-li-2954"></a>using JavaScript data types, 168 (ex. 2.78)</li>
</ul></li>
<li><a id="c555_b2-li-2955"></a>type tag, 148, 152<ul class="none">
<li><a id="c555_b2-li-2956"></a>two-level, 168</li>
</ul></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-2957"></a>unary operator, 15</li>
<li><a id="c555_b2-li-2958"></a>unbound name, 206</li>
<li><a id="c555_b2-li-2959"></a><span class="KeyTerm1">undefined</span> (predeclared name), 157</li>
<li><a id="c555_b2-li-2960"></a><span class="KeyTerm1">unev</span> register, 500</li>
<li><a id="c555_b2-li-2961"></a>unification, 415–417<ul class="none">
<li><a id="c555_b2-li-2962"></a>discovery of algorithm, 398<i>n</i></li>
<li><a id="c555_b2-li-2963"></a>implementation, 431–433</li>
<li><a id="c555_b2-li-2964"></a>pattern matching vs., 416, 418<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2965"></a><span class="KeyTerm1">unify_match</span>, <i>431</i></li>
<li><a id="c555_b2-li-2966"></a><span class="KeyTerm1">union_set</span>, 131<ul class="none">
<li><a id="c555_b2-li-2967"></a>binary-tree representation, 138 (ex. 2.65)</li>
<li><a id="c555_b2-li-2968"></a>ordered-list representation, 135 (ex. 2.62)</li>
<li><a id="c555_b2-li-2969"></a>unordered-list representation, 133 (ex. 2.59)</li>
</ul></li>
<li><a id="c555_b2-li-2970"></a><span class="KeyTerm1">unique</span> (query language), 445 (ex. 4.72)</li>
<li><a id="c555_b2-li-2971"></a><span class="KeyTerm1">unique_pairs</span>, 108 (ex. 2.40)</li>
<li><a id="c555_b2-li-2972"></a>unit square, 117</li>
<li><a id="c555_b2-li-2973"></a>univariate polynomial, 177</li>
<li><a id="c555_b2-li-2974"></a>universal machine, 349<ul class="none">
<li><a id="c555_b2-li-2975"></a>explicit-control evaluator as, 519</li>
<li><a id="c555_b2-li-2976"></a>general-purpose computer as, 519</li>
</ul></li>
<li><a id="c555_b2-li-2977"></a>University of Edinburgh, 399<i>n</i></li>
<li><a id="c555_b2-li-2978"></a>University of Marseille, 399<i>n</i></li>
<li><a id="c555_b2-li-2979"></a>UNIX, 561<i>n</i>
<ul class="none">
<li><a id="c555_b2-li-2980"></a>epoch, 46<i>n</i></li>
</ul></li>
<li><a id="c555_b2-li-2981"></a><span class="KeyTerm1">unknown_component_type</span>, <i>515</i></li>
<li><a id="c555_b2-li-2982"></a><span class="KeyTerm1">unknown_function_type</span>, <i>515</i></li>
<li><a id="c555_b2-li-2983"></a>unordered-list representation of sets, 132–133</li>
<li><a id="c555_b2-li-2984"></a><span class="KeyTerm1">unparse</span>
<ul class="none">
<li><a id="c555_b2-li-2985"></a>as inverse of <span class="KeyTerm1">parse</span>, 335 (ex. 4.2)</li>
<li><a id="c555_b2-li-2986"></a>in query interpreter, 425, <i>441</i></li>
</ul></li>
<li><a id="c555_b2-li-2987"></a><span class="KeyTerm1">update_insts</span>, <i>476</i></li>
<li><a id="c555_b2-li-2988"></a><span class="KeyTerm1">upper_bound</span>, 82 (ex. 2.7)</li>
<li><a id="c555_b2-li-2989"></a><span class="KeyTerm1">up_split</span>, 115 (ex. 2.44)</li>
<li><a id="c555_b2-li-2990"></a>upward compatibility, 370 (ex. 4.29)</li>
<li><a id="c555_b2-li-2991"></a><span class="KeyTerm1">user_print</span>, <i>347</i>
<ul class="none">
<li><a id="c555_b2-li-2992"></a>modified for compiled code, <i>559n</i></li>
</ul></li>
<li><a id="c555_b2-li-2993"></a><span class="KeyTerm1">user_read</span>, <i>347</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-2994"></a>V operation on semaphore, 276<i>n</i></li>
<li><a id="c555_b2-li-2995"></a><span class="KeyTerm1">val</span> register, 500<ul class="none">
<li><a id="c555_b2-li-2996"></a>value</li>
<li><a id="c555_b2-li-2997"></a>of an expression, 4, 5<i>n</i></li>
<li><a id="c555_b2-li-2998"></a>of a program, 338 (ex. 4.8)</li>
</ul></li>
<li><a id="c555_b2-li-2999"></a><span class="KeyTerm1">value_fun</span>, 478</li>
<li><a id="c555_b2-li-3000"></a><span class="KeyTerm1">variable</span>, <i>178</i></li>
<li><a id="c555_b2-li-3001"></a>variable<ul class="none">
<li><a id="c555_b2-li-3002"></a>assignment to, 192</li>
<li><a id="c555_b2-li-3003"></a>declaration, 191</li>
<li><a id="c555_b2-li-3004"></a>declaration, parsing of, 333</li>
<li><a id="c555_b2-li-3005"></a>parameter as, 192</li>
</ul></li>
<li><a id="c555_b2-li-3006"></a>variable-length code, 140</li>
<li><a id="c555_b2-li-3007"></a>vector (data structure), 488<ul class="none">
<li><a id="c555_b2-li-3008"></a>for arguments of <span class="KeyTerm1">apply</span>, 346<i>n</i></li>
<li><a id="c555_b2-li-3009"></a>used in spread and rest parameter syntax, 276</li>
</ul></li>
<li><a id="c555_b2-li-3010"></a>vector (mathematical)<ul class="none">
<li><a id="c555_b2-li-3011"></a>operations on, 105 (ex. 2.37), 118 (ex. 2.46)</li>
<li><a id="c555_b2-li-3012"></a>in picture-language frame, 117</li>
<li><a id="c555_b2-li-3013"></a>represented as pair, 118 (ex. 2.46)</li>
<li><a id="c555_b2-li-3014"></a>represented as sequence, 105 (ex. 2.37) <span class="KeyTerm1">vector_ref</span> (primitive function), 488</li>
</ul></li>
<li><a id="c555_b2-li-3015"></a><span class="KeyTerm1">vector_set</span> (primitive function), 488</li>
<li><a id="c555_b2-li-3016"></a><span class="KeyTerm1">verbs</span>, <i>381</i></li>
<li><a id="c555_b2-li-3017"></a>very high-level language, 18<i>n</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-3018"></a>Wadler, Philip, 204<i>n</i></li>
<li><a id="c555_b2-li-3019"></a>Wadsworth, Christopher, 310<i>n</i></li>
<li><a id="c555_b2-li-3020"></a>Wagner, Eric G., 79<i>n</i></li>
<li><a id="c555_b2-li-3021"></a>Walker, Francis Amasa, 112<i>n</i></li>
<li><a id="c555_b2-li-3022"></a>walking down a list with <span class="KeyTerm1">tail</span>, 87</li>
<li><a id="c555_b2-li-3023"></a>Wallis, John, 52<i>n</i></li>
<li><a id="c555_b2-li-3024"></a>Wand, Mitchell, 319<i>n</i>, 506<i>n</i></li>
<li><a id="c555_b2-li-3025"></a>Waters, Richard C., 103<i>n</i></li>
<li><a id="c555_b2-li-3026"></a>web browser, interpreting JavaScript, 2</li>
<li><a id="c555_b2-li-3027"></a><span class="KeyTerm1">weight</span>, <i>143</i></li>
<li><a id="c555_b2-li-3028"></a><span class="KeyTerm1">weight_leaf</span>, <i>143</i></li>
<li><a id="c555_b2-li-3029"></a>Weyl, Hermann, 69</li>
<li><a id="c555_b2-li-3030"></a>“what is” vs. “how to” description, <i>see</i> declarative vs. imperative knowledge</li>
<li><a id="c555_b2-li-3031"></a><span class="KeyTerm1">wheel</span> (rule), <i>407</i>, 423 (ex. 4.63)</li>
<li><a id="c555_b2-li-3032"></a><span class="KeyTerm1"><b>while</b></span> (keyword), 337 (ex. 4.7), <i>see also</i> while loop while loop<ul class="none">
<li><a id="c555_b2-li-3033"></a>implementing in analyzing evaluator, 359 (ex. 4.20)</li>
<li><a id="c555_b2-li-3034"></a>implementing in metacircular evaluator, 337 (ex. 4.7)</li>
</ul></li>
<li><a id="c555_b2-li-3035"></a>whitespace characters, 335 (ex. 4.2)</li>
<li><a id="c555_b2-li-3036"></a><span class="KeyTerm1">width</span>, <i>83</i></li>
<li><a id="c555_b2-li-3037"></a>width of an interval, 82 (ex. 2.9)</li>
<li><a id="c555_b2-li-3038"></a>Wilde, Oscar (Perlis's paraphrase of), 5<i>n</i></li>
<li><a id="c555_b2-li-3039"></a>Wiles, Andrew, 44<i>n</i></li>
<li><a id="c555_b2-li-3040"></a>Winograd, Terry, 376<i>n</i></li>
<li><a id="c555_b2-li-3041"></a>Winston, Patrick Henry, 376<i>n</i>, 385<i>n</i></li>
<li><a id="c555_b2-li-3042"></a>wire, in digital circuit, 241</li>
<li><a id="c555_b2-li-3043"></a>Wise, David S., 286<i>n</i></li>
<li><a id="c555_b2-li-3044"></a>wishful thinking, 72, 127</li>
<li><a id="c555_b2-li-3045"></a><span class="KeyTerm1">withdraw</span>, <i>191</i>
<ul class="none">
<li><a id="c555_b2-li-3046"></a>problems in concurrent system, 264</li>
</ul></li>
<li><a id="c555_b2-li-3047"></a>world line of a particle, 281<i>n</i>, 314<i>n</i></li>
<li><a id="c555_b2-li-3048"></a>Wright, E. M., 292<i>n</i></li>
<li><a id="c555_b2-li-3049"></a>Wright, Jesse B., 79<i>n</i></li>
<li><a id="c555_b2-li-3050"></a>Wrigstad, Tobias, daughter of, 124</li>
<li><a id="c555_b2-li-3051"></a><span class="KeyTerm1">xcor_vect</span>, 118 (ex. 2.46)</li>
<li><a id="c555_b2-li-3052"></a>Xerox Palo Alto Research Center, 252<i>n</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-3053"></a><i>Y</i> operator, 353<i>n</i></li>
<li><a id="c555_b2-li-3054"></a>Yang Hui, 36<i>n</i></li>
<li><a id="c555_b2-li-3055"></a><span class="KeyTerm1">ycor_vect</span>, 118 (ex. 2.46)</li>
<li><a id="c555_b2-li-3056"></a>Yochelson, Jerome C., 494<i>n</i></li>
</ul>
</section>
<section class="BS_indexSec">
<ul class="none">
<li><a id="c555_b2-li-3057"></a>Zabih, Ramin, 376<i>n</i></li>
<li><a id="c555_b2-li-3058"></a>zero crossings of a signal, 304 (ex. 3.74), 304 (ex. 3.75), 305 (ex. 3.76)</li>
<li><a id="c555_b2-li-3059"></a>zero test (generic), 169 (ex. 2.80)<ul class="none">
<li><a id="c555_b2-li-3060"></a>for polynomials, 182 (ex. 2.87)</li>
</ul></li>
<li><a id="c555_b2-li-3061"></a>Zilles, Stephen N., 78<i>n</i></li>
<li><a id="c555_b2-li-3062"></a>Zippel, Richard E., 188<i>n</i></li>
</ul>
</section>
</section>
</section>
</body><body>
<section>
<header>
<h1><a id="c800_b2-title-0001"></a><span class="chapterTitle">List of Exercises</span></h1>
</header>
<figure><figcaption class="tablecaption"><a id="c800_b2-tbl-0001"></a></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c800_b2-para-0001"></a><b>1.1</b></td>
<td><a id="c800_b2-para-0002"></a>16</td>
<td><a id="c800_b2-para-0003"></a><b>1.11</b></td>
<td><a id="c800_b2-para-0004"></a>36</td>
<td><a id="c800_b2-para-0005"></a><b>1.21</b></td>
<td><a id="c800_b2-para-0006"></a>46</td>
<td><a id="c800_b2-para-0007"></a><b>1.31</b></td>
<td><a id="c800_b2-para-0008"></a>52</td>
<td><a id="c800_b2-para-0009"></a><b>1.41</b></td>
<td><a id="c800_b2-para-0010"></a>67</td></tr>
<tr>
<td><a id="c800_b2-para-0011"></a><b>1.2</b></td>
<td><a id="c800_b2-para-0012"></a>17</td>
<td><a id="c800_b2-para-0013"></a><b>1.12</b></td>
<td><a id="c800_b2-para-0014"></a>36</td>
<td><a id="c800_b2-para-0015"></a><b>1.22</b></td>
<td><a id="c800_b2-para-0016"></a>46</td>
<td><a id="c800_b2-para-0017"></a><b>1.32</b></td>
<td><a id="c800_b2-para-0018"></a>53</td>
<td><a id="c800_b2-para-0019"></a><b>1.42</b></td>
<td><a id="c800_b2-para-0020"></a>67</td></tr>
<tr>
<td><a id="c800_b2-para-0021"></a><b>1.3</b></td>
<td><a id="c800_b2-para-0022"></a>17</td>
<td><a id="c800_b2-para-0023"></a><b>1.13</b></td>
<td><a id="c800_b2-para-0024"></a>36</td>
<td><a id="c800_b2-para-0025"></a><b>1.23</b></td>
<td><a id="c800_b2-para-0026"></a>47</td>
<td><a id="c800_b2-para-0027"></a><b>1.33</b></td>
<td><a id="c800_b2-para-0028"></a>53</td>
<td><a id="c800_b2-para-0029"></a><b>1.43</b></td>
<td><a id="c800_b2-para-0030"></a>68</td></tr>
<tr>
<td><a id="c800_b2-para-0031"></a><b>1.4</b></td>
<td><a id="c800_b2-para-0032"></a>17</td>
<td><a id="c800_b2-para-0033"></a><b>1.14</b></td>
<td><a id="c800_b2-para-0034"></a>37</td>
<td><a id="c800_b2-para-0035"></a><b>1.24</b></td>
<td><a id="c800_b2-para-0036"></a>47</td>
<td><a id="c800_b2-para-0037"></a><b>1.34</b></td>
<td><a id="c800_b2-para-0038"></a>58</td>
<td><a id="c800_b2-para-0039"></a><b>1.44</b></td>
<td><a id="c800_b2-para-0040"></a>68</td></tr>
<tr>
<td><a id="c800_b2-para-0041"></a><b>1.5</b></td>
<td><a id="c800_b2-para-0042"></a>17</td>
<td><a id="c800_b2-para-0043"></a><b>1.15</b></td>
<td><a id="c800_b2-para-0044"></a>37</td>
<td><a id="c800_b2-para-0045"></a><b>1.25</b></td>
<td><a id="c800_b2-para-0046"></a>47</td>
<td><a id="c800_b2-para-0047"></a><b>1.35</b></td>
<td><a id="c800_b2-para-0048"></a>62</td>
<td><a id="c800_b2-para-0049"></a><b>1.45</b></td>
<td><a id="c800_b2-para-0050"></a>68</td></tr>
<tr>
<td><a id="c800_b2-para-0051"></a><b>1.6</b></td>
<td><a id="c800_b2-para-0052"></a>20</td>
<td><a id="c800_b2-para-0053"></a><b>1.16</b></td>
<td><a id="c800_b2-para-0054"></a>40</td>
<td><a id="c800_b2-para-0055"></a><b>1.26</b></td>
<td><a id="c800_b2-para-0056"></a>47</td>
<td><a id="c800_b2-para-0057"></a><b>1.36</b></td>
<td><a id="c800_b2-para-0058"></a>62</td>
<td><a id="c800_b2-para-0059"></a><b>1.46</b></td>
<td><a id="c800_b2-para-0060"></a>68</td></tr>
<tr>
<td><a id="c800_b2-para-0061"></a><b>1.7</b></td>
<td><a id="c800_b2-para-0062"></a>21</td>
<td><a id="c800_b2-para-0063"></a><b>1.17</b></td>
<td><a id="c800_b2-para-0064"></a>40</td>
<td><a id="c800_b2-para-0065"></a><b>1.27</b></td>
<td><a id="c800_b2-para-0066"></a>48</td>
<td><a id="c800_b2-para-0067"></a><b>1.37</b></td>
<td><a id="c800_b2-para-0068"></a>62</td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0069"></a><b>1.8</b></td>
<td><a id="c800_b2-para-0070"></a>21</td>
<td><a id="c800_b2-para-0071"></a><b>1.18</b></td>
<td><a id="c800_b2-para-0072"></a>40</td>
<td><a id="c800_b2-para-0073"></a><b>1.28</b></td>
<td><a id="c800_b2-para-0074"></a>48</td>
<td><a id="c800_b2-para-0075"></a><b>1.38</b></td>
<td><a id="c800_b2-para-0076"></a>62</td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0077"></a><b>1.9</b></td>
<td><a id="c800_b2-para-0078"></a>30</td>
<td><a id="c800_b2-para-0079"></a><b>1.19</b></td>
<td><a id="c800_b2-para-0080"></a>40</td>
<td><a id="c800_b2-para-0081"></a><b>1.29</b></td>
<td><a id="c800_b2-para-0082"></a>52</td>
<td><a id="c800_b2-para-0083"></a><b>1.39</b></td>
<td><a id="c800_b2-para-0084"></a>63</td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0085"></a><b>1.10</b></td>
<td><a id="c800_b2-para-0086"></a>31</td>
<td><a id="c800_b2-para-0087"></a><b>1.20</b></td>
<td><a id="c800_b2-para-0088"></a>43</td>
<td><a id="c800_b2-para-0089"></a><b>1.30</b></td>
<td><a id="c800_b2-para-0090"></a>52</td>
<td><a id="c800_b2-para-0091"></a><b>1.40</b></td>
<td><a id="c800_b2-para-0092"></a>67</td>
<td></td>
<td></td></tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0093"></a><b>2.1</b></td>
<td><a id="c800_b2-para-0094"></a>76</td>
<td><a id="c800_b2-para-0095"></a><b>2.21</b></td>
<td><a id="c800_b2-para-0096"></a>91</td>
<td><a id="c800_b2-para-0097"></a><b>2.41</b></td>
<td><a id="c800_b2-para-0098"></a>108</td>
<td><a id="c800_b2-para-0099"></a><b>2.61</b></td>
<td><a id="c800_b2-para-0100"></a>135</td>
<td><a id="c800_b2-para-0101"></a><b>2.81</b></td>
<td><a id="c800_b2-para-0102"></a>174</td></tr>
<tr>
<td><a id="c800_b2-para-0103"></a><b>2.2</b></td>
<td><a id="c800_b2-para-0104"></a>77</td>
<td><a id="c800_b2-para-0105"></a><b>2.22</b></td>
<td><a id="c800_b2-para-0106"></a>92</td>
<td><a id="c800_b2-para-0107"></a><b>2.42</b></td>
<td><a id="c800_b2-para-0108"></a>108</td>
<td><a id="c800_b2-para-0109"></a><b>2.62</b></td>
<td><a id="c800_b2-para-0110"></a>135</td>
<td><a id="c800_b2-para-0111"></a><b>2.82</b></td>
<td><a id="c800_b2-para-0112"></a>175</td></tr>
<tr>
<td><a id="c800_b2-para-0113"></a><b>2.3</b></td>
<td><a id="c800_b2-para-0114"></a>78</td>
<td><a id="c800_b2-para-0115"></a><b>2.23</b></td>
<td><a id="c800_b2-para-0116"></a>92</td>
<td><a id="c800_b2-para-0117"></a><b>2.43</b></td>
<td><a id="c800_b2-para-0118"></a>110</td>
<td><a id="c800_b2-para-0119"></a><b>2.63</b></td>
<td><a id="c800_b2-para-0120"></a>137</td>
<td><a id="c800_b2-para-0121"></a><b>2.83</b></td>
<td><a id="c800_b2-para-0122"></a>175</td></tr>
<tr>
<td><a id="c800_b2-para-0123"></a><b>2.4</b></td>
<td><a id="c800_b2-para-0124"></a>80</td>
<td><a id="c800_b2-para-0125"></a><b>2.24</b></td>
<td><a id="c800_b2-para-0126"></a>94</td>
<td><a id="c800_b2-para-0127"></a><b>2.44</b></td>
<td><a id="c800_b2-para-0128"></a>115</td>
<td><a id="c800_b2-para-0129"></a><b>2.64</b></td>
<td><a id="c800_b2-para-0130"></a>137</td>
<td><a id="c800_b2-para-0131"></a><b>2.84</b></td>
<td><a id="c800_b2-para-0132"></a>175</td></tr>
<tr>
<td><a id="c800_b2-para-0133"></a><b>2.5</b></td>
<td><a id="c800_b2-para-0134"></a>80</td>
<td><a id="c800_b2-para-0135"></a><b>2.25</b></td>
<td><a id="c800_b2-para-0136"></a>95</td>
<td><a id="c800_b2-para-0137"></a><b>2.45</b></td>
<td><a id="c800_b2-para-0138"></a>117</td>
<td><a id="c800_b2-para-0139"></a><b>2.65</b></td>
<td><a id="c800_b2-para-0140"></a>138</td>
<td><a id="c800_b2-para-0141"></a><b>2.85</b></td>
<td><a id="c800_b2-para-0142"></a>176</td></tr>
<tr>
<td><a id="c800_b2-para-0143"></a><b>2.6</b></td>
<td><a id="c800_b2-para-0144"></a>80</td>
<td><a id="c800_b2-para-0145"></a><b>2.26</b></td>
<td><a id="c800_b2-para-0146"></a>95</td>
<td><a id="c800_b2-para-0147"></a><b>2.46</b></td>
<td><a id="c800_b2-para-0148"></a>118</td>
<td><a id="c800_b2-para-0149"></a><b>2.66</b></td>
<td><a id="c800_b2-para-0150"></a>139</td>
<td><a id="c800_b2-para-0151"></a><b>2.86</b></td>
<td><a id="c800_b2-para-0152"></a>176</td></tr>
<tr>
<td><a id="c800_b2-para-0153"></a><b>2.7</b></td>
<td><a id="c800_b2-para-0154"></a>82</td>
<td><a id="c800_b2-para-0155"></a><b>2.27</b></td>
<td><a id="c800_b2-para-0156"></a>95</td>
<td><a id="c800_b2-para-0157"></a><b>2.47</b></td>
<td><a id="c800_b2-para-0158"></a>119</td>
<td><a id="c800_b2-para-0159"></a><b>2.67</b></td>
<td><a id="c800_b2-para-0160"></a>145</td>
<td><a id="c800_b2-para-0161"></a><b>2.87</b></td>
<td><a id="c800_b2-para-0162"></a>182</td></tr>
<tr>
<td><a id="c800_b2-para-0163"></a><b>2.8</b></td>
<td><a id="c800_b2-para-0164"></a>82</td>
<td><a id="c800_b2-para-0165"></a><b>2.28</b></td>
<td><a id="c800_b2-para-0166"></a>95</td>
<td><a id="c800_b2-para-0167"></a><b>2.48</b></td>
<td><a id="c800_b2-para-0168"></a>120</td>
<td><a id="c800_b2-para-0169"></a><b>2.68</b></td>
<td><a id="c800_b2-para-0170"></a>145</td>
<td><a id="c800_b2-para-0171"></a><b>2.88</b></td>
<td><a id="c800_b2-para-0172"></a>182</td></tr>
<tr>
<td><a id="c800_b2-para-0173"></a><b>2.9</b></td>
<td><a id="c800_b2-para-0174"></a>82</td>
<td><a id="c800_b2-para-0175"></a><b>2.29</b></td>
<td><a id="c800_b2-para-0176"></a>96</td>
<td><a id="c800_b2-para-0177"></a><b>2.49</b></td>
<td><a id="c800_b2-para-0178"></a>120</td>
<td><a id="c800_b2-para-0179"></a><b>2.69</b></td>
<td><a id="c800_b2-para-0180"></a>146</td>
<td><a id="c800_b2-para-0181"></a><b>2.89</b></td>
<td><a id="c800_b2-para-0182"></a>182</td></tr>
<tr>
<td><a id="c800_b2-para-0183"></a><b>2.10</b></td>
<td><a id="c800_b2-para-0184"></a>82</td>
<td><a id="c800_b2-para-0185"></a><b>2.30</b></td>
<td><a id="c800_b2-para-0186"></a>97</td>
<td><a id="c800_b2-para-0187"></a><b>2.50</b></td>
<td><a id="c800_b2-para-0188"></a>122</td>
<td><a id="c800_b2-para-0189"></a><b>2.70</b></td>
<td><a id="c800_b2-para-0190"></a>146</td>
<td><a id="c800_b2-para-0191"></a><b>2.90</b></td>
<td><a id="c800_b2-para-0192"></a>183</td></tr>
<tr>
<td><a id="c800_b2-para-0193"></a><b>2.11</b></td>
<td><a id="c800_b2-para-0194"></a>82</td>
<td><a id="c800_b2-para-0195"></a><b>2.31</b></td>
<td><a id="c800_b2-para-0196"></a>97</td>
<td><a id="c800_b2-para-0197"></a><b>2.51</b></td>
<td><a id="c800_b2-para-0198"></a>122</td>
<td><a id="c800_b2-para-0199"></a><b>2.71</b></td>
<td><a id="c800_b2-para-0200"></a>146</td>
<td><a id="c800_b2-para-0201"></a><b>2.91</b></td>
<td><a id="c800_b2-para-0202"></a>183</td></tr>
<tr>
<td><a id="c800_b2-para-0203"></a><b>2.12</b></td>
<td><a id="c800_b2-para-0204"></a>83</td>
<td><a id="c800_b2-para-0205"></a><b>2.32</b></td>
<td><a id="c800_b2-para-0206"></a>98</td>
<td><a id="c800_b2-para-0207"></a><b>2.52</b></td>
<td><a id="c800_b2-para-0208"></a>123</td>
<td><a id="c800_b2-para-0209"></a><b>2.72</b></td>
<td><a id="c800_b2-para-0210"></a>147</td>
<td><a id="c800_b2-para-0211"></a><b>2.92</b></td>
<td><a id="c800_b2-para-0212"></a>184</td></tr>
<tr>
<td><a id="c800_b2-para-0213"></a><b>2.13</b></td>
<td><a id="c800_b2-para-0214"></a>83</td>
<td><a id="c800_b2-para-0215"></a><b>2.33</b></td>
<td><a id="c800_b2-para-0216"></a>103</td>
<td><a id="c800_b2-para-0217"></a><b>2.53</b></td>
<td><a id="c800_b2-para-0218"></a>125</td>
<td><a id="c800_b2-para-0219"></a><b>2.73</b></td>
<td><a id="c800_b2-para-0220"></a>160</td>
<td><a id="c800_b2-para-0221"></a><b>2.93</b></td>
<td><a id="c800_b2-para-0222"></a>185</td></tr>
<tr>
<td><a id="c800_b2-para-0223"></a><b>2.14</b></td>
<td><a id="c800_b2-para-0224"></a>84</td>
<td><a id="c800_b2-para-0225"></a><b>2.34</b></td>
<td><a id="c800_b2-para-0226"></a>103</td>
<td><a id="c800_b2-para-0227"></a><b>2.54</b></td>
<td><a id="c800_b2-para-0228"></a>125</td>
<td><a id="c800_b2-para-0229"></a><b>2.74</b></td>
<td><a id="c800_b2-para-0230"></a>161</td>
<td><a id="c800_b2-para-0231"></a><b>2.94</b></td>
<td><a id="c800_b2-para-0232"></a>186</td></tr>
<tr>
<td><a id="c800_b2-para-0233"></a><b>2.15</b></td>
<td><a id="c800_b2-para-0234"></a>84</td>
<td><a id="c800_b2-para-0235"></a><b>2.35</b></td>
<td><a id="c800_b2-para-0236"></a>104</td>
<td><a id="c800_b2-para-0237"></a><b>2.55</b></td>
<td><a id="c800_b2-para-0238"></a>125</td>
<td><a id="c800_b2-para-0239"></a><b>2.75</b></td>
<td><a id="c800_b2-para-0240"></a>163</td>
<td><a id="c800_b2-para-0241"></a><b>2.95</b></td>
<td><a id="c800_b2-para-0242"></a>186</td></tr>
<tr>
<td><a id="c800_b2-para-0243"></a><b>2.16</b></td>
<td><a id="c800_b2-para-0244"></a>84</td>
<td><a id="c800_b2-para-0245"></a><b>2.36</b></td>
<td><a id="c800_b2-para-0246"></a>104</td>
<td><a id="c800_b2-para-0247"></a><b>2.56</b></td>
<td><a id="c800_b2-para-0248"></a>130</td>
<td><a id="c800_b2-para-0249"></a><b>2.76</b></td>
<td><a id="c800_b2-para-0250"></a>163</td>
<td><a id="c800_b2-para-0251"></a><b>2.96</b></td>
<td><a id="c800_b2-para-0252"></a>187</td></tr>
<tr>
<td><a id="c800_b2-para-0253"></a><b>2.17</b></td>
<td><a id="c800_b2-para-0254"></a>89</td>
<td><a id="c800_b2-para-0255"></a><b>2.37</b></td>
<td><a id="c800_b2-para-0256"></a>105</td>
<td><a id="c800_b2-para-0257"></a><b>2.57</b></td>
<td><a id="c800_b2-para-0258"></a>130</td>
<td><a id="c800_b2-para-0259"></a><b>2.77</b></td>
<td><a id="c800_b2-para-0260"></a>168</td>
<td><a id="c800_b2-para-0261"></a><b>2.97</b></td>
<td><a id="c800_b2-para-0262"></a>187</td></tr>
<tr>
<td><a id="c800_b2-para-0263"></a><b>2.18</b></td>
<td><a id="c800_b2-para-0264"></a>89</td>
<td><a id="c800_b2-para-0265"></a><b>2.38</b></td>
<td><a id="c800_b2-para-0266"></a>105</td>
<td><a id="c800_b2-para-0267"></a><b>2.58</b></td>
<td><a id="c800_b2-para-0268"></a>131</td>
<td><a id="c800_b2-para-0269"></a><b>2.78</b></td>
<td><a id="c800_b2-para-0270"></a>168</td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0271"></a><b>2.19</b></td>
<td><a id="c800_b2-para-0272"></a>89</td>
<td><a id="c800_b2-para-0273"></a><b>2.39</b></td>
<td><a id="c800_b2-para-0274"></a>106</td>
<td><a id="c800_b2-para-0275"></a><b>2.59</b></td>
<td><a id="c800_b2-para-0276"></a>133</td>
<td><a id="c800_b2-para-0277"></a><b>2.79</b></td>
<td><a id="c800_b2-para-0278"></a>169</td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0279"></a><b>2.20</b></td>
<td><a id="c800_b2-para-0280"></a>90</td>
<td><a id="c800_b2-para-0281"></a><b>2.40</b></td>
<td><a id="c800_b2-para-0282"></a>108</td>
<td><a id="c800_b2-para-0283"></a><b>2.60</b></td>
<td><a id="c800_b2-para-0284"></a>133</td>
<td><a id="c800_b2-para-0285"></a><b>2.80</b></td>
<td><a id="c800_b2-para-0286"></a>169</td>
<td></td>
<td></td></tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0287"></a><b>3.1</b></td>
<td><a id="c800_b2-para-0288"></a>196</td>
<td><a id="c800_b2-para-0289"></a><b>3.11</b></td>
<td><a id="c800_b2-para-0290"></a>220</td>
<td><a id="c800_b2-para-0291"></a><b>3.21</b></td>
<td><a id="c800_b2-para-0292"></a>234</td>
<td><a id="c800_b2-para-0293"></a><b>3.31</b></td>
<td><a id="c800_b2-para-0294"></a>249</td>
<td><a id="c800_b2-para-0295"></a><b>3.41</b></td>
<td><a id="c800_b2-para-0296"></a>271</td></tr>
<tr>
<td><a id="c800_b2-para-0297"></a><b>3.2</b></td>
<td><a id="c800_b2-para-0298"></a>196</td>
<td><a id="c800_b2-para-0299"></a><b>3.12</b></td>
<td><a id="c800_b2-para-0300"></a>225</td>
<td><a id="c800_b2-para-0301"></a><b>3.22</b></td>
<td><a id="c800_b2-para-0302"></a>235</td>
<td><a id="c800_b2-para-0303"></a><b>3.32</b></td>
<td><a id="c800_b2-para-0304"></a>252</td>
<td><a id="c800_b2-para-0305"></a><b>3.42</b></td>
<td><a id="c800_b2-para-0306"></a>271</td></tr>
<tr>
<td><a id="c800_b2-para-0307"></a><b>3.3</b></td>
<td><a id="c800_b2-para-0308"></a>196</td>
<td><a id="c800_b2-para-0309"></a><b>3.13</b></td>
<td><a id="c800_b2-para-0310"></a>226</td>
<td><a id="c800_b2-para-0311"></a><b>3.23</b></td>
<td><a id="c800_b2-para-0312"></a>235</td>
<td><a id="c800_b2-para-0313"></a><b>3.33</b></td>
<td><a id="c800_b2-para-0314"></a>261</td>
<td><a id="c800_b2-para-0315"></a><b>3.43</b></td>
<td><a id="c800_b2-para-0316"></a>274</td></tr>
<tr>
<td><a id="c800_b2-para-0317"></a><b>3.4</b></td>
<td><a id="c800_b2-para-0318"></a>197</td>
<td><a id="c800_b2-para-0319"></a><b>3.14</b></td>
<td><a id="c800_b2-para-0320"></a>226</td>
<td><a id="c800_b2-para-0321"></a><b>3.24</b></td>
<td><a id="c800_b2-para-0322"></a>240</td>
<td><a id="c800_b2-para-0323"></a><b>3.34</b></td>
<td><a id="c800_b2-para-0324"></a>261</td>
<td><a id="c800_b2-para-0325"></a><b>3.44</b></td>
<td><a id="c800_b2-para-0326"></a>274</td></tr>
<tr>
<td><a id="c800_b2-para-0327"></a><b>3.5</b></td>
<td><a id="c800_b2-para-0328"></a>200</td>
<td><a id="c800_b2-para-0329"></a><b>3.15</b></td>
<td><a id="c800_b2-para-0330"></a>228</td>
<td><a id="c800_b2-para-0331"></a><b>3.25</b></td>
<td><a id="c800_b2-para-0332"></a>240</td>
<td><a id="c800_b2-para-0333"></a><b>3.35</b></td>
<td><a id="c800_b2-para-0334"></a>261</td>
<td><a id="c800_b2-para-0335"></a><b>3.45</b></td>
<td><a id="c800_b2-para-0336"></a>275</td></tr>
<tr>
<td><a id="c800_b2-para-0337"></a><b>3.6</b></td>
<td><a id="c800_b2-para-0338"></a>200</td>
<td><a id="c800_b2-para-0339"></a><b>3.16</b></td>
<td><a id="c800_b2-para-0340"></a>229</td>
<td><a id="c800_b2-para-0341"></a><b>3.26</b></td>
<td><a id="c800_b2-para-0342"></a>240</td>
<td><a id="c800_b2-para-0343"></a><b>3.36</b></td>
<td><a id="c800_b2-para-0344"></a>261</td>
<td><a id="c800_b2-para-0345"></a><b>3.46</b></td>
<td><a id="c800_b2-para-0346"></a>278</td></tr>
<tr>
<td><a id="c800_b2-para-0347"></a><b>3.7</b></td>
<td><a id="c800_b2-para-0348"></a>205</td>
<td><a id="c800_b2-para-0349"></a><b>3.17</b></td>
<td><a id="c800_b2-para-0350"></a>229</td>
<td><a id="c800_b2-para-0351"></a><b>3.27</b></td>
<td><a id="c800_b2-para-0352"></a>240</td>
<td><a id="c800_b2-para-0353"></a><b>3.37</b></td>
<td><a id="c800_b2-para-0354"></a>262</td>
<td><a id="c800_b2-para-0355"></a><b>3.47</b></td>
<td><a id="c800_b2-para-0356"></a>278</td></tr>
<tr>
<td><a id="c800_b2-para-0357"></a><b>3.8</b></td>
<td><a id="c800_b2-para-0358"></a>206</td>
<td><a id="c800_b2-para-0359"></a><b>3.18</b></td>
<td><a id="c800_b2-para-0360"></a>229</td>
<td><a id="c800_b2-para-0361"></a><b>3.28</b></td>
<td><a id="c800_b2-para-0362"></a>245</td>
<td><a id="c800_b2-para-0363"></a><b>3.38</b></td>
<td><a id="c800_b2-para-0364"></a>267</td>
<td><a id="c800_b2-para-0365"></a><b>3.48</b></td>
<td><a id="c800_b2-para-0366"></a>279</td></tr>
<tr>
<td><a id="c800_b2-para-0367"></a><b>3.9</b></td>
<td><a id="c800_b2-para-0368"></a>212</td>
<td><a id="c800_b2-para-0369"></a><b>3.19</b></td>
<td><a id="c800_b2-para-0370"></a>229</td>
<td><a id="c800_b2-para-0371"></a><b>3.29</b></td>
<td><a id="c800_b2-para-0372"></a>245</td>
<td><a id="c800_b2-para-0373"></a><b>3.39</b></td>
<td><a id="c800_b2-para-0374"></a>270</td>
<td><a id="c800_b2-para-0375"></a><b>3.49</b></td>
<td><a id="c800_b2-para-0376"></a>279</td></tr>
<tr>
<td><a id="c800_b2-para-0377"></a><b>3.10</b></td>
<td><a id="c800_b2-para-0378"></a>217</td>
<td><a id="c800_b2-para-0379"></a><b>3.20</b></td>
<td><a id="c800_b2-para-0380"></a>230</td>
<td><a id="c800_b2-para-0381"></a><b>3.30</b></td>
<td><a id="c800_b2-para-0382"></a>245</td>
<td><a id="c800_b2-para-0383"></a><b>3.40</b></td>
<td><a id="c800_b2-para-0384"></a>270</td>
<td><a id="c800_b2-para-0385"></a><b>3.50</b></td>
<td><a id="c800_b2-para-0386"></a>287</td></tr>
<tr>
<td><a id="c800_b2-para-0387"></a><b>3.51</b></td>
<td><a id="c800_b2-para-0388"></a>287</td>
<td><a id="c800_b2-para-0389"></a><b>3.58</b></td>
<td><a id="c800_b2-para-0390"></a>293</td>
<td><a id="c800_b2-para-0391"></a><b>3.65</b></td>
<td><a id="c800_b2-para-0392"></a>299</td>
<td><a id="c800_b2-para-0393"></a><b>3.72</b></td>
<td><a id="c800_b2-para-0394"></a>302</td>
<td><a id="c800_b2-para-0395"></a><b>3.79</b></td>
<td><a id="c800_b2-para-0396"></a>308</td></tr>
<tr>
<td><a id="c800_b2-para-0397"></a><b>3.52</b></td>
<td><a id="c800_b2-para-0398"></a>288</td>
<td><a id="c800_b2-para-0399"></a><b>3.59</b></td>
<td><a id="c800_b2-para-0400"></a>294</td>
<td><a id="c800_b2-para-0401"></a><b>3.66</b></td>
<td><a id="c800_b2-para-0402"></a>301</td>
<td><a id="c800_b2-para-0403"></a><b>3.73</b></td>
<td><a id="c800_b2-para-0404"></a>303</td>
<td><a id="c800_b2-para-0405"></a><b>3.80</b></td>
<td><a id="c800_b2-para-0406"></a>308</td></tr>
<tr>
<td><a id="c800_b2-para-0407"></a><b>3.53</b></td>
<td><a id="c800_b2-para-0408"></a>292</td>
<td><a id="c800_b2-para-0409"></a><b>3.60</b></td>
<td><a id="c800_b2-para-0410"></a>294</td>
<td><a id="c800_b2-para-0411"></a><b>3.67</b></td>
<td><a id="c800_b2-para-0412"></a>301</td>
<td><a id="c800_b2-para-0413"></a><b>3.74</b></td>
<td><a id="c800_b2-para-0414"></a>304</td>
<td><a id="c800_b2-para-0415"></a><b>3.81</b></td>
<td><a id="c800_b2-para-0416"></a>312</td></tr>
<tr>
<td><a id="c800_b2-para-0417"></a><b>3.54</b></td>
<td><a id="c800_b2-para-0418"></a>292</td>
<td><a id="c800_b2-para-0419"></a><b>3.61</b></td>
<td><a id="c800_b2-para-0420"></a>295</td>
<td><a id="c800_b2-para-0421"></a><b>3.68</b></td>
<td><a id="c800_b2-para-0422"></a>301</td>
<td><a id="c800_b2-para-0423"></a><b>3.75</b></td>
<td><a id="c800_b2-para-0424"></a>304</td>
<td><a id="c800_b2-para-0425"></a><b>3.82</b></td>
<td><a id="c800_b2-para-0426"></a>312</td></tr>
<tr>
<td><a id="c800_b2-para-0427"></a><b>3.55</b></td>
<td><a id="c800_b2-para-0428"></a>292</td>
<td><a id="c800_b2-para-0429"></a><b>3.62</b></td>
<td><a id="c800_b2-para-0430"></a>295</td>
<td><a id="c800_b2-para-0431"></a><b>3.69</b></td>
<td><a id="c800_b2-para-0432"></a>301</td>
<td><a id="c800_b2-para-0433"></a><b>3.76</b></td>
<td><a id="c800_b2-para-0434"></a>305</td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0435"></a><b>3.56</b></td>
<td><a id="c800_b2-para-0436"></a>292</td>
<td><a id="c800_b2-para-0437"></a><b>3.63</b></td>
<td><a id="c800_b2-para-0438"></a>298</td>
<td><a id="c800_b2-para-0439"></a><b>3.70</b></td>
<td><a id="c800_b2-para-0440"></a>302</td>
<td><a id="c800_b2-para-0441"></a><b>3.77</b></td>
<td><a id="c800_b2-para-0442"></a>307</td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0443"></a><b>3.57</b></td>
<td><a id="c800_b2-para-0444"></a>293</td>
<td><a id="c800_b2-para-0445"></a><b>3.64</b></td>
<td><a id="c800_b2-para-0446"></a>298</td>
<td><a id="c800_b2-para-0447"></a><b>3.71</b></td>
<td><a id="c800_b2-para-0448"></a>302</td>
<td><a id="c800_b2-para-0449"></a><b>3.78</b></td>
<td><a id="c800_b2-para-0450"></a>308</td>
<td></td>
<td></td></tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0451"></a><b>4.1</b></td>
<td><a id="c800_b2-para-0452"></a>328</td>
<td><a id="c800_b2-para-0453"></a><b>4.17</b></td>
<td><a id="c800_b2-para-0454"></a>352</td>
<td><a id="c800_b2-para-0455"></a><b>4.33</b></td>
<td><a id="c800_b2-para-0456"></a>377</td>
<td><a id="c800_b2-para-0457"></a><b>4.49</b></td>
<td><a id="c800_b2-para-0458"></a>396</td>
<td><a id="c800_b2-para-0459"></a><b>4.65</b></td>
<td><a id="c800_b2-para-0460"></a>423</td></tr>
<tr>
<td><a id="c800_b2-para-0461"></a><b>4.2</b></td>
<td><a id="c800_b2-para-0462"></a>335</td>
<td><a id="c800_b2-para-0463"></a><b>4.18</b></td>
<td><a id="c800_b2-para-0464"></a>352</td>
<td><a id="c800_b2-para-0465"></a><b>4.34</b></td>
<td><a id="c800_b2-para-0466"></a>378</td>
<td><a id="c800_b2-para-0467"></a><b>4.50</b></td>
<td><a id="c800_b2-para-0468"></a>396</td>
<td><a id="c800_b2-para-0469"></a><b>4.66</b></td>
<td><a id="c800_b2-para-0470"></a>424</td></tr>
<tr>
<td><a id="c800_b2-para-0471"></a><b>4.3</b></td>
<td><a id="c800_b2-para-0472"></a>336</td>
<td><a id="c800_b2-para-0473"></a><b>4.19</b></td>
<td><a id="c800_b2-para-0474"></a>354</td>
<td><a id="c800_b2-para-0475"></a><b>4.35</b></td>
<td><a id="c800_b2-para-0476"></a>378</td>
<td><a id="c800_b2-para-0477"></a><b>4.51</b></td>
<td><a id="c800_b2-para-0478"></a>397</td>
<td><a id="c800_b2-para-0479"></a><b>4.67</b></td>
<td><a id="c800_b2-para-0480"></a>424</td></tr>
<tr>
<td><a id="c800_b2-para-0481"></a><b>4.4</b></td>
<td><a id="c800_b2-para-0482"></a>336</td>
<td><a id="c800_b2-para-0483"></a><b>4.20</b></td>
<td><a id="c800_b2-para-0484"></a>359</td>
<td><a id="c800_b2-para-0485"></a><b>4.36</b></td>
<td><a id="c800_b2-para-0486"></a>379</td>
<td><a id="c800_b2-para-0487"></a><b>4.52</b></td>
<td><a id="c800_b2-para-0488"></a>397</td>
<td><a id="c800_b2-para-0489"></a><b>4.68</b></td>
<td><a id="c800_b2-para-0490"></a>444</td></tr>
<tr>
<td><a id="c800_b2-para-0491"></a><b>4.5</b></td>
<td><a id="c800_b2-para-0492"></a>336</td>
<td><a id="c800_b2-para-0493"></a><b>4.21</b></td>
<td><a id="c800_b2-para-0494"></a>360</td>
<td><a id="c800_b2-para-0495"></a><b>4.37</b></td>
<td><a id="c800_b2-para-0496"></a>379</td>
<td><a id="c800_b2-para-0497"></a><b>4.53</b></td>
<td><a id="c800_b2-para-0498"></a>404</td>
<td><a id="c800_b2-para-0499"></a><b>4.69</b></td>
<td><a id="c800_b2-para-0500"></a>445</td></tr>
<tr>
<td><a id="c800_b2-para-0501"></a><b>4.6</b></td>
<td><a id="c800_b2-para-0502"></a>336</td>
<td><a id="c800_b2-para-0503"></a><b>4.22</b></td>
<td><a id="c800_b2-para-0504"></a>360</td>
<td><a id="c800_b2-para-0505"></a><b>4.38</b></td>
<td><a id="c800_b2-para-0506"></a>380</td>
<td><a id="c800_b2-para-0507"></a><b>4.54</b></td>
<td><a id="c800_b2-para-0508"></a>406</td>
<td><a id="c800_b2-para-0509"></a><b>4.70</b></td>
<td><a id="c800_b2-para-0510"></a>445</td></tr>
<tr>
<td><a id="c800_b2-para-0511"></a><b>4.7</b></td>
<td><a id="c800_b2-para-0512"></a>337</td>
<td><a id="c800_b2-para-0513"></a><b>4.23</b></td>
<td><a id="c800_b2-para-0514"></a>362</td>
<td><a id="c800_b2-para-0515"></a><b>4.39</b></td>
<td><a id="c800_b2-para-0516"></a>380</td>
<td><a id="c800_b2-para-0517"></a><b>4.55</b></td>
<td><a id="c800_b2-para-0518"></a>408</td>
<td><a id="c800_b2-para-0519"></a><b>4.71</b></td>
<td><a id="c800_b2-para-0520"></a>445</td></tr>
<tr>
<td><a id="c800_b2-para-0521"></a><b>4.8</b></td>
<td><a id="c800_b2-para-0522"></a>338</td>
<td><a id="c800_b2-para-0523"></a><b>4.24</b></td>
<td><a id="c800_b2-para-0524"></a>362</td>
<td><a id="c800_b2-para-0525"></a><b>4.40</b></td>
<td><a id="c800_b2-para-0526"></a>380</td>
<td><a id="c800_b2-para-0527"></a><b>4.56</b></td>
<td><a id="c800_b2-para-0528"></a>408</td>
<td><a id="c800_b2-para-0529"></a><b>4.72</b></td>
<td><a id="c800_b2-para-0530"></a>445</td></tr>
<tr>
<td><a id="c800_b2-para-0531"></a><b>4.9</b></td>
<td><a id="c800_b2-para-0532"></a>343</td>
<td><a id="c800_b2-para-0533"></a><b>4.25</b></td>
<td><a id="c800_b2-para-0534"></a>367</td>
<td><a id="c800_b2-para-0535"></a><b>4.41</b></td>
<td><a id="c800_b2-para-0536"></a>380</td>
<td><a id="c800_b2-para-0537"></a><b>4.57</b></td>
<td><a id="c800_b2-para-0538"></a>408</td>
<td><a id="c800_b2-para-0539"></a><b>4.73</b></td>
<td><a id="c800_b2-para-0540"></a>446</td></tr>
<tr>
<td><a id="c800_b2-para-0541"></a><b>4.10</b></td>
<td><a id="c800_b2-para-0542"></a>343</td>
<td><a id="c800_b2-para-0543"></a><b>4.26</b></td>
<td><a id="c800_b2-para-0544"></a>368</td>
<td><a id="c800_b2-para-0545"></a><b>4.42</b></td>
<td><a id="c800_b2-para-0546"></a>380</td>
<td><a id="c800_b2-para-0547"></a><b>4.58</b></td>
<td><a id="c800_b2-para-0548"></a>409</td>
<td><a id="c800_b2-para-0549"></a><b>4.74</b></td>
<td><a id="c800_b2-para-0550"></a>446</td></tr>
<tr>
<td><a id="c800_b2-para-0551"></a><b>4.11</b></td>
<td><a id="c800_b2-para-0552"></a>343</td>
<td><a id="c800_b2-para-0553"></a><b>4.27</b></td>
<td><a id="c800_b2-para-0554"></a>368</td>
<td><a id="c800_b2-para-0555"></a><b>4.43</b></td>
<td><a id="c800_b2-para-0556"></a>385</td>
<td><a id="c800_b2-para-0557"></a><b>4.59</b></td>
<td><a id="c800_b2-para-0558"></a>410</td>
<td><a id="c800_b2-para-0559"></a><b>4.75</b></td>
<td><a id="c800_b2-para-0560"></a>447</td></tr>
<tr>
<td><a id="c800_b2-para-0561"></a><b>4.12</b></td>
<td><a id="c800_b2-para-0562"></a>344</td>
<td><a id="c800_b2-para-0563"></a><b>4.28</b></td>
<td><a id="c800_b2-para-0564"></a>368</td>
<td><a id="c800_b2-para-0565"></a><b>4.44</b></td>
<td><a id="c800_b2-para-0566"></a>385</td>
<td><a id="c800_b2-para-0567"></a><b>4.60</b></td>
<td><a id="c800_b2-para-0568"></a>411</td>
<td><a id="c800_b2-para-0569"></a><b>4.76</b></td>
<td><a id="c800_b2-para-0570"></a>447</td></tr>
<tr>
<td><a id="c800_b2-para-0571"></a><b>4.13</b></td>
<td><a id="c800_b2-para-0572"></a>344</td>
<td><a id="c800_b2-para-0573"></a><b>4.29</b></td>
<td><a id="c800_b2-para-0574"></a>370</td>
<td><a id="c800_b2-para-0575"></a><b>4.45</b></td>
<td><a id="c800_b2-para-0576"></a>385</td>
<td><a id="c800_b2-para-0577"></a><b>4.61</b></td>
<td><a id="c800_b2-para-0578"></a>411</td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0579"></a><b>4.14</b></td>
<td><a id="c800_b2-para-0580"></a>348</td>
<td><a id="c800_b2-para-0581"></a><b>4.30</b></td>
<td><a id="c800_b2-para-0582"></a>372</td>
<td><a id="c800_b2-para-0583"></a><b>4.46</b></td>
<td><a id="c800_b2-para-0584"></a>385</td>
<td><a id="c800_b2-para-0585"></a><b>4.62</b></td>
<td><a id="c800_b2-para-0586"></a>422</td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0587"></a><b>4.15</b></td>
<td><a id="c800_b2-para-0588"></a>350</td>
<td><a id="c800_b2-para-0589"></a><b>4.31</b></td>
<td><a id="c800_b2-para-0590"></a>372</td>
<td><a id="c800_b2-para-0591"></a><b>4.47</b></td>
<td><a id="c800_b2-para-0592"></a>385</td>
<td><a id="c800_b2-para-0593"></a><b>4.63</b></td>
<td><a id="c800_b2-para-0594"></a>423</td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0595"></a><b>4.16</b></td>
<td><a id="c800_b2-para-0596"></a>352</td>
<td><a id="c800_b2-para-0597"></a><b>4.32</b></td>
<td><a id="c800_b2-para-0598"></a>372</td>
<td><a id="c800_b2-para-0599"></a><b>4.48</b></td>
<td><a id="c800_b2-para-0600"></a>396</td>
<td><a id="c800_b2-para-0601"></a><b>4.64</b></td>
<td><a id="c800_b2-para-0602"></a>423</td>
<td></td>
<td></td></tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td></tr>
<tr>
<td><a id="c800_b2-para-0603"></a><b>5.1</b></td>
<td><a id="c800_b2-para-0604"></a>452</td>
<td><a id="c800_b2-para-0605"></a><b>5.12</b></td>
<td><a id="c800_b2-para-0606"></a>484</td>
<td><a id="c800_b2-para-0607"></a><b>5.23</b></td>
<td><a id="c800_b2-para-0608"></a>511</td>
<td><a id="c800_b2-para-0609"></a><b>5.34</b></td>
<td><a id="c800_b2-para-0610"></a>534</td>
<td><a id="c800_b2-para-0611"></a><b>5.45</b></td>
<td><a id="c800_b2-para-0612"></a>556</td></tr>
<tr>
<td><a id="c800_b2-para-0613"></a><b>5.2</b></td>
<td><a id="c800_b2-para-0614"></a>454</td>
<td><a id="c800_b2-para-0615"></a><b>5.13</b></td>
<td><a id="c800_b2-para-0616"></a>486</td>
<td><a id="c800_b2-para-0617"></a><b>5.24</b></td>
<td><a id="c800_b2-para-0618"></a>511</td>
<td><a id="c800_b2-para-0619"></a><b>5.35</b></td>
<td><a id="c800_b2-para-0620"></a>535</td>
<td><a id="c800_b2-para-0621"></a><b>5.46</b></td>
<td><a id="c800_b2-para-0622"></a>557</td></tr>
<tr>
<td><a id="c800_b2-para-0623"></a><b>5.3</b></td>
<td><a id="c800_b2-para-0624"></a>457</td>
<td><a id="c800_b2-para-0625"></a><b>5.14</b></td>
<td><a id="c800_b2-para-0626"></a>486</td>
<td><a id="c800_b2-para-0627"></a><b>5.25</b></td>
<td><a id="c800_b2-para-0628"></a>513</td>
<td><a id="c800_b2-para-0629"></a><b>5.36</b></td>
<td><a id="c800_b2-para-0630"></a>549</td>
<td><a id="c800_b2-para-0631"></a><b>5.47</b></td>
<td><a id="c800_b2-para-0632"></a>557</td></tr>
<tr>
<td><a id="c800_b2-para-0633"></a><b>5.4</b></td>
<td><a id="c800_b2-para-0634"></a>466</td>
<td><a id="c800_b2-para-0635"></a><b>5.15</b></td>
<td><a id="c800_b2-para-0636"></a>486</td>
<td><a id="c800_b2-para-0637"></a><b>5.26</b></td>
<td><a id="c800_b2-para-0638"></a>513</td>
<td><a id="c800_b2-para-0639"></a><b>5.37</b></td>
<td><a id="c800_b2-para-0640"></a>549</td>
<td><a id="c800_b2-para-0641"></a><b>5.48</b></td>
<td><a id="c800_b2-para-0642"></a>562</td></tr>
<tr>
<td><a id="c800_b2-para-0643"></a><b>5.5</b></td>
<td><a id="c800_b2-para-0644"></a>467</td>
<td><a id="c800_b2-para-0645"></a><b>5.16</b></td>
<td><a id="c800_b2-para-0646"></a>486</td>
<td><a id="c800_b2-para-0647"></a><b>5.27</b></td>
<td><a id="c800_b2-para-0648"></a>517</td>
<td><a id="c800_b2-para-0649"></a><b>5.38</b></td>
<td><a id="c800_b2-para-0650"></a>549</td>
<td><a id="c800_b2-para-0651"></a><b>5.49</b></td>
<td><a id="c800_b2-para-0652"></a>562</td></tr>
<tr>
<td><a id="c800_b2-para-0653"></a><b>5.6</b></td>
<td><a id="c800_b2-para-0654"></a>467</td>
<td><a id="c800_b2-para-0655"></a><b>5.17</b></td>
<td><a id="c800_b2-para-0656"></a>486</td>
<td><a id="c800_b2-para-0657"></a><b>5.28</b></td>
<td><a id="c800_b2-para-0658"></a>517</td>
<td><a id="c800_b2-para-0659"></a><b>5.39</b></td>
<td><a id="c800_b2-para-0660"></a>549</td>
<td><a id="c800_b2-para-0661"></a><b>5.50</b></td>
<td><a id="c800_b2-para-0662"></a>563</td></tr>
<tr>
<td><a id="c800_b2-para-0663"></a><b>5.7</b></td>
<td><a id="c800_b2-para-0664"></a>469</td>
<td><a id="c800_b2-para-0665"></a><b>5.18</b></td>
<td><a id="c800_b2-para-0666"></a>486</td>
<td><a id="c800_b2-para-0667"></a><b>5.29</b></td>
<td><a id="c800_b2-para-0668"></a>518</td>
<td><a id="c800_b2-para-0669"></a><b>5.40</b></td>
<td><a id="c800_b2-para-0670"></a>553</td>
<td><a id="c800_b2-para-0671"></a><b>5.51</b></td>
<td><a id="c800_b2-para-0672"></a>563</td></tr>
<tr>
<td><a id="c800_b2-para-0673"></a><b>5.8</b></td>
<td><a id="c800_b2-para-0674"></a>477</td>
<td><a id="c800_b2-para-0675"></a><b>5.19</b></td>
<td><a id="c800_b2-para-0676"></a>492</td>
<td><a id="c800_b2-para-0677"></a><b>5.30</b></td>
<td><a id="c800_b2-para-0678"></a>518</td>
<td><a id="c800_b2-para-0679"></a><b>5.41</b></td>
<td><a id="c800_b2-para-0680"></a>553</td>
<td><a id="c800_b2-para-0681"></a><b>5.52</b></td>
<td><a id="c800_b2-para-0682"></a>563</td></tr>
<tr>
<td><a id="c800_b2-para-0683"></a><b>5.9</b></td>
<td><a id="c800_b2-para-0684"></a>483</td>
<td><a id="c800_b2-para-0685"></a><b>5.20</b></td>
<td><a id="c800_b2-para-0686"></a>492</td>
<td><a id="c800_b2-para-0687"></a><b>5.31</b></td>
<td><a id="c800_b2-para-0688"></a>518</td>
<td><a id="c800_b2-para-0689"></a><b>5.42</b></td>
<td><a id="c800_b2-para-0690"></a>556</td>
<td><a id="c800_b2-para-0691"></a><b>5.53</b></td>
<td><a id="c800_b2-para-0692"></a>564</td></tr>
<tr>
<td><a id="c800_b2-para-0693"></a><b>5.10</b></td>
<td><a id="c800_b2-para-0694"></a>483</td>
<td><a id="c800_b2-para-0695"></a><b>5.21</b></td>
<td><a id="c800_b2-para-0696"></a>492</td>
<td><a id="c800_b2-para-0697"></a><b>5.32</b></td>
<td><a id="c800_b2-para-0698"></a>526</td>
<td><a id="c800_b2-para-0699"></a><b>5.43</b></td>
<td><a id="c800_b2-para-0700"></a>556</td>
<td><a id="c800_b2-para-0701"></a><b>5.54</b></td>
<td><a id="c800_b2-para-0702"></a>564</td></tr>
<tr>
<td><a id="c800_b2-para-0703"></a><b>5.11</b></td>
<td><a id="c800_b2-para-0704"></a>484</td>
<td><a id="c800_b2-para-0705"></a><b>5.22</b></td>
<td><a id="c800_b2-para-0706"></a>511</td>
<td><a id="c800_b2-para-0707"></a><b>5.33</b></td>
<td><a id="c800_b2-para-0708"></a>526</td>
<td><a id="c800_b2-para-0709"></a><b>5.44</b></td>
<td><a id="c800_b2-para-0710"></a>556</td>
<td><a id="c800_b2-para-0711"></a><b>5.55</b></td>
<td><a id="c800_b2-para-0712"></a>564</td></tr></tbody></table></div>
</figure>
</section>
</body></body></html>