<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>References</title>
<link href="../styles/MIT_style.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:5e22faf7-6d97-43f5-a05d-571a507bcb19" name="Adept.expected.resource"/>
</head>
<body>
<section>
<header>
<h1><a id="b1-title-0001"/><span class="chapterTitle">References</span></h1>
</header>
<section class="biblioDiv"><a id="b1-ref-0001"/>
<h2><a id="b1-title-0002"/></h2>
<ol class="biblioEntryList">
<li class="bibliographyEntry"><a id="b1-bib-0001"/>Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister, Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992. The Supercomputer Toolkit: A general framework for special-purpose computing. <i>International Journal of High-Speed Electronics</i> 3(3):337–361.</li>
<li class="bibliographyEntry"><a id="b1-bib-0002"/>Allen, John. 1978. <i>Anatomy of Lisp</i>. New York: McGraw-Hill.</li>
<li class="bibliographyEntry"><a id="b1-bib-0003"/>Appel, Andrew W. 1987. Garbage collection can be faster than stack allocation. <i>Information Processing Letters</i> 25(4):275–279.</li>
<li class="bibliographyEntry"><a id="b1-bib-0004"/>Backus, John. 1978. Can programming be liberated from the von Neumann style? <i>Communications of the ACM</i> 21(8):613–641.</li>
<li class="bibliographyEntry"><a id="b1-bib-0005"/>Baker, Henry G., Jr. 1978. List processing in real time on a serial computer. <i>Communications of the ACM</i> 21(4):280–293.</li>
<li class="bibliographyEntry"><a id="b1-bib-0006"/>Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise. 1982. The Scheme-81 architecture—System and chip. In <i>Proceedings of the MIT Conference on Advanced Research in VLSI</i>, edited by Paul Penfield, Jr. Dedham, MA: Artech House.</li>
<li class="bibliographyEntry"><a id="b1-bib-0007"/>Borning, Alan. 1977. ThingLab—An object-oriented system for building simulations using constraints. In <i>Proceedings of the 5th International Joint Conference on Artificial Intelligence</i>.</li>
<li class="bibliographyEntry"><a id="b1-bib-0008"/>Borodin, Alan, and Ian Munro. 1975. <i>The Computational Complexity of Algebraic and Numeric Problems</i>. New York: American Elsevier.</li>
<li class="bibliographyEntry"><a id="b1-bib-0009"/>Chaitin, Gregory J. 1975. Randomness and mathematical proof. <i>Scientific American</i> 232(5): 47–52.</li>
<li class="bibliographyEntry"><a id="b1-bib-0010"/>Church, Alonzo. 1941. <i>The Calculi of Lambda-Conversion</i>. Princeton, N.J.: Princeton University Press.</li>
<li class="bibliographyEntry"><a id="b1-bib-0011"/>Clark, Keith L. 1978. Negation as failure. In <i>Logic and Data Bases</i>. New York: Plenum Press, pp. 293–322.</li>
<li class="bibliographyEntry"><a id="b1-bib-0012"/>Clinger, William. 1982. Nondeterministic call by need is neither lazy nor by name. In <i>Proceedings of the ACM Symposium on Lisp and Functional Programming</i>, pp. 226–234.</li>
<li class="bibliographyEntry"><a id="b1-bib-0013"/>Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel. 1973. Un système de communication homme-machine en français. Technical report, Groupe d’Intelligence Artificielle, Université d’Aix-Marseille II, Luminy.</li>
<li class="bibliographyEntry"><a id="b1-bib-0014"/>Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2022. <i>Introduction to Algorithms</i>. 4th edition. Cambridge, MA: MIT Press.</li>
<li class="bibliographyEntry"><a id="b1-bib-0015"/>Crockford, Douglas. 2008. <i>JavaScript: The Good Parts</i>. Sebastopol, CA: O’Reilly Media.</li>
<li class="bibliographyEntry"><a id="b1-bib-0016"/>Darlington, John, Peter Henderson, and David Turner. 1982. <i>Functional Programming and Its Applications</i>. New York: Cambridge University Press.</li>
<li class="bibliographyEntry"><a id="b1-bib-0017"/>Dijkstra, Edsger W. 1968a. The structure of the “THE” multiprogramming system. <i>Communications of the ACM</i> 11(5):341–346.</li>
<li class="bibliographyEntry"><a id="b1-bib-0018"/>Dijkstra, Edsger W. 1968b. Cooperating sequential processes. In <i>Programming Languages</i>, edited by F. Genuys. New York: Academic Press, pp. 43–112.</li>
<li class="bibliographyEntry"><a id="b1-bib-0019"/>Dinesman, Howard P. 1968. <i>Superior Mathematical Puzzles</i>. New York: Simon and Schuster.</li>
<li class="bibliographyEntry"><a id="b1-bib-0020"/>de Kleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman. 1977. AMORD: Explicit control of reasoning. In <i>Proceedings of the ACM Symposium on Artificial Intelligence and Programming Languages</i>, pp. 116–125.</li>
<li class="bibliographyEntry"><a id="b1-bib-0021"/>Doyle, Jon. 1979. A truth maintenance system. <i>Artificial Intelligence</i> 12:231–272.</li>
<li class="bibliographyEntry"><a id="b1-bib-0022"/>ECMA. 1997. ECMAScript: A general purpose, cross-platform programming language. 1st edition, edited by Guy L. Steele Jr. <i>Ecma International</i>.</li>
<li class="bibliographyEntry"><a id="b1-bib-0023"/>ECMA. 2015. ECMAScript: A general purpose, cross-platform programming language. 6th edition, edited by Allen Wirfs-Brock. <i>Ecma International</i>.</li>
<li class="bibliographyEntry"><a id="b1-bib-0024"/>ECMA. 2020. <i>ECMAScript: A general purpose, cross-platform programming language</i>. 11th edition, edited by Jordan Harband. <i>Ecma International</i>.</li>
<li class="bibliographyEntry"><a id="b1-bib-0025"/>Edwards, A. W. F. 2019. <i>Pascal's Arithmetical Triangle. Mineola</i>, New York: Dover Publications.</li>
<li class="bibliographyEntry"><a id="b1-bib-0026"/>Feeley, Marc. 1986. Deux approches à l’implantation du language Scheme. Masters thesis, Université de Montréal.</li>
<li class="bibliographyEntry"><a id="b1-bib-0027"/>Feeley, Marc and Guy Lapalme. 1987. Using closures for code generation. <i>Journal of Computer Languages</i> 12(1):47–66.</li>
<li class="bibliographyEntry"><a id="b1-bib-0028"/>Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National Fifth Generation Project: Introduction, survey, and evaluation. In <i>Future Generation Computer Systems</i>, vol. 9, pp. 105–117.</li>
<li class="bibliographyEntry"><a id="b1-bib-0029"/>Feller, William. 1957. <i>An Introduction to Probability Theory and Its Applications</i>, volume 1. <i>New York</i>: John Wiley &amp; Sons.</li>
<li class="bibliographyEntry"><a id="b1-bib-0030"/>Fenichel, R., and J. Yochelson. 1969. A Lisp garbage collector for virtual memory computer systems. <i>Communications of the ACM</i> 12(11):611–612.</li>
<li class="bibliographyEntry"><a id="b1-bib-0031"/>Floyd, Robert. 1967. Nondeterministic algorithms. <i>JACM</i>, 14(4):636–644.</li>
<li class="bibliographyEntry"><a id="b1-bib-0032"/>Forbus, Kenneth D., and Johan de Kleer. 1993. <i>Building Problem Solvers</i>. Cambridge, MA: MIT Press.</li>
<li class="bibliographyEntry"><a id="b1-bib-0033"/>Friedman, Daniel P., and David S. Wise. 1976. CONS should not evaluate its arguments. In <i>Automata, Languages, and Programming: Third International Colloquium</i>, edited by S. Michaelson and R. Milner, pp. 257–284.</li>
<li class="bibliographyEntry"><a id="b1-bib-0034"/>Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992. <i>Essentials of Programming Languages</i>. Cambridge, MA: MIT Press/McGraw-Hill.</li>
<li class="bibliographyEntry"><a id="b1-bib-0035"/>Gabriel, Richard P. 1988. The Why of <i>Y</i>. <i>Lisp Pointers</i> 2(2):15–25.</li>
<li class="bibliographyEntry"><a id="b1-bib-0036"/>Goldberg, Adele, and David Robson. 1983. <i>Smalltalk-80: The Language and Its Implementation</i>. Reading, MA: Addison-Wesley.</li>
<li class="bibliographyEntry"><a id="b1-bib-0037"/>Gordon, Michael, Robin Milner, and Christopher Wadsworth. 1979. <i>Edinburgh LCF. Lecture Notes in Computer Science</i>, volume 78. New York: Springer-Verlag.</li>
<li class="bibliographyEntry"><a id="b1-bib-0038"/>Gray, Jim, and Andreas Reuter. 1993. <i>Transaction Processing: Concepts and Models</i>. San Mateo, CA: Morgan-Kaufman.</li>
<li class="bibliographyEntry"><a id="b1-bib-0039"/>Green, Cordell. 1969. Application of theorem proving to problem solving. In <i>Proceedings of the International Joint Conference on Artificial Intelligence</i>, pp. 219–240.</li>
<li class="bibliographyEntry"><a id="b1-bib-0040"/>Green, Cordell, and Bertram Raphael. 1968. The use of theorem-proving techniques in question-answering systems. In <i>Proceedings of the ACM National Conference</i>, pp. 169–181.</li>
<li class="bibliographyEntry"><a id="b1-bib-0041"/>Guttag, John V. 1977. Abstract data types and the development of data structures. <i>Communications of the ACM</i> 20(6):397–404.</li>
<li class="bibliographyEntry"><a id="b1-bib-0042"/>Hamming, Richard W. 1980. <i>Coding and Information Theory</i>. Englewood Cliffs, N.J.: Prentice-Hall.</li>
<li class="bibliographyEntry"><a id="b1-bib-0043"/>Hanson, Christopher P. 1990. Efficient stack allocation for tail-recursive languages. In <i>Proceedings of ACM Conference on Lisp and Functional Programming</i>, pp. 106–118.</li>
<li class="bibliographyEntry"><a id="b1-bib-0044"/>Hanson, Christopher P. 1991. A syntactic closures macro facility. <i>Lisp Pointers</i>, 4(4):9–16.</li>
<li class="bibliographyEntry"><a id="b1-bib-0045"/>Hardy, Godfrey H. 1921. Srinivasa Ramanujan. <i>Proceedings of the London Mathematical Society</i> XIX(2).</li>
<li class="bibliographyEntry"><a id="b1-bib-0046"/>Hardy, Godfrey H., and E. M. Wright. 1960. <i>An Introduction to the Theory of Numbers</i>. 4th edition. New York: Oxford University Press.</li>
<li class="bibliographyEntry"><a id="b1-bib-0047"/>Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. <i>IBM Systems Journal</i> 7(2):74–84.</li>
<li class="bibliographyEntry"><a id="b1-bib-0048"/>Henderson, Peter. 1980. <i>Functional Programming: Application and Implementation</i>. Englewood Cliffs, N.J.: Prentice-Hall.</li>
<li class="bibliographyEntry"><a id="b1-bib-0049"/>Henderson. Peter. 1982. Functional Geometry. In <i>Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming</i>, pp. 179–187.</li>
<li class="bibliographyEntry"><a id="b1-bib-0050"/>Hewitt, Carl E. 1969. PLANNER: A language for proving theorems in robots. In <i>Proceedings of the International Joint Conference on Artificial Intelligence</i>, pp. 295–301.</li>
<li class="bibliographyEntry"><a id="b1-bib-0051"/>Hewitt, Carl E. 1977. Viewing control structures as patterns of passing messages. <i>Journal of Artificial Intelligence</i> 8(3):323–364.</li>
<li class="bibliographyEntry"><a id="b1-bib-0052"/>Hoare, C. A. R. 1972. Proof of correctness of data representations. <i>Acta Informatica</i> 1(1):271–281.</li>
<li class="bibliographyEntry"><a id="b1-bib-0053"/>Hodges, Andrew. 1983. <i>Alan Turing: The Enigma</i>. New York: Simon and Schuster.</li>
<li class="bibliographyEntry"><a id="b1-bib-0054"/>Hofstadter, Douglas R. 1979. <i>Gödel, Escher, Bach: An Eternal Golden Braid</i>. New York: Basic Books.</li>
<li class="bibliographyEntry"><a id="b1-bib-0055"/>Hughes, R. J. M. 1990. Why functional programming matters. In <i>Research Topics in Functional Programming</i>, edited by David Turner. Reading, MA: Addison-Wesley, pp. 17–42.</li>
<li class="bibliographyEntry"><a id="b1-bib-0056"/>IEEE Std 1178-1990. 1990. IEEE Standard for the Scheme Programming Language.</li>
<li class="bibliographyEntry"><a id="b1-bib-0057"/>Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted by M. Lind, Herbert Kanner, and Robert Floyd. 1960. THUNKS: A way of compiling procedure statements, with some comments on procedure declarations. Unpublished manuscript. (Also, private communication from Wallace Feurzeig.)</li>
<li class="bibliographyEntry"><a id="b1-bib-0058"/>Jaffar, Joxan, and Peter J. Stuckey. 1986. Semantics of infinite tree logic programming. <i>Theoretical Computer Science</i> 46:141–158.</li>
<li class="bibliographyEntry"><a id="b1-bib-0059"/>Kaldewaij, Anne. 1990. <i>Programming: The Derivation of Algorithms</i>. New York: PrenticeHall.</li>
<li class="bibliographyEntry"><a id="b1-bib-0060"/>Knuth, Donald E. 1997a. <i>Fundamental Algorithms</i>. Volume 1 of The Art of Computer Programming. 3rd edition. Reading, MA: Addison-Wesley.</li>
<li class="bibliographyEntry"><a id="b1-bib-0061"/>Knuth, Donald E. 1997b. <i>Seminumerical Algorithms</i>. Volume 2 of The Art of Computer Programming. 3rd edition. Reading, MA: Addison-Wesley.</li>
<li class="bibliographyEntry"><a id="b1-bib-0062"/>Konopasek, Milos, and Sundaresan Jayaraman. 1984. <i>The TK!Solver Book: A Guide to Problem-Solving in Science, Engineering, Business, and Education</i><i>.</i> Berkeley, CA: Osborne/McGraw-Hill.</li>
<li class="bibliographyEntry"><a id="b1-bib-0063"/>Kowalski, Robert. 1973. Predicate logic as a programming language. Technical report 70, Department of Computational Logic, School of Artificial Intelligence, University of Edinburgh.</li>
<li class="bibliographyEntry"><a id="b1-bib-0064"/>Kowalski, Robert. 1979. <i>Logic for Problem Solving</i><i>.</i> New York: North-Holland.</li>
<li class="bibliographyEntry"><a id="b1-bib-0065"/>Lamport, Leslie. 1978. Time, clocks, and the ordering of events in a distributed system. <i>Communications of the ACM</i> 21(7):558–565.</li>
<li class="bibliographyEntry"><a id="b1-bib-0066"/>Lampson, Butler, J. J. Horning, R. London, J. G. Mitchell, and G. K. Popek. 1981. Report on the programming language Euclid. Technical report, Computer Systems Research Group, University of Toronto.</li>
<li class="bibliographyEntry"><a id="b1-bib-0067"/>Landin, Peter. 1965. A correspondence between Algol 60 and Church's lambda notation: Part I. <i>Communications of the ACM</i> 8(2):89–101.</li>
<li class="bibliographyEntry"><a id="b1-bib-0068"/>Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage collector based on the lifetimes of objects. <i>Communications of the ACM</i> 26(6):419–429.</li>
<li class="bibliographyEntry"><a id="b1-bib-0069"/>Liskov, Barbara H., and Stephen N. Zilles. 1975. Specification techniques for data abstractions. <i>IEEE Transactions on Software Engineering</i> 1(1):7–19.</li>
<li class="bibliographyEntry"><a id="b1-bib-0070"/>McAllester, David Allen. 1978. A three-valued truth-maintenance system. Memo 473, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="b1-bib-0071"/>McAllester, David Allen. 1980. An outlook on truth maintenance. Memo 551, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="b1-bib-0072"/>McCarthy, John. 1967. A basis for a mathematical theory of computation. In <i>Computer Programing and Formal Systems</i>, edited by P. Braffort and D. Hirschberg. North-Holland, pp. 33–70.</li>
<li class="bibliographyEntry"><a id="b1-bib-0073"/>McDermott, Drew, and Gerald Jay Sussman. 1972. Conniver reference manual. Memo 259, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="b1-bib-0074"/>Miller, Gary L. 1976. Riemann's Hypothesis and tests for primality. <i>Journal of Computer and System Sciences</i> 13(3):300–317.</li>
<li class="bibliographyEntry"><a id="b1-bib-0075"/>Miller, James S., and Guillermo J. Rozas. 1994. Garbage collection is fast, but a stack is faster. Memo 1462, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="b1-bib-0076"/>Moon, David. 1978. MacLisp reference manual, Version 0. Technical report, MIT Laboratory for Computer Science.</li>
<li class="bibliographyEntry"><a id="b1-bib-0077"/>Morris, J. H., Eric Schmidt, and Philip Wadler. 1980. Experience with an applicative string processing language. In <i>Proceedings of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of Programming Languages</i><i>.</i></li>
<li class="bibliographyEntry"><a id="b1-bib-0078"/>Phillips, Hubert. 1934. <i>The Sphinx Problem Book</i>. London: Faber and Faber.</li>
<li class="bibliographyEntry"><a id="b1-bib-0079"/>Phillips, Hubert. 1961. <i>My Best Puzzles in Logic and Reasoning</i>. New York: Dover Publications.</li>
<li class="bibliographyEntry"><a id="b1-bib-0080"/>Rabin, Michael O. 1980. Probabilistic algorithm for testing primality. <i>Journal of Number Theory</i> 12:128–138.</li>
<li class="bibliographyEntry"><a id="b1-bib-0081"/>Raymond, Eric. 1996. <i>The New Hacker's Dictionary</i><i>.</i> 3rd edition. Cambridge, MA: MIT Press.</li>
<li class="bibliographyEntry"><a id="b1-bib-0082"/>Raynal, Michel. 1986. <i>Algorithms for Mutual Exclusion</i><i>.</i> Cambridge, MA: MIT Press.</li>
<li class="bibliographyEntry"><a id="b1-bib-0083"/>Rees, Jonathan A., and Norman I. Adams IV. 1982. T: A dialect of Lisp or, lambda: The ultimate software tool. In <i>Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming</i><i>,</i> pp. 114–122.</li>
<li class="bibliographyEntry"><a id="b1-bib-0084"/>Rivest, Ronald L., Adi Shamir, and Leonard M. Adleman. 1978. A method for obtaining digital signatures and public-key cryptosystems. <i>Communications of the ACM</i><i>,</i> 21(2):120–126.</li>
<li class="bibliographyEntry"><a id="b1-bib-0085"/>Robinson, J. A. 1965. A machine-oriented logic based on the resolution principle. <i>Journal of the ACM</i> 12(1):23.</li>
<li class="bibliographyEntry"><a id="b1-bib-0086"/>Robinson, J. A. 1983. Logic programming—Past, present, and future. <i>New Generation Computing</i> 1:107–124.</li>
<li class="bibliographyEntry"><a id="b1-bib-0087"/>Spafford, Eugene H. 1989. The Internet Worm: Crisis and aftermath. <i>Communications of the ACM</i> 32(6):678–688.</li>
<li class="bibliographyEntry"><a id="b1-bib-0088"/>Steele, Guy Lewis, Jr. 1977. Debunking the “expensive procedure call” myth. In <i>Proceedings of the National Conference of the ACM</i><i>,</i> pp. 153–162.</li>
<li class="bibliographyEntry"><a id="b1-bib-0089"/>Steele, Guy Lewis, Jr., and Gerald Jay Sussman. 1975. Scheme: An interpreter for the extended lambda calculus. Memo 349, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="b1-bib-0090"/>Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R. Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow. 1983. <i>The Hacker's Dictionary</i><i>.</i> New York: Harper &amp; Row.</li>
<li class="bibliographyEntry"><a id="b1-bib-0091"/>Stoy, Joseph E. 1977. <i>Denotational Semantics</i><i>.</i> Cambridge, MA: MIT Press.</li>
<li class="bibliographyEntry"><a id="b1-bib-0092"/>Sussman, Gerald Jay, and Richard M. Stallman. 1975. Heuristic techniques in computeraided circuit analysis. <i>IEEE Transactions on Circuits and Systems</i> CAS-22(11):857–865.</li>
<li class="bibliographyEntry"><a id="b1-bib-0093"/>Sussman, Gerald Jay, and Guy Lewis Steele Jr. 1980. Constraints—A language for expressing almost-hierarchical descriptions. <i>AI Journal</i> 14:1–39.</li>
<li class="bibliographyEntry"><a id="b1-bib-0094"/>Sussman, Gerald Jay, and Jack Wisdom. 1992. Chaotic evolution of the solar system. <i>Science</i> 257:256–262.</li>
<li class="bibliographyEntry"><a id="b1-bib-0095"/>Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak. 1971. Microplanner reference manual. Memo 203A, MIT Artificial Intelligence Laboratory.</li>
<li class="bibliographyEntry"><a id="b1-bib-0096"/>Sutherland, Ivan E. 1963. SKETCHPAD: A man-machine graphical communication system. Technical report 296, MIT Lincoln Laboratory.</li>
<li class="bibliographyEntry"><a id="b1-bib-0097"/>Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978. Data type specification: Parameterization and the power of specification techniques. In <i>Conference Record of the Tenth Annual ACM Symposium on Theory of Computing</i>, pp. 119–132.</li>
<li class="bibliographyEntry"><a id="b1-bib-0098"/>Turner, David. 1981. The future of applicative languages. In <i>Proceedings of the 3rd European Conference on Informatics</i>, Lecture Notes in Computer Science, volume 123. New York: Springer-Verlag, pp. 334–348.</li>
<li class="bibliographyEntry"><a id="b1-bib-0099"/>Wand, Mitchell. 1980. Continuation-based program transformation strategies. <i>Journal of the ACM</i> 27(1):164–180.</li>
<li class="bibliographyEntry"><a id="b1-bib-0100"/>Waters, Richard C. 1979. A method for analyzing loop programs. <i>IEEE Transactions on Software Engineering</i> 5(3):237–247.</li>
<li class="bibliographyEntry"><a id="b1-bib-0101"/>Winston, Patrick. 1992. <i>Artificial Intelligence</i>. 3rd edition. Reading, MA: Addison-Wesley.</li>
<li class="bibliographyEntry"><a id="b1-bib-0102"/>Zabih, Ramin, David McAllester, and David Chapman. 1987. Non-deterministic Lisp with dependency-directed backtracking. <i>AAAI-87</i>, pp. 59–64.</li>
<li class="bibliographyEntry"><a id="b1-bib-0103"/>Zippel, Richard. 1979. Probabilistic algorithms for sparse polynomials. Ph.D. dissertation, Department of Electrical Engineering and Computer Science, MIT.</li>
<li class="bibliographyEntry"><a id="b1-bib-0104"/>Zippel, Richard. 1993. <i>Effective Polynomial Computation</i><i>.</i> Boston, MA: Kluwer Academic Publishers.</li>
</ol>
</section>
</section>
</body>
</html>