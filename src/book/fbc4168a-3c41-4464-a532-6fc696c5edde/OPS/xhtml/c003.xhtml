<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>3 Modularity, Objects, and State</title>
<link href="../styles/MIT_style.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:5e22faf7-6d97-43f5-a05d-571a507bcb19" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<h1><a id="c3-title-0001"/><span class="chapterNumber">3</span><br/><span class="chapterTitle">Modularity, Objects, and State</span></h1>
</header>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c3-para-0001"/><i>Mεταβάλλον αναπαύεται</i></p>
<p class="quote-epigraphparafirst"><a id="c3-para-0002"/>(Even while it changes, it stands still.)</p>
<p class="quote-epigraphsource">—Heraclitus</p></blockquote>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c3-para-0003"/>Plus ça change, plus c’est la même chose.</p>
<p class="quote-epigraphsource">—Alphonse Karr</p></blockquote>
<p class="paraaftertitle"><a id="c3-para-0004"/>The preceding chapters introduced the basic elements from which programs are made. We saw how primitive functions and primitive data are combined to construct compound entities, and we learned that abstraction is vital in helping us to cope with the complexity of large systems. But these tools are not sufficient for designing programs. Effective program synthesis also requires organizational principles that can guide us in formulating the overall design of a program. In particular, we need strategies to help us structure large systems so that they will be <i>modular</i>, that is, so that they can be divided “naturally” into coherent parts that can be separately developed and maintained.</p>
<p><a id="c3-para-0005"/>One powerful design strategy, which is particularly appropriate to the construction of programs for modeling physical systems, is to base the structure of our programs on the structure of the system being modeled. For each object in the system, we construct a corresponding computational object. For each system action, we define a symbolic operation in our computational model. Our hope in using this strategy is that extending the model to accommodate new objects or new actions will require no strategic changes to the program, only the addition of the new symbolic analogs of those objects or actions. If we have been successful in our system organization, then to add a new feature or debug an old one we will have to work on only a localized part of the system.</p>
<p><a id="c3-para-0006"/>To a large extent, then, the way we organize a large program is dictated by our perception of the system to be modeled. In this chapter we will investigate two prominent organizational strategies arising from two rather different “world views” of the structure of systems. The first organizational strategy concentrates on <i>objects</i>, viewing a large system as a collection of distinct objects whose behaviors may change over time. An alternative organizational strategy concentrates on the <i>streams</i> of information that flow in the system, much as an electrical engineer views a signal-processing system.</p>
<p><a id="c3-para-0007"/>Both the object-based approach and the stream-processing approach raise significant linguistic issues in programming. With objects, we must be concerned with how a computational object can change and yet maintain its identity. This will force us to abandon our old substitution model of computation (section 1.1.5) in favor of a more mechanistic but less theoretically tractable <i>environment model</i> of computation. The difficulties of dealing with objects, change, and identity are a fundamental consequence of the need to grapple with time in our computational models. These difficulties become even greater when we allow the possibility of concurrent execution of programs. The stream approach can be most fully exploited when we decouple simulated time in our model from the order of the events that take place in the computer during evaluation. We will accomplish this using a technique known as <i>delayed evaluation</i>.</p>
<section><a id="c3-title-0002"/>
<section>
<h2><a id="c3-sec-0002"/><span>3.1</span> <a id="c3-title-0003"/>Assignment and Local State</h2>
<p class="paraaftertitle"><a id="c3-para-0008"/>We ordinarily view the world as populated by independent objects, each of which has a state that changes over time. An object is said to “have state” if its behavior is influenced by its history. A bank account, for example, has state in that the answer to the question “Can I withdraw $100?” depends upon the history of deposit and withdrawal transactions. We can characterize an object's state by one or more <i>state variables</i>, which among them maintain enough information about history to determine the object's current behavior. In a simple banking system, we could characterize the state of an account by a current balance rather than by remembering the entire history of account transactions.</p>
<p><a id="c3-para-0009"/>In a system composed of many objects, the objects are rarely completely independent. Each may influence the states of others through interactions, which serve to couple the state variables of one object to those of other objects. Indeed, the view that a system is composed of separate objects is most useful when the state variables of the system can be grouped into closely coupled subsystems that are only loosely coupled to other subsystems.</p>
<p><a id="c3-para-0010"/>This view of a system can be a powerful framework for organizing computational models of the system. For such a model to be modular, it should be decomposed into computational objects that model the actual objects in the system. Each computational object must have its own <i>local state variables</i> describing the actual object's state. Since the states of objects in the system being modeled change over time, the state variables of the corresponding computational objects must also change. If we choose to model the flow of time in the system by the elapsed time in the computer, then we must have a way to construct computational objects whose behaviors change as our programs run. In particular, if we wish to model state variables by ordinary symbolic names in the programming language, then the language must provide an <i>assignment operation</i> to enable us to change the value associated with a name.</p>
<section>
<h3><a id="c3-sec-0003"/><span>3.1.1</span> <a id="c3-title-0004"/>Local State Variables</h3>
<p class="paraaftertitle"><a id="c3-para-0011"/>To illustrate what we mean by having a computational object with time-varying state, let us model the situation of withdrawing money from a bank account. We will do this using a function <span class="KeyTerm1">withdraw</span>, which takes as argument an <span class="KeyTerm1">amount</span> to be withdrawn. If there is enough money in the account to accommodate the withdrawal, then <span class="KeyTerm1">withdraw</span> should return the balance remaining after the withdrawal. Otherwise, <span class="KeyTerm1">withdraw</span> should return the message <i>Insufficient funds.</i> For example, if we begin</p>
<p class="paracontinue"><a id="c3-para-0012"/>with $100 in the account, we should obtain the following sequence of responses using <span class="KeyTerm1">withdraw</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0013"/>withdraw(25);</p>
<p class="Sp-text-1"><a id="c3-para-0014"/><i>75</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0015"/>withdraw(25);</p>
<p class="Sp-text-1"><a id="c3-para-0016"/><i>50</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0017"/>withdraw(60);</p>
<p class="Sp-text-1"><a id="c3-para-0018"/><i>"Insufficient funds"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0019"/>withdraw(15);</p>
<p class="Sp-text-1"><a id="c3-para-0020"/><i>35</i></p>
<p class="paracontinue"><a id="c3-para-0021"/>Observe that the expression <span class="KeyTerm1">withdraw(25)</span>, evaluated twice, yields different values. This is a new kind of behavior for a function. Until now, all our JavaScript functions could be viewed as specifications for computing mathematical functions. A call to a function computed the value of the function applied to the given arguments, and two calls to the same function with the same arguments always produced the same result.<a id="c3-fn-0001a"/><a href="#c3-fn-0001"><sup>1</sup></a></p>
<p><a id="c3-para-0022"/>So far, all our names have been <i>immutable</i>. When a function was applied, the values that its parameters referred to never changed, and once a declaration was evaluated, the declared name never changed its value. To implement functions like <span class="KeyTerm1">withdraw</span>, we introduce <i>variable declarations</i>, which use the keyword <span class="KeyTerm1"><b>let</b></span>, in addition to constant declarations, which use the keyword <span class="KeyTerm1"><b>const</b></span>. We can declare a variable <span class="KeyTerm1">balance</span> to indicate the balance of money in the account and define <span class="KeyTerm1">withdraw</span> as a function that accesses <span class="KeyTerm1">balance</span>. The <span class="KeyTerm1">withdraw</span> function checks to see if <span class="KeyTerm1">balance</span> is at least as large as the requested <span class="KeyTerm1">amount</span>. If so, <span class="KeyTerm1">withdraw</span> decrements <span class="KeyTerm1">balance</span> by <span class="KeyTerm1">amount</span> and returns the new value of <span class="KeyTerm1">balance</span>. Otherwise, <span class="KeyTerm1">withdraw</span> returns the <i>Insufficient funds</i> message. Here are the declarations of <span class="KeyTerm1">balance</span> and <span class="KeyTerm1">withdraw</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0023"/><b>let</b> balance = 100;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0024"/><b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0025"/>    <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0026"/>        balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0027"/>        <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0028"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0029"/>        <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-0030"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0031"/>}</p>
<p class="paracontinue"><a id="c3-para-0032"/>Decrementing <span class="KeyTerm1">balance</span> is accomplished by the expression statement</p>
<p class="Sp-text-1"><a id="c3-para-0033"/>balance = balance - amount;</p>
<p class="paracontinue"><a id="c3-para-0034"/>The syntax of <i>assignment</i> expressions is</p>
<p class="Sp-text-1"><a id="c3-para-0035"/><span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>new</i>-<i>value</i></span></p>
<p class="paracontinue"><a id="c3-para-0036"/>Here <i>name</i> has been declared with <span class="KeyTerm1"><b>let</b></span> or as a function parameter and <i>new</i>-<i>value</i> is any expression. The assignment changes <i>name</i> so that its value is the result obtained by evaluating <i>new</i>-<i>value</i>. In the case at hand, we are changing <span class="KeyTerm1">balance</span> so that its new value will be the result of subtracting <span class="KeyTerm1">amount</span> from the previous value of <span class="KeyTerm1">balance</span>.<a id="c3-fn-0002a"/><a href="#c3-fn-0002"><sup>2</sup></a></p>
<p><a id="c3-para-0037"/>The function <span class="KeyTerm1">withdraw</span> also uses a <i>sequence of statements</i> to cause two statements to be evaluated in the case where the <span class="KeyTerm1"><b>if</b></span> test is true: first decrementing <span class="KeyTerm1">balance</span> and then returning the value of <span class="KeyTerm1">balance</span>. In general, executing a sequence</p>
<p class="Sp-text-1"><a id="c3-para-0038"/><span class="KeyTerm2"><i>stmt</i><sub>1</sub></span> <span class="KeyTerm2"><i>stmt</i><sub>2</sub></span> <i>. . .</i><span class="KeyTerm2"><i>stmt<sub>n</sub></i></span></p>
<p class="paracontinue"><a id="c3-para-0039"/>causes the statements <i>stmt</i><sub>1</sub> through <i>stmt<sub>n</sub></i> to be evaluated in sequence.<a id="c3-fn-0003a"/><a href="#c3-fn-0003"><sup>3</sup></a></p>
<p><a id="c3-para-0040"/>Although <span class="KeyTerm1">withdraw</span> works as desired, the variable <span class="KeyTerm1">balance</span> presents a problem. As specified above, <span class="KeyTerm1">balance</span> is a name defined in the program environment and is freely accessible to be examined or modified by any function. It would be much better if we could somehow make <span class="KeyTerm1">balance</span> internal to <span class="KeyTerm1">withdraw</span>, so that <span class="KeyTerm1">withdraw</span> would be the only function that could access <span class="KeyTerm1">balance</span> directly and any other function could access <span class="KeyTerm1">balance</span> only indirectly (through calls to <span class="KeyTerm1">withdraw</span>). This would more accurately model the notion that <span class="KeyTerm1">balance</span> is a local state variable used by <span class="KeyTerm1">withdraw</span> to keep track of the state of the account.</p>
<p><a id="c3-para-0047"/>We can make <span class="KeyTerm1">balance</span> internal to <span class="KeyTerm1">withdraw</span> by rewriting the definition as follows:</p>
<p class="Sp-text-1"><a id="c3-para-0048"/><b>function</b> make_withdraw_balance_100() {</p>
<p class="Sp-text-1"><a id="c3-para-0049"/>    <b>let</b> balance = 100;</p>
<p class="Sp-text-1"><a id="c3-para-0050"/>    <b>return</b> amount =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-0051"/>               <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0052"/>                   balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0053"/>                   <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0054"/>               } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0055"/>                   <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-0056"/>               }</p>
<p class="Sp-text-1"><a id="c3-para-0057"/>           };</p>
<p class="Sp-text-1"><a id="c3-para-0058"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0059"/><b>const</b> new_withdraw = make_withdraw_balance_100();</p>
<p class="paracontinue"><a id="c3-para-0060"/>What we have done here is use <span class="KeyTerm1"><b>let</b></span> to establish an environment with a local variable <span class="KeyTerm1">balance</span>, bound to the initial value 100. Within this local environment, we use a lambda expression<a id="c3-fn-0004a"/><a href="#c3-fn-0004"><sup>4</sup></a> to create a function that takes <span class="KeyTerm1">amount</span> as an argument and behaves like our previous <span class="KeyTerm1">withdraw</span> function. This function—returned as the result of evaluating the body of the <span class="KeyTerm1">make_withdraw_balance_100</span> function—behaves in precisely the same way as <span class="KeyTerm1">withdraw</span>, but its variable <span class="KeyTerm1">balance</span> is not accessible by any other function.<a id="c3-fn-0005a"/><a href="#c3-fn-0005"><sup>5</sup></a></p>
<p><a id="c3-para-0061"/>Combining assignments with variable declarations is the general programming technique we will use for constructing computational objects with local state. Unfortunately, using this technique raises a serious problem: When we first introduced functions, we also introduced the substitution model of evaluation (section 1.1.5) to provide an interpretation of what function application means. We said that applying a function whose body is a return statement should be interpreted as evaluating the return expression of the function with the parameters replaced by their values. For functions with more complex bodies, we need to evaluate the whole body with the parameters replaced by their values. The trouble is that, as soon as we introduce assignment into our language, substitution is no longer an adequate model of function application. (We will see why this is so in section 3.1.3.) As a consequence, we technically have at this point no way to understand why the <span class="KeyTerm1">new_withdraw</span> function behaves as claimed above. In order to really understand a function such as <span class="KeyTerm1">new_withdraw</span>, we will need to develop a new model of function application. In section 3.2 we will introduce such a model, together with an explanation of assignments and variable declarations. First, however, we examine some variations on the theme established by <span class="KeyTerm1">new_withdraw</span>.</p>
<p><a id="c3-para-0063"/>Parameters of functions as well as names declared with <span class="KeyTerm1"><b>let</b></span> are variables. The following function, <span class="KeyTerm1">make_withdraw</span>, creates “withdrawal processors.” The parameter <span class="KeyTerm1">balance</span> in <span class="KeyTerm1">make_withdraw</span> specifies the initial amount of money in the account.<a id="c3-fn-0006a"/><a href="#c3-fn-0006"><sup>6</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-0064"/><b>function</b> make_withdraw(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-0065"/>    <b>return</b> amount =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-0066"/>               <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0067"/>                   balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0068"/>                   <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0069"/>               } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0070"/>                   <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-0071"/>               }</p>
<p class="Sp-text-1"><a id="c3-para-0072"/>           };</p>
<p class="Sp-text-1"><a id="c3-para-0073"/>}</p>
<p class="paracontinue"><a id="c3-para-0074"/>The function <span class="KeyTerm1">make_withdraw</span> can be used as follows to create two objects <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0075"/><b>const</b> W1 = make_withdraw(100);</p>
<p class="Sp-text-1"><a id="c3-para-0076"/><b>const</b> W2 = make_withdraw(100);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0077"/>W1(50);</p>
<p class="Sp-text-1"><a id="c3-para-0078"/><i>50</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0079"/>W2(70);</p>
<p class="Sp-text-1"><a id="c3-para-0080"/><i>30</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0081"/>W2(40);</p>
<p class="Sp-text-1"><a id="c3-para-0082"/><i>"Insufficient funds"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0083"/>W1(40);</p>
<p class="Sp-text-1"><a id="c3-para-0084"/><i>10</i></p>
<p class="paracontinue"><a id="c3-para-0085"/>Observe that <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> are completely independent objects, each with its own local state variable <span class="KeyTerm1">balance</span>. Withdrawals from one do not affect the other.</p>
<p><a id="c3-para-0086"/>We can also create objects that handle deposits as well as withdrawals, and thus we can represent simple bank accounts. Here is a function that returns a “bankaccount object” with a specified initial balance:</p>
<p class="Sp-text-1"><a id="c3-para-0087"/><b>function</b> make_account(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-0088"/>    <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0089"/>        <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0090"/>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0091"/>            <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0092"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0093"/>            <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-0094"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-0095"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0096"/>    <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0097"/>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c3-para-0098"/>        <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0099"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0100"/>    <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c3-para-0101"/>        <b>return</b> m === "withdraw"</p>
<p class="Sp-text-1"><a id="c3-para-0102"/>               ? withdraw</p>
<p class="Sp-text-1"><a id="c3-para-0103"/>               : m === "deposit"</p>
<p class="Sp-text-1"><a id="c3-para-0104"/>               ? deposit</p>
<p class="Sp-text-1"><a id="c3-para-0105"/>               : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c3-para-0106"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0107"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c3-para-0108"/>}</p>
<p class="paracontinue"><a id="c3-para-0109"/>Each call to <span class="KeyTerm1">make_account</span> sets up an environment with a local state variable <span class="KeyTerm1">balance</span>. Within this environment, <span class="KeyTerm1">make_account</span> defines functions <span class="KeyTerm1">deposit</span> and <span class="KeyTerm1">withdraw</span> that access <span class="KeyTerm1">balance</span> and an additional function <span class="KeyTerm1">dispatch</span> that takes a “message” as input and returns one of the two local functions. The <span class="KeyTerm1">dispatch</span> function itself is returned as the value that represents the bank-account object. This is precisely the <i>message-passing</i> style of programming that we saw in section 2.4.3, although here we are using it in conjunction with the ability to modify local variables.</p>
<p><a id="c3-para-0110"/>The function <span class="KeyTerm1">make_account</span> can be used as follows:</p>
<p class="Sp-text-1"><a id="c3-para-0111"/><b>const</b> acc = make_account(100);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0112"/>acc("withdraw")(50);</p>
<p class="Sp-text-1"><a id="c3-para-0113"/><i>50</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0114"/>acc("withdraw")(60);</p>
<p class="Sp-text-1"><a id="c3-para-0115"/><i>"Insufficient funds"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0116"/>acc("deposit")(40);</p>
<p class="Sp-text-1"><a id="c3-para-0117"/><i>90</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0118"/>acc("withdraw")(60);</p>
<p class="Sp-text-1"><a id="c3-para-0119"/><i>30</i></p>
<p class="paracontinue"><a id="c3-para-0120"/>Each call to <span class="KeyTerm1">acc</span> returns the locally defined <span class="KeyTerm1">deposit</span> or <span class="KeyTerm1">withdraw</span> function, which is then applied to the specified <span class="KeyTerm1">amount</span>. As was the case with <span class="KeyTerm1">make_withdraw</span>, another call to <span class="KeyTerm1">make_account</span></p>
<p class="Sp-text-1"><a id="c3-para-0121"/><b>const</b> acc2 = make_account(100);</p>
<p class="paracontinue"><a id="c3-para-0122"/>will produce a completely separate account object, which maintains its own local <span class="KeyTerm1">balance</span>.</p>
<section>
<h5><a id="c3-sec-0004"/><a id="c3-title-0005"/>Exercise 3.1</h5>
<p class="paraaftertitle"><a id="c3-para-0124"/>An <i>accumulator</i> is a function that is called repeatedly with a single numeric argument and accumulates its arguments into a sum. Each time it is called, it returns the currently accumulated sum. Write a function <span class="KeyTerm1">make_accumulator</span> that generates accumulators, each maintaining an independent sum. The input to <span class="KeyTerm1">make_accumulator</span> should specify the initial value of the sum; for example</p>
<p class="Sp-text-1"><a id="c3-para-0125"/><b>const</b> a = make_accumulator(5); </p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0126"/>a(10);</p>
<p class="Sp-text-1"><a id="c3-para-0127"/><i>15</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0128"/>a(10);</p>
<p class="Sp-text-1"><a id="c3-para-0129"/><i>25</i></p>
</section>
<section>
<h5><a id="c3-sec-0005"/><a id="c3-title-0006"/>Exercise 3.2</h5>
<p class="paraaftertitle"><a id="c3-para-0130"/>In software-testing applications, it is useful to be able to count the number of times a given function is called during the course of a computation. Write a function <span class="KeyTerm1">make_monitored</span> that takes as input a function, <span class="KeyTerm1">f</span>, that itself takes one input. The result returned by <span class="KeyTerm1">make_monitored</span> is a third function, say <span class="KeyTerm1">mf</span>, that keeps track of the number of times it has been called by maintaining an internal counter. If the input to <span class="KeyTerm1">mf</span> is the string <span class="KeyTerm1">"how many calls"</span>, then <span class="KeyTerm1">mf</span> returns the value of the counter. If the input is the string <span class="KeyTerm1">"reset count"</span>, then <span class="KeyTerm1">mf</span> resets the counter to zero. For any other input, <span class="KeyTerm1">mf</span> returns the result of calling <span class="KeyTerm1">f</span> on that input and increments the counter. For instance, we could make a monitored version of the <span class="KeyTerm1">sqrt</span> function:</p>
<p class="Sp-text-1"><a id="c3-para-0131"/><b>const</b> s = make_monitored(math_sqrt);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0132"/>s(100);</p>
<p class="Sp-text-1"><a id="c3-para-0133"/><i>10</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0134"/>s("how many calls");</p>
<p class="Sp-text-1"><a id="c3-para-0135"/><i>1</i></p>
</section>
<section>
<h5><a id="c3-sec-0006"/><a id="c3-title-0007"/>Exercise 3.3</h5>
<p class="paraaftertitle"><a id="c3-para-0136"/>Modify the <span class="KeyTerm1">make_account</span> function so that it creates password-protected accounts. That is, <span class="KeyTerm1">make_account</span> should take a string as an additional argument, as in</p>
<p class="Sp-text-1"><a id="c3-para-0137"/><b>const</b> acc = make_account(100, "secret password");</p>
<p class="paracontinue"><a id="c3-para-0138"/>The resulting account object should process a request only if it is accompanied by the password with which the account was created, and should otherwise return a complaint:</p>
<p class="Sp-text-1"><a id="c3-para-0139"/>acc("secret password", "withdraw")(40);</p>
<p class="Sp-text-1"><a id="c3-para-0140"/><i>60</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0141"/>acc("some other password", "deposit")(40);</p>
<p class="Sp-text-1"><a id="c3-para-0142"/><i>"Incorrect password"</i></p>
</section>
<section>
<h5><a id="c3-sec-0007"/><a id="c3-title-0008"/>Exercise 3.4</h5>
<p class="paraaftertitle"><a id="c3-para-0143"/>Modify the <span class="KeyTerm1">make_account</span> function of exercise 3.3 by adding another local state variable so that, if an account is accessed more than seven consecutive times with an incorrect password, it invokes the function <span class="KeyTerm1">call_the_cops</span>.</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0008"/><span>3.1.2</span> <a id="c3-title-0009"/>The Benefits of Introducing Assignment</h3>
<p class="paraaftertitle"><a id="c3-para-0144"/>As we shall see, introducing assignment into our programming language leads us into a thicket of difficult conceptual issues. Nevertheless, viewing systems as collections of objects with local state is a powerful technique for maintaining a modular design. As a simple example, consider the design of a function <span class="KeyTerm1">rand</span> that, whenever it is called, returns an integer chosen at random.</p>
<p><a id="c3-para-0145"/>It is not at all clear what is meant by “chosen at random.” What we presumably want is for successive calls to <span class="KeyTerm1">rand</span> to produce a sequence of numbers that has statistical properties of uniform distribution. We will not discuss methods for generating suitable sequences here. Rather, let us assume that we have a function <span class="KeyTerm1">rand_update</span> that has the property that if we start with a given number <i>x</i><sub>1</sub> and form</p>
<p class="Sp-text-1"><a id="c3-para-0146"/><span class="KeyTerm2"><i>x</i><sub>2</sub></span> = rand_update(<span class="KeyTerm2"><i>x</i><sub>1</sub></span>);</p>
<p class="Sp-text-1"><a id="c3-para-0147"/><span class="KeyTerm2"><i>x</i><sub>3</sub></span> = rand_update(<span class="KeyTerm2"><i>x</i><sub>2</sub></span>);</p>
<p class="paracontinue"><a id="c3-para-0148"/>then the sequence of values <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>, <span class="KeyTerm1"><i>. . .</i></span>, will have the desired statistical properties.<a id="c3-fn-0007a"/><a href="#c3-fn-0007"><sup>7</sup></a></p>
<p><a id="c3-para-5148"/>We can implement <span class="KeyTerm1">rand</span> as a function with a local state variable <span class="KeyTerm1">x</span> that is initialized to some fixed value <span class="KeyTerm1">random_init</span>. Each call to <span class="KeyTerm1">rand</span> computes <span class="KeyTerm1">rand_update</span> of the current value of <span class="KeyTerm1">x</span>, returns this as the random number, and also stores this as the new value of <span class="KeyTerm1">x</span>.</p>
<p class="Sp-text-1"><a id="c3-para-0149"/><b>function</b> make_rand() {</p>
<p class="Sp-text-1"><a id="c3-para-0150"/>    <b>let</b> x = random_init;</p>
<p class="Sp-text-1"><a id="c3-para-0151"/>    <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-0152"/>              x = rand_update(x);</p>
<p class="Sp-text-1"><a id="c3-para-0153"/>              <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c3-para-0154"/>           };</p>
<p class="Sp-text-1"><a id="c3-para-0155"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0156"/><b>const</b> rand = make_rand();</p>
<p><a id="c3-para-0157"/>Of course, we could generate the same sequence of random numbers without using assignment by simply calling <span class="KeyTerm1">rand_update</span> directly. However, this would mean that any part of our program that used random numbers would have to explicitly remember the current value of <span class="KeyTerm1">x</span> to be passed as an argument to <span class="KeyTerm1">rand_update</span>. To realize what an annoyance this would be, consider using random numbers to implement a technique called <i>Monte Carlo simulation</i>.</p>
<p><a id="c3-para-0158"/>The Monte Carlo method consists of choosing sample experiments at random from a large set and then making deductions on the basis of the probabilities estimated from tabulating the results of those experiments. For example, we can approximate <i>π</i> using the fact that 6/<i>π</i><sup>2</sup> is the probability that two integers chosen at random will have no factors in common; that is, that their greatest common divisor will be 1.<a id="c3-fn-0008a"/><a href="#c3-fn-0008"><sup>8</sup></a> To obtain the approximation to <i>π</i>, we perform a large number of experiments. In each experiment we choose two integers at random and perform a test to see if their GCD is 1. The fraction of times that the test is passed gives us our estimate of 6/<i>π</i><sup>2</sup>, and from this we obtain our approximation to <i>π</i>.</p>
<p><a id="c3-para-0159"/>The heart of our program is a function <span class="KeyTerm1">monte_carlo</span>, which takes as arguments the number of times to try an experiment, together with the experiment, represented as a no-argument function that will return either true or false each time it is run. The function <span class="KeyTerm1">monte_carlo</span> runs the experiment for the designated number of trials and returns a number telling the fraction of the trials in which the experiment was found to be true.</p>
<p class="Sp-text-1"><a id="c3-para-0160"/><b>function</b> estimate_pi(trials) {</p>
<p class="Sp-text-1"><a id="c3-para-0161"/>    <b>return</b> math_sqrt(6 / monte_carlo(trials, dirichlet_test));</p>
<p class="Sp-text-1"><a id="c3-para-0162"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0163"/><b>function</b> dirichlet_test() {</p>
<p class="Sp-text-1"><a id="c3-para-0164"/>    <b>return</b> gcd(rand(), rand()) === 1;</p>
<p class="Sp-text-1"><a id="c3-para-0165"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0166"/><b>function</b> monte_carlo(trials, experiment) {</p>
<p class="Sp-text-1"><a id="c3-para-0167"/>    <b>function</b> iter(trials_remaining, trials_passed) {</p>
<p class="Sp-text-1"><a id="c3-para-0168"/>        <b>return</b> trials_remaining === 0</p>
<p class="Sp-text-1"><a id="c3-para-0169"/>               ? trials_passed / trials</p>
<p class="Sp-text-1"><a id="c3-para-0170"/>               : experiment()</p>
<p class="Sp-text-1"><a id="c3-para-0171"/>               ? iter(trials_remaining - 1, trials_passed + 1)</p>
<p class="Sp-text-1"><a id="c3-para-0172"/>               : iter(trials_remaining - 1, trials_passed);</p>
<p class="Sp-text-1"><a id="c3-para-0173"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0174"/>    <b>return</b> iter(trials, 0);</p>
<p class="Sp-text-1"><a id="c3-para-0175"/>}</p>
<p><a id="c3-para-0176"/>Now let us try the same computation using <span class="KeyTerm1">rand_update</span> directly rather than <span class="KeyTerm1">rand</span>, the way we would be forced to proceed if we did not use assignment to model local state:</p>
<p class="Sp-text-1"><a id="c3-para-0177"/><b>function</b> estimate_pi(trials) {</p>
<p class="Sp-text-1"><a id="c3-para-0178"/>    <b>return</b> math_sqrt(6 / random_gcd_test(trials, random_init));</p>
<p class="Sp-text-1"><a id="c3-para-0179"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0180"/><b>function</b> random_gcd_test(trials, initial_x) {</p>
<p class="Sp-text-1"><a id="c3-para-0181"/>    <b>function</b> iter(trials_remaining, trials_passed, x) {</p>
<p class="Sp-text-1"><a id="c3-para-0182"/>        <b>const</b> x1 = rand_update(x);</p>
<p class="Sp-text-1"><a id="c3-para-0183"/>        <b>const</b> x2 = rand_update(x1);</p>
<p class="Sp-text-1"><a id="c3-para-0184"/>        <b>return</b> trials_remaining === 0</p>
<p class="Sp-text-1"><a id="c3-para-0185"/>               ? trials_passed / trials</p>
<p class="Sp-text-1"><a id="c3-para-0186"/>               : gcd(x1, x2) === 1</p>
<p class="Sp-text-1"><a id="c3-para-0187"/>               ? iter(trials_remaining - 1, trials_passed + 1, x2)</p>
<p class="Sp-text-1"><a id="c3-para-0188"/>               : iter(trials_remaining - 1, trials_passed, x2);</p>
<p class="Sp-text-1"><a id="c3-para-0189"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0190"/>    <b>return</b> iter(trials, 0, initial_x);</p>
<p class="Sp-text-1"><a id="c3-para-0191"/>}</p>
<p><a id="c3-para-0192"/>While the program is still simple, it betrays some painful breaches of modularity. In our first version of the program, using <span class="KeyTerm1">rand</span>, we can express the Monte Carlo method directly as a general <span class="KeyTerm1">monte_carlo</span> function that takes as an argument an arbitrary <span class="KeyTerm1">experiment</span> function. In our second version of the program, with no local state for the random-number generator, <span class="KeyTerm1">random_gcd_test</span> must explicitly manipulate the random numbers <span class="KeyTerm1">x1</span> and <span class="KeyTerm1">x2</span> and recycle <span class="KeyTerm1">x2</span> through the iterative loop as the new input to <span class="KeyTerm1">rand_update</span>. This explicit handling of the random numbers intertwines the structure of accumulating test results with the fact that our particular experiment uses two random numbers, whereas other Monte Carlo experiments might use one random number or three. Even the top-level function <span class="KeyTerm1">estimate_pi</span> has to be concerned with supplying an initial random number. The fact that the random-number generator's insides are leaking out into other parts of the program makes it difficult for us to isolate the Monte Carlo idea so that it can be applied to other tasks. In the first version of the program, assignment encapsulates the state of the random-number generator within the <span class="KeyTerm1">rand</span> function, so that the details of random-number generation remain independent of the rest of the program.</p>
<p><a id="c3-para-0193"/>The general phenomenon illustrated by the Monte Carlo example is this: From the point of view of one part of a complex process, the other parts appear to change with time. They have hidden time-varying local state. If we wish to write computer programs whose structure reflects this decomposition, we make computational objects (such as bank accounts and random-number generators) whose behavior changes with time. We model state with local state variables, and we model the changes of state with assignments to those variables.</p>
<p><a id="c3-para-0194"/>It is tempting to conclude this discussion by saying that, by introducing assignment and the technique of hiding state in local variables, we are able to structure systems in a more modular fashion than if all state had to be manipulated explicitly, by passing additional parameters. Unfortunately, as we shall see, the story is not so simple.</p>
<section>
<h5><a id="c3-sec-0009"/><a id="c3-title-0010"/>Exercise 3.5</h5>
<p class="paraaftertitle"><a id="c3-para-0195"/><i>Monte Carlo integration</i> is a method of estimating definite integrals by means of Monte Carlo simulation. Consider computing the area of a region of space described by a predicate <i>P</i>(<i>x</i>, <i>y</i>) that is true for points (<i>x</i>, <i>y</i>) in the region and false for points not in the region. For example, the region contained within a circle of radius 3 centered at (5, 7) is described by the predicate that tests whether (<i>x</i> – 5)<sup>2</sup> + (<i>y</i> – 7)<sup>2</sup> 3<sup>2</sup>. To estimate the area of the region described by such a predicate, begin by choosing a rectangle that contains the region. For example, a rectangle with diagonally opposite corners at (2, 4) and (8, 10) contains the circle above. The desired integral is the area of that portion of the rectangle that lies in the region. We can estimate the integral by picking, at random, points (<i>x</i>, <i>y</i>) that lie in the rectangle, and testing <i>P</i>(<i>x</i>, <i>y</i>) for each point to determine whether the point lies in the region. If we try this with many points, then the fraction of points that fall in the region should give an estimate of the proportion of the rectangle that lies in the region. Hence, multiplying this fraction by the area of the entire rectangle should produce an estimate of the integral.</p>
<p><a id="c3-para-0196"/>Implement Monte Carlo integration as a function estimate_integral that takes as arguments a predicate P, upper and lower bounds <span class="KeyTerm1">x1</span>, <span class="KeyTerm1">x2</span>, <span class="KeyTerm1">y1</span>, and <span class="KeyTerm1">y2</span> for the rectangle, and the number of trials to perform in order to produce the estimate. Your function should use the same <span class="KeyTerm1">monte_carlo</span> function that was used above to estimate <i>π</i>. Use your <span class="KeyTerm1">estimate_integral</span> to produce an estimate of <i>π</i> by measuring the area of a unit circle.</p>
<p><a id="c3-para-0197"/>You will find it useful to have a function that returns a number chosen at random from a given range. The following random_in_range function implements this in terms of the math_random function used in section 1.2.6, which returns a nonnegative number less than 1.</p>
<p class="Sp-text-1"><a id="c3-para-0198"/><b>function</b> random_in_range(low, high) {</p>
<p class="Sp-text-1"><a id="c3-para-0199"/>    <b>const</b> range = high - low;</p>
<p class="Sp-text-1"><a id="c3-para-0200"/>    <b>return</b> low + math_random() * range;</p>
<p class="Sp-text-1"><a id="c3-para-0201"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0010"/><a id="c3-title-0011"/>Exercise 3.6</h5>
<p class="paraaftertitle"><a id="c3-para-0202"/>It is useful to be able to reset a random-number generator to produce a sequence starting from a given value. Design a new rand function that is called with an argument that is either the string "<span class="KeyTerm1">generate</span>" or the string "<span class="KeyTerm1">reset</span>" and behaves as follows: rand("<span class="KeyTerm1">generate</span>") produces a new random number; rand("<span class="KeyTerm1">reset</span>")(<i>new</i>-<i>value</i>) resets the internal state variable to the designated <i>new</i>-<i>value</i>. Thus, by resetting the state, one can generate repeatable sequences. These are very handy to have when testing and debugging programs that use random numbers.</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0011"/><span>3.1.3</span> <a id="c3-title-0012"/>The Costs of Introducing Assignment</h3>
<p class="paraaftertitle"><a id="c3-para-0203"/>As we have seen, assignment enables us to model objects that have local state. However, this advantage comes at a price. Our programming language can no longer be interpreted in terms of the substitution model of function application that we introduced in section 1.1.5. Moreover, no simple model with “nice” mathematical properties can be an adequate framework for dealing with objects and assignment in programming languages.</p>
<p><a id="c3-para-0204"/>So long as we do not use assignments, two evaluations of the same function with the same arguments will produce the same result, so that functions can be viewed as computing mathematical functions. Programming without any use of assignments, as we did throughout the first two chapters of this book, is accordingly known as <i>functional programming</i>.</p>
<p><a id="c3-para-0205"/>To understand how assignment complicates matters, consider a simplified version of the <span class="KeyTerm1">make_withdraw</span> function of section 3.1.1 that does not bother to check for an insufficient amount:</p>
<p class="Sp-text-1"><a id="c3-para-0206"/><b>function</b> make_simplified_withdraw(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-0207"/>    <b>return</b> amount =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-0208"/>               balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0209"/>               <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0210"/>           };</p>
<p class="Sp-text-1"><a id="c3-para-0211"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0212"/><b>const</b> W = make_simplified_withdraw(25);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0213"/>W(20);</p>
<p class="Sp-text-1"><a id="c3-para-0214"/><i>5</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0215"/>W(10);</p>
<p class="Sp-text-1"><a id="c3-para-0216"/><i>-5</i></p>
<p class="paracontinue"><a id="c3-para-0217"/>Compare this function with the following <span class="KeyTerm1">make_decrementer</span> function, which does not use assignment:</p>
<p class="Sp-text-1"><a id="c3-para-0218"/><b>function</b> make_decrementer(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-0219"/>   <b>return</b> amount =&gt; balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0220"/>}</p>
<p class="paracontinue"><a id="c3-para-0221"/>The function <span class="KeyTerm1">make_decrementer</span> returns a function that subtracts its input from a designated amount <span class="KeyTerm1">balance</span>, but there is no accumulated effect over successive calls, as with <span class="KeyTerm1">make_simplified_withdraw</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0222"/><b>const</b> D = make_decrementer(25);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0223"/>D(20);</p>
<p class="Sp-text-1"><a id="c3-para-0224"/><i>5</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0225"/>D(10);</p>
<p class="Sp-text-1"><a id="c3-para-0226"/><i>15</i></p>
<p class="paracontinue"><a id="c3-para-0227"/>We can use the substitution model to explain how <span class="KeyTerm1">make_decrementer</span> works. For instance, let us analyze the evaluation of the expression</p>
<p class="Sp-text-1"><a id="c3-para-0228"/>make_decrementer(25)(20)</p>
<p class="paracontinue"><a id="c3-para-0229"/>We first simplify the function expression of the application by substituting 25 for <span class="KeyTerm1">balance</span> in the body of <span class="KeyTerm1">make_decrementer</span>. This reduces the expression to</p>
<p class="Sp-text-1"><a id="c3-para-0230"/>(amount =&gt; 25 - amount)(20)</p>
<p class="paracontinue"><a id="c3-para-0231"/>Now we apply the function by substituting 20 for <span class="KeyTerm1">amount</span> in the body of the lambda expression:</p>
<p class="Sp-text-1"><a id="c3-para-0232"/>25 - 20</p>
<p class="paracontinue"><a id="c3-para-0233"/>The final answer is 5.</p>
<p><a id="c3-para-0234"/>Observe, however, what happens if we attempt a similar substitution analysis with <span class="KeyTerm1">make_simplified_withdraw</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0235"/>make_simplified_withdraw(25)(20)</p>
<p class="paracontinue"><a id="c3-para-0236"/>We first simplify the function expression by substituting 25 for <span class="KeyTerm1">balance</span> in the body of <span class="KeyTerm1">make_simplified_withdraw</span>. This reduces the expression to<a id="c3-fn-0009a"/><a href="#c3-fn-0009"><sup>9</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-0237"/>(amount =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-0238"/>    balance = 25 - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0239"/>    <b>return</b> 25;</p>
<p class="Sp-text-1"><a id="c3-para-0240"/>})(20)</p>
<p class="paracontinue"><a id="c3-para-0241"/>Now we apply the function by substituting 20 for <span class="KeyTerm1">amount</span> in the body of the lambda expression:</p>
<p class="Sp-text-1"><a id="c3-para-0242"/>balance = 25 - 20;</p>
<p class="Sp-text-1"><a id="c3-para-0243"/><b>return</b> 25;</p>
<p class="paracontinue"><a id="c3-para-0244"/>If we adhered to the substitution model, we would have to say that the meaning of the function application is to first set <span class="KeyTerm1">balance</span> to 5 and then return 25 as the value of the expression. This gets the wrong answer. In order to get the correct answer, we would have to somehow distinguish the first occurrence of <span class="KeyTerm1">balance</span> (before the effect of the assignment) from the second occurrence of <span class="KeyTerm1">balance</span> (after the effect of the assignment), and the substitution model cannot do this.</p>
<p><a id="c3-para-0245"/>The trouble here is that substitution is based ultimately on the notion that the name in our language are essentially symbols for values. This worked well for constants. But a variable, whose value can change with assignment, cannot simply be a name for a value. A variable somehow refers to a place where a value can be stored, and the value stored at this place can change. In section 3.2 we will see how environments play this role of “place” in our computational model.</p>
<section>
<h5><a id="c3-sec-0012"/><a id="c3-title-0013"/>Sameness and change</h5>
<p class="paraaftertitle"><a id="c3-para-0246"/>The issue surfacing here is more profound than the mere breakdown of a particular model of computation. As soon as we introduce change into our computational models, many notions that were previously straightforward become problematical. Consider the concept of two things being “the same.”</p>
<p><a id="c3-para-0247"/>Suppose we call <span class="KeyTerm1">make_decrementer</span> twice with the same argument to create two functions:</p>
<p class="Sp-text-1"><a id="c3-para-0248"/><b>const</b> D1 = make_decrementer(25);</p>
<p class="Sp-text-1"><a id="c3-para-0249"/><b>const</b> D2 = make_decrementer(25);</p>
<p class="paracontinue"><a id="c3-para-0250"/>Are <span class="KeyTerm1"><span class="KeyTerm1">D1</span> </span>and <span class="KeyTerm1"><span class="KeyTerm1">D2</span> </span>the same? An acceptable answer is yes, because <span class="KeyTerm1"><span class="KeyTerm1">D1</span> </span>and <span class="KeyTerm1"><span class="KeyTerm1">D2</span> </span>have the same computational behavior—each is a function that subtracts its input from 25. In fact, <span class="KeyTerm1"><span class="KeyTerm1">D1</span> </span>could be substituted for <span class="KeyTerm1"><span class="KeyTerm1">D2</span> </span>in any computation without changing the result.</p>
<p><a id="c3-para-0251"/>Contrast this with making two calls to <span class="KeyTerm1">make_simplified_withdraw</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0252"/><b>const</b> W1 = make_simplified_withdraw(25);</p>
<p class="Sp-text-1"><a id="c3-para-0253"/><b>const</b> W2 = make_simplified_withdraw(25);</p>
<p class="paracontinue"><a id="c3-para-0254"/>Are <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> the same? Surely not, because calls to <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> have distinct effects, as shown by the following sequence of interactions:</p>
<p class="Sp-text-1"><a id="c3-para-0255"/>W1(20);</p>
<p class="Sp-text-1"><a id="c3-para-0256"/><i>5</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0257"/>W1(20);</p>
<p class="Sp-text-1"><a id="c3-para-0258"/><i>-15</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0259"/>W2(20);</p>
<p class="Sp-text-1"><a id="c3-para-0260"/><i>5</i></p>
<p class="paracontinue"><a id="c3-para-0261"/>Even though <span class="KeyTerm1"><span class="KeyTerm1">W1</span> </span>and <span class="KeyTerm1"><span class="KeyTerm1">W2</span> </span>are “equal” in the sense that they are both created by evaluating the same expression, <span class="KeyTerm1">make_simplified_withdraw(25)</span>, it is not true that <span class="KeyTerm1"><span class="KeyTerm1">W1</span> </span>could be substituted for <span class="KeyTerm1"><span class="KeyTerm1">W2</span> </span>in any expression without changing the result of evaluating the expression.</p>
<p><a id="c3-para-0262"/>A language that supports the concept that “equals can be substituted for equals” in an expression without changing the value of the expression is said to be <i>referentially transparent</i>. Referential transparency is violated when we include assignment in our computer language. This makes it tricky to determine when we can simplify expressions by substituting equivalent expressions. Consequently, reasoning about programs that use assignment becomes drastically more difficult.</p>
<p><a id="c3-para-0263"/>Once we forgo referential transparency, the notion of what it means for computational objects to be “the same” becomes difficult to capture in a formal way. Indeed, the meaning of “same” in the real world that our programs model is hardly clear in itself. In general, we can determine that two apparently identical objects are indeed “the same one” only by modifying one object and then observing whether the other object has changed in the same way. But how can we tell if an object has “changed” other than by observing the “same” object twice and seeing whether some property of the object differs from one observation to the next? Thus, we cannot determine “change” without some a priori notion of “sameness,” and we cannot determine sameness without observing the effects of change.</p>
<p><a id="c3-para-0264"/>As an example of how this issue arises in programming, consider the situation where Peter and Paul have a bank account with $100 in it. There is a substantial difference between modeling this as</p>
<p class="Sp-text-1"><a id="c3-para-0265"/><b>const</b> peter_acc = make_account(100);</p>
<p class="Sp-text-1"><a id="c3-para-0266"/><b>const</b> paul_acc = make_account(100);</p>
<p class="paracontinue"><a id="c3-para-0267"/>and modeling it as</p>
<p class="Sp-text-1"><a id="c3-para-0268"/><b>const</b> peter_acc = make_account(100);</p>
<p class="Sp-text-1"><a id="c3-para-0269"/><b>const</b> paul_acc = peter_acc;</p>
<p class="paracontinue"><a id="c3-para-0270"/>In the first situation, the two bank accounts are distinct. Transactions made by Peter will not affect Paul's account, and vice versa. In the second situation, however, we have defined <span class="KeyTerm1">paul_acc</span> to be <i>the same thing</i> as <span class="KeyTerm1">peter_acc</span>. In effect, Peter and Paul now have a joint bank account, and if Peter makes a withdrawal from <span class="KeyTerm1">peter_acc</span> Paul will observe less money in <span class="KeyTerm1">paul_acc</span>. These two similar but distinct situations can cause confusion in building computational models. With the shared account, in particular, it can be especially confusing that there is one object (the bank account) that has two different names (<span class="KeyTerm1">peter_acc</span> and <span class="KeyTerm1">paul_acc</span>); if we are searching for all the places in our program where <span class="KeyTerm1">paul_acc</span> can be changed, we must remember to look also at things that change <span class="KeyTerm1">peter_acc</span>.<a id="c3-fn-0010a"/><a href="#c3-fn-0010"><sup>10</sup></a></p>
<p><a id="c3-para-0271"/>With reference to the above remarks on “sameness” and “change,” observe that if Peter and Paul could only examine their bank balances, and could not perform operations that changed the balance, then the issue of whether the two accounts are distinct would be moot. In general, so long as we never modify data objects, we can regard a compound data object to be precisely the totality of its pieces. For example, a rational number is determined by giving its numerator and its denominator. But this view is no longer valid in the presence of change, where a compound data object has an “identity” that is something different from the pieces of which it is composed. A bank account is still “the same” bank account even if we change the balance by making a withdrawal; conversely, we could have two different bank accounts with the same state information. This complication is a consequence, not of our programming language, but of our perception of a bank account as an object. We do not, for example, ordinarily regard a rational number as a changeable object with identity, such that we could change the numerator and still have “the same” rational number.</p>
</section>
<section>
<h5><a id="c3-sec-0013"/><a id="c3-title-0014"/>Pitfalls of imperative programming</h5>
<p class="paraaftertitle"><a id="c3-para-0272"/>In contrast to functional programming, programming that makes extensive use of assignment is known as <i>imperative programming</i>. In addition to raising complications about computational models, programs written in imperative style are susceptible to bugs that cannot occur in functional programs. For example, recall the iterative factorial program from section 1.2.1 (here using a conditional statement instead of a conditional expression):</p>
<p class="Sp-text-1"><a id="c3-para-0273"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c3-para-0274"/>    <b>function</b> iter(product, counter) {</p>
<p class="Sp-text-1"><a id="c3-para-0275"/>        <b>if</b> (counter &gt; n) {</p>
<p class="Sp-text-1"><a id="c3-para-0276"/>            <b>return</b> product;</p>
<p class="Sp-text-1"><a id="c3-para-0277"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0278"/>            <b>return</b> iter(counter * product,</p>
<p class="Sp-text-1"><a id="c3-para-0279"/>                        counter + 1);</p>
<p class="Sp-text-1"><a id="c3-para-0280"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-0281"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0282"/>    <b>return</b> iter(1, 1);</p>
<p class="Sp-text-1"><a id="c3-para-0283"/>}</p>
<p class="paracontinue"><a id="c3-para-0284"/>Instead of passing arguments in the internal iterative loop, we could adopt a more imperative style by using explicit assignment to update the values of the variables <span class="KeyTerm1">product</span> and <span class="KeyTerm1">counter</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0285"/><b>function</b> factorial(n) { </p>
<p class="Sp-text-1"><a id="c3-para-0286"/>    <b>let</b> product = 1;</p>
<p class="Sp-text-1"><a id="c3-para-0287"/>    <b>let</b> counter = 1;</p>
<p class="Sp-text-1"><a id="c3-para-0288"/>    <b>function</b> iter() {</p>
<p class="Sp-text-1"><a id="c3-para-0289"/>        <b>if</b> (counter &gt; n) {</p>
<p class="Sp-text-1"><a id="c3-para-0290"/>            <b>return</b> product;</p>
<p class="Sp-text-1"><a id="c3-para-0291"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0292"/>            product = counter * product;</p>
<p class="Sp-text-1"><a id="c3-para-0293"/>            counter = counter + 1;</p>
<p class="Sp-text-1"><a id="c3-para-0294"/>            <b>return</b> iter();</p>
<p class="Sp-text-1"><a id="c3-para-0295"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-0296"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0297"/>    <b>return</b> iter();</p>
<p class="Sp-text-1"><a id="c3-para-0298"/>}</p>
<p class="paracontinue"><a id="c3-para-0299"/>This does not change the results produced by the program, but it does introduce a subtle trap. How do we decide the order of the assignments? As it happens, the program is correct as written. But writing the assignments in the opposite order</p>
<p class="Sp-text-1"><a id="c3-para-0300"/>counter = counter + 1;</p>
<p class="Sp-text-1"><a id="c3-para-0301"/>product = counter * product;</p>
<p class="paracontinue"><a id="c3-para-0302"/>would have produced a different, incorrect result. In general, programming with assignment forces us to carefully consider the relative orders of the assignments to make sure that each statement is using the correct version of the variables that have been changed. This issue simply does not arise in functional programs.<a id="c3-fn-0011a"/><a href="#c3-fn-0011"><sup>11</sup></a></p>
<p><a id="c3-para-0303"/>The complexity of imperative programs becomes even worse if we consider applications in which several processes execute concurrently. We will return to this in section 3.4. First, however, we will address the issue of providing a computational model for expressions that involve assignment, and explore the uses of objects with local state in designing simulations.</p>
</section>
<section>
<h5><a id="c3-sec-0014"/><a id="c3-title-0015"/>Exercise 3.7</h5>
<p class="paraaftertitle"><a id="c3-para-0304"/>Consider the bank account objects created by <span class="KeyTerm1">make_account</span>, with the password modification described in exercise 3.3. Suppose that our banking system requires the ability to make joint accounts. Define a function <span class="KeyTerm1">make_joint</span> that accomplishes this. The function <span class="KeyTerm1">make_joint</span> should take three arguments. The first is a password-protected account. The second argument must match the password with which the account was defined in order for the <span class="KeyTerm1">make_joint</span> operation to proceed. The third argument is a new password. The function <span class="KeyTerm1">make_joint</span> is to create an additional access to the original account using the new password. For example, if <span class="KeyTerm1">peter_acc</span> is a bank account with password <span class="KeyTerm1">"open sesame"</span>, then</p>
<p class="Sp-text-1"><a id="c3-para-0305"/><b>const</b> paul_acc = make_joint(peter_acc, "open sesame", "rosebud");</p>
<p class="paracontinue"><a id="c3-para-0306"/>will allow one to make transactions on <span class="KeyTerm1">peter_acc</span> using the name <span class="KeyTerm1">paul_acc</span> and the password <span class="KeyTerm1">"rosebud"</span>. You may wish to modify your solution to exercise 3.3 to accommodate this new feature.</p>
</section>
<section>
<h5><a id="c3-sec-0015"/><a id="c3-title-0016"/>Exercise 3.8</h5>
<p class="paraaftertitle"><a id="c3-para-0307"/>When we defined the evaluation model in section 1.1.3, we said that the first step in evaluating an expression is to evaluate its subexpressions. But we never specified the order in which the subexpressions should be evaluated (e.g., left to right or right to left). When we introduce assignment, the order in which the operands of an operator combination are evaluated can make a difference to the result. Define a simple function <span class="KeyTerm1">f</span> such that evaluating <span class="KeyTerm1">f(0) + f(1)</span> will return 0 if the operands of <span class="KeyTerm1">+</span> are evaluated from left to right but will return 1 if the operands are evaluated from right to left.</p>
</section>
</section>
</section>
<section>
<h2><a id="c3-sec-0016"/><span>3.2</span> <a id="c3-title-0017"/>The Environment Model of Evaluation</h2>
<p class="paraaftertitle"><a id="c3-para-0308"/>When we introduced compound functions in chapter 1, we used the substitution model of evaluation (section 1.1.5) to define what is meant by applying a function to arguments:</p>
<ul style="list-style-type:disc">
<li>To apply a compound function to arguments, evaluate the return expression of the function (more generally, the body) with each parameter replaced by the corresponding argument.</li>
</ul>

<p><a id="c3-para-0310"/>Once we admit assignment into our programming language, such a definition is no longer adequate. In particular, section 3.1.3 argued that, in the presence of assignment, a name cannot be considered to be merely representing a value. Rather, a name must somehow designate a “place” in which values can be stored. In our new model of evaluation, these places will be maintained in structures called <i>environments</i>.</p>
<p><a id="c3-para-0311"/>An environment is a sequence of <i>frames</i>. Each frame is a table (possibly empty) of <i>bindings</i>, which associate names with their corresponding values. (A single frame may contain at most one binding for any name.) Each frame also has a pointer to its <i>enclosing environment</i>, unless, for the purposes of discussion, the frame is considered to be <i>global</i>. The <i>value of a name</i> with respect to an environment is the value given by the binding of the name in the first frame in the environment that contains a binding for that name. If no frame in the sequence specifies a binding for the name, then the name is said to be <i>unbound</i> in the environment.</p>
<p><a id="c3-para-0312"/><a id="c3-fig-0001a"/><a href="#c3-fig-0001">Figure 3.1</a> shows a simple environment structure consisting of three frames, labeled I, II, and III. In the diagram, A, B, C, and D are pointers to environments. C and D point to the same environment. The names <span class="KeyTerm1">z</span> and <span class="KeyTerm1">x</span> are bound in frame II, while <span class="KeyTerm1">y</span> and <span class="KeyTerm1">x</span> are bound in frame I. The value of <span class="KeyTerm1">x</span> in environment D is 3. The value of <span class="KeyTerm1">x</span> with respect to environment B is also 3. This is determined as follows: We examine the first frame in the sequence (frame III) and do not find a binding for <span class="KeyTerm1">x</span>, so we proceed to the enclosing environment D and find the binding in frame I. On the other hand, the value of <span class="KeyTerm1">x</span> in environment A is 7, because the first frame in the sequence (frame II) contains a binding of <span class="KeyTerm1">x</span> to 7. With respect to environment A, the binding of <span class="KeyTerm1">x</span> to 7 in frame II is said to <i>shadow</i> the binding of <span class="KeyTerm1">x</span> to 3 in frame I.</p>
<figure id="c3-fig-0001"><img alt="c3-fig-0001.jpg" src="../images/c3-fig-0001.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0001a">Figure 3.1</a></span> <a id="c3-para-0313"/>A simple environment structure.</p></figcaption></figure>
<p><a id="c3-para-0314"/>The environment is crucial to the evaluation process, because it determines the context in which an expression should be evaluated. Indeed, one could say that expressions in a programming language do not, in themselves, have any meaning. Rather, an expression acquires a meaning only with respect to some environment in which it is evaluated. Even the interpretation of an expression as straightforward as <span class="KeyTerm1">display(1)</span> depends on an understanding that one is operating in a context in which the name <span class="KeyTerm1">display</span> refers to the primitive function that displays a value. Thus, in our model of evaluation we will always speak of evaluating an expression with respect to some environment. To describe interactions with the interpreter, we will suppose that there is a global environment, consisting of a single frame (with no enclosing environment) that includes values for the names associated with the primitive functions. For example, the idea that <span class="KeyTerm1">display</span> is the name for the primitive display function is captured by saying that the name <span class="KeyTerm1">display</span> is bound in the global environment to the primitive display function.</p>
<p><a id="c3-para-0315"/>Before we evaluate a program, we extend the global environment with a new frame, the <i>program frame</i>, resulting in the <i>program environment</i>. We will add the names that are declared at the top level of the program, outside of any block, to this frame. The given program is then evaluated with respect to the program environment.</p>
<section>
<h3><a id="c3-sec-0017"/><span>3.2.1</span> <a id="c3-title-0018"/>The Rules for Evaluation</h3>
<p class="paraaftertitle"><a id="c3-para-0316"/>The overall specification of how the interpreter evaluates a function application remains the same as when we first introduced it in section 1.1.4:</p>
<ul style="list-style-type:disc">
<li>To evaluate an application:<ol class="BS_NumberList1">
<li><a id="c3-li-0003"/><span>1. </span>Evaluate the subexpressions of the application.<a id="c3-fn-0012a"/><a href="#c3-fn-0012"><sup>12</sup></a></li>
<li><a id="c3-li-0004"/><span>2. </span>Apply the value of the function subexpression to the values of the argument subexpressions.</li>
</ol></li>
</ul>

<p class="paracontinue"><a id="c3-para-0320"/>The environment model of evaluation replaces the substitution model in specifying what it means to apply a compound function to arguments.</p>
<p><a id="c3-para-0321"/>In the environment model of evaluation, a function is always a pair consisting of some code and a pointer to an environment. Functions are created in one way only: by evaluating a lambda expression. This produces a function whose code is obtained from the text of the lambda expression and whose environment is the environment in which the lambda expression was evaluated to produce the function. For example, consider the function declaration</p>
<p class="Sp-text-1"><a id="c3-para-0322"/><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c3-para-0323"/>    <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c3-para-0324"/>}</p>
<p class="paracontinue"><a id="c3-para-0325"/>evaluated in the program environment. The function declaration syntax is equivalent to an underlying implicit lambda expression. It would have been equivalent to have used<a id="c3-fn-0013a"/><a href="#c3-fn-0013"><sup>13</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-0326"/><b>const</b> square = x =&gt; x * x;</p>
<p class="paracontinue"><a id="c3-para-0327"/>which evaluates <span class="KeyTerm1">x =&gt; x * x</span> and binds <span class="KeyTerm1">square</span> to the resulting value, all in the program environment.</p>
<p><a id="c3-para-0328"/><a id="c3-fig-0002a"/><a href="#c3-fig-0002">Figure 3.2</a> shows the result of evaluating this declaration statement. The global environment encloses the program environment. To reduce clutter, after this figure we will not display the global environment (as it is always the same), but we are reminded of its existence by the pointer from the program environment upward. The function object is a pair whose code specifies that the function has one parameter, namely <span class="KeyTerm1">x</span>, and a function body <span class="KeyTerm1"><b>return</b> x * x;</span>. The environment part of the function is a pointer to the program environment, since that is the environment in which the lambda expression was evaluated to produce the function. A new binding, which associates the function object with the name <span class="KeyTerm1">square</span>, has been added to the program frame.</p>
<figure id="c3-fig-0002"><img alt="c3-fig-0002.jpg" src="../images/c3-fig-0002.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0002a">Figure 3.2</a></span> <a id="c3-para-0329"/>Environment structure produced by evaluating <span class="KeyTerm1"><b>function</b> square(x) { <b>return</b> x * x; }</span> in the program environment.</p></figcaption></figure>
<p><a id="c3-para-0330"/>In general, <span class="KeyTerm1"><b>const</b></span>, <span class="KeyTerm1"><b>function</b></span>, and <span class="KeyTerm1"><b>let</b></span> add bindings to frames. Assignment is forbidden on constants, so our environment model needs to distinguish names that refer to constants from names that refer to variables. We indicate that a name is a constant by writing an equal sign after the colon that follows the name. We consider function declarations as equivalent to constant declarations;<a id="c3-fn-0014a"/><a href="#c3-fn-0014"><sup>14</sup></a> observe the equal signs after the colons in <a href="#c3-fig-0002">figure 3.2</a>.</p>
<p><a id="c3-para-0331"/>Now that we have seen how functions are created, we can describe how functions are applied. The environment model specifies: To apply a function to arguments, create a new environment containing a frame that binds the parameters to the values of the arguments. The enclosing environment of this frame is the environment specified by the function. Now, within this new environment, evaluate the function body.</p>
<p><a id="c3-para-0332"/>To show how this rule is followed, <a id="c3-fig-0003a"/><a href="#c3-fig-0003">figure 3.3</a> illustrates the environment structure created by evaluating the expression <span class="KeyTerm1">square(5)</span> in the program environment, where <span class="KeyTerm1">square</span> is the function generated in <a href="#c3-fig-0002">figure 3.2</a>. Applying the function results in the creation of a new environment, labeled E1 in the figure, that begins with a frame in which <span class="KeyTerm1">x</span>, the parameter for the function, is bound to the argument 5. Note that name <span class="KeyTerm1">x</span> in environment E1 is followed by a colon with no equal sign, which indicates that the parameter <span class="KeyTerm1">x</span> is treated as a variable.<a id="c3-fn-0015a"/><a href="#c3-fn-0015"><sup>15</sup></a> The pointer leading upward from this frame shows that the frame's enclosing environment is the program environment. The program environment is chosen here, because this is the environment that is indicated as part of the <span class="KeyTerm1">square</span> function object. Within E1, we evaluate the body of the function, <span class="KeyTerm1"><b>return</b> x * x;</span>. Since the value of <span class="KeyTerm1">x</span> in E1 is 5, the result is <span class="KeyTerm1">5 * 5</span>, or 25.</p>
<figure id="c3-fig-0003"><img alt="c3-fig-0003.jpg" src="../images/c3-fig-0003.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0003a">Figure 3.3</a></span> <a id="c3-para-0333"/>Environment created by evaluating <span class="KeyTerm1">square(5)</span> in the program environment.</p></figcaption></figure>
<p><a id="c3-para-0334"/>The environment model of function application can be summarized by two rules:</p>
<ul style="list-style-type:disc">
<li>A function object is applied to a set of arguments by constructing a frame, binding the parameters of the function to the arguments of the call, and then evaluating the body of the function in the context of the new environment constructed. The new frame has as its enclosing environment the environment part of the function object being applied. The result of the application is the result of evaluating the return expression of the first return statement encountered while evaluating the function body.</li>
<li>A function is created by evaluating a lambda expression relative to a given environment. The resulting function object is a pair consisting of the text of the lambda expression and a pointer to the environment in which the function was created.</li>
</ul>

<p><a id="c3-para-0337"/>Finally, we specify the behavior of assignment, the operation that forced us to introduce the environment model in the first place. Evaluating the expression <i>name</i> <span class="KeyTerm1">=</span> <i>value</i> in some environment locates the binding of the name in the environment. That is, one finds the first frame in the environment that contains a binding for the name. If the binding is a variable binding—indicated in the frame by just <span class="KeyTerm1">:</span> after the name—that binding is changed to reflect the new value of the variable. Otherwise, if the binding in the frame is a constant binding—indicated in the frame by <span class="KeyTerm1">:=</span> after the name—the assignment signals an <span class="KeyTerm1">"assignment to constant"</span> error. If the name is unbound in the environment, then the assignment signals a <span class="KeyTerm1">"variable undeclared"</span> error.</p>
<p><a id="c3-para-0338"/>These evaluation rules, though considerably more complex than the substitution model, are still reasonably straightforward. Moreover, the evaluation model, though abstract, provides a correct description of how the interpreter evaluates expressions. In chapter 4 we shall see how this model can serve as a blueprint for implementing a working interpreter. The following sections elaborate the details of the model by analyzing some illustrative programs.</p>
</section>
<section>
<h3><a id="c3-sec-0018"/><span>3.2.2</span> <a id="c3-title-0019"/>Applying Simple Functions</h3>
<p class="paraaftertitle"><a id="c3-para-0339"/>When we introduced the substitution model in section 1.1.5 we showed how the application <span class="KeyTerm1">f(5)</span> evaluates to 136, given the following function declarations:</p>
<p class="Sp-text-1"><a id="c3-para-0340"/><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c3-para-0341"/>    <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c3-para-0342"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0343"/><b>function</b> sum_of_squares(x, y) {</p>
<p class="Sp-text-1"><a id="c3-para-0344"/>    <b>return</b> square(x) + square(y);</p>
<p class="Sp-text-1"><a id="c3-para-0345"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0346"/><b>function</b> f(a) {</p>
<p class="Sp-text-1"><a id="c3-para-0347"/>    <b>return</b> sum_of_squares(a + 1, a * 2);</p>
<p class="Sp-text-1"><a id="c3-para-0348"/>}</p>
<p class="paracontinue"><a id="c3-para-0349"/>We can analyze the same example using the environment model. <a id="c3-fig-0004a"/><a href="#c3-fig-0004">Figure 3.4</a> shows the three function objects created by evaluating the definitions of <span class="KeyTerm1">f</span>, <span class="KeyTerm1">square</span>, and <span class="KeyTerm1">sum_of_squares</span> in the program environment. Each function object consists of some code, together with a pointer to the program environment.</p>
<figure id="c3-fig-0004"><img alt="c3-fig-0004.jpg" src="../images/c3-fig-0004.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0004a">Figure 3.4</a></span> <a id="c3-para-0350"/>Function objects in the program frame.</p></figcaption></figure>
<p><a id="c3-para-0351"/>In <a id="c3-fig-0005a"/><a href="#c3-fig-0005">figure 3.5</a> we see the environment structure created by evaluating the expression <span class="KeyTerm1">f(5)</span>. The call to <span class="KeyTerm1">f</span> creates a new environment, E1, beginning with a frame in which <span class="KeyTerm1">a</span>, the parameter of <span class="KeyTerm1">f</span>, is bound to the argument 5. In E1, we evaluate the body of <span class="KeyTerm1">f</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0353"/><b>return</b> sum_of_squares(a + 1, a * 2);</p>
<figure id="c3-fig-0005"><img alt="c3-fig-0005.jpg" src="../images/c3-fig-0005.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0005a">Figure 3.5</a></span> <a id="c3-para-0352"/>Environments created by evaluating <span class="KeyTerm1">f(5)</span> using the functions in <a href="#c3-fig-0004">figure 3.4</a>.</p></figcaption></figure>
<p class="paracontinue"><a id="c3-para-0354"/>To evaluate the return statement, we first evaluate the subexpressions of the return expression. The first subexpression, <span class="KeyTerm1">sum_of_squares</span>, has a value that is a function object. (Notice how this value is found: We first look in the first frame of E1, which contains no binding for <span class="KeyTerm1">sum_of_squares</span>. Then we proceed to the enclosing environment, i.e., the program environment, and find the binding shown in <a href="#c3-fig-0004">figure 3.4</a>.) The other two subexpressions are evaluated by applying the primitive operations <span class="KeyTerm1">+</span> and <span class="KeyTerm1">*</span> to evaluate the two combinations <span class="KeyTerm1">a + 1</span> and <span class="KeyTerm1">a * 2</span> to obtain 6 and 10, respectively.</p>
<p><a id="c3-para-0355"/>Now we apply the function object <span class="KeyTerm1">sum_of_squares</span> to the arguments 6 and 10. This results in a new environment, E2, in which the parameters <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> are bound to the arguments. Within E2 we evaluate the statement</p>
<p class="Sp-text-1"><a id="c3-para-0356"/><b>return</b> square(x) + square(y);</p>
<p class="paracontinue"><a id="c3-para-0357"/>This leads us to evaluate <span class="KeyTerm1">square(x)</span>, where <span class="KeyTerm1">square</span> is found in the program frame and <span class="KeyTerm1">x</span> is 6. Once again, we set up a new environment, E3, in which <span class="KeyTerm1">x</span> is bound to 6, and within this we evaluate the body of <span class="KeyTerm1">square</span>, which is <span class="KeyTerm1"><b>return</b> x * x;</span>. Also as part of applying <span class="KeyTerm1">sum_of_squares</span>, we must evaluate the subexpression <span class="KeyTerm1">square(y)</span>, where <span class="KeyTerm1">y</span> is 10. This second call to <span class="KeyTerm1">square</span> creates another environment, E4, in which <span class="KeyTerm1">x</span>, the parameter of <span class="KeyTerm1">square</span>, is bound to 10. And within E4 we must evaluate <span class="KeyTerm1"><b>return</b> x * x;</span>.</p>
<p><a id="c3-para-0358"/>The important point to observe is that each call to <span class="KeyTerm1">square</span> creates a new environment containing a binding for <span class="KeyTerm1">x</span>. We can see here how the different frames serve to keep separate the different local variables all named <span class="KeyTerm1">x</span>. Notice that each frame created by <span class="KeyTerm1">square</span> points to the program environment, since this is the environment indicated by the <span class="KeyTerm1">square</span> function object.</p>
<p><a id="c3-para-0359"/>After the subexpressions are evaluated, the results are returned. The values generated by the two calls to <span class="KeyTerm1">square</span> are added by <span class="KeyTerm1">sum_of_squares</span>, and this result is returned by <span class="KeyTerm1">f</span>. Since our focus here is on the environment structures, we will not dwell on how these returned values are passed from call to call; however, this is also an important aspect of the evaluation process, and we will return to it in detail in chapter 5.</p>
<section>
<h5><a id="c3-sec-0019"/><a id="c3-title-0020"/>Exercise 3.9</h5>
<p class="paraaftertitle"><a id="c3-para-0360"/>In section 1.2.1 we used the substitution model to analyze two functions for computing factorials, a recursive version</p>
<p class="Sp-text-1"><a id="c3-para-0361"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c3-para-0362"/>    <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c3-para-0363"/>           ? 1</p>
<p class="Sp-text-1"><a id="c3-para-0364"/>           : n * factorial(n - 1);</p>
<p class="Sp-text-1"><a id="c3-para-0365"/>}</p>
<p class="paracontinue"><a id="c3-para-0366"/>and an iterative version</p>
<p class="Sp-text-1"><a id="c3-para-0367"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c3-para-0368"/>    <b>return</b> fact_iter(1, 1, n);</p>
<p class="Sp-text-1"><a id="c3-para-0369"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0370"/><b>function</b> fact_iter(product, counter, max_count) {</p>
<p class="Sp-text-1"><a id="c3-para-0371"/>    <b>return</b> counter &gt; max_count</p>
<p class="Sp-text-1"><a id="c3-para-0372"/>           ? product</p>
<p class="Sp-text-1"><a id="c3-para-0373"/>           : fact_iter(counter * product,</p>
<p class="Sp-text-1"><a id="c3-para-0374"/>                       counter + 1,</p>
<p class="Sp-text-1"><a id="c3-para-0375"/>                       max_count);</p>
<p class="Sp-text-1"><a id="c3-para-0376"/>}</p>
<p class="paracontinue"><a id="c3-para-0377"/>Show the environment structures created by evaluating <span class="KeyTerm1">factorial(6)</span> using each version of the <span class="KeyTerm1">factorial</span> function.<a id="c3-fn-0016a"/><a href="#c3-fn-0016"><sup>16</sup></a></p>
</section>
</section>
<section>
<h3><a id="c3-sec-0020"/><span>3.2.3</span> <a id="c3-title-0021"/>Frames as the Repository of Local State</h3>
<p class="paraaftertitle"><a id="c3-para-0378"/>We can turn to the environment model to see how functions and assignment can be used to represent objects with local state. As an example, consider the “withdrawal processor” from section 3.1.1 created by calling the function</p>
<p class="Sp-text-1"><a id="c3-para-0379"/><b>function</b> make_withdraw(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-0380"/>    <b>return</b> amount =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-0381"/>               <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0382"/>                   balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0383"/>                   <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0384"/>               } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0385"/>                   <b>return</b> "insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-0386"/>               }</p>
<p class="Sp-text-1"><a id="c3-para-0387"/>           };</p>
<p class="Sp-text-1"><a id="c3-para-0388"/>}</p>
<p class="paracontinue"><a id="c3-para-0389"/>Let us describe the evaluation of</p>
<p class="Sp-text-1"><a id="c3-para-0390"/><b>const</b> W1 = make_withdraw(100); </p>
<p class="paracontinue"><a id="c3-para-0391"/>followed by</p>
<p class="Sp-text-1"><a id="c3-para-0392"/>W1(50);</p>
<p class="Sp-text-1"><a id="c3-para-0393"/><i>50</i></p>
<p class="paracontinue"><a id="c3-para-0394"/><a id="c3-fig-0006a"/><a href="#c3-fig-0006">Figure 3.6</a> shows the result of declaring the <span class="KeyTerm1">make_withdraw</span> function in the program environment. This produces a function object that contains a pointer to the program environment. So far, this is no different from the examples we have already seen, except that the return expression in the body of the function is itself a lambda expression.</p>
<figure id="c3-fig-0006"><img alt="c3-fig-0006.jpg" src="../images/c3-fig-0006.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0006a">Figure 3.6</a></span> <a id="c3-para-0395"/>Result of defining <span class="KeyTerm1">make_withdraw</span> in the program environment.</p></figcaption></figure>
<p><a id="c3-para-0396"/>The interesting part of the computation happens when we apply the function <span class="KeyTerm1">make_withdraw</span> to an argument:</p>
<p class="Sp-text-1"><a id="c3-para-0397"/><b>const</b> W1 = make_withdraw(100);</p>
<p class="paracontinue"><a id="c3-para-0398"/>We begin, as usual, by setting up an environment E1 in which the parameter <span class="KeyTerm1">balance</span> is bound to the argument 100. Within this environment, we evaluate the body of <span class="KeyTerm1">make_withdraw</span>, namely the return statement whose return expression is a lambda expression. The evaluation of this lambda expression constructs a new function object, whose code is as specified by the lambda expression and whose environment is E1, the environment in which the lambda expression was evaluated to produce the function. The resulting function object is the value returned by the call to <span class="KeyTerm1">make_withdraw</span>. This is bound to <span class="KeyTerm1">W1</span> in the program environment, since the constant declaration itself is being evaluated in the program environment. <a id="c3-fig-0007a"/><a href="#c3-fig-0007">Figure 3.7</a> shows the resulting environment structure.</p>
<figure id="c3-fig-0007"><img alt="c3-fig-0007.jpg" src="../images/c3-fig-0007.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0007a">Figure 3.7</a></span> <a id="c3-para-0399"/>Result of evaluating <span class="KeyTerm1"><b>const</b> W1 = make_withdraw(100);</span>.</p></figcaption></figure>
<p><a id="c3-para-0400"/>Now we can analyze what happens when <span class="KeyTerm1">W1</span> is applied to an argument:</p>
<p class="Sp-text-1"><a id="c3-para-0401"/>W1(50);</p>
<p class="Sp-text-1"><a id="c3-para-0402"/><i>50</i></p>
<p class="paracontinue"><a id="c3-para-0403"/>We begin by constructing a frame in which <span class="KeyTerm1">amount</span>, the parameter of <span class="KeyTerm1">W1</span>, is bound to the argument 50. The crucial point to observe is that this frame has as its enclosing environment not the program environment, but rather the environment E1, because this is the environment that is specified by the <span class="KeyTerm1">W1</span> function object. Within this new environment, we evaluate the body of the function:</p>
<p class="Sp-text-1"><a id="c3-para-0404"/><b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0405"/>    balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0406"/>    <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0407"/>} <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0408"/>    <b>return</b> "insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-0409"/>}</p>
<p class="paracontinue"><a id="c3-para-0410"/>The resulting environment structure is shown in <a id="c3-fig-0008a"/><a href="#c3-fig-0008">figure 3.8</a>. The expression being evaluated references both <span class="KeyTerm1">amount</span> and <span class="KeyTerm1">balance</span>. The variable <span class="KeyTerm1">amount</span> will be found in the first frame in the environment, and <span class="KeyTerm1">balance</span> will be found by following the enclosing-environment pointer to E1.</p>
<figure id="c3-fig-0008"><img alt="c3-fig-0008.jpg" src="../images/c3-fig-0008.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0008a">Figure 3.8</a></span> <a id="c3-para-0411"/>Environments created by applying the function object <span class="KeyTerm1">W1</span>.</p></figcaption></figure>
<p><a id="c3-para-0412"/>When the assignment is executed, the binding of <span class="KeyTerm1">balance</span> in E1 is changed. At the completion of the call to <span class="KeyTerm1"><span class="KeyTerm1">W1</span></span>, <span class="KeyTerm1">balance</span> is 50, and the frame that contains <span class="KeyTerm1">balance</span> is still pointed to by the function object <span class="KeyTerm1"><span class="KeyTerm1">W1</span></span>. The frame that binds <span class="KeyTerm1">amount</span> (in which we executed the code that changed <span class="KeyTerm1">balance</span>) is no longer relevant, since the function call that constructed it has terminated, and there are no pointers to that frame from other parts of the environment. The next time <span class="KeyTerm1"><span class="KeyTerm1">W1</span> </span>is called, this will build a new frame that binds <span class="KeyTerm1">amount</span> and whose enclosing environment is E1. We see that E1 serves as the “place” that holds the local state variable for the function object <span class="KeyTerm1"><span class="KeyTerm1">W1</span></span>. <a id="c3-fig-0009a"/><a href="#c3-fig-0009">Figure 3.9</a> shows the situation after the call to <span class="KeyTerm1"><span class="KeyTerm1">W1</span></span>.</p>
<figure id="c3-fig-0009"><img alt="c3-fig-0009.jpg" src="../images/c3-fig-0009.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0009a">Figure 3.9</a></span> <a id="c3-para-0413"/>Environments after the call to <span class="KeyTerm1">W1</span>.</p></figcaption></figure>
<p><a id="c3-para-0414"/>Observe what happens when we create a second “withdraw” object by making another call to <span class="KeyTerm1">make_withdraw</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0415"/><b>const</b> W2 = make_withdraw(100);</p>
<p class="paracontinue"><a id="c3-para-0416"/>This produces the environment structure of <a id="c3-fig-0010a"/><a href="#c3-fig-0010">figure 3.10</a>, which shows that <span class="KeyTerm1">W2</span> is a function object, that is, a pair with some code and an environment. The environment E2 for <span class="KeyTerm1">W2</span> was created by the call to <span class="KeyTerm1">make_withdraw</span>. It contains a frame with its own local binding for <span class="KeyTerm1">balance</span>. On the other hand, <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> have the same code: the code specified by the lambda expression in the body of <span class="KeyTerm1">make_withdraw</span>.<a id="c3-fn-0017a"/><a href="#c3-fn-0017"><sup>17</sup></a> We see here why <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> behave as independent objects. Calls to <span class="KeyTerm1">W1</span> reference the state variable <span class="KeyTerm1">balance</span> stored in E1, whereas calls to <span class="KeyTerm1">W2</span> reference the <span class="KeyTerm1">balance</span> stored in E2. Thus, changes to the local state of one object do not affect the other object.</p>
<figure id="c3-fig-0010"><img alt="c3-fig-0010.jpg" src="../images/c3-fig-0010.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0010a">Figure 3.10</a></span> <a id="c3-para-0417"/>Using <span class="KeyTerm1"><b>const</b> W2 = make_withdraw(100);</span> to create a second object.</p></figcaption></figure>
<section>
<h5><a id="c3-sec-0021"/><a id="c3-title-0022"/>Exercise 3.10</h5>
<p class="paraaftertitle"><a id="c3-para-0418"/>In the <span class="KeyTerm1">make_withdraw</span> function the local variable <span class="KeyTerm1">balance</span> is created as a parameter of <span class="KeyTerm1">make_withdraw</span>. We could also create the local state variable separately, using what we might call an <i>immediately invoked lambda expression</i> as follows:</p>
<p class="Sp-text-1"><a id="c3-para-0419"/><b>function</b> make_withdraw(initial_amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0420"/>    <b>return</b> (balance =&gt;</p>
<p class="Sp-text-1"><a id="c3-para-0421"/>              amount =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-0422"/>                  <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0423"/>                      balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0424"/>                      <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0425"/>                   } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0426"/>                      <b>return</b> "insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-0427"/>                   }</p>
<p class="Sp-text-1"><a id="c3-para-0428"/>              })(initial_amount);</p>
<p class="Sp-text-1"><a id="c3-para-0429"/>}</p>
<p class="paracontinue"><a id="c3-para-0430"/>The outer lambda expression is invoked immediately after it is evaluated. Its only purpose is to create a local variable <span class="KeyTerm1">balance</span> and initialize it to <span class="KeyTerm1">initial_amount</span>. Use the environment model to analyze this alternate version of <span class="KeyTerm1">make_withdraw</span>, drawing figures like the ones above to illustrate the interactions</p>
<p class="Sp-text-1"><a id="c3-para-0431"/><b>const</b> W1 = make_withdraw(100);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0432"/>W1(50);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0433"/><b>const</b> W2 = make_withdraw(100);</p>
<p class="paracontinue"><a id="c3-para-0434"/>Show that the two versions of <span class="KeyTerm1">make_withdraw</span> create objects with the same behavior. How do the environment structures differ for the two versions?</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0022"/><span>3.2.4</span> <a id="c3-title-0023"/>Internal Declarations</h3>
<p class="paraaftertitle"><a id="c3-para-0435"/>In this section we handle the evaluation of function bodies or other blocks (such as the branches of conditional statements) that contain declarations. Each block opens a new scope for names declared in the block. In order to evaluate a block in a given environment, we extend that environment by a new frame that contains all names declared directly (that is, outside of nested blocks) in the body of the block and then evaluate the body in the newly constructed environment.</p>
<p><a id="c3-para-0436"/>Section 1.1.8 introduced the idea that functions can have internal declarations, thus leading to a block structure as in the following function to compute square roots:</p>
<p class="Sp-text-1"><a id="c3-para-0437"/><b>function</b> sqrt(x) {</p>
<p class="Sp-text-1"><a id="c3-para-0438"/>   <b>function</b> is_good_enough(guess) {</p>
<p class="Sp-text-1"><a id="c3-para-0439"/>      <b>return</b> abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c3-para-0440"/>   }</p>
<p class="Sp-text-1"><a id="c3-para-0441"/>   <b>function</b> improve(guess) {</p>
<p class="Sp-text-1"><a id="c3-para-0442"/>      <b>return</b> average(guess, x / guess);</p>
<p class="Sp-text-1"><a id="c3-para-0443"/>   }</p>
<p class="Sp-text-1"><a id="c3-para-0444"/>   <b>function</b> sqrt_iter(guess){</p>
<p class="Sp-text-1"><a id="c3-para-0445"/>      <b>return</b> is_good_enough(guess)</p>
<p class="Sp-text-1"><a id="c3-para-0446"/>             ? guess</p>
<p class="Sp-text-1"><a id="c3-para-0447"/>             : sqrt_iter(improve(guess));</p>
<p class="Sp-text-1"><a id="c3-para-0448"/>   }</p>
<p class="Sp-text-1"><a id="c3-para-0449"/>   <b>return</b> sqrt_iter(1);</p>
<p class="Sp-text-1"><a id="c3-para-0450"/>}</p>
<p class="paracontinue"><a id="c3-para-0451"/>Now we can use the environment model to see why these internal declarations behave as desired. <a id="c3-fig-0011a"/><a href="#c3-fig-0011">Figure 3.11</a> shows the point in the evaluation of the expression <span class="KeyTerm1">sqrt(2)</span> where the internal function <span class="KeyTerm1">is_good_enough</span> has been called for the first time with <span class="KeyTerm1">guess</span> equal to 1.</p>
<figure id="c3-fig-0011"><img alt="c3-fig-0011.jpg" src="../images/c3-fig-0011.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0011a">Figure 3.11</a></span> <a id="c3-para-0452"/>The <span class="KeyTerm1">sqrt</span> function with internal declarations.</p></figcaption></figure>
<p><a id="c3-para-0453"/>Observe the structure of the environment. The name <span class="KeyTerm1">sqrt</span> is bound in the program environment to a function object whose associated environment is the program environment. When <span class="KeyTerm1">sqrt</span> was called, a new environment, E1, was formed, subordinate to the program environment, in which the parameter <span class="KeyTerm1">x</span> is bound to 2. The body of <span class="KeyTerm1">sqrt</span> was then evaluated in E1. That body is a block with local function declarations and therefore E1 was extended with a new frame for those declarations, resulting in the new environment E2. The body of the block was then evaluated in E2. Since the first statement in the body is</p>
<p class="Sp-text-1"><a id="c3-para-0454"/><b>function</b> is_good_enough(guess) {</p>
<p class="Sp-text-1"><a id="c3-para-0455"/>    <b>return</b> abs(square(guess) - x) &lt; 0.001;</p>
<p class="Sp-text-1"><a id="c3-para-0456"/>}</p>
<p class="paracontinue"><a id="c3-para-0457"/>evaluating this declaration created the function <span class="KeyTerm1">is_good_enough</span> in the environment E2. To be more precise, the name <span class="KeyTerm1">is_good_enough</span> in the first frame of E2 was bound to a function object whose associated environment is E2. Similarly, <span class="KeyTerm1">improve</span> and <span class="KeyTerm1">sqrt_iter</span> were defined as functions in E2. For conciseness, <a href="#c3-fig-0011">figure 3.11</a> shows only the function object for <span class="KeyTerm1">is_good_enough</span>.</p>
<p><a id="c3-para-0458"/>After the local functions were defined, the expression <span class="KeyTerm1">sqrt_iter(1)</span> was evaluated, still in environment E2. So the function object bound to <span class="KeyTerm1">sqrt_iter</span> in E2 was called with 1 as an argument. This created an environment E3 in which <span class="KeyTerm1">guess</span>, the parameter of <span class="KeyTerm1">sqrt_iter</span>, is bound to 1. The function <span class="KeyTerm1">sqrt_iter</span> in turn called <span class="KeyTerm1">is_good_enough</span> with the value of <span class="KeyTerm1">guess</span> (from E3) as the argument for <span class="KeyTerm1">is_good_ enough</span>. This set up another environment, E4, in which <span class="KeyTerm1">guess</span> (the parameter of <span class="KeyTerm1">is_good_enough</span>) is bound to 1. Although <span class="KeyTerm1">sqrt_iter</span> and <span class="KeyTerm1">is_good_enough</span> both have a parameter named <span class="KeyTerm1">guess</span>, these are two distinct local variables located in different frames. Also, E3 and E4 both have E2 as their enclosing environment, because the <span class="KeyTerm1">sqrt_iter</span> and <span class="KeyTerm1">is_good_enough</span> functions both have E2 as their environment part. One consequence of this is that the name <span class="KeyTerm1">x</span> that appears in the body of <span class="KeyTerm1">is_ good_enough</span> will reference the binding of <span class="KeyTerm1">x</span> that appears in E1, namely the value of <span class="KeyTerm1">x</span> with which the original <span class="KeyTerm1">sqrt</span> function was called.</p>
<p><a id="c3-para-0459"/>The environment model thus explains the two key properties that make local function declarations a useful technique for modularizing programs:</p>
<ul style="list-style-type:disc">
<li>The names of the local functions do not interfere with names external to the enclosing function, because the local function names will be bound in the frame that the block creates when it is evaluated, rather than being bound in the program environment.</li>
<li>The local functions can access the arguments of the enclosing function, simply by using parameter names as free names. This is because the body of the local function is evaluated in an environment that is subordinate to the evaluation environment for the enclosing function.</li>
</ul>

<section>
<h5><a id="c3-sec-0023"/><a id="c3-title-0024"/>Exercise 3.11</h5>
<p class="paraaftertitle"><a id="c3-para-0462"/>In section 3.2.3 we saw how the environment model described the behavior of functions with local state. Now we have seen how internal declarations work. A typical messagepassing function contains both of these aspects. Consider the bank account function of section 3.1.1:</p>
<p class="Sp-text-1"><a id="c3-para-0463"/><b>function</b> make_account(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-0464"/>    <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0465"/>        <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0466"/>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-0467"/>            <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0468"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0469"/>            <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-0470"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-0471"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0472"/>    <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-0473"/>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c3-para-0474"/>        <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-0475"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0476"/>    <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c3-para-0477"/>        <b>return</b> m === "withdraw"</p>
<p class="Sp-text-1"><a id="c3-para-0478"/>               ? withdraw</p>
<p class="Sp-text-1"><a id="c3-para-0479"/>               : m === "deposit"</p>
<p class="Sp-text-1"><a id="c3-para-0480"/>               ? deposit</p>
<p class="Sp-text-1"><a id="c3-para-0481"/>               : "Unknown request: make_account";</p>
<p class="Sp-text-1"><a id="c3-para-0482"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0483"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c3-para-0484"/>}</p>
<p class="paracontinue"><a id="c3-para-0485"/>Show the environment structure generated by the sequence of interactions</p>
<p class="Sp-text-1"><a id="c3-para-0486"/><b>const</b> acc = make_account(50);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0487"/>acc("deposit")(40);</p>
<p class="Sp-text-1"><a id="c3-para-0488"/><i>90</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0489"/>acc("withdraw")(60);</p>
<p class="Sp-text-1"><a id="c3-para-0490"/><i>30</i></p>
<p class="paracontinue"><a id="c3-para-0491"/>Where is the local state for <span class="KeyTerm1">acc</span> kept? Suppose we define another account</p>
<p class="Sp-text-1"><a id="c3-para-0492"/><b>const</b> acc2 = make_account(100);</p>
<p class="paracontinue"><a id="c3-para-0493"/>How are the local states for the two accounts kept distinct? Which parts of the environment structure are shared between <span class="KeyTerm1">acc</span> and <span class="KeyTerm1">acc2</span>?</p>
</section>
<section>
<h5><a id="c3-sec-0024"/><a id="c3-title-0025"/>More about blocks</h5>
<p class="paraaftertitle"><a id="c3-para-0494"/>As we saw, the scope of the names declared in <span class="KeyTerm1">sqrt</span> is the whole body of <span class="KeyTerm1">sqrt</span>. This explains why <i>mutual recursion</i> works, as in this (quite wasteful) way of checking whether a nonnegative integer is even.</p>
<p class="Sp-text-1"><a id="c3-para-0495"/><b>function</b> f(x) {</p>
<p class="Sp-text-1"><a id="c3-para-0496"/>    <b>function</b> is_even(n) {</p>
<p class="Sp-text-1"><a id="c3-para-0497"/>        <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c3-para-0498"/>               ? <b>true</b></p>
<p class="Sp-text-1"><a id="c3-para-0499"/>               : is_odd(n - 1);</p>
<p class="Sp-text-1"><a id="c3-para-0500"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0501"/>    <b>function</b> is_odd(n) {</p>
<p class="Sp-text-1"><a id="c3-para-0502"/>        <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c3-para-0503"/>               ? <b>false</b></p>
<p class="Sp-text-1"><a id="c3-para-0504"/>               : is_even(n - 1);</p>
<p class="Sp-text-1"><a id="c3-para-0505"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0506"/>    <b>return</b> is_even(x);</p>
<p class="Sp-text-1"><a id="c3-para-0507"/>}</p>
<p class="paracontinue"><a id="c3-para-0508"/>At the time when <span class="KeyTerm1">is_even</span> is called during a call to <span class="KeyTerm1">f</span>, the environment diagram looks like the one in <a href="#c3-fig-0011">figure 3.11</a> when <span class="KeyTerm1">sqrt_iter</span> is called. The functions <span class="KeyTerm1">is_even</span> and <span class="KeyTerm1">is_odd</span> are bound in E2 to function objects that point to E2 as the environment in which to evaluate calls to those functions. Thus <span class="KeyTerm1">is_odd</span> in the body of <span class="KeyTerm1">is_even</span> refers to the right function. Although <span class="KeyTerm1">is_odd</span> is defined after <span class="KeyTerm1">is_even</span>, this is no different from how in the body of <span class="KeyTerm1">sqrt_iter</span> the name <span class="KeyTerm1">improve</span> and the name <span class="KeyTerm1">sqrt_iter</span> itself refer to the right functions.</p>
<p><a id="c3-para-0509"/>Equipped with a way to handle declarations within blocks, we can revisit declarations of names at the top level. In section 3.2.1, we saw that the names declared at the top level are added to the program frame. A better explanation is that the whole program is placed in an implicit block, which is evaluated in the global environment. The treatment of blocks described above then handles the top level: The global environment is extended by a frame that contains the bindings of all names declared in the implicit block. That frame is the program frame and the resulting environment is the program environment.</p>
<p><a id="c3-para-0510"/>We said that a block's body is evaluated in an environment that contains all names declared directly in the body of the block. A locally declared name is put into the environment when the block is entered, but without an associated value. The evaluation of its declaration during evaluation of the block body then assigns to the name the result of evaluating the expression to the right of the <span class="KeyTerm1">=</span>, as if the declaration were an assignment. Since the addition of the name to the environment is separate from the evaluation of the declaration, and the whole block is in the scope of the name, an erroneous program could attempt to access the value of a name before its declaration is evaluated; the evaluation of an unassigned name signals an error.<a id="c3-fn-0018a"/><a href="#c3-fn-0018"><sup>18</sup></a></p>
</section>
</section>
</section>
<section>
<h2><a id="c3-sec-0025"/><span>3.3</span> <a id="c3-title-0026"/>Modeling with Mutable Data</h2>
<p class="paraaftertitle"><a id="c3-para-0511"/>Chapter 2 dealt with compound data as a means for constructing computational objects that have several parts, in order to model real-world objects that have several aspects. In that chapter we introduced the discipline of data abstraction, according to which data structures are specified in terms of constructors, which create data objects, and selectors, which access the parts of compound data objects. But we now know that there is another aspect of data that chapter 2 did not address. The desire to model systems composed of objects that have changing state leads us to the need to modify compound data objects, as well as to construct and select from them. In order to model compound objects with changing state, we will design data abstractions to include, in addition to selectors and constructors, operations called <i>mutators</i>, which modify data objects. For instance, modeling a banking system requires us to change account balances. Thus, a data structure for representing bank accounts might admit an operation</p>
<p class="Sp-text-1"><a id="c3-para-0512"/>set_balance(<i>account</i>, <i>new</i>-<i>value</i>)</p>
<p class="paracontinue"><a id="c3-para-0513"/>that changes the balance of the designated account to the designated new value. Data objects for which mutators are defined are known as <i>mutable data objects</i>.</p>
<p><a id="c3-para-0514"/>Chapter 2 introduced pairs as a general-purpose “glue” for synthesizing compound data. We begin this section by defining basic mutators for pairs, so that pairs can serve as building blocks for constructing mutable data objects. These mutators greatly enhance the representational power of pairs, enabling us to build data structures other than the sequences and trees that we worked with in section 2.2. We also present some examples of simulations in which complex systems are modeled as collections of objects with local state.</p>
<section>
<h3><a id="c3-sec-0026"/><span>3.3.1</span> <a id="c3-title-0027"/>Mutable List Structure</h3>
<p class="paraaftertitle"><a id="c3-para-0515"/>The basic operations on pairs—<span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>—can be used to construct list structure and to select parts from list structure, but they are incapable of modifying list structure. The same is true of the list operations we have used so far, such as <span class="KeyTerm1">append</span> and <span class="KeyTerm1">list</span>, since these can be defined in terms of <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>. To modify list structures we need new operations.</p>
<p><a id="c3-para-0516"/>The primitive mutators for pairs are <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span>. The function <span class="KeyTerm1">set_head</span> takes two arguments, the first of which must be a pair. It modifies this pair, replacing the <span class="KeyTerm1">head</span> pointer by a pointer to the second argument of <span class="KeyTerm1">set_head</span>.<a id="c3-fn-0019a"/><a href="#c3-fn-0019"><sup>19</sup></a></p>
<p><a id="c3-para-5516"/>As an example, suppose that <span class="KeyTerm1">x</span> is bound to <span class="KeyTerm1">list(list("a", "b"), "c", "d")</span> and <span class="KeyTerm1">y</span> to <span class="KeyTerm1">list("e", "f")</span> as illustrated in <a id="c3-fig-0012a"/><a href="#c3-fig-0012">figure 3.12</a>. Evaluating the expression <span class="KeyTerm1">set_head(x, y)</span> modifies the pair to which <span class="KeyTerm1">x</span> is bound, replacing its <span class="KeyTerm1">head</span> by the value of <span class="KeyTerm1">y</span>. The result of the operation is shown in <a id="c3-fig-0013a"/><a href="#c3-fig-0013">figure 3.13</a>. The structure <span class="KeyTerm1">x</span> has been modified and is now equivalent to <span class="KeyTerm1">list(list("e", "f"), "c", "d")</span>. The pairs representing the list <span class="KeyTerm1">list("a", "b")</span>, identified by the pointer that was replaced, are now detached from the original structure.<a id="c3-fn-0020a"/><a href="#c3-fn-0020"><sup>20</sup></a></p>
<figure id="c3-fig-0012"><img alt="c3-fig-0012.jpg" src="../images/c3-fig-0012.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0012a">Figure 3.12</a></span> <a id="c3-para-0517"/>Lists <span class="KeyTerm1">x</span>: <span class="KeyTerm1">list(list("a", "b"), "c", "d")</span> and <span class="KeyTerm1">y</span>: <span class="KeyTerm1">list("e", "f")</span>.</p></figcaption></figure>
<figure id="c3-fig-0013"><img alt="c3-fig-0013.jpg" src="../images/c3-fig-0013.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0013a">Figure 3.13</a></span> <a id="c3-para-0518"/>Effect of <span class="KeyTerm1">set_head(x, y)</span> on the lists in <a href="#c3-fig-0012">figure 3.12</a>.</p></figcaption></figure>
<p><a id="c3-para-0519"/>Compare <a href="#c3-fig-0013">figure 3.13</a> with <a id="c3-fig-0014a"/><a href="#c3-fig-0014">figure 3.14</a>, which illustrates the result of executing</p>
<p class="Sp-text-1"><a id="c3-para-0521"/><b>const</b> z = pair(y, tail(x));</p>
<p class="paracontinue"><a id="c3-para-0522"/>with <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> bound to the original lists of <a href="#c3-fig-0012">figure 3.12</a>. The name <span class="KeyTerm1">z</span> is now bound to a new pair created by the <span class="KeyTerm1">pair</span> operation; the list to which <span class="KeyTerm1">x</span> is bound is unchanged. The <span class="KeyTerm1">set_tail</span> operation is similar to <span class="KeyTerm1">set_head</span>. The only difference is that the <span class="KeyTerm1">tail</span> pointer of the pair, rather than the <span class="KeyTerm1">head</span> pointer, is replaced. The effect of executing <span class="KeyTerm1">set_tail(x, y)</span> on the lists of <a href="#c3-fig-0012">figure 3.12</a> is shown in <a id="c3-fig-0015a"/><a href="#c3-fig-0015">figure 3.15</a>. Here the <span class="KeyTerm1">tail</span> pointer of <span class="KeyTerm1">x</span> has been replaced by the pointer to <span class="KeyTerm1">list("e", "f")</span>. Also, the list <span class="KeyTerm1">list("c", "d")</span>, which used to be the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">x</span>, is now detached from the structure.</p>
<figure id="c3-fig-0014"><img alt="c3-fig-0014.jpg" src="../images/c3-fig-0014.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0014a">Figure 3.14</a></span> <a id="c3-para-0520"/>Effect of <span class="KeyTerm1"><b>const</b> z = pair(y, tail(x));</span> on the lists in <a href="#c3-fig-0012">figure 3.12</a>.</p></figcaption></figure>
<figure id="c3-fig-0015"><img alt="c3-fig-0015.jpg" src="../images/c3-fig-0015.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0015a">Figure 3.15</a></span> <a id="c3-para-0523"/>Effect of <span class="KeyTerm1">set_tail(x, y)</span> on the lists in <a href="#c3-fig-0012">figure 3.12</a>.</p></figcaption></figure>
<p><a id="c3-para-0524"/>The function <span class="KeyTerm1">pair</span> builds new list structure by creating new pairs, whereas <span class="KeyTerm1">set_ head</span> and <span class="KeyTerm1">set_tail</span> modify existing pairs. Indeed, we could implement <span class="KeyTerm1">pair</span> in terms of the two mutators, together with a function <span class="KeyTerm1">get_new_pair</span>, which returns a new pair that is not part of any existing list structure. We obtain the new pair, set its <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> pointers to the designated objects, and return the new pair as the result of the <span class="KeyTerm1">pair</span>.<a id="c3-fn-0021a"/><a href="#c3-fn-0021"><sup>21</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-0525"/><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c3-para-0526"/>    <b>const</b> fresh = get_new_pair();</p>
<p class="Sp-text-1"><a id="c3-para-5525"/>    set_head(fresh, x);</p>
<p class="Sp-text-1"><a id="c3-para-5526"/>    set_tail(fresh, y);</p>
<p class="Sp-text-1"><a id="c3-para-0527"/>    <b>return</b> fresh;</p>
<p class="Sp-text-1"><a id="c3-para-0528"/>}</p>
<section>
<h5><a id="c3-sec-0027"/><a id="c3-title-0028"/>Exercise 3.12</h5>
<p class="paraaftertitle"><a id="c3-para-0529"/>The following function for appending lists was introduced in section 2.2.1:</p>
<p class="Sp-text-1"><a id="c3-para-0530"/><b>function</b> append(x, y) {</p>
<p class="Sp-text-1"><a id="c3-para-0531"/>    <b>return</b> is_null(x)</p>
<p class="Sp-text-1"><a id="c3-para-0532"/>           ? y</p>
<p class="Sp-text-1"><a id="c3-para-0533"/>           : pair(head(x), append(tail(x), y));</p>
<p class="Sp-text-1"><a id="c3-para-0534"/>}</p>
<p class="paracontinue"><a id="c3-para-0535"/>The function <span class="KeyTerm1">append</span> forms a new list by successively adjoining the elements of <span class="KeyTerm1">x</span> to the front of <span class="KeyTerm1">y</span>. The function <span class="KeyTerm1">append_mutator</span> is similar to <span class="KeyTerm1">append</span>, but it is a mutator rather than a constructor. It appends the lists by splicing them together, modifying the final pair of <span class="KeyTerm1">x</span> so that its <span class="KeyTerm1">tail</span> is now <span class="KeyTerm1">y</span>. (It is an error to call <span class="KeyTerm1">append_mutator</span> with an empty <span class="KeyTerm1">x</span>.)</p>
<p class="Sp-text-1"><a id="c3-para-0536"/><b>function</b> append_mutator(x, y) {</p>
<p class="Sp-text-1"><a id="c3-para-0537"/>    set_tail(last_pair(x), y);</p>
<p class="Sp-text-1"><a id="c3-para-0538"/>    <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c3-para-0539"/>}</p>
<p class="paracontinue"><a id="c3-para-0540"/>Here <span class="KeyTerm1">last_pair</span> is a function that returns the last pair in its argument:</p>
<p class="Sp-text-1"><a id="c3-para-0541"/><b>function</b> last_pair(x) {</p>
<p class="Sp-text-1"><a id="c3-para-0542"/>    <b>return</b> is_null(tail(x))</p>
<p class="Sp-text-1"><a id="c3-para-0543"/>          ? x</p>
<p class="Sp-text-1"><a id="c3-para-0544"/>          : last_pair(tail(x));</p>
<p class="Sp-text-1"><a id="c3-para-0545"/>}</p>
<p class="paracontinue"><a id="c3-para-0546"/>Consider the interaction</p>
<p class="Sp-text-1"><a id="c3-para-0547"/><b>const</b> x = list("a", "b");</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0548"/><b>const</b> y = list("c", "d");</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0549"/><b>const</b> z = append(x, y);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0550"/>z;</p>
<p class="Sp-text-1"><a id="c3-para-0551"/>["a", ["b", ["c", ["d, null]]]]</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0552"/>tail(x);</p>
<p class="Sp-text-1"><a id="c3-para-0553"/><span class="KeyTerm2"><i>response</i></span></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0554"/><b>const</b> w = append_mutator(x, y);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0555"/>w;</p>
<p class="Sp-text-1"><a id="c3-para-0556"/>["a", ["b", ["c", ["d", null]]]]</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0557"/>tail(x);</p>
<p class="Sp-text-1"><a id="c3-para-0558"/><span class="KeyTerm2"><i>response</i></span></p>
<p class="paracontinue"><a id="c3-para-0559"/>What are the missing <i>response</i>s? Draw box-and-pointer diagrams to explain your answer.</p>
</section>
<section>
<h5><a id="c3-sec-0028"/><a id="c3-title-0029"/>Exercise 3.13</h5>
<p class="paraaftertitle"><a id="c3-para-0560"/>Consider the following <span class="KeyTerm1">make_cycle</span> function, which uses the <span class="KeyTerm1">last_pair</span> function defined in exercise 3.12:</p>
<p class="Sp-text-1"><a id="c3-para-0561"/><b>function</b> make_cycle(x) {</p>
<p class="Sp-text-1"><a id="c3-para-0562"/>    set_tail(last_pair(x), x);</p>
<p class="Sp-text-1"><a id="c3-para-0563"/>    <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c3-para-0564"/>}</p>
<p class="paracontinue"><a id="c3-para-0565"/>Draw a box-and-pointer diagram that shows the structure <span class="KeyTerm1">z</span> created by</p>
<p class="Sp-text-1"><a id="c3-para-0566"/><b>const</b> z = make_cycle(list("a", "b", "c"));</p>
<p class="paracontinue"><a id="c3-para-0567"/>What happens if we try to compute <span class="KeyTerm1">last_pair(z)</span>?</p>
</section>
<section>
<h5><a id="c3-sec-0029"/><a id="c3-title-0030"/>Exercise 3.14</h5>
<p class="paraaftertitle"><a id="c3-para-0568"/>The following function is quite useful, although obscure:</p>
<p class="Sp-text-1"><a id="c3-para-0569"/><b>function</b> mystery(x) {</p>
<p class="Sp-text-1"><a id="c3-para-0570"/>    <b>function</b> loop(x, y) {</p>
<p class="Sp-text-1"><a id="c3-para-0571"/>        <b>if</b> (is_null(x)) {</p>
<p class="Sp-text-1"><a id="c3-para-0572"/>            <b>return</b> y;</p>
<p class="Sp-text-1"><a id="c3-para-0573"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0574"/>            <b>const</b> temp = tail(x);</p>
<p class="Sp-text-1"><a id="c3-para-0575"/>            set_tail(x, y);</p>
<p class="Sp-text-1"><a id="c3-para-0576"/>            <b>return</b> loop(temp, x);</p>
<p class="Sp-text-1"><a id="c3-para-0577"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-0578"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0579"/>    <b>return</b> loop(x, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c3-para-0580"/>}</p>
<p class="paracontinue"><a id="c3-para-0581"/>The function <span class="KeyTerm1">loop</span> uses the “temporary” name <span class="KeyTerm1">temp</span> to hold the old value of the <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">x</span>, since the <span class="KeyTerm1">set_tail</span> on the next line destroys the <span class="KeyTerm1">tail</span>. Explain what <span class="KeyTerm1">mystery</span> does in general. Suppose <span class="KeyTerm1">v</span> is defined by</p>
<p class="Sp-text-1"><a id="c3-para-0582"/><b>const</b> v = list("a", "b", "c", "d");</p>
<p class="paracontinue"><a id="c3-para-0583"/>Draw the box-and-pointer diagram that represents the list to which <span class="KeyTerm1">v</span> is bound. Suppose that we now evaluate</p>
<p class="Sp-text-1"><a id="c3-para-0584"/><b>const</b> w = mystery(v);</p>
<p class="paracontinue"><a id="c3-para-0585"/>Draw box-and-pointer diagrams that show the structures <span class="KeyTerm1">v</span> and <span class="KeyTerm1">w</span> after evaluating this program. What would be printed as the values of <span class="KeyTerm1">v</span> and <span class="KeyTerm1">w</span>?</p>
</section>
<section>
<h5><a id="c3-sec-0030"/><a id="c3-title-0031"/>Sharing and identity</h5>
<p class="paraaftertitle"><a id="c3-para-0586"/>We mentioned in section 3.1.3 the theoretical issues of “sameness” and “change” raised by the introduction of assignment. These issues arise in practice when individual pairs are <i>shared</i> among different data objects. For example, consider the structure formed by</p>
<p class="Sp-text-1"><a id="c3-para-0587"/><b>const</b> x = list("a", "b");</p>
<p class="Sp-text-1"><a id="c3-para-0588"/><b>const</b> z1 = pair(x, x);</p>
<p class="paracontinue"><a id="c3-para-0589"/>As shown in <a id="c3-fig-0016a"/><a href="#c3-fig-0016">figure 3.16</a>, <span class="KeyTerm1">z1</span> is a pair whose <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> both point to the same pair <span class="KeyTerm1">x</span>. This sharing of <span class="KeyTerm1">x</span> by the <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> of <span class="KeyTerm1">z1</span> is a consequence of the straightforward way in which <span class="KeyTerm1">pair</span> is implemented. In general, using <span class="KeyTerm1">pair</span> to construct lists will result in an interlinked structure of pairs in which many individual pairs are shared by many different structures.</p>
<figure id="c3-fig-0016"><img alt="c3-fig-0016.jpg" src="../images/c3-fig-0016.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0016a">Figure 3.16</a></span> <a id="c3-para-0590"/>The list <span class="KeyTerm1">z1</span> formed by <span class="KeyTerm1">pair(x, x)</span>.</p></figcaption></figure>
<p><a id="c3-para-0591"/>In contrast to <a href="#c3-fig-0016">figure 3.16</a>, <a id="c3-fig-0017a"/><a href="#c3-fig-0017">figure 3.17</a> shows the structure created by</p>
<p class="Sp-text-1"><a id="c3-para-0593"/><b>const</b> z2 = pair(list("a", "b"), list("a", "b"));</p>
<p class="paracontinue"><a id="c3-para-0594"/>In this structure, the pairs in the two <span class="KeyTerm1">list("a", "b")</span> lists are distinct, although they contain the same strings.<a id="c3-fn-0022a"/><a href="#c3-fn-0022"><sup>22</sup></a></p>
<figure id="c3-fig-0017"><img alt="c3-fig-0017.jpg" src="../images/c3-fig-0017.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0017a">Figure 3.17</a></span> <a id="c3-para-0592"/>The list <span class="KeyTerm1">z2</span> formed by <span class="KeyTerm1">pair(list("a", "b"), list("a", "b"))</span>.</p></figcaption></figure>
<p><a id="c3-para-0595"/>When thought of as a list, <span class="KeyTerm1">z1</span> and <span class="KeyTerm1">z2</span> both represent “the same” list:</p>
<p class="Sp-text-1"><a id="c3-para-0596"/>list(list("a", "b"), "a", "b")</p>
<p class="paracontinue"><a id="c3-para-0597"/>In general, sharing is completely undetectable if we operate on lists using only <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>. However, if we allow mutators on list structure, sharing becomes significant. As an example of the difference that sharing can make, consider the following function, which modifies the <span class="KeyTerm1">head</span> of the structure to which it is applied:</p>
<p class="Sp-text-1"><a id="c3-para-0598"/><b>function</b> set_to_wow(x) {</p>
<p class="Sp-text-1"><a id="c3-para-0599"/>    set_head(head(x), "wow");</p>
<p class="Sp-text-1"><a id="c3-para-0600"/>    <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c3-para-0601"/>}</p>
<p class="paracontinue"><a id="c3-para-0602"/>Even though <span class="KeyTerm1">z1</span> and <span class="KeyTerm1">z2</span> are “the same” structure, applying <span class="KeyTerm1">set_to_wow</span> to them yields different results. With <span class="KeyTerm1">z1</span>, altering the <span class="KeyTerm1">head</span> also changes the <span class="KeyTerm1">tail</span>, because in <span class="KeyTerm1">z1</span> the <span class="KeyTerm1">head</span> and the <span class="KeyTerm1">tail</span> are the same pair. With <span class="KeyTerm1">z2</span>, the <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> are distinct, so <span class="KeyTerm1">set_to_wow</span> modifies only the <span class="KeyTerm1">head</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0603"/>z1;</p>
<p class="Sp-text-1"><a id="c3-para-0604"/><i>[["a", ["b", null]], ["a", ["b", null]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0605"/>set_to_wow(z1);</p>
<p class="Sp-text-1"><a id="c3-para-0606"/><i>[["wow", ["b", null]], ["wow", ["b", null]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0607"/>z2;</p>
<p class="Sp-text-1"><a id="c3-para-0608"/><i>[["a", ["b", null]], ["a", ["b", null]]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0609"/>set_to_wow(z2);</p>
<p class="Sp-text-1"><a id="c3-para-0610"/><i>[["wow", ["b", null]], ["a", ["b", null]]]</i></p>
<p><a id="c3-para-0611"/>One way to detect sharing in list structures is to use the primitive predicate <span class="KeyTerm1">===</span>, which we introduced in section 1.1.6 to test whether two numbers are equal and extended in section 2.3.1 to test whether two strings are equal. When applied to two nonprimitive values, <span class="KeyTerm1">x === y</span> tests whether <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> are the same object (that is, whether <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> are equal as pointers). Thus, with <span class="KeyTerm1">z1</span> and <span class="KeyTerm1">z2</span> as defined in <a href="#c3-fig-0016">figure 3.16 and 3.17</a>, <span class="KeyTerm1">head(z1) === tail(z1)</span> is true and <span class="KeyTerm1">head(z2) === tail(z2)</span> is false.</p>
<p><a id="c3-para-5611"/>As will be seen in the following sections, we can exploit sharing to greatly extend the repertoire of data structures that can be represented by pairs. On the other hand, sharing can also be dangerous, since modifications made to structures will also affect other structures that happen to share the modified parts. The mutation operations <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span> should be used with care; unless we have a good understanding of how our data objects are shared, mutation can have unanticipated results.<a id="c3-fn-0023a"/><a href="#c3-fn-0023"><sup>23</sup></a></p>
</section>
<section>
<h5><a id="c3-sec-0031"/><a id="c3-title-0032"/>Exercise 3.15</h5>
<p class="paraaftertitle"><a id="c3-para-0612"/>Draw box-and-pointer diagrams to explain the effect of <span class="KeyTerm1">set_to_wow</span> on the structures <span class="KeyTerm1">z1</span> and <span class="KeyTerm1">z2</span> above.</p>
</section>
<section>
<h5><a id="c3-sec-0032"/><a id="c3-title-0033"/>Exercise 3.16</h5>
<p class="paraaftertitle"><a id="c3-para-0613"/>Ben Bitdiddle decides to write a function to count the number of pairs in any list structure. “It's easy,” he reasons. “The number of pairs in any structure is the number in the <span class="KeyTerm1">head</span> plus the number in the <span class="KeyTerm1">tail</span> plus one more to count the current pair.” So Ben writes the following function</p>
<p class="Sp-text-1"><a id="c3-para-0614"/><b>function</b> count_pairs(x) {</p>
<p class="Sp-text-1"><a id="c3-para-0615"/>    <b>return</b> ! is_pair(x)</p>
<p class="Sp-text-1"><a id="c3-para-0616"/>           ? 0</p>
<p class="Sp-text-1"><a id="c3-para-0617"/>           : count_pairs(head(x)) +</p>
<p class="Sp-text-1"><a id="c3-para-0618"/>             count_pairs(tail(x)) + 1;</p>
<p class="Sp-text-1"><a id="c3-para-0619"/>}</p>
<p class="paracontinue"><a id="c3-para-0620"/>Show that this function is not correct. In particular, draw box-and-pointer diagrams representing list structures made up of exactly three pairs for which Ben's function would return 3; return 4; return 7; never return at all.</p>
</section>
<section>
<h5><a id="c3-sec-0033"/><a id="c3-title-0034"/>Exercise 3.17</h5>
<p class="paraaftertitle"><a id="c3-para-0621"/>Devise a correct version of the <span class="KeyTerm1">count_pairs</span> function of exercise 3.16 that returns the number of distinct pairs in any structure. (Hint: Traverse the structure, maintaining an auxiliary data structure that is used to keep track of which pairs have already been counted.)</p>
</section>
<section>
<h5><a id="c3-sec-0034"/><a id="c3-title-0035"/>Exercise 3.18</h5>
<p class="paraaftertitle"><a id="c3-para-0622"/>Write a function that examines a list and determines whether it contains a cycle, that is, whether a program that tried to find the end of the list by taking successive <span class="KeyTerm1">tail</span>s would go into an infinite loop. Exercise 3.13 constructed such lists.</p>
</section>
<section>
<h5><a id="c3-sec-0035"/><a id="c3-title-0036"/>Exercise 3.19</h5>
<p class="paraaftertitle"><a id="c3-para-0623"/>Redo exercise 3.18 using an algorithm that takes only a constant amount of space. (This requires a very clever idea.)</p>
</section>
<section>
<h5><a id="c3-sec-0036"/><a id="c3-title-0037"/>Mutation is just assignment</h5>
<p class="paraaftertitle"><a id="c3-para-0624"/>When we introduced compound data, we observed in section 2.1.3 that pairs can be represented purely in terms of functions:</p>
<p class="Sp-text-1"><a id="c3-para-0625"/><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c3-para-0626"/>    <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c3-para-0627"/>    <b>return</b> m === "head"</p>
<p class="Sp-text-1"><a id="c3-para-0628"/>           ? x</p>
<p class="Sp-text-1"><a id="c3-para-0629"/>           : m === "tail"</p>
<p class="Sp-text-1"><a id="c3-para-0630"/>           ? y</p>
<p class="Sp-text-1"><a id="c3-para-0631"/>           : error(m, "undefined operation – pair");</p>
<p class="Sp-text-1"><a id="c3-para-0632"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0633"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c3-para-0634"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0635"/><b>function</b> head(z) { <b>return</b> z("head"); }</p>
<p class="Sp-text-1"><a id="c3-para-0636"/><b>function</b> tail(z) { <b>return</b> z("tail"); }</p>
<p class="paracontinue"><a id="c3-para-0637"/>The same observation is true for mutable data. We can implement mutable data objects as functions using assignment and local state. For instance, we can extend the above pair implementation to handle <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span> in a manner analogous to the way we implemented bank accounts using <span class="KeyTerm1">make_account</span> in section 3.1.1:</p>
<p class="Sp-text-1"><a id="c3-para-0638"/><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c3-para-0639"/>    <b>function</b> set_x(v) { x = v; }</p>
<p class="Sp-text-1"><a id="c3-para-0640"/>    <b>function</b> set_y(v) { y = v; }</p>
<p class="Sp-text-1"><a id="c3-para-0641"/>    <b>return</b> m =&gt; m === "head"</p>
<p class="Sp-text-1"><a id="c3-para-0642"/>                ? x</p>
<p class="Sp-text-1"><a id="c3-para-0643"/>                : m === "tail"</p>
<p class="Sp-text-1"><a id="c3-para-0644"/>                ? y</p>
<p class="Sp-text-1"><a id="c3-para-0645"/>                : m === "set_head"</p>
<p class="Sp-text-1"><a id="c3-para-0646"/>                ? set_x</p>
<p class="Sp-text-1"><a id="c3-para-0647"/>                : m === "set_tail"</p>
<p class="Sp-text-1"><a id="c3-para-0648"/>                ? set_y</p>
<p class="Sp-text-1"><a id="c3-para-0649"/>                : error(m, "undefined operation – pair");</p>
<p class="Sp-text-1"><a id="c3-para-0650"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0651"/><b>function</b> head(z) { <b>return</b> z("head"); }</p>
<p class="Sp-text-1"><a id="c3-para-0652"/><b>function</b> tail(z) { <b>return</b> z("tail"); }</p>
<p class="Sp-text-1"><a id="c3-para-0653"/><b>function</b> set_head(z, new_value) {</p>
<p class="Sp-text-1"><a id="c3-para-0654"/>    z("set_head")(new_value);</p>
<p class="Sp-text-1"><a id="c3-para-0655"/>    <b>return</b> z;</p>
<p class="Sp-text-1"><a id="c3-para-0656"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0657"/><b>function</b> set_tail(z, new_value) {</p>
<p class="Sp-text-1"><a id="c3-para-0658"/>    z("set_tail")(new_value);</p>
<p class="Sp-text-1"><a id="c3-para-0659"/>    <b>return</b> z;</p>
<p class="Sp-text-1"><a id="c3-para-0660"/>}</p>
<p><a id="c3-para-0661"/>Assignment is all that is needed, theoretically, to account for the behavior of mutable data. As soon as we admit assignment to our language, we raise all the issues, not only of assignment, but of mutable data in general.<a id="c3-fn-0024a"/><a href="#c3-fn-0024"><sup>24</sup></a></p>
</section>
<section>
<h5><a id="c3-sec-0037"/><a id="c3-title-0038"/>Exercise 3.20</h5>
<p class="paraaftertitle"><a id="c3-para-0662"/>Draw environment diagrams to illustrate the evaluation of the sequence of statements</p>
<p class="Sp-text-1"><a id="c3-para-0663"/><b>const</b> x = pair(1, 2);</p>
<p class="Sp-text-1"><a id="c3-para-0664"/><b>const</b> z = pair(x, x);</p>
<p class="Sp-text-1"><a id="c3-para-0665"/>set_head(tail(z), 17);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0666"/>head(x);</p>
<p class="Sp-text-1"><a id="c3-para-0667"/><i>17</i></p>
<p class="paracontinue"><a id="c3-para-0668"/>using the functional implementation of pairs given above. (Compare exercise 3.11.)</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0038"/><span>3.3.2</span> <a id="c3-title-0039"/>Representing Queues</h3>
<p class="paraaftertitle"><a id="c3-para-0669"/>The mutators <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span> enable us to use pairs to construct data structures that cannot be built with <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> alone. This section shows how to use pairs to represent a data structure called a queue. Section 3.3.3 will show how to represent data structures called tables.</p>
<p><a id="c3-para-0670"/>A <i>queue</i> is a sequence in which items are inserted at one end (called the <i>rear</i> of the queue) and deleted from the other end (the <i>front</i>). <a id="c3-fig-0018a"/><a href="#c3-fig-0018">Figure 3.18</a> shows an initially empty queue in which the items <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> are inserted. Then <span class="KeyTerm1">a</span> is removed, <span class="KeyTerm1">c</span> and <span class="KeyTerm1">d</span> are inserted, and <span class="KeyTerm1">b</span> is removed. Because items are always removed in the order in which they are inserted, a queue is sometimes called a <i>FIFO</i> (first in, first out) buffer.</p>
<figure id="c3-fig-0018"><img alt="c3-fig-0018.jpg" src="../images/c3-fig-0018.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0018a">Figure 3.18</a></span> <a id="c3-para-0671"/>Queue operations.</p></figcaption></figure>
<p><a id="c3-para-0672"/>In terms of data abstraction, we can regard a queue as defined by the following set of operations:</p>
<ul style="list-style-type:disc">
<li>a constructor:
<p class="paracontinue"><a id="c3-para-0674"/><span class="KeyTerm1">make_queue</span>()</p>
<p class="paracontinue"><a id="c3-para-0675"/>returns an empty queue (a queue containing no items).</p></li>
<li>a predicate:
<p class="paracontinue"><a id="c3-para-0677"/><span class="KeyTerm1">is_empty_queue</span>(<span class="KeyTerm2"><i>queue</i></span>)</p>
<p class="paracontinue"><a id="c3-para-0678"/>tests if the queue is empty.</p></li>
<li>a selector:
<p class="paracontinue"><a id="c3-para-0680"/><span class="KeyTerm1">front_queue</span>(<span class="KeyTerm2"><i>queue</i></span>)</p>
<p class="paracontinue"><a id="c3-para-0681"/>returns the object at the front of the queue, signaling an error if the queue is empty; it does not modify the queue.</p></li>
<li>two mutators:
<p class="paracontinue"><a id="c3-para-0683"/><span class="KeyTerm1">insert_queue</span>(<span class="KeyTerm2"><i>queue</i></span>, <span class="KeyTerm2"><i>item</i></span>)</p>
<p class="paracontinue"><a id="c3-para-0684"/>inserts the item at the rear of the queue and returns the modified queue as its value.</p>
<p class="paracontinue"><a id="c3-para-0685"/><span class="KeyTerm1">delete_queue</span>(<span class="KeyTerm2"><i>queue</i></span>)</p>
<p class="paracontinue"><a id="c3-para-0686"/>removes the item at the front of the queue and returns the modified queue as its value, signaling an error if the queue is empty before the deletion.</p></li>
</ul>

<p><a id="c3-para-0687"/>Because a queue is a sequence of items, we could certainly represent it as an ordinary list; the front of the queue would be the <span class="KeyTerm1">head</span> of the list, inserting an item in the queue would amount to appending a new element at the end of the list, and deleting an item from the queue would just be taking the <span class="KeyTerm1">tail</span> of the list. However, this representation is inefficient, because in order to insert an item we must scan the list until we reach the end. Since the only method we have for scanning a list is by successive <span class="KeyTerm1">tail</span> operations, this scanning requires Θ(<i>n</i>) steps for a list of <i>n</i> items. A simple modification to the list representation overcomes this disadvantage by allowing the queue operations to be implemented so that they require Θ(1) steps; that is, so that the number of steps needed is independent of the length of the queue.</p>
<p><a id="c3-para-5687"/>The difficulty with the list representation arises from the need to scan to find the end of the list. The reason we need to scan is that, although the standard way of representing a list as a chain of pairs readily provides us with a pointer to the beginning of the list, it gives us no easily accessible pointer to the end. The modification that avoids the drawback is to represent the queue as a list, together with an additional pointer that indicates the final pair in the list. That way, when we go to insert an item, we can consult the rear pointer and so avoid scanning the list.</p>
<p><a id="c3-para-0688"/>A queue is represented, then, as a pair of pointers, <span class="KeyTerm1">front_ptr</span> and <span class="KeyTerm1">rear_ptr</span>, which indicate, respectively, the first and last pairs in an ordinary list. Since we would like the queue to be an identifiable object, we can use <span class="KeyTerm1">pair</span> to combine the two pointers. Thus, the queue itself will be the <span class="KeyTerm1">pair</span> of the two pointers. <a id="c3-fig-0019a"/><a href="#c3-fig-0019">Figure 3.19</a> illustrates this representation.</p>
<figure id="c3-fig-0019"><img alt="c3-fig-0019.jpg" src="../images/c3-fig-0019.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0019a">Figure 3.19</a></span> <a id="c3-para-0689"/>Implementation of a queue as a list with front and rear pointers.</p></figcaption></figure>
<p><a id="c3-para-0690"/>To define the queue operations we use the following functions, which enable us to select and to modify the front and rear pointers of a queue:</p>
<p class="Sp-text-1"><a id="c3-para-0691"/><b>function</b> front_ptr(queue) { <b>return</b> head(queue); }</p>
<p class="Sp-text-1"><a id="c3-para-0692"/><b>function</b> rear_ptr(queue) { <b>return</b> tail(queue); }</p>
<p class="Sp-text-1"><a id="c3-para-0693"/><b>function</b> set_front_ptr(queue, item) { set_head(queue, item); }</p>
<p class="Sp-text-1"><a id="c3-para-0694"/><b>function</b> set_rear_ptr(queue, item) { set_tail(queue, item); }</p>
<p><a id="c3-para-0695"/>Now we can implement the actual queue operations. We will consider a queue to be empty if its front pointer is the empty list:</p>
<p class="Sp-text-1"><a id="c3-para-0696"/><b>function</b> is_empty_queue(queue) { <b>return</b> is_null(front_ptr(queue)); }</p>
<p class="paracontinue"><a id="c3-para-0697"/>The <span class="KeyTerm1">make_queue</span> constructor returns, as an initially empty queue, a pair whose <span class="KeyTerm1">head</span> and <span class="KeyTerm1">tail</span> are both the empty list:</p>
<p class="Sp-text-1"><a id="c3-para-0698"/><b>function</b> make_queue() { <b>return</b> pair(<b>null</b>, <b>null</b>); }</p>
<p class="paracontinue"><a id="c3-para-0699"/>To select the item at the front of the queue, we return the <span class="KeyTerm1">head</span> of the pair indicated by the front pointer:</p>
<p class="Sp-text-1"><a id="c3-para-0700"/><b>function</b> front_queue(queue) {</p>
<p class="Sp-text-1"><a id="c3-para-0701"/>    <b>return</b> is_empty_queue(queue)</p>
<p class="Sp-text-1"><a id="c3-para-0702"/>           ? error(queue, "front_queue called with an empty queue")</p>
<p class="Sp-text-1"><a id="c3-para-0703"/>           : head(front_ptr(queue));</p>
<p class="Sp-text-1"><a id="c3-para-0704"/>}</p>
<p><a id="c3-para-0705"/>To insert an item in a queue, we follow the method whose result is indicated in <a id="c3-fig-0020a"/><a href="#c3-fig-0020">figure 3.20</a>. We first create a new pair whose <span class="KeyTerm1">head</span> is the item to be inserted and whose <span class="KeyTerm1">tail</span> is the empty list. If the queue was initially empty, we set the front and rear pointers of the queue to this new pair. Otherwise, we modify the final pair in the queue to point to the new pair, and also set the rear pointer to the new pair.</p>
<p class="Sp-text-1"><a id="c3-para-0707"/><b>function</b> insert_queue(queue, item) {</p>
<p class="Sp-text-1"><a id="c3-para-0708"/>    <b>const</b> new_pair = pair(item, <b>null</b>);</p>
<p class="Sp-text-1"><a id="c3-para-0709"/>    <b>if</b> (is_empty_queue(queue)) {</p>
<p class="Sp-text-1"><a id="c3-para-0710"/>        set_front_ptr(queue, new_pair);</p>
<p class="Sp-text-1"><a id="c3-para-0711"/>        set_rear_ptr(queue, new_pair);</p>
<p class="Sp-text-1"><a id="c3-para-0712"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0713"/>        set_tail(rear_ptr(queue), new_pair);</p>
<p class="Sp-text-1"><a id="c3-para-0714"/>        set_rear_ptr(queue, new_pair);</p>
<p class="Sp-text-1"><a id="c3-para-0715"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0716"/>    <b>return</b> queue;</p>
<p class="Sp-text-1"><a id="c3-para-0717"/>}</p>
<figure id="c3-fig-0020"><img alt="c3-fig-0020.jpg" src="../images/c3-fig-0020.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0020a">Figure 3.20</a></span> <a id="c3-para-0706"/>Result of using <span class="KeyTerm1">insert_queue(q, "d")</span> on the queue of <a href="#c3-fig-0019">figure 3.19</a>.</p></figcaption></figure>
<p><a id="c3-para-0718"/>To delete the item at the front of the queue, we merely modify the front pointer so that it now points at the second item in the queue, which can be found by following the <span class="KeyTerm1">tail</span> pointer of the first item (see <a id="c3-fig-0021a"/><a href="#c3-fig-0021">figure 3.21</a>):<a id="c3-fn-0025a"/><a href="#c3-fn-0025"><sup>25</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-0720"/><b>function</b> delete_queue(queue) {</p>
<p class="Sp-text-1"><a id="c3-para-0721"/>    <b>if</b> (is_empty_queue(queue)) {</p>
<p class="Sp-text-1"><a id="c3-para-0722"/>        error(queue, "delete_queue called with an empty queue");</p>
<p class="Sp-text-1"><a id="c3-para-0723"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0724"/>        set_front_ptr(queue, tail(front_ptr(queue)));</p>
<p class="Sp-text-1"><a id="c3-para-0725"/>        <b>return</b> queue;</p>
<p class="Sp-text-1"><a id="c3-para-0726"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0727"/>}</p>
<figure id="c3-fig-0021"><img alt="c3-fig-0021.jpg" src="../images/c3-fig-0021.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0021a">Figure 3.21</a></span> <a id="c3-para-0719"/>Result of using <span class="KeyTerm1">delete_queue(q)</span> on the queue of <a href="#c3-fig-0020">figure 3.20</a>.</p></figcaption></figure>
<section>
<h5><a id="c3-sec-0039"/><a id="c3-title-0040"/>Exercise 3.21</h5>
<p class="paraaftertitle"><a id="c3-para-0728"/>Ben Bitdiddle decides to test the queue implementation described above. He types in the functions to the JavaScript interpreter and proceeds to try them out:</p>
<p class="Sp-text-1"><a id="c3-para-0729"/><b>const</b> q1 = make_queue();</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0730"/>insert_queue(q1, "a");</p>
<p class="Sp-text-1"><a id="c3-para-0731"/><i>[["a", null], ["a", null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0732"/>insert_queue(q1, "b");</p>
<p class="Sp-text-1"><a id="c3-para-0733"/><i>[["a", ["b", null]], ["b", null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0734"/>delete_queue(q1);</p>
<p class="Sp-text-1"><a id="c3-para-0735"/><i>[["b", null], ["b", null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0736"/>delete_queue(q1);</p>
<p class="Sp-text-1"><a id="c3-para-0737"/><i>[null, ["b", null]]</i></p>
<p class="paracontinue"><a id="c3-para-0738"/>“It's all wrong!” he complains. “The interpreter's response shows that the last item is inserted into the queue twice. And when I delete both items, the second <span class="KeyTerm1">b</span> is still there, so the queue isn't empty, even though it's supposed to be.” Eva Lu Ator suggests that Ben has misunderstood what is happening. “It's not that the items are going into the queue twice,” she explains. “It's just that the standard JavaScript printer doesn't know how to make sense of the queue representation. If you want to see the queue printed correctly, you'll have to define your own print function for queues.” Explain what Eva Lu is talking about. In particular, show why Ben's examples produce the printed results that they do. Define a function <span class="KeyTerm1">print_queue</span> that takes a queue as input and prints the sequence of items in the queue.</p>
</section>
<section>
<h5><a id="c3-sec-0040"/><a id="c3-title-0041"/>Exercise 3.22</h5>
<p class="paraaftertitle"><a id="c3-para-0739"/>Instead of representing a queue as a pair of pointers, we can build a queue as a function with local state. The local state will consist of pointers to the beginning and the end of an ordinary list. Thus, the <span class="KeyTerm1">make_queue</span> function will have the form</p>
<p class="Sp-text-1"><a id="c3-para-0740"/><b>function</b> make_queue() {</p>
<p class="Sp-text-1"><a id="c3-para-0741"/>    <b>let</b> front_ptr = <i>. . .</i>;</p>
<p class="Sp-text-1"><a id="c3-para-0742"/>    <b>let</b> rear_ptr = <i>. . .</i>;</p>
<p class="Sp-text-1"><a id="c3-para-0743"/>    〈<span class="KeyTerm2"><i>declarations of internal functions</i></span>〉</p>
<p class="Sp-text-1"><a id="c3-para-0744"/>    <b>function</b> dispatch(m) {<i>. . .</i>}</p>
<p class="Sp-text-1"><a id="c3-para-0745"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c3-para-0746"/>}</p>
<p class="paracontinue"><a id="c3-para-0747"/>Complete the definition of <span class="KeyTerm1">make_queue</span> and provide implementations of the queue operations using this representation.</p>
</section>
<section>
<h5><a id="c3-sec-0041"/><a id="c3-title-0042"/>Exercise 3.23</h5>
<p class="paraaftertitle"><a id="c3-para-0748"/>A <i>deque</i> (“double-ended queue”) is a sequence in which items can be inserted and deleted either at the front or at the rear. Operations on deques are the constructor <span class="KeyTerm1">make_deque</span>, the predicate <span class="KeyTerm1">is_empty_deque</span>, selectors <span class="KeyTerm1">front_deque</span> and <span class="KeyTerm1">rear_deque</span>, and mutators <span class="KeyTerm1">front_insert_deque</span>, <span class="KeyTerm1">front_delete_deque</span>, <span class="KeyTerm1">rear_insert_deque</span>, and <span class="KeyTerm1">rear_delete_ deque</span>. Show how to represent deques using pairs, and give implementations of the operations.<a id="c3-fn-0026a"/><a href="#c3-fn-0026"><sup>26</sup></a> All operations should be accomplished in Θ(1) steps.</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0042"/><span>3.3.3</span> <a id="c3-title-0043"/>Representing Tables</h3>
<p class="paraaftertitle"><a id="c3-para-0749"/>When we studied various ways of representing sets in chapter 2, we mentioned in section 2.3.3 the task of maintaining a table of records indexed by identifying keys. In the implementation of data-directed programming in section 2.4.3, we made extensive use of two-dimensional tables, in which information is stored and retrieved using two keys. Here we see how to build tables as mutable list structures.</p>
<p><a id="c3-para-0750"/>We first consider a one-dimensional table, in which each value is stored under a single key. We implement the table as a list of records, each of which is implemented as a pair consisting of a key and the associated value. The records are glued together to form a list by pairs whose <span class="KeyTerm1">head</span>s point to successive records. These gluing pairs are called the <i>backbone</i> of the table. In order to have a place that we can change when we add a new record to the table, we build the table as a <i>headed list</i>. A headed list has a special backbone pair at the beginning, which holds a dummy “record”—in this case the arbitrarily chosen string <span class="KeyTerm1">"*table*"</span>. <a id="c3-fig-0022a"/><a href="#c3-fig-0022">Figure 3.22</a> shows the box-and-pointer diagram for the table</p>
<p class="Sp-text-1"><a id="c3-para-0752"/>a: 1</p>
<p class="Sp-text-1"><a id="c3-para-0753"/>b: 2</p>
<p class="Sp-text-1"><a id="c3-para-0754"/>c: 3</p>
<figure id="c3-fig-0022"><img alt="c3-fig-0022.jpg" src="../images/c3-fig-0022.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0022a">Figure 3.22</a></span> <a id="c3-para-0751"/>A table represented as a headed list.</p></figcaption></figure>
<p><a id="c3-para-0755"/>To extract information from a table we use the <span class="KeyTerm1">lookup</span> function, which takes a key as argument and returns the associated value (or <span class="KeyTerm1">undefined</span> if there is no value stored under that key). The function <span class="KeyTerm1">lookup</span> is defined in terms of the <span class="KeyTerm1">assoc</span> operation, which expects a key and a list of records as arguments. Note that <span class="KeyTerm1">assoc</span> never sees the dummy record. The function <span class="KeyTerm1">assoc</span> returns the record that has the given key as its <span class="KeyTerm1">head</span>.<a id="c3-fn-0027a"/><a href="#c3-fn-0027"><sup>27</sup></a> The function <span class="KeyTerm1">lookup</span> then checks to see that the resulting record returned by <span class="KeyTerm1">assoc</span> is not <span class="KeyTerm1">undefined</span>, and returns the value (the <span class="KeyTerm1">tail</span>) of the record.</p>
<p class="Sp-text-1"><a id="c3-para-0756"/><b>function</b> lookup(key, table) {</p>
<p class="Sp-text-1"><a id="c3-para-0757"/>    <b>const</b> record = assoc(key, tail(table));</p>
<p class="Sp-text-1"><a id="c3-para-0758"/>    <b>return</b> is_undefined(record)</p>
<p class="Sp-text-1"><a id="c3-para-0759"/>           ? undefined</p>
<p class="Sp-text-1"><a id="c3-para-0760"/>           : tail(record);</p>
<p class="Sp-text-1"><a id="c3-para-0761"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0762"/><b>function</b> assoc(key, records) {</p>
<p class="Sp-text-1"><a id="c3-para-0763"/>    <b>return</b> is_null(records)</p>
<p class="Sp-text-1"><a id="c3-para-0764"/>           ? undefined</p>
<p class="Sp-text-1"><a id="c3-para-0765"/>           : equal(key, head(head(records)))</p>
<p class="Sp-text-1"><a id="c3-para-0766"/>           ? head(records)</p>
<p class="Sp-text-1"><a id="c3-para-0767"/>           : assoc(key, tail(records));</p>
<p class="Sp-text-1"><a id="c3-para-0768"/>}</p>
<p><a id="c3-para-0769"/>To insert a value in a table under a specified key, we first use <span class="KeyTerm1">assoc</span> to see if there is already a record in the table with this key. If not, we form a new record by <span class="KeyTerm1">pair</span>ing the key with the value, and insert this at the head of the table's list of records, after the dummy record. If there already is a record with this key, we set the <span class="KeyTerm1">tail</span> of this record to the designated new value. The header of the table provides us with a fixed location to modify in order to insert the new record.<a id="c3-fn-0028a"/><a href="#c3-fn-0028"><sup>28</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-0770"/><b>function</b> insert(key, value, table) {</p>
<p class="Sp-text-1"><a id="c3-para-0771"/>    <b>const</b> record = assoc(key, tail(table));</p>
<p class="Sp-text-1"><a id="c3-para-0772"/>    <b>if</b> (is_undefined(record)) {</p>
<p class="Sp-text-1"><a id="c3-para-0773"/>        set_tail(table,</p>
<p class="Sp-text-1"><a id="c3-para-0774"/>                 pair(pair(key, value), tail(table)));</p>
<p class="Sp-text-1"><a id="c3-para-0775"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0776"/>        set_tail(record, value);</p>
<p class="Sp-text-1"><a id="c3-para-0777"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0778"/>    <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c3-para-0779"/>}</p>
<p><a id="c3-para-0780"/>To construct a new table, we simply create a list containing just the string <span class="KeyTerm1">"*table*"</span>:</p>
<p class="Sp-text-1"><a id="c3-para-0781"/><b>function</b> make_table() {</p>
<p class="Sp-text-1"><a id="c3-para-0782"/>    <b>return</b> list("*table*");</p>
<p class="Sp-text-1"><a id="c3-para-0783"/>}</p>
<section>
<h5><a id="c3-sec-0043"/><a id="c3-title-0044"/>Two-dimensional tables</h5>
<p class="paraaftertitle"><a id="c3-para-0784"/>In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. <a id="c3-fig-0023a"/><a href="#c3-fig-0023">Figure 3.23</a> shows the box-and-pointer diagram for the table</p>
<p class="Sp-text-1"><a id="c3-para-0786"/>"math":</p>
<p class="Sp-text-1"><a id="c3-para-0787"/>    "+": 43</p>
<p class="Sp-text-1"><a id="c3-para-0788"/>    "-": 45</p>
<p class="Sp-text-1"><a id="c3-para-0789"/>    "*": 42</p>
<p class="Sp-text-1"><a id="c3-para-0790"/>"letters":</p>
<p class="Sp-text-1"><a id="c3-para-0791"/>    "a": 97</p>
<p class="Sp-text-1"><a id="c3-para-0792"/>    "b": 98</p>
<p class="paracontinue"><a id="c3-para-0793"/>which has two subtables. (The subtables don't need a special header string, since the key that identifies the subtable serves this purpose.)</p>
<figure id="c3-fig-0023"><img alt="c3-fig-0023.jpg" src="../images/c3-fig-0023.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0023a">Figure 3.23</a></span> <a id="c3-para-0785"/>A two-dimensional table.</p></figcaption></figure>
<p><a id="c3-para-0794"/>When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable.</p>
<p class="Sp-text-1"><a id="c3-para-0795"/><b>function</b> lookup(key_1, key_2, table) {</p>
<p class="Sp-text-1"><a id="c3-para-0796"/>    <b>const</b> subtable = assoc(key_1, tail(table));</p>
<p class="Sp-text-1"><a id="c3-para-0797"/>    <b>if</b> (is_undefined(subtable)) {</p>
<p class="Sp-text-1"><a id="c3-para-0798"/>        <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c3-para-0799"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0800"/>        <b>const</b> record = assoc(key_2, tail(subtable));</p>
<p class="Sp-text-1"><a id="c3-para-0801"/>        <b>return</b> is_undefined(record)</p>
<p class="Sp-text-1"><a id="c3-para-0802"/>               ? undefined</p>
<p class="Sp-text-1"><a id="c3-para-0803"/>               : tail(record);</p>
<p class="Sp-text-1"><a id="c3-para-0804"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0805"/>}</p>
<p><a id="c3-para-0806"/>To insert a new item under a pair of keys, we use <span class="KeyTerm1">assoc</span> to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record (<span class="KeyTerm1">key_2</span>, <span class="KeyTerm1">value</span>) and insert it into the table under the first key. If a</p>
<p class="paracontinue"><a id="c3-para-0807"/>subtable already exists for the first key, we insert the new record into this subtable, using the insertion method for one-dimensional tables described above:</p>
<p class="Sp-text-1"><a id="c3-para-0808"/><b>function</b> insert(key_1, key_2, value, table) {</p>
<p class="Sp-text-1"><a id="c3-para-0809"/>    <b>const</b> subtable = assoc(key_1, tail(table));</p>
<p class="Sp-text-1"><a id="c3-para-0810"/>    <b>if</b> (is_undefined(subtable)) {</p>
<p class="Sp-text-1"><a id="c3-para-0811"/>        set_tail(table,</p>
<p class="Sp-text-1"><a id="c3-para-0812"/>                 pair(list(key_1, pair(key_2, value)), tail(table)));</p>
<p class="Sp-text-1"><a id="c3-para-0813"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0814"/>        <b>const</b> record = assoc(key_2, tail(table));</p>
<p class="Sp-text-1"><a id="c3-para-0815"/>        <b>if</b> (is_undefined(record)) {</p>
<p class="Sp-text-1"><a id="c3-para-0816"/>            set_tail(subtable,</p>
<p class="Sp-text-1"><a id="c3-para-0817"/>                     pair(pair(key_2, value), tail(subtable)));</p>
<p class="Sp-text-1"><a id="c3-para-0818"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0819"/>            set_tail(record, value);</p>
<p class="Sp-text-1"><a id="c3-para-0820"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-0821"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0822"/>    <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c3-para-0823"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0044"/><a id="c3-title-0045"/>Creating local tables</h5>
<p class="paraaftertitle"><a id="c3-para-0824"/>The <span class="KeyTerm1">lookup</span> and <span class="KeyTerm1">insert</span> operations defined above take the table as an argument. This enables us to use programs that access more than one table. Another way to deal with multiple tables is to have separate <span class="KeyTerm1">lookup</span> and <span class="KeyTerm1">insert</span> functions for each table. We can do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this “table object” supplies the function with which to operate on the internal table. Here is a generator for two-dimensional tables represented in this fashion:</p>
<p class="Sp-text-1"><a id="c3-para-0825"/><b>function</b> make_table() {</p>
<p class="Sp-text-1"><a id="c3-para-0826"/>    <b>const</b> local_table = list("*table*");</p>
<p class="Sp-text-1"><a id="c3-para-0827"/>    <b>function</b> lookup(key_1, key_2) {</p>
<p class="Sp-text-1"><a id="c3-para-0828"/>        <b>const</b> subtable = assoc(key_1, tail(local_table));</p>
<p class="Sp-text-1"><a id="c3-para-0829"/>        <b>if</b> (is_undefined(subtable)) {</p>
<p class="Sp-text-1"><a id="c3-para-0830"/>            <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c3-para-0831"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0832"/>            <b>const</b> record = assoc(key_2, tail(subtable));</p>
<p class="Sp-text-1"><a id="c3-para-0833"/>            <b>return</b> is_undefined(record)</p>
<p class="Sp-text-1"><a id="c3-para-0834"/>                   ? undefined</p>
<p class="Sp-text-1"><a id="c3-para-0835"/>                   : tail(record);</p>
<p class="Sp-text-1"><a id="c3-para-0836"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-0837"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0838"/>    <b>function</b> insert(key_1, key_2, value) {</p>
<p class="Sp-text-1"><a id="c3-para-0839"/>        <b>const</b> subtable = assoc(key_1, tail(local_table));</p>
<p class="Sp-text-1"><a id="c3-para-0840"/>        <b>if</b> (is_undefined(subtable)) {</p>
<p class="Sp-text-1"><a id="c3-para-0841"/>            set_tail(local_table,</p>
<p class="Sp-text-1"><a id="c3-para-0842"/>                     pair(list(key_1, pair(key_2, value)),</p>
<p class="Sp-text-1"><a id="c3-para-0843"/>                          tail(local_table)));</p>
<p class="Sp-text-1"><a id="c3-para-0844"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0845"/>            <b>const</b> record = assoc(key_2, tail(subtable));</p>
<p class="Sp-text-1"><a id="c3-para-0846"/>            <b>if</b> (is_undefined(record)) {</p>
<p class="Sp-text-1"><a id="c3-para-0847"/>                set_tail(subtable,</p>
<p class="Sp-text-1"><a id="c3-para-0848"/>                         pair(pair(key_2, value), tail(subtable)));</p>
<p class="Sp-text-1"><a id="c3-para-0849"/>            } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0850"/>                set_tail(record, value);</p>
<p class="Sp-text-1"><a id="c3-para-0851"/>            }</p>
<p class="Sp-text-1"><a id="c3-para-0852"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-0853"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0854"/>    <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c3-para-0855"/>        <b>return</b> m === "lookup"</p>
<p class="Sp-text-1"><a id="c3-para-0856"/>               ? lookup</p>
<p class="Sp-text-1"><a id="c3-para-0857"/>               : m === "insert"</p>
<p class="Sp-text-1"><a id="c3-para-0858"/>               ? insert</p>
<p class="Sp-text-1"><a id="c3-para-0859"/>               : error(m, "unknown operation – table");</p>
<p class="Sp-text-1"><a id="c3-para-0860"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0861"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c3-para-0862"/>}</p>
<p><a id="c3-para-0863"/>Using <span class="KeyTerm1">make_table</span>, we could implement the <span class="KeyTerm1">get</span> and <span class="KeyTerm1">put</span> operations used in section 2.4.3 for data-directed programming, as follows:</p>
<p class="Sp-text-1"><a id="c3-para-0864"/><b>const</b> operation_table = make_table();</p>
<p class="Sp-text-1"><a id="c3-para-0865"/><b>const</b> get = operation_table("lookup");</p>
<p class="Sp-text-1"><a id="c3-para-0866"/><b>const</b> put = operation_table("insert");</p>
<p class="paracontinue"><a id="c3-para-0867"/>The function <span class="KeyTerm1">get</span> takes as arguments two keys, and <span class="KeyTerm1">put</span> takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to <span class="KeyTerm1">make_table</span>.</p>
</section>
<section>
<h5><a id="c3-sec-0045"/><a id="c3-title-0046"/>Exercise 3.24</h5>
<p class="paraaftertitle"><a id="c3-para-0868"/>In the table implementations above, the keys are tested for equality using <span class="KeyTerm1">equal</span> (called by <span class="KeyTerm1">assoc</span>). This is not always the appropriate test. For instance, we might have a table with numeric keys in which we don't need an exact match to the number we're looking up, but only a number within some tolerance of it. Design a table constructor <span class="KeyTerm1">make_table</span> that takes as an argument a <span class="KeyTerm1">same_key</span> function that will be used to test “equality” of keys. The function <span class="KeyTerm1">make_table</span> should return a <span class="KeyTerm1">dispatch</span> function that can be used to access appropriate <span class="KeyTerm1">lookup</span> and <span class="KeyTerm1">insert</span> functions for a local table.</p>
</section>
<section>
<h5><a id="c3-sec-0046"/><a id="c3-title-0047"/>Exercise 3.25</h5>
<p class="paraaftertitle"><a id="c3-para-0869"/>Generalizing oneand two-dimensional tables, show how to implement a table in which values are stored under an arbitrary number of keys and different values may be stored under different numbers of keys. The <span class="KeyTerm1">lookup</span> and <span class="KeyTerm1">insert</span> functions should take as input a list of keys used to access the table.</p>
</section>
<section>
<h5><a id="c3-sec-0047"/><a id="c3-title-0048"/>Exercise 3.26</h5>
<p class="paraaftertitle"><a id="c3-para-0870"/>To search a table as implemented above, one needs to scan through the list of records. This is basically the unordered list representation of section 2.3.3. For large tables, it may be more efficient to structure the table in a different manner. Describe a table implementation where the (key, value) records are organized using a binary tree, assuming that keys can be ordered in some way (e.g., numerically or alphabetically). (Compare exercise 2.66 of chapter 2.)</p>
</section>
<section>
<h5><a id="c3-sec-0048"/><a id="c3-title-0049"/>Exercise 3.27</h5>
<p class="paraaftertitle"><a id="c3-para-0871"/><i>Memoization</i> (also called <i>tabulation</i>) is a technique that enables a function to record, in a local table, values that have previously been computed. This technique can make a vast difference in the performance of a program. A memoized function maintains a table in which values of previous calls are stored using as keys the arguments that produced the values. When the memoized function is asked to compute a value, it first checks the table to see if the value is already there and, if so, just returns that value. Otherwise, it computes the new value in the ordinary way and stores this in the table. As an example of memoization, recall from section 1.2.2 the exponential process for computing Fibonacci numbers:</p>
<p class="Sp-text-1"><a id="c3-para-0872"/><b>function</b> fib(n) {</p>
<p class="Sp-text-1"><a id="c3-para-0873"/>    <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c3-para-0874"/>           ? 0</p>
<p class="Sp-text-1"><a id="c3-para-0875"/>           : n === 1</p>
<p class="Sp-text-1"><a id="c3-para-0876"/>           ? 1</p>
<p class="Sp-text-1"><a id="c3-para-0877"/>           : fib(n - 1) + fib(n - 2);</p>
<p class="Sp-text-1"><a id="c3-para-0878"/>}</p>
<p class="paracontinue"><a id="c3-para-0879"/>The memoized version of the same function is</p>
<p class="Sp-text-1"><a id="c3-para-0880"/><b>const</b> memo_fib = memoize(n =&gt; n === 0</p>
<p class="Sp-text-1"><a id="c3-para-0881"/>                              ? 0</p>
<p class="Sp-text-1"><a id="c3-para-0882"/>                              : n === 1</p>
<p class="Sp-text-1"><a id="c3-para-0883"/>                              ? 1</p>
<p class="Sp-text-1"><a id="c3-para-0884"/>                              : memo_fib(n - 1) +</p>
<p class="Sp-text-1"><a id="c3-para-0885"/>                                memo_fib(n - 2)</p>
<p class="Sp-text-1"><a id="c3-para-0886"/>                        );</p>
<p class="paracontinue"><a id="c3-para-0887"/>where the memoizer is defined as</p>
<p class="Sp-text-1"><a id="c3-para-0888"/><b>function</b> memoize(f) {</p>
<p class="Sp-text-1"><a id="c3-para-0889"/>    <b>const</b> table = make_table();</p>
<p class="Sp-text-1"><a id="c3-para-0890"/>    <b>return</b> x =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-0891"/>               <b>const</b> previously_computed_result =</p>
<p class="Sp-text-1"><a id="c3-para-0892"/>                   lookup(x, table);</p>
<p class="Sp-text-1"><a id="c3-para-0893"/>               <b>if</b> (is_undefined(previously_computed_result)) {</p>
<p class="Sp-text-1"><a id="c3-para-0894"/>                   <b>const</b> result = f(x);</p>
<p class="Sp-text-1"><a id="c3-para-0895"/>                   insert(x, result, table);</p>
<p class="Sp-text-1"><a id="c3-para-0896"/>                   <b>return</b> result;</p>
<p class="Sp-text-1"><a id="c3-para-0897"/>               } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0898"/>                   <b>return</b> previously_computed_result;</p>
<p class="Sp-text-1"><a id="c3-para-0899"/>               }</p>
<p class="Sp-text-1"><a id="c3-para-0900"/>           };</p>
<p class="Sp-text-1"><a id="c3-para-0901"/>}</p>
<p class="paracontinue"><a id="c3-para-0902"/>Draw an environment diagram to analyze the computation of <span class="KeyTerm1">memo_fib(3)</span>. Explain why <span class="KeyTerm1">memo_fib</span> computes the <i>n</i>th Fibonacci number in a number of steps proportional to <i>n</i>. Would the scheme still work if we had simply defined <span class="KeyTerm1">memo_fib</span> to be <span class="KeyTerm1">memoize(fib)</span>?</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0049"/><span>3.3.4</span> <a id="c3-title-0050"/>A Simulator for Digital Circuits</h3>
<p class="paraaftertitle"><a id="c3-para-0903"/>Designing complex digital systems, such as computers, is an important engineering activity. Digital systems are constructed by interconnecting simple elements. Although the behavior of these individual elements is simple, networks of them can have very complex behavior. Computer simulation of proposed circuit designs is an important tool used by digital systems engineers. In this section we design a system for performing digital logic simulations. This system typifies a kind of program called an <i>event-driven simulation</i>, in which actions (“events”) trigger further events that happen at a later time, which in turn trigger more events, and so on.</p>
<p><a id="c3-para-0904"/>Our computational model of a circuit will be composed of objects that correspond to the elementary components from which the circuit is constructed. There are <i>wires</i>, which carry <i>digital signals</i>. A digital signal may at any moment have only one of two possible values, 0 and 1. There are also various types of digital <i>function boxes</i>, which connect wires carrying input signals to other output wires. Such boxes produce output signals computed from their input signals. The output signal is delayed by a time that depends on the type of the function box. For example, an <i>inverter</i> is a primitive function box that inverts its input. If the input signal to an inverter changes to 0, then one <i>inverter-delay</i> later the inverter will change its output signal to 1. If the input signal to an inverter changes to 1, then one <i>inverter-delay</i> later the inverter will change its output signal to 0. We draw an inverter symbolically as in <a id="c3-fig-0024a"/><a href="#c3-fig-0024">figure 3.24</a>. An <i>and-gate</i>, also shown in <a href="#c3-fig-0024">figure 3.24</a>, is a primitive function box with two inputs and one output. It drives its output signal to a value that is the <i>logical and</i> of the inputs. That is, if both of its input signals become 1, then one <i>and-gate-delay</i> time later the and-gate will force its output signal to be 1; otherwise the output will be 0. An <i>or-gate</i> is a similar two-input primitive function box that drives its output signal to a value that is the <i>logical or</i> of the inputs. That is, the output will become 1 if at least one of the input signals is 1; otherwise the output will become 0.</p>
<figure id="c3-fig-0024"><img alt="c3-fig-0024.jpg" src="../images/c3-fig-0024.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0024a">Figure 3.24</a></span> <a id="c3-para-0905"/>Primitive functions in the digital logic simulator.</p></figcaption></figure>
<p><a id="c3-para-0906"/>We can connect primitive functions together to construct more complex functions. To accomplish this we wire the outputs of some function boxes to the inputs of other function boxes. For example, the <i>half-adder</i> circuit shown in <a id="c3-fig-0025a"/><a href="#c3-fig-0025">figure 3.25</a> consists of an or-gate, two and-gates, and an inverter. It takes two input signals, <i>A</i> and <i>B</i>, and has two output signals, <i>S</i> and <i>C</i>. <i>S</i> will become 1 whenever precisely one of <i>A</i> and <i>B</i> is 1, and <i>C</i> will become 1 whenever <i>A</i> and <i>B</i> are both 1. We can see from the figure that, because of the delays involved, the outputs may be generated at different times. Many of the difficulties in the design of digital circuits arise from this fact.</p>
<figure id="c3-fig-0025"><img alt="c3-fig-0025.jpg" src="../images/c3-fig-0025.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0025a">Figure 3.25</a></span> <a id="c3-para-0907"/>A half-adder circuit.</p></figcaption></figure>
<p><a id="c3-para-0908"/>We will now build a program for modeling the digital logic circuits we wish to study. The program will construct computational objects modeling the wires, which will “hold” the signals. Function boxes will be modeled by functions that enforce the correct relationships among the signals.</p>
<p><a id="c3-para-0909"/>One basic element of our simulation will be a function <span class="KeyTerm1">make_wire</span>, which constructs wires. For example, we can construct six wires as follows:</p>
<p class="Sp-text-1"><a id="c3-para-0910"/><b>const</b> a = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-0911"/><b>const</b> b = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-0912"/><b>const</b> c = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-0913"/><b>const</b> d = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-0914"/><b>const</b> e = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-0915"/><b>const</b> s = make_wire();</p>
<p class="paracontinue"><a id="c3-para-0916"/>We attach a function box to a set of wires by calling a function that constructs that kind of box. The arguments to the constructor function are the wires to be attached to the box. For example, given that we can construct and-gates, or-gates, and inverters, we can wire together the half-adder shown in <a href="#c3-fig-0025">figure 3.25</a>:</p>
<p class="Sp-text-1"><a id="c3-para-0917"/>or_gate(a, b, d);</p>
<p class="Sp-text-1"><a id="c3-para-0918"/><i>"ok"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0919"/>and_gate(a, b, c);</p>
<p class="Sp-text-1"><a id="c3-para-0920"/><i>"ok"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0921"/>inverter(c, e);</p>
<p class="Sp-text-1"><a id="c3-para-0922"/><i>"ok"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-0923"/>and_gate(d, e, s);</p>
<p class="Sp-text-1"><a id="c3-para-0924"/><i>"ok"</i></p>
<p><a id="c3-para-0925"/>Better yet, we can explicitly name this operation by defining a function <span class="KeyTerm1">half_ adder</span> that constructs this circuit, given the four external wires to be attached to the half-adder:</p>
<p class="Sp-text-1"><a id="c3-para-0926"/><b>function</b> half_adder(a, b, s, c) {</p>
<p class="Sp-text-1"><a id="c3-para-0927"/>    <b>const</b> d = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-0928"/>    <b>const</b> e = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-0929"/>    or_gate(a, b, d);</p>
<p class="Sp-text-1"><a id="c3-para-0930"/>    and_gate(a, b, c);</p>
<p class="Sp-text-1"><a id="c3-para-0931"/>    inverter(c, e);</p>
<p class="Sp-text-1"><a id="c3-para-0932"/>    and_gate(d, e, s);</p>
<p class="Sp-text-1"><a id="c3-para-0933"/>    <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c3-para-0934"/>}</p>
<p class="paracontinue"><a id="c3-para-0935"/>The advantage of making this definition is that we can use <span class="KeyTerm1">half_adder</span> itself as a building block in creating more complex circuits. <a id="c3-fig-0026a"/><a href="#c3-fig-0026">Figure 3.26</a>, for example, shows a <i>full-adder</i> composed of two half-adders and an or-gate.<a id="c3-fn-0029a"/><a href="#c3-fn-0029"><sup>29</sup></a> We can construct a fulladder as follows:</p>
<p class="Sp-text-1"><a id="c3-para-0937"/><b>function</b> full_adder(a, b, c_in, sum, c_out) {</p>
<p class="Sp-text-1"><a id="c3-para-0938"/>    <b>const</b> s = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-0939"/>    <b>const</b> c1 = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-0940"/>    <b>const</b> c2 = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-0941"/>    half_adder(b, c_in, s, c1);</p>
<p class="Sp-text-1"><a id="c3-para-0942"/>    half_adder(a, s, sum, c2);</p>
<p class="Sp-text-1"><a id="c3-para-0943"/>    or_gate(c1, c2, c_out);</p>
<p class="Sp-text-1"><a id="c3-para-0944"/>    <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c3-para-0945"/>}</p>
<p class="paracontinue"><a id="c3-para-0946"/>Having defined <span class="KeyTerm1">full_adder</span> as a function, we can now use it as a building block for creating still more complex circuits. (For example, see exercise 3.30.)</p>
<figure id="c3-fig-0026"><img alt="c3-fig-0026.jpg" src="../images/c3-fig-0026.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0026a">Figure 3.26</a></span> <a id="c3-para-0936"/>A full-adder circuit.</p></figcaption></figure>
<p><a id="c3-para-0947"/>In essence, our simulator provides us with the tools to construct a language of circuits. If we adopt the general perspective on languages with which we approached the study of JavaScript in section 1.1, we can say that the primitive function boxes form the primitive elements of the language, that wiring boxes together provides a means of combination, and that specifying wiring patterns as functions serves as a means of abstraction.</p>
<section>
<h5><a id="c3-sec-0050"/><a id="c3-title-0051"/>Primitive function boxes</h5>
<p class="paraaftertitle"><a id="c3-para-0948"/>The primitive function boxes implement the “forces” by which a change in the signal on one wire influences the signals on other wires. To build function boxes, we use the following operations on wires:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">get_signal(</span><i>wire</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-0950"/>returns the current value of the signal on the wire.</p></li>
<li><span class="KeyTerm1">set_signal(</span><i>wire</i><span class="KeyTerm1">,</span> <i>new</i>-<i>value</i><span class="KeyTerm1">)</span>:
<p class="paracontinue"><a id="c3-para-0952"/>changes the value of the signal on the wire to the new value.</p></li>
<li><span class="KeyTerm1">add_action(</span><i>wire</i><span class="KeyTerm1">,</span> <i>function</i>-<i>of</i> -<i>no</i>-<i>arguments</i><span class="KeyTerm1">)</span>:
<p class="paracontinue"><a id="c3-para-0954"/>asserts that the designated function should be run whenever the signal on the wire changes value. Such functions are the vehicles by which changes in the signal value on the wire are communicated to other wires.</p></li>
</ul>

<p class="paracontinue"><a id="c3-para-0955"/>In addition, we will make use of a function <span class="KeyTerm1">after_delay</span> that takes a time delay and a function to be run and executes the given function after the given delay.</p>
<p><a id="c3-para-0956"/>Using these functions, we can define the primitive digital logic functions. To connect an input to an output through an inverter, we use <span class="KeyTerm1">add_action</span> to associate with the input wire a function that will be run whenever the signal on the input wire changes value. The function computes the <span class="KeyTerm1">logical_not</span> of the input signal, and then, after one <span class="KeyTerm1">inverter_delay</span>, sets the output signal to be this new value:</p>
<p class="Sp-text-1"><a id="c3-para-0957"/><b>function</b> inverter(input, output) {</p>
<p class="Sp-text-1"><a id="c3-para-0958"/>    <b>function</b> invert_input() {</p>
<p class="Sp-text-1"><a id="c3-para-0959"/>        <b>const</b> new_value = logical_not(get_signal(input));</p>
<p class="Sp-text-1"><a id="c3-para-0960"/>        after_delay(inverter_delay,</p>
<p class="Sp-text-1"><a id="c3-para-0961"/>                    () =&gt; set_signal(output, new_value));</p>
<p class="Sp-text-1"><a id="c3-para-0962"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0963"/>    add_action(input, invert_input);</p>
<p class="Sp-text-1"><a id="c3-para-0964"/>    <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c3-para-0965"/>}</p>
<p class="Sp-text-1"><a id="c3-para-0966"/><b>function</b> logical_not(s) {</p>
<p class="Sp-text-1"><a id="c3-para-0967"/>    <b>return</b> s === 0</p>
<p class="Sp-text-1"><a id="c3-para-0968"/>           ? 1</p>
<p class="Sp-text-1"><a id="c3-para-0969"/>           : s === 1</p>
<p class="Sp-text-1"><a id="c3-para-0970"/>           ? 0</p>
<p class="Sp-text-1"><a id="c3-para-0971"/>           : error(s, "invalid signal");</p>
<p class="Sp-text-1"><a id="c3-para-0972"/>}</p>
<p><a id="c3-para-0973"/>An and-gate is a little more complex. The action function must be run if either of the inputs to the gate changes. It computes the <span class="KeyTerm1">logical_and</span> (using a function analogous to <span class="KeyTerm1">logical_not</span>) of the values of the signals on the input wires and sets up a change to the new value to occur on the output wire after one <span class="KeyTerm1">and_gate_delay</span>.</p>
<p class="Sp-text-1"><a id="c3-para-0974"/><b>function</b> and_gate(a1, a2, output) {</p>
<p class="Sp-text-1"><a id="c3-para-0975"/>    <b>function</b> and_action_function() {</p>
<p class="Sp-text-1"><a id="c3-para-0976"/>        <b>const</b> new_value = logical_and(get_signal(a1),</p>
<p class="Sp-text-1"><a id="c3-para-0977"/>                                      get_signal(a2));</p>
<p class="Sp-text-1"><a id="c3-para-0978"/>        after_delay(and_gate_delay,</p>
<p class="Sp-text-1"><a id="c3-para-0979"/>                    () =&gt; set_signal(output, new_value));</p>
<p class="Sp-text-1"><a id="c3-para-0980"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-0981"/>    add_action(a1, and_action_function);</p>
<p class="Sp-text-1"><a id="c3-para-0982"/>    add_action(a2, and_action_function);</p>
<p class="Sp-text-1"><a id="c3-para-0983"/>    <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c3-para-0984"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0051"/><a id="c3-title-0052"/>Exercise 3.28</h5>
<p class="paraaftertitle"><a id="c3-para-0985"/>Define an or-gate as a primitive function box. Your <span class="KeyTerm1">or_gate</span> constructor should be similar to <span class="KeyTerm1">and_gate</span>.</p>
</section>
<section>
<h5><a id="c3-sec-0052"/><a id="c3-title-0053"/>Exercise 3.29</h5>
<p class="paraaftertitle"><a id="c3-para-0986"/>Another way to construct an or-gate is as a compound digital logic device, built from andgates and inverters. Define a function <span class="KeyTerm1">or_gate</span> that accomplishes this. What is the delay time of the or-gate in terms of <span class="KeyTerm1">and_gate_delay</span> and <span class="KeyTerm1">inverter_delay</span>?</p>
</section>
<section>
<h5><a id="c3-sec-0053"/><a id="c3-title-0054"/>Exercise 3.30</h5>
<p class="paraaftertitle"><a id="c3-para-0987"/><a id="c3-fig-0027a"/><a href="#c3-fig-0027">Figure 3.27</a> shows a <i>ripple-carry adder</i> formed by stringing together <i>n</i> full-adders. This is the simplest form of parallel adder for adding two <i>n</i>-bit binary numbers. The inputs <i>A</i><sub>1</sub>, <i>A</i><sub>2</sub>, <i>A</i><sub>3</sub>, . . ., <i>A<sub>n</sub></i> and <i>B</i><sub>1</sub>, <i>B</i><sub>2</sub>, <i>B</i><sub>3</sub>, . . ., <i>B<sub>n</sub></i> are the two binary numbers to be added (each <i>A<sub>k</sub></i> and <i>B<sub>k</sub></i> is a 0 or a 1). The circuit generates <i>S</i><sub>1</sub>, <i>S</i><sub>2</sub>, <i>S</i><sub>3</sub>, . . ., <i>S<sub>n</sub></i>, the <i>n</i> bits of the sum, and <i>C</i>, the carry from the addition. Write a function <span class="KeyTerm1">ripple_carry_adder</span> that generates this circuit. The function should take as arguments three lists of <i>n</i> wires each—the <i>A<sub>k</sub></i>, the <i>B<sub>k</sub></i>, and the <i>S<sub>k</sub></i>—and also another wire <i>C</i>. The major drawback of the ripple-carry adder is the need to wait for the carry signals to propagate. What is the delay needed to obtain the complete output from an <i>n</i>-bit ripple-carry adder, expressed in terms of the delays for and-gates, or-gates, and inverters?</p>
<figure id="c3-fig-0027"><img alt="c3-fig-0027.jpg" src="../images/c3-fig-0027.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0027a">Figure 3.27</a></span> <a id="c3-para-0988"/>A ripple-carry adder for <i>n</i>-bit numbers.</p></figcaption></figure>
</section>
<section>
<h5><a id="c3-sec-0054"/><a id="c3-title-0055"/>Representing wires</h5>
<p class="paraaftertitle"><a id="c3-para-0989"/>A wire in our simulation will be a computational object with two local state variables: a <span class="KeyTerm1">signal_value</span> (initially taken to be 0) and a collection of <span class="KeyTerm1">action_functions</span> to be run when the signal changes value. We implement the wire, using messagepassing style, as a collection of local functions together with a <span class="KeyTerm1">dispatch</span> function that selects the appropriate local operation, just as we did with the simple bankaccount object in section 3.1.1:</p>
<p class="Sp-text-1"><a id="c3-para-0990"/><b>function</b> make_wire() {</p>
<p class="Sp-text-1"><a id="c3-para-0991"/>    <b>let</b> signal_value = 0;</p>
<p class="Sp-text-1"><a id="c3-para-0992"/>    <b>let</b> action_functions = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c3-para-0993"/>    <b>function</b> set_my_signal(new_value) {</p>
<p class="Sp-text-1"><a id="c3-para-0994"/>        <b>if</b> (signal_value !== new_value) {</p>
<p class="Sp-text-1"><a id="c3-para-0995"/>            signal_value = new_value;</p>
<p class="Sp-text-1"><a id="c3-para-0996"/>            <b>return</b> call_each(action_functions);</p>
<p class="Sp-text-1"><a id="c3-para-0997"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-0998"/>            <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c3-para-0999"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1000"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1001"/>    <b>function</b> accept_action_function(fun) {</p>
<p class="Sp-text-1"><a id="c3-para-1002"/>        action_functions = pair(fun, action_functions);</p>
<p class="Sp-text-1"><a id="c3-para-1003"/>        fun();</p>
<p class="Sp-text-1"><a id="c3-para-1004"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1005"/>    <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c3-para-1006"/>        <b>return</b> m === "get_signal"</p>
<p class="Sp-text-1"><a id="c3-para-1007"/>               ? signal_value</p>
<p class="Sp-text-1"><a id="c3-para-1008"/>               : m === "set_signal"</p>
<p class="Sp-text-1"><a id="c3-para-1009"/>               ? set_my_signal</p>
<p class="Sp-text-1"><a id="c3-para-1010"/>               : m === "add_action"</p>
<p class="Sp-text-1"><a id="c3-para-1011"/>               ? accept_action_function</p>
<p class="Sp-text-1"><a id="c3-para-1012"/>               : error(m, "unknown operation – wire");</p>
<p class="Sp-text-1"><a id="c3-para-1013"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1014"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c3-para-1015"/>}</p>
<p class="paracontinue"><a id="c3-para-1016"/>The local function <span class="KeyTerm1">set_my_signal</span> tests whether the new signal value changes the signal on the wire. If so, it runs each of the action functions, using the following function <span class="KeyTerm1">call_each</span>, which calls each of the items in a list of no-argument functions:</p>
<p class="Sp-text-1"><a id="c3-para-1017"/><b>function</b> call_each(functions) {</p>
<p class="Sp-text-1"><a id="c3-para-1018"/>    <b>if</b> (is_null(functions)) {</p>
<p class="Sp-text-1"><a id="c3-para-1019"/>        <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c3-para-1020"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1021"/>        head(functions)();</p>
<p class="Sp-text-1"><a id="c3-para-1022"/>        <b>return</b> call_each(tail(functions));</p>
<p class="Sp-text-1"><a id="c3-para-1023"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1024"/>}</p>
<p class="paracontinue"><a id="c3-para-1025"/>The local function <span class="KeyTerm1">accept_action_function</span> adds the given function to the list of functions to be run, and then runs the new function once. (See exercise 3.31.)</p>
<p><a id="c3-para-1026"/>With the local <span class="KeyTerm1">dispatch</span> function set up as specified, we can provide the following functions to access the local operations on wires:<a id="c3-fn-0030a"/><a href="#c3-fn-0030"><sup>30</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1027"/><b>function</b> get_signal(wire) {</p>
<p class="Sp-text-1"><a id="c3-para-1028"/>    <b>return</b> wire("get_signal");</p>
<p class="Sp-text-1"><a id="c3-para-1029"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1030"/><b>function</b> set_signal(wire, new_value) {</p>
<p class="Sp-text-1"><a id="c3-para-1031"/>    <b>return</b> wire("set_signal")(new_value);</p>
<p class="Sp-text-1"><a id="c3-para-1032"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1033"/><b>function</b> add_action(wire, action_function) {</p>
<p class="Sp-text-1"><a id="c3-para-1034"/>    <b>return</b> wire("add_action")(action_function);</p>
<p class="Sp-text-1"><a id="c3-para-1035"/>}</p>
<p><a id="c3-para-1036"/>Wires, which have time-varying signals and may be incrementally attached to devices, are typical of mutable objects. We have modeled them as functions with local state variables that are modified by assignment. When a new wire is created, a new set of state variables is allocated (by the <span class="KeyTerm1"><b>let</b></span> statements in <span class="KeyTerm1">make_wire</span>) and a new <span class="KeyTerm1">dispatch</span> function is constructed and returned, capturing the environment with the new state variables.</p>
<p><a id="c3-para-1037"/>The wires are shared among the various devices that have been connected to them. Thus, a change made by an interaction with one device will affect all the other devices attached to the wire. The wire communicates the change to its neighbors by calling the action functions provided to it when the connections were established.</p>
</section>
<section>
<h5><a id="c3-sec-0055"/><a id="c3-title-0056"/>The agenda</h5>
<p class="paraaftertitle"><a id="c3-para-1038"/>The only thing needed to complete the simulator is <span class="KeyTerm1">after_delay</span>. The idea here is that we maintain a data structure, called an <i>agenda</i>, that contains a schedule of things to do. The following operations are defined for agendas:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">make_agenda()</span>:
<p class="paracontinue"><a id="c3-para-1040"/>returns a new empty agenda.</p></li>
<li><span class="KeyTerm1">is_empty_agenda(</span><i>agenda</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-1042"/>is true if the specified agenda is empty.</p></li>
<li><span class="KeyTerm1">first_agenda_item(</span><i>agenda</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-1044"/>returns the first item on the agenda.</p></li>
<li><span class="KeyTerm1">remove_first_agenda_item(</span><i>agenda</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-1046"/>modifies the agenda by removing the first item.</p></li>
<li><span class="KeyTerm1">add_to_agenda(</span><i>time</i><span class="KeyTerm1">,</span> <i>action</i><span class="KeyTerm1">,</span> <i>agenda</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-1048"/>modifies the agenda by adding the given action function to be run at the specified time.</p></li>
<li><span class="KeyTerm1">current_time(</span><i>agenda</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-1050"/>returns the current simulation time.</p></li>
</ul>

<p><a id="c3-para-1051"/>The particular agenda that we use is denoted by <span class="KeyTerm1">the_agenda</span>. The function <span class="KeyTerm1">after_delay</span> adds new elements to <span class="KeyTerm1">the_agenda</span>:</p>
<p class="Sp-text-1"><a id="c3-para-1052"/><b>function</b> after_delay(delay, action) {</p>
<p class="Sp-text-1"><a id="c3-para-1053"/>    add_to_agenda(delay + current_time(the_agenda),</p>
<p class="Sp-text-1"><a id="c3-para-1054"/>                  action,</p>
<p class="Sp-text-1"><a id="c3-para-1055"/>                  the_agenda);</p>
<p class="Sp-text-1"><a id="c3-para-1056"/>}</p>
<p><a id="c3-para-1057"/>The simulation is driven by the function <span class="KeyTerm1">propagate</span>, which executes each function on <span class="KeyTerm1">the_agenda</span> in sequence. In general, as the simulation runs, new items will be added to the agenda, and <span class="KeyTerm1">propagate</span> will continue the simulation as long as there are items on the agenda:</p>
<p class="Sp-text-1"><a id="c3-para-1058"/><b>function</b> propagate() {</p>
<p class="Sp-text-1"><a id="c3-para-1059"/>    <b>if</b> (is_empty_agenda(the_agenda)) {</p>
<p class="Sp-text-1"><a id="c3-para-1060"/>        <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c3-para-1061"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1062"/>        <b>const</b> first_item = first_agenda_item(the_agenda);</p>
<p class="Sp-text-1"><a id="c3-para-1063"/>        first_item();</p>
<p class="Sp-text-1"><a id="c3-para-1064"/>        remove_first_agenda_item(the_agenda);</p>
<p class="Sp-text-1"><a id="c3-para-1065"/>        <b>return</b> propagate();</p>
<p class="Sp-text-1"><a id="c3-para-1066"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1067"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0056"/><a id="c3-title-0057"/>A sample simulation</h5>
<p class="paraaftertitle"><a id="c3-para-1068"/>The following function, which places a “probe” on a wire, shows the simulator in action. The probe tells the wire that, whenever its signal changes value, it should print the new signal value, together with the current time and a name that identifies the wire.</p>
<p class="Sp-text-1"><a id="c3-para-1069"/><b>function</b> probe(name, wire) {</p>
<p class="Sp-text-1"><a id="c3-para-1070"/>    add_action(wire,</p>
<p class="Sp-text-1"><a id="c3-para-1071"/>               () =&gt; display(name + " " +</p>
<p class="Sp-text-1"><a id="c3-para-1072"/>                             stringify(current_time(the_agenda)) +</p>
<p class="Sp-text-1"><a id="c3-para-1073"/>                             ", new value = " +</p>
<p class="Sp-text-1"><a id="c3-para-1074"/>                             stringify(get_signal(wire))));</p>
<p class="Sp-text-1"><a id="c3-para-1075"/>}</p>
<p><a id="c3-para-1076"/>We begin by initializing the agenda and specifying delays for the primitive function boxes:</p>
<p class="Sp-text-1"><a id="c3-para-1077"/><b>const</b> the_agenda = make_agenda();</p>
<p class="Sp-text-1"><a id="c3-para-1078"/><b>const</b> inverter_delay = 2;</p>
<p class="Sp-text-1"><a id="c3-para-1079"/><b>const</b> and_gate_delay = 3;</p>
<p class="Sp-text-1"><a id="c3-para-1080"/><b>const</b> or_gate_delay = 5;</p>
<p class="paracontinue"><a id="c3-para-1081"/>Now we define four wires, placing probes on two of them:</p>
<p class="Sp-text-1"><a id="c3-para-1082"/><b>const</b> input_1 = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-1083"/><b>const</b> input_2 = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-1084"/><b>const</b> sum = make_wire();</p>
<p class="Sp-text-1"><a id="c3-para-1085"/><b>const</b> carry = make_wire();</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-1086"/>probe("sum", sum);</p>
<p class="Sp-text-1"><a id="c3-para-1087"/><i>"sum 0, new value = 0"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-1088"/>probe("carry", carry);</p>
<p class="Sp-text-1"><a id="c3-para-1089"/><i>"carry 0, new value = 0"</i></p>
<p class="paracontinue"><a id="c3-para-1090"/>Next we connect the wires in a half-adder circuit (as in <a href="#c3-fig-0025">figure 3.25</a>), set the signal on <span class="KeyTerm1">input_1</span> to 1, and run the simulation:</p>
<p class="Sp-text-1"><a id="c3-para-1091"/>half_adder(input_1, input_2, sum, carry);</p>
<p class="Sp-text-1"><a id="c3-para-1092"/><i>"ok"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-1093"/>set_signal(input_1, 1);</p>
<p class="Sp-text-1"><a id="c3-para-1094"/><i>"done"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-1095"/>propagate();</p>
<p class="Sp-text-1"><a id="c3-para-1096"/><i>"sum 8, new value = 1"</i></p>
<p class="Sp-text-1"><a id="c3-para-1097"/><i>"done"</i></p>
<p class="paracontinue"><a id="c3-para-1098"/>The <span class="KeyTerm1">sum</span> signal changes to 1 at time 8. We are now eight time units from the beginning of the simulation. At this point, we can set the signal on <span class="KeyTerm1">input_2</span> to 1 and allow the values to propagate:</p>
<p class="Sp-text-1"><a id="c3-para-1099"/>set_signal(input_2, 1);</p>
<p class="Sp-text-1"><a id="c3-para-1100"/><i>"done"</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-1101"/>propagate();</p>
<p class="Sp-text-1"><a id="c3-para-1102"/><i>"carry 11, new value = 1"</i></p>
<p class="Sp-text-1"><a id="c3-para-1103"/><i>"sum 16, new value = 0"</i></p>
<p class="Sp-text-1"><a id="c3-para-5103"/><i>"done"</i></p>
<p class="paracontinue"><a id="c3-para-1104"/>The <span class="KeyTerm1">carry</span> changes to 1 at time 11 and the <span class="KeyTerm1">sum</span> changes to 0 at time 16.</p>
</section>
<section>
<h5><a id="c3-sec-0057"/><a id="c3-title-0058"/>Exercise 3.31</h5>
<p class="paraaftertitle"><a id="c3-para-1105"/>The internal function <span class="KeyTerm1">accept_action_function</span> defined in <span class="KeyTerm1">make_wire</span> specifies that when a new action function is added to a wire, the function is immediately run. Explain why this initialization is necessary. In particular, trace through the half-adder example in the paragraphs above and say how the system's response would differ if we had defined <span class="KeyTerm1">accept_action_function</span> as</p>
<p class="Sp-text-1"><a id="c3-para-1106"/><b>function</b> accept_action_function(fun) {</p>
<p class="Sp-text-1"><a id="c3-para-1107"/>    action_functions = pair(fun, action_functions);</p>
<p class="Sp-text-1"><a id="c3-para-1108"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0058"/><a id="c3-title-0059"/>Implementing the agenda</h5>
<p class="paraaftertitle"><a id="c3-para-1109"/>Finally, we give details of the agenda data structure, which holds the functions that are scheduled for future execution.</p>
<p><a id="c3-para-1110"/>The agenda is made up of <i>time segments</i>. Each time segment is a pair consisting of a number (the time) and a queue (see exercise 3.32) that holds the functions that are scheduled to be run during that time segment.</p>
<p class="Sp-text-1"><a id="c3-para-1111"/><b>function</b> make_time_segment(time, queue) {</p>
<p class="Sp-text-1"><a id="c3-para-1112"/>    <b>return</b> pair(time, queue);</p>
<p class="Sp-text-1"><a id="c3-para-1113"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1114"/><b>function</b> segment_time(s) { <b>return</b> head(s); }</p>
<p class="Sp-text-1"><a id="c3-para-1115"/><b>function</b> segment_queue(s) { <b>return</b> tail(s); }</p>
<p class="paracontinue"><a id="c3-para-1116"/>We will operate on the time-segment queues using the queue operations described in section 3.3.2.</p>
<p><a id="c3-para-1117"/>The agenda itself is a one-dimensional table of time segments. It differs from the tables described in section 3.3.3 in that the segments will be sorted in order of increasing time. In addition, we store the <i>current time</i> (i.e., the time of the last action that was processed) at the head of the agenda. A newly constructed agenda has no time segments and has a current time of 0:<a id="c3-fn-0031a"/><a href="#c3-fn-0031"><sup>31</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1118"/><b>function</b> make_agenda() { <b>return</b> list(0); }</p>
<p class="Sp-text-1"><a id="c3-para-1119"/><b>function</b> current_time(agenda) { <b>return</b> head(agenda); }</p>
<p class="Sp-text-1"><a id="c3-para-1120"/><b>function</b> set_current_time(agenda, time) {</p>
<p class="Sp-text-1"><a id="c3-para-1121"/>    set_head(agenda, time);</p>
<p class="Sp-text-1"><a id="c3-para-1122"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1123"/><b>function</b> segments(agenda) { <b>return</b> tail(agenda); }</p>
<p class="Sp-text-1"><a id="c3-para-1124"/><b>function</b> set_segments(agenda, segs) {</p>
<p class="Sp-text-1"><a id="c3-para-1125"/>    set_tail(agenda, segs);</p>
<p class="Sp-text-1"><a id="c3-para-1126"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1127"/><b>function</b> first_segment(agenda) { <b>return</b> head(segments(agenda)); }</p>
<p class="Sp-text-1"><a id="c3-para-1128"/><b>function</b> rest_segments(agenda) { <b>return</b> tail(segments(agenda)); }</p>
<p><a id="c3-para-1129"/>An agenda is empty if it has no time segments:</p>
<p class="Sp-text-1"><a id="c3-para-1130"/><b>function</b> is_empty_agenda(agenda) {</p>
<p class="Sp-text-1"><a id="c3-para-1131"/>    <b>return</b> is_null(segments(agenda));</p>
<p class="Sp-text-1"><a id="c3-para-1132"/>}</p>
<p><a id="c3-para-1133"/>To add an action to an agenda, we first check if the agenda is empty. If so, we create a time segment for the action and install this in the agenda. Otherwise, we scan the agenda, examining the time of each segment. If we find a segment for our appointed time, we add the action to the associated queue. If we reach a time later than the one to which we are appointed, we insert a new time segment into the agenda just before it. If we reach the end of the agenda, we must create a new time segment at the end.</p>
<p class="Sp-text-1"><a id="c3-para-1134"/><b>function</b> add_to_agenda(time, action, agenda) {</p>
<p class="Sp-text-1"><a id="c3-para-1135"/>    <b>function</b> belongs_before(segs) {</p>
<p class="Sp-text-1"><a id="c3-para-1136"/>        <b>return</b> is_null(segs) || time &lt; segment_time(head(segs));</p>
<p class="Sp-text-1"><a id="c3-para-1137"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1138"/>    <b>function</b> make_new_time_segment(time, action) {</p>
<p class="Sp-text-1"><a id="c3-para-1139"/>        <b>const</b> q = make_queue();</p>
<p class="Sp-text-1"><a id="c3-para-1140"/>        insert_queue(q, action);</p>
<p class="Sp-text-1"><a id="c3-para-1141"/>        <b>return</b> make_time_segment(time, q);</p>
<p class="Sp-text-1"><a id="c3-para-1142"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1143"/>    <b>function</b> add_to_segments(segs) {</p>
<p class="Sp-text-1"><a id="c3-para-1144"/>        <b>if</b> (segment_time(head(segs)) === time) {</p>
<p class="Sp-text-1"><a id="c3-para-1145"/>            insert_queue(segment_queue(head(segs)), action);</p>
<p class="Sp-text-1"><a id="c3-para-1146"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1147"/>            <b>const</b> rest = tail(segs);</p>
<p class="Sp-text-1"><a id="c3-para-1148"/>            <b>if</b> (belongs_before(rest)) {</p>
<p class="Sp-text-1"><a id="c3-para-1149"/>                set_tail(segs, pair(make_new_time_segment(time, action),</p>
<p class="Sp-text-1"><a id="c3-para-1150"/>                                    tail(segs)));</p>
<p class="Sp-text-1"><a id="c3-para-1151"/>            } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1152"/>                add_to_segments(rest);</p>
<p class="Sp-text-1"><a id="c3-para-1153"/>            }</p>
<p class="Sp-text-1"><a id="c3-para-1154"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1155"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1156"/>    <b>const</b> segs = segments(agenda);</p>
<p class="Sp-text-1"><a id="c3-para-1157"/>    <b>if</b> (belongs_before(segs)) {</p>
<p class="Sp-text-1"><a id="c3-para-1158"/>        set_segments(agenda,</p>
<p class="Sp-text-1"><a id="c3-para-1159"/>                    pair(make_new_time_segment(time, action), segs));</p>
<p class="Sp-text-1"><a id="c3-para-1160"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1161"/>        add_to_segments(segs);</p>
<p class="Sp-text-1"><a id="c3-para-1162"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1163"/>}</p>
<p><a id="c3-para-1164"/>The function that removes the first item from the agenda deletes the item at the front of the queue in the first time segment. If this deletion makes the time segment empty, we remove it from the list of segments:<a id="c3-fn-0032a"/><a href="#c3-fn-0032"><sup>32</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1165"/><b>function</b> remove_first_agenda_item(agenda) {</p>
<p class="Sp-text-1"><a id="c3-para-1166"/>    <b>const</b> q = segment_queue(first_segment(agenda));</p>
<p class="Sp-text-1"><a id="c3-para-1167"/>    delete_queue(q);</p>
<p class="Sp-text-1"><a id="c3-para-1168"/>    <b>if</b> (is_empty_queue(q)) {</p>
<p class="Sp-text-1"><a id="c3-para-1169"/>        set_segments(agenda, rest_segments(agenda));</p>
<p class="Sp-text-1"><a id="c3-para-1170"/>    } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c3-para-1171"/>}</p>
<p><a id="c3-para-1172"/>The first agenda item is found at the head of the queue in the first time segment. Whenever we extract an item, we also update the current time:<a id="c3-fn-0033a"/><a href="#c3-fn-0033"><sup>33</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1173"/><b>function</b> first_agenda_item(agenda) {</p>
<p class="Sp-text-1"><a id="c3-para-1174"/>    <b>if</b> (is_empty_agenda(agenda)) {</p>
<p class="Sp-text-1"><a id="c3-para-1175"/>        error("agenda is empty – first_agenda_item");</p>
<p class="Sp-text-1"><a id="c3-para-1176"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1177"/>        <b>const</b> first_seg = first_segment(agenda);</p>
<p class="Sp-text-1"><a id="c3-para-1178"/>        set_current_time(agenda, segment_time(first_seg));</p>
<p class="Sp-text-1"><a id="c3-para-1179"/>        <b>return</b> front_queue(segment_queue(first_seg));</p>
<p class="Sp-text-1"><a id="c3-para-1180"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1181"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0059"/><a id="c3-title-0060"/>Exercise 3.32</h5>
<p class="paraaftertitle"><a id="c3-para-1182"/>The functions to be run during each time segment of the agenda are kept in a queue. Thus, the functions for each segment are called in the order in which they were added to the agenda (first in, first out). Explain why this order must be used. In particular, trace the behavior of an and-gate whose inputs change from 0,1 to 1,0 in the same segment and say how the behavior would differ if we stored a segment's functions in an ordinary list, adding and removing functions only at the front (last in, first out).</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0060"/><span>3.3.5</span> <a id="c3-title-0061"/>Propagation of Constraints</h3>
<p class="paraaftertitle"><a id="c3-para-1183"/>Computer programs are traditionally organized as one-directional computations, which perform operations on prespecified arguments to produce desired outputs. On the other hand, we often model systems in terms of relations among quantities. For example, a mathematical model of a mechanical structure might include the information that the deflection <i>d</i> of a metal rod is related to the force <i>F</i> on the rod, the length <i>L</i> of the rod, the cross-sectional area <i>A</i>, and the elastic modulus <i>E</i> via the equation</p>
<p class="Sp-text-2"><a id="c3-para-1184"/><i>dAE</i> = <i>FL</i></p>
<p class="paracontinue"><a id="c3-para-1185"/>Such an equation is not one-directional. Given any four of the quantities, we can use it to compute the fifth. Yet translating the equation into a traditional computer language would force us to choose one of the quantities to be computed in terms of the other four. Thus, a function for computing the area <i>A</i> could not be used to compute the deflection <i>d</i>, even though the computations of <i>A</i> and <i>d</i> arise from the same equation.<a id="c3-fn-0034a"/><a href="#c3-fn-0034"><sup>34</sup></a></p>
<p><a id="c3-para-1186"/>In this section, we sketch the design of a language that enables us to work in terms of relations themselves. The primitive elements of the language are <i>primitive constraints</i>, which state that certain relations hold between quantities. For example, <span class="KeyTerm1">adder(a, b, c)</span> specifies that the quantities <i>a</i>, <i>b</i>, and <i>c</i> must be related by the equation <i>a</i> + <i>b</i> = <i>c</i>, <span class="KeyTerm1">multiplier(x, y, z)</span> expresses the constraint <i>xy</i> = <i>z</i>, and <span class="KeyTerm1">constant(3.14, x)</span> says that the value of <i>x</i> must be 3.14.</p>
<p><a id="c3-para-1187"/>Our language provides a means of combining primitive constraints in order to express more complex relations. We combine constraints by constructing <i>constraint networks</i>, in which constraints are joined by <i>connectors</i>. A connector is an object that “holds” a value that may participate in one or more constraints. For example, we know that the relationship between Fahrenheit and Celsius temperatures is</p>
<p class="Sp-text-2"><a id="c3-para-1188"/>9<i>C</i> = 5(<i>F</i> – 32)</p>
<p class="paracontinue"><a id="c3-para-1189"/>Such a constraint can be thought of as a network consisting of primitive adder, multiplier, and constant constraints (<a id="c3-fig-0028a"/><a href="#c3-fig-0028">figure 3.28</a>). In the figure, we see on the left a multiplier box with three terminals, labeled <i>m</i><sub>1</sub>, <i>m</i><sub>2</sub>, and <i>p</i>. These connect the multiplier to the rest of the network as follows: The <i>m</i><sub>1</sub> terminal is linked to a connector <i>C</i>, which will hold the Celsius temperature. The <i>m</i><sub>2</sub> terminal is linked to a connector <i>w</i>, which is also linked to a constant box that holds 9. The <i>p</i> terminal, which the multiplier box constrains to be the product of <i>m</i><sub>1</sub> and <i>m</i><sub>2</sub>, is linked to the <i>p</i> terminal of another multiplier box, whose <i>m</i><sub>2</sub> is connected to a constant 5 and whose <i>m</i><sub>1</sub> is connected to one of the terms in a sum.</p>
<figure id="c3-fig-0028"><img alt="c3-fig-0028.jpg" src="../images/c3-fig-0028.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0028a">Figure 3.28</a></span> <a id="c3-para-1190"/>The relation 9C = 5(F – 32) expressed as a constraint network.</p></figcaption></figure>
<p><a id="c3-para-1191"/>Computation by such a network proceeds as follows: When a connector is given a value (by the user or by a constraint box to which it is linked), it awakens all of its associated constraints (except for the constraint that just awakened it) to inform them that it has a value. Each awakened constraint box then polls its connectors to see if there is enough information to determine a value for a connector. If so, the box sets that connector, which then awakens all of its associated constraints, and so on. For instance, in conversion between Celsius and Fahrenheit, <i>w</i>, <i>x</i>, and <i>y</i> are immediately set by the constant boxes to 9, 5, and 32, respectively. The connectors awaken the multipliers and the adder, which determine that there is not enough information to proceed. If the user (or some other part of the network) sets <i>C</i> to a value (say 25), the leftmost multiplier will be awakened, and it will set <i>u</i> to 25 9 = 225. Then <i>u</i> awakens the second multiplier, which sets <i>v</i> to 45, and <i>v</i> awakens the adder, which sets <i>F</i> to 77.</p>
<section>
<h5><a id="c3-sec-0061"/><a id="c3-title-0062"/>Using the constraint system</h5>
<p class="paraaftertitle"><a id="c3-para-1192"/>To use the constraint system to carry out the temperature computation outlined above, we first call the constructor <span class="KeyTerm1">make_connector</span> to create two connectors, <span class="KeyTerm1">C</span> and <span class="KeyTerm1">F</span>, and then link them in an appropriate network:</p>
<p class="Sp-text-1"><a id="c3-para-1193"/><b>const</b> C = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1194"/><b>const</b> F = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1195"/>celsius_fahrenheit_converter(C, F);</p>
<p class="Sp-text-1"><a id="c3-para-1196"/><i>"ok"</i></p>
<p class="paracontinue"><a id="c3-para-1197"/>The function that creates the network is defined as follows:</p>
<p class="Sp-text-1"><a id="c3-para-1198"/><b>function</b> celsius_fahrenheit_converter(c, f) {</p>
<p class="Sp-text-1"><a id="c3-para-1199"/>    <b>const</b> u = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1200"/>    <b>const</b> v = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1201"/>    <b>const</b> w = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1202"/>    <b>const</b> x = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1203"/>    <b>const</b> y = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1204"/>    multiplier(c, w, u);</p>
<p class="Sp-text-1"><a id="c3-para-1205"/>    multiplier(v, x, u);</p>
<p class="Sp-text-1"><a id="c3-para-1206"/>    adder(v, y, f);</p>
<p class="Sp-text-1"><a id="c3-para-1207"/>    constant(9, w);</p>
<p class="Sp-text-1"><a id="c3-para-1208"/>    constant(5, x);</p>
<p class="Sp-text-1"><a id="c3-para-1209"/>    constant(32, y);</p>
<p class="Sp-text-1"><a id="c3-para-1210"/>    <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c3-para-1211"/>}</p>
<p class="paracontinue"><a id="c3-para-1212"/>This function creates the internal connectors <span class="KeyTerm1">u</span>, <span class="KeyTerm1">v</span>, <span class="KeyTerm1">w</span>, <span class="KeyTerm1">x</span>, and <span class="KeyTerm1">y</span>, and links them as shown in <a href="#c3-fig-0028">figure 3.28</a> using the primitive constraint constructors <span class="KeyTerm1">adder</span>, <span class="KeyTerm1">multiplier</span>, and <span class="KeyTerm1">constant</span>. Just as with the digital-circuit simulator of section 3.3.4, expressing these combinations of primitive elements in terms of functions automatically provides our language with a means of abstraction for compound objects.</p>
<p><a id="c3-para-1213"/>To watch the network in action, we can place probes on the connectors <span class="KeyTerm1">C</span> and <span class="KeyTerm1">F</span>, using a <span class="KeyTerm1">probe</span> function similar to the one we used to monitor wires in section 3.3.4. Placing a probe on a connector will cause a message to be printed whenever the connector is given a value:</p>
<p class="Sp-text-1"><a id="c3-para-1214"/>probe("Celsius temp", C);</p>
<p class="Sp-text-1"><a id="c3-para-1215"/>probe("Fahrenheit temp", F);</p>
<p class="paracontinue"><a id="c3-para-1216"/>Next we set the value of <span class="KeyTerm1">C</span> to 25. (The third argument to <span class="KeyTerm1">set_value</span> tells <span class="KeyTerm1">C</span> that this directive comes from the <span class="KeyTerm1">user</span>.)</p>
<p class="Sp-text-1"><a id="c3-para-1217"/>set_value(C, 25, "user");</p>
<p class="Sp-text-1"><a id="c3-para-1218"/><i>"Probe: Celsius temp = 25"</i></p>
<p class="Sp-text-1"><a id="c3-para-1219"/><i>"Probe: Fahrenheit temp = 77"</i></p>
<p class="Sp-text-1"><a id="c3-para-1220"/><i>"done"</i></p>
<p class="paracontinue"><a id="c3-para-1221"/>The probe on <span class="KeyTerm1">C</span> awakens and reports the value. <span class="KeyTerm1">C</span> also propagates its value through the network as described above. This sets <span class="KeyTerm1">F</span> to 77, which is reported by the probe on <span class="KeyTerm1">F</span>.</p>
<p><a id="c3-para-1222"/>Now we can try to set <span class="KeyTerm1">F</span> to a new value, say 212:</p>
<p class="Sp-text-1"><a id="c3-para-1223"/>set_value(F, 212, "user");</p>
<p class="Sp-text-1"><a id="c3-para-1224"/><i>"Error! Contradiction: (77, 212)"</i></p>
<p class="paracontinue"><a id="c3-para-1225"/>The connector complains that it has sensed a contradiction: Its value is 77, and someone is trying to set it to 212. If we really want to reuse the network with new values, we can tell <span class="KeyTerm1">C</span> to forget its old value:</p>
<p class="Sp-text-1"><a id="c3-para-1226"/>forget_value(C, "user");</p>
<p class="Sp-text-1"><a id="c3-para-1227"/><i>"Probe: Celsius temp = ?"</i></p>
<p class="Sp-text-1"><a id="c3-para-1228"/><i>"Probe: Fahrenheit temp = ?"</i></p>
<p class="Sp-text-1"><a id="c3-para-1229"/><i>"done"</i></p>
<p class="paracontinue"><a id="c3-para-1230"/><span class="KeyTerm1">C</span> finds that the <span class="KeyTerm1">"user"</span>, who set its value originally, is now retracting that value, so <span class="KeyTerm1">C</span> agrees to lose its value, as shown by the probe, and informs the rest of the network of this fact. This information eventually propagates to <span class="KeyTerm1">F</span>, which now finds that it has no reason for continuing to believe that its own value is 77. Thus, <span class="KeyTerm1">F</span> also gives up its value, as shown by the probe.</p>
<p><a id="c3-para-1231"/>Now that <span class="KeyTerm1">F</span> has no value, we are free to set it to 212:</p>
<p class="Sp-text-1"><a id="c3-para-1232"/>set_value(F, 212, "user");</p>
<p class="Sp-text-1"><a id="c3-para-1233"/><i>"Probe: Fahrenheit temp = 212"</i></p>
<p class="Sp-text-1"><a id="c3-para-1234"/><i>"Probe: Celsius temp = 100"</i></p>
<p class="Sp-text-1"><a id="c3-para-1235"/><i>"done"</i>?</p>
<p class="paracontinue"><a id="c3-para-1236"/>This new value, when propagated through the network, forces <span class="KeyTerm1">C</span> to have a value of 100, and this is registered by the probe on <span class="KeyTerm1">C</span>. Notice that the very same network is being used to compute <span class="KeyTerm1">C</span> given <span class="KeyTerm1">F</span> and to compute <span class="KeyTerm1">F</span> given <span class="KeyTerm1">C</span>. This nondirectionality of computation is the distinguishing feature of constraint-based systems.</p>
</section>
<section>
<h5><a id="c3-sec-0062"/><a id="c3-title-0063"/>Implementing the constraint system</h5>
<p class="paraaftertitle"><a id="c3-para-1237"/>The constraint system is implemented via procedural objects with local state, in a manner very similar to the digital-circuit simulator of section 3.3.4. Although the primitive objects of the constraint system are somewhat more complex, the overall system is simpler, since there is no concern about agendas and logic delays.</p>
<p><a id="c3-para-1238"/>The basic operations on connectors are the following:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">has_value(</span><i>connector</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-1240"/>tells whether the connector has a value.</p></li>
<li><span class="KeyTerm1">get_value(</span><i>connector</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-1242"/>returns the connector's current value.</p></li>
<li><span class="KeyTerm1">set_value(</span><i>connector</i><span class="KeyTerm1">,</span> <i>new</i>-<i>value</i><span class="KeyTerm1">,</span> <i>informant</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-1244"/>indicates that the informant is requesting the connector to set its value to the new value.</p></li>
<li><span class="KeyTerm1">forget_value(</span><i>connector</i><span class="KeyTerm1">,</span> <i>retractor</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-1246"/>tells the connector that the retractor is requesting it to forget its value.</p></li>
<li><span class="KeyTerm1">connect(</span><i>connector</i><span class="KeyTerm1">,</span> <i>new</i>-<i>constraint</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c3-para-1248"/>tells the connector to participate in the new constraint.</p></li>
</ul>

<p class="paracontinue"><a id="c3-para-1249"/>The connectors communicate with the constraints by means of the functions <span class="KeyTerm1">inform_ about_value</span>, which tells the given constraint that the connector has a value, and <span class="KeyTerm1">inform_about_no_value</span>, which tells the constraint that the connector has lost its value.</p>
<p><a id="c3-para-1250"/><span class="KeyTerm1">Adder</span> constructs an adder constraint among summand connectors <span class="KeyTerm1">a1</span> and <span class="KeyTerm1">a2</span> and a <span class="KeyTerm1">sum</span> connector. An adder is implemented as a function with local state (the function <span class="KeyTerm1">me</span> below):</p>
<p class="Sp-text-1"><a id="c3-para-1251"/><b>function</b> adder(a1, a2, sum) {</p>
<p class="Sp-text-1"><a id="c3-para-1252"/>    <b>function</b> process_new_value() {</p>
<p class="Sp-text-1"><a id="c3-para-1253"/>        <b>if</b> (has_value(a1) &amp;&amp; has_value(a2)) {</p>
<p class="Sp-text-1"><a id="c3-para-1254"/>            set_value(sum, get_value(a1) + get_value(a2), me);</p>
<p class="Sp-text-1"><a id="c3-para-1255"/>        } <b>else if</b> (has_value(a1) &amp;&amp; has_value(sum)) {</p>
<p class="Sp-text-1"><a id="c3-para-1256"/>            set_value(a2, get_value(sum) - get_value(a1), me);</p>
<p class="Sp-text-1"><a id="c3-para-1257"/>        } <b>else if</b> (has_value(a2) &amp;&amp; has_value(sum)) {</p>
<p class="Sp-text-1"><a id="c3-para-1258"/>            set_value(a1, get_value(sum) - get_value(a2), me);</p>
<p class="Sp-text-1"><a id="c3-para-1259"/>        } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c3-para-1260"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1261"/>    <b>function</b> process_forget_value() {</p>
<p class="Sp-text-1"><a id="c3-para-1262"/>        forget_value(sum, me);</p>
<p class="Sp-text-1"><a id="c3-para-1263"/>        forget_value(a1, me);</p>
<p class="Sp-text-1"><a id="c3-para-1264"/>        forget_value(a2, me);</p>
<p class="Sp-text-1"><a id="c3-para-1265"/>        process_new_value();</p>
<p class="Sp-text-1"><a id="c3-para-1266"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1267"/>    <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c3-para-1268"/>        <b>if</b> (request === "I have a value.") {</p>
<p class="Sp-text-1"><a id="c3-para-1269"/>            process_new_value();</p>
<p class="Sp-text-1"><a id="c3-para-1270"/>        } <b>else if</b> (request === "I lost my value.") {</p>
<p class="Sp-text-1"><a id="c3-para-1271"/>            process_forget_value();</p>
<p class="Sp-text-1"><a id="c3-para-1272"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1273"/>            error(request, "unknown request – adder");</p>
<p class="Sp-text-1"><a id="c3-para-1274"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1275"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1276"/>    connect(a1, me);</p>
<p class="Sp-text-1"><a id="c3-para-1277"/>    connect(a2, me);</p>
<p class="Sp-text-1"><a id="c3-para-1278"/>    connect(sum, me);</p>
<p class="Sp-text-1"><a id="c3-para-1279"/>    <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c3-para-1280"/>}</p>
<p class="paracontinue"><a id="c3-para-1281"/>The function <span class="KeyTerm1">adder</span> connects the new adder to the designated connectors and returns it as its value. The function <span class="KeyTerm1">me</span>, which represents the adder, acts as a dispatch to the local functions. The following “syntax interfaces” (see footnote 30 in section 3.3.4) are used in conjunction with the dispatch:</p>
<p class="Sp-text-1"><a id="c3-para-1282"/><b>function</b> inform_about_value(constraint) {</p>
<p class="Sp-text-1"><a id="c3-para-1283"/>    <b>return</b> constraint("I have a value.");</p>
<p class="Sp-text-1"><a id="c3-para-1284"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1285"/><b>function</b> inform_about_no_value(constraint) {</p>
<p class="Sp-text-1"><a id="c3-para-1286"/>    <b>return</b> constraint("I lost my value.");</p>
<p class="Sp-text-1"><a id="c3-para-1287"/>}</p>
<p class="paracontinue"><a id="c3-para-1288"/>The adder's local function <span class="KeyTerm1">process_new_value</span> is called when the adder is informed that one of its connectors has a value. The adder first checks to see if both <span class="KeyTerm1">a1</span> and <span class="KeyTerm1">a2</span> have values. If so, it tells <span class="KeyTerm1">sum</span> to set its value to the sum of the two addends. The <span class="KeyTerm1">informant</span> argument to <span class="KeyTerm1">set_value</span> is <span class="KeyTerm1">me</span>, which is the adder object itself. If <span class="KeyTerm1">a1</span> and <span class="KeyTerm1">a2</span> do not both have values, then the adder checks to see if perhaps <span class="KeyTerm1">a1</span> and <span class="KeyTerm1">sum</span> have values. If so, it sets <span class="KeyTerm1">a2</span> to the difference of these two. Finally, if <span class="KeyTerm1">a2</span> and <span class="KeyTerm1">sum</span> have values, this gives the adder enough information to set <span class="KeyTerm1">a1</span>. If the adder is told that one of its connectors has lost a value, it requests that all of its connectors now lose their values. (Only those values that were set by this adder are actually lost.) Then it runs <span class="KeyTerm1">process_new_value</span>. The reason for this last step is that one or more connectors may still have a value (that is, a connector may have had a value that was not originally set by the adder), and these values may need to be propagated back through the adder.</p>
<p><a id="c3-para-1289"/>A multiplier is very similar to an adder. It will set its <span class="KeyTerm1">product</span> to 0 if either of the factors is 0, even if the other factor is not known.</p>
<p class="Sp-text-1"><a id="c3-para-1290"/><b>function</b> multiplier(m1, m2, product) {</p>
<p class="Sp-text-1"><a id="c3-para-1291"/>    <b>function</b> process_new_value() {</p>
<p class="Sp-text-1"><a id="c3-para-1292"/>        <b>if</b> ((has_value(m1) &amp;&amp; get_value(m1) === 0)</p>
<p class="Sp-text-1"><a id="c3-para-1293"/>         || (has_value(m2) &amp;&amp; get_value(m2) === 0)) {</p>
<p class="Sp-text-1"><a id="c3-para-1294"/>            set_value(product, 0, me);</p>
<p class="Sp-text-1"><a id="c3-para-1295"/>        } <b>else if</b> (has_value(m1) &amp;&amp; has_value(m2)) {</p>
<p class="Sp-text-1"><a id="c3-para-1296"/>            set_value(product, get_value(m1) * get_value(m2), me);</p>
<p class="Sp-text-1"><a id="c3-para-1297"/>        } <b>else if</b> (has_value(product) &amp;&amp; has_value(m1)) {</p>
<p class="Sp-text-1"><a id="c3-para-1298"/>            set_value(m2, get_value(product) / get_value(m1), me);</p>
<p class="Sp-text-1"><a id="c3-para-1299"/>        } <b>else if</b> (has_value(product) &amp;&amp; has_value(m2)) {</p>
<p class="Sp-text-1"><a id="c3-para-1300"/>            set_value(m1, get_value(product) / get_value(m2), me);</p>
<p class="Sp-text-1"><a id="c3-para-1301"/>        } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c3-para-1302"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1303"/>    <b>function</b> process_forget_value() {</p>
<p class="Sp-text-1"><a id="c3-para-1304"/>        forget_value(product, me);</p>
<p class="Sp-text-1"><a id="c3-para-1305"/>        forget_value(m1, me);</p>
<p class="Sp-text-1"><a id="c3-para-1306"/>        forget_value(m2, me);</p>
<p class="Sp-text-1"><a id="c3-para-1307"/>        process_new_value();</p>
<p class="Sp-text-1"><a id="c3-para-1308"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1309"/>    <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c3-para-1310"/>        <b>if</b> (request === "I have a value.") {</p>
<p class="Sp-text-1"><a id="c3-para-1311"/>            process_new_value();</p>
<p class="Sp-text-1"><a id="c3-para-1312"/>        } <b>else if</b> (request === "I lost my value.") {</p>
<p class="Sp-text-1"><a id="c3-para-1313"/>            process_forget_value();</p>
<p class="Sp-text-1"><a id="c3-para-1314"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1315"/>            error(request, "unknown request – multiplier");</p>
<p class="Sp-text-1"><a id="c3-para-1316"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1317"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1318"/>    connect(m1, me);</p>
<p class="Sp-text-1"><a id="c3-para-1319"/>    connect(m2, me);</p>
<p class="Sp-text-1"><a id="c3-para-1320"/>    connect(product, me);</p>
<p class="Sp-text-1"><a id="c3-para-1321"/>    <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c3-para-1322"/>}</p>
<p class="paracontinue"><a id="c3-para-1323"/>A <span class="KeyTerm1">constant</span> constructor simply sets the value of the designated connector. Any <span class="KeyTerm1">"I have a value."</span> or <span class="KeyTerm1">"I lost my value."</span> message sent to the constant box will produce an error.</p>
<p class="Sp-text-1"><a id="c3-para-1324"/><b>function</b> constant(value, connector) {</p>
<p class="Sp-text-1"><a id="c3-para-1325"/>    <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c3-para-1326"/>        error(request, "unknown request – constant");</p>
<p class="Sp-text-1"><a id="c3-para-1327"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1328"/>    connect(connector, me);</p>
<p class="Sp-text-1"><a id="c3-para-1329"/>    set_value(connector, value, me);</p>
<p class="Sp-text-1"><a id="c3-para-1330"/>    <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c3-para-1331"/>}</p>
<p class="paracontinue"><a id="c3-para-1332"/>Finally, a probe prints a message about the setting or unsetting of the designated connector:</p>
<p class="Sp-text-1"><a id="c3-para-1333"/><b>function</b> probe(name, connector) {</p>
<p class="Sp-text-1"><a id="c3-para-1334"/>    <b>function</b> print_probe(value) {</p>
<p class="Sp-text-1"><a id="c3-para-1335"/>        display("Probe: " + name + " = " + stringify(value));</p>
<p class="Sp-text-1"><a id="c3-para-1336"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1337"/>    <b>function</b> process_new_value() {</p>
<p class="Sp-text-1"><a id="c3-para-1338"/>        print_probe(get_value(connector));</p>
<p class="Sp-text-1"><a id="c3-para-1339"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1340"/>    <b>function</b> process_forget_value() {</p>
<p class="Sp-text-1"><a id="c3-para-1341"/>        print_probe("?");</p>
<p class="Sp-text-1"><a id="c3-para-1342"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1343"/>    <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c3-para-1344"/>        <b>return</b> request === "I have a value."</p>
<p class="Sp-text-1"><a id="c3-para-1345"/>               ? process_new_value()</p>
<p class="Sp-text-1"><a id="c3-para-1346"/>               : request === "I lost my value."</p>
<p class="Sp-text-1"><a id="c3-para-1347"/>               ? process_forget_value()</p>
<p class="Sp-text-1"><a id="c3-para-1348"/>               : error(request, "unknown request – probe");</p>
<p class="Sp-text-1"><a id="c3-para-1349"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1350"/>    connect(connector, me);</p>
<p class="Sp-text-1"><a id="c3-para-1351"/>    <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c3-para-1352"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0063"/><a id="c3-title-0064"/>Representing connectors</h5>
<p class="paraaftertitle"><a id="c3-para-1353"/>A connector is represented as a procedural object with local state variables <span class="KeyTerm1">value</span>, the current value of the connector; <span class="KeyTerm1">informant</span>, the object that set the connector's value; and <span class="KeyTerm1">constraints</span>, a list of the constraints in which the connector participates.</p>
<p class="Sp-text-1"><a id="c3-para-1354"/><b>function</b> make_connector() {</p>
<p class="Sp-text-1"><a id="c3-para-1355"/>    <b>let</b> value = <b>false</b>;</p>
<p class="Sp-text-1"><a id="c3-para-1356"/>    <b>let</b> informant = <b>false</b>;</p>
<p class="Sp-text-1"><a id="c3-para-1357"/>    <b>let</b> constraints = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c3-para-1358"/>    <b>function</b> set_my_value(newval, setter) {</p>
<p class="Sp-text-1"><a id="c3-para-1359"/>        <b>if</b> (!has_value(me)) {</p>
<p class="Sp-text-1"><a id="c3-para-1360"/>            value = newval;</p>
<p class="Sp-text-1"><a id="c3-para-1361"/>            informant = setter;</p>
<p class="Sp-text-1"><a id="c3-para-1362"/>            <b>return</b> for_each_except(setter,</p>
<p class="Sp-text-1"><a id="c3-para-1363"/>                                   inform_about_value,</p>
<p class="Sp-text-1"><a id="c3-para-1364"/>                                   constraints);</p>
<p class="Sp-text-1"><a id="c3-para-1365"/>        } <b>else if</b> (value !== newval) {</p>
<p class="Sp-text-1"><a id="c3-para-1366"/>            error(list(value, newval), "contradiction");</p>
<p class="Sp-text-1"><a id="c3-para-1367"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1368"/>            <b>return</b> "ignored";</p>
<p class="Sp-text-1"><a id="c3-para-1369"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1370"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1371"/>    <b>function</b> forget_my_value(retractor) {</p>
<p class="Sp-text-1"><a id="c3-para-1372"/>        <b>if</b> (retractor === informant) {</p>
<p class="Sp-text-1"><a id="c3-para-1373"/>            informant = <b>false</b>;</p>
<p class="Sp-text-1"><a id="c3-para-1374"/>            <b>return</b> for_each_except(retractor,</p>
<p class="Sp-text-1"><a id="c3-para-1375"/>                                   inform_about_no_value,</p>
<p class="Sp-text-1"><a id="c3-para-1376"/>                                   constraints);</p>
<p class="Sp-text-1"><a id="c3-para-1377"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1378"/>            <b>return</b> "ignored";</p>
<p class="Sp-text-1"><a id="c3-para-1379"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1380"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1381"/>    <b>function</b> connect(new_constraint) {</p>
<p class="Sp-text-1"><a id="c3-para-1382"/>        <b>if</b> (is_null(member(new_constraint, constraints))) {</p>
<p class="Sp-text-1"><a id="c3-para-1383"/>            constraints = pair(new_constraint, constraints);</p>
<p class="Sp-text-1"><a id="c3-para-1384"/>        } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c3-para-1385"/>        <b>if</b> (has_value(me)) {</p>
<p class="Sp-text-1"><a id="c3-para-1386"/>            inform_about_value(new_constraint);</p>
<p class="Sp-text-1"><a id="c3-para-1387"/>        } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c3-para-1388"/>        <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c3-para-1389"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1390"/>    <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c3-para-1391"/>        <b>if</b> (request === "has_value") {</p>
<p class="Sp-text-1"><a id="c3-para-1392"/>            <b>return</b> informant !== <b>false</b>;</p>
<p class="Sp-text-1"><a id="c3-para-1393"/>        } <b>else if</b> (request === "value") {</p>
<p class="Sp-text-1"><a id="c3-para-1394"/>            <b>return</b> value;</p>
<p class="Sp-text-1"><a id="c3-para-1395"/>        } <b>else if</b> (request === "set_value") {</p>
<p class="Sp-text-1"><a id="c3-para-1396"/>            <b>return</b> set_my_value;</p>
<p class="Sp-text-1"><a id="c3-para-1397"/>        } <b>else if</b> (request === "forget") {</p>
<p class="Sp-text-1"><a id="c3-para-1398"/>            <b>return</b> forget_my_value;</p>
<p class="Sp-text-1"><a id="c3-para-1399"/>        } <b>else if</b> (request === "connect") {</p>
<p class="Sp-text-1"><a id="c3-para-1400"/>            <b>return</b> connect;</p>
<p class="Sp-text-1"><a id="c3-para-1401"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1402"/>            error(request, "unknown operation – connector");</p>
<p class="Sp-text-1"><a id="c3-para-1403"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1404"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1405"/>    <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c3-para-1406"/>}</p>
<p><a id="c3-para-1407"/>The connector's local function <span class="KeyTerm1">set_my_value</span> is called when there is a request to set the connector's value. If the connector does not currently have a value, it will set its value and remember as <span class="KeyTerm1">informant</span> the constraint that requested the value to be set.<a id="c3-fn-0035a"/><a href="#c3-fn-0035"><sup>35</sup></a> Then the connector will notify all of its participating constraints except the constraint that requested the value to be set. This is accomplished using the following iterator, which applies a designated function to all items in a list except a given one:</p>
<p class="Sp-text-1"><a id="c3-para-1408"/><b>function</b> for_each_except(exception, fun, list) {</p>
<p class="Sp-text-1"><a id="c3-para-1409"/>    <b>function</b> loop(items) {</p>
<p class="Sp-text-1"><a id="c3-para-1410"/>        <b>if</b> (is_null(items)) {</p>
<p class="Sp-text-1"><a id="c3-para-1411"/>            <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c3-para-1412"/>        } <b>else if</b> (head(items) === exception) {</p>
<p class="Sp-text-1"><a id="c3-para-1413"/>            <b>return</b> loop(tail(items));</p>
<p class="Sp-text-1"><a id="c3-para-1414"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1415"/>            fun(head(items));</p>
<p class="Sp-text-1"><a id="c3-para-1416"/>            <b>return</b> loop(tail(items));</p>
<p class="Sp-text-1"><a id="c3-para-1417"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1418"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1419"/>    <b>return</b> loop(list);</p>
<p class="Sp-text-1"><a id="c3-para-1420"/>}</p>
<p><a id="c3-para-1421"/>If a connector is asked to forget its value, it runs <span class="KeyTerm1">forget_my_value</span>, a local function that first checks to make sure that the request is coming from the same object that set the value originally. If so, the connector informs its associated constraints about the loss of the value.</p>
<p><a id="c3-para-1422"/>The local function <span class="KeyTerm1">connect</span> adds the designated new constraint to the list of constraints if it is not already in that list.<a id="c3-fn-0036a"/><a href="#c3-fn-0036"><sup>36</sup></a> Then, if the connector has a value, it informs the new constraint of this fact.</p>
<p><a id="c3-para-1423"/>The connector's function <span class="KeyTerm1">me</span> serves as a dispatch to the other internal functions and also represents the connector as an object. The following functions provide a syntax interface for the dispatch:</p>
<p class="Sp-text-1"><a id="c3-para-1424"/><b>function</b> has_value(connector) {</p>
<p class="Sp-text-1"><a id="c3-para-1425"/>    <b>return</b> connector("has_value");</p>
<p class="Sp-text-1"><a id="c3-para-1426"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1427"/><b>function</b> get_value(connector) {</p>
<p class="Sp-text-1"><a id="c3-para-1428"/>    <b>return</b> connector("value");</p>
<p class="Sp-text-1"><a id="c3-para-1429"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1430"/><b>function</b> set_value(connector, new_value, informant) {</p>
<p class="Sp-text-1"><a id="c3-para-1431"/>    <b>return</b> connector("set_value")(new_value, informant);</p>
<p class="Sp-text-1"><a id="c3-para-1432"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1433"/><b>function</b> forget_value(connector, retractor) {</p>
<p class="Sp-text-1"><a id="c3-para-1434"/>    <b>return</b> connector("forget")(retractor);</p>
<p class="Sp-text-1"><a id="c3-para-1435"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1436"/><b>function</b> connect(connector, new_constraint) {</p>
<p class="Sp-text-1"><a id="c3-para-1437"/>   <b>return</b> connector("connect")(new_constraint);</p>
<p class="Sp-text-1"><a id="c3-para-1438"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0064"/><a id="c3-title-0065"/>Exercise 3.33</h5>
<p class="paraaftertitle"><a id="c3-para-1439"/>Using primitive multiplier, adder, and constant constraints, define a function averager that takes three connectors <span class="KeyTerm1">a</span>, <span class="KeyTerm1">b</span>, and <span class="KeyTerm1">c</span> as inputs and establishes the constraint that the value of c is the average of the values of a and b.</p>
</section>
<section>
<h5><a id="c3-sec-0065"/><a id="c3-title-0066"/>Exercise 3.34</h5>
<p class="paraaftertitle"><a id="c3-para-1440"/>Louis Reasoner wants to build a squarer, a constraint device with two terminals such that the value of connector b on the second terminal will always be the square of the value a on the first terminal. He proposes the following simple device made from a multiplier:</p>
<p class="Sp-text-1"><a id="c3-para-1441"/><b>function</b> squarer(a, b) {</p>
<p class="Sp-text-1"><a id="c3-para-1442"/>    <b>return</b> multiplier(a, a, b);</p>
<p class="Sp-text-1"><a id="c3-para-1443"/>}</p>
<p class="paracontinue"><a id="c3-para-1444"/>There is a serious flaw in this idea. Explain.</p>
</section>
<section>
<h5><a id="c3-sec-0066"/><a id="c3-title-0067"/>Exercise 3.35</h5>
<p class="paraaftertitle"><a id="c3-para-1445"/>Ben Bitdiddle tells Louis that one way to avoid the trouble in exercise 3.34 is to define a squarer as a new primitive constraint. Fill in the missing portions in Ben's outline for a function to implement such a constraint:</p>
<p class="Sp-text-1"><a id="c3-para-1446"/><b>function</b> squarer(a, b) {</p>
<p class="Sp-text-1"><a id="c3-para-1447"/>    <b>function</b> process_new_value() {</p>
<p class="Sp-text-1"><a id="c3-para-1448"/>        <b>if</b> (has_value(b)) {</p>
<p class="Sp-text-1"><a id="c3-para-1449"/>            <b>if</b> (get_value(b) &lt; 0) {</p>
<p class="Sp-text-1"><a id="c3-para-1450"/>                error(get_value(b), "square less than 0 – squarer");</p>
<p class="Sp-text-1"><a id="c3-para-1451"/>            } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1452"/>                <span class="KeyTerm2"><i>alternative<sub>1</sub></i></span></p>
<p class="Sp-text-1"><a id="c3-para-1453"/>            }</p>
<p class="Sp-text-1"><a id="c3-para-1454"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1455"/>            <span class="KeyTerm2"><i>alternative<sub>2</sub></i></span></p>
<p class="Sp-text-1"><a id="c3-para-1456"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1457"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1458"/>    <b>function</b> process_forget_value() {</p>
<p class="Sp-text-1"><a id="c3-para-1459"/>        <span class="KeyTerm2"><i>body<sub>1</sub></i></span></p>
<p class="Sp-text-1"><a id="c3-para-1460"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1461"/>    <b>function</b> me(request) {</p>
<p class="Sp-text-1"><a id="c3-para-1462"/>        <span class="KeyTerm2"><i>body<sub>2</sub></i></span></p>
<p class="Sp-text-1"><a id="c3-para-1463"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1464"/>    <span class="KeyTerm2"><i>statements</i></span></p>
<p class="Sp-text-1"><a id="c3-para-1465"/>    <b>return</b> me;</p>
<p class="Sp-text-1"><a id="c3-para-1466"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0067"/><a id="c3-title-0068"/>Exercise 3.36</h5>
<p class="paraaftertitle"><a id="c3-para-1467"/>Suppose we evaluate the following sequence of statements in the program environment:</p>
<p class="Sp-text-1"><a id="c3-para-1468"/><b>const</b> a = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1469"/><b>const</b> b = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1470"/>set_value(a, 10, "user");</p>
<p class="paracontinue"><a id="c3-para-1471"/>At some time during evaluation of the <span class="KeyTerm1">set_value</span>, the following expression from the connector's local function is evaluated:</p>
<p class="Sp-text-1"><a id="c3-para-1472"/>for_each_except(setter, inform_about_value, constraints);</p>
<p class="paracontinue"><a id="c3-para-1473"/>Draw an environment diagram showing the environment in which the above expression is evaluated.</p>
</section>
<section>
<h5><a id="c3-sec-0068"/><a id="c3-title-0069"/>Exercise 3.37</h5>
<p class="paraaftertitle"><a id="c3-para-1474"/>The <span class="KeyTerm1">celsius_fahrenheit_converter</span> function is cumbersome when compared with a more expression-oriented style of definition, such as</p>
<p class="Sp-text-1"><a id="c3-para-1475"/><b>function</b> celsius_fahrenheit_converter(x) {</p>
<p class="Sp-text-1"><a id="c3-para-1476"/>   <b>return</b> cplus(cmul(cdiv(cv(9), cv(5)), x), cv(32));</p>
<p class="Sp-text-1"><a id="c3-para-1477"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-1478"/><b>const</b> C = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1479"/><b>const</b> F = celsius_fahrenheit_converter(C);</p>
<p class="paracontinue"><a id="c3-para-1480"/>Here <span class="KeyTerm1">cplus</span>, <span class="KeyTerm1">cmul</span>, etc. are the “constraint” versions of the arithmetic operations. For example, <span class="KeyTerm1">cplus</span> takes two connectors as arguments and returns a connector that is related to these by an adder constraint:</p>
<p class="Sp-text-1"><a id="c3-para-1481"/><b>function</b> cplus(x, y) {</p>
<p class="Sp-text-1"><a id="c3-para-1482"/>    <b>const</b> z = make_connector();</p>
<p class="Sp-text-1"><a id="c3-para-1483"/>    adder(x, y, z);</p>
<p class="Sp-text-1"><a id="c3-para-1484"/>    <b>return</b> z;</p>
<p class="Sp-text-1"><a id="c3-para-1485"/>}</p>
<p class="paracontinue"><a id="c3-para-1486"/>Define analogous functions <span class="KeyTerm1">cminus</span>, <span class="KeyTerm1">cmul</span>, <span class="KeyTerm1">cdiv</span>, and <span class="KeyTerm1">cv</span> (constant value) that enable us to define compound constraints as in the converter example above.<a id="c3-fn-0037a"/><a href="#c3-fn-0037"><sup>37</sup></a></p>
</section>
</section>
</section>
<section>
<h2><a id="c3-sec-0069"/><span>3.4</span> <a id="c3-title-0070"/>Concurrency: Time Is of the Essence</h2>
<p class="paraaftertitle"><a id="c3-para-1492"/>We've seen the power of computational objects with local state as tools for modeling. Yet, as section 3.1.3 warned, this power extracts a price: the loss of referential transparency, giving rise to a thicket of questions about sameness and change, and the need to abandon the substitution model of evaluation in favor of the more intricate environment model.</p>
<p><a id="c3-para-1493"/>The central issue lurking beneath the complexity of state, sameness, and change is that by introducing assignment we are forced to admit <i>time</i> into our computational models. Before we introduced assignment, all our programs were timeless, in the sense that any expression that has a value always has the same value. In contrast, recall the example of modeling withdrawals from a bank account and returning the resulting balance, introduced at the beginning of section 3.1.1:</p>
<p class="Sp-text-1"><a id="c3-para-1494"/>withdraw(25);</p>
<p class="Sp-text-1"><a id="c3-para-1495"/><i>75</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-1496"/>withdraw(25);</p>
<p class="Sp-text-1"><a id="c3-para-1497"/><i>50</i></p>
<p class="paracontinue"><a id="c3-para-1498"/>Here successive evaluations of the same expression yield different values. This behavior arises from the fact that the execution of assignments (in this case, assignments to the variable <span class="KeyTerm1">balance</span>) delineates <i>moments in time</i> when values change. The result of evaluating an expression depends not only on the expression itself, but also on whether the evaluation occurs before or after these moments. Building models in terms of computational objects with local state forces us to confront time as an essential concept in programming.</p>
<p><a id="c3-para-1499"/>We can go further in structuring computational models to match our perception of the physical world. Objects in the world do not change one at a time in sequence. Rather we perceive them as acting <i>concurrently</i>—all at once. So it is often natural to model systems as collections of <i>threads</i> (sequences of computational steps) that execute concurrently.<a id="c3-fn-0038a"/><a href="#c3-fn-0038"><sup>38</sup></a> Just as we can make our programs modular by organizing models in terms of objects with separate local state, it is often appropriate to divide computational models into parts that evolve separately and concurrently. Even if the programs are to be executed on a sequential computer, the practice of writing programs as if they were to be executed concurrently forces the programmer to avoid inessential timing constraints and thus makes programs more modular.</p>
<p><a id="c3-para-1500"/>In addition to making programs more modular, concurrent computation can provide a speed advantage over sequential computation. Sequential computers execute only one operation at a time, so the amount of time it takes to perform a task is proportional to the total number of operations performed.<a id="c3-fn-0039a"/><a href="#c3-fn-0039"><sup>39</sup></a> However, if it is possible to decompose a problem into pieces that are relatively independent and need to communicate only rarely, it may be possible to allocate pieces to separate computing processors, producing a speed advantage proportional to the number of processors available.</p>
<p><a id="c3-para-1501"/>Unfortunately, the complexities introduced by assignment become even more problematic in the presence of concurrency. The fact of concurrent execution, either because the world operates in parallel or because our computers do, entails additional complexity in our understanding of time.</p>
<section>
<h3><a id="c3-sec-0070"/><span>3.4.1</span> <a id="c3-title-0071"/>The Nature of Time in Concurrent Systems</h3>
<p class="paraaftertitle"><a id="c3-para-1502"/>On the surface, time seems straightforward. It is an ordering imposed on events.<a id="c3-fn-0040a"/><a href="#c3-fn-0040"><sup>40</sup></a> For any events <i>A</i> and <i>B</i>, either <i>A</i> occurs before <i>B</i>, <i>A</i> and <i>B</i> are simultaneous, or <i>A</i> occurs after <i>B</i>. For instance, returning to the bank account example, suppose that Peter withdraws $10 and Paul withdraws $25 from a joint account that initially contains $100, leaving $65 in the account. Depending on the order of the two withdrawals, the sequence of balances in the account is either $100 $90 $65 or $100 $75 $65. In a computer implementation of the banking system, this changing sequence of balances could be modeled by successive assignments to a variable <span class="KeyTerm1">balance</span>.</p>
<p><a id="c3-para-1503"/>In complex situations, however, such a view can be problematic. Suppose that Peter and Paul, and other people besides, are accessing the same bank account through a network of banking machines distributed all over the world. The actual sequence of balances in the account will depend critically on the detailed timing of the accesses and the details of the communication among the machines.</p>
<p><a id="c3-para-1504"/>This indeterminacy in the order of events can pose serious problems in the design of concurrent systems. For instance, suppose that the withdrawals made by Peter and Paul are implemented as two separate threads sharing a common variable <span class="KeyTerm1">balance</span>, each thread specified by the function given in section 3.1.1:</p>
<p class="Sp-text-1"><a id="c3-para-1505"/><b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1506"/>    <b>if</b> (balance &gt;= amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1507"/>        balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-1508"/>        <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1509"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1510"/>        <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-1511"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1512"/>}</p>
<p class="paracontinue"><a id="c3-para-1513"/>If the two threads operate independently, then Peter might test the balance and attempt to withdraw a legitimate amount. However, Paul might withdraw some funds in between the time that Peter checks the balance and the time Peter completes the withdrawal, thus invalidating Peter's test.</p>
<p><a id="c3-para-1514"/>Things can be worse still. Consider the statement</p>
<p class="Sp-text-1"><a id="c3-para-1515"/>balance = balance - amount;</p>
<p class="paracontinue"><a id="c3-para-1516"/>executed as part of each withdrawal process. This consists of three steps: (1) accessing the value of the <span class="KeyTerm1">balance</span> variable; (2) computing the new balance; (3) setting <span class="KeyTerm1">balance</span> to this new value. If Peter and Paul's withdrawals execute this statement concurrently, then the two withdrawals might interleave the order in which they access <span class="KeyTerm1">balance</span> and set it to the new value.</p>
<p><a id="c3-para-1517"/>The timing diagram in <a id="c3-fig-0029a"/><a href="#c3-fig-0029">figure 3.29</a> depicts an order of events where <span class="KeyTerm1">balance</span> starts at 100, Peter withdraws 10, Paul withdraws 25, and yet the final value of <span class="KeyTerm1">balance</span> is 75. As shown in the diagram, the reason for this anomaly is that Paul's assignment of 75 to <span class="KeyTerm1">balance</span> is made under the assumption that the value of <span class="KeyTerm1">balance</span> to be decremented is 100. That assumption, however, became invalid when Peter changed <span class="KeyTerm1">balance</span> to 90. This is a catastrophic failure for the banking system, because the total amount of money in the system is not conserved. Before the transactions, the total amount of money was $100. Afterwards, Peter has $10, Paul has $25, and the bank has $75.<a id="c3-fn-0041a"/><a href="#c3-fn-0041"><sup>41</sup></a></p>
<figure id="c3-fig-0029"><img alt="c3-fig-0029.jpg" src="../images/c3-fig-0029.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0029a">Figure 3.29</a></span> <a id="c3-para-1518"/>Timing diagram showing how interleaving the order of events in two banking withdrawals can lead to an incorrect final balance.</p></figcaption></figure>
<p><a id="c3-para-1519"/>The general phenomenon illustrated here is that several threads may share a common state variable. What makes this complicated is that more than one thread may be trying to manipulate the shared state at the same time. For the bank account example, during each transaction, each customer should be able to act as if the other customers did not exist. When customers change the balance in a way that depends on the balance, they must be able to assume that, just before the moment of change, the balance is still what they thought it was.</p>
<section>
<h5><a id="c3-sec-0071"/><a id="c3-title-0072"/>Correct behavior of concurrent programs</h5>
<p class="paraaftertitle"><a id="c3-para-1520"/>The above example typifies the subtle bugs that can creep into concurrent programs. The root of this complexity lies in the assignments to variables that are shared among the different threads. We already know that we must be careful in writing programs that use assignment, because the results of a computation depend on the order in which the assignments occur.<a id="c3-fn-0042a"/><a href="#c3-fn-0042"><sup>42</sup></a> With concurrent threads we must be especially careful about assignments, because we may not be able to control the order of the assignments made by the different threads. If several such changes might be made concurrently (as with two depositors accessing a joint account) we need some way to ensure that our system behaves correctly. For example, in the case of withdrawals from a joint bank account, we must ensure that money is conserved. To make concurrent programs behave correctly, we may have to place some restrictions on concurrent execution.</p>
<p><a id="c3-para-1521"/>One possible restriction on concurrency would stipulate that no two operations that change any shared state variables can occur at the same time. This is an extremely stringent requirement. For distributed banking, it would require the system designer to ensure that only one transaction could proceed at a time. This would be both inefficient and overly conservative. <a id="c3-fig-0030a"/><a href="#c3-fig-0030">Figure 3.30</a> shows Peter and Paul sharing a bank account, where Paul has a private account as well. The diagram illustrates two withdrawals from the shared account (one by Peter and one by Paul) and a deposit to Paul's private account.<a id="c3-fn-0043a"/><a href="#c3-fn-0043"><sup>43</sup></a> The two withdrawals from the shared account must not be concurrent (since both access and update the same account), and Paul's deposit and withdrawal must not be concurrent (since both access and update the amount in Paul's wallet). But there should be no problem permitting Paul's deposit to his private account to proceed concurrently with Peter's withdrawal from the shared account.</p>
<figure id="c3-fig-0030"><img alt="c3-fig-0030.jpg" src="../images/c3-fig-0030.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0030a">Figure 3.30</a></span> <a id="c3-para-1522"/>Concurrent deposits and withdrawals from a joint account in Bank1 and a private account in Bank2.</p></figcaption></figure>
<p><a id="c3-para-1523"/>A less stringent restriction on concurrency would ensure that a concurrent system produces the same result as if the threads had run sequentially in some order. There are two important aspects to this requirement. First, it does not require the threads to actually run sequentially, but only to produce results that are the same <i>as if</i> they had run sequentially. For the example in <a href="#c3-fig-0030">figure 3.30</a>, the designer of the bank account system can safely allow Paul's deposit and Peter's withdrawal to happen concurrently, because the net result will be the same as if the two operations had happened sequentially. Second, there may be more than one possible “correct” result produced by a concurrent program, because we require only that the result be the same as for <i>some</i> sequential order. For example, suppose that Peter and Paul's joint account starts out with $100, and Peter deposits $40 while Paul concurrently withdraws half the money in the account. Then sequential execution could result in the account balance being either $70 or $90 (see exercise 3.38).<a id="c3-fn-0044a"/><a href="#c3-fn-0044"><sup>44</sup></a></p>
<p><a id="c3-para-1524"/>There are still weaker requirements for correct execution of concurrent programs. A program for simulating diffusion (say, the flow of heat in an object) might consist of a large number of threads, each one representing a small volume of space, that update their values concurrently. Each thread repeatedly changes its value to the average of its own value and its neighbors’ values. This algorithm converges to the right answer independent of the order in which the operations are done; there is no need for any restrictions on concurrent use of the shared values.</p>
</section>
<section>
<h5><a id="c3-sec-0072"/><a id="c3-title-0073"/>Exercise 3.38</h5>
<p class="paraaftertitle"><a id="c3-para-1525"/>Suppose that Peter, Paul, and Mary share a joint bank account that initially contains $100. Concurrently, Peter deposits $10, Paul withdraws $20, and Mary withdraws half the money in the account, by executing the following commands:</p>
<figure><figcaption class="tablecaption"><a id="c3-tbl-0001"/></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c3-para-1526"/>Peter:</td>
<td><a id="c3-para-1527"/><span class="KeyTerm1">balance = balance + 10</span></td></tr>
<tr>
<td><a id="c3-para-1528"/>Paul:</td>
<td><a id="c3-para-1529"/><span class="KeyTerm1">balance = balance - 20</span></td></tr>
<tr>
<td><a id="c3-para-1530"/>Mary:</td>
<td><a id="c3-para-1531"/><span class="KeyTerm1">balance = balance - (balance / 2)</span></td></tr></tbody></table></div></figure>
<ol class="BS_NumberListA">
<li><a id="c3-li-0027"/><span>a. </span>List all the different possible values for <span class="KeyTerm1">balance</span> after these three transactions have been completed, assuming that the banking system forces the three threads to run sequentially in some order.</li>
<li><a id="c3-li-0028"/><span>b. </span>What are some other values that could be produced if the system allows the threads to be interleaved? Draw timing diagrams like the one in <a href="#c3-fig-0029">figure 3.29</a> to explain how these values can occur.</li>
</ol>
</section>
</section>
<section>
<h3><a id="c3-sec-0073"/><span>3.4.2</span> <a id="c3-title-0074"/>Mechanisms for Controlling Concurrency</h3>
<p class="paraaftertitle"><a id="c3-para-1534"/>We've seen that the difficulty in dealing with concurrent threads is rooted in the need to consider the interleaving of the order of events in the different threads. For example, suppose we have two threads, one with three ordered events (<i>a</i>, <i>b</i>, <i>c</i>) and one with three ordered events (<i>x</i>, <i>y</i>, <i>z</i>). If the two threads run concurrently, with no constraints on how their execution is interleaved, then there are 20 different possible orderings for the events that are consistent with the individual orderings for the two threads:</p>
<figure><figcaption class="tablecaption"><a id="c3-tbl-0002"/></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c3-para-1535"/>(<i>a</i>, <i>b</i>, <i>c</i>, <i>x</i>, <i>y</i>, <i>z</i>)</td>
<td><a id="c3-para-1536"/>(<i>a</i>, <i>x</i>, <i>b</i>, <i>y</i>, <i>c</i>, <i>z</i>)</td>
<td><a id="c3-para-1537"/>(<i>x</i>, <i>a</i>, <i>b</i>, <i>c</i>, <i>y</i>, <i>z</i>)</td>
<td><a id="c3-para-1538"/>(<i>x</i>, <i>a</i>, <i>y</i>, <i>z</i>, <i>b</i>, <i>c</i>)</td></tr>
<tr>
<td><a id="c3-para-1539"/>(<i>a</i>, <i>b</i>, <i>x</i>, <i>c</i>, <i>y</i>, <i>z</i>)</td>
<td><a id="c3-para-1540"/>(<i>a</i>, <i>x</i>, <i>b</i>, <i>y</i>, <i>z</i>, <i>c</i>)</td>
<td><a id="c3-para-1541"/>(<i>x</i>, <i>a</i>, <i>b</i>, <i>y</i>, <i>c</i>, <i>z</i>)</td>
<td><a id="c3-para-1542"/>(<i>x</i>, <i>y</i>, <i>a</i>, <i>b</i>, <i>c</i>, <i>z</i>)</td></tr>
<tr>
<td><a id="c3-para-1543"/>(<i>a</i>, <i>b</i>, <i>x</i>, <i>y</i>, <i>c</i>, <i>z</i>)</td>
<td><a id="c3-para-1544"/>(<i>a</i>, <i>x</i>, <i>y</i>, <i>b</i>, <i>c</i>, <i>z</i>)</td>
<td><a id="c3-para-1545"/>(<i>x</i>, <i>a</i>, <i>b</i>, <i>y</i>, <i>z</i>, <i>c</i>)</td>
<td><a id="c3-para-1546"/>(<i>x</i>, <i>y</i>, <i>a</i>, <i>b</i>, <i>z</i>, <i>c</i>)</td></tr>
<tr>
<td><a id="c3-para-1547"/>(<i>a</i>, <i>b</i>, <i>x</i>, <i>y</i>, <i>z</i>, <i>c</i>)</td>
<td><a id="c3-para-1548"/>(<i>a</i>, <i>x</i>, <i>y</i>, <i>b</i>, <i>z</i>, <i>c</i>)</td>
<td><a id="c3-para-1549"/>(<i>x</i>, <i>a</i>, <i>y</i>, <i>b</i>, <i>c</i>, <i>z</i>)</td>
<td><a id="c3-para-1550"/>(<i>x</i>, <i>y</i>, <i>a</i>, <i>z</i>, <i>b</i>, <i>c</i>)</td></tr>
<tr>
<td><a id="c3-para-1551"/>(<i>a</i>, <i>x</i>, <i>b</i>, <i>c</i>, <i>y</i>, <i>z</i>)</td>
<td><a id="c3-para-1552"/>(<i>a</i>, <i>x</i>, <i>y</i>, <i>z</i>, <i>b</i>, <i>c</i>)</td>
<td><a id="c3-para-1553"/>(<i>x</i>, <i>a</i>, <i>y</i>, <i>b</i>, <i>z</i>, <i>c</i>)</td>
<td><a id="c3-para-1554"/>(<i>x</i>, <i>y</i>, <i>z</i>, <i>a</i>, <i>b</i>, <i>c</i>)</td></tr></tbody></table></div>
</figure>

<p class="paracontinue"><a id="c3-para-1555"/>As programmers designing this system, we would have to consider the effects of each of these 20 orderings and check that each behavior is acceptable. Such an approach rapidly becomes unwieldy as the numbers of threads and events increase.</p>
<p><a id="c3-para-5555"/>A more practical approach to the design of concurrent systems is to devise general mechanisms that allow us to constrain the interleaving of concurrent threads so that we can be sure that the program behavior is correct. Many mechanisms have been developed for this purpose. In this section, we describe one of them, the <i>serializer</i>.</p>
<section>
<h5><a id="c3-sec-0074"/><a id="c3-title-0075"/>Serializing access to shared state</h5>
<p class="paraaftertitle"><a id="c3-para-1556"/>Serialization implements the following idea: Threads will execute concurrently, but there will be certain collections of functions that cannot be executed concurrently. More precisely, serialization creates distinguished sets of functions such that only one execution of a function in each serialized set is permitted to happen at a time. If some function in the set is being executed, then a thread that attempts to execute any function in the set will be forced to wait until the first execution has finished.</p>
<p><a id="c3-para-1557"/>We can use serialization to control access to shared variables. For example, if we want to update a shared variable based on the previous value of that variable, we put the access to the previous value of the variable and the assignment of the new value to the variable in the same function. We then ensure that no other function that assigns to the variable can run concurrently with this function by serializing all of these functions with the same serializer. This guarantees that the value of the variable cannot be changed between an access and the corresponding assignment.</p>
</section>
<section>
<h5><a id="c3-sec-0075"/><a id="c3-title-0076"/>Serializers</h5>
<p class="paraaftertitle"><a id="c3-para-1558"/>To make the above mechanism more concrete, suppose that we have extended JavaScript to include a function called <span class="KeyTerm1">concurrent_execute</span>:</p>
<p class="Sp-text-1"><a id="c3-para-1559"/>concurrent_execute(<span class="KeyTerm2"><i>f</i><sub>1</sub></span>, <span class="KeyTerm2"><i>f</i><sub>2</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>f<sub>k</sub></i></span>)</p>
<p class="paracontinue"><a id="c3-para-1560"/>Each <i>f</i> must be a function of no arguments. The function <span class="KeyTerm1">concurrent_execute</span> creates a separate thread for each <i>f,</i> which applies <i>f</i> (to no arguments). These threads all run concurrently.<a id="c3-fn-0045a"/><a href="#c3-fn-0045"><sup>45</sup></a></p>
<p><a id="c3-para-1561"/>As an example of how this is used, consider</p>
<p class="Sp-text-1"><a id="c3-para-1562"/><b>let</b> x = 10;</p>
<p class="Sp-text-1"><a id="c3-para-1563"/>concurrent_execute(() =&gt; { x = x * x; },</p>
<p class="Sp-text-1"><a id="c3-para-1564"/>                   () =&gt; { x = x + 1; });</p>
<p class="paracontinue"><a id="c3-para-1565"/>This creates two concurrent threads—<i>T</i><sub>1</sub>, which sets <span class="KeyTerm1">x</span> to <span class="KeyTerm1">x</span> times <span class="KeyTerm1">x</span>, and <i>T</i><sub>2</sub>, which increments <span class="KeyTerm1">x</span>. After execution is complete, <span class="KeyTerm1">x</span> will be left with one of five possible values, depending on the interleaving of the events of <i>T</i><sub>1</sub> and <i>T</i><sub>2</sub>:</p>
<figure><figcaption class="tablecaption"><a id="c3-tbl-0003"/></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c3-para-1566"/>101:</td>
<td><a id="c3-para-1567"/><i>T</i><sub>1</sub> sets <span class="KeyTerm1">x</span> to 100 and then <i>T</i><sub>2</sub> increments <span class="KeyTerm1">x</span> to 101.</td></tr>
<tr>
<td><a id="c3-para-1568"/>121:</td>
<td><a id="c3-para-1569"/><i>T</i><sub>2</sub> increments <span class="KeyTerm1">x</span> to 11 and then <i>T</i><sub>1</sub> sets <span class="KeyTerm1">x</span> to <span class="KeyTerm1">x</span> times <span class="KeyTerm1">x</span>.</td></tr>
<tr>
<td><a id="c3-para-1570"/>110:</td>
<td><a id="c3-para-1571"/><i>T</i><sub>2</sub> changes <span class="KeyTerm1">x</span> from 10 to 11 between the two times that <i>T</i><sub>1</sub></td></tr>
<tr>
<td/>
<td><a id="c3-para-1572"/>accesses the value of <span class="KeyTerm1">x</span> during the evaluation of <span class="KeyTerm1">x * x</span>.</td></tr>
<tr>
<td><a id="c3-para-1573"/>11:</td>
<td><a id="c3-para-1574"/><i>T</i><sub>2</sub> accesses <span class="KeyTerm1">x</span>, then <i>T</i><sub>1</sub> sets <span class="KeyTerm1">x</span> to 100, then <i>T</i><sub>2</sub> sets <span class="KeyTerm1">x</span>.</td></tr>
<tr>
<td><a id="c3-para-1575"/>100:</td>
<td><a id="c3-para-1576"/><i>T</i><sub>1</sub> accesses <span class="KeyTerm1">x</span> (twice), then <i>T</i><sub>2</sub> sets <span class="KeyTerm1">x</span> to 11, then <i>T</i><sub>1</sub> sets <span class="KeyTerm1">x</span>.</td></tr></tbody></table></div></figure>

<p><a id="c3-para-1577"/>We can constrain the concurrency by using serialized functions, which are created by <i>serializers</i>. Serializers are constructed by <span class="KeyTerm1">make_serializer</span>, whose implementation is given below. A serializer takes a function as argument and returns a serialized function that behaves like the original function. All calls to a given serializer return serialized functions in the same set.</p>
<p><a id="c3-para-1578"/>Thus, in contrast to the example above, executing</p>
<p class="Sp-text-1"><a id="c3-para-1579"/><b>let</b> x = 10;</p>
<p class="Sp-text-1"><a id="c3-para-1580"/><b>const</b> s = make_serializer();</p>
<p class="Sp-text-1"><a id="c3-para-1581"/>concurrent_execute(s(() =&gt; { x = x * x; }),</p>
<p class="Sp-text-1"><a id="c3-para-1582"/>                   s(() =&gt; { x = x + 1; }));</p>
<p class="paracontinue"><a id="c3-para-1583"/>can produce only two possible values for <span class="KeyTerm1">x</span>, 101 or 121. The other possibilities are eliminated, because the execution of <i>T</i><sub>1</sub> and <i>T</i><sub>2</sub> cannot be interleaved.</p>
<p><a id="c3-para-1584"/>Here is a version of the <span class="KeyTerm1">make_account</span> function from section 3.1.1, where the deposits and withdrawals have been serialized:</p>
<p class="Sp-text-1"><a id="c3-para-1585"/><b>function</b> make_account(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-1586"/>    <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1587"/>        <b>if</b> (balance &gt; amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1588"/>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-1589"/>            <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1590"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1591"/>            <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-1592"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1593"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1594"/>    <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1595"/>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c3-para-1596"/>        <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1597"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1598"/>    <b>const</b> protect = make_serializer();</p>
<p class="Sp-text-1"><a id="c3-para-1599"/>    <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c3-para-1600"/>        <b>return</b> m === "withdraw"</p>
<p class="Sp-text-1"><a id="c3-para-1601"/>               ? protect(withdraw)</p>
<p class="Sp-text-1"><a id="c3-para-1602"/>               : m === "deposit"</p>
<p class="Sp-text-1"><a id="c3-para-1603"/>               ? protect(deposit)</p>
<p class="Sp-text-1"><a id="c3-para-1604"/>               : m === "balance"</p>
<p class="Sp-text-1"><a id="c3-para-1605"/>               ? balance</p>
<p class="Sp-text-1"><a id="c3-para-1606"/>               : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c3-para-1607"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1608"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c3-para-1609"/>}</p>
<p class="paracontinue"><a id="c3-para-1610"/>With this implementation, two threads cannot be withdrawing from or depositing into a single account concurrently. This eliminates the source of the error illustrated in <a href="#c3-fig-0029">figure 3.29</a>, where Peter changes the account balance between the times when Paul accesses the balance to compute the new value and when Paul actually performs the assignment. On the other hand, each account has its own serializer, so that deposits and withdrawals for different accounts can proceed concurrently.</p>
</section>
<section>
<h5><a id="c3-sec-0076"/><a id="c3-title-0077"/>Exercise 3.39</h5>
<p class="paraaftertitle"><a id="c3-para-1611"/>Which of the five possibilities in the concurrent execution shown above remain if we instead serialize execution as follows:</p>
<p class="Sp-text-1"><a id="c3-para-1612"/><b>let</b> x = 10;</p>
<p class="Sp-text-1"><a id="c3-para-1613"/><b>const</b> s = make_serializer();</p>
<p class="Sp-text-1"><a id="c3-para-1614"/>concurrent_execute( () =&gt; { x = s(() =&gt; x * x)(); },</p>
<p class="Sp-text-1"><a id="c3-para-1615"/>                   s(() =&gt; { x = x + 1; }));</p>
</section>
<section>
<h5><a id="c3-sec-0077"/><a id="c3-title-0078"/>Exercise 3.40</h5>
<p class="paraaftertitle"><a id="c3-para-1616"/>Give all possible values of <span class="KeyTerm1">x</span> that can result from executing</p>
<p class="Sp-text-1"><a id="c3-para-1617"/><b>let</b> x = 10;</p>
<p class="Sp-text-1"><a id="c3-para-1618"/>concurrent_execute(() =&gt; { x = x * x; },</p>
<p class="Sp-text-1"><a id="c3-para-1619"/>                   () =&gt; { x = x * x * x; });</p>
<p class="paracontinue"><a id="c3-para-1620"/>Which of these possibilities remain if we instead use serialized functions:</p>
<p class="Sp-text-1"><a id="c3-para-1621"/><b>let</b> x = 10;</p>
<p class="Sp-text-1"><a id="c3-para-1622"/><b>const</b> s = make_serializer(); concurrent_execute(s(() =&gt; { x = x * x; }),</p>
<p class="Sp-text-1"><a id="c3-para-1623"/>                   s(() =&gt; { x = x * x * x; }));</p>
</section>
<section>
<h5><a id="c3-sec-0078"/><a id="c3-title-0079"/>Exercise 3.41</h5>
<p class="paraaftertitle"><a id="c3-para-1624"/>Ben Bitdiddle worries that it would be better to implement the bank account as follows (where the commented line has been changed):</p>
<p class="Sp-text-1"><a id="c3-para-1625"/><b>function</b> make_account(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-1626"/>    <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1627"/>        <b>if</b> (balance &gt; amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1628"/>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-1629"/>            <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1630"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1631"/>            <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-1632"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1633"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1634"/>    <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1635"/>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c3-para-1636"/>        <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1637"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1638"/>    <b>const</b> protect = make_serializer();</p>
<p class="Sp-text-1"><a id="c3-para-1639"/>    <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c3-para-1640"/>        <b>return</b> m === "withdraw"</p>
<p class="Sp-text-1"><a id="c3-para-1641"/>               ? protect(withdraw)</p>
<p class="Sp-text-1"><a id="c3-para-1642"/>               : m === "deposit"</p>
<p class="Sp-text-1"><a id="c3-para-1643"/>               ? protect(deposit)</p>
<p class="Sp-text-1"><a id="c3-para-1644"/>               : m === "balance"</p>
<p class="Sp-text-1"><a id="c3-para-1645"/>               ? protect(() =&gt; balance)(undefined) <span class="KeyTerm2"><i>// serialized</i></span></p>
<p class="Sp-text-1"><a id="c3-para-1646"/>               : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c3-para-1647"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1648"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c3-para-1649"/>}</p>
<p class="paracontinue"><a id="c3-para-1650"/>because allowing unserialized access to the bank balance can result in anomalous behavior. Do you agree? Is there any scenario that demonstrates Ben's concern?</p>
</section>
<section>
<h5><a id="c3-sec-0079"/><a id="c3-title-0080"/>Exercise 3.42</h5>
<p class="paraaftertitle"><a id="c3-para-1651"/>Ben Bitdiddle suggests that it's a waste of time to create a new serialized function in response to every <span class="KeyTerm1">withdraw</span> and <span class="KeyTerm1">deposit</span> message. He says that <span class="KeyTerm1">make_account</span> could be changed so that the calls to <span class="KeyTerm1">protect</span> are done outside the <span class="KeyTerm1">dispatch</span> function. That is, an account would return the same serialized function (which was created at the same time as the account) each time it is asked for a withdrawal function.</p>
<p class="Sp-text-1"><a id="c3-para-1652"/><b>function</b> make_account(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-1653"/>    <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1654"/>        <b>if</b> (balance &gt; amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1655"/>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-1656"/>            <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1657"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1658"/>            <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-1659"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1660"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1661"/>    <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1662"/>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c3-para-1663"/>        <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1664"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1665"/>    <b>const</b> protect = make_serializer();</p>
<p class="Sp-text-1"><a id="c3-para-1666"/>    <b>const</b> protect_withdraw = protect(withdraw);</p>
<p class="Sp-text-1"><a id="c3-para-1667"/>    <b>const</b> protect_deposit = protect(deposit);</p>
<p class="Sp-text-1"><a id="c3-para-1668"/>    <b>function</b> dispatch(m) {</p>
<p class="Sp-text-1"><a id="c3-para-1669"/>        <b>return</b> m === "withdraw"</p>
<p class="Sp-text-1"><a id="c3-para-1670"/>               ? protect_withdraw</p>
<p class="Sp-text-1"><a id="c3-para-1671"/>               : m === "deposit"</p>
<p class="Sp-text-1"><a id="c3-para-1672"/>               ? protect_deposit</p>
<p class="Sp-text-1"><a id="c3-para-1673"/>               : m === "balance"</p>
<p class="Sp-text-1"><a id="c3-para-1674"/>               ? balance</p>
<p class="Sp-text-1"><a id="c3-para-1675"/>               : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c3-para-1676"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1677"/>    <b>return</b> dispatch;</p>
<p class="Sp-text-1"><a id="c3-para-1678"/>}</p>
<p class="paracontinue"><a id="c3-para-1679"/>Is this a safe change to make? In particular, is there any difference in what concurrency is allowed by these two versions of <span class="KeyTerm1">make_account</span> ?</p>
</section>
<section>
<h5><a id="c3-sec-0080"/><a id="c3-title-0081"/>Complexity of using multiple shared resources</h5>
<p class="paraaftertitle"><a id="c3-para-1680"/>Serializers provide a powerful abstraction that helps isolate the complexities of concurrent programs so that they can be dealt with carefully and (hopefully) correctly. However, while using serializers is relatively straightforward when there is only a single shared resource (such as a single bank account), concurrent programming can be treacherously difficult when there are multiple shared resources.</p>
<p><a id="c3-para-1681"/>To illustrate one of the difficulties that can arise, suppose we wish to swap the balances in two bank accounts. We access each account to find the balance, compute the difference between the balances, withdraw this difference from one account, and deposit it in the other account. We could implement this as follows:<a id="c3-fn-0046a"/><a href="#c3-fn-0046"><sup>46</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1682"/><b>function</b> exchange(account1, account2) {</p>
<p class="Sp-text-1"><a id="c3-para-1683"/>    <b>const</b> difference = account1("balance") - account2("balance");</p>
<p class="Sp-text-1"><a id="c3-para-1684"/>    account1("withdraw")(difference);</p>
<p class="Sp-text-1"><a id="c3-para-1685"/>    account2("deposit")(difference);</p>
<p class="Sp-text-1"><a id="c3-para-1686"/>}</p>
<p><a id="c3-para-1687"/>This function works well when only a single thread is trying to do the exchange. Suppose, however, that Peter and Paul both have access to accounts <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, and <i>a</i><sub>3</sub>, and that Peter exchanges <i>a</i><sub>1 </sub>and <i>a</i><sub>2 </sub>while Paul concurrently exchanges <i>a</i><sub>1 </sub>and <i>a</i><sub>3</sub>. Even with account deposits and withdrawals serialized for individual accounts (as in the <span class="KeyTerm1">make_account</span> function shown above in this section), <span class="KeyTerm1">exchange</span> can still produce incorrect results. For example, Peter might compute the difference in the balances for <i>a</i><sub>1</sub> and <i>a</i><sub>2</sub>, but then Paul might change the balance in <i>a</i><sub>1</sub> before Peter is able to complete the exchange.<a id="c3-fn-0047a"/><a href="#c3-fn-0047"><sup>47</sup></a> For correct behavior, we must arrange for the <span class="KeyTerm1">exchange</span> function to lock out any other concurrent accesses to the accounts during the entire time of the exchange.</p>
<p><a id="c3-para-1688"/>One way we can accomplish this is by using both accounts’ serializers to serialize the entire <span class="KeyTerm1">exchange</span> function. To do this, we will arrange for access to an account's serializer. Note that we are deliberately breaking the modularity of the bank-account object by exposing the serializer. The following version of <span class="KeyTerm1">make_ account</span> is identical to the original version given in section 3.1.1, except that a serializer is provided to protect the balance variable, and the serializer is exported via message passing:</p>
<p class="Sp-text-1"><a id="c3-para-1689"/><b>function</b> make_account_and_serializer(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-1690"/>    <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1691"/>        <b>if</b> (balance &gt; amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1692"/>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-1693"/>            <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1694"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1695"/>            <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-1696"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1697"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1698"/>    <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1699"/>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c3-para-1700"/>        <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1701"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1702"/>    <b>const</b> balance_serializer = make_serializer();</p>
<p class="Sp-text-1"><a id="c3-para-1703"/>    <b>return</b> m =&gt; m === "withdraw"</p>
<p class="Sp-text-1"><a id="c3-para-1704"/>                ? withdraw</p>
<p class="Sp-text-1"><a id="c3-para-1705"/>                : m === "deposit"</p>
<p class="Sp-text-1"><a id="c3-para-1706"/>                ? deposit</p>
<p class="Sp-text-1"><a id="c3-para-1707"/>                : m === "balance"</p>
<p class="Sp-text-1"><a id="c3-para-1708"/>                ? balance</p>
<p class="Sp-text-1"><a id="c3-para-1709"/>                : m === "serializer"</p>
<p class="Sp-text-1"><a id="c3-para-1710"/>                ? balance_serializer</p>
<p class="Sp-text-1"><a id="c3-para-1711"/>                : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c3-para-1712"/>}</p>
<p><a id="c3-para-1713"/>We can use this to do serialized deposits and withdrawals. However, unlike our earlier serialized account, it is now the responsibility of each user of bank-account objects to explicitly manage the serialization, for example as follows:<a id="c3-fn-0048a"/><a href="#c3-fn-0048"><sup>48</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1714"/><b>function</b> deposit(account, amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1715"/>    <b>const</b> s = account("serializer");</p>
<p class="Sp-text-1"><a id="c3-para-1716"/>    <b>const</b> d = account("deposit");</p>
<p class="Sp-text-1"><a id="c3-para-1717"/>    s(d(amount));</p>
<p class="Sp-text-1"><a id="c3-para-1718"/>}</p>
<p><a id="c3-para-1719"/>Exporting the serializer in this way gives us enough flexibility to implement a serialized exchange program. We simply serialize the original <span class="KeyTerm1">exchange</span> function with the serializers for both accounts:</p>
<p class="Sp-text-1"><a id="c3-para-1720"/><b>function</b> serialized_exchange(account1, account2) {</p>
<p class="Sp-text-1"><a id="c3-para-1721"/>    <b>const</b> serializer1 = account1("serializer");</p>
<p class="Sp-text-1"><a id="c3-para-1722"/>    <b>const</b> serializer2 = account2("serializer");</p>
<p class="Sp-text-1"><a id="c3-para-1723"/>    serializer1(serializer2(exchange))(account1, account2);</p>
<p class="Sp-text-1"><a id="c3-para-1724"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0081"/><a id="c3-title-0082"/>Exercise 3.43</h5>
<p class="paraaftertitle"><a id="c3-para-1725"/>Suppose that the balances in three accounts start out as $10, $20, and $30, and that multiple threads run, exchanging the balances in the accounts. Argue that if the threads are run sequentially, after any number of concurrent exchanges, the account balances should be $10, $20, and $30 in some order. Draw a timing diagram like the one in <a href="#c3-fig-0029">figure 3.29</a> to show how this condition can be violated if the exchanges are implemented using the first version of the account-exchange program in this section. On the other hand, argue that even with this <span class="KeyTerm1">exchange</span> program, the sum of the balances in the accounts will be preserved. Draw a timing diagram to show how even this condition would be violated if we did not serialize the transactions on individual accounts.</p>
</section>
<section>
<h5><a id="c3-sec-0082"/><a id="c3-title-0083"/>Exercise 3.44</h5>
<p class="paraaftertitle"><a id="c3-para-1726"/>Consider the problem of transferring an amount from one account to another. Ben Bitdiddle claims that this can be accomplished with the following function, even if there are multiple people concurrently transferring money among multiple accounts, using any account mechanism that serializes deposit and withdrawal transactions, for example, the version of <span class="KeyTerm1">make_account</span> in the text above.</p>
<p class="Sp-text-1"><a id="c3-para-1727"/><b>function</b> transfer(from_account, to_account, amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1728"/>    from_account("withdraw")(amount);</p>
<p class="Sp-text-1"><a id="c3-para-1729"/>    to_account("deposit")(amount);</p>
<p class="Sp-text-1"><a id="c3-para-1730"/>}</p>
<p class="paracontinue"><a id="c3-para-1731"/>Louis Reasoner claims that there is a problem here, and that we need to use a more sophisticated method, such as the one required for dealing with the exchange problem. Is Louis right? If not, what is the essential difference between the transfer problem and the exchange problem? (You should assume that the balance in <span class="KeyTerm1">from_account</span> is at least <span class="KeyTerm1">amount</span>.)</p>
</section>
<section>
<h5><a id="c3-sec-0083"/><a id="c3-title-0084"/>Exercise 3.45</h5>
<p class="paraaftertitle"><a id="c3-para-1732"/>Louis Reasoner thinks our bank-account system is unnecessarily complex and error-prone now that deposits and withdrawals aren't automatically serialized. He suggests that <span class="KeyTerm1">make_ account_and_serializer</span> should have exported the serializer (for use by such functions as <span class="KeyTerm1">serialized_exchange</span>) in addition to (rather than instead of) using it to serialize accounts and deposits as <span class="KeyTerm1">make_account</span> did. He proposes to redefine accounts as follows:</p>
<p class="Sp-text-1"><a id="c3-para-1733"/><b>function</b> make_account_and_serializer(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-1734"/>    <b>function</b> withdraw(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1735"/>        <b>if</b> (balance &gt; amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1736"/>            balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-1737"/>            <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1738"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1739"/>            <b>return</b> "Insufficient funds";</p>
<p class="Sp-text-1"><a id="c3-para-1740"/>        }</p>
<p class="Sp-text-1"><a id="c3-para-1741"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1742"/>    <b>function</b> deposit(amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1743"/>        balance = balance + amount;</p>
<p class="Sp-text-1"><a id="c3-para-1744"/>        <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-1745"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1746"/>    <b>const</b> balance_serializer = make_serializer();</p>
<p class="Sp-text-1"><a id="c3-para-1747"/>    <b>return</b> m =&gt; m === "withdraw"</p>
<p class="Sp-text-1"><a id="c3-para-1748"/>                ? balance_serializer(withdraw)</p>
<p class="Sp-text-1"><a id="c3-para-1749"/>                : m === "deposit"</p>
<p class="Sp-text-1"><a id="c3-para-1750"/>                ? balance_serializer(deposit)</p>
<p class="Sp-text-1"><a id="c3-para-1751"/>                : m === "balance"</p>
<p class="Sp-text-1"><a id="c3-para-1752"/>                ? balance</p>
<p class="Sp-text-1"><a id="c3-para-1753"/>                : m === "serializer"</p>
<p class="Sp-text-1"><a id="c3-para-1754"/>                ? balance_serializer</p>
<p class="Sp-text-1"><a id="c3-para-1755"/>                : error(m, "unknown request – make_account");</p>
<p class="Sp-text-1"><a id="c3-para-1756"/>}</p>
<p class="paracontinue"><a id="c3-para-1757"/>Then deposits are handled as with the original make_account:</p>
<p class="Sp-text-1"><a id="c3-para-1758"/><b>function</b> deposit(account, amount) {</p>
<p class="Sp-text-1"><a id="c3-para-1759"/>    account("deposit")(amount);</p>
<p class="Sp-text-1"><a id="c3-para-1760"/>}</p>
<p class="paracontinue"><a id="c3-para-1761"/>Explain what is wrong with Louis's reasoning. In particular, consider what happens when <span class="KeyTerm1">serialized_exchange</span> is called.</p>
</section>
<section>
<h5><a id="c3-sec-0084"/><a id="c3-title-0085"/>Implementing serializers</h5>
<p class="paraaftertitle"><a id="c3-para-1762"/>We implement serializers in terms of a more primitive synchronization mechanism called a <i>mutex</i>. A mutex is an object that supports two operations—the mutex can be <i>acquired</i>, and the mutex can be <i>released</i>. Once a mutex has been acquired, no other acquire operations on that mutex may proceed until the mutex is released.<a id="c3-fn-0049a"/><a href="#c3-fn-0049"><sup>49</sup></a> In our implementation, each serializer has an associated mutex. Given a function <span class="KeyTerm1">f</span>, the serializer returns a function that acquires the mutex, runs <span class="KeyTerm1">f</span>, and then releases the mutex. This ensures that only one of the functions produced by the serializer can be running at once, which is precisely the serialization property that we need to guarantee. To apply serializers to functions that take an arbitrary number of arguments, we use JavaScript's <i>rest</i> parameter and <i>spread</i> syntax. The <span class="KeyTerm1">…</span> in front of the parameter <span class="KeyTerm1">args</span> collects the rest (here all) of the arguments of any call of the function into a <i>vector</i> data structure. The <span class="KeyTerm1">…</span> in front of <span class="KeyTerm1">args</span> in the application <span class="KeyTerm1">f(…args)</span> spreads the elements of <span class="KeyTerm1">args</span> so that they become separate arguments of <span class="KeyTerm1">f</span>.</p>
<p class="Sp-text-1"><a id="c3-para-1763"/><b>function</b> make_serializer() {</p>
<p class="Sp-text-1"><a id="c3-para-1764"/>    <b>const</b> mutex = make_mutex();</p>
<p class="Sp-text-1"><a id="c3-para-1765"/>    <b>return</b> f =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-1766"/>               <b>function</b> serialized_f(…args) {</p>
<p class="Sp-text-1"><a id="c3-para-1767"/>                   mutex("acquire");</p>
<p class="Sp-text-1"><a id="c3-para-1768"/>                   <b>const</b> val = f(…args);</p>
<p class="Sp-text-1"><a id="c3-para-1769"/>                   mutex("release");</p>
<p class="Sp-text-1"><a id="c3-para-1770"/>                   <b>return</b> val;</p>
<p class="Sp-text-1"><a id="c3-para-1771"/>               }</p>
<p class="Sp-text-1"><a id="c3-para-1772"/>               <b>return</b> serialized_f;</p>
<p class="Sp-text-1"><a id="c3-para-1773"/>           };</p>
<p class="Sp-text-1"><a id="c3-para-1774"/>}</p>
<p><a id="c3-para-1775"/>The mutex is a mutable object (here we'll use a one-element list, which we'll refer to as a <i>cell</i>) that can hold the value true or false. When the value is false, the mutex is available to be acquired. When the value is true, the mutex is unavailable, and any thread that attempts to acquire the mutex must wait.</p>
<p><a id="c3-para-1776"/>Our mutex constructor <span class="KeyTerm1">make_mutex</span> begins by initializing the cell contents to false. To acquire the mutex, we test the cell. If the mutex is available, we set the cell contents to true and proceed. Otherwise, we wait in a loop, attempting to acquire over and over again, until we find that the mutex is available.<a id="c3-fn-0050a"/><a href="#c3-fn-0050"><sup>50</sup></a> To release the mutex, we set the cell contents to false.</p>
<p class="Sp-text-1"><a id="c3-para-1777"/><b>function</b> make_mutex() {</p>
<p class="Sp-text-1"><a id="c3-para-1778"/>    <b>const</b> cell = list(<b>false</b>);</p>
<p class="Sp-text-1"><a id="c3-para-1779"/>    <b>function</b> the_mutex(m) {</p>
<p class="Sp-text-1"><a id="c3-para-1780"/>    <b>return</b> m === "acquire"</p>
<p class="Sp-text-1"><a id="c3-para-1781"/>           ? test_and_set(cell)</p>
<p class="Sp-text-1"><a id="c3-para-1782"/>             ? the_mutex("acquire") <i>// retry</i></p>
<p class="Sp-text-1"><a id="c3-para-1783"/>             : <b>true</b></p>
<p class="Sp-text-1"><a id="c3-para-1784"/>           : m === "release"</p>
<p class="Sp-text-1"><a id="c3-para-1785"/>           ? clear(cell)</p>
<p class="Sp-text-1"><a id="c3-para-1786"/>           : error(m, "unknown request – mutex");</p>
<p class="Sp-text-1"><a id="c3-para-1787"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1788"/>    <b>return</b> the_mutex;</p>
<p class="Sp-text-1"><a id="c3-para-1789"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1790"/><b>function</b> clear(cell) {</p>
<p class="Sp-text-1"><a id="c3-para-1791"/>    set_head(cell, <b>false</b>);</p>
<p class="Sp-text-1"><a id="c3-para-1792"/>}</p>
<p><a id="c3-para-1793"/>The function <span class="KeyTerm1">test_and_set</span> tests the cell and returns the result of the test. In addition, if the test was false, <span class="KeyTerm1">test_and_set</span> sets the cell contents to true before returning false. We can express this behavior as the following function:</p>
<p class="Sp-text-1"><a id="c3-para-1794"/><b>function</b> test_and_set(cell) {</p>
<p class="Sp-text-1"><a id="c3-para-1795"/>    <b>if</b> (head(cell)) {</p>
<p class="Sp-text-1"><a id="c3-para-1796"/>        <b>return true</b>;</p>
<p class="Sp-text-1"><a id="c3-para-1797"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1798"/>        set_head(cell, <b>true</b>);</p>
<p class="Sp-text-1"><a id="c3-para-1799"/>        <b>return false</b>;</p>
<p class="Sp-text-1"><a id="c3-para-1800"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1801"/>}</p>
<p><a id="c3-para-1802"/>However, this implementation of <span class="KeyTerm1">test_and_set</span> does not suffice as it stands. There is a crucial subtlety here, which is the essential place where concurrency control enters the system: The <span class="KeyTerm1">test_and_set</span> operation must be performed <i>atomically</i>. That is, we must guarantee that, once a thread has tested the cell and found it to be false, the cell contents will actually be set to true before any other thread can test the cell. If we do not make this guarantee, then the mutex can fail in a way similar to the bank-account failure in <a href="#c3-fig-0029">figure 3.29</a>. (See exercise 3.46.)</p>
<p><a id="c3-para-1803"/>The actual implementation of <span class="KeyTerm1">test_and_set</span> depends on the details of how our system runs concurrent threads. For example, we might be executing concurrent threads on a sequential processor using a time-slicing mechanism that cycles through the threads, permitting each thread to run for a short time before interrupting it and moving on to the next thread. In that case, <span class="KeyTerm1">test_and_set</span> can work by disabling time slicing during the testing and setting. Alternatively, multiprocessing computers provide instructions that support atomic operations directly in hardware.<a id="c3-fn-0051a"/><a href="#c3-fn-0051"><sup>51</sup></a></p>
</section>
<section>
<h5><a id="c3-sec-0085"/><a id="c3-title-0086"/>Exercise 3.46</h5>
<p class="paraaftertitle"><a id="c3-para-1804"/>Suppose that we implement <span class="KeyTerm1">test_and_set</span> using an ordinary function as shown in the text, without attempting to make the operation atomic. Draw a timing diagram like the one in <a href="#c3-fig-0029">figure 3.29</a> to demonstrate how the mutex implementation can fail by allowing two threads to acquire the mutex at the same time.</p>
</section>
<section>
<h5><a id="c3-sec-0086"/><a id="c3-title-0087"/>Exercise 3.47</h5>
<p class="paraaftertitle"><a id="c3-para-1805"/>A semaphore (of size <i>n</i>) is a generalization of a mutex. Like a mutex, a semaphore supports acquire and release operations, but it is more general in that up to <i>n</i> threads can acquire it concurrently. Additional threads that attempt to acquire the semaphore must wait for release operations. Give implementations of semaphores</p>
<ol class="BS_NumberListA">
<li><a id="c3-li-0029"/><span>a. </span>in terms of mutexes</li>
<li><a id="c3-li-0030"/><span>b. </span>in terms of atomic <span class="KeyTerm1">test_and_set</span> operations.</li>
</ol>
</section>
<section>
<h5><a id="c3-sec-0087"/><a id="c3-title-0088"/>Deadlock</h5>
<p class="paraaftertitle"><a id="c3-para-1808"/>Now that we have seen how to implement serializers, we can see that account exchanging still has a problem, even with the <span class="KeyTerm1">serialized_exchange</span> function above. Imagine that Peter attempts to exchange <i>a</i><sub>1</sub> with <i>a</i><sub>2</sub> while Paul concurrently attempts to exchange <i>a</i><sub>2</sub> with <i>a</i><sub>1</sub>. Suppose that Peter's thread reaches the point where it has entered a serialized function protecting <i>a</i><sub>1</sub> and, just after that, Paul's thread enters a serialized function protecting <i>a</i><sub>2</sub>. Now Peter cannot proceed (to enter a serialized function protecting <i>a</i><sub>2</sub>) until Paul exits the serialized function protecting <i>a</i><sub>2</sub>. Similarly, Paul cannot proceed until Peter exits the serialized function protecting <i>a</i><sub>1</sub>. Each thread is stalled forever, waiting for the other. This situation is called a <i>deadlock</i>. Deadlock is always a danger in systems that provide concurrent access to multiple shared resources.</p>
<p><a id="c3-para-1809"/>One way to avoid the deadlock in this situation is to give each account a unique identification number and rewrite <span class="KeyTerm1">serialized_exchange</span> so that a thread will always attempt to enter a function protecting the lowest-numbered account first. Although this method works well for the exchange problem, there are other situations that require more sophisticated deadlock-avoidance techniques, or where deadlock cannot be avoided at all. (See exercises 3.48 and 3.49.)<a id="c3-fn-0052a"/><a href="#c3-fn-0052"><sup>52</sup></a></p>
</section>
<section>
<h5><a id="c3-sec-0088"/><a id="c3-title-0089"/>Exercise 3.48</h5>
<p class="paraaftertitle"><a id="c3-para-1810"/>Explain in detail why the deadlock-avoidance method described above, (i.e., the accounts are numbered, and each thread attempts to acquire the smaller-numbered account first) avoids deadlock in the exchange problem. Rewrite <span class="KeyTerm1">serialized_exchange</span> to incorporate this idea. (You will also need to modify <span class="KeyTerm1">make_account</span> so that each account is created with a number, which can be accessed by sending an appropriate message.)</p>
</section>
<section>
<h5><a id="c3-sec-0089"/><a id="c3-title-0090"/>Exercise 3.49</h5>
<p class="paraaftertitle"><a id="c3-para-1811"/>Give a scenario where the deadlock-avoidance mechanism described above does not work. (Hint: In the exchange problem, each thread knows in advance which accounts it will need to get access to. Consider a situation where a thread must get access to some shared resources before it can know which additional shared resources it will require.)</p>
</section>
<section>
<h5><a id="c3-sec-0090"/><a id="c3-title-0091"/>Concurrency, time, and communication</h5>
<p class="paraaftertitle"><a id="c3-para-1812"/>We've seen how programming concurrent systems requires controlling the ordering of events when different threads access shared state, and we've seen how to achieve this control through judicious use of serializers. But the problems of concurrency lie deeper than this, because, from a fundamental point of view, it's not always clear what is meant by “shared state.”</p>
<p><a id="c3-para-1813"/>Mechanisms such as <span class="KeyTerm1">test_and_set</span> require threads to examine a global shared flag at arbitrary times. This is problematic and inefficient to implement in modern high-speed processors, where due to optimization techniques such as pipelining and cached memory, the contents of memory may not be in a consistent state at every instant. In some multiprocessing systems, therefore, the serializer paradigm is being supplanted by other approaches to concurrency control.<a id="c3-fn-0053a"/><a href="#c3-fn-0053"><sup>53</sup></a></p>
<p><a id="c3-para-1814"/>The problematic aspects of shared state also arise in large, distributed systems. For instance, imagine a distributed banking system where individual branch banks maintain local values for bank balances and periodically compare these with values maintained by other branches. In such a system the value of “the account balance” would be undetermined, except right after synchronization. If Peter deposits money in an account he holds jointly with Paul, when should we say that the account balance has changed—when the balance in the local branch changes, or not until after the synchronization? And if Paul accesses the account from a different branch, what are the reasonable constraints to place on the banking system such that the behavior is “correct”? The only thing that might matter for correctness is the behavior observed by Peter and Paul individually and the “state” of the account immediately after synchronization. Questions about the “real” account balance or the order of events between synchronizations may be irrelevant or meaningless.<a id="c3-fn-0054a"/><a href="#c3-fn-0054"><sup>54</sup></a></p>
<p><a id="c3-para-1815"/>The basic phenomenon here is that synchronizing different threads, establishing shared state, or imposing an order on events requires communication among the threads. In essence, any notion of time in concurrency control must be intimately tied to communication.<a id="c3-fn-0055a"/><a href="#c3-fn-0055"><sup>55</sup></a> It is intriguing that a similar connection between time and communication also arises in the Theory of Relativity, where the speed of light (the fastest signal that can be used to synchronize events) is a fundamental constant relating time and space. The complexities we encounter in dealing with time and state in our computational models may in fact mirror a fundamental complexity of the physical universe.</p>
</section>
</section>
</section>
<section>
<h2><a id="c3-sec-0091"/><span>3.5</span> <a id="c3-title-0092"/>Streams</h2>
<p class="paraaftertitle"><a id="c3-para-1816"/>We've gained a good understanding of assignment as a tool in modeling, as well as an appreciation of the complex problems that assignment raises. It is time to ask whether we could have gone about things in a different way, so as to avoid some of these problems. In this section, we explore an alternative approach to modeling state, based on data structures called <i>streams</i>. As we shall see, streams can mitigate some of the complexity of modeling state.</p>
<p><a id="c3-para-1817"/>Let's step back and review where this complexity comes from. In an attempt to model real-world phenomena, we made some apparently reasonable decisions: We modeled real-world objects with local state by computational objects with local variables. We identified time variation in the real world with time variation in the computer. We implemented the time variation of the states of the model objects in the computer with assignments to the local variables of the model objects.</p>
<p><a id="c3-para-1818"/>Is there another approach? Can we avoid identifying time in the computer with time in the modeled world? Must we make the model change with time in order to model phenomena in a changing world? Think about the issue in terms of mathematical functions. We can describe the time-varying behavior of a quantity <i>x</i> as a function of time <i>x</i>(<i>t</i>). If we concentrate on <i>x</i> instant by instant, we think of it as a changing quantity. Yet if we concentrate on the entire time history of values, we do not emphasize change—the function itself does not change.<a id="c3-fn-0056a"/><a href="#c3-fn-0056"><sup>56</sup></a></p>
<p><a id="c3-para-1819"/>If time is measured in discrete steps, then we can model a time function as a (possibly infinite) sequence. In this section, we will see how to model change in terms of sequences that represent the time histories of the systems being modeled. To accomplish this, we introduce new data structures called <i>streams</i>. From an abstract point of view, a stream is simply a sequence. However, we will find that the straightforward implementation of streams as lists (as in section 2.2.1) doesn't fully reveal the power of stream processing. As an alternative, we introduce the technique of <i>delayed evaluation</i>, which enables us to represent very large (even infinite) sequences as streams.</p>
<p><a id="c3-para-1820"/>Stream processing lets us model systems that have state without ever using assignment or mutable data. This has important implications, both theoretical and practical, because we can build models that avoid the drawbacks inherent in introducing assignment. On the other hand, the stream framework raises difficulties of its own, and the question of which modeling technique leads to more modular and more easily maintained systems remains open.</p>
<section>
<h3><a id="c3-sec-0092"/><span>3.5.1</span> <a id="c3-title-0093"/>Streams Are Delayed Lists</h3>
<p class="paraaftertitle"><a id="c3-para-1821"/>As we saw in section 2.2.3, sequences can serve as standard interfaces for combining program modules. We formulated powerful abstractions for manipulating sequences, such as <span class="KeyTerm1">map</span>, <span class="KeyTerm1">filter</span>, and <span class="KeyTerm1">accumulate</span>, that capture a wide variety of operations in a manner that is both succinct and elegant.</p>
<p><a id="c3-para-1822"/>Unfortunately, if we represent sequences as lists, this elegance is bought at the price of severe inefficiency with respect to both the time and space required by our computations. When we represent manipulations on sequences as transformations of lists, our programs must construct and copy data structures (which may be huge) at every step of a process.</p>
<p><a id="c3-para-1823"/>To see why this is true, let us compare two programs for computing the sum of all the prime numbers in an interval. The first program is written in standard iterative style:<a id="c3-fn-0057a"/><a href="#c3-fn-0057"><sup>57</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1824"/><b>function</b> sum_primes(a, b) {</p>
<p class="Sp-text-1"><a id="c3-para-1825"/>    <b>function</b> iter(count, accum) {</p>
<p class="Sp-text-1"><a id="c3-para-1826"/>        <b>return</b> count &gt; b</p>
<p class="Sp-text-1"><a id="c3-para-1827"/>               ? accum</p>
<p class="Sp-text-1"><a id="c3-para-1828"/>               : is_prime(count)</p>
<p class="Sp-text-1"><a id="c3-para-1829"/>               ? iter(count + 1, count + accum)</p>
<p class="Sp-text-1"><a id="c3-para-1830"/>               : iter(count + 1, accum);</p>
<p class="Sp-text-1"><a id="c3-para-1831"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1832"/>    <b>return</b> iter(a, 0);</p>
<p class="Sp-text-1"><a id="c3-para-1833"/>}</p>
<p class="paracontinue"><a id="c3-para-1834"/>The second program performs the same computation using the sequence operations of section 2.2.3:</p>
<p class="Sp-text-1"><a id="c3-para-1835"/><b>function</b> sum_primes(a, b) {</p>
<p class="Sp-text-1"><a id="c3-para-1836"/>    <b>return</b> accumulate((x, y) =&gt; x + y,</p>
<p class="Sp-text-1"><a id="c3-para-1837"/>                      0,</p>
<p class="Sp-text-1"><a id="c3-para-1838"/>                      filter(is_prime,</p>
<p class="Sp-text-1"><a id="c3-para-1839"/>                             enumerate_interval(a, b)));</p>
<p class="Sp-text-1"><a id="c3-para-1840"/>}</p>
<p><a id="c3-para-1841"/>In carrying out the computation, the first program needs to store only the sum being accumulated. In contrast, the filter in the second program cannot do any testing until <span class="KeyTerm1">enumerate_interval</span> has constructed a complete list of the numbers in the interval. The filter generates another list, which in turn is passed to <span class="KeyTerm1">accumulate</span> before being collapsed to form a sum. Such large intermediate storage is not needed by the first program, which we can think of as enumerating the interval incrementally, adding each prime to the sum as it is generated.</p>
<p><a id="c3-para-1842"/>The inefficiency in using lists becomes painfully apparent if we use the sequence paradigm to compute the second prime in the interval from 10,000 to 1,000,000 by evaluating the expression</p>
<p class="Sp-text-1"><a id="c3-para-1843"/>head(tail(filter(is_prime,</p>
<p class="Sp-text-1"><a id="c3-para-1844"/>                 enumerate_interval(10000, 1000000))));</p>
<p class="paracontinue"><a id="c3-para-1845"/>This expression does find the second prime, but the computational overhead is outrageous. We construct a list of almost a million integers, filter this list by testing each element for primality, and then ignore almost all of the result. In a more traditional programming style, we would interleave the enumeration and the filtering, and stop when we reached the second prime.</p>
<p><a id="c3-para-1846"/>Streams are a clever idea that allows one to use sequence manipulations without incurring the costs of manipulating sequences as lists. With streams we can achieve the best of both worlds: We can formulate programs elegantly as sequence manipulations, while attaining the efficiency of incremental computation. The basic idea is to arrange to construct a stream only partially, and to pass the partial construction to the program that consumes the stream. If the consumer attempts to access a part of the stream that has not yet been constructed, the stream will automatically construct just enough more of itself to produce the required part, thus preserving the illusion that the entire stream exists. In other words, although we will write programs as if we were processing complete sequences, we design our stream implementation to automatically and transparently interleave the construction of the stream with its use.</p>
<p><a id="c3-para-1847"/>To accomplish this, we will construct streams using pairs, with the first item of the stream in the head of the pair. However, rather than placing the value of the rest of the stream into the tail of the pair, we will put there a “promise” to compute the rest if it is ever requested. If we have a data item <span class="KeyTerm1">h</span> and a stream <span class="KeyTerm1">t</span>, we construct a stream whose head is <span class="KeyTerm1">h</span> and whose tail is <span class="KeyTerm1">t</span> by evaluating <span class="KeyTerm1">pair(h, () =&gt; t)</span>—the tail <span class="KeyTerm1">t</span> of a stream is “wrapped” in a function of no arguments, so that its evaluation will be <i>delayed</i>. The empty stream is <span class="KeyTerm1"><b>null</b></span>, the same as the empty list.</p>
<p><a id="c3-para-1848"/>To access the first data item of a nonempty stream, we simply select the <span class="KeyTerm1">head</span> of the pair, as with a list. But to access the tail of a stream, we need to evaluate the delayed expression. For convenience, we define</p>
<p class="Sp-text-1"><a id="c3-para-1849"/><b>function</b> stream_tail(stream) {</p>
<p class="Sp-text-1"><a id="c3-para-1850"/>    <b>return</b> tail(stream)();</p>
<p class="Sp-text-1"><a id="c3-para-1851"/>}</p>
<p class="paracontinue"><a id="c3-para-1852"/>This selects the tail of the pair and applies the function found there to obtain the next pair of the stream (or <span class="KeyTerm1"><b>null</b></span> if the tail of the stream is empty)—in effect, <i>forcing</i> the function in the tail of the pair to fulfill its promise.</p>
<p><a id="c3-para-1853"/>We can make and use streams, in just the same way as we can make and use lists, to represent aggregate data arranged in a sequence. In particular, we can build stream analogs of the list operations from chapter 2, such as <span class="KeyTerm1">list_ref</span>, <span class="KeyTerm1">map</span>, and <span class="KeyTerm1">for_each</span>:<a id="c3-fn-0058a"/><a href="#c3-fn-0058"><sup>58</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1854"/><b>function</b> stream_ref(s, n) {</p>
<p class="Sp-text-1"><a id="c3-para-1855"/>    <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c3-para-1856"/>           ? head(s)</p>
<p class="Sp-text-1"><a id="c3-para-1857"/>           : stream_ref(stream_tail(s), n - 1);</p>
<p class="Sp-text-1"><a id="c3-para-1858"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1859"/><b>function</b> stream_map(f, s) {</p>
<p class="Sp-text-1"><a id="c3-para-1860"/>    <b>return</b> is_null(s)</p>
<p class="Sp-text-1"><a id="c3-para-1861"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c3-para-1862"/>           : pair(f(head(s)),</p>
<p class="Sp-text-1"><a id="c3-para-1863"/>                  () =&gt; stream_map(f, stream_tail(s)));</p>
<p class="Sp-text-1"><a id="c3-para-1864"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1865"/><b>function</b> stream_for_each(fun, s) {</p>
<p class="Sp-text-1"><a id="c3-para-1866"/>    <b>if</b> (is_null(s)) {</p>
<p class="Sp-text-1"><a id="c3-para-1867"/>        <b>return true</b>;</p>
<p class="Sp-text-1"><a id="c3-para-1868"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1869"/>        fun(head(s));</p>
<p class="Sp-text-1"><a id="c3-para-1870"/>        <b>return</b> stream_for_each(fun, stream_tail(s));</p>
<p class="Sp-text-1"><a id="c3-para-1871"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-1872"/>}</p>
<p class="paracontinue"><a id="c3-para-1873"/>The function <span class="KeyTerm1">stream_for_each</span> is useful for viewing streams:</p>
<p class="Sp-text-1"><a id="c3-para-1874"/><b>function</b> display_stream(s) {</p>
<p class="Sp-text-1"><a id="c3-para-1875"/>    <b>return</b> stream_for_each(display, s);</p>
<p class="Sp-text-1"><a id="c3-para-1876"/>}</p>
<p><a id="c3-para-1877"/>To make the stream implementation automatically and transparently interleave the construction of a stream with its use, we have arranged for the tail of a stream to be evaluated when it is accessed by the <span class="KeyTerm1">stream_tail</span> function rather than when the stream is constructed by <span class="KeyTerm1">pair</span>. This implementation choice is reminiscent of our discussion of rational numbers in section 2.1.2, where we saw that we can choose to implement rational numbers so that the reduction of numerator and denominator to lowest terms is performed either at construction time or at selection time. The two rational-number implementations produce the same data abstraction, but the choice has an effect on efficiency. There is a similar relationship between streams and ordinary lists. As a data abstraction, streams are the same as lists. The difference is the time at which the elements are evaluated. With ordinary lists, both the <span class="KeyTerm1">head</span> and the <span class="KeyTerm1">tail</span> are evaluated at construction time. With streams, the <span class="KeyTerm1">tail</span> is evaluated at selection time.</p>
<section>
<h5><a id="c3-sec-0093"/><a id="c3-title-0094"/>Streams in action</h5>
<p class="paraaftertitle"><a id="c3-para-1878"/>To see how this data structure behaves, let us analyze the “outrageous” prime computation we saw above, reformulated in terms of streams:</p>
<p class="Sp-text-1"><a id="c3-para-1879"/>head(stream_tail(stream_filter(</p>
<p class="Sp-text-1"><a id="c3-para-1880"/>                     is_prime,</p>
<p class="Sp-text-1"><a id="c3-para-1881"/>                     stream_enumerate_interval(10000, 1000000))));</p>
<p class="paracontinue"><a id="c3-para-1882"/>We will see that it does indeed work efficiently.</p>
<p><a id="c3-para-1883"/>We begin by calling <span class="KeyTerm1">stream_enumerate_interval</span> with the arguments 10,000 and 1,000,000. The function <span class="KeyTerm1">stream_enumerate_interval</span> is the stream analog of <span class="KeyTerm1">enumerate_interval</span> (section 2.2.3):</p>
<p class="Sp-text-1"><a id="c3-para-1884"/><b>function</b> stream_enumerate_interval(low, high) {</p>
<p class="Sp-text-1"><a id="c3-para-1885"/>    <b>return</b> low &gt; high</p>
<p class="Sp-text-1"><a id="c3-para-1886"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c3-para-1887"/>           : pair(low,</p>
<p class="Sp-text-1"><a id="c3-para-1888"/>                  () =&gt; stream_enumerate_interval(low + 1, high));</p>
<p class="Sp-text-1"><a id="c3-para-1889"/>}</p>
<p class="paracontinue"><a id="c3-para-1890"/>and thus the result returned by <span class="KeyTerm1">stream_enumerate_interval</span>, formed by the <span class="KeyTerm1">pair</span>, is<a id="c3-fn-0059a"/><a href="#c3-fn-0059"><sup>59</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1891"/>pair(10000, () =&gt; stream_enumerate_interval(10001, 1000000));</p>
<p class="paracontinue"><a id="c3-para-1892"/>That is, <span class="KeyTerm1">stream_enumerate_interval</span> returns a stream represented as a pair whose <span class="KeyTerm1">head</span> is 10,000 and whose <span class="KeyTerm1">tail</span> is a promise to enumerate more of the interval if so requested. This stream is now filtered for primes, using the stream analog of the <span class="KeyTerm1">filter</span> function (section 2.2.3):</p>
<p class="Sp-text-1"><a id="c3-para-1893"/><b>function</b> stream_filter(pred, stream) {</p>
<p class="Sp-text-1"><a id="c3-para-1894"/>    <b>return</b> is_null(stream)</p>
<p class="Sp-text-1"><a id="c3-para-1895"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c3-para-1896"/>           : pred(head(stream))</p>
<p class="Sp-text-1"><a id="c3-para-1897"/>           ? pair(head(stream),</p>
<p class="Sp-text-1"><a id="c3-para-1898"/>                  () =&gt; stream_filter(pred, stream_tail(stream)))</p>
<p class="Sp-text-1"><a id="c3-para-1899"/>           : stream_filter(pred, stream_tail(stream));</p>
<p class="Sp-text-1"><a id="c3-para-1900"/>}</p>
<p class="paracontinue"><a id="c3-para-1901"/>The function <span class="KeyTerm1">stream_filter</span> tests the <span class="KeyTerm1">head</span> of the stream (which is 10,000). Since this is not prime, <span class="KeyTerm1">stream_filter</span> examines the tail of its input stream. The call to <span class="KeyTerm1">stream_tail</span> forces evaluation of the delayed <span class="KeyTerm1">stream_enumerate_interval</span>, which now returns</p>
<p class="Sp-text-1"><a id="c3-para-1902"/>pair(10001, () =&gt; stream_enumerate_interval(10002, 1000000));</p>
<p class="paracontinue"><a id="c3-para-1903"/>The function <span class="KeyTerm1">stream_filter</span> now looks at the <span class="KeyTerm1">head</span> of this stream, 10,001, sees that this is not prime either, forces another <span class="KeyTerm1">stream_tail</span>, and so on, until <span class="KeyTerm1">stream_ enumerate_interval</span> yields the prime 10,007, whereupon <span class="KeyTerm1">stream_filter</span>, according to its definition, returns</p>
<p class="Sp-text-1"><a id="c3-para-1904"/>pair(head(stream),</p>
<p class="Sp-text-1"><a id="c3-para-1905"/>     stream_filter(pred, stream_tail(stream)));</p>
<p class="paracontinue"><a id="c3-para-1906"/>which in this case is</p>
<p class="Sp-text-1"><a id="c3-para-1907"/>pair(10007,</p>
<p class="Sp-text-1"><a id="c3-para-1908"/>     () =&gt; stream_filter(</p>
<p class="Sp-text-1"><a id="c3-para-1909"/>              is_prime,</p>
<p class="Sp-text-1"><a id="c3-para-1910"/>              pair(10008,</p>
<p class="Sp-text-1"><a id="c3-para-1911"/>                   () =&gt; stream_enumerate_interval(10009, 1000000))));</p>
<p class="paracontinue"><a id="c3-para-1912"/>This result is now passed to <span class="KeyTerm1">stream_tail</span> in our original expression. This forces the delayed <span class="KeyTerm1">stream_filter</span>, which in turn keeps forcing the delayed <span class="KeyTerm1">stream_ enumerate_interval</span> until it finds the next prime, which is 10,009. Finally, the result passed to <span class="KeyTerm1">head</span> in our original expression is</p>
<p class="Sp-text-1"><a id="c3-para-1913"/>pair(10009,</p>
<p class="Sp-text-1"><a id="c3-para-1914"/>     () =&gt; stream_filter(</p>
<p class="Sp-text-1"><a id="c3-para-1915"/>              is_prime,</p>
<p class="Sp-text-1"><a id="c3-para-1916"/>              pair(10010,</p>
<p class="Sp-text-1"><a id="c3-para-1917"/>                   () =&gt; stream_enumerate_interval(10011, 1000000))));</p>
<p class="paracontinue"><a id="c3-para-1918"/>The function <span class="KeyTerm1">head</span> returns 10,009, and the computation is complete. Only as many integers were tested for primality as were necessary to find the second prime, and the interval was enumerated only as far as was necessary to feed the prime filter.</p>
<p><a id="c3-para-1919"/>In general, we can think of delayed evaluation as “demand-driven” programming, whereby each stage in the stream process is activated only enough to satisfy the next stage. What we have done is to decouple the actual order of events in the computation from the apparent structure of our functions. We write functions as if the streams existed “all at once” when, in reality, the computation is performed incrementally, as in traditional programming styles.</p>
</section>
<section>
<h5><a id="c3-sec-0094"/><a id="c3-title-0095"/>An optimization</h5>
<p class="paraaftertitle"><a id="c3-para-1920"/>When we construct stream pairs, we delay the evaluation of their tail expressions by wrapping these expressions in a function. We force their evaluation when needed, by applying the function.</p>
<p><a id="c3-para-1921"/>This implementation suffices for streams to work as advertised, but there is an important optimization that we shall consider where needed. In many applications, we end up forcing the same delayed object many times. This can lead to serious inefficiency in recursive programs involving streams. (See exercise 3.57.) The solution is to build delayed objects so that the first time they are forced, they store the value that is computed. Subsequent forcings will simply return the stored value without repeating the computation. In other words, we implement the construction of stream pairs as a memoized function similar to the one described in exercise 3.27. One way to accomplish this is to use the following function, which takes as argument a function (of no arguments) and returns a memoized version of the function. The first time the memoized function is run, it saves the computed result. On subsequent evaluations, it simply returns the result.<a id="c3-fn-0060a"/><a href="#c3-fn-0060"><sup>60</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1922"/><b>function</b> memo(fun) {</p>
<p class="Sp-text-1"><a id="c3-para-1923"/>    <b>let</b> already_run = <b>false</b>;</p>
<p class="Sp-text-1"><a id="c3-para-1924"/>    <b>let</b> result = undefined;</p>
<p class="Sp-text-1"><a id="c3-para-1925"/>    <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-1926"/>               <b>if</b> (!already_run) {</p>
<p class="Sp-text-1"><a id="c3-para-1927"/>                   result = fun();</p>
<p class="Sp-text-1"><a id="c3-para-1928"/>                   already_run = <b>true</b>;</p>
<p class="Sp-text-1"><a id="c3-para-1929"/>                   <b>return</b> result;</p>
<p class="Sp-text-1"><a id="c3-para-1930"/>               } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-1931"/>                   <b>return</b> result;</p>
<p class="Sp-text-1"><a id="c3-para-1932"/>               }</p>
<p class="Sp-text-1"><a id="c3-para-1933"/>           };</p>
<p class="Sp-text-1"><a id="c3-para-1934"/>}</p>
<p><a id="c3-para-1935"/>We can make use of <span class="KeyTerm1">memo</span> whenever we construct a stream pair. For example, instead of</p>
<p class="Sp-text-1"><a id="c3-para-1936"/><b>function</b> stream_map(f, s) {</p>
<p class="Sp-text-1"><a id="c3-para-1937"/>    <b>return</b> is_null(s)</p>
<p class="Sp-text-1"><a id="c3-para-1938"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c3-para-1939"/>           : pair(f(head(s)),</p>
<p class="Sp-text-1"><a id="c3-para-1940"/>                  () =&gt; stream_map(f, stream_tail(s)));</p>
<p class="Sp-text-1"><a id="c3-para-1941"/>}</p>
<p class="paracontinue"><a id="c3-para-1942"/>we can define an optimized function stream_map as follows:</p>
<p class="Sp-text-1"><a id="c3-para-1943"/><b>function</b> stream_map_optimized(f, s) {</p>
<p class="Sp-text-1"><a id="c3-para-1944"/>    <b>return</b> is_null(s)</p>
<p class="Sp-text-1"><a id="c3-para-1945"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c3-para-1946"/>           : pair(f(head(s)),</p>
<p class="Sp-text-1"><a id="c3-para-1947"/>                  memo(() =&gt;</p>
<p class="Sp-text-1"><a id="c3-para-1948"/>                         stream_map_optimized(f, stream_tail(s))));</p>
<p class="Sp-text-1"><a id="c3-para-1949"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0095"/><a id="c3-title-0096"/>Exercise 3.50</h5>
<p class="paraaftertitle"><a id="c3-para-1950"/>Declare a function stream_map_2 that takes a binary function and two streams as arguments and returns a stream whose elements are the results of applying the function pairwise to the corresponding elements of the argument streams.</p>
<p class="Sp-text-1"><a id="c3-para-1951"/><b>function</b> stream_map_2(f, s1, s2) {</p>
<p class="Sp-text-1"><a id="c3-para-1952"/>    …</p>
<p class="Sp-text-1"><a id="c3-para-1953"/>}</p>
<p class="paracontinue"><a id="c3-para-1954"/>Similar to <span class="KeyTerm1">stream_map_optimized</span>, declare a function <span class="KeyTerm1">stream_map_2_optimized</span> by modifying your <span class="KeyTerm1">stream_map_2</span> such that the result stream employs memoization.</p>
</section>
<section>
<h5><a id="c3-sec-0096"/><a id="c3-title-0097"/>Exercise 3.51</h5>
<p class="paraaftertitle"><a id="c3-para-1955"/>Note that our primitive function <span class="KeyTerm1">display</span> returns its argument after displaying it. What does the interpreter print in response to evaluating each statement in the following sequence?<a id="c3-fn-0061a"/><a href="#c3-fn-0061"><sup>61</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-1956"/><b>let</b> x = stream_map(display, stream_enumerate_interval(0, 10));</p>
<p class="Sp-text-1"><a id="c3-para-1957"/>stream_ref(x, 5);</p>
<p class="Sp-text-1"><a id="c3-para-1958"/>stream_ref(x, 7);</p>
<p class="paracontinue"><a id="c3-para-1959"/>What does the interpreter print if <span class="KeyTerm1">stream_map_optimized</span> is used instead of stream_map?</p>
<p class="Sp-text-1"><a id="c3-para-1960"/><b>let</b> x = stream_map_optimized(display, stream_enumerate_interval(0, 10));</p>
<p class="Sp-text-1"><a id="c3-para-1961"/>stream_ref(x, 5);</p>
<p class="Sp-text-1"><a id="c3-para-1962"/>stream_ref(x, 7);</p>
</section>
<section>
<h5><a id="c3-sec-0097"/><a id="c3-title-0098"/>Exercise 3.52</h5>
<p class="paraaftertitle"><a id="c3-para-1963"/>Consider the sequence of statements</p>
<p class="Sp-text-1"><a id="c3-para-1964"/><b>let</b> sum = 0;</p>
<p class="Sp-text-1"><a id="c3-para-1965"/><b>function</b> accum(x) {</p>
<p class="Sp-text-1"><a id="c3-para-1966"/>    sum = x + sum;</p>
<p class="Sp-text-1"><a id="c3-para-1967"/>    <b>return</b> sum;</p>
<p class="Sp-text-1"><a id="c3-para-1968"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1969"/><b>const</b> seq = stream_map(accum, stream_enumerate_interval(1, 20));</p>
<p class="Sp-text-1"><a id="c3-para-1970"/><b>const</b> y = stream_filter(is_even, seq);</p>
<p class="Sp-text-1"><a id="c3-para-1971"/><b>const</b> z = stream_filter(x =&gt; x % 5 === 0, seq);</p>
<p class="Sp-text-1"><a id="c3-para-1972"/>stream_ref(y, 7);</p>
<p class="Sp-text-1"><a id="c3-para-1973"/>display_stream(z);</p>
<p class="paracontinue"><a id="c3-para-1974"/>What is the value of <span class="KeyTerm1">sum</span> after each of the above statements is evaluated? What is the printed response to evaluating the <span class="KeyTerm1">stream_ref</span> and <span class="KeyTerm1">display_stream</span> expressions? Would these responses differ if we had applied the function <span class="KeyTerm1">memo</span> on every tail of every constructed stream pair, as suggested in the optimization above? Explain.</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0098"/><span>3.5.2</span> <a id="c3-title-0099"/>Infinite Streams</h3>
<p class="paraaftertitle"><a id="c3-para-1975"/>We have seen how to support the illusion of manipulating streams as complete entities even though, in actuality, we compute only as much of the stream as we need to access. We can exploit this technique to represent sequences efficiently as streams, even if the sequences are very long. What is more striking, we can use streams to represent sequences that are infinitely long. For instance, consider the following definition of the stream of positive integers:</p>
<p class="Sp-text-1"><a id="c3-para-1976"/><b>function</b> integers_starting_from(n) {</p>
<p class="Sp-text-1"><a id="c3-para-1977"/>    <b>return</b> pair(n, () =&gt; integers_starting_from(n + 1));</p>
<p class="Sp-text-1"><a id="c3-para-1978"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1979"/><b>const</b> integers = integers_starting_from(1);</p>
<p class="paracontinue"><a id="c3-para-1980"/>This makes sense because <span class="KeyTerm1">integers</span> will be a pair whose <span class="KeyTerm1">head</span> is 1 and whose <span class="KeyTerm1">tail</span> is a promise to produce the integers beginning with 2. This is an infinitely long stream, but in any given time we can examine only a finite portion of it. Thus, our programs will never know that the entire infinite stream is not there.</p>
<p><a id="c3-para-1981"/>Using <span class="KeyTerm1">integers</span> we can define other infinite streams, such as the stream of integers that are not divisible by 7:</p>
<p class="Sp-text-1"><a id="c3-para-1982"/><b>function</b> is_divisible(x, y) { <b>return</b> x % y === 0; }</p>
<p class="Sp-text-1"><a id="c3-para-1983"/><b>const</b> no_sevens = stream_filter(x =&gt; ! is_divisible(x, 7),</p>
<p class="Sp-text-1"><a id="c3-para-1984"/>                                integers);</p>
<p class="paracontinue"><a id="c3-para-1985"/>Then we can find integers not divisible by 7 simply by accessing elements of this stream:</p>
<p class="Sp-text-1"><a id="c3-para-1986"/>stream_ref(no_sevens, 100);</p>
<p class="Sp-text-1"><a id="c3-para-1987"/><i>117</i></p>
<p><a id="c3-para-1988"/>In analogy with <span class="KeyTerm1">integers</span>, we can define the infinite stream of Fibonacci numbers:</p>
<p class="Sp-text-1"><a id="c3-para-1989"/><b>function</b> fibgen(a, b) {</p>
<p class="Sp-text-1"><a id="c3-para-1990"/>    <b>return</b> pair(a, () =&gt; fibgen(b, a + b));</p>
<p class="Sp-text-1"><a id="c3-para-1991"/>}</p>
<p class="Sp-text-1"><a id="c3-para-1992"/><b>const</b> fibs = fibgen(0, 1);</p>
<p class="paracontinue"><a id="c3-para-1993"/>The constant <span class="KeyTerm1">fibs</span> is a pair whose <span class="KeyTerm1">head</span> is 0 and whose <span class="KeyTerm1">tail</span> is a promise to evaluate <span class="KeyTerm1">fibgen(1, 1)</span>. When we evaluate this delayed <span class="KeyTerm1">fibgen(1, 1)</span>, it will produce a pair whose <span class="KeyTerm1">head</span> is 1 and whose <span class="KeyTerm1">tail</span> is a promise to evaluate <span class="KeyTerm1">fibgen(1, 2)</span>, and so on.</p>
<p><a id="c3-para-1994"/>For a look at a more exciting infinite stream, we can generalize the <span class="KeyTerm1">no_sevens</span> example to construct the infinite stream of prime numbers, using a method known as the <i>sieve of Eratosthenes</i>.<a id="c3-fn-0062a"/><a href="#c3-fn-0062"><sup>62</sup></a> We start with the integers beginning with 2, which is the first prime. To get the rest of the primes, we start by filtering the multiples of 2 from the rest of the integers. This leaves a stream beginning with 3, which is the next prime. Now we filter the multiples of 3 from the rest of this stream. This leaves a stream beginning with 5, which is the next prime, and so on. In other words, we construct the primes by a sieving process, described as follows: To sieve a stream S, form a stream whose first element is the first element of S and the rest of which is obtained by filtering all multiples of the first element of S out of the rest of S and sieving the result. This process is readily described in terms of stream operations:</p>
<p class="Sp-text-1"><a id="c3-para-1995"/><b>function</b> sieve(stream) {</p>
<p class="Sp-text-1"><a id="c3-para-1996"/>    <b>return</b> pair(head(stream),</p>
<p class="Sp-text-1"><a id="c3-para-1997"/>                () =&gt; sieve(stream_filter(</p>
<p class="Sp-text-1"><a id="c3-para-1998"/>                                 x =&gt; ! is_divisible(x, head(stream)),</p>
<p class="Sp-text-1"><a id="c3-para-1999"/>                                 stream_tail(stream))));</p>
<p class="Sp-text-1"><a id="c3-para-2000"/>}</p>
<p class="Sp-text-1"><a id="c3-para-2001"/><b>const</b> primes = sieve(integers_starting_from(2));</p>
<p class="paracontinue"><a id="c3-para-2002"/>Now to find a particular prime we need only ask for it:</p>
<p class="Sp-text-1"><a id="c3-para-2003"/>stream_ref(primes, 50);</p>
<p class="Sp-text-1"><a id="c3-para-2004"/><i>233</i></p>
<p><a id="c3-para-2005"/>It is interesting to contemplate the signal-processing system set up by <span class="KeyTerm1">sieve</span>, shown in the “Henderson diagram” in <a id="c3-fig-0031a"/><a href="#c3-fig-0031">figure 3.31</a>.<a id="c3-fn-0063a"/><a href="#c3-fn-0063"><sup>63</sup></a> The input stream feeds into an “un<span class="KeyTerm1">pair</span>er” that separates the first element of the stream from the rest of the stream. The first element is used to construct a divisibility filter, through which the rest is passed, and the output of the filter is fed to another sieve box. Then the original first element is adjoined to the output of the internal sieve to form the output stream. Thus, not only is the stream infinite, but the signal processor is also infinite, because the sieve contains a sieve within it.</p>
<figure id="c3-fig-0031"><img alt="c3-fig-0031.jpg" src="../images/c3-fig-0031.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0031a">Figure 3.31</a></span> <a id="c3-para-2006"/>The prime sieve viewed as a signal-processing system. Each solid line represents a stream of values being transmitted. The dashed line from the <span class="KeyTerm1">head</span> to the <span class="KeyTerm1">pair</span> and the <span class="KeyTerm1">filter</span> indicates that this is a single value rather than a stream.</p></figcaption></figure>
<section>
<h5><a id="c3-sec-0099"/><a id="c3-title-0100"/>Defining streams implicitly</h5>
<p class="paraaftertitle"><a id="c3-para-2007"/>The <span class="KeyTerm1">integers</span> and <span class="KeyTerm1">fibs</span> streams above were defined by specifying “generating” functions that explicitly compute the stream elements one by one. An alternative way to specify streams is to take advantage of delayed evaluation to define streams implicitly. For example, the following statement defines the stream <span class="KeyTerm1">ones</span> to be an infinite stream of ones:</p>
<p class="Sp-text-1"><a id="c3-para-2008"/><b>const</b> ones = pair(1, () =&gt; ones);</p>
<p class="paracontinue"><a id="c3-para-2009"/>This works much like the declaration of a recursive function: <span class="KeyTerm1">ones</span> is a pair whose <span class="KeyTerm1">head</span> is 1 and whose <span class="KeyTerm1">tail</span> is a promise to evaluate <span class="KeyTerm1">ones</span>. Evaluating the <span class="KeyTerm1">tail</span> gives us again a 1 and a promise to evaluate <span class="KeyTerm1">ones</span>, and so on.</p>
<p><a id="c3-para-2010"/>We can do more interesting things by manipulating streams with operations such as <span class="KeyTerm1">add_streams</span>, which produces the elementwise sum of two given streams:<a id="c3-fn-0064a"/><a href="#c3-fn-0064"><sup>64</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-2011"/><b>function</b> add_streams(s1, s2) {</p>
<p class="Sp-text-1"><a id="c3-para-2012"/>    <b>return</b> stream_map_2((x1, x2) =&gt; x1 + x2, s1, s2);</p>
<p class="Sp-text-1"><a id="c3-para-2013"/>}</p>
<p class="paracontinue"><a id="c3-para-2014"/>Now we can define the integers as follows:</p>
<p class="Sp-text-1"><a id="c3-para-2015"/><b>const</b> integers = pair(1, () =&gt; add_streams(ones, integers));</p>
<p class="paracontinue"><a id="c3-para-2016"/>This defines <span class="KeyTerm1">integers</span> to be a stream whose first element is 1 and the rest of which is the sum of <span class="KeyTerm1">ones</span> and <span class="KeyTerm1">integers</span>. Thus, the second element of <span class="KeyTerm1">integers</span> is 1 plus the first element of <span class="KeyTerm1">integers</span>, or 2; the third element of <span class="KeyTerm1">integers</span> is 1 plus the second element of <span class="KeyTerm1">integers</span>, or 3; and so on. This definition works because, at any point, enough of the <span class="KeyTerm1">integers</span> stream has been generated so that we can feed it back into the definition to produce the next integer.</p>
<p><a id="c3-para-2017"/>We can define the Fibonacci numbers in the same style:</p>
<p class="Sp-text-1"><a id="c3-para-2018"/><b>const</b> fibs = pair(0,</p>
<p class="Sp-text-1"><a id="c3-para-2019"/>                  () =&gt; pair(1,</p>
<p class="Sp-text-1"><a id="c3-para-2020"/>                             () =&gt; add_streams(stream_tail(fibs),</p>
<p class="Sp-text-1"><a id="c3-para-2021"/>                                               fibs)));</p>
<p class="paracontinue"><a id="c3-para-2022"/>This definition says that <span class="KeyTerm1">fibs</span> is a stream beginning with 0 and 1, such that the rest of the stream can be generated by adding <span class="KeyTerm1">fibs</span> to itself shifted by one place:</p>
<figure><figcaption class="tablecaption"><a id="c3-tbl-0004"/></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td/>
<td/>
<td><a id="c3-para-2023"/>1</td>
<td><a id="c3-para-2024"/>1</td>
<td><a id="c3-para-2025"/>2</td>
<td><a id="c3-para-2026"/>3</td>
<td><a id="c3-para-2027"/>5</td>
<td><a id="c3-para-2028"/>8</td>
<td><a id="c3-para-2029"/>13</td>
<td><a id="c3-para-2030"/>21</td>
<td><a id="c3-para-2031"/><span class="KeyTerm1"><i>. . .</i></span></td>
<td><a id="c3-para-2032"/>=</td>
<td><a id="c3-para-2033"/><span class="KeyTerm1">stream_tail(fibs)</span></td></tr>
<tr>
<td/>
<td/>
<td><a id="c3-para-2034"/>0</td>
<td><a id="c3-para-2035"/>1</td>
<td><a id="c3-para-2036"/>1</td>
<td><a id="c3-para-2037"/>2</td>
<td><a id="c3-para-2038"/>3</td>
<td><a id="c3-para-2039"/>5</td>
<td><a id="c3-para-2040"/>8</td>
<td><a id="c3-para-2041"/>13</td>
<td><a id="c3-para-2042"/><span class="KeyTerm1"><i>. . .</i></span></td>
<td><a id="c3-para-2043"/>=</td>
<td><a id="c3-para-2044"/><span class="KeyTerm1">fibs</span></td></tr>
<tr style="border-top:1px solid #000000;">
<td><a id="c3-para-2045"/>0</td>
<td><a id="c3-para-2046"/>1</td>
<td><a id="c3-para-2047"/>1</td>
<td><a id="c3-para-2048"/>2</td>
<td><a id="c3-para-2049"/>3</td>
<td><a id="c3-para-2050"/>5</td>
<td><a id="c3-para-2051"/>8</td>
<td><a id="c3-para-2052"/>13</td>
<td><a id="c3-para-2053"/>21</td>
<td><a id="c3-para-2054"/>34</td>
<td><a id="c3-para-2055"/><span class="KeyTerm1"><i>. . .</i></span></td>
<td><a id="c3-para-2056"/>=</td>
<td><a id="c3-para-2057"/><span class="KeyTerm1">fibs</span></td></tr></tbody></table></div>
</figure>

<p><a id="c3-para-2058"/>The function <span class="KeyTerm1">scale_stream</span> is also useful in formulating such stream definitions. This multiplies each item in a stream by a given constant:</p>
<p class="Sp-text-1"><a id="c3-para-2059"/><b>function</b> scale_stream(stream, factor) {</p>
<p class="Sp-text-1"><a id="c3-para-2060"/>    <b>return</b> stream_map(x =&gt; x * factor,</p>
<p class="Sp-text-1"><a id="c3-para-2061"/>                      stream);</p>
<p class="Sp-text-1"><a id="c3-para-2062"/>}</p>
<p class="paracontinue"><a id="c3-para-2063"/>For example,</p>
<p class="Sp-text-1"><a id="c3-para-2064"/><b>const</b> double = pair(1, () =&gt; scale_stream(double, 2));</p>
<p class="paracontinue"><a id="c3-para-2065"/>produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, . . . .</p>
<p><a id="c3-para-2066"/>An alternate definition of the stream of primes can be given by starting with the integers and filtering them by testing for primality. We will need the first prime, 2, to get started:</p>
<p class="Sp-text-1"><a id="c3-para-2067"/><b>const</b> primes = pair(2,</p>
<p class="Sp-text-1"><a id="c3-para-2068"/>                    () =&gt; stream_filter(is_prime,</p>
<p class="Sp-text-1"><a id="c3-para-2069"/>                                        integers_starting_from(3)));</p>
<p class="paracontinue"><a id="c3-para-2070"/>This definition is not so straightforward as it appears, because we will test whether a number <i>n</i> is prime by checking whether <i>n</i> is divisible by a prime (not by just any integer) less than or equal to <img alt="c3-fig-5001.jpg" src="../images/c3-fig-5001.jpg"/>:</p>
<p class="Sp-text-1"><a id="c3-para-2071"/><b>function</b> is_prime(n) {</p>
<p class="Sp-text-1"><a id="c3-para-2072"/>    <b>function</b> iter(ps) {</p>
<p class="Sp-text-1"><a id="c3-para-2073"/>        <b>return</b> square(head(ps)) &gt; n</p>
<p class="Sp-text-1"><a id="c3-para-2074"/>               ? <b>true</b></p>
<p class="Sp-text-1"><a id="c3-para-2075"/>               : is_divisible(n, head(ps))</p>
<p class="Sp-text-1"><a id="c3-para-2076"/>               ? <b>false</b></p>
<p class="Sp-text-1"><a id="c3-para-2077"/>               : iter(stream_tail(ps));</p>
<p class="Sp-text-1"><a id="c3-para-2078"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-2079"/>    <b>return</b> iter(primes);</p>
<p class="Sp-text-1"><a id="c3-para-2080"/>}</p>
<p class="paracontinue"><a id="c3-para-2081"/>This is a recursive definition, since <span class="KeyTerm1">primes</span> is defined in terms of the <span class="KeyTerm1">is_prime</span> predicate, which itself uses the <span class="KeyTerm1">primes</span> stream. The reason this function works is that, at any point, enough of the <span class="KeyTerm1">primes</span> stream has been generated to test the primality of the numbers we need to check next. That is, for every <i>n</i> we test for primality, either <i>n</i> is not prime (in which case there is a prime already generated that divides it) or <i>n</i> is prime (in which case there is a prime already generated—i.e., a prime less than <i>n</i>—that is greater than <img alt="c3-fig-5001.jpg" src="../images/c3-fig-5001.jpg"/>).<a id="c3-fn-0065a"/><a href="#c3-fn-0065"><sup>65</sup></a></p>
</section>
<section>
<h5><a id="c3-sec-0100"/><a id="c3-title-0101"/>Exercise 3.53</h5>
<p class="paraaftertitle"><a id="c3-para-2082"/>Without running the program, describe the elements of the stream defined by</p>
<p class="Sp-text-1"><a id="c3-para-2083"/><b>const</b> s = pair(1, () =&gt; add_streams(s, s));</p>
</section>
<section>
<h5><a id="c3-sec-0101"/><a id="c3-title-0102"/>Exercise 3.54</h5>
<p class="paraaftertitle"><a id="c3-para-2084"/>Define a function <span class="KeyTerm1">mul_streams</span>, analogous to <span class="KeyTerm1">add_streams</span>, that produces the elementwise product of its two input streams. Use this together with the stream of <span class="KeyTerm1">integers</span> to complete the following definition of the stream whose <i>n</i>th element (counting from 0) is <i>n</i> + 1 factorial:</p>
<p class="Sp-text-1"><a id="c3-para-2085"/><b>const</b> factorials = pair(1, () =&gt; mul_streams(〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉));</p>
</section>
<section>
<h5><a id="c3-sec-0102"/><a id="c3-title-0103"/>Exercise 3.55</h5>
<p class="paraaftertitle"><a id="c3-para-2086"/>Define a function <span class="KeyTerm1">partial_sums</span> that takes as argument a stream <i>S</i> and returns the stream whose elements are <i>S</i><sub>0</sub>, <i>S</i><sub>0</sub> + <i>S</i><sub>1</sub>, <i>S</i><sub>0</sub> + <i>S</i><sub>1</sub> + <i>S</i><sub>2</sub>, . . . . For example, <span class="KeyTerm1">partial_sums(integers)</span> should be the stream 1, 3, 6, 10, 15, <i>. . .</i>.</p>
</section>
<section>
<h5><a id="c3-sec-0103"/><a id="c3-title-0104"/>Exercise 3.56</h5>
<p class="paraaftertitle"><a id="c3-para-2087"/>A famous problem, first raised by R. Hamming, is to enumerate, in ascending order with no repetitions, all positive integers with no prime factors other than 2, 3, or 5. One obvious way to do this is to simply test each integer in turn to see whether it has any factors other than 2, 3, and 5. But this is very inefficient, since, as the integers get larger, fewer and fewer of them fit the requirement. As an alternative, let us call the required stream of numbers <span class="KeyTerm1">S</span> and notice the following facts about it.</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1"><span class="KeyTerm1">S</span> </span>begins with 1.</li>
<li>The elements of <span class="KeyTerm1">scale_stream(S, 2)</span> are also elements of <span class="KeyTerm1"><span class="KeyTerm1">S</span></span>.</li>
<li>The same is true for <span class="KeyTerm1">scale_stream(S, 3)</span> and <span class="KeyTerm1">scale_stream(S, 5)</span>.</li>
<li>These are all the elements of <span class="KeyTerm1"><span class="KeyTerm1">S</span></span>.</li>
</ul>

<p class="paracontinue"><a id="c3-para-2092"/>Now all we have to do is combine elements from these sources. For this we define a function <span class="KeyTerm1">merge</span> that combines two ordered streams into one ordered result stream, eliminating repetitions:</p>
<p class="Sp-text-1"><a id="c3-para-2093"/><b>function</b> merge(s1, s2) {</p>
<p class="Sp-text-1"><a id="c3-para-2094"/>    <b>if</b> (is_null(s1)) {</p>
<p class="Sp-text-1"><a id="c3-para-2095"/>        <b>return</b> s2;</p>
<p class="Sp-text-1"><a id="c3-para-2096"/>    } <b>else if</b> (is_null(s2)) {</p>
<p class="Sp-text-1"><a id="c3-para-2097"/>        <b>return</b> s1;</p>
<p class="Sp-text-1"><a id="c3-para-2098"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c3-para-2099"/>        <b>const</b> s1head = head(s1);</p>
<p class="Sp-text-1"><a id="c3-para-2100"/>        <b>const</b> s2head = head(s2);</p>
<p class="Sp-text-1"><a id="c3-para-2101"/>        <b>return</b> s1head &lt; s2head</p>
<p class="Sp-text-1"><a id="c3-para-2102"/>               ? pair(s1head, () =&gt; merge(stream_tail(s1), s2))</p>
<p class="Sp-text-1"><a id="c3-para-2103"/>               : s1head &gt; s2head</p>
<p class="Sp-text-1"><a id="c3-para-2104"/>               ? pair(s2head, () =&gt; merge(s1, stream_tail(s2)))</p>
<p class="Sp-text-1"><a id="c3-para-2105"/>               : pair(s1head, () =&gt; merge(stream_tail(s1), stream_tail(s2)));</p>
<p class="Sp-text-1"><a id="c3-para-2106"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-2107"/>}</p>
<p class="paracontinue"><a id="c3-para-2108"/>Then the required stream may be constructed with <span class="KeyTerm1">merge</span>, as follows:</p>
<p class="Sp-text-1"><a id="c3-para-2109"/><b>const</b> S = pair(1, () =&gt; merge(<i>(</i>??<i>)</i>, <i>(</i>??<i>)</i>));</p>
<p class="paracontinue"><a id="c3-para-2110"/>Fill in the missing expressions in the places marked <i>(</i>??<i>)</i> above.</p>
</section>
<section>
<h5><a id="c3-sec-0104"/><a id="c3-title-0105"/>Exercise 3.57</h5>
<p class="paraaftertitle"><a id="c3-para-2111"/>How many additions are performed when we compute the <i>n</i>th Fibonacci number using the declaration of fibs based on the <span class="KeyTerm1">add_streams</span> function? Show that this number is exponentially greater than the number of additions performed if <span class="KeyTerm1">add_streams</span> had used the function <span class="KeyTerm1">stream_map_2_optimized</span> described in exercise 3.50.<a id="c3-fn-0066a"/><a href="#c3-fn-0066"><sup>66</sup></a></p>
</section>
<section>
<h5><a id="c3-sec-0105"/><a id="c3-title-0106"/>Exercise 3.58</h5>
<p class="paraaftertitle"><a id="c3-para-2112"/>Give an interpretation of the stream computed by the function</p>
<p class="Sp-text-1"><a id="c3-para-2113"/><b>function</b> expand(num, den, radix) {</p>
<p class="Sp-text-1"><a id="c3-para-2114"/>    <b>return</b> pair(math_trunc((num * radix) / den),</p>
<p class="Sp-text-1"><a id="c3-para-2115"/>                () =&gt; expand((num * radix) % den, den, radix));</p>
<p class="Sp-text-1"><a id="c3-para-2116"/>}</p>
<p class="paracontinue"><a id="c3-para-2117"/>where <span class="KeyTerm1">math_trunc</span> discards the fractional part of its argument, here the remainder of the division. What are the successive elements produced by <span class="KeyTerm1">expand(1, 7, 10)</span>? What is produced by <span class="KeyTerm1">expand(3, 8, 10)</span>?</p>
</section>
<section>
<h5><a id="c3-sec-0106"/><a id="c3-title-0107"/>Exercise 3.59</h5>
<p class="paraaftertitle"><a id="c3-para-2118"/>In section 2.5.3 we saw how to implement a polynomial arithmetic system representing polynomials as lists of terms. In a similar way, we can work with <i>power series</i>, such as</p>
<p><a id="c3-para-2119"/></p>
<figure id="c3-fig-0032"><img alt="c3-fig-5003.jpg" src="../images/c3-fig-5003.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c3-para-2120"/>represented as infinite streams. We will represent the series <i>a</i><sub>0</sub> + <i>a</i><sub>1</sub><i>x</i> + <i>a</i><sub>2</sub><i>x</i><sup>2</sup> + <i>a</i><sub>3</sub><i>x</i><sup>3</sup> + as the stream whose elements are the coefficients <i>a</i><sub>0</sub>, <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, <i>a</i><sub>3</sub>, . . . .</p>
<ol class="BS_NumberListA">
<li><a id="c3-li-0035"/><span>a. </span>The integral of the series <i>a</i><sub>0</sub> + <i>a</i><sub>1</sub><i>x</i> + <i>a</i><sub>2</sub><i>x</i><sup>2</sup> + <i>a</i><sub>3</sub><i>x</i><sup>3</sup> +· · ·is the series
<p class="Sp-text-2"><a id="c3-para-2122"/><i>c</i> + <i>a</i><sub>0</sub><i>x</i> + <img alt="c3-fig-5004.jpg" src="../images/c3-fig-5004.jpg"/><i>a</i><sub>1</sub><i>x</i><sup>2</sup> + <img alt="c3-fig-5005.jpg" src="../images/c3-fig-5005.jpg"/><i>a</i><sub>2</sub><i>x</i><sup>3</sup> + <img alt="c3-fig-5002.jpg" src="../images/c3-fig-5002.jpg"/><i>a</i><sub>3</sub><i>x</i><sup>4</sup> + · · ·</p>
<p class="paracontinue"><a id="c3-para-2123"/>where <i>c</i> is any constant. Define a function <span class="KeyTerm1">integrate_series</span> that takes as input a stream <i>a</i><sub>0</sub>, <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, <i>. . .</i> representing a power series and returns the stream <i>a</i><sub>0</sub>, <img alt="c3-fig-5004.jpg" src="../images/c3-fig-5004.jpg"/><i>a</i><sub>1</sub>, <img alt="c3-fig-5005.jpg" src="../images/c3-fig-5005.jpg"/><i>a</i><sub>2</sub>, <i>. . .</i> of coefficients of the nonconstant terms of the integral of the series. (Since the result has no constant term, it doesn't represent a power series; when we use <span class="KeyTerm1">integrate_series</span>, we will use <span class="KeyTerm1">pair</span> to adjoin the appropriate constant to the beginning of the stream.)</p></li>
<li><a id="c3-li-0036"/><span>b. </span>The function <i>x</i> <img alt="c3-fig-5007.jpg" src="../images/c3-fig-5007.jpg"/> <i>e<sup>x</sup></i> is its own derivative. This implies that <i>e<sup>x</sup></i> and the integral of <i>e<sup>x</sup></i> are the same series, except for the constant term, which is <i>e</i><sup>0</sup> = 1. Accordingly, we can generate the series for <i>e<sup>x</sup></i> as
<p class="Sp-text-1"><a id="c3-para-2125"/><b>const</b> exp_series = pair(1, () =&gt; integrate_series(exp_series));</p>
<p class="paracontinue"><a id="c3-para-2126"/>Show how to generate the series for sine and cosine, starting from the facts that the derivative of sine is cosine and the derivative of cosine is the negative of sine:</p>
<p class="Sp-text-1"><a id="c3-para-2127"/><b>const</b> cosine_series = pair(1, 〈<span class="KeyTerm2">??</span>〉);</p>
<p class="Sp-text-1"><a id="c3-para-2128"/><b>const</b> sine_series = pair(0, 〈<span class="KeyTerm2">??</span>〉);</p></li>
</ol>
</section>
<section>
<h5><a id="c3-sec-0107"/><a id="c3-title-0108"/>Exercise 3.60</h5>
<p class="paraaftertitle"><a id="c3-para-2129"/>With power series represented as streams of coefficients as in exercise 3.59, adding series is implemented by <span class="KeyTerm1">add-streams</span>. Complete the declaration of the following function for multiplying series:</p>
<p class="Sp-text-1"><a id="c3-para-2130"/><b>function</b> mul_series(s1, s2) {</p>
<p class="Sp-text-1"><a id="c3-para-2131"/>    pair(〈<span class="KeyTerm2">??</span>〉, () =&gt; add_streams(〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉));</p>
<p class="Sp-text-1"><a id="c3-para-2132"/><sub>}</sub></p>
<p class="paracontinue"><a id="c3-para-2133"/>You can test your function by verifying that <i>sin</i><sup>2</sup><i>x</i> + <i>cos</i><sup>2</sup><i>x</i> = 1, using the series from exercise 3.59.</p>
</section>
<section>
<h5><a id="c3-sec-0108"/><a id="c3-title-0109"/>Exercise 3.61</h5>
<p class="paraaftertitle"><a id="c3-para-2134"/>Let <i>S</i> be a power series (exercise 3.59) whose constant term is 1. Suppose we want to find the power series 1/<i>S</i>, that is, the series <i>X</i> such that <i>S X</i> = 1. Write <i>S</i> = 1 + <i>S<sub>R</sub></i> where <i>S<sub>R</sub></i> is the part of <i>S</i> after the constant term. Then we can solve for <i>X</i> as follows:</p>
<figure><figcaption class="tablecaption"><a id="c3-tbl-0005"/></figcaption>
<div>
<table class="BS_TableNone"><tbody>
<tr>
<td style="text-align:right;"><a id="c3-para-2135"/><i>S</i> · <i>X</i></td>
<td><a id="c3-para-2136"/>=</td>
<td><a id="c3-para-2137"/>1</td></tr>
<tr>
<td style="text-align:right;"><a id="c3-para-2138"/>(1 + <i>S<sub>R</sub></i>) <i>· X</i></td>
<td><a id="c3-para-2139"/>=</td>
<td><a id="c3-para-2140"/>1</td></tr>
<tr>
<td style="text-align:right;"><a id="c3-para-2141"/><i>X</i> + <i>S<sub>R</sub> · X</i></td>
<td><a id="c3-para-2142"/>=</td>
<td><a id="c3-para-2143"/>1</td></tr>
<tr>
<td style="text-align:right;"><a id="c3-para-2144"/><i>X</i></td>
<td><a id="c3-para-2145"/>=</td>
<td><a id="c3-para-2146"/>1 – <i>S<sub>R</sub> · X</i></td></tr></tbody></table></div></figure>

<p class="paracontinue"><a id="c3-para-2147"/>In other words, <i>X</i> is the power series whose constant term is 1 and whose higher-order terms are given by the negative of <i>S<sub>R</sub></i> times <i>X</i>. Use this idea to write a function <span class="KeyTerm1">invert_ unit_series</span> that computes 1/<i>S</i> for a power series <i>S</i> with constant term 1. You will need to use <span class="KeyTerm1">mul_series</span> from exercise 3.60.</p>
</section>
<section>
<h5><a id="c3-sec-0109"/><a id="c3-title-0110"/>Exercise 3.62</h5>
<p class="paraaftertitle"><a id="c3-para-2148"/>Use the results of exercises 3.60 and 3.61 to define a function <span class="KeyTerm1">div_series</span> that divides two power series. The function <span class="KeyTerm1">div_series</span> should work for any two series, provided that the denominator series begins with a nonzero constant term. (If the denominator has a zero constant term, then <span class="KeyTerm1">div_series</span> should signal an error.) Show how to use <span class="KeyTerm1">div_series</span> together with the result of exercise 3.59 to generate the power series for tangent.</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0110"/><span>3.5.3</span> <a id="c3-title-0111"/>Exploiting the Stream Paradigm</h3>
<p class="paraaftertitle"><a id="c3-para-2149"/>Streams with delayed evaluation can be a powerful modeling tool, providing many of the benefits of local state and assignment. Moreover, they avoid some of the theoretical tangles that accompany the introduction of assignment into a programming language.</p>
<p><a id="c3-para-2150"/>The stream approach can be illuminating because it allows us to build systems with different module boundaries than systems organized around assignment to state variables. For example, we can think of an entire time series (or signal) as a focus of interest, rather than the values of the state variables at individual moments. This makes it convenient to combine and compare components of state from different moments.</p>
<section>
<h5><a id="c3-sec-0111"/><a id="c3-title-0112"/>Formulating iterations as stream processes</h5>
<p class="paraaftertitle"><a id="c3-para-2151"/>In section 1.2.1, we introduced iterative processes, which proceed by updating state variables. We know now that we can represent state as a “timeless” stream of values rather than as a set of variables to be updated. Let's adopt this perspective in revisiting the square-root function from section 1.1.7. Recall that the idea is to generate a sequence of better and better guesses for the square root of <i>x</i> by applying over and over again the function that improves guesses:</p>
<p class="Sp-text-1"><a id="c3-para-2152"/><b>function</b> sqrt_improve(guess, x) {</p>
<p class="Sp-text-1"><a id="c3-para-2153"/>    <b>return</b> average(guess, x / guess);</p>
<p class="Sp-text-1"><a id="c3-para-2154"/>}</p>
<p><a id="c3-para-2155"/>In our original <span class="KeyTerm1">sqrt</span> function, we made these guesses be the successive values of a state variable. Instead we can generate the infinite stream of guesses, starting with an initial guess of 1:</p>
<p class="Sp-text-1"><a id="c3-para-2156"/><b>function</b> sqrt_stream(x) {</p>
<p class="Sp-text-1"><a id="c3-para-2157"/>    <b>return</b> pair(1, () =&gt; stream_map(guess =&gt; sqrt_improve(guess, x),</p>
<p class="Sp-text-1"><a id="c3-para-2158"/>                                    sqrt_stream(x)));</p>
<p class="Sp-text-1"><a id="c3-para-2159"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-2160"/>display_stream(sqrt_stream(2));</p>
<p class="Sp-text-1"><a id="c3-para-2161"/><i>1</i></p>
<p class="Sp-text-1"><a id="c3-para-2162"/><i>1.5</i></p>
<p class="Sp-text-1"><a id="c3-para-2163"/><i>1.4166666666666665</i></p>
<p class="Sp-text-1"><a id="c3-para-2164"/><i>1.4142156862745097</i></p>
<p class="Sp-text-1"><a id="c3-para-2165"/><i>1.4142135623746899</i></p>
<p class="Sp-text-1"><a id="c3-para-2166"/><i>…</i></p>
<p class="paracontinue"><a id="c3-para-2167"/>We can generate more and more terms of the stream to get better and better guesses. If we like, we can write a function that keeps generating terms until the answer is good enough. (See exercise 3.64.)</p>
<p><a id="c3-para-2168"/>Another iteration that we can treat in the same way is to generate an approximation to <i>π</i>, based upon the alternating series that we saw in section 1.3.1:</p>
<p><a id="c3-para-2169"/></p>
<figure id="c3-fig-0033"><img alt="c3-fig-5008.jpg" src="../images/c3-fig-5008.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c3-para-2170"/>We first generate the stream of summands of the series (the reciprocals of the odd integers, with alternating signs). Then we take the stream of sums of more and more terms (using the <span class="KeyTerm1">partial_sums</span> function of exercise 3.55) and scale the result by 4:</p>
<p class="Sp-text-1"><a id="c3-para-2171"/><b>function</b> pi_summands(n) {</p>
<p class="Sp-text-1"><a id="c3-para-2172"/>    <b>return</b> pair(1 / n, () =&gt; stream_map(x =&gt; - x, pi_summands(n + 2)));</p>
<p class="Sp-text-1"><a id="c3-para-2173"/>}</p>
<p class="Sp-text-1"><a id="c3-para-2174"/><b>const</b> pi_stream = scale_stream(partial_sums(pi_summands(1)), 4);</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c3-para-2175"/>display_stream(pi_stream);</p>
<p class="Sp-text-1"><a id="c3-para-2176"/><i>4</i></p>
<p class="Sp-text-1"><a id="c3-para-2177"/><i>2.666666666666667</i></p>
<p class="Sp-text-1"><a id="c3-para-2178"/><i>3.466666666666667</i></p>
<p class="Sp-text-1"><a id="c3-para-2179"/><i>2.8952380952380956</i></p>
<p class="Sp-text-1"><a id="c3-para-2180"/><i>3.3396825396825403</i></p>
<p class="Sp-text-1"><a id="c3-para-2181"/><i>2.9760461760461765</i></p>
<p class="Sp-text-1"><a id="c3-para-2182"/><i>3.2837384837384844</i></p>
<p class="Sp-text-1"><a id="c3-para-2183"/><i>3.017071817071818</i></p>
<p class="Sp-text-1"><a id="c3-para-2184"/><i>…</i></p>
<p class="paracontinue"><a id="c3-para-2185"/>This gives us a stream of better and better approximations to <i>π</i>, although the approximations converge rather slowly. Eight terms of the sequence bound the value of <i>π</i> between 3.284 and 3.017.</p>
<p><a id="c3-para-2186"/>So far, our use of the stream of states approach is not much different from updating state variables. But streams give us an opportunity to do some interesting tricks. For example, we can transform a stream with a <i>sequence accelerator</i> that converts a sequence of approximations to a new sequence that converges to the same value as the original, only faster.</p>
<p><a id="c3-para-2187"/>One such accelerator, due to the eighteenth-century Swiss mathematician Leonhard Euler, works well with sequences that are partial sums of alternating series (series of terms with alternating signs). In Euler's technique, if <i>S<sub>n </sub></i>is the <i>n</i>th term of the original sum sequence, then the accelerated sequence has terms</p>
<p><a id="c3-para-2188"/></p>
<figure id="c3-fig-0034"><img alt="c3-fig-5009.jpg" src="../images/c3-fig-5009.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c3-para-2189"/>Thus, if the original sequence is represented as a stream of values, the transformed sequence is given by</p>
<p class="Sp-text-1"><a id="c3-para-2190"/><b>function</b> euler_transform(s) {</p>
<p class="Sp-text-1"><a id="c3-para-2191"/>    <b>const</b> s0 = stream_ref(s, 0);     <span class="KeyTerm2"><i>// S<sub>n</sub></i><sub>–1</sub></span></p>
<p class="Sp-text-1"><a id="c3-para-2192"/>    <b>const</b> s1 = stream_ref(s, 1);     <span class="KeyTerm2"><i>// S<sub>n</sub></i></span></p>
<p class="Sp-text-1"><a id="c3-para-2193"/>    <b>const</b> s2 = stream_ref(s, 2);     <span class="KeyTerm2"><i>// S<sub>n</sub></i><sub>+1</sub></span></p>
<p class="Sp-text-1"><a id="c3-para-2194"/>    <b>return</b> pair(s2 - square(s2 - s1) / (s0 + (-2) * s1 + s2),</p>
<p class="Sp-text-1"><a id="c3-para-2195"/>                memo(() =&gt; euler_transform(stream_tail(s))));</p>
<p class="Sp-text-1"><a id="c3-para-2196"/>}</p>
<p class="paracontinue"><a id="c3-para-2197"/>Note that we make use of the memoization optimization of section 3.5.1, because in the following we will rely on repeated evaluation of the resulting stream.</p>
<p><a id="c3-para-2198"/>We can demonstrate Euler acceleration with our sequence of approximations to <i>π</i>:</p>
<p class="Sp-text-1"><a id="c3-para-2199"/>display_stream(euler_transform(pi_stream));</p>
<p class="Sp-text-1"><a id="c3-para-2200"/><i>3.166666666666667</i></p>
<p class="Sp-text-1"><a id="c3-para-2201"/><i>3.1333333333333337</i></p>
<p class="Sp-text-1"><a id="c3-para-2202"/><i>3.1452380952380956</i></p>
<p class="Sp-text-1"><a id="c3-para-2203"/><i>3.13968253968254</i></p>
<p class="Sp-text-1"><a id="c3-para-2204"/><i>3.1427128427128435</i></p>
<p class="Sp-text-1"><a id="c3-para-2205"/><i>3.1408813408813416</i></p>
<p class="Sp-text-1"><a id="c3-para-2206"/><i>3.142071817071818</i></p>
<p class="Sp-text-1"><a id="c3-para-2207"/><i>3.1412548236077655</i></p>
<p class="Sp-text-1"><a id="c3-para-2208"/><i>…</i></p>
<p><a id="c3-para-2209"/>Even better, we can accelerate the accelerated sequence, and recursively accelerate that, and so on. Namely, we create a stream of streams (a structure we'll call a <i>tableau</i>) in which each stream is the transform of the preceding one:</p>
<p class="Sp-text-1"><a id="c3-para-2210"/><b>function</b> make_tableau(transform, s) {</p>
<p class="Sp-text-1"><a id="c3-para-2211"/>    <b>return</b> pair(s, () =&gt; make_tableau(transform, transform(s)));</p>
<p class="Sp-text-1"><a id="c3-para-2212"/>}</p>
<p class="paracontinue"><a id="c3-para-2213"/>The tableau has the form</p>
<figure><figcaption class="tablecaption"><a id="c3-tbl-0006"/></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c3-para-2214"/><i>s</i><sub>00</sub></td>
<td><a id="c3-para-2215"/><i>s</i><sub>01</sub></td>
<td><a id="c3-para-2216"/><i>s</i><sub>02</sub></td>
<td><a id="c3-para-2217"/><i>s</i><sub>03</sub></td>
<td><a id="c3-para-2218"/><i>s</i><sub>04</sub></td>
<td><a id="c3-para-2219"/>. . .</td></tr>
<tr>
<td/>
<td><a id="c3-para-2220"/><i>s</i><sub>10</sub></td>
<td><a id="c3-para-2221"/><i>s</i><sub>11</sub></td>
<td><a id="c3-para-2222"/><i>s</i><sub>12</sub></td>
<td><a id="c3-para-2223"/><i>s</i><sub>13</sub></td>
<td><a id="c3-para-2224"/>. . .</td></tr>
<tr>
<td/>
<td/>
<td><a id="c3-para-2225"/><i>s</i><sub>20</sub></td>
<td><a id="c3-para-2226"/><i>s</i><sub>21</sub></td>
<td><a id="c3-para-2227"/><i>s</i><sub>22</sub></td>
<td><a id="c3-para-2228"/>. . .</td></tr>
<tr>
<td/>
<td/>
<td/>
<td/>
<td><a id="c3-para-2229"/>. . .</td>
<td/></tr></tbody></table></div>
</figure>

<p class="paracontinue"><a id="c3-para-2230"/>Finally, we form a sequence by taking the first term in each row of the tableau:</p>
<p class="Sp-text-1"><a id="c3-para-2231"/><b>function</b> accelerated_sequence(transform, s) {</p>
<p class="Sp-text-1"><a id="c3-para-2232"/>    <b>return</b> stream_map(head, make_tableau(transform, s));</p>
<p class="Sp-text-1"><a id="c3-para-2233"/>}</p>
<p><a id="c3-para-2234"/>We can demonstrate this kind of “super-acceleration” of the <i>π</i> sequence:</p>
<p class="Sp-text-1"><a id="c3-para-2235"/>display_stream(accelerated_sequence(euler_transform, pi_stream));</p>
<p class="Sp-text-1"><a id="c3-para-2236"/><i>4</i></p>
<p class="Sp-text-1"><a id="c3-para-2237"/><i>3.166666666666667</i></p>
<p class="Sp-text-1"><a id="c3-para-2238"/><i>3.142105263157895</i></p>
<p class="Sp-text-1"><a id="c3-para-2239"/><i>3.141599357319005</i></p>
<p class="Sp-text-1"><a id="c3-para-2240"/><i>3.1415927140337785</i></p>
<p class="Sp-text-1"><a id="c3-para-2241"/><i>3.1415926539752927</i></p>
<p class="Sp-text-1"><a id="c3-para-2242"/><i>3.1415926535911765</i></p>
<p class="Sp-text-1"><a id="c3-para-2243"/><i>3.141592653589778</i></p>
<p class="Sp-text-1"><a id="c3-para-2244"/><i>…</i></p>
<p class="paracontinue"><a id="c3-para-2245"/>The result is impressive. Taking eight terms of the sequence yields the correct value of <i>π</i> to 14 decimal places. If we had used only the original <i>π</i> sequence, we would need to compute on the order of 10<sup>13</sup> terms (i.e., expanding the series far enough so that the individual terms are less then 10<sup>–13</sup>) to get that much accuracy!</p>
<p><a id="c3-para-2246"/>We could have implemented these acceleration techniques without using streams. But the stream formulation is particularly elegant and convenient because the entire sequence of states is available to us as a data structure that can be manipulated with a uniform set of operations.</p>
</section>
<section>
<h5><a id="c3-sec-0112"/><a id="c3-title-0113"/>Exercise 3.63</h5>
<p class="paraaftertitle"><a id="c3-para-2247"/>Louis Reasoner is not happy with the performance of the stream produced by the <span class="KeyTerm1">sqrt_ stream</span> function and tries to optimize it using memoization:</p>
<p class="Sp-text-1"><a id="c3-para-2248"/><b>function</b> sqrt_stream_optimized(x) {</p>
<p class="Sp-text-1"><a id="c3-para-2249"/>    <b>return</b> pair(1,</p>
<p class="Sp-text-1"><a id="c3-para-2250"/>                memo(() =&gt; stream_map(guess =&gt;</p>
<p class="Sp-text-1"><a id="c3-para-2251"/>                                        sqrt_improve(guess, x),</p>
<p class="Sp-text-1"><a id="c3-para-2252"/>                                      sqrt_stream_optimized(x))));</p>
<p class="Sp-text-1"><a id="c3-para-2253"/>}</p>
<p class="paracontinue"><a id="c3-para-2254"/>Alyssa P. Hacker instead proposes</p>
<p class="Sp-text-1"><a id="c3-para-2255"/><b>function</b> sqrt_stream_optimized_2(x) {</p>
<p class="Sp-text-1"><a id="c3-para-2256"/>    <b>const</b> guesses = pair(1,</p>
<p class="Sp-text-1"><a id="c3-para-2257"/>                         memo(() =&gt; stream_map(guess =&gt;</p>
<p class="Sp-text-1"><a id="c3-para-2258"/>                                                 sqrt_improve(guess, x),</p>
<p class="Sp-text-1"><a id="c3-para-2259"/>                                               guesses)));</p>
<p class="Sp-text-1"><a id="c3-para-2260"/>    <b>return</b> guesses;</p>
<p class="Sp-text-1"><a id="c3-para-2261"/>}</p>
<p class="paracontinue"><a id="c3-para-2262"/>and claims that Louis's version is considerably less efficient than hers, because it performs redundant computation. Explain Alyssa's answer. Would Alyssa's approach without memoization be more efficient than the original <span class="KeyTerm1">sqrt_stream</span>?</p>
</section>
<section>
<h5><a id="c3-sec-0113"/><a id="c3-title-0114"/>Exercise 3.64</h5>
<p class="paraaftertitle"><a id="c3-para-2263"/>Write a function <span class="KeyTerm1">stream_limit</span> that takes as arguments a stream and a number (the tolerance). It should examine the stream until it finds two successive elements that differ in absolute value by less than the tolerance, and return the second of the two elements. Using this, we could compute square roots up to a given tolerance by</p>
<p class="Sp-text-1"><a id="c3-para-2264"/><b>function</b> sqrt(x, tolerance) {</p>
<p class="Sp-text-1"><a id="c3-para-2265"/>    <b>return</b> stream_limit(sqrt_stream(x), tolerance);</p>
<p class="Sp-text-1"><a id="c3-para-2266"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0114"/><a id="c3-title-0115"/>Exercise 3.65</h5>
<p class="paraaftertitle"><a id="c3-para-2267"/>Use the series</p>
<p class="Sp-text-2"><a id="c3-para-2268"/><img alt="c3-fig-5017.jpg" src="../images/c3-fig-5017.jpg"/></p>
<p class="paracontinue"><a id="c3-para-2269"/>to compute three sequences of approximations to the natural logarithm of 2, in the same way we did above for <i>π</i>. How rapidly do these sequences converge?</p>
</section>
<section>
<h5><a id="c3-sec-0115"/><a id="c3-title-0116"/>Infinite streams of pairs</h5>
<p class="paraaftertitle"><a id="c3-para-2270"/>In section 2.2.3, we saw how the sequence paradigm handles traditional nested loops as processes defined on sequences of pairs. If we generalize this technique to infinite streams, then we can write programs that are not easily represented as loops, because the “looping” must range over an infinite set.</p>
<p><a id="c3-para-2271"/>For example, suppose we want to generalize the <span class="KeyTerm1">prime_sum_pairs</span> function of section 2.2.3 to produce the stream of pairs of <i>all</i> integers (<i>i</i>, <i>j</i>) with <i>i</i> ≤ <i>j</i> such that <i>i</i> + <i>j</i> is prime. If <span class="KeyTerm1">int_pairs</span> is the sequence of all pairs of integers (<i>i</i>, <i>j</i>) with <i>i</i> ≤ <i>j</i>, then our required stream is simply<a id="c3-fn-0067a"/><a href="#c3-fn-0067"><sup>67</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-2272"/>stream_filter(pair =&gt; is_prime(head(pair) + head(tail(pair))),</p>
<p class="Sp-text-1"><a id="c3-para-2273"/>              int_pairs);</p>
<p><a id="c3-para-2274"/>Our problem, then, is to produce the stream <span class="KeyTerm1">int_pairs</span>. More generally, suppose we have two streams <i>S</i> = (<i>S<sub>i</sub></i>) and <i>T</i> = (<i>T<sub>j</sub></i>), and imagine the infinite rectangular array</p>
<figure><figcaption class="tablecaption"><a id="c3-tbl-0007"/></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c3-para-2275"/>(<i>S</i><sub>0</sub>, <i>T</i><sub>0</sub>)</td>
<td><a id="c3-para-2276"/>(<i>S</i><sub>0</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c3-para-2277"/>(<i>S</i><sub>0</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c3-para-2278"/><i>. . .</i></td></tr>
<tr>
<td><a id="c3-para-2279"/>(<i>S</i><sub>1</sub>, <i>T</i><sub>0</sub>)</td>
<td><a id="c3-para-2280"/>(<i>S</i><sub>1</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c3-para-2281"/>(<i>S</i><sub>1</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c3-para-2282"/><i>. . .</i></td></tr>
<tr>
<td><a id="c3-para-2283"/>(<i>S</i><sub>2</sub>, <i>T</i><sub>0</sub>)</td>
<td><a id="c3-para-2284"/>(<i>S</i><sub>2</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c3-para-2285"/>(<i>S</i><sub>2</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c3-para-2286"/><i>. . .</i></td></tr>
<tr>
<td><a id="c3-para-2287"/><i>. . .</i></td>
<td/>
<td/>
<td/></tr></tbody></table></div>
</figure>

<p class="paracontinue"><a id="c3-para-2288"/>We wish to generate a stream that contains all the pairs in the array that lie on or above the diagonal, i.e., the pairs</p>
<figure><figcaption class="tablecaption"><a id="c3-tbl-0008"/></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr>
<td><a id="c3-para-2289"/>(<i>S</i><sub>0</sub>, <i>T</i><sub>0</sub>)</td>
<td><a id="c3-para-2290"/>(<i>S</i><sub>0</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c3-para-2291"/>(<i>S</i><sub>0</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c3-para-2292"/><i>. . .</i></td></tr>
<tr>
<td/>
<td><a id="c3-para-2293"/>(<i>S</i><sub>1</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c3-para-2294"/>(<i>S</i><sub>1</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c3-para-2295"/><i>. . .</i></td></tr>
<tr>
<td/>
<td/>
<td><a id="c3-para-2296"/>(<i>S</i><sub>2</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c3-para-2297"/><i>. . .</i></td></tr>
<tr>
<td/>
<td/>
<td/>
<td><a id="c3-para-2298"/><i>. . .</i></td></tr></tbody></table></div>
</figure>

<p class="paracontinue"><a id="c3-para-2299"/>(If we take both <i>S</i> and <i>T</i> to be the stream of integers, then this will be our desired stream <span class="KeyTerm1">int_pairs</span>.)</p>
<p><a id="c3-para-2300"/>Call the general stream of pairs <span class="KeyTerm1">pairs(S, T)</span>, and consider it to be composed of three parts: the pair (<i>S</i><sub>0</sub>, <i>T</i><sub>0</sub>), the rest of the pairs in the first row, and the remaining pairs:<a id="c3-fn-0068a"/><a href="#c3-fn-0068"><sup>68</sup></a></p>
<figure><figcaption class="tablecaption"><a id="c3-tbl-0009"/></figcaption>
<div class="big_device">
<table class="BS_TableNone"><tbody>
<tr style="border-bottom:1px solid #000000;">
<td style="border-right:1px solid #000000;"><a id="c3-para-2301"/>(<i>S</i><sub>0</sub>, <i>T</i><sub>0</sub>)</td>
<td><a id="c3-para-2302"/>(<i>S</i><sub>0</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c3-para-2303"/>(<i>S</i><sub>0</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c3-para-2304"/><i>. . .</i></td></tr>
<tr>
<td style="border-right:1px solid #000000;"/>
<td><a id="c3-para-2305"/>(<i>S</i><sub>1</sub>, <i>T</i><sub>1</sub>)</td>
<td><a id="c3-para-2306"/>(<i>S</i><sub>1</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c3-para-2307"/><i>. . .</i></td></tr>
<tr>
<td style="border-right:1px solid #000000;"/>
<td/>
<td><a id="c3-para-2308"/>(<i>S</i><sub>2</sub>, <i>T</i><sub>2</sub>)</td>
<td><a id="c3-para-2309"/><i>. . .</i></td></tr>
<tr>
<td style="border-right:1px solid #000000;"/>
<td/>
<td/>
<td><a id="c3-para-2310"/><i>. . .</i></td></tr></tbody></table></div>
</figure>

<p class="paracontinue"><a id="c3-para-2311"/>Observe that the third piece in this decomposition (pairs that are not in the first row) is (recursively) the pairs formed from <span class="KeyTerm1">stream_tail(S)</span> and <span class="KeyTerm1">stream_tail(T)</span>. Also note that the second piece (the rest of the first row) is</p>
<p class="Sp-text-1"><a id="c3-para-2312"/>stream_map(x =&gt; list(head(s), x),</p>
<p class="Sp-text-1"><a id="c3-para-2313"/>stream_tail(t));</p>
<p class="paracontinue"><a id="c3-para-2314"/>Thus we can form our stream of pairs as follows:</p>
<p class="Sp-text-1"><a id="c3-para-2315"/><b>function</b> pairs(s, t) {</p>
<p class="Sp-text-1"><a id="c3-para-2316"/>    <b>return</b> pair(list(head(s), head(t)),</p>
<p class="Sp-text-1"><a id="c3-para-2317"/>                () =&gt; <span class="KeyTerm2"><i>combine</i>-<i>in</i>-<i>some</i>-<i>way</i></span>(</p>
<p class="Sp-text-1"><a id="c3-para-2318"/>                          stream_map(x =&gt; list(head(s), x),</p>
<p class="Sp-text-1"><a id="c3-para-2319"/>                                     stream_tail(t)),</p>
<p class="Sp-text-1"><a id="c3-para-2320"/>                          pairs(stream_tail(s), stream_tail(t))));</p>
<p class="Sp-text-1"><a id="c3-para-2321"/>}</p>
<p><a id="c3-para-2322"/>In order to complete the function, we must choose some way to combine the two inner streams. One idea is to use the stream analog of the <span class="KeyTerm1">append</span> function from section 2.2.1:</p>
<p class="Sp-text-1"><a id="c3-para-2323"/><b>function</b> stream_append(s1, s2) {</p>
<p class="Sp-text-1"><a id="c3-para-2324"/>    <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c3-para-2325"/>           ? s2</p>
<p class="Sp-text-1"><a id="c3-para-2326"/>           : pair(head(s1),</p>
<p class="Sp-text-1"><a id="c3-para-2327"/>                  () =&gt; stream_append(stream_tail(s1), s2));</p>
<p class="Sp-text-1"><a id="c3-para-2328"/>}</p>
<p class="paracontinue"><a id="c3-para-2329"/>This is unsuitable for infinite streams, however, because it takes all the elements from the first stream before incorporating the second stream. In particular, if we try to generate all pairs of positive integers using</p>
<p class="Sp-text-1"><a id="c3-para-2330"/>pairs(integers, integers);</p>
<p class="paracontinue"><a id="c3-para-2331"/>our stream of results will first try to run through all pairs with the first integer equal to 1, and hence will never produce pairs with any other value of the first integer.</p>
<p><a id="c3-para-2332"/>To handle infinite streams, we need to devise an order of combination that ensures that every element will eventually be reached if we let our program run long enough. An elegant way to accomplish this is with the following <span class="KeyTerm1">interleave</span> function:<a id="c3-fn-0069a"/><a href="#c3-fn-0069"><sup>69</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-2333"/><b>function</b> interleave(s1, s2) {</p>
<p class="Sp-text-1"><a id="c3-para-2334"/>    <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c3-para-2335"/>           ? s2</p>
<p class="Sp-text-1"><a id="c3-para-2336"/>           : pair(head(s1),</p>
<p class="Sp-text-1"><a id="c3-para-2337"/>                  () =&gt; interleave(s2, stream_tail(s1)));</p>
<p class="Sp-text-1"><a id="c3-para-2338"/>}</p>
<p class="paracontinue"><a id="c3-para-2339"/>Since <span class="KeyTerm1">interleave</span> takes elements alternately from the two streams, every element of the second stream will eventually find its way into the interleaved stream, even if the first stream is infinite.</p>
<p><a id="c3-para-2340"/>We can thus generate the required stream of pairs as</p>
<p class="Sp-text-1"><a id="c3-para-2341"/><b>function</b> pairs(s, t) {</p>
<p class="Sp-text-1"><a id="c3-para-2342"/>    <b>return</b> pair(list(head(s), head(t)),</p>
<p class="Sp-text-1"><a id="c3-para-2343"/>                () =&gt; interleave(stream_map(x =&gt; list(head(s), x),</p>
<p class="Sp-text-1"><a id="c3-para-2344"/>                                            stream_tail(t)),</p>
<p class="Sp-text-1"><a id="c3-para-2345"/>                                 pairs(stream_tail(s),</p>
<p class="Sp-text-1"><a id="c3-para-2346"/>                                       stream_tail(t))));</p>
<p class="Sp-text-1"><a id="c3-para-2347"/>}</p>
</section>
<section>
<h5><a id="c3-sec-0116"/><a id="c3-title-0117"/>Exercise 3.66</h5>
<p class="paraaftertitle"><a id="c3-para-2348"/>Examine the stream <span class="KeyTerm1">pairs(integers, integers)</span>. Can you make any general comments about the order in which the pairs are placed into the stream? For example, approximately how many pairs precede the pair (1,100)? the pair (99,100)? the pair (100,100)? (If you can make precise mathematical statements here, all the better. But feel free to give more qualitative answers if you find yourself getting bogged down.)</p>
</section>
<section>
<h5><a id="c3-sec-0117"/><a id="c3-title-0118"/>Exercise 3.67</h5>
<p class="paraaftertitle"><a id="c3-para-2349"/>Modify the <span class="KeyTerm1">pairs</span> function so that <span class="KeyTerm1">pairs(integers, integers)</span> will produce the stream of <i>all</i> pairs of integers (<i>i</i>, <i>j</i>) (without the condition <i>i</i> ≤ <i>j</i>). Hint: You will need to mix in an additional stream.</p>
</section>
<section>
<h5><a id="c3-sec-0118"/><a id="c3-title-0119"/>Exercise 3.68</h5>
<p class="paraaftertitle"><a id="c3-para-2350"/>Louis Reasoner thinks that building a stream of pairs from three parts is unnecessarily complicated. Instead of separating the pair (<i>S</i><sub>0</sub>, <i>T</i><sub>0</sub>) from the rest of the pairs in the first row, he proposes to work with the whole first row, as follows:</p>
<p class="Sp-text-1"><a id="c3-para-2351"/><b>function</b> pairs(s, t) {</p>
<p class="Sp-text-1"><a id="c3-para-2352"/>    <b>return</b> interleave(stream_map(x =&gt; list(head(s), x),</p>
<p class="Sp-text-1"><a id="c3-para-2353"/>                                 t),</p>
<p class="Sp-text-1"><a id="c3-para-2354"/>                      pair(stream_tail(s), stream_tail(t)));</p>
<p class="Sp-text-1"><a id="c3-para-2355"/>}</p>
<p class="paracontinue"><a id="c3-para-2356"/>Does this work? Consider what happens if we evaluate <span class="KeyTerm1">pairs(integers, integers)</span> using Louis's definition of <span class="KeyTerm1">pairs</span>.</p>
</section>
<section>
<h5><a id="c3-sec-0119"/><a id="c3-title-0120"/>Exercise 3.69</h5>
<p class="paraaftertitle"><a id="c3-para-2357"/>Write a function <span class="KeyTerm1">triples</span> that takes three infinite streams, <i>S</i>, <i>T</i>, and <i>U</i>, and produces the stream of triples (<i>S<sub>i</sub></i>, <i>T<sub>j</sub></i>, <i>U<sub>k</sub></i>) such that <i>i</i> ≤ <i>j ≤ k</i>. Use <span class="KeyTerm1">triples</span> to generate the stream of all Pythagorean triples of positive integers, i.e., the triples (<i>i</i>, <i>j</i>, <i>k</i>) such that <i>i ≤ j</i> and <i>i</i><sup>2</sup> + <i>j</i><sup>2</sup> = <i>k</i><sup>2</sup>.</p>
</section>
<section>
<h5><a id="c3-sec-0120"/><a id="c3-title-0121"/>Exercise 3.70</h5>
<p class="paraaftertitle"><a id="c3-para-2358"/>It would be nice to be able to generate streams in which the pairs appear in some useful order, rather than in the order that results from an <i>ad hoc</i> interleaving process. We can use a technique similar to the <span class="KeyTerm1">merge</span> function of exercise 3.56, if we define a way to say that one pair of integers is “less than” another. One way to do this is to define a “weighting function” <i>W</i>(<i>i</i>, <i>j</i>) and stipulate that (<i>i</i><sub>1</sub>, <i>j</i><sub>1</sub>) is less than (<i>i</i><sub>2</sub>, <i>j</i><sub>2</sub>) if <i>W</i>(<i>i</i><sub>1</sub>, <i>j</i><sub>1</sub>) &lt; <i>W</i>(<i>i</i><sub>2</sub>, <i>j</i><sub>2</sub>). Write a function <span class="KeyTerm1">merge_weighted</span> that is like <span class="KeyTerm1">merge</span>, except that <span class="KeyTerm1">merge_weighted</span> takes an additional argument <span class="KeyTerm1">weight</span>, which is a function that computes the weight of a pair, and is used to determine the order in which elements should appear in the resulting merged stream.<a id="c3-fn-0070a"/><a href="#c3-fn-0070"><sup>70</sup></a> Using this, generalize <span class="KeyTerm1">pairs</span> to a function <span class="KeyTerm1">weighted_pairs</span> that takes two streams, together with a function that computes a weighting function, and generates the stream of pairs, ordered according to weight. Use your function to generate</p>
<ol class="BS_NumberListA">
<li><a id="c3-li-0037"/><span>a. </span>the stream of all pairs of positive integers (<i>i</i>, <i>j</i>) with <i>i</i> ≤ <i>j</i> ordered according to the sum <i>i</i> + <i>j</i></li>
<li><a id="c3-li-0038"/><span>b. </span>the stream of all pairs of positive integers (<i>i</i>, <i>j</i>) with <i>i</i> ≤ <i>j</i>, where neither <i>i</i> nor <i>j</i> is divisible by 2, 3, or 5, and the pairs are ordered according to the sum 2<i>i</i> + 3<i>j</i> + 5<i>ij</i>.</li>
</ol>
</section>
<section>
<h5><a id="c3-sec-0121"/><a id="c3-title-0122"/>Exercise 3.71</h5>
<p class="paraaftertitle"><a id="c3-para-2361"/>Numbers that can be expressed as the sum of two cubes in more than one way are sometimes called <i>Ramanujan numbers</i>, in honor of the mathematician Srinivasa Ramanujan.<a id="c3-fn-0071a"/><a href="#c3-fn-0071"><sup>71</sup></a> Ordered streams of pairs provide an elegant solution to the problem of computing these numbers. To find a number that can be written as the sum of two cubes in two different ways, we need only generate the stream of pairs of integers (<i>i</i>, <i>j</i>) weighted according to the sum <i>i</i><sup>3</sup> + <i>j</i><sup>3</sup> (see exercise 3.70), then search the stream for two consecutive pairs with the same weight. Write a function to generate the Ramanujan numbers. The first such number is 1,729. What are the next five?</p>
</section>
<section>
<h5><a id="c3-sec-0122"/><a id="c3-title-0123"/>Exercise 3.72</h5>
<p class="paraaftertitle"><a id="c3-para-2362"/>In a similar way to exercise 3.71 generate a stream of all numbers that can be written as the sum of two squares in three different ways (showing how they can be so written).</p>
</section>
<section>
<h5><a id="c3-sec-0123"/><a id="c3-title-0124"/>Streams as signals</h5>
<p class="paraaftertitle"><a id="c3-para-2363"/>We began our discussion of streams by describing them as computational analogs of the “signals” in signal-processing systems. In fact, we can use streams to model signal-processing systems in a very direct way, representing the values of a signal at successive time intervals as consecutive elements of a stream. For instance, we can implement an <i>integrator</i> or <i>summer</i> that, for an input stream <i>x</i> = (<i>x<sub>i</sub></i>), an initial value <i>C</i>, and a small increment <i>dt</i>, accumulates the sum</p>
<p><a id="c3-para-2364"/></p>
<figure id="c3-fig-0035"><img alt="c3-fig-5010.jpg" src="../images/c3-fig-5010.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c3-para-2365"/>and returns the stream of values <i>S</i> = (<i>S<sub>i</sub></i>). The following <span class="KeyTerm1">integral</span> function is reminiscent of the “implicit style” definition of the stream of integers (section 3.5.2):</p>
<p class="Sp-text-1"><a id="c3-para-2366"/><b>function</b> integral(integrand, initial_value, dt) {</p>
<p class="Sp-text-1"><a id="c3-para-2367"/>    <b>const</b> integ = pair(initial_value,</p>
<p class="Sp-text-1"><a id="c3-para-2368"/>                       () =&gt; add_streams(scale_stream(integrand, dt),</p>
<p class="Sp-text-1"><a id="c3-para-2369"/>                                         integ));</p>
<p class="Sp-text-1"><a id="c3-para-2370"/>    <b>return</b> integ;</p>
<p class="Sp-text-1"><a id="c3-para-2371"/>}</p>
<p class="paracontinue"><a id="c3-para-2372"/><a id="c3-fig-0036a"/><a href="#c3-fig-0036">Figure 3.32</a> is a picture of a signal-processing system that corresponds to the <span class="KeyTerm1">integral</span> function. The input stream is scaled by <i>dt</i> and passed through an adder, whose output is passed back through the same adder. The self-reference in the definition of <span class="KeyTerm1">integ</span> is reflected in the figure by the feedback loop that connects the output of the adder to one of the inputs.</p>
<figure id="c3-fig-0036"><img alt="c3-fig-0032.jpg" src="../images/c3-fig-0032.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0036a">Figure 3.32</a></span> <a id="c3-para-2373"/>The <span class="KeyTerm1">integral</span> function viewed as a signal-processing system.</p></figcaption></figure>
</section>
<section>
<h5><a id="c3-sec-0124"/><a id="c3-title-0125"/>Exercise 3.73</h5>
<p class="paraaftertitle"><a id="c3-para-2374"/>We can model electrical circuits using streams to represent the values of currents or voltages at a sequence of times. For instance, suppose we have an <i>RC circuit</i> consisting of a resistor of resistance <i>R</i> and a capacitor of capacitance <i>C</i> in series. The voltage response <i>v</i> of the circuit to an injected current <i>i</i> is determined by the formula in <a id="c3-fig-0037a"/><a href="#c3-fig-0037">figure 3.33</a>, whose structure is shown by the accompanying signal-flow diagram.</p>
<figure id="c3-fig-0037"><img alt="c3-fig-0033.jpg" src="../images/c3-fig-0033.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0037a">Figure 3.33</a></span> <a id="c3-para-2375"/>An RC circuit and the associated signal-flow diagram.</p></figcaption></figure>
<p><a id="c3-para-2376"/>Write a function <span class="KeyTerm1">RC</span> that models this circuit. <span class="KeyTerm1">RC</span> should take as inputs the values of <i>R</i>, <i>C</i>, and <i>dt</i> and should return a function that takes as inputs a stream representing the current <i>i</i> and an initial value for the capacitor voltage <i>v</i><sub>0</sub> and produces as output the stream of voltages <i>v</i>. For example, you should be able to use <span class="KeyTerm1">RC</span> to model an RC circuit with <i>R</i> = 5 ohms, <i>C</i> = 1 farad, and a 0.5-second time step by evaluating <span class="KeyTerm1"><b>const</b> RC1 = RC(5, 1, 0.5)</span>. This defines <span class="KeyTerm1">RC1</span> as a function that takes a stream representing the time sequence of currents and an initial capacitor voltage and produces the output stream of voltages.</p>
</section>
<section>
<h5><a id="c3-sec-0125"/><a id="c3-title-0126"/>Exercise 3.74</h5>
<p class="paraaftertitle"><a id="c3-para-2377"/>Alyssa P. Hacker is designing a system to process signals coming from physical sensors. One important feature she wishes to produce is a signal that describes the <i>zero crossings</i> of the input signal. That is, the resulting signal should be +1 whenever the input signal changes from negative to positive, –1 whenever the input signal changes from positive to negative, and 0 otherwise. (Assume that the sign of a 0 input is positive.) For example, a typical input signal with its associated zero-crossing signal would be</p>
<p><a id="c3-para-2378"/></p>
<figure id="c3-fig-0038"><img alt="c3-fig-5011.jpg" src="../images/c3-fig-5011.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c3-para-2379"/>In Alyssa's system, the signal from the sensor is represented as a stream <span class="KeyTerm1">sense_data</span> and the stream <span class="KeyTerm1">zero_crossings</span> is the corresponding stream of zero crossings. Alyssa first writes a function <span class="KeyTerm1">sign_change_detector</span> that takes two values as arguments and compares the signs of the values to produce an appropriate 0, 1, or –1. She then constructs her zero-crossing stream as follows:</p>
<p class="Sp-text-1"><a id="c3-para-2380"/><b>function</b> make_zero_crossings(input_stream, last_value) {</p>
<p class="Sp-text-1"><a id="c3-para-2381"/>    <b>return</b> pair(sign_change_detector(head(input_stream), last_value),</p>
<p class="Sp-text-1"><a id="c3-para-2382"/>                () =&gt; make_zero_crossings(stream_tail(input_stream),</p>
<p class="Sp-text-1"><a id="c3-para-2383"/>                                          head(input_stream)));</p>
<p class="Sp-text-1"><a id="c3-para-2384"/>}</p>
<p class="Sp-text-1"><a id="c3-para-2385"/><b>const</b> zero_crossings = make_zero_crossings(sense_data, 0);</p>
<p class="paracontinue"><a id="c3-para-2386"/>Alyssa's boss, Eva Lu Ator, walks by and suggests that this program is approximately equivalent to the following one, which uses the function <span class="KeyTerm1">stream_map_2</span> from exercise 3.50:</p>
<p class="Sp-text-1"><a id="c3-para-2387"/><b>const</b> zero_crossings = stream_map_2(sign_change_detector,</p>
<p class="Sp-text-1"><a id="c3-para-2388"/>                                    sense_data,</p>
<p class="Sp-text-1"><a id="c3-para-2389"/>                                    <span class="KeyTerm2"><i>expression</i></span>);</p>
<p class="paracontinue"><a id="c3-para-2390"/>Complete the program by supplying the indicated <i>expression</i>.</p>
</section>
<section>
<h5><a id="c3-sec-0126"/><a id="c3-title-0127"/>Exercise 3.75</h5>
<p class="paraaftertitle"><a id="c3-para-2391"/>Unfortunately, Alyssa's zero-crossing detector in exercise 3.74 proves to be insufficient, because the noisy signal from the sensor leads to spurious zero crossings. Lem E. Tweakit, a hardware specialist, suggests that Alyssa smooth the signal to filter out the noise before extracting the zero crossings. Alyssa takes his advice and decides to extract the zero crossings from the signal constructed by averaging each value of the sense data with the previous value. She explains the problem to her assistant, Louis Reasoner, who attempts to implement the idea, altering Alyssa's program as follows:</p>
<p class="Sp-text-1"><a id="c3-para-2392"/><b>function</b> make_zero_crossings(input_stream, last_value) {</p>
<p class="Sp-text-1"><a id="c3-para-2393"/>    <b>const</b> avpt = (head(input_stream) + last_value) / 2;</p>
<p class="Sp-text-1"><a id="c3-para-2394"/>    <b>return</b> pair(sign_change_detector(avpt, last_value),</p>
<p class="Sp-text-1"><a id="c3-para-2395"/>                () =&gt; make_zero_crossings(stream_tail(input_stream),</p>
<p class="Sp-text-1"><a id="c3-para-2396"/>                                          avpt));</p>
<p class="Sp-text-1"><a id="c3-para-2397"/>}</p>
<p class="paracontinue"><a id="c3-para-2398"/>This does not correctly implement Alyssa's plan. Find the bug that Louis has installed and fix it without changing the structure of the program. (Hint: You will need to increase the number of arguments to <span class="KeyTerm1">make_zero_crossings</span>.)</p>
</section>
<section>
<h5><a id="c3-sec-0127"/><a id="c3-title-0128"/>Exercise 3.76</h5>
<p class="paraaftertitle"><a id="c3-para-2399"/>Eva Lu Ator has a criticism of Louis's approach in exercise 3.75. The program he wrote is not modular, because it intermixes the operation of smoothing with the zero-crossing extraction. For example, the extractor should not have to be changed if Alyssa finds a better way to condition her input signal. Help Louis by writing a function <span class="KeyTerm1">smooth</span> that takes a stream as input and produces a stream in which each element is the average of two successive input stream elements. Then use <span class="KeyTerm1">smooth</span> as a component to implement the zero-crossing detector in a more modular style.</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0128"/><span>3.5.4</span> <a id="c3-title-0129"/>Streams and Delayed Evaluation</h3>
<p class="paraaftertitle"><a id="c3-para-2400"/>The <span class="KeyTerm1">integral</span> function at the end of the preceding section shows how we can use streams to model signal-processing systems that contain feedback loops. The feedback loop for the adder shown in <a href="#c3-fig-0036">figure 3.32</a> is modeled by the fact that <span class="KeyTerm1">integral</span>'s internal stream <span class="KeyTerm1">integ</span> is defined in terms of itself:</p>
<p class="Sp-text-1"><a id="c3-para-2401"/><b>const</b> integ = pair(initial_value,</p>
<p class="Sp-text-1"><a id="c3-para-2402"/>                   () =&gt; add_streams(scale_stream(integrand, dt),</p>
<p class="Sp-text-1"><a id="c3-para-2403"/>                                     integ));</p>
<p class="paracontinue"><a id="c3-para-2404"/>The interpreter's ability to deal with such an implicit definition depends on the delay resulting from wrapping the call to <span class="KeyTerm1">add_streams</span> in a lambda expression. Without this delay, the interpreter could not construct <span class="KeyTerm1">integ</span> before evaluating the call to <span class="KeyTerm1">add_streams</span>, which would require that <span class="KeyTerm1">integ</span> already be defined. In general, such a delay is crucial for using streams to model signal-processing systems that contain loops. Without a delay, our models would have to be formulated so that the inputs to any signal-processing component would be fully evaluated before the output could be produced. This would outlaw loops.</p>
<p><a id="c3-para-2405"/>Unfortunately, stream models of systems with loops may require uses of a delay beyond the stream programming pattern seen so far. For instance, <a id="c3-fig-0039a"/><a href="#c3-fig-0039">figure 3.34</a> shows a signal-processing system for solving the differential equation <i>dy</i>/<i>dt</i> = <i>f</i> (<i>y</i>) where <i>f</i> is a given function. The figure shows a mapping component, which applies <i>f</i> to its input signal, linked in a feedback loop to an integrator in a manner very similar to that of the analog computer circuits that are actually used to solve such equations.</p>
<figure id="c3-fig-0039"><img alt="c3-fig-0034.jpg" src="../images/c3-fig-0034.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0039a">Figure 3.34</a></span> <a id="c3-para-2406"/>An “analog computer circuit” that solves the equation <i>dy</i>/<i>dt</i> = <i>f</i> (<i>y</i>).</p></figcaption></figure>
<p><a id="c3-para-2407"/>Assuming we are given an initial value <i>y</i><sub>0</sub> for <i>y</i>, we could try to model this system using the function</p>
<p class="Sp-text-1"><a id="c3-para-2408"/><b>function</b> solve(f, y0, dt) {</p>
<p class="Sp-text-1"><a id="c3-para-2409"/>    <b>const</b> y = integral(dy, y0, dt);</p>
<p class="Sp-text-1"><a id="c3-para-2410"/>    <b>const</b> dy = stream_map(f, y);</p>
<p class="Sp-text-1"><a id="c3-para-2411"/>    <b>return</b> y;</p>
<p class="Sp-text-1"><a id="c3-para-2412"/>}</p>
<p class="paracontinue"><a id="c3-para-2413"/>This function does not work, because in the first line of <span class="KeyTerm1">solve</span> the call to <span class="KeyTerm1">integral</span> requires that the input <span class="KeyTerm1">dy</span> be defined, which does not happen until the second line of <span class="KeyTerm1">solve</span>.</p>
<p><a id="c3-para-2414"/>On the other hand, the intent of our definition does make sense, because we can, in principle, begin to generate the <span class="KeyTerm1">y</span> stream without knowing <span class="KeyTerm1">dy</span>. Indeed, <span class="KeyTerm1">integral</span> and many other stream operations can generate part of the answer given only partial information about the arguments. For <span class="KeyTerm1">integral</span>, the first element of the output stream is the specified <span class="KeyTerm1">initial_value</span>. Thus, we can generate the first element of the output stream without evaluating the integrand <span class="KeyTerm1">dy</span>. Once we know the first element of <span class="KeyTerm1">y</span>, the <span class="KeyTerm1">stream_map</span> in the second line of <span class="KeyTerm1">solve</span> can begin working to generate the first element of <span class="KeyTerm1">dy</span>, which will produce the next element of <span class="KeyTerm1">y</span>, and so on.</p>
<p><a id="c3-para-2415"/>To take advantage of this idea, we will redefine <span class="KeyTerm1">integral</span> to expect the integrand stream to be a <i>delayed argument</i>. The function <span class="KeyTerm1">integral</span> will force the integrand to be evaluated only when it is required to generate more than the first element of the output stream:</p>
<p class="Sp-text-1"><a id="c3-para-2416"/><b>function</b> integral(delayed_integrand, initial_value, dt) {</p>
<p class="Sp-text-1"><a id="c3-para-2417"/>    <b>const</b> integ =</p>
<p class="Sp-text-1"><a id="c3-para-2418"/>        pair(initial_value, </p>
<p class="Sp-text-1"><a id="c3-para-2419"/>             () =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-2420"/>                 <b>const</b> integrand = delayed_integrand();</p>
<p class="Sp-text-1"><a id="c3-para-2421"/>                 <b>return</b> add_streams(scale_stream(integrand, dt),</p>
<p class="Sp-text-1"><a id="c3-para-2422"/>                                    integ);</p>
<p class="Sp-text-1"><a id="c3-para-2423"/>             });</p>
<p class="Sp-text-1"><a id="c3-para-2424"/>    <b>return</b> integ;</p>
<p class="Sp-text-1"><a id="c3-para-2425"/>}</p>
<p class="paracontinue"><a id="c3-para-2426"/>Now we can implement our <span class="KeyTerm1">solve</span> function by delaying the evaluation of <span class="KeyTerm1">dy</span> in the declaration of <span class="KeyTerm1">y</span>:</p>
<p class="Sp-text-1"><a id="c3-para-2427"/><b>function</b> solve(f, y0, dt) {</p>
<p class="Sp-text-1"><a id="c3-para-2428"/>    <b>const</b> y = integral(() =&gt; dy, y0, dt);</p>
<p class="Sp-text-1"><a id="c3-para-2429"/>    <b>const</b> dy = stream_map(f, y);</p>
<p class="Sp-text-1"><a id="c3-para-2430"/>    <b>return</b> y;</p>
<p class="Sp-text-1"><a id="c3-para-2431"/>}</p>
<p class="paracontinue"><a id="c3-para-2432"/>In general, every caller of <span class="KeyTerm1">integral</span> must now delay the integrand argument. We can demonstrate that the <span class="KeyTerm1">solve</span> function works by approximating <i>e</i> ≈ 2.718 by computing the value at <i>y</i> = 1 of the solution to the differential equation <i>dy</i>/<i>dt</i> = <i>y</i> with initial condition <i>y</i>(0) = 1:<a id="c3-fn-0072a"/><a href="#c3-fn-0072"><sup>72</sup></a></p>
<p class="Sp-text-1"><a id="c3-para-2433"/>stream_ref(solve(y =&gt; y, 1, 0.001), 1000);</p>
<p class="Sp-text-1"><a id="c3-para-2434"/><i>2.716923932235896</i></p>
<section>
<h5><a id="c3-sec-0129"/><a id="c3-title-0130"/>Exercise 3.77</h5>
<p class="paraaftertitle"><a id="c3-para-2435"/>The <span class="KeyTerm1">integral</span> function used above was analogous to the “implicit” definition of the infinite stream of integers in section 3.5.2. Alternatively, we can give a definition of <span class="KeyTerm1">integral</span> that is more like <span class="KeyTerm1">integers-starting-from</span> (also in section 3.5.2):</p>
<p class="Sp-text-1"><a id="c3-para-2436"/><b>function</b> integral(integrand, initial_value, dt) {</p>
<p class="Sp-text-1"><a id="c3-para-2437"/>    <b>return</b> pair(initial_value,</p>
<p class="Sp-text-1"><a id="c3-para-2438"/>                is_null(integrand)</p>
<p class="Sp-text-1"><a id="c3-para-2439"/>                ? <b>null</b></p>
<p class="Sp-text-1"><a id="c3-para-2440"/>                : integral(stream_tail(integrand),</p>
<p class="Sp-text-1"><a id="c3-para-2441"/>                           dt * head(integrand) + initial_value,</p>
<p class="Sp-text-1"><a id="c3-para-2442"/>                           dt));</p>
<p class="Sp-text-1"><a id="c3-para-2443"/>}</p>
<p class="paracontinue"><a id="c3-para-2444"/>When used in systems with loops, this function has the same problem as does our original version of <span class="KeyTerm1">integral</span>. Modify the function so that it expects the <span class="KeyTerm1">integrand</span> as a delayed argument and hence can be used in the <span class="KeyTerm1">solve</span> function shown above.</p>
</section>
<section>
<h5><a id="c3-sec-0130"/><a id="c3-title-0131"/>Exercise 3.78</h5>
<p class="paraaftertitle"><a id="c3-para-2445"/>Consider the problem of designing a signal-processing system to study the homogeneous second-order linear differential equation</p>
<p><a id="c3-para-2446"/></p>
<figure id="c3-fig-0052"><img alt="c3-fig-5012.jpg" src="../images/c3-fig-5012.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c3-para-2447"/>The output stream, modeling <i>y</i>, is generated by a network that contains a loop. This is because the value of <i>d</i><sup>2</sup><i>y</i>/<i>dt</i><sup>2</sup> depends upon the values of <i>y</i> and <i>dy</i>/<i>dt</i> and both of these are determined by integrating <i>d</i><sup>2</sup><i>y</i>/<i>dt</i><sup>2</sup>. The diagram we would like to encode is shown in <a id="c3-fig-0040a"/><a href="#c3-fig-0040">figure 3.35</a>. Write a function <span class="KeyTerm1">solve_2nd</span> that takes as arguments the constants <i>a</i>, <i>b</i>, and <i>dt</i> and the initial values <i>y</i><sub>0</sub> and <i>dy</i><sub>0</sub> for <i>y</i> and <i>dy</i>/<i>dt</i> and generates the stream of successive values of <i>y</i>.</p>
<figure id="c3-fig-0040"><img alt="c3-fig-0035.jpg" src="../images/c3-fig-0035.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0040a">Figure 3.35</a></span> <a id="c3-para-2448"/>Signal-flow diagram for the solution to a second-order linear differential equation.</p></figcaption></figure>
</section>
<section>
<h5><a id="c3-sec-0131"/><a id="c3-title-0132"/>Exercise 3.79</h5>
<p class="paraaftertitle"><a id="c3-para-2449"/>Generalize the <span class="KeyTerm1">solve_2nd</span> function of exercise 3.78 so that it can be used to solve general second-order differential equations <i>d</i><sup>2</sup><i>y</i>/<i>dt</i><sup>2</sup> = <i>f</i> (<i>dy</i>/<i>dt</i>, <i>y</i>).</p>
</section>
<section>
<h5><a id="c3-sec-0132"/><a id="c3-title-0133"/>Exercise 3.80</h5>
<p class="paraaftertitle"><a id="c3-para-2450"/>A <i>series RLC circuit</i> consists of a resistor, a capacitor, and an inductor connected in series, as shown in <a id="c3-fig-0041a"/><a href="#c3-fig-0041">figure 3.36</a>. If <i>R</i>, <i>L</i>, and <i>C</i> are the resistance, inductance, and capacitance, then the relations between voltage (<i>v</i>) and current (<i>i</i>) for the three components are described by the equations</p>
<p><a id="c3-para-2453"/></p>
<figure id="c3-fig-0053"><img alt="c3-fig-5013.jpg" src="../images/c3-fig-5013.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c3-para-2454"/>and the circuit connections dictate the relations</p>
<p class="Sp-text-2"><a id="c3-para-2455"/><i>i<sub>R</sub></i> = <i>i<sub>L</sub></i> = –<i>i<sub>C</sub></i></p>
<p class="Sp-text-2"><a id="c3-para-2456"/><i>v<sub>C</sub></i> = <i>v<sub>L</sub></i> + <i>v<sub>R</sub></i></p>
<p class="paracontinue"><a id="c3-para-2457"/>Combining these equations shows that the state of the circuit (summarized by <i>v<sub>C</sub></i>, the voltage across the capacitor, and <i>i<sub>L</sub></i>, the current in the inductor) is described by the pair of differential equations</p>
<p><a id="c3-para-2458"/></p>
<figure id="c3-fig-0054"><img alt="c3-fig-5014.jpg" src="../images/c3-fig-5014.jpg"/><figcaption class="figurecaption">
</figcaption></figure>

<p class="paracontinue"><a id="c3-para-2459"/>The signal-flow diagram representing this system of differential equations is shown in <a id="c3-fig-0042a"/><a href="#c3-fig-0042">figure 3.37</a>.</p>
<figure id="c3-fig-0041"><img alt="c3-fig-0036.jpg" src="../images/c3-fig-0036.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0041a">Figure 3.36</a></span> <a id="c3-para-2451"/>A series RLC circuit.</p></figcaption></figure>
<figure id="c3-fig-0042"><img alt="c3-fig-0037.jpg" src="../images/c3-fig-0037.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0042a">Figure 3.37</a></span> <a id="c3-para-2460"/>A signal-flow diagram for the solution to a series RLC circuit.</p></figcaption></figure>
<p><a id="c3-para-2461"/>Write a function <span class="KeyTerm1">RLC</span> that takes as arguments the parameters <i>R</i>, <i>L</i>, and <i>C</i> of the circuit and the time increment <i>dt</i>. In a manner similar to that of the <span class="KeyTerm1">RC</span> function of exercise 3.73, <span class="KeyTerm1">RLC</span> should produce a function that takes the initial values of the state variables, 5<img alt="c3-fig-5015.jpg" src="../images/c3-fig-5015.jpg"/> and <img alt="c3-fig-5016.jpg" src="../images/c3-fig-5016.jpg"/>, and produces a pair (using <span class="KeyTerm1">pair</span>) of the streams of states <i>v<sub>C</sub></i> and <i>i<sub>L</sub></i>. Using <span class="KeyTerm1">RLC</span>, generate the pair of streams that models the behavior of a series RLC circuit with <i>R</i> = 1 ohm, <i>C</i> = 0.2 farad, <i>L</i> = 1 henry, <i>dt</i> = 0.1 second, and initial values <img alt="c3-fig-5016.jpg" src="../images/c3-fig-5016.jpg"/> = 0 amps and <img alt="c3-fig-5015.jpg" src="../images/c3-fig-5015.jpg"/> = 10 volts.</p>
</section>
<section>
<h5><a id="c3-sec-0133"/><a id="c3-title-0134"/>Normal-order evaluation</h5>
<p class="paraaftertitle"><a id="c3-para-2462"/>The examples in this section illustrate how delayed evaluation provides great programming flexibility, but the same examples also show how this can make our programs more complex. Our new <span class="KeyTerm1">integral</span> function, for instance, gives us the power to model systems with loops, but we must now remember that <span class="KeyTerm1">integral</span> should be called with a delayed integrand, and every function that uses <span class="KeyTerm1">integral</span> must be aware of this. In effect, we have created two classes of functions: ordinary functions and functions that take delayed arguments. In general, creating separate classes of functions forces us to create separate classes of higher-order functions as well.<a id="c3-fn-0073a"/><a href="#c3-fn-0073"><sup>73</sup></a></p>
<p><a id="c3-para-2463"/>One way to avoid the need for two different classes of functions is to make all functions take delayed arguments. We could adopt a model of evaluation in which all arguments to functions are automatically delayed and arguments are forced only when they are actually needed (for example, when they are required by a primitive operation). This would transform our language to use normal-order evaluation, which we first described when we introduced the substitution model for evaluation in section 1.1.5. Converting to normal-order evaluation provides a uniform and elegant way to simplify the use of delayed evaluation, and this would be a natural strategy to adopt if we were concerned only with stream processing. In section 4.2, after we have studied the evaluator, we will see how to transform our language in just this way. Unfortunately, including delays in function calls wreaks havoc with our ability to design programs that depend on the order of events, such as programs that use assignment, mutate data, or perform input or output. Even a single delay in the tail of a pair can cause great confusion, as illustrated by exercises 3.51 and 3.52. As far as anyone knows, mutability and delayed evaluation do not mix well in programming languages.</p>
</section>
</section>
<section>
<h3><a id="c3-sec-0134"/><span>3.5.5</span> <a id="c3-title-0135"/>Modularity of Functional Programs and Modularity of Objects</h3>
<p class="paraaftertitle"><a id="c3-para-2464"/>As we saw in section 3.1.2, one of the major benefits of introducing assignment is that we can increase the modularity of our systems by encapsulating, or “hiding,” parts of the state of a large system within local variables. Stream models can provide an equivalent modularity without the use of assignment. As an illustration, we can reimplement the Monte Carlo estimation of <i>π</i>, which we examined in section 3.1.2, from a stream-processing point of view.</p>
<p><a id="c3-para-2465"/>The key modularity issue was that we wished to hide the internal state of a random-number generator from programs that used random numbers. We began with a function <span class="KeyTerm1">rand_update</span>, whose successive values furnished our supply of random numbers, and used this to produce a random-number generator:</p>
<p class="Sp-text-1"><a id="c3-para-2466"/><b>function</b> make_rand() {</p>
<p class="Sp-text-1"><a id="c3-para-2467"/>    <b>let</b> x = random_init;</p>
<p class="Sp-text-1"><a id="c3-para-2468"/>    <b>return</b> () =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-2469"/>               x = rand_update(x);</p>
<p class="Sp-text-1"><a id="c3-para-2470"/>               <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c3-para-2471"/>           };</p>
<p class="Sp-text-1"><a id="c3-para-2472"/>}</p>
<p class="Sp-text-1"><a id="c3-para-2473"/><b>const</b> rand = make_rand();</p>
<p><a id="c3-para-2474"/>In the stream formulation there is no random-number generator <i>per se</i>, just a stream of random numbers produced by successive calls to <span class="KeyTerm1">rand_update</span>:</p>
<p class="Sp-text-1"><a id="c3-para-2475"/><b>const</b> random_numbers =</p>
<p class="Sp-text-1"><a id="c3-para-2476"/>    pair(random_init,</p>
<p class="Sp-text-1"><a id="c3-para-2477"/>         () =&gt; stream_map(rand_update, random_numbers));</p>
<p class="paracontinue"><a id="c3-para-2478"/>We use this to construct the stream of outcomes of the Cesàro experiment performed on consecutive pairs in the <span class="KeyTerm1">random_numbers</span> stream:</p>
<p class="Sp-text-1"><a id="c3-para-2479"/><b>function</b> map_successive_pairs(f, s) {</p>
<p class="Sp-text-1"><a id="c3-para-2480"/>    <b>return</b> pair(f(head(s), head(stream_tail(s))),</p>
<p class="Sp-text-1"><a id="c3-para-2481"/>                () =&gt; map_successive_pairs(</p>
<p class="Sp-text-1"><a id="c3-para-2482"/>                          f,</p>
<p class="Sp-text-1"><a id="c3-para-2483"/>                          stream_tail(stream_tail(s))));</p>
<p class="Sp-text-1"><a id="c3-para-2484"/>}</p>
<p class="Sp-text-1"><a id="c3-para-2485"/><b>const</b> dirichlet_stream =</p>
<p class="Sp-text-1"><a id="c3-para-2486"/>    map_successive_pairs((r1, r2) =&gt; gcd(r1, r2) === 1,</p>
<p class="Sp-text-1"><a id="c3-para-2487"/>                         random_numbers);</p>
<p class="paracontinue"><a id="c3-para-2488"/>The <span class="KeyTerm1">dirichlet_stream</span> is now fed to a <span class="KeyTerm1">monte_carlo</span> function, which produces a stream of estimates of probabilities. The results are then converted into a stream of estimates of <i>π</i>. This version of the program doesn't need a parameter telling how many trials to perform. Better estimates of <i>π</i> (from performing more experiments) are obtained by looking farther into the <span class="KeyTerm1">pi</span> stream:</p>
<p class="Sp-text-1"><a id="c3-para-2489"/><b>function</b> monte_carlo(experiment_stream, passed, failed) {</p>
<p class="Sp-text-1"><a id="c3-para-2490"/>    <b>function</b> next(passed, failed) {</p>
<p class="Sp-text-1"><a id="c3-para-2491"/>        <b>return</b> pair(passed / (passed + failed),</p>
<p class="Sp-text-1"><a id="c3-para-2492"/>                    () =&gt; monte_carlo(stream_tail(experiment_stream),</p>
<p class="Sp-text-1"><a id="c3-para-2493"/>                                      passed, failed));</p>
<p class="Sp-text-1"><a id="c3-para-2494"/>    }</p>
<p class="Sp-text-1"><a id="c3-para-2495"/>    <b>return</b> head(experiment_stream)</p>
<p class="Sp-text-1"><a id="c3-para-2496"/>           ? next(passed + 1, failed)</p>
<p class="Sp-text-1"><a id="c3-para-2497"/>           : next(passed, failed + 1);</p>
<p class="Sp-text-1"><a id="c3-para-2498"/>}</p>
<p class="Sp-text-1"><a id="c3-para-2499"/><b>const</b> pi = stream_map(p =&gt; math_sqrt(6 / p),</p>
<p class="Sp-text-1"><a id="c3-para-2500"/>                      monte_carlo(dirichlet_stream, 0, 0));</p>
<p class="paracontinue"><a id="c3-para-2501"/>There is considerable modularity in this approach, because we still can formulate a general <span class="KeyTerm1">monte_carlo</span> function that can deal with arbitrary experiments. Yet there is no assignment or local state.</p>
<section>
<h5><a id="c3-sec-0135"/><a id="c3-title-0136"/>Exercise 3.81</h5>
<p class="paraaftertitle"><a id="c3-para-2502"/>Exercise 3.6 discussed generalizing the random-number generator to allow one to reset the random-number sequence so as to produce repeatable sequences of “random” numbers. Produce a stream formulation of this same generator that operates on an input stream of requests to <span class="KeyTerm1">"generate"</span> a new random number or to <span class="KeyTerm1">"reset"</span> the sequence to a specified value and that produces the desired stream of random numbers. Don't use assignment in your solution.</p>
</section>
<section>
<h5><a id="c3-sec-0136"/><a id="c3-title-0137"/>Exercise 3.82</h5>
<p class="paraaftertitle"><a id="c3-para-2503"/>Redo exercise 3.5 on Monte Carlo integration in terms of streams. The stream version of <span class="KeyTerm1">estimate_integral</span> will not have an argument telling how many trials to perform. Instead, it will produce a stream of estimates based on successively more trials.</p>
</section>
<section>
<h5><a id="c3-sec-0137"/><a id="c3-title-0138"/>A functional-programming view of time</h5>
<p class="paraaftertitle"><a id="c3-para-2504"/>Let us now return to the issues of objects and state that were raised at the beginning of this chapter and examine them in a new light. We introduced assignment and mutable objects to provide a mechanism for modular construction of programs that model systems with state. We constructed computational objects with local state variables and used assignment to modify these variables. We modeled the temporal behavior of the objects in the world by the temporal behavior of the corresponding computational objects.</p>
<p><a id="c3-para-2505"/>Now we have seen that streams provide an alternative way to model objects with local state. We can model a changing quantity, such as the local state of some object, using a stream that represents the time history of successive states. In essence, we represent time explicitly, using streams, so that we decouple time in our simulated world from the sequence of events that take place during evaluation. Indeed, because of the presence of delayed evaluation there may be little relation between simulated time in the model and the order of events during the evaluation.</p>
<p><a id="c3-para-2506"/>In order to contrast these two approaches to modeling, let us reconsider the implementation of a “withdrawal processor” that monitors the balance in a bank account. In section 3.1.3 we implemented a simplified version of such a processor:</p>
<p class="Sp-text-1"><a id="c3-para-2507"/><b>function</b> make_simplified_withdraw(balance) {</p>
<p class="Sp-text-1"><a id="c3-para-2508"/>    <b>return</b> amount =&gt; {</p>
<p class="Sp-text-1"><a id="c3-para-2509"/>               balance = balance - amount;</p>
<p class="Sp-text-1"><a id="c3-para-2510"/>               <b>return</b> balance;</p>
<p class="Sp-text-1"><a id="c3-para-2511"/>           };</p>
<p class="Sp-text-1"><a id="c3-para-2512"/>}</p>
<p class="paracontinue"><a id="c3-para-2513"/>Calls to <span class="KeyTerm1">make_simplified_withdraw</span> produce computational objects, each with a local state variable <span class="KeyTerm1">balance</span> that is decremented by successive calls to the object. The object takes an <span class="KeyTerm1">amount</span> as an argument and returns the new balance. We can imagine the user of a bank account typing a sequence of inputs to such an object and observing the sequence of returned values shown on a display screen.</p>
<p><a id="c3-para-2514"/>Alternatively, we can model a withdrawal processor as a function that takes as input a balance and a stream of amounts to withdraw and produces the stream of successive balances in the account:</p>
<p class="Sp-text-1"><a id="c3-para-2515"/><b>function</b> stream_withdraw(balance, amount_stream) {</p>
<p class="Sp-text-1"><a id="c3-para-2516"/>    <b>return</b> pair(balance,</p>
<p class="Sp-text-1"><a id="c3-para-2517"/>                () =&gt; stream_withdraw(balance - head(amount_stream),</p>
<p class="Sp-text-1"><a id="c3-para-2518"/>                                      stream_tail(amount_stream)));</p>
<p class="Sp-text-1"><a id="c3-para-2519"/>}</p>
<p class="paracontinue"><a id="c3-para-2520"/>The function <span class="KeyTerm1">stream_withdraw</span> implements a well-defined mathematical function whose output is fully determined by its input. Suppose, however, that the input <span class="KeyTerm1">amount_stream</span> is the stream of successive values typed by the user and that the resulting stream of balances is displayed. Then, from the perspective of the user who is typing values and watching results, the stream process has the same behavior as the object created by <span class="KeyTerm1">make_simplified_withdraw</span>. However, with the stream version, there is no assignment, no local state variable, and consequently none of the theoretical difficulties that we encountered in section 3.1.3. Yet the system has state!</p>
<p><a id="c3-para-2521"/>This is really remarkable. Even though <span class="KeyTerm1">stream_withdraw</span> implements a welldefined mathematical function whose behavior does not change, the user's perception here is one of interacting with a system that has a changing state. One way to resolve this paradox is to realize that it is the user's temporal existence that imposes state on the system. If the user could step back from the interaction and think in terms of streams of balances rather than individual transactions, the system would appear stateless.<a id="c3-fn-0074a"/><a href="#c3-fn-0074"><sup>74</sup></a></p>
<p><a id="c3-para-2522"/>From the point of view of one part of a complex process, the other parts appear to change with time. They have hidden time-varying local state. If we wish to write programs that model this kind of natural decomposition in our world (as we see it from our viewpoint as a part of that world) with structures in our computer, we make computational objects that are not functional—they must change with time. We model state with local state variables, and we model the changes of state with assignments to those variables. By doing this we make the time of execution of a computation model time in the world that we are part of, and thus we get “objects” in our computer.</p>
<p><a id="c3-para-2523"/>Modeling with objects is powerful and intuitive, largely because this matches the perception of interacting with a world of which we are part. However, as we've seen repeatedly throughout this chapter, these models raise thorny problems of constraining the order of events and of synchronizing multiple processes. The possibility of avoiding these problems has stimulated the development of <i>functional programming languages</i>, which do not include any provision for assignment or mutable data. In such a language, all functions implement well-defined mathematical functions of their arguments, whose behavior does not change. The functional approach is extremely attractive for dealing with concurrent systems.<a id="c3-fn-0075a"/><a href="#c3-fn-0075"><sup>75</sup></a></p>
<p><a id="c3-para-2524"/>On the other hand, if we look closely, we can see time-related problems creeping into functional models as well. One particularly troublesome area arises when we wish to design interactive systems, especially ones that model interactions between independent entities. For instance, consider once more the implementation of a banking system that permits joint bank accounts. In a conventional system using assignment and objects, we would model the fact that Peter and Paul share an account by having both Peter and Paul send their transaction requests to the same bank-account object, as we saw in section 3.1.3. From the stream point of view, where there are no “objects” <i>per se</i>, we have already indicated that a bank account can be modeled as a process that operates on a stream of transaction requests to produce a stream of responses. Accordingly, we could model the fact that Peter and Paul have a joint bank account by merging Peter's stream of transaction requests with Paul's stream of requests and feeding the result to the bank-account stream process, as shown in <a id="c3-fig-0043a"/><a href="#c3-fig-0043">figure 3.38</a>.</p>
<figure id="c3-fig-0043"><img alt="c3-fig-0038.jpg" src="../images/c3-fig-0038.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c3-fig-0043a">Figure 3.38</a></span> <a id="c3-para-2525"/>A joint bank account, modeled by merging two streams of transaction requests.</p></figcaption></figure>
<p><a id="c3-para-2526"/>The trouble with this formulation is in the notion of <i>merge</i>. It will not do to merge the two streams by simply taking alternately one request from Peter and one request from Paul. Suppose Paul accesses the account only very rarely. We could hardly force Peter to wait for Paul to access the account before he could issue a second transaction. However such a merge is implemented, it must interleave the two transaction streams in some way that is constrained by “real time” as perceived by Peter and Paul, in the sense that, if Peter and Paul meet, they can agree that certain transactions were processed before the meeting, and other transactions were processed after the meeting.<a id="c3-fn-0076a"/><a href="#c3-fn-0076"><sup>76</sup></a> This is precisely the same constraint that we had to deal with in section 3.4.1, where we found the need to introduce explicit synchronization to ensure a “correct” order of events in concurrent processing of objects with state. Thus, in an attempt to support the functional style, the need to merge inputs from different agents reintroduces the same problems that the functional style was meant to eliminate.</p>
<p><a id="c3-para-2527"/>We began this chapter with the goal of building computational models whose structure matches our perception of the real world we are trying to model. We can model the world as a collection of separate, time-bound, interacting objects with state, or we can model the world as a single, timeless, stateless unity. Each view has powerful advantages, but neither view alone is completely satisfactory. A grand unification has yet to emerge.<a id="c3-fn-0077a"/><a href="#c3-fn-0077"><sup>77</sup></a></p>
</section>
</section>
</section>
</section>
<section class="BS_enoteSec">
<aside class="noteEntry"><a id="c3-fn-0001"/><a href="#c3-fn-0001a">1</a> Actually, this is not quite true. One exception was the random-number generator in section 1.2.6. Another exception involved the operation/type tables we introduced in section 2.4.3, where the values of two calls to <span class="KeyTerm1">get</span> with the same arguments depended on intervening calls to <span class="KeyTerm1">put</span>. On the other hand, until we introduce assignment, we have no way to create such functions ourselves.</aside>
<aside class="noteEntry"><a id="c3-fn-0002"/><a href="#c3-fn-0002a">2</a> The value of an assignment is the value being assigned to the name. Assignment expression statements look similar to and should not be confused with constant and variable declarations of the form
<br/><span class="BS_Sp-text-1_FN"><b>const</b> <span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>value</i></span>;</span>
<br/>and
<br/><span class="BS_Sp-text-1_FN"><b>let</b> <span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>value</i></span>;</span>
<br/>in which a newly declared <i>name</i> is associated with a <i>value</i>. Assignment expressions look similar to and should not be confused with expressions of the form
<br/><span class="BS_Sp-text-1_FN"><span class="KeyTerm2"><i>expression</i><sub>1</sub></span> === <span class="KeyTerm2"><i>expression</i><sub>2</sub></span></span>
<br/>which evaluate to <span class="KeyTerm1"><b>true</b></span> if <i>expression</i><sub>1</sub> evaluates to the same value as <i>expression</i><sub>2</sub> and to <span class="KeyTerm1"><b>false</b></span> otherwise.</aside>
<aside class="noteEntry"><a id="c3-fn-0003"/><a href="#c3-fn-0003a">3</a> We have already used sequences implicitly in our programs, because in JavaScript the body block of a function can contain a sequence of function declarations followed by a return statement, not just a single return statement, as discussed in section 1.1.8.</aside>
<aside class="noteEntry"><a id="c3-fn-0004"/><a href="#c3-fn-0004a">4</a> Blocks as bodies of lambda expressions were introduced in section 2.2.4.</aside>
<aside class="noteEntry"><a id="c3-fn-0005"/><a href="#c3-fn-0005a">5</a> In programming-language jargon, the variable <span class="KeyTerm1">balance</span> is said to be <i>encapsulated</i> within the <span class="KeyTerm1">new_withdraw</span> function. Encapsulation reflects the general system-design principle known as the <i>hiding principle</i>: One can make a system more modular and robust by protecting parts of the system from each other; that is, by providing information access only to those parts of the system that have a “need to know.”</aside>
<aside class="noteEntry"><a id="c3-fn-0006"/><a href="#c3-fn-0006a">6</a> In contrast with <span class="KeyTerm1">make_withdraw_balance_100</span> above, we do not have to use <span class="KeyTerm1"><b>let</b></span> to make <span class="KeyTerm1">balance</span> a local variable, since parameters are already local. This will be clearer after the discussion of the environment model of evaluation in section 3.2. (See also exercise 3.10.)</aside>
<aside class="noteEntry"><a id="c3-fn-0007"/><a href="#c3-fn-0007a">7</a> One common way to implement <span class="KeyTerm1">rand_update</span> is to use the rule that <i>x</i> is updated to <i>ax</i> + <i>b</i> modulo <i>m</i>, where <i>a</i>, <i>b</i>, and <i>m</i> are appropriately chosen integers. Chapter 3 of Knuth 1997b includes an extensive discussion of techniques for generating sequences of random numbers and establishing their statistical properties. Notice that the <span class="KeyTerm1">rand_update</span> function computes a mathematical function: Given the same input twice, it produces the same output. Therefore, the number sequence produced by <span class="KeyTerm1">rand_update</span> certainly is not “random,” if by “random” we insist that each number in the sequence is unrelated to the preceding number. The relation between “real randomness” and so-called <i>pseudo-random</i> sequences, which are produced by well-determined computations and yet have suitable statistical properties, is a complex question involving difficult issues in mathematics and philosophy. Kolmogorov, Solomonoff, and Chaitin have made great progress in clarifying these issues; a discussion can be found in Chaitin 1975.</aside>
<aside class="noteEntry"><a id="c3-fn-0008"/><a href="#c3-fn-0008a">8</a> This theorem is due to G. Lejeune Dirichlet. See section 4.5.2 of Knuth 1997b for a discussion and a proof.</aside>
<aside class="noteEntry"><a id="c3-fn-0009"/><a href="#c3-fn-0009a">9</a> We don't substitute for the occurrence of <span class="KeyTerm1">balance</span> in the assignment because the name in an assignment is not evaluated. If we did substitute for it, we would get <span class="KeyTerm1">25 = 25 - amount;</span>, which makes no sense.</aside>
<aside class="noteEntry"><a id="c3-fn-0010"/><a href="#c3-fn-0010a">10</a> The phenomenon of a single computational object being accessed by more than one name is known as <i>aliasing</i>. The joint bank account situation illustrates a very simple example of an alias. In section 3.3 we will see much more complex examples, such as “distinct” compound data structures that share parts. Bugs can occur in our programs if we forget that a change to an object may also, as a “side effect,” change a “different” object because the two “different” objects are actually a single object appearing under different aliases. These so-called <i>side-effect bugs</i> are so difficult to locate and to analyze that some people have proposed that programming languages be designed in such a way as to not allow side effects or aliasing (Lampson et al. 1981; Morris, Schmidt, and Wadler 1980).</aside>
<aside class="noteEntry"><a id="c3-fn-0011"/><a href="#c3-fn-0011a">11</a> In view of this, it is ironic that introductory programming is most often taught in a highly imperative style. This may be a vestige of a belief, common throughout the 1960s and 1970s, that programs that call functions must inherently be less efficient than programs that perform assignments. (Steele (1977) debunks this argument.) Alternatively it may reflect a view that step-by-step assignment is easier for beginners to visualize than function call. Whatever the reason, it often saddles beginning programmers with “should I set this variable before or after that one” concerns that can complicate programming and obscure the important ideas.</aside>
<aside class="noteEntry"><a id="c3-fn-0012"/><a href="#c3-fn-0012a">12</a> Assignment introduces a subtlety into step 1 of the evaluation rule. As shown in exercise 3.8, the presence of assignment allows us to write expressions that will produce different values depending on the order in which the subexpressions in a combination are evaluated. To eliminate such ambiguities, JavaScript specifies left-to-right evaluation of the subexpressions of combinations and of the argument expressions of applications.</aside>
<aside class="noteEntry"><a id="c3-fn-0013"/><a href="#c3-fn-0013a">13</a> Footnote 54 in chapter 1 mentions subtle differences between the two in full JavaScript, which we will ignore in this book.</aside>
<aside class="noteEntry"><a id="c3-fn-0014"/><a href="#c3-fn-0014a">14</a> We mentioned in footnote 54 in chapter 1 that the full JavaScript language allows assignment to names that are declared with function declarations.</aside>
<aside class="noteEntry"><a id="c3-fn-0015"/><a href="#c3-fn-0015a">15</a> This example does not make use of the fact that the parameter <span class="KeyTerm1">x</span> is a variable, but recall the function <span class="KeyTerm1">make_withdraw</span> in section 3.1.1, which relied on its parameter being a variable.</aside>
<aside class="noteEntry"><a id="c3-fn-0016"/><a href="#c3-fn-0016a">16</a> The environment model will not clarify our claim in section 1.2.1 that the interpreter can execute a function such as <span class="KeyTerm1">fact_iter</span> in a constant amount of space using tail recursion. We will discuss tail recursion when we deal with the control structure of the interpreter in section 5.4.</aside>
<aside class="noteEntry"><a id="c3-fn-0017"/><a href="#c3-fn-0017a">17</a> Whether <span class="KeyTerm1">W1</span> and <span class="KeyTerm1">W2</span> share the same physical code stored in the computer, or whether they each keep a copy of the code, is a detail of the implementation. For the interpreter we implement in chapter 4, the code is in fact shared.</aside>
<aside class="noteEntry"><a id="c3-fn-0018"/><a href="#c3-fn-0018a">18</a> This explains why the program in footnote 56 of chapter 1 goes wrong. The time between creating the binding for a name and evaluating the declaration of the name is called the <i>temporal dead zone</i> (TDZ).</aside>
<aside class="noteEntry"><a id="c3-fn-0019"/><a href="#c3-fn-0019a">19</a> The functions <span class="KeyTerm1">set_head</span> and <span class="KeyTerm1">set_tail</span> return the value <span class="KeyTerm1">undefined</span>. They should be used only for their effect.</aside>
<aside class="noteEntry"><a id="c3-fn-0020"/><a href="#c3-fn-0020a">20</a> We see from this that mutation operations on lists can create “garbage” that is not part of any accessible structure. We will see in section 5.3.2 that JavaScript memory-management systems include a <i>garbage collector</i>, which identifies and recycles the memory space used by unneeded pairs.</aside>
<aside class="noteEntry"><a id="c3-fn-0021"/><a href="#c3-fn-0021a">21</a> Section 5.3.1 will show how a memory-management system can implement <span class="KeyTerm1">get_new_pair</span>.</aside>
<aside class="noteEntry"><a id="c3-fn-0022"/><a href="#c3-fn-0022a">22</a> The two pairs are distinct because each call to <span class="KeyTerm1">pair</span> returns a new pair. The strings are “the same” in the sense that they are primitive data (just like numbers) that are composed of the same characters in the same order. Since JavaScript provides no way to mutate a string, any sharing that the designers of a JavaScript interpreter might decide to implement for strings is undetectable. We consider primitive data such as numbers, booleans, and strings to be <i>identical</i> if and only if they are <i>indistinguishable</i>.</aside>
<aside class="noteEntry"><a id="c3-fn-0023"/><a href="#c3-fn-0023a">23</a> The subtleties of dealing with sharing of mutable data objects reflect the underlying issues of “sameness” and “change” that were raised in section 3.1.3. We mentioned there that admitting change to our language requires that a compound object must have an “identity” that is something different from the pieces from which it is composed. In JavaScript, we consider this “identity” to be the quality that is tested by <span class="KeyTerm1">===</span>, i.e., by equality of pointers. Since in most JavaScript implementations a pointer is essentially a memory address, we are “solving the problem” of defining the identity of objects by stipulating that a data object “itself” is the information stored in some particular set of memory locations in the computer. This suffices for simple JavaScript programs, but is hardly a general way to resolve the issue of “sameness” in computational models.</aside>
<aside class="noteEntry"><a id="c3-fn-0024"/><a href="#c3-fn-0024a">24</a> On the other hand, from the viewpoint of implementation, assignment requires us to modify the environment, which is itself a mutable data structure. Thus, assignment and mutation are equipotent: Each can be implemented in terms of the other.</aside>
<aside class="noteEntry"><a id="c3-fn-0025"/><a href="#c3-fn-0025a">25</a> If the first item is the final item in the queue, the front pointer will be the empty list after the deletion, which will mark the queue as empty; we needn't worry about updating the rear pointer, which will still point to the deleted item, because <span class="KeyTerm1">is_empty_queue</span> looks only at the front pointer.</aside>
<aside class="noteEntry"><a id="c3-fn-0026"/><a href="#c3-fn-0026a">26</a> Be careful not to make the interpreter try to print a structure that contains cycles. (See exercise 3.13.)</aside>
<aside class="noteEntry"><a id="c3-fn-0027"/><a href="#c3-fn-0027a">27</a> Because <span class="KeyTerm1">assoc</span> uses <span class="KeyTerm1">equal</span>, it can recognize keys that are strings, numbers, or list structure.</aside>
<aside class="noteEntry"><a id="c3-fn-0028"/><a href="#c3-fn-0028a">28</a> Thus, the first backbone pair is the object that represents the table “itself”; that is, a pointer to the table is a pointer to this pair. This same backbone pair always starts the table. If we did not arrange things in this way, <span class="KeyTerm1">insert</span> would have to return a new value for the start of the table when it added a new record.</aside>
<aside class="noteEntry"><a id="c3-fn-0029"/><a href="#c3-fn-0029a">29</a> A full-adder is a basic circuit element used in adding two binary numbers. Here <i>A</i> and <i>B</i> are the bits at corresponding positions in the two numbers to be added, and <i>C<sub>in</sub></i> is the carry bit from the addition one place to the right. The circuit generates <i>SUM</i>, which is the sum bit in the corresponding position, and <i>C<sub>out</sub></i>, which is the carry bit to be propagated to the left.</aside>
<aside class="noteEntry"><a id="c3-fn-0030"/><a href="#c3-fn-0030a">30</a> These functions are simply syntactic sugar that allow us to use ordinary functional syntax to access the local functions of objects. It is striking that we can interchange the role of “functions” and “data” in such a simple way. For example, if we write <span class="KeyTerm1">wire("get_signal")</span> we think of <span class="KeyTerm1">wire</span> as a function that is called with the message <span class="KeyTerm1">"get_signal"</span> as input. Alternatively, writing <span class="KeyTerm1">get_signal(wire)</span> encourages us to think of <span class="KeyTerm1">wire</span> as a data object that is the input to a function <span class="KeyTerm1">get_signal</span>. The truth of the matter is that, in a language in which we can deal with functions as objects, there is no fundamental difference between “functions” and “data,” and we can choose our syntactic sugar to allow us to program in whatever style we choose.</aside>
<aside class="noteEntry"><a id="c3-fn-0031"/><a href="#c3-fn-0031a">31</a> The agenda is a headed list, like the tables in section 3.3.3, but since the list is headed by the time, we do not need an additional dummy header (such as the <span class="KeyTerm1">"*table*"</span> string used with tables).</aside>
<aside class="noteEntry"><a id="c3-fn-0032"/><a href="#c3-fn-0032a">32</a> Observe that the conditional statement in this function has an empty block as its alternative statement. Such a “one-armed conditional statement” is used to decide whether to do something, rather than to select between two statements.</aside>
<aside class="noteEntry"><a id="c3-fn-0033"/><a href="#c3-fn-0033a">33</a> In this way, the current time will always be the time of the action most recently processed. Storing this time at the head of the agenda ensures that it will still be available even if the associated time segment has been deleted.</aside>
<aside class="noteEntry"><a id="c3-fn-0034"/><a href="#c3-fn-0034a">34</a> Constraint propagation first appeared in the incredibly forward-looking SKETCHPAD system of Ivan Sutherland (1963). A beautiful constraint-propagation system based on the Smalltalk language was developed by Alan Borning (1977) at Xerox Palo Alto Research Center. Sussman, Stallman, and Steele applied constraint propagation to electrical circuit analysis (Sussman and Stallman 1975; Sussman and Steele 1980). TK!Solver (Konopasek and Jayaraman 1984) is an extensive modeling environment based on constraints.</aside>
<aside class="noteEntry"><a id="c3-fn-0035"/><a href="#c3-fn-0035a">35</a> The <span class="KeyTerm1">setter</span> might not be a constraint. In our temperature example, we used <span class="KeyTerm1">"user"</span> as the <span class="KeyTerm1">setter</span>.</aside>
<aside class="noteEntry"><a id="c3-fn-0036"/><a href="#c3-fn-0036a">36</a> We can use the function <span class="KeyTerm1">member</span> from section 2.3.1 to test whether <span class="KeyTerm1">new_constraint</span> is already in <span class="KeyTerm1">constraints</span>, although <span class="KeyTerm1">member</span> was introduced as being limited to numbers and strings, because we extended <span class="KeyTerm1">===</span> to pointer equality in section 3.3.1.</aside>
<aside class="noteEntry"><a id="c3-fn-0037"/><a href="#c3-fn-0037a">37</a> The expression-oriented format is convenient because it avoids the need to name the intermediate expressions in a computation. Our original formulation of the constraint language is cumbersome in the same way that many languages are cumbersome when dealing with operations on compound data. For example, if we wanted to compute the product (<i>a</i> + <i>b</i>) (<i>c</i> + <i>d</i>), where the variables represent vectors, we could work in “imperative style,” using functions that set the values of designated vector arguments but do not themselves return vectors as values:
<br/><span class="BS_Sp-text-1_FN">v_sum("a", "b", temp1);</span>
<br/><span class="BS_Sp-text-1_FN">v_sum("c", "d", temp2);</span>
<br/><span class="BS_Sp-text-1_FN">v_prod(temp1, temp2, answer);</span>
<br/>Alternatively, we could deal with expressions, using functions that return vectors as values, and thus avoid explicitly mentioning <span class="KeyTerm1">temp1</span> and <span class="KeyTerm1">temp2</span>:
<br/><span class="BS_Sp-text-1_FN"><b>const</b> answer = v_prod(v_sum("a", "b"), v_sum("c", "d"));</span>
<br/>Since JavaScript allows us to return compound objects as values of functions, we can transform our imperative-style constraint language into an expression-oriented style as shown in this exercise. Given the advantage of the expression-oriented format, one might ask if there is any reason to have implemented the system in imperative style, as we did in this section. One reason is that the non-expression-oriented constraint language provides a handle on constraint objects (e.g., the value of the <span class="KeyTerm1">adder</span> function) as well as on connector objects. This is useful if we wish to extend the system with new operations that communicate with constraints directly rather than only indirectly via operations on connectors. Although it is easy to implement the expression-oriented style in terms of the imperative implementation, it is very difficult to do the converse.</aside>
<aside class="noteEntry"><a id="c3-fn-0038"/><a href="#c3-fn-0038a">38</a> Such sequential threads are called “processes” throughout the book, but in this section we use the term “thread” to emphasize their access to shared memory.</aside>
<aside class="noteEntry"><a id="c3-fn-0039"/><a href="#c3-fn-0039a">39</a> Most real processors actually execute a few operations at a time, following a strategy called <i>pipelining</i>. Although this technique greatly improves the effective utilization of the hardware, it is used only to speed up the execution of a sequential instruction stream, while retaining the behavior of the sequential program.</aside>
<aside class="noteEntry"><a id="c3-fn-0040"/><a href="#c3-fn-0040a">40</a> To quote some graffiti seen on a building wall in Cambridge, Massachusetts: “Time is a device that was invented to keep everything from happening at once.”</aside>
<aside class="noteEntry"><a id="c3-fn-0041"/><a href="#c3-fn-0041a">41</a> An even worse failure for this system could occur if the two assignments attempt to change the balance simultaneously, in which case the actual data appearing in memory might end up being a random combination of the information being written by the two threads. Most computers have interlocks on the primitive memory-write operations, which protect against such simultaneous access. Even this seemingly simple kind of protection, however, raises implementation challenges in the design of multiprocessing computers, where elaborate <i>cache-coherence</i> protocols are required to ensure that the various processors will maintain a consistent view of memory contents, despite the fact that data may be replicated (“cached”) among the different processors to increase the speed of memory access.</aside>
<aside class="noteEntry"><a id="c3-fn-0042"/><a href="#c3-fn-0042a">42</a> The factorial program in section 3.1.3 illustrates this for a single sequential thread.</aside>
<aside class="noteEntry"><a id="c3-fn-0043"/><a href="#c3-fn-0043a">43</a> The columns show the contents of Peter's wallet, the joint account (in Bank1), Paul's wallet, and Paul's private account (in Bank2), before and after each withdrawal (W) and deposit (D). Peter withdraws $10 from Bank1; Paul deposits $5 in Bank2, then withdraws $25 from Bank1.</aside>
<aside class="noteEntry"><a id="c3-fn-0044"/><a href="#c3-fn-0044a">44</a> A more formal way to express this idea is to say that concurrent programs are inherently <i>nondeterministic</i>. That is, they are described not by single-valued functions, but by functions whose results are sets of possible values. In section 4.3 we will study a language for expressing nondeterministic computations.</aside>
<aside class="noteEntry"><a id="c3-fn-0045"/><a href="#c3-fn-0045a">45</a> The function <span class="KeyTerm1">concurrent_execute</span> is not part of the JavaScript standard, but the examples in this section can be implemented in ECMAScript 2020.</aside>
<aside class="noteEntry"><a id="c3-fn-0046"/><a href="#c3-fn-0046a">46</a> We have simplified <span class="KeyTerm1">exchange</span> by exploiting the fact that our <span class="KeyTerm1">deposit</span> message accepts negative amounts. (This is a serious bug in our banking system!)</aside>
<aside class="noteEntry"><a id="c3-fn-0047"/><a href="#c3-fn-0047a">47</a> If the account balances start out as $10, $20, and $30, then after any number of concurrent exchanges, the balances should still be $10, $20, and $30 in some order. Serializing the deposits to individual accounts is not sufficient to guarantee this. See exercise 3.43.</aside>
<aside class="noteEntry"><a id="c3-fn-0048"/><a href="#c3-fn-0048a">48</a> Exercise 3.45 investigates why deposits and withdrawals are no longer automatically serialized by the account.</aside>
<aside class="noteEntry"><a id="c3-fn-0049"/><a href="#c3-fn-0049a">49</a> The term “mutex” is an abbreviation for <i>mutual exclusion</i>. The general problem of arranging a mechanism that permits concurrent threads to safely share resources is called the mutual exclusion problem. Our mutex is a simple variant of the <i>semaphore</i> mechanism (see exercise 3.47), which was introduced in the “THE” Multiprogramming System developed at the Technological University of Eindhoven and named for the university's initials in Dutch (Dijkstra 1968a). The acquire and release operations were originally called P and V, from the Dutch words <i>passeren</i> (to pass) and <i>vrijgeven</i> (to release), in reference to the semaphores used on railroad systems. Dijkstra's classic exposition (1968b) was one of the first to clearly present the issues of concurrency control, and showed how to use semaphores to handle a variety of concurrency problems.</aside>
<aside class="noteEntry"><a id="c3-fn-0050"/><a href="#c3-fn-0050a">50</a> In most time-shared operating systems, threads that are blocked by a mutex do not waste time “busy-waiting” as above. Instead, the system schedules another thread to run while the first is waiting, and the blocked thread is awakened when the mutex becomes available.</aside>
<aside class="noteEntry"><a id="c3-fn-0051"/><a href="#c3-fn-0051a">51</a> There are many variants of such instructions—including test-and-set, test-and-clear, swap, compare-and-exchange, load-reserve, and store-conditional—whose design must be carefully matched to the machine's processor–memory interface. One issue that arises here is to determine what happens if two threads attempt to acquire the same resource at exactly the same time by using such an instruction. This requires some mechanism for making a decision about which thread gets control. Such a mechanism is called an <i>arbiter</i>. Arbiters usually boil down to some sort of hardware device. Unfortunately, it is possible to prove that one cannot physically construct a fair arbiter that works 100% of the time unless one allows the arbiter an arbitrarily long time to make its decision. The fundamental phenomenon here was originally observed by the fourteenth-century French philosopher Jean Buridan in his commentary on Aristotle's <i>De caelo</i>. Buridan argued that a perfectly rational dog placed between two equally attractive sources of food will starve to death, because it is incapable of deciding which to go to first.</aside>
<aside class="noteEntry"><a id="c3-fn-0052"/><a href="#c3-fn-0052a">52</a> The general technique for avoiding deadlock by numbering the shared resources and acquiring them in order is due to Havender (1968). Situations where deadlock cannot be avoided require <i>deadlock-recovery</i> methods, which entail having threads “back out” of the deadlocked state and try again. Deadlock-recovery mechanisms are widely used in data-base-management systems, a topic that is treated in detail in Gray and Reuter 1993.</aside>
<aside class="noteEntry"><a id="c3-fn-0053"/><a href="#c3-fn-0053a">53</a> One such alternative to serialization is called <i>barrier synchronization</i>. The programmer permits concurrent threads to execute as they please, but establishes certain synchronization points (“barriers”) through which no thread can proceed until all the threads have reached the barrier. Some processors provide machine instructions that permit programmers to establish synchronization points at places where consistency is required. The PowerPC<sup>TM</sup>, for example, includes for this purpose two instructions called SYNC and EIEIO (Enforced In-order Execution of Input/Output).</aside>
<aside class="noteEntry"><a id="c3-fn-0054"/><a href="#c3-fn-0054a">54</a> This may seem like a strange point of view, but there are systems that work this way. International charges to credit-card accounts, for example, are normally cleared on a per-country basis, and the charges made in different countries are periodically reconciled. Thus the account balance may be different in different countries.</aside>
<aside class="noteEntry"><a id="c3-fn-0055"/><a href="#c3-fn-0055a">55</a> For distributed systems, this perspective was pursued by Lamport (1978), who showed how to use communication to establish “global clocks” that can be used to establish orderings on events in distributed systems.</aside>
<aside class="noteEntry"><a id="c3-fn-0056"/><a href="#c3-fn-0056a">56</a> Physicists sometimes adopt this view by introducing the “world lines” of particles as a device for reasoning about motion. We've also already mentioned (section 2.2.3) that this is the natural way to think about signal-processing systems. We will explore applications of streams to signal processing in section 3.5.3.</aside>
<aside class="noteEntry"><a id="c3-fn-0057"/><a href="#c3-fn-0057a">57</a> Assume that we have a predicate <span class="KeyTerm1">is_prime</span> (e.g., as in section 1.2.6) that tests for primality.</aside>
<aside class="noteEntry"><a id="c3-fn-0058"/><a href="#c3-fn-0058a">58</a> This should bother you. The fact that we are defining such similar functions for streams and lists indicates that we are missing some underlying abstraction. Unfortunately, in order to exploit this abstraction, we will need to exert finer control over the process of evaluation than we can at present. We will discuss this point further at the end of section 3.5.4. In section 4.2, we'll develop a framework that unifies lists and streams.</aside>
<aside class="noteEntry"><a id="c3-fn-0059"/><a href="#c3-fn-0059a">59</a> The numbers shown here do not really appear in the delayed expression. What actually appears is the original expression, in an environment in which the variables are bound to the appropriate numbers. For example, <span class="KeyTerm1">low + 1</span> with <span class="KeyTerm1">low</span> bound to 10,000 actually appears where <span class="KeyTerm1">10001</span> is shown.</aside>
<aside class="noteEntry"><a id="c3-fn-0060"/><a href="#c3-fn-0060a">60</a> There are many possible implementations of streams other than the one described in this section. Delayed evaluation, which is the key to making streams practical, was inherent in Algol 60's <i>call-by-name</i> parameter-passing method. The use of this mechanism to implement streams was first described by Landin (1965). Delayed evaluation for streams was introduced into Lisp by Friedman and Wise (1976). In their implementation, <span class="KeyTerm1">cons</span> (the Lisp equivalent of our <span class="KeyTerm1">pair</span> function) always delays evaluating its arguments, so that lists automatically behave as streams. The memoizing optimization is also known as <i>call-by-need</i>. The Algol community would refer to our original delayed objects as <i>call-by-name thunks</i> and to the optimized versions as <i>call-by-need thunks</i>.</aside>
<aside class="noteEntry"><a id="c3-fn-0061"/><a href="#c3-fn-0061a">61</a> Exercises such as 3.51 and 3.52 are valuable for testing our understanding of how delayed evaluation works. On the other hand, intermixing delayed evaluation with printing—and, even worse, with assignment—is extremely confusing, and instructors of courses on computer languages have traditionally tormented their students with examination questions such as the ones in this section. Needless to say, writing programs that depend on such subtleties is odious programming style. Part of the power of stream processing is that it lets us ignore the order in which events actually happen in our programs. Unfortunately, this is precisely what we cannot afford to do in the presence of assignment, which forces us to be concerned with time and change.</aside>
<aside class="noteEntry"><a id="c3-fn-0062"/><a href="#c3-fn-0062a">62</a> Eratosthenes, a third-century BCE Alexandrian Greek philosopher, is famous for giving the first accurate estimate of the circumference of the Earth, which he computed by observing shadows cast at noon on the day of the summer solstice. Eratosthenes's sieve method, although ancient, has formed the basis for special-purpose hardware “sieves” that, until the 1970s, were the most powerful tools in existence for locating large primes. Since then, however, these methods have been superseded by outgrowths of the probabilistic techniques discussed in section 1.2.6.</aside>
<aside class="noteEntry"><a id="c3-fn-0063"/><a href="#c3-fn-0063a">63</a> We have named these figures after Peter Henderson, who was the first person to show us diagrams of this sort as a way of thinking about stream processing.</aside>
<aside class="noteEntry"><a id="c3-fn-0064"/><a href="#c3-fn-0064a">64</a> This uses the function <span class="KeyTerm1">stream_map_2</span> from exercise 3.50.</aside>
<aside class="noteEntry"><a id="c3-fn-0065"/><a href="#c3-fn-0065a">65</a> This last point is very subtle and relies on the fact that <i>p<sub>n</sub></i><sub>+1</sub> ≤ <img alt="c3-fig-5002.jpg" src="../images/c3-fig-5002.jpg"/>. (Here, <i>p<sub>k</sub></i> denotes the <i>k</i>th prime.) Estimates such as these are very difficult to establish. The ancient proof by Euclid that there are an infinite number of primes shows that <i>p<sub>n</sub></i><sub>+1</sub> ≤ <i>p</i><sub>1</sub><i>p</i><sub>2</sub> ··· <i>p<sub>n</sub></i> + 1, and no substantially better result was proved until 1851, when the Russian mathematician P. L. Chebyshev established that <i>p<sub>n</sub></i><sub>+1</sub> ≤ 2<i>p<sub>n</sub></i> for all <i>n</i>. This result, originally conjectured in 1845, is known as <i>Bertrand's hypothesis</i>. A proof can be found in section 22.3 of Hardy and Wright 1960.</aside>
<aside class="noteEntry"><a id="c3-fn-0066"/><a href="#c3-fn-0066a">66</a> This exercise shows how call-by-need is closely related to ordinary memoization as described in exercise 3.27. In that exercise, we used assignment to explicitly construct a local table. Our call-by-need stream optimization effectively constructs such a table automatically, storing values in the previously forced parts of the stream.</aside>
<aside class="noteEntry"><a id="c3-fn-0067"/><a href="#c3-fn-0067a">67</a> As in section 2.2.3, we represent a pair of integers as a list rather than a pair.</aside>
<aside class="noteEntry"><a id="c3-fn-0068"/><a href="#c3-fn-0068a">68</a> See exercise 3.68 for some insight into why we chose this decomposition.</aside>
<aside class="noteEntry"><a id="c3-fn-0069"/><a href="#c3-fn-0069a">69</a> The precise statement of the required property on the order of combination is as follows: There should be a function <i>f</i> of two arguments such that the pair corresponding to element <i>i</i> of the first stream and element <i>j</i> of the second stream will appear as element number <i>f</i> (<i>i</i>, <i>j</i>) of the output stream. The trick of using <span class="KeyTerm1">interleave</span> to accomplish this was shown to us by David Turner, who employed it in the language KRC (Turner 1981).</aside>
<aside class="noteEntry"><a id="c3-fn-0070"/><a href="#c3-fn-0070a">70</a> We will require that the weighting function be such that the weight of a pair increases as we move out along a row or down along a column of the array of pairs.</aside>
<aside class="noteEntry"><a id="c3-fn-0071"/><a href="#c3-fn-0071a">71</a> To quote from G. H. Hardy's obituary of Ramanujan (Hardy 1921): “It was Mr. Littlewood (I believe) who remarked that ‘every positive integer was one of his friends.’ I remember once going to see him when he was lying ill at Putney. I had ridden in taxi-cab No. 1729, and remarked that the number seemed to me a rather dull one, and that I hoped it was not an unfavorable omen. ‘No,’ he replied, ‘it is a very interesting number; it is the smallest number expressible as the sum of two cubes in two different ways.”’ The trick of using weighted pairs to generate the Ramanujan numbers was shown to us by Charles Leiserson.</aside>
<aside class="noteEntry"><a id="c3-fn-0072"/><a href="#c3-fn-0072a">72</a> To complete in reasonable time, this calculation requires the use of the memoization optimization from section 3.5.1 in <span class="KeyTerm1">integral</span> and in the function <span class="KeyTerm1">add_streams</span> used in <span class="KeyTerm1">integral</span> (using the function <span class="KeyTerm1">stream_map_2_optimized</span> as suggested in exercise 3.57).</aside>
<aside class="noteEntry"><a id="c3-fn-0073"/><a href="#c3-fn-0073a">73</a> This is a small reflection, in JavaScript, of the difficulties that early statically typed languages such as Pascal had in coping with higher-order functions. In these languages, the programmer had to specify the data types of the arguments and the result of each function: number, logical value, sequence, and so on. Consequently, we could not express an abstraction such as “map a given function <span class="KeyTerm1">fun</span> over all the elements in a sequence” by a single higherorder function such as <span class="KeyTerm1">stream_map</span>. Rather, we would need a different mapping function for each different combination of argument and result data types that might be specified for a <span class="KeyTerm1">fun</span>. Maintaining a practical notion of “data type” in the presence of higher-order functions raises many difficult issues. One way of dealing with this problem is illustrated by the language ML (Gordon, Milner, and Wadsworth 1979), whose “parametrically polymorphic data types” include templates for higher-order transformations between data types. Moreover, data types for most functions in ML are never explicitly declared by the programmer. Instead, ML includes a <i>type-inferencing</i> mechanism that uses information in the environment to deduce the data types for newly defined functions. Today, statically typed programming languages have evolved to typically support some form of type inference as well as parametric polymorphism, with varying degrees of power. Haskell couples an expressive type system with powerful type inference.</aside>
<aside class="noteEntry"><a id="c3-fn-0074"/><a href="#c3-fn-0074a">74</a> Similarly in physics, when we observe a moving particle, we say that the position (state) of the particle is changing. However, from the perspective of the particle's world line in space-time there is no change involved.</aside>
<aside class="noteEntry"><a id="c3-fn-0075"/><a href="#c3-fn-0075a">75</a> John Backus, the inventor of Fortran, gave high visibility to functional programming when he was awarded the ACM Turing award in 1978. His acceptance speech (Backus 1978) strongly advocated the functional approach. A good overview of functional programming is given in Henderson 1980 and in Darlington, Henderson, and Turner 1982.</aside>
<aside class="noteEntry"><a id="c3-fn-0076"/><a href="#c3-fn-0076a">76</a> Observe that, for any two streams, there is in general more than one acceptable order of interleaving. Thus, technically, “merge” is a relation rather than a function—the answer is not a deterministic function of the inputs. We already mentioned (footnote 44) that nondeterminism is essential when dealing with concurrency. The merge relation illustrates the same essential nondeterminism, from the functional perspective. In section 4.3, we will look at nondeterminism from yet another point of view.</aside>
<aside class="noteEntry"><a id="c3-fn-0077"/><a href="#c3-fn-0077a">77</a> The object model approximates the world by dividing it into separate pieces. The functional model does not modularize along object boundaries. The object model is useful when the unshared state of the “objects” is much larger than the state that they share. An example of a place where the object viewpoint fails is quantum mechanics, where thinking of things as individual particles leads to paradoxes and confusions. Unifying the object view with the functional view may have little to do with programming, but rather with fundamental epistemological issues.</aside>
</section>
</section>
</body>
</html>