<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>4 Metalinguistic Abstraction</title>
<link href="../styles/MIT_style.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:5e22faf7-6d97-43f5-a05d-571a507bcb19" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<h1><a id="c4-title-0001"/><span class="chapterNumber">4</span><br/><span class="chapterTitle">Metalinguistic Abstraction</span></h1>
</header>
<blockquote class="quote-epigraph">
<p class="quote-epigraphparafirst"><a id="c4-para-0001"/>. . . It's in words that the magic is—Abracadabra, Open Sesame, and the rest—but the magic words in one story aren't magical in the next. The real magic is to understand which words work, and when, and for what; the trick is to learn the trick.</p>
<p class="quote-epigraphparafirst"><a id="c4-para-0002"/>. . . And those words are made from the letters of our alphabet: a couple-dozen squiggles we can draw with the pen. This is the key! And the treasure, too, if we can only get our hands on it! It's as if—as if the key to the treasure <i>is</i> the treasure!</p>
<p class="quote-epigraphsource">—John Barth, <i>Chimera</i></p></blockquote>
<p class="paraaftertitle"><a id="c4-para-0003"/>In our study of program design, we have seen that expert programmers control the complexity of their designs with the same general techniques used by designers of all complex systems. They combine primitive elements to form compound objects, they abstract compound objects to form higher-level building blocks, and they preserve modularity by adopting appropriate large-scale views of system structure. In illustrating these techniques, we have used JavaScript as a language for describing processes and for constructing computational data objects and processes to model complex phenomena in the real world. However, as we confront increasingly complex problems, we will find that JavaScript, or indeed any fixed programming language, is not sufficient for our needs. We must constantly turn to new languages in order to express our ideas more effectively. Establishing new languages is a powerful strategy for controlling complexity in engineering design; we can often enhance our ability to deal with a complex problem by adopting a new language that enables us to describe (and hence to think about) the problem in a different way, using primitives, means of combination, and means of abstraction that are particularly well suited to the problem at hand.<a id="c4-fn-0001a"/><a href="#c4-fn-0001"><sup>1</sup></a></p>
<p><a id="c4-para-0004"/>Programming is endowed with a multitude of languages. There are physical languages, such as the machine languages for particular computers. These languages are concerned with the representation of data and control in terms of individual bits of storage and primitive machine instructions. The machine-language programmer is concerned with using the given hardware to erect systems and utilities for the efficient implementation of resource-limited computations. High-level languages, erected on a machine-language substrate, hide concerns about the representation of data as collections of bits and the representation of programs as sequences of primitive instructions. These languages have means of combination and abstraction, such as function declaration, that are appropriate to the larger-scale organization of systems.</p>
<p><a id="c4-para-0005"/><i>Metalinguistic abstraction</i>—establishing new languages—plays an important role in all branches of engineering design. It is particularly important to computer programming, because in programming not only can we formulate new languages but we can also implement these languages by constructing evaluators. An <i>evaluator</i> (or <i>interpreter</i>) for a programming language is a function that, when applied to a statement or expression of the language, performs the actions required to evaluate that statement or expression. It is no exaggeration to regard this as the most fundamental idea in programming:</p>
<blockquote class="quote">
<p class="quoteparafirst"><a id="c4-para-0006"/>The evaluator, which determines the meaning of statements and expressions in a programming language, is just another program.</p></blockquote>

<p class="paracontinue"><a id="c4-para-0007"/>To appreciate this point is to change our images of ourselves as programmers. We come to see ourselves as designers of languages, rather than only users of languages designed by others.</p>
<p><a id="c4-para-0008"/>In fact, we can regard almost any program as the evaluator for some language. For instance, the polynomial manipulation system of section 2.5.3 embodies the rules of polynomial arithmetic and implements them in terms of operations on list-structured data. If we augment this system with functions to read and print polynomial expressions, we have the core of a special-purpose language for dealing with problems in symbolic mathematics. The digital-logic simulator of section 3.3.4 and the constraint propagator of section 3.3.5 are legitimate languages in their own right, each with its own primitives, means of combination, and means of abstraction. Seen from this perspective, the technology for coping with large-scale computer systems merges with the technology for building new computer languages, and computer science itself becomes no more (and no less) than the discipline of constructing appropriate descriptive languages.</p>
<p><a id="c4-para-0009"/>We now embark on a tour of the technology by which languages are established in terms of other languages. In this chapter we shall use JavaScript as a base, implementing evaluators as JavaScript functions. We will take the first step in understanding how languages are implemented by building an evaluator for JavaScript itself. The language implemented by our evaluator will be a subset of JavaScript. Although the evaluator described in this chapter is written for a particular subset of JavaScript, it contains the essential structure of an evaluator for any language designed for writing programs for a sequential machine. (In fact, most language processors contain, deep within them, a little evaluator.) The evaluator has been simplified for the purposes of illustration and discussion, and some features have been left out that would be important to include in a production-quality JavaScript system. Nevertheless, this simple evaluator is adequate to execute most of the programs in this book.<a id="c4-fn-0002a"/><a href="#c4-fn-0002"><sup>2</sup></a></p>
<p><a id="c4-para-0010"/>An important advantage of making the evaluator accessible as a JavaScript program is that we can implement alternative evaluation rules by describing these as modifications to the evaluator program. One place where we can use this power to good effect is to gain extra control over the ways in which computational models embody the notion of time, which was so central to the discussion in chapter 3. There, we mitigated some of the complexities of state and assignment by using streams to decouple the representation of time in the world from time in the computer. Our stream programs, however, were sometimes cumbersome, because they were constrained by the applicative-order evaluation of JavaScript. In section 4.2, we'll change the underlying language to provide for a more elegant approach, by modifying the evaluator to provide for <i>normal-order evaluation</i>.</p>
<p><a id="c4-para-0011"/>Section 4.3 implements a more ambitious linguistic change, whereby statements and expressions have many values, rather than just a single value. In this language of <i>nondeterministic computing</i>, it is natural to express processes that generate all possible values for statements and expressions and then search for those values that satisfy certain constraints. In terms of models of computation and time, this is like having time branch into a set of “possible futures” and then searching for appropriate time lines. With our nondeterministic evaluator, keeping track of multiple values and performing searches are handled automatically by the underlying mechanism of the language.</p>
<p><a id="c4-para-0012"/>In section 4.4 we implement a <i>logic-programming</i> language in which knowledge is expressed in terms of relations, rather than in terms of computations with inputs and outputs. Even though this makes the language drastically different from JavaScript, or indeed from any conventional language, we will see that the logic-programming evaluator shares the essential structure of the JavaScript evaluator.</p>
<section><a id="c4-title-0002"/>
<section>
<h2><a id="c4-sec-0002"/><span>4.1</span> <a id="c4-title-0003"/>The Metacircular Evaluator</h2>
<p class="paraaftertitle"><a id="c4-para-0013"/>Our evaluator for JavaScript will be implemented as a JavaScript program. It may seem circular to think about evaluating JavaScript programs using an evaluator that is itself implemented in JavaScript. However, evaluation is a process, so it is appropriate to describe the evaluation process using JavaScript, which, after all, is our tool for describing processes.<a id="c4-fn-0003a"/><a href="#c4-fn-0003"><sup>3</sup></a> An evaluator that is written in the same language that it evaluates is said to be <i>metacircular</i>.</p>
<p><a id="c4-para-0014"/>The metacircular evaluator is essentially a JavaScript formulation of the environment model of evaluation described in section 3.2. Recall that the model specifies the evaluation of function application in two basic steps:</p>
<ol class="BS_NumberList1">
<li><a id="c4-li-0001"/><span>1. </span>To evaluate a function application, evaluate the subexpressions and then apply the value of the function subexpression to the values of the argument subexpressions.</li>
<li><a id="c4-li-0002"/><span>2. </span>To apply a compound function to a set of arguments, evaluate the body of the function in a new environment. To construct this environment, extend the environment part of the function object by a frame in which the parameters of the function are bound to the arguments to which the function is applied.</li>
</ol>

<p><a id="c4-para-0017"/>These two rules describe the essence of the evaluation process, a basic cycle in which statements and expressions to be evaluated in environments are reduced to functions to be applied to arguments, which in turn are reduced to new statements and expressions to be evaluated in new environments, and so on, until we get down to names, whose values are looked up in the environment, and to operators and primitive functions, which are applied directly (see <a id="c4-fig-0001a"/><a href="#c4-fig-0001">figure 4.1</a>).<a id="c4-fn-0004a"/><a href="#c4-fn-0004"><sup>4</sup></a> This evaluation cycle will be embodied by the interplay between the two critical functions in the evaluator, <span class="KeyTerm1">evaluate</span> and <span class="KeyTerm1">apply</span>, which are described in section 4.1.1 (see <a href="#c4-fig-0001">figure 4.1</a>).</p>
<figure id="c4-fig-0001"><img alt="c4-fig-0001.jpg" src="../images/c4-fig-0001.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0001a">Figure 4.1</a></span> <a id="c4-para-0018"/>The <span class="KeyTerm1">evaluate</span>–<span class="KeyTerm1">apply</span> cycle exposes the essence of a computer language.</p></figcaption></figure>
<p><a id="c4-para-0019"/>The implementation of the evaluator will depend upon functions that define the <i>syntax</i> of the statements and expressions to be evaluated. We will use data abstraction to make the evaluator independent of the representation of the language. For example, rather than committing to a choice that an assignment is to be represented by a string beginning with a name followed by <span class="KeyTerm1">=</span>, we use an abstract predicate <span class="KeyTerm1">is_assignment</span> to test for an assignment, and we use abstract selectors <span class="KeyTerm1">assignment_symbol</span> and <span class="KeyTerm1">assignment_value_expression</span> to access the parts of an assignment. The data abstraction layers presented in section 4.1.2 will allow the evaluator to remain independent of concrete syntactic issues, such as the keywords of the interpreted language, and of the choice of data structures that represent the program components. There are also operations, described in section 4.1.3, that specify the representation of functions and environments. For example, <span class="KeyTerm1">make_function</span> constructs compound functions, <span class="KeyTerm1">lookup_symbol_value</span> accesses the values of names, and <span class="KeyTerm1">apply_primitive_function</span> applies a primitive function to a given list of arguments.</p>
<section>
<h3><a id="c4-sec-0003"/><span>4.1.1</span> <a id="c4-title-0004"/>The Core of the Evaluator</h3>
<p class="paraaftertitle"><a id="c4-para-0020"/>The evaluation process can be described as the interplay between two functions: <span class="KeyTerm1">evaluate</span> and <span class="KeyTerm1">apply</span>.</p>
<section>
<h5><a id="c4-sec-0004"/><a id="c4-title-0005"/>The function <span class="KeyTerm1">evaluate</span></h5>
<p class="paraaftertitle"><a id="c4-para-0021"/>The function <span class="KeyTerm1">evaluate</span> takes as arguments a program <i>component</i>—a statement or expression<a id="c4-fn-0005a"/><a href="#c4-fn-0005"><sup>5</sup></a>—and an environment. It classifies the component and directs its evaluation. The function <span class="KeyTerm1">evaluate</span> is structured as a case analysis of the syntactic type of the component to be evaluated. In order to keep the function general, we express the determination of the type of a component abstractly, making no commitment to any particular representation for the various types of components. Each type of component has a <i>syntax predicate</i> that tests for it and an abstract means for selecting its parts. This <i>abstract syntax</i> makes it easy to see how we can change the syntax of the language by using the same evaluator, but with a different collection of syntax functions.</p>
<section>
<h6><a id="c4-sec-0005"/><a id="c4-title-0006"/>Primitive expressions</h6>
<ul style="list-style-type:disc">
<li>For literal expressions, such as numbers, <span class="KeyTerm1">evaluate</span> returns their value.</li>
<li>The function <span class="KeyTerm1">evaluate</span> must look up names in the environment to find their values.</li>
</ul>
</section>
<section>
<h6><a id="c4-sec-0006"/><a id="c4-title-0007"/>Combinations</h6>
<ul style="list-style-type:disc">
<li>For a function application, <span class="KeyTerm1">evaluate</span> must recursively evaluate the function expression and the argument expressions of the application. The resulting function and arguments are passed to <span class="KeyTerm1">apply</span>, which handles the actual function application.</li>
<li>An operator combination is transformed into a function application and then evaluated.</li>
</ul>
</section>
<section>
<h6><a id="c4-sec-0007"/><a id="c4-title-0008"/>Syntactic forms</h6>
<ul style="list-style-type:disc">
<li>A conditional expression or statement requires special processing of its parts, so as to evaluate the consequent if the predicate is true, and otherwise to evaluate the alternative.</li>
<li>A lambda expression must be transformed into an applicable function by packaging together the parameters and body specified by the lambda expression with the environment of the evaluation.</li>
<li>A sequence of statements requires evaluating its components in the order in which they appear.</li>
<li>A block requires evaluating its body in a new environment that reflects all names declared within the block.</li>
<li>A return statement must produce a value that becomes the result of the function call that gave rise to the evaluation of the return statement.</li>
<li>A function declaration is transformed into a constant declaration and then evaluated.</li>
<li>A constant or variable declaration or an assignment must call <span class="KeyTerm1">evaluate</span> recursively to compute the new value to be associated with the name being declared or assigned. The environment must be modified to reflect the new value of the name.</li>
</ul>
<p class="paraaftertitle"><a id="c4-para-0033"/>Here is the declaration of <span class="KeyTerm1">evaluate</span>:</p>
<p class="Sp-text-1"><a id="c4-para-0034"/><b>function</b> evaluate(component, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0035"/>    <b>return</b> is_literal(component)</p>
<p class="Sp-text-1"><a id="c4-para-0036"/>           ? literal_value(component)</p>
<p class="Sp-text-1"><a id="c4-para-0037"/>           : is_name(component)</p>
<p class="Sp-text-1"><a id="c4-para-0038"/>           ? lookup_symbol_value(symbol_of_name(component), env)</p>
<p class="Sp-text-1"><a id="c4-para-0039"/>           : is_application(component)</p>
<p class="Sp-text-1"><a id="c4-para-0040"/>           ? apply(evaluate(function_expression(component), env),</p>
<p class="Sp-text-1"><a id="c4-para-0041"/>                   list_of_values(arg_expressions(component), env))</p>
<p class="Sp-text-1"><a id="c4-para-0042"/>           : is_operator_combination(component)</p>
<p class="Sp-text-1"><a id="c4-para-0043"/>           ? evaluate(operator_combination_to_application(component), env)</p>
<p class="Sp-text-1"><a id="c4-para-0044"/>           : is_conditional(component)</p>
<p class="Sp-text-1"><a id="c4-para-0045"/>           ? eval_conditional(component, env)</p>
<p class="Sp-text-1"><a id="c4-para-0046"/>           : is_lambda_expression(component)</p>
<p class="Sp-text-1"><a id="c4-para-0047"/>           ? make_function(lambda_parameter_symbols(component),</p>
<p class="Sp-text-1"><a id="c4-para-0048"/>                           lambda_body(component), env)</p>
<p class="Sp-text-1"><a id="c4-para-0049"/>           : is_sequence(component)</p>
<p class="Sp-text-1"><a id="c4-para-0050"/>           ? eval_sequence(sequence_statements(component), env)</p>
<p class="Sp-text-1"><a id="c4-para-0051"/>           : is_block(component)</p>
<p class="Sp-text-1"><a id="c4-para-0052"/>           ? eval_block(component, env)</p>
<p class="Sp-text-1"><a id="c4-para-0053"/>           : is_return_statement(component)</p>
<p class="Sp-text-1"><a id="c4-para-0054"/>           ? eval_return_statement(component, env)</p>
<p class="Sp-text-1"><a id="c4-para-0055"/>           : is_function_declaration(component)</p>
<p class="Sp-text-1"><a id="c4-para-0056"/>           ? evaluate(function_decl_to_constant_decl(component), env)</p>
<p class="Sp-text-1"><a id="c4-para-0057"/>           : is_declaration(component)</p>
<p class="Sp-text-1"><a id="c4-para-0058"/>           ? eval_declaration(component, env)</p>
<p class="Sp-text-1"><a id="c4-para-0059"/>           : is_assignment(component)</p>
<p class="Sp-text-1"><a id="c4-para-0060"/>           ? eval_assignment(component, env)</p>
<p class="Sp-text-1"><a id="c4-para-0061"/>           : error(component, "unknown syntax – evaluate");</p>
<p class="Sp-text-1"><a id="c4-para-0062"/>}</p>
<p><a id="c4-para-0063"/>For clarity, <span class="KeyTerm1">evaluate</span> has been implemented as a case analysis using conditional expressions. The disadvantage of this is that our function handles only a few distinguishable types of statements and expressions, and no new ones can be defined without editing the declaration of <span class="KeyTerm1">evaluate</span>. In most interpreter implementations, dispatching on the type of a component is done in a data-directed style. This allows a user to add new types of components that <span class="KeyTerm1">evaluate</span> can distinguish, without modifying the declaration of <span class="KeyTerm1">evaluate</span> itself. (See exercise 4.3.)</p>
<p><a id="c4-para-0064"/>The representation of names is handled by the syntax abstractions. Internally, the evaluator uses strings to represent names, and we refer to such strings as <i>symbols</i>. The function <span class="KeyTerm1">symbol_of_name</span> used in <span class="KeyTerm1">evaluate</span> extracts from a name the symbol by which it is represented.</p>
</section>
</section>
<section>
<h5><a id="c4-sec-0008"/><a id="c4-title-0009"/>Apply</h5>
<p class="paraaftertitle"><a id="c4-para-0065"/>The function <span class="KeyTerm1">apply</span> takes two arguments, a function and a list of arguments to which the function should be applied. The function <span class="KeyTerm1">apply</span> classifies functions into two kinds: It calls <span class="KeyTerm1">apply_primitive_function</span> to apply primitives; it applies compound functions by evaluating the block that makes up the body of the function. The environment for the evaluation of the body of a compound function is constructed by extending the base environment carried by the function to include a frame that binds the parameters of the function to the arguments to which the function is to be applied. Here is the declaration of <span class="KeyTerm1">apply</span>:</p>
<p class="Sp-text-1"><a id="c4-para-0066"/><b>function</b> apply(fun, args) {</p>
<p class="Sp-text-1"><a id="c4-para-0067"/>    <b>if</b> (is_primitive_function(fun)) {</p>
<p class="Sp-text-1"><a id="c4-para-0068"/>        <b>return</b> apply_primitive_function(fun, args);</p>
<p class="Sp-text-1"><a id="c4-para-0069"/>    } <b>else if</b> (is_compound_function(fun)) {</p>
<p class="Sp-text-1"><a id="c4-para-0070"/>        <b>const</b> result = evaluate(function_body(fun),</p>
<p class="Sp-text-1"><a id="c4-para-0071"/>                               extend_environment(</p>
<p class="Sp-text-1"><a id="c4-para-0072"/>                                   function_parameters(fun),</p>
<p class="Sp-text-1"><a id="c4-para-0073"/>                                   args,</p>
<p class="Sp-text-1"><a id="c4-para-0074"/>                                   function_environment(fun)));</p>
<p class="Sp-text-1"><a id="c4-para-0075"/>        <b>return</b> is_return_value(result)</p>
<p class="Sp-text-1"><a id="c4-para-0076"/>               ? return_value_content(result)</p>
<p class="Sp-text-1"><a id="c4-para-0077"/>               : undefined;</p>
<p class="Sp-text-1"><a id="c4-para-0078"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0079"/>        error(fun, "unknown function type – apply");</p>
<p class="Sp-text-1"><a id="c4-para-0080"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0081"/>}</p>
<p class="paracontinue"><a id="c4-para-0082"/>In order to return a value, a JavaScript function needs to evaluate a return statement. If a function terminates without evaluating a return statement, the value <span class="KeyTerm1">undefined</span> is returned. To distinguish the two cases, the evaluation of a return statement will wrap the result of evaluating its return expression into a <i>return value</i>. If the evaluation of the function body yields such a return value, the content of the return value is retrieved; otherwise the value <span class="KeyTerm1">undefined</span> is returned.<a id="c4-fn-0006a"/><a href="#c4-fn-0006"><sup>6</sup></a></p>
</section>
<section>
<h5><a id="c4-sec-0009"/><a id="c4-title-0010"/>Function arguments</h5>
<p class="paraaftertitle"><a id="c4-para-0083"/>When <span class="KeyTerm1">evaluate</span> processes a function application, it uses <span class="KeyTerm1">list_of_values</span> to produce the list of arguments to which the function is to be applied. The function <span class="KeyTerm1">list_of_values</span> takes as an argument the argument expressions of the application. It evaluates each argument expression and returns a list of the corresponding values:<a id="c4-fn-0007a"/><a href="#c4-fn-0007"><sup>7</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0084"/><b>function</b> list_of_values(exps, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0085"/>    <b>return</b> map(arg =&gt; evaluate(arg, env), exps);</p>
<p class="Sp-text-1"><a id="c4-para-0086"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0010"/><a id="c4-title-0011"/>Conditionals</h5>
<p class="paraaftertitle"><a id="c4-para-0087"/>The function <span class="KeyTerm1">eval_conditional</span> evaluates the predicate part of a conditional component in the given environment. If the result is true, the consequent is evaluated, otherwise the alternative is evaluated:</p>
<p class="Sp-text-1"><a id="c4-para-0088"/><b>function</b> eval_conditional(component, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0089"/>    <b>return</b> is_truthy(evaluate(conditional_predicate(component), env))</p>
<p class="Sp-text-1"><a id="c4-para-0090"/>           ? evaluate(conditional_consequent(component), env)</p>
<p class="Sp-text-1"><a id="c4-para-0091"/>           : evaluate(conditional_alternative(component), env);</p>
<p class="Sp-text-1"><a id="c4-para-0092"/>}</p>
<p class="paracontinue"><a id="c4-para-0093"/>Note that the evaluator does not need to distinguish between conditional expressions and conditional statements.</p>
<p><a id="c4-para-0094"/>The use of <span class="KeyTerm1">is_truthy</span> in <span class="KeyTerm1">eval_conditional</span> highlights the issue of the connection between an implemented language and an implementation language. The <span class="KeyTerm1">conditional_predicate</span> is evaluated in the language being implemented and thus yields a value in that language. The interpreter predicate <span class="KeyTerm1">is_truthy</span> translates that value into a value that can be tested by the conditional expression in the implementation language: The metacircular representation of truth might not be the same as that of the underlying JavaScript.<a id="c4-fn-0008a"/><a href="#c4-fn-0008"><sup>8</sup></a></p>
</section>
<section>
<h5><a id="c4-sec-0011"/><a id="c4-title-0012"/>Sequences</h5>
<p class="paraaftertitle"><a id="c4-para-0095"/>The function <span class="KeyTerm1">eval_sequence</span> is used by <span class="KeyTerm1">evaluate</span> to evaluate a sequence of statements at the top level or in a block. It takes as arguments a sequence of statements and an environment, and evaluates the statements in the order in which they occur. The value returned is the value of the final statement, except that if the evaluation of any statement in the sequence yields a return value, that value is returned and the subsequent statements are ignored.<a id="c4-fn-0009a"/><a href="#c4-fn-0009"><sup>9</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0103"/><b>function</b> eval_sequence(stmts, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0104"/>    <b>if</b> (is_empty_sequence(stmts)) {</p>
<p class="Sp-text-1"><a id="c4-para-0105"/>        <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c4-para-0106"/>    } <b>else if</b> (is_last_statement(stmts)) {</p>
<p class="Sp-text-1"><a id="c4-para-0107"/>        <b>return</b> evaluate(first_statement(stmts), env);</p>
<p class="Sp-text-1"><a id="c4-para-0108"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0109"/>        <b>const</b> first_stmt_value =</p>
<p class="Sp-text-1"><a id="c4-para-0110"/>            evaluate(first_statement(stmts), env);</p>
<p class="Sp-text-1"><a id="c4-para-0111"/>        <b>if</b> (is_return_value(first_stmt_value)) {</p>
<p class="Sp-text-1"><a id="c4-para-0112"/>            <b>return</b> first_stmt_value;</p>
<p class="Sp-text-1"><a id="c4-para-0113"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0114"/>            <b>return</b> eval_sequence(rest_statements(stmts), env);</p>
<p class="Sp-text-1"><a id="c4-para-0115"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-0116"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0117"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0012"/><a id="c4-title-0013"/>Blocks</h5>
<p class="paraaftertitle"><a id="c4-para-0118"/>The function <span class="KeyTerm1">eval_block</span> handles blocks. The variables and constants (including functions) declared in the block have the whole block as their scope and thus are “scanned out” before the body of the block is evaluated. The body of the block is evaluated with respect to an environment that extends the current environment by a frame that binds each local name to a special value, <span class="KeyTerm1">"*unassigned*"</span>. This string serves as a placeholder, before the evaluation of the declaration assigns the name its proper value. An attempt to access the value of the name before its declaration is evaluated leads to an error at run time (see exercise 4.12), as stated in footnote 56 in chapter 1.</p>
<p class="Sp-text-1"><a id="c4-para-0119"/><b>function</b> eval_block(component, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0120"/>    <b>const</b> body = block_body(component);</p>
<p class="Sp-text-1"><a id="c4-para-0121"/>    <b>const</b> locals = scan_out_declarations(body);</p>
<p class="Sp-text-1"><a id="c4-para-0122"/>    <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c4-para-0123"/>    <b>return</b> evaluate(body, extend_environment(locals,</p>
<p class="Sp-text-1"><a id="c4-para-0124"/>                                             unassigneds,</p>
<p class="Sp-text-1"><a id="c4-para-0125"/>                                             env));</p>
<p class="Sp-text-1"><a id="c4-para-0126"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0127"/><b>function</b> list_of_unassigned(symbols) {</p>
<p class="Sp-text-1"><a id="c4-para-0128"/>    <b>return</b> map(symbol =&gt; "*unassigned*", symbols);</p>
<p class="Sp-text-1"><a id="c4-para-0129"/>}</p>
<p class="paracontinue"><a id="c4-para-0130"/>The function <span class="KeyTerm1">scan_out_declarations</span> collects a list of all symbols representing names declared in the body. It uses <span class="KeyTerm1">declaration_symbol</span> to retrieve the symbol that represents the name from the declaration statements it finds.</p>
<p class="Sp-text-1"><a id="c4-para-0131"/><b>function</b> scan_out_declarations(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0132"/>    <b>return</b> is_sequence(component)</p>
<p class="Sp-text-1"><a id="c4-para-0133"/>           ? accumulate(append,</p>
<p class="Sp-text-1"><a id="c4-para-0134"/>                        <b>null</b>,</p>
<p class="Sp-text-1"><a id="c4-para-0135"/>                        map(scan_out_declarations,</p>
<p class="Sp-text-1"><a id="c4-para-0136"/>                            sequence_statements(component)))</p>
<p class="Sp-text-1"><a id="c4-para-0137"/>           : is_declaration(component)</p>
<p class="Sp-text-1"><a id="c4-para-0138"/>           ? list(declaration_symbol(component))</p>
<p class="Sp-text-1"><a id="c4-para-0139"/>           : <b>null</b>;</p>
<p class="Sp-text-1"><a id="c4-para-0140"/>}</p>
<p class="paracontinue"><a id="c4-para-0141"/>We ignore declarations that are nested in another block, because the evaluation of that block will take care of them. The function <span class="KeyTerm1">scan_out_declarations</span> looks for declarations only in sequences because declarations in conditional statements, function declarations, and lambda expressions are always in a nested block.</p>
</section>
<section>
<h5><a id="c4-sec-0013"/><a id="c4-title-0014"/>Return statements</h5>
<p class="paraaftertitle"><a id="c4-para-0142"/>The function <span class="KeyTerm1">eval_return_statement</span> is used to evaluate return statements. As seen in <span class="KeyTerm1">apply</span> and the evaluation of sequences, the result of evaluation of a return statement needs to be identifiable so that the evaluation of a function body can return immediately, even if there are statements after the return statement. For this purpose, the evaluation of a return statement wraps the result of evaluating the return expression in a return value object.<a id="c4-fn-0010a"/><a href="#c4-fn-0010"><sup>10</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0143"/><b>function</b> eval_return_statement(component, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0144"/>    <b>return</b> make_return_value(evaluate(return_expression(component),</p>
<p class="Sp-text-1"><a id="c4-para-0145"/>                                      env));</p>
<p class="Sp-text-1"><a id="c4-para-0146"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0014"/><a id="c4-title-0015"/>Assignments and declarations</h5>
<p class="paraaftertitle"><a id="c4-para-0147"/>The function <span class="KeyTerm1">eval_assignment</span> handles assignments to names. (To simplify the presentation of our evaluator, we are allowing assignment not just to variables but also—erroneously—to constants. Exercise 4.11 explains how we could distinguish constants from variables and prevent assignment to constants.) The function <span class="KeyTerm1">eval_assignment</span> calls <span class="KeyTerm1">evaluate</span> on the value expression to find the value to be assigned and calls <span class="KeyTerm1">assignment_symbol</span> to retrieve the symbol that represents the name from the assignment. The function <span class="KeyTerm1">eval_assignment</span> transmits the symbol and the value to <span class="KeyTerm1">assign_symbol_value</span> to be installed in the designated environment. The evaluation of an assignment returns the value that was assigned.</p>
<p class="Sp-text-1"><a id="c4-para-0148"/><b>function</b> eval_assignment(component, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0149"/>    <b>const</b> value = evaluate(assignment_value_expression(component),</p>
<p class="Sp-text-1"><a id="c4-para-0150"/>                           env);</p>
<p class="Sp-text-1"><a id="c4-para-0151"/>    assign_symbol_value(assignment_symbol(component), value, env);</p>
<p class="Sp-text-1"><a id="c4-para-0152"/>    <b>return</b> value;</p>
<p class="Sp-text-1"><a id="c4-para-0153"/>}</p>
<p><a id="c4-para-0154"/>Constant and variable declarations are both recognized by the <span class="KeyTerm1">is_declaration</span> syntax predicate. They are treated in a manner similar to assignments, because <span class="KeyTerm1">eval_block</span> has already bound their symbols to <span class="KeyTerm1">"*unassigned*"</span> in the current environment. Their evaluation replaces <span class="KeyTerm1">"*unassigned*"</span> with the result of evaluating the value expression.</p>
<p class="Sp-text-1"><a id="c4-para-0155"/><b>function</b> eval_declaration(component, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0156"/>    assign_symbol_value(</p>
<p class="Sp-text-1"><a id="c4-para-0157"/>        declaration_symbol(component),</p>
<p class="Sp-text-1"><a id="c4-para-0158"/>        evaluate(declaration_value_expression(component), env), env);</p>
<p class="Sp-text-1"><a id="c4-para-0159"/>    <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c4-para-0160"/>}</p>
<p class="paracontinue"><a id="c4-para-0161"/>The result of evaluating the body of a function is determined by return statements, and therefore the return value <span class="KeyTerm1">undefined</span> in <span class="KeyTerm1">eval_declaration</span> only matters when the declaration occurs at the top level, outside of any function body. Here we use the return value <span class="KeyTerm1">undefined</span> to simplify the presentation; exercise 4.8 describes the real result of evaluating top-level components in JavaScript.</p>
</section>
<section>
<h5><a id="c4-sec-0015"/><a id="c4-title-0016"/>Exercise 4.1</h5>
<p class="paraaftertitle"><a id="c4-para-0162"/>Notice that we cannot tell whether the metacircular evaluator evaluates argument expressions from left to right or from right to left. Its evaluation order is inherited from the underlying JavaScript: If the arguments to <span class="KeyTerm1">pair</span> in <span class="KeyTerm1">map</span> are evaluated from left to right, then <span class="KeyTerm1">list_of_values</span> will evaluate argument expressions from left to right; and if the arguments to <span class="KeyTerm1">pair</span> are evaluated from right to left, then <span class="KeyTerm1">list_of_values</span> will evaluate argument expressions from right to left.</p>
<p><a id="c4-para-0163"/>Write a version of <span class="KeyTerm1">list_of_values</span> that evaluates argument expressions from left to right regardless of the order of evaluation in the underlying JavaScript. Also write a version of <span class="KeyTerm1">list_of_values</span> that evaluates argument expressions from right to left.</p>
</section>
</section>
<section>
<h3><a id="c4-sec-0016"/><span>4.1.2</span> <a id="c4-title-0017"/>Representing Components</h3>
<p class="paraaftertitle"><a id="c4-para-0164"/>Programmers write programs as text, i.e. sequences of characters, entered in a programming environment or a text editor. To run our evaluator, we need to start with a representation of this program text as a JavaScript value. In section 2.3.1 we introduced strings to represent text. We would like to evaluate programs such as <span class="KeyTerm1">"const size = 2; 5 * size;"</span> from section 1.1.2. Unfortunately, such program text does not provide enough structure to the evaluator. In this example, the program parts <span class="KeyTerm1">"size = 2"</span> and <span class="KeyTerm1">"5 * size"</span> look similar, but carry very different meanings. Abstract syntax functions such as <span class="KeyTerm1">declaration_value_expression</span> would be difficult and error-prone to implement by examining the program text. In this section, we therefore introduce a function <span class="KeyTerm1">parse</span> that translates program text to a <i>taggedlist representation</i>, reminiscent of the tagged data of section 2.4.2. For example, the application of <span class="KeyTerm1">parse</span> to the program string above produces a data structure that reflects the structure of the program: a sequence consisting of a constant declaration associating the name <span class="KeyTerm1">size</span> with the value 2 and a multiplication.</p>
<p class="Sp-text-1"><a id="c4-para-0165"/>parse("const size = 2; 5 * size;");</p>
<p class="Sp-text-1"><a id="c4-para-0166"/><i>list("sequence",</i></p>
<p class="Sp-text-1"><a id="c4-para-0167"/>     <i>list(list("constant_declaration",</i></p>
<p class="Sp-text-1"><a id="c4-para-0168"/>               <i>list("name", "size"), list("literal", 2)),</i></p>
<p class="Sp-text-1"><a id="c4-para-0169"/>          <i>list("binary_operator_combination", "*",</i></p>
<p class="Sp-text-1"><a id="c4-para-0170"/>               <i>list("literal", 5), list("name", "size"))))</i></p>
<p class="paracontinue"><a id="c4-para-0171"/>The syntax functions used by the evaluator access the tagged-list representation produced by <span class="KeyTerm1">parse</span>.</p>
<p><a id="c4-para-0172"/>The evaluator is reminiscent of the symbolic differentiation program discussed in section 2.3.2. Both programs operate on symbolic data. In both programs, the result of operating on an object is determined by operating recursively on the pieces of the object and combining the results in a way that depends on the type of the object. In both programs we used data abstraction to decouple the general rules of operation from the details of how the objects are represented. In the differentiation program this meant that the same differentiation function could deal with algebraic expressions in prefix form, in infix form, or in some other form. For the evaluator, this means that the syntax of the language being evaluated is determined solely by <span class="KeyTerm1">parse</span> and the functions that classify and extract pieces of the tagged lists produced by <span class="KeyTerm1">parse</span>.</p>
<p><a id="c4-para-0173"/><a id="c4-fig-0002a"/><a href="#c4-fig-0002">Figure 4.2</a> depicts the abstraction barrier formed by the syntax predicates and selectors, which interface the evaluator to the tagged-list representation of programs, which in turn is separated from the string representation by <span class="KeyTerm1">parse</span>. Below we describe the parsing of program components and list the corresponding syntax predicates and selectors, as well as constructors if they are needed.</p>
<figure id="c4-fig-0002"><img alt="c4-fig-0002.jpg" src="../images/c4-fig-0002.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0002a">Figure 4.2</a></span> <a id="c4-para-0174"/>Syntax abstraction in the evaluator.</p></figcaption></figure>
<section>
<h5><a id="c4-sec-0017"/><a id="c4-title-0018"/>Literal expression</h5>
<p class="paraaftertitle"><a id="c4-para-0175"/>Literal expressions are parsed into tagged lists with tag <span class="KeyTerm1">"literal"</span> and the actual value.</p>
<p class="Sp-text-1"><a id="c4-para-0176"/>《<span class="KeyTerm2"><i>literal</i>-<i>expression</i></span> 》 = list("literal", <span class="KeyTerm2"><i>value</i></span>)</p>
<p class="paracontinue"><a id="c4-para-0177"/>where <i>value</i> is the JavaScript value represented by the <i>literal</i>-<i>expression</i> string. Here 《 <i>literal</i>-<i>expression</i> 》 denotes the result of parsing the string <i>literal</i>-<i>expression</i>.</p>
<p class="Sp-text-1"><a id="c4-para-0178"/>parse("1;");</p>
<p class="Sp-text-1"><a id="c4-para-0179"/><i>list("literal", 1)</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-0180"/>parse("'hello world';");</p>
<p class="Sp-text-1"><a id="c4-para-0181"/><i>list("literal", "hello world")</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-0182"/>parse("null;");</p>
<p class="Sp-text-1"><a id="c4-para-0183"/><i>list("literal", null)</i></p>
<p class="paracontinue"><a id="c4-para-0184"/>The syntax predicate for literal expressions is <span class="KeyTerm1">is_literal</span>.</p>
<p class="Sp-text-1"><a id="c4-para-0185"/><b>function</b> is_literal(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0186"/>   <b>return</b> is_tagged_list(component, "literal");</p>
<p class="Sp-text-1"><a id="c4-para-0187"/>}</p>
<p class="paracontinue"><a id="c4-para-0188"/>It is defined in terms of the function <span class="KeyTerm1">is_tagged_list</span>, which identifies lists that begin with a designated string:</p>
<p class="Sp-text-1"><a id="c4-para-0189"/><b>function</b> is_tagged_list(component, the_tag) {</p>
<p class="Sp-text-1"><a id="c4-para-0190"/>   <b>return</b> is_pair(component) &amp;&amp; head(component) === the_tag;</p>
<p class="Sp-text-1"><a id="c4-para-0191"/>}</p>
<p class="paracontinue"><a id="c4-para-0192"/>The second element of the list that results from parsing a literal expression is its actual JavaScript value. The selector for retrieving the value is <span class="KeyTerm1">literal_value</span>.</p>
<p class="Sp-text-1"><a id="c4-para-0193"/><b>function</b> literal_value(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0194"/>   <b>return</b> head(tail(component));</p>
<p class="Sp-text-1"><a id="c4-para-0195"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-0196"/>literal_value(parse("null;"));</p>
<p class="Sp-text-1"><a id="c4-para-0197"/><i>null</i></p>
<p class="paracontinue"><a id="c4-para-0198"/>In the rest of this section, we just list the syntax predicates and selectors, and omit their declarations if they just access the obvious list elements.</p>
<p><a id="c4-para-0199"/>We provide a constructor for literals, which will come in handy:</p>
<p class="Sp-text-1"><a id="c4-para-0200"/><b>function</b> make_literal(value) {</p>
<p class="Sp-text-1"><a id="c4-para-0201"/>   <b>return</b> list("literal", value);</p>
<p class="Sp-text-1"><a id="c4-para-0202"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0018"/><a id="c4-title-0019"/>Names</h5>
<p class="paraaftertitle"><a id="c4-para-0203"/>The tagged-list representation for names includes the tag <span class="KeyTerm1">"name"</span> as first element and the string representing the name as second element.</p>
<p class="Sp-text-1"><a id="c4-para-0204"/>《 <span class="KeyTerm2"><i>name</i></span> 》 = list("name", <span class="KeyTerm2"><i>symbol</i></span>)</p>
<p class="paracontinue"><a id="c4-para-0205"/>where <i>symbol</i> is a string that contains the characters that make up the <i>name</i> as written in the program. The syntax predicate for names is <span class="KeyTerm1">is_name</span>. The symbol is accessed using the selector <span class="KeyTerm1">symbol_of_name</span>. We provide a constructor for names, to be used by <span class="KeyTerm1">operator_combination_to_application</span>:</p>
<p class="Sp-text-1"><a id="c4-para-0206"/><b>function</b> make_name(symbol) {</p>
<p class="Sp-text-1"><a id="c4-para-0207"/>   <b>return</b> list("name", symbol);</p>
<p class="Sp-text-1"><a id="c4-para-0208"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0019"/><a id="c4-title-0020"/>Expression statements</h5>
<p class="paraaftertitle"><a id="c4-para-0209"/>We do not need to distinguish between expressions and expression statements. Consequently, <span class="KeyTerm1">parse</span> can ignore the difference between the two kinds of components:</p>
<p class="Sp-text-1"><a id="c4-para-0210"/>《 <span class="KeyTerm2"><i>expression</i></span>; 》 = 《 <span class="KeyTerm2"><i>expression</i></span> 》</p>
</section>
<section>
<h5><a id="c4-sec-0020"/><a id="c4-title-0021"/>Function applications</h5>
<p class="paraaftertitle"><a id="c4-para-0211"/>Function applications are parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0212"/>《 <span class="KeyTerm2"><i>fun</i>-<i>expr</i>(<i>arg</i>-<i>expr</i><sub>1</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>arg</i>-<i>expr<sub>n</sub></i>)</span> 》=</p>
<p class="Sp-text-1"><a id="c4-para-0213"/>     list("application",</p>
<p class="Sp-text-1"><a id="c4-para-0214"/>          《 <span class="KeyTerm2"><i>fun</i>-<i>expr</i></span> 》,</p>
<p class="Sp-text-1"><a id="c4-para-0215"/>          list(《 <span class="KeyTerm2"><i>arg</i>-<i>expr</i><sub>1</sub></span> 》, <i>. . .</i>, 《 <span class="KeyTerm2"><i>arg</i>-<i>expr<sub>n</sub></i></span> 》))</p>
<p class="paracontinue"><a id="c4-para-0216"/>We declare <span class="KeyTerm1">is_application</span> as the syntax predicate and <span class="KeyTerm1">function_expression</span> and <span class="KeyTerm1">arg_expressions</span> as the selectors. We add a constructor for function applications, to be used by <span class="KeyTerm1">operator_combination_to_application</span>:</p>
<p class="Sp-text-1"><a id="c4-para-0217"/><b>function</b> make_application(function_expression, argument_expressions) {</p>
<p class="Sp-text-1"><a id="c4-para-0218"/>    <b>return</b> list("application",</p>
<p class="Sp-text-1"><a id="c4-para-0219"/>                function_expression, argument_expressions);</p>
<p class="Sp-text-1"><a id="c4-para-0220"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0021"/><a id="c4-title-0022"/>Conditionals</h5>
<p class="paraaftertitle"><a id="c4-para-0221"/>Conditional expressions are parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0222"/>《 <span class="KeyTerm2"><i>predicate</i></span> ? <span class="KeyTerm2"><i>consequent</i>-<i>expression</i></span> : <span class="KeyTerm2"><i>alternative</i>-<i>expression</i></span> 》=</p>
<p class="Sp-text-1"><a id="c4-para-0223"/>         list("conditional_expression",</p>
<p class="Sp-text-1"><a id="c4-para-0224"/>              《 <i>predicate</i> 》,</p>
<p class="Sp-text-1"><a id="c4-para-0225"/>              《 <i>consequent</i>-<i>expression</i> 》,</p>
<p class="Sp-text-1"><a id="c4-para-0226"/>              《 <i>alternative</i>-<i>expression</i> 》)</p>
<p class="paracontinue"><a id="c4-para-0227"/>Similarly, conditional statements are parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0228"/>《 <b>if</b> (<span class="KeyTerm2"><i>predicate</i></span>) <span class="KeyTerm2"><i>consequent</i>-<i>block</i></span> <b>else</b> <span class="KeyTerm2"><i>alternative</i>-<i>block</i></span> 》=</p>
<p class="Sp-text-1"><a id="c4-para-0229"/>         list("conditional_statement",</p>
<p class="Sp-text-1"><a id="c4-para-0230"/>              《 <i>predicate</i> 》,</p>
<p class="Sp-text-1"><a id="c4-para-0231"/>              《 <i>consequent</i>-<i>block</i> 》,</p>
<p class="Sp-text-1"><a id="c4-para-0232"/>              《 <i>alternative</i>-<i>block</i> 》)</p>
<p class="paracontinue"><a id="c4-para-0233"/>The syntax predicate <span class="KeyTerm1">is_conditional</span> returns true for both kinds of conditionals, and the selectors <span class="KeyTerm1">conditional_predicate</span>, <span class="KeyTerm1">conditional_consequent</span>, and <span class="KeyTerm1">conditional_alternative</span> can be applied to both kinds.</p>
</section>
<section>
<h5><a id="c4-sec-0022"/><a id="c4-title-0023"/>Lambda expressions</h5>
<p class="paraaftertitle"><a id="c4-para-0234"/>A lambda expression whose body is an expression is parsed as if the body consisted of a block containing a single return statement whose return expression is the body of the lambda expression.</p>
<p class="Sp-text-1"><a id="c4-para-0235"/>《 (<span class="KeyTerm2"><i>name</i><sub>1</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>name<sub>n</sub></i></span>) =&gt; <span class="KeyTerm2"><i>expression</i></span> 》 =</p>
<p class="Sp-text-1"><a id="c4-para-0236"/>    《 (<span class="KeyTerm2"><i>name</i><sub>1</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>name<sub>n</sub></i></span>) =&gt; { <b>return</b> <span class="KeyTerm2"><i>expression</i></span> ; } 》</p>
<p><a id="c4-para-0237"/>A lambda expression whose body is a block is parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0238"/>《 (<span class="KeyTerm2"><i>name</i><sub>1</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>name<sub>n</sub></i></span>) =&gt; <i>block</i> 》=</p>
<p class="Sp-text-1"><a id="c4-para-0239"/>    list("lambda_expression",</p>
<p class="Sp-text-1"><a id="c4-para-0240"/>     list(《 <span class="KeyTerm2"><i>name</i><sub>1</sub></span> 》, <i>. . .</i>, 《 <span class="KeyTerm2"><i>name<sub>n</sub></i></span> 》),</p>
<p class="Sp-text-1"><a id="c4-para-0241"/>     《 <span class="KeyTerm2"><i>block</i></span> 》)</p>
<p class="paracontinue"><a id="c4-para-0242"/>The syntax predicate is <span class="KeyTerm1">is_lambda_expression</span> and the selector for the body of the lambda expression is <span class="KeyTerm1">lambda_body</span>. The selector for the parameters, called <span class="KeyTerm1">lambda_parameter_symbols</span>, additionally extracts the symbols from the names.</p>
<p class="Sp-text-1"><a id="c4-para-0243"/><b>function</b> lambda_parameter_symbols(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0244"/>    <b>return</b> map(symbol_of_name, head(tail(component)));</p>
<p class="Sp-text-1"><a id="c4-para-0245"/>}</p>
<p class="paracontinue"><a id="c4-para-0246"/>The function <span class="KeyTerm1">function_decl_to_constant_decl</span> needs a constructor for lambda expressions:</p>
<p class="Sp-text-1"><a id="c4-para-0247"/><b>function</b> make_lambda_expression(parameters, body) {</p>
<p class="Sp-text-1"><a id="c4-para-0248"/>    <b>return</b> list("lambda_expression", parameters, body);</p>
<p class="Sp-text-1"><a id="c4-para-0249"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0023"/><a id="c4-title-0024"/>Sequences</h5>
<p class="paraaftertitle"><a id="c4-para-0250"/>A sequence statement packages a sequence of statements into a single statement. A sequence of statements is parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0251"/>《 <span class="KeyTerm2"><i>statement</i><sub>1</sub></span> <i>· · ·</i> <span class="KeyTerm2"><i>statement<sub>n</sub></i></span> 》 =</p>
<p class="Sp-text-1"><a id="c4-para-0252"/>      list("sequence", list(《 <span class="KeyTerm2"><i>statement</i><sub>1</sub></span> 》, <i>. . .</i>, 《 <span class="KeyTerm2"><i>statement<sub>n</sub></i></span> 》))</p>
<p class="paracontinue"><a id="c4-para-0253"/>The syntax predicate is <span class="KeyTerm1">is_sequence</span> and the selector is <span class="KeyTerm1">sequence_statements</span>. We retrieve the first of a list of statements using <span class="KeyTerm1">first_statement</span> and the remaining statements using <span class="KeyTerm1">rest_statements</span>. We test whether the list is empty using the predicate <span class="KeyTerm1">is_empty_sequence</span> and whether it contains only one element using the predicate <span class="KeyTerm1">is_last_statement</span>.<a id="c4-fn-0011a"/><a href="#c4-fn-0011"><sup>11</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0254"/><b>function</b> first_statement(stmts) { <b>return</b> head(stmts); }</p>
<p class="Sp-text-1"><a id="c4-para-0255"/><b>function</b> rest_statements(stmts) { <b>return</b> tail(stmts); }</p>
<p class="Sp-text-1"><a id="c4-para-0256"/><b>function</b> is_empty_sequence(stmts) { <b>return</b> is_null(stmts); }</p>
<p class="Sp-text-1"><a id="c4-para-0257"/><b>function</b> is_last_statement(stmts) { <b>return</b> is_null(tail(stmts)); }</p>
</section>
<section>
<h5><a id="c4-sec-0024"/><a id="c4-title-0025"/>Blocks</h5>
<p class="paraaftertitle"><a id="c4-para-0258"/>Blocks are parsed as follows:<a id="c4-fn-0012a"/><a href="#c4-fn-0012"><sup>12</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0259"/>《 { <span class="KeyTerm2"><i>statements</i></span> } 》 = list("block", 《 <span class="KeyTerm2"><i>statements</i></span> 》 )</p>
<p class="paracontinue"><a id="c4-para-0260"/>Here <i>statements</i> refers to a sequence of statements, as shown above. The syntax predicate is <span class="KeyTerm1">is_block</span> and the selector is <span class="KeyTerm1">block_body</span>.</p>
</section>
<section>
<h5><a id="c4-sec-0025"/><a id="c4-title-0026"/>Return statements</h5>
<p class="paraaftertitle"><a id="c4-para-0261"/>Return statements are parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0262"/>《 <b>return</b> <span class="KeyTerm2"><i>expression</i></span>; 》 = list("return_statement", 《 <span class="KeyTerm2"><i>expression</i></span> 》 )</p>
<p class="paracontinue"><a id="c4-para-0263"/>The syntax predicate and selector are, respectively, <span class="KeyTerm1">is_return_statement</span> and <span class="KeyTerm1">return_expression</span>.</p>
</section>
<section>
<h5><a id="c4-sec-0026"/><a id="c4-title-0027"/>Assignments</h5>
<p class="paraaftertitle"><a id="c4-para-0264"/>Assignments are parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0265"/>《 <span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>expression</i></span> 》 = list("assignment", 《 <span class="KeyTerm2"><i>name</i></span> 》 , 《 <span class="KeyTerm2"><i>expression</i></span> 》 )</p>
<p class="paracontinue"><a id="c4-para-0266"/>The syntax predicate is <span class="KeyTerm1">is_assignment</span> and the selectors are <span class="KeyTerm1">assignment_symbol</span> and <span class="KeyTerm1">assignment_value_expression</span>. The symbol is wrapped in a tagged list representing the name, and thus <span class="KeyTerm1">assignment_symbol</span> needs to unwrap it.</p>
<p class="Sp-text-1"><a id="c4-para-0267"/><b>function</b> assignment_symbol(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0268"/>    <b>return</b> symbol_of_name(head(tail(component))));</p>
<p class="Sp-text-1"><a id="c4-para-0269"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0027"/><a id="c4-title-0028"/>Constant, variable, and function declarations</h5>
<p class="paraaftertitle"><a id="c4-para-0270"/>Constant and variable declarations are parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0271"/>《 <b>const</b> <span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>expression</i></span>; 》 =</p>
<p class="Sp-text-1"><a id="c4-para-0272"/>    list("constant_declaration", 《 <span class="KeyTerm2"><i>name</i></span> 》, 《 <span class="KeyTerm2"><i>expression</i></span> 》)</p>
<p class="Sp-text-1"><a id="c4-para-0273"/>《 <b>let</b> <span class="KeyTerm2"><i>name</i></span> = <span class="KeyTerm2"><i>expression</i></span>; 》 =</p>
<p class="Sp-text-1"><a id="c4-para-0274"/>    list("variable_declaration", 《 <span class="KeyTerm2"><i>name</i></span> 》, 《 <span class="KeyTerm2"><i>expression</i></span> 》)</p>
<p class="paracontinue"><a id="c4-para-0275"/>The selectors <span class="KeyTerm1">declaration_symbol</span> and <span class="KeyTerm1">declaration_value_expression</span> apply to both kinds.</p>
<p class="Sp-text-1"><a id="c4-para-0276"/><b>function</b> declaration_symbol(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0277"/>    <b>return</b> symbol_of_name(head(tail(component)));</p>
<p class="Sp-text-1"><a id="c4-para-0278"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0279"/><b>function</b> declaration_value_expression(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0280"/>    <b>return</b> head(tail(tail(component)));</p>
<p class="Sp-text-1"><a id="c4-para-0281"/>}</p>
<p class="paracontinue"><a id="c4-para-0282"/>The function <span class="KeyTerm1">function_decl_to_constant_decl</span> needs a constructor for constant declarations:</p>
<p class="Sp-text-1"><a id="c4-para-0283"/><b>function</b> make_constant_declaration(name, value_expression) {</p>
<p class="Sp-text-1"><a id="c4-para-0284"/>    <b>return</b> list("constant_declaration", name, value_expression);</p>
<p class="Sp-text-1"><a id="c4-para-0285"/>}</p>
<p><a id="c4-para-0286"/>Function declarations are parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0287"/><b>function</b> <span class="KeyTerm2"><i>name</i></span>(<span class="KeyTerm2"><i>name</i><sub>1</sub></span>, <i>. . .</i> <span class="KeyTerm2"><i>name<sub>n</sub></i></span>) <span class="KeyTerm2"><i>block</i></span> 》=</p>
<p class="Sp-text-1"><a id="c4-para-0288"/>    list("function_declaration",</p>
<p class="Sp-text-1"><a id="c4-para-0289"/>     《 <span class="KeyTerm2"><i>name</i></span> 》,</p>
<p class="Sp-text-1"><a id="c4-para-0290"/>     list(《 <span class="KeyTerm2"><i>name</i><sub>1</sub></span> 》, <i>. . .</i>, 《 <span class="KeyTerm2"><i>name<sub>n</sub></i></span> 》),</p>
<p class="Sp-text-1"><a id="c4-para-0291"/>     《 <span class="KeyTerm2"><i>block</i></span> 》)</p>
<p class="paracontinue"><a id="c4-para-0292"/>The syntax predicate <span class="KeyTerm1">is_function_declaration</span> recognizes these. The selectors are <span class="KeyTerm1">function_declaration_name</span>, <span class="KeyTerm1">function_declaration_parameters</span>, and <span class="KeyTerm1">function_declaration_body</span>.</p>
<p><a id="c4-para-0293"/>The syntax predicate <span class="KeyTerm1">is_declaration</span> returns true for all three kinds of declarations.</p>
<p class="Sp-text-1"><a id="c4-para-0294"/><b>function</b> is_declaration(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0295"/>    <b>return</b> is_tagged_list(component, "constant_declaration") ||</p>
<p class="Sp-text-1"><a id="c4-para-0296"/>           is_tagged_list(component, "variable_declaration") ||</p>
<p class="Sp-text-1"><a id="c4-para-0297"/>           is_tagged_list(component, "function_declaration");</p>
<p class="Sp-text-1"><a id="c4-para-0298"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0028"/><a id="c4-title-0029"/>Derived components</h5>
<p class="paraaftertitle"><a id="c4-para-0299"/>Some syntactic forms in our language can be defined in terms of components involving other syntactic forms, rather than being implemented directly. One example is function declaration, which <span class="KeyTerm1">evaluate</span> transforms into a constant declaration whose value expression is a lambda expression.<a id="c4-fn-0013a"/><a href="#c4-fn-0013"><sup>13</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0300"/><b>function</b> function_decl_to_constant_decl(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0301"/>    <b>return</b> make_constant_declaration(</p>
<p class="Sp-text-1"><a id="c4-para-0302"/>               function_declaration_name(component),</p>
<p class="Sp-text-1"><a id="c4-para-0303"/>               make_lambda_expression(</p>
<p class="Sp-text-1"><a id="c4-para-0304"/>                   function_declaration_parameters(component),</p>
<p class="Sp-text-1"><a id="c4-para-0305"/>                   function_declaration_body(component)));</p>
<p class="Sp-text-1"><a id="c4-para-0306"/>}</p>
<p class="paracontinue"><a id="c4-para-0307"/>Implementing the evaluation of function declarations in this way simplifies the evaluator because it reduces the number of syntactic forms for which the evaluation process must be explicitly specified.</p>
<p><a id="c4-para-0308"/>Similarly, we define operator combinations in terms of function applications. Operator combinations are unary or binary and carry their operator symbol as second element in the tagged-list representation:</p>
<p class="Sp-text-1"><a id="c4-para-0309"/>《 <span class="KeyTerm2"><i>unary</i>-<i>operator expression</i></span> 》=</p>
<p class="Sp-text-1"><a id="c4-para-0310"/>    list("unary_operator_combination",</p>
<p class="Sp-text-1"><a id="c4-para-0311"/>         "<span class="KeyTerm2"><i>unary</i>-<i>operator</i></span>",</p>
<p class="Sp-text-1"><a id="c4-para-0312"/>         list(《 <span class="KeyTerm2"><i>expression</i></span> 》))</p>
<p class="paracontinue"><a id="c4-para-0313"/>where <i>unary</i>-<i>operator</i> is <span class="KeyTerm1">!</span> (for logical negation) or <span class="KeyTerm1">-unary</span> (for numeric negation), and</p>
<p class="Sp-text-1"><a id="c4-para-0314"/>《 <span class="KeyTerm2"><i>expression</i><sub>1</sub> <i>binary</i>-<i>operator expression</i><sub>2</sub></span> 》=</p>
<p class="Sp-text-1"><a id="c4-para-0315"/>    list("binary_operator_combination",</p>
<p class="Sp-text-1"><a id="c4-para-0316"/>         "<span class="KeyTerm2"><i>binary</i>-<i>operator</i></span>",</p>
<p class="Sp-text-1"><a id="c4-para-0317"/>         list(《 <span class="KeyTerm2"><i>expression</i><sub>1</sub></span> 》, 《 <span class="KeyTerm2"><i>expression</i><sub>2</sub></span> 》))</p>
<p class="paracontinue"><a id="c4-para-0318"/>where <i>binary</i>-<i>operator</i> is <span class="KeyTerm1">+</span>, <span class="KeyTerm1">-</span>, <span class="KeyTerm1">*</span>, <span class="KeyTerm1">/</span>, <span class="KeyTerm1">%</span>, <span class="KeyTerm1">===</span>, <span class="KeyTerm1">!==</span>, <span class="KeyTerm1">&gt;</span>, <span class="KeyTerm1">&lt;</span>, <span class="KeyTerm1">&gt;=</span> or <span class="KeyTerm1">&lt;=</span>. The syntax predicates are <span class="KeyTerm1">is_operator_combination</span>, <span class="KeyTerm1">is_unary_operator_combination</span>, and <span class="KeyTerm1">is_binary_operator_combination</span>, and the selectors are <span class="KeyTerm1">operator_symbol</span>, <span class="KeyTerm1">first_operand</span>, and <span class="KeyTerm1">second_operand</span>.</p>
<p><a id="c4-para-0319"/>The evaluator uses <span class="KeyTerm1">operator_combination_to_application</span> to transform an operator combination into a function application whose function expression is the name of the operator:</p>
<p class="Sp-text-1"><a id="c4-para-0320"/><b>function</b> operator_combination_to_application(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0321"/>    <b>const</b> operator = operator_symbol(component);</p>
<p class="Sp-text-1"><a id="c4-para-0322"/>    <b>return</b> is_unary_operator_combination(component)</p>
<p class="Sp-text-1"><a id="c4-para-0323"/>           ? make_application(make_name(operator),</p>
<p class="Sp-text-1"><a id="c4-para-0324"/>                              list(first_operand(component)))</p>
<p class="Sp-text-1"><a id="c4-para-0325"/>           : make_application(make_name(operator),</p>
<p class="Sp-text-1"><a id="c4-para-0326"/>                              list(first_operand(component),</p>
<p class="Sp-text-1"><a id="c4-para-0327"/>                                   second_operand(component)));</p>
<p class="Sp-text-1"><a id="c4-para-0328"/>}</p>
<p><a id="c4-para-0329"/>Components (such as function declarations and operator combinations) that we choose to implement as syntactic transformations are called <i>derived components</i>. Logical composition operations are also derived components (see exercise 4.4).</p>
</section>
<section>
<h5><a id="c4-sec-0029"/><a id="c4-title-0030"/>Exercise 4.2</h5>
<p class="paraaftertitle"><a id="c4-para-0330"/>The inverse of <span class="KeyTerm1">parse</span> is called <span class="KeyTerm1">unparse</span>. It takes as argument a tagged list as produced by <span class="KeyTerm1">parse</span> and returns a string that adheres to JavaScript notation.</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0014"/><span>a. </span>Write a function <span class="KeyTerm1">unparse</span> by following the structure of <span class="KeyTerm1">evaluate</span> (without the environment parameter), but producing a string that represents the given component, rather than evaluating it. Recall from section 3.3.4 that the operator <span class="KeyTerm1">+</span> can be applied to two strings to concatenate them and that the primitive function <span class="KeyTerm1">stringify</span> turns values such as 1.5, true, <span class="KeyTerm1"><b>null</b></span> and <span class="KeyTerm1">undefined</span> into strings. Take care to respect operator precedences by surrounding the strings that result from unparsing operator combinations with parentheses (always or whenever necessary).</li>
<li><a id="c4-li-0015"/><span>b. </span>Your <span class="KeyTerm1">unparse</span> function will come in handy when solving later exercises in this section. Improve <span class="KeyTerm1">unparse</span> by adding <span class="KeyTerm1">" "</span> (space) and <span class="KeyTerm1">"\n"</span> (newline) characters to the result string, to follow the indentation style used in the JavaScript programs of this book. Adding such whitespace characters to (or removing them from) a program text in order to make the text easier to read is called <i>pretty-printing</i>.</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0030"/><a id="c4-title-0031"/>Exercise 4.3</h5>
<p class="paraaftertitle"><a id="c4-para-0333"/>Rewrite <span class="KeyTerm1">evaluate</span> so that the dispatch is done in data-directed style. Compare this with the data-directed differentiation function of exercise 2.73. (You may use the tag of the tagged-list representation as the type of the components.)</p>
</section>
<section>
<h5><a id="c4-sec-0031"/><a id="c4-title-0032"/>Exercise 4.4</h5>
<p class="paraaftertitle"><a id="c4-para-0334"/>Recall from section 1.1.6 that the logical composition operations <span class="KeyTerm1">&amp;&amp;</span> and <span class="KeyTerm1">||</span> are syntactic sugar for conditional expressions: The logical conjunction <i>expression</i><sub>1</sub> <span class="KeyTerm1">&amp;&amp;</span> <i>expression</i><sub>2</sub> is syntactic sugar for <i>expression</i><sub>1</sub> <span class="KeyTerm1">?</span> <i>expression</i><sub>2</sub> : <span class="KeyTerm1"><b>false</b></span>, and the logical disjunction <i>expression</i><sub>1 </sub><span class="KeyTerm1">||</span> <i>expression</i><sub>2 </sub>is syntactic sugar for <i>expression</i><sub>1 </sub><span class="KeyTerm1">? <b>true</b></span> : <i>expression</i><sub>2</sub>. They are parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0335"/>《 <span class="KeyTerm2"><i>expression</i><sub>1</sub> <i>logical</i>-<i>operation expression</i><sub>2</sub></span> 》=</p>
<p class="Sp-text-1"><a id="c4-para-0336"/>    list("logical_composition",</p>
<p class="Sp-text-1"><a id="c4-para-0337"/>         "<span class="KeyTerm2"><i>logical</i>-<i>operation</i></span>",</p>
<p class="Sp-text-1"><a id="c4-para-0338"/>         list(《 <span class="KeyTerm2"><i>expression</i><sub>1</sub> </span> 》, 《 <span class="KeyTerm2"><i>expression</i><sub>2</sub> </span> 》))</p>
<p class="paracontinue"><a id="c4-para-0339"/>where <i>logical</i>-<i>operation</i> is <span class="KeyTerm1">&amp;&amp;</span> or <span class="KeyTerm1">||</span>. Install <span class="KeyTerm1">&amp;&amp;</span> and <span class="KeyTerm1">||</span> as new syntactic forms for the evaluator by declaring appropriate syntax functions and evaluation functions <span class="KeyTerm1">eval_and</span> and <span class="KeyTerm1">eval_or</span>. Alternatively, show how to implement <span class="KeyTerm1">&amp;&amp;</span> and <span class="KeyTerm1">||</span> as derived components.</p>
</section>
<section>
<h5><a id="c4-sec-0032"/><a id="c4-title-0033"/>Exercise 4.5</h5>
<ol class="BS_NumberListA">
<li><a id="c4-li-0016"/><span>a. </span>In JavaScript, lambda expressions must not have duplicate parameters. The evaluator in section 4.1.1 does not check for this.<ul style="list-style-type:disc">
<li>Modify the evaluator so that any attempt to apply a function with duplicate parameters signals an error.</li>
<li>Implement a <span class="KeyTerm1">verify</span> function that checks whether any lambda expression in a given program contains duplicate parameters. With such a function, we could check the entire program before we pass it to <span class="KeyTerm1">evaluate</span>.</li>
</ul>
<p class="paracontinue"><a id="c4-para-0343"/>In order to implement this check in an evaluator for JavaScript, which of these two approaches would you prefer? Why?</p></li>
<li><a id="c4-li-0019"/><span>b. </span>In JavaScript, the parameters of a lambda expression must be distinct from the names declared <i>directly</i> in the body block of the lambda expression (as opposed to in an inner block). Use your preferred approach above to check for this as well.</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0033"/><a id="c4-title-0034"/>Exercise 4.6</h5>
<p class="paraaftertitle"><a id="c4-para-0345"/>The language Scheme includes a variant of <span class="KeyTerm1"><b>let</b></span> called <span class="KeyTerm1"><b>let</b>*</span>. We could approximate the behavior of <span class="KeyTerm1"><b>let</b>*</span> in JavaScript by stipulating that a <span class="KeyTerm1"><b>let</b>*</span> declaration implicitly introduces a new block whose body includes the declaration and all subsequent statements of the statement sequence in which the declaration occurs. For example, the program</p>
<p class="Sp-text-1"><a id="c4-para-0346"/><b>let</b>* x = 3;</p>
<p class="Sp-text-1"><a id="c4-para-0347"/><b>let</b>* y = x + 2;</p>
<p class="Sp-text-1"><a id="c4-para-0348"/><b>let</b>* z = x + y + 5;</p>
<p class="Sp-text-1"><a id="c4-para-0349"/>display(x * z);</p>
<p class="paracontinue"><a id="c4-para-0350"/>displays 39 and could be seen as a shorthand for</p>
<p class="Sp-text-1"><a id="c4-para-0351"/>{</p>
<p class="Sp-text-1"><a id="c4-para-0352"/>  <b>let</b> x = 3;</p>
<p class="Sp-text-1"><a id="c4-para-0353"/>  {</p>
<p class="Sp-text-1"><a id="c4-para-0354"/>    <b>let</b> y = x + 2;</p>
<p class="Sp-text-1"><a id="c4-para-0355"/>    {</p>
<p class="Sp-text-1"><a id="c4-para-0356"/>      <b>let</b> z = x + y + 5;</p>
<p class="Sp-text-1"><a id="c4-para-0357"/>      display(x * z);</p>
<p class="Sp-text-1"><a id="c4-para-0358"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0359"/>  }</p>
<p class="Sp-text-1"><a id="c4-para-0360"/>}</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0020"/><span>a. </span>Write a program in such an extended JavaScript language that behaves differently when some occurrences of the keyword <span class="KeyTerm1"><b>let</b></span> are replaced with <span class="KeyTerm1"><b>let</b>*</span>.</li>
<li><a id="c4-li-0021"/><span>b. </span>Introduce <span class="KeyTerm1"><b>let</b>*</span> as a new syntactic form by designing a suitable tagged-list representation and writing a parse rule. Declare a syntax predicate and selectors for the tagged-list representation.</li>
<li><a id="c4-li-0022"/><span>c. </span>Assuming that <span class="KeyTerm1">parse</span> implements your new rule, write a <span class="KeyTerm1">let_star_to_nested_let</span> function that transforms any occurrence of <span class="KeyTerm1"><b>let</b>*</span> in a given program as described above. We could then evaluate a program <span class="KeyTerm1">p</span> in the extended language by running <span class="KeyTerm1">evaluate(let_star_to_nested_let(p))</span>.</li>
<li><a id="c4-li-0023"/><span>d. </span>As an alternative, consider implementing <span class="KeyTerm1"><b>let</b>*</span> by adding to <span class="KeyTerm1">evaluate</span> a clause that recognizes the new syntactic form and calls a function <span class="KeyTerm1">eval_let_star_declaration</span>. Why does this approach not work?</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0034"/><a id="c4-title-0035"/>Exercise 4.7</h5>
<p class="paraaftertitle"><a id="c4-para-0365"/>JavaScript supports <i>while loops</i> that execute a given statement repeatedly. Specifically,</p>
<p class="Sp-text-1"><a id="c4-para-0366"/><b>while</b> (<span class="KeyTerm2"><i>predicate</i></span>) { <span class="KeyTerm2"><i>body</i></span> }</p>
<p class="paracontinue"><a id="c4-para-0367"/>evaluates the <i>predicate</i>, and if the result is true, evaluates the <i>body</i> and then evaluates the whole while loop again. Once the <i>predicate</i> evaluates to false, the while loop terminates.</p>
<p><a id="c4-para-0368"/>For example, recall the imperative-style version of the iterative factorial function from section 3.1.3:</p>
<p class="Sp-text-1"><a id="c4-para-0369"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c4-para-0370"/>    <b>let</b> product = 1;</p>
<p class="Sp-text-1"><a id="c4-para-0371"/>    <b>let</b> counter = 1;</p>
<p class="Sp-text-1"><a id="c4-para-0372"/>    <b>function</b> iter() {</p>
<p class="Sp-text-1"><a id="c4-para-0373"/>        <b>if</b> (counter &gt; n) {</p>
<p class="Sp-text-1"><a id="c4-para-0374"/>            <b>return</b> product;</p>
<p class="Sp-text-1"><a id="c4-para-0375"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0376"/>            product = counter * product;</p>
<p class="Sp-text-1"><a id="c4-para-0377"/>            counter = counter + 1;</p>
<p class="Sp-text-1"><a id="c4-para-0378"/>            <b>return</b> iter();</p>
<p class="Sp-text-1"><a id="c4-para-0379"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-0380"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0381"/>    <b>return</b> iter();</p>
<p class="Sp-text-1"><a id="c4-para-0382"/>}</p>
<p class="paracontinue"><a id="c4-para-0383"/>We can formulate the same algorithm using a while loop as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0384"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c4-para-0385"/>    <b>let</b> product = 1;</p>
<p class="Sp-text-1"><a id="c4-para-0386"/>    <b>let</b> counter = 1;</p>
<p class="Sp-text-1"><a id="c4-para-0387"/>    <b>while</b> (counter &lt;= n) {</p>
<p class="Sp-text-1"><a id="c4-para-0388"/>        product = counter * product;</p>
<p class="Sp-text-1"><a id="c4-para-0389"/>        counter = counter + 1;</p>
<p class="Sp-text-1"><a id="c4-para-0390"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0391"/>    <b>return</b> product;</p>
<p class="Sp-text-1"><a id="c4-para-0392"/>}</p>
<p class="paracontinue"><a id="c4-para-0393"/>While loops are parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-0394"/>《 <b>while</b> (<span class="KeyTerm2"><i>predicate</i></span>) <span class="KeyTerm2"><i>block</i></span> 》 =</p>
<p class="Sp-text-1"><a id="c4-para-0395"/>        list("while_loop", 《 <span class="KeyTerm2"><i>predicate</i></span> 》, 《 <span class="KeyTerm2"><i>block</i></span> 》)</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0024"/><span>a. </span>Declare a syntax predicate and selectors to handle while loops.</li>
<li><a id="c4-li-0025"/><span>b. </span>Declare a function <span class="KeyTerm1">while_loop</span> that takes as arguments a predicate and a body—each represented by a function of no arguments—and simulates the behavior of the while loop. The <span class="KeyTerm1">factorial</span> function would then look as follows:
<p class="Sp-text-1"><a id="c4-para-0398"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c4-para-0399"/>    <b>let</b> product = 1;</p>
<p class="Sp-text-1"><a id="c4-para-0400"/>    <b>let</b> counter = 1;</p>
<p class="Sp-text-1"><a id="c4-para-0401"/>    while_loop(() =&gt; counter &lt;= n,</p>
<p class="Sp-text-1"><a id="c4-para-0402"/>               () =&gt; {</p>
<p class="Sp-text-1"><a id="c4-para-0403"/>                   product = counter * product;</p>
<p class="Sp-text-1"><a id="c4-para-0404"/>                   counter = counter + 1;</p>
<p class="Sp-text-1"><a id="c4-para-0405"/>               });</p>
<p class="Sp-text-1"><a id="c4-para-0406"/>    <b>return</b> product;</p>
<p class="Sp-text-1"><a id="c4-para-0407"/>}</p>
<p class="paracontinue"><a id="c4-para-0408"/>Your function <span class="KeyTerm1">while_loop</span> should generate an iterative process (see section 1.2.1).</p></li>
<li><a id="c4-li-0026"/><span>c. </span>Install while loops as a derived component by defining a transformation function <span class="KeyTerm1">while_to_application</span> that makes use of your function <span class="KeyTerm1">while_loop</span>.</li>
<li><a id="c4-li-0027"/><span>d. </span>What problem arises with this approach for implementing while loops, when the programmer decides within the body of the loop to return from the function that contains the loop?</li>
<li><a id="c4-li-0028"/><span>e. </span>Change your approach to address the problem. How about directly installing while loops for the evaluator, using a function <span class="KeyTerm1">eval_while</span>?</li>
<li><a id="c4-li-0029"/><span>f. </span>Following this direct approach, implement a <span class="KeyTerm1"><b>break</b>;</span> statement that immediately terminates the loop in which it is evaluated.</li>
<li><a id="c4-li-0030"/><span>g. </span>Implement a <span class="KeyTerm1"><b>continue</b>;</span> statement that terminates only the loop iteration in which it is evaluated, and continues with evaluating the while loop predicate.</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0035"/><a id="c4-title-0036"/>Exercise 4.8</h5>
<p class="paraaftertitle"><a id="c4-para-0414"/>The result of evaluating the body of a function is determined by its return statements. Following up on footnote 9 and the evaluation of declarations in section 4.1.1, this exercise addresses the question of what should be the result of evaluating a JavaScript program that consists of a sequence of statements (declarations, blocks, expression statements, and conditional statements) <i>outside of</i> any function body.</p>
<p><a id="c4-para-0415"/>For such a program, JavaScript statically distinguishes between <i>value-producing</i> and <i>non-value-producing statements</i>. (Here “statically” means that we can make the distinction by <i>inspecting</i> the program rather than by running it.) All declarations are non-valueproducing, and all expression statements and conditional statements are value-producing. The value of an expression statement is the value of the expression. The value of a conditional statement is the value of the branch that gets executed, or the value <span class="KeyTerm1">undefined</span> if that branch is not value-producing. A block is value-producing if its body (sequence of statements) is value-producing, and then its value is the value of its body. A sequence is value-producing if any of its component statements is value-producing, and then its value is the value of its <i>last</i> value-producing component statement. Finally, if the whole program is not value-producing, its value is the value <span class="KeyTerm1">undefined</span>.</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0031"/><span>a. </span>According to this specification, what are the values of the following four programs?
<p class="Sp-text-1"><a id="c4-para-0417"/>1; 2; 3;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-0418"/>1; { <b>if</b> (<b>true</b>) {} <b>else</b> { 2; } }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-5418"/>1; <b>const</b> x = 2;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-0419"/>1; { <b>let</b> x = 2; { x = x + 3; } }</p></li>
<li><a id="c4-li-0032"/><span>b. </span>Modify the evaluator to adhere to this specification.</li>
</ol>
</section>
</section>
<section>
<h3><a id="c4-sec-0036"/><span>4.1.3</span> <a id="c4-title-0037"/>Evaluator Data Structures</h3>
<p class="paraaftertitle"><a id="c4-para-0421"/>In addition to defining the representation of components, the evaluator implementation must also define the data structures that the evaluator manipulates internally, as part of the execution of a program, such as the representation of functions and environments and the representation of true and false.</p>
<section>
<h5><a id="c4-sec-0037"/><a id="c4-title-0038"/>Testing of predicates</h5>
<p class="paraaftertitle"><a id="c4-para-0422"/>In order to limit the predicate expressions of conditionals to proper predicates (expressions that evaluate to a boolean value) as we do throughout this book, we insist here that the function <span class="KeyTerm1">is_truthy</span> gets applied only to boolean values, and we accept only the boolean value <span class="KeyTerm1"><b>true</b></span> to be truthy. The opposite of <span class="KeyTerm1">is_truthy</span> is called <span class="KeyTerm1">is_falsy</span>.<a id="c4-fn-0014a"/><a href="#c4-fn-0014"><sup>14</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0432"/><b>function</b> is_truthy(x) {</p>
<p class="Sp-text-1"><a id="c4-para-0433"/>    <b>return</b> is_boolean(x)</p>
<p class="Sp-text-1"><a id="c4-para-0434"/>           ? x</p>
<p class="Sp-text-1"><a id="c4-para-0435"/>           : error(x, "boolean expected, received");</p>
<p class="Sp-text-1"><a id="c4-para-0436"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0437"/><b>function</b> is_falsy(x) { <b>return</b> ! is_truthy(x); }</p>
</section>
<section>
<h5><a id="c4-sec-0038"/><a id="c4-title-0039"/>Representing functions</h5>
<p class="paraaftertitle"><a id="c4-para-0438"/>To handle primitives, we assume that we have available the following functions:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">apply_primitive_function(</span><i>fun</i><span class="KeyTerm1">,</span> <i>args</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c4-para-0440"/>applies the given primitive function to the argument values in the list <i>args</i> and returns the result of the application.</p></li>
<li><span class="KeyTerm1">is_primitive_function(</span><i>fun</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c4-para-0442"/>tests whether <i>fun</i> is a primitive function.</p></li>
</ul>

<p class="paracontinue"><a id="c4-para-0443"/>These mechanisms for handling primitives are further described in section 4.1.4.</p>
<p><a id="c4-para-0444"/>Compound functions are constructed from parameters, function bodies, and environments using the constructor <span class="KeyTerm1">make_function</span>:</p>
<p class="Sp-text-1"><a id="c4-para-0445"/><b>function</b> make_function(parameters, body, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0446"/>    <b>return</b> list("compound_function", parameters, body, env);</p>
<p class="Sp-text-1"><a id="c4-para-0447"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0448"/><b>function</b> is_compound_function(f) {</p>
<p class="Sp-text-1"><a id="c4-para-0449"/>    <b>return</b> is_tagged_list(f, "compound_function");</p>
<p class="Sp-text-1"><a id="c4-para-0450"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0451"/><b>function</b> function_parameters(f) { <b>return</b> list_ref(f, 1); }</p>
<p class="Sp-text-1"><a id="c4-para-0452"/><b>function</b> function_body(f) { <b>return</b> list_ref(f, 2); }</p>
<p class="Sp-text-1"><a id="c4-para-0453"/><b>function</b> function_environment(f) { <b>return</b> list_ref(f, 3); }</p>
</section>
<section>
<h5><a id="c4-sec-0039"/><a id="c4-title-0040"/>Representing return values</h5>
<p class="paraaftertitle"><a id="c4-para-0454"/>We saw in section 4.1.1 that the evaluation of a sequence terminates when a return statement is encountered, and that the evaluation of a function application needs to return the value <span class="KeyTerm1">undefined</span> if the evaluation of the function body does not encounter a return statement. In order to recognize that a value resulted from a return statement, we introduce <i>return values</i> as evaluator data structures.</p>
<p class="Sp-text-1"><a id="c4-para-0455"/><b>function</b> make_return_value(content) {</p>
<p class="Sp-text-1"><a id="c4-para-0456"/>    <b>return</b> list("return_value", content);</p>
<p class="Sp-text-1"><a id="c4-para-0457"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0458"/><b>function</b> is_return_value(value) {</p>
<p class="Sp-text-1"><a id="c4-para-0459"/>    <b>return</b> is_tagged_list(value, "return_value");</p>
<p class="Sp-text-1"><a id="c4-para-0460"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0461"/><b>function</b> return_value_content(value) {</p>
<p class="Sp-text-1"><a id="c4-para-0462"/>    <b>return</b> head(tail(value));</p>
<p class="Sp-text-1"><a id="c4-para-0463"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0040"/><a id="c4-title-0041"/>Operations on Environments</h5>
<p class="paraaftertitle"><a id="c4-para-0464"/>The evaluator needs operations for manipulating environments. As explained in section 3.2, an environment is a sequence of frames, where each frame is a table of bindings that associate symbols with their corresponding values. We use the following operations for manipulating environments:</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">lookup_symbol_value(</span><i>symbol</i><span class="KeyTerm1">,</span> <i>env</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c4-para-0466"/>returns the value that is bound to <i>symbol</i> in the environment <i>env</i>, or signals an error if <i>symbol</i> is unbound.</p></li>
<li><span class="KeyTerm1">extend_environment(</span><i>symbols</i><span class="KeyTerm1">,</span> <i>values</i><span class="KeyTerm1">,</span> <i>base</i>-<i>env</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c4-para-0468"/>returns a new environment, consisting of a new frame in which the symbols in the list <i>symbols</i> are bound to the corresponding elements in the list <i>values</i>, where the enclosing environment is the environment <i>base</i>-<i>env</i>.</p></li>
<li><span class="KeyTerm1">assign_symbol_value(</span><i>symbol</i><span class="KeyTerm1">,</span> <i>value</i><span class="KeyTerm1">,</span> <i>env</i><span class="KeyTerm1">)</span>
<p class="paracontinue"><a id="c4-para-0470"/>finds the innermost frame of <i>env</i> in which <i>symbol</i> is bound, and changes that frame so that <i>symbol</i> is now bound to <i>value</i>, or signals an error if <i>symbol</i> is unbound.</p></li>
</ul>

<p><a id="c4-para-0471"/>To implement these operations we represent an environment as a list of frames. The enclosing environment of an environment is the <span class="KeyTerm1">tail</span> of the list. The empty environment is simply the empty list.</p>
<p class="Sp-text-1"><a id="c4-para-0472"/><b>function</b> enclosing_environment(env) { <b>return</b> tail(env); }</p>
<p class="Sp-text-1"><a id="c4-para-0473"/><b>function</b> first_frame(env) { <b>return</b> head(env); }</p>
<p class="Sp-text-1"><a id="c4-para-0474"/><b>const</b> the_empty_environment = <b>null</b>;</p>
<p class="paracontinue"><a id="c4-para-0475"/>Each frame of an environment is represented as a pair of lists: a list of the names bound in that frame and a list of the associated values.<a id="c4-fn-0015a"/><a href="#c4-fn-0015"><sup>15</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0476"/><b>function</b> make_frame(symbols, values) { <b>return</b> pair(symbols, values); }</p>
<p class="Sp-text-1"><a id="c4-para-0477"/><b>function</b> frame_symbols(frame) { <b>return</b> head(frame); }</p>
<p class="Sp-text-1"><a id="c4-para-0478"/><b>function</b> frame_values(frame) { <b>return</b> tail(frame); }</p>
<p><a id="c4-para-0479"/>To extend an environment by a new frame that associates symbols with values, we make a frame consisting of the list of symbols and the list of values, and we adjoin this to the environment. We signal an error if the number of symbols does not match the number of values.</p>
<p class="Sp-text-1"><a id="c4-para-0480"/><b>function</b> extend_environment(symbols, vals, base_env) {</p>
<p class="Sp-text-1"><a id="c4-para-0481"/>    <b>return</b> length(symbols) === length(vals)</p>
<p class="Sp-text-1"><a id="c4-para-0482"/>           ? pair(make_frame(symbols, vals), base_env)</p>
<p class="Sp-text-1"><a id="c4-para-0483"/>           : error(pair(symbols, vals),</p>
<p class="Sp-text-1"><a id="c4-para-0484"/>                   length(symbols) &lt; length(vals)</p>
<p class="Sp-text-1"><a id="c4-para-0485"/>                   ? "too many arguments supplied"</p>
<p class="Sp-text-1"><a id="c4-para-0486"/>                   : "too few arguments supplied");</p>
<p class="Sp-text-1"><a id="c4-para-0487"/>}</p>
<p class="paracontinue"><a id="c4-para-0488"/>This is used by <span class="KeyTerm1">apply</span> in section 4.1.1 to bind the parameters of a function to its arguments.</p>
<p><a id="c4-para-0489"/>To look up a symbol in an environment, we scan the list of symbols in the first frame. If we find the desired symbol, we return the corresponding element in the list of values. If we do not find the symbol in the current frame, we search the enclosing environment, and so on. If we reach the empty environment, we signal an <span class="KeyTerm1">"unbound name"</span> error.</p>
<p class="Sp-text-1"><a id="c4-para-0490"/><b>function</b> lookup_symbol_value(symbol, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0491"/>    <b>function</b> env_loop(env) {</p>
<p class="Sp-text-1"><a id="c4-para-0492"/>        <b>function</b> scan(symbols, vals) {</p>
<p class="Sp-text-1"><a id="c4-para-0493"/>            <b>return</b> is_null(symbols)</p>
<p class="Sp-text-1"><a id="c4-para-0494"/>                   ? env_loop(enclosing_environment(env))</p>
<p class="Sp-text-1"><a id="c4-para-0495"/>                   : symbol === head(symbols)</p>
<p class="Sp-text-1"><a id="c4-para-0496"/>                   ? head(vals)</p>
<p class="Sp-text-1"><a id="c4-para-0497"/>                   : scan(tail(symbols), tail(vals));</p>
<p class="Sp-text-1"><a id="c4-para-0498"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-0499"/>        <b>if</b> (env === the_empty_environment) {</p>
<p class="Sp-text-1"><a id="c4-para-0500"/>            error(symbol, "unbound name");</p>
<p class="Sp-text-1"><a id="c4-para-0501"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0502"/>            <b>const</b> frame = first_frame(env);</p>
<p class="Sp-text-1"><a id="c4-para-0503"/>            <b>return</b> scan(frame_symbols(frame), frame_values(frame));</p>
<p class="Sp-text-1"><a id="c4-para-0504"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-0505"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0506"/>    <b>return</b> env_loop(env);</p>
<p class="Sp-text-1"><a id="c4-para-0507"/>}</p>
<p><a id="c4-para-0508"/>To assign a new value to a symbol in a specified environment, we scan for the symbol, just as in <span class="KeyTerm1">lookup_symbol_value</span>, and change the corresponding value when we find it.</p>
<p class="Sp-text-1"><a id="c4-para-0509"/><b>function</b> assign_symbol_value(symbol, val, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0510"/>    <b>function</b> env_loop(env) {</p>
<p class="Sp-text-1"><a id="c4-para-0511"/>        <b>function</b> scan(symbols, vals) {</p>
<p class="Sp-text-1"><a id="c4-para-0512"/>            <b>return</b> is_null(symbols)</p>
<p class="Sp-text-1"><a id="c4-para-0513"/>                   ? env_loop(enclosing_environment(env))</p>
<p class="Sp-text-1"><a id="c4-para-0514"/>                   : symbol === head(symbols)</p>
<p class="Sp-text-1"><a id="c4-para-0515"/>                   ? set_head(vals, val)</p>
<p class="Sp-text-1"><a id="c4-para-0516"/>                   : scan(tail(symbols), tail(vals));</p>
<p class="Sp-text-1"><a id="c4-para-0517"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-0518"/>        <b>if</b> (env === the_empty_environment) {</p>
<p class="Sp-text-1"><a id="c4-para-0519"/>            error(symbol, "unbound name – assignment");</p>
<p class="Sp-text-1"><a id="c4-para-0520"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0521"/>            <b>const</b> frame = first_frame(env);</p>
<p class="Sp-text-1"><a id="c4-para-0522"/>            <b>return</b> scan(frame_symbols(frame), frame_values(frame));</p>
<p class="Sp-text-1"><a id="c4-para-0523"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-0524"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0525"/>    <b>return</b> env_loop(env);</p>
<p class="Sp-text-1"><a id="c4-para-0526"/>}</p>
<p><a id="c4-para-0527"/>The method described here is only one of many plausible ways to represent environments. Since we used data abstraction to isolate the rest of the evaluator from the detailed choice of representation, we could change the environment representation if we wanted to. (See exercise 4.9.) In a production-quality JavaScript system, the speed of the evaluator's environment operations—especially that of symbol lookup—has a major impact on the performance of the system. The representation described here, although conceptually simple, is not efficient and would not ordinarily be used in a production system.<a id="c4-fn-0016a"/><a href="#c4-fn-0016"><sup>16</sup></a></p>
</section>
<section>
<h5><a id="c4-sec-0041"/><a id="c4-title-0042"/>Exercise 4.9</h5>
<p class="paraaftertitle"><a id="c4-para-0528"/>Instead of representing a frame as a pair of lists, we can represent a frame as a list of bindings, where each binding is a symbol-value pair. Rewrite the environment operations to use this alternative representation.</p>
</section>
<section>
<h5><a id="c4-sec-0042"/><a id="c4-title-0043"/>Exercise 4.10</h5>
<p class="paraaftertitle"><a id="c4-para-0529"/>The functions <span class="KeyTerm1">lookup_symbol_value</span> and <span class="KeyTerm1">assign_symbol_value</span> can be expressed in terms of a more abstract function for traversing the environment structure. Define an abstraction that captures the common pattern and redefine the two functions in terms of this abstraction.</p>
</section>
<section>
<h5><a id="c4-sec-0043"/><a id="c4-title-0044"/>Exercise 4.11</h5>
<p class="paraaftertitle"><a id="c4-para-0530"/>Our language distinguishes constants from variables by using different keywords—<span class="KeyTerm1"><b>const</b></span> and <span class="KeyTerm1"><b>let</b></span>—and prevents assignment to constants. However, our interpreter does not make use of this distinction; the function <span class="KeyTerm1">assign_symbol_value</span> will happily assign a new value to a given symbol, regardless whether it is declared as a constant or a variable. Correct this flaw by calling the function <span class="KeyTerm1">error</span> whenever an attempt is made to use a constant on the left-hand side of an assignment. You may proceed as follows:</p>
<ul style="list-style-type:disc">
<li>Introduce predicates <span class="KeyTerm1">is_constant_declaration</span> and <span class="KeyTerm1">is_variable_declaration</span> that allow you to distinguish the two kinds. As shown in section 4.1.2, <span class="KeyTerm1">parse</span> distinguishes them by using the tags <span class="KeyTerm1">"constant_declaration"</span> and <span class="KeyTerm1">"variable_declaration"</span>.</li>
<li>Change <span class="KeyTerm1">scan_out_declarations</span> and (if necessary) <span class="KeyTerm1">extend_environment</span> such that constants are distinguishable from variables in the frames in which they are bound.</li>
<li>Change <span class="KeyTerm1">assign_symbol_value</span> such that it checks whether the given symbol has been declared as a variable or as a constant, and in the latter case signals an error that assignment operations are not allowed on constants.</li>
<li>Change <span class="KeyTerm1">eval_declaration</span> such that when it encounters a constant declaration, it calls a new function, <span class="KeyTerm1">assign_constant_value</span>, which does not perform the check that you introduced in <span class="KeyTerm1">assign_symbol_value</span>.</li>
<li>If necessary, change <span class="KeyTerm1">apply</span> to ensure that assignment to function parameters remains possible.</li>
</ul>
</section>
<section>
<h5><a id="c4-sec-0044"/><a id="c4-title-0045"/>Exercise 4.12</h5>
<ol class="BS_NumberListA">
<li><a id="c4-li-0043"/><span>a. </span>JavaScript's specification requires an implementation to signal a runtime error upon an attempt to access the value of a name before its declaration is evaluated (see the end of section 3.2.4). To achieve this behavior in the evaluator, change <span class="KeyTerm1">lookup_symbol_value</span> to signal an error if the value it finds is <span class="KeyTerm1">"*unassigned*"</span>.</li>
<li><a id="c4-li-0044"/><span>b. </span>Similarly, we must not assign a new value to a variable if we have not evaluated its <span class="KeyTerm1"><b>let</b></span> declaration yet. Change the evaluation of assignment such that assignment to a variable declared with <span class="KeyTerm1"><b>let</b></span> signals an error in this case.</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0045"/><a id="c4-title-0046"/>Exercise 4.13</h5>
<p class="paraaftertitle"><a id="c4-para-0538"/>Prior to ECMAScript 2015's strict mode that we are using in this book, JavaScript variables worked quite differently from Scheme variables, which would have made this adaptation to JavaScript considerably less compelling.</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0045"/><span>a. </span>Before ECMAScript 2015, the only way to declare a local variable in JavaScript was using the keyword <span class="KeyTerm1"><b>var</b></span> instead of the keyword <span class="KeyTerm1"><b>let</b></span>. The scope of variables declared with <span class="KeyTerm1"><b>var</b></span> is the entire body of the immediately surrounding function declaration or lambda expression, rather than just the immediately enclosing block. Modify <span class="KeyTerm1">scan_out_declarations</span> and <span class="KeyTerm1">eval_block</span> such that names declared with <span class="KeyTerm1"><b>const</b></span> and <span class="KeyTerm1"><b>let</b></span> follow the scoping rules of <span class="KeyTerm1"><b>var</b></span>.</li>
<li><a id="c4-li-0046"/><span>b. </span>When not in strict mode, JavaScript permits undeclared names to appear to the left of the <span class="KeyTerm1">=</span> in assignments. Such an assignment adds the new binding to the global environment. Modify the function <span class="KeyTerm1">assign_symbol_value</span> to make assignment behave this way. The strict mode, which forbids such assignments, was introduced in JavaScript in order to make programs more secure. What security issue is addressed by preventing assignment from adding bindings to the global environment?</li>
</ol>
</section>
</section>
<section>
<h3><a id="c4-sec-0046"/><span>4.1.4</span> <a id="c4-title-0047"/>Running the Evaluator as a Program</h3>
<p class="paraaftertitle"><a id="c4-para-0541"/>Given the evaluator, we have in our hands a description (expressed in JavaScript) of the process by which JavaScript statements and expressions are evaluated. One advantage of expressing the evaluator as a program is that we can run the program. This gives us, running within JavaScript, a working model of how JavaScript itself evaluates expressions. This can serve as a framework for experimenting with evaluation rules, as we shall do later in this chapter.</p>
<p><a id="c4-para-0542"/>Our evaluator program reduces expressions ultimately to the application of primitive functions. Therefore, all that we need to run the evaluator is to create a mechanism that calls on the underlying JavaScript system to model the application of primitive functions.</p>
<p><a id="c4-para-0543"/>There must be a binding for each primitive function name and operator, so that when <span class="KeyTerm1">evaluate</span> evaluates the function expression of an application of a primitive, it will find an object to pass to <span class="KeyTerm1">apply</span>. We thus set up a global environment that associates unique objects with the names of the primitive functions and operators that can appear in the expressions we will be evaluating. The global environment also includes bindings for <span class="KeyTerm1">undefined</span> and other names, so that they can be used as constants in expressions to be evaluated.</p>
<p class="Sp-text-1"><a id="c4-para-0544"/><b>function</b> setup_environment() {</p>
<p class="Sp-text-1"><a id="c4-para-0545"/>    <b>return</b> extend_environment(append(primitive_function_symbols,</p>
<p class="Sp-text-1"><a id="c4-para-0546"/>                                     primitive_constant_symbols),</p>
<p class="Sp-text-1"><a id="c4-para-0547"/>                              append(primitive_function_objects,</p>
<p class="Sp-text-1"><a id="c4-para-0548"/>                                     primitive_constant_values),</p>
<p class="Sp-text-1"><a id="c4-para-0549"/>                              the_empty_environment);</p>
<p class="Sp-text-1"><a id="c4-para-0550"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0551"/><b>const</b> the_global_environment = setup_environment();</p>
<p><a id="c4-para-0552"/>It does not matter how we represent primitive function objects, so long as <span class="KeyTerm1">apply</span> can identify and apply them using the functions <span class="KeyTerm1">is_primitive_function</span> and <span class="KeyTerm1">apply_primitive_function</span>. We have chosen to represent a primitive function as a list beginning with the string <span class="KeyTerm1">"primitive"</span> and containing a function in the underlying JavaScript that implements that primitive.</p>
<p class="Sp-text-1"><a id="c4-para-0553"/><b>function</b> is_primitive_function(fun) {</p>
<p class="Sp-text-1"><a id="c4-para-0554"/>    <b>return</b> is_tagged_list(fun, "primitive");</p>
<p class="Sp-text-1"><a id="c4-para-0555"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0556"/><b>function</b> primitive_implementation(fun) { <b>return</b> head(tail(fun)); }</p>
<p><a id="c4-para-0557"/>The function <span class="KeyTerm1">setup_environment</span> will get the primitive names and implementation functions from a list:<a id="c4-fn-0017a"/><a href="#c4-fn-0017"><sup>17</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0558"/><b>const</b> primitive_functions = list(list("head", head ),</p>
<p class="Sp-text-1"><a id="c4-para-0559"/>                                 list("tail", tail ),</p>
<p class="Sp-text-1"><a id="c4-para-0560"/>                                 list("pair", pair ),</p>
<p class="Sp-text-1"><a id="c4-para-0561"/>                                 list("is_null", is_null ),</p>
<p class="Sp-text-1"><a id="c4-para-0562"/>                                 list("+", (x, y) =&gt; x + y ),</p>
<p class="Sp-text-1"><a id="c4-para-0563"/>                                 〈<span class="KeyTerm2"><i>more primitive functions</i></span>〉</p>
<p class="Sp-text-1"><a id="c4-para-0564"/>                                );</p>
<p class="Sp-text-1"><a id="c4-para-0565"/><b>const</b> primitive_function_symbols =</p>
<p class="Sp-text-1"><a id="c4-para-0566"/>    map(f =&gt; head(f), primitive_functions);</p>
<p class="Sp-text-1"><a id="c4-para-0567"/><b>const</b> primitive_function_objects =</p>
<p class="Sp-text-1"><a id="c4-para-0568"/>    map(f =&gt; list("primitive", head(tail(f))),</p>
<p class="Sp-text-1"><a id="c4-para-0569"/>        primitive_functions);</p>
<p><a id="c4-para-0570"/>Similar to primitive functions, we define other primitive constants that are installed in the global environment by the function <span class="KeyTerm1">setup_environment</span>.</p>
<p class="Sp-text-1"><a id="c4-para-0571"/><b>const</b> primitive_constants = list(list("undefined", undefined),</p>
<p class="Sp-text-1"><a id="c4-para-0572"/>                                 list("math_PI", math_PI)</p>
<p class="Sp-text-1"><a id="c4-para-0573"/>                                 〈<span class="KeyTerm2"><i>more primitive constants</i></span>〉</p>
<p class="Sp-text-1"><a id="c4-para-0574"/>                                );</p>
<p class="Sp-text-1"><a id="c4-para-0575"/><b>const</b> primitive_constant_symbols =</p>
<p class="Sp-text-1"><a id="c4-para-0576"/>    map(c =&gt; head(c), primitive_constants);</p>
<p class="Sp-text-1"><a id="c4-para-0577"/><b>const</b> primitive_constant_values =</p>
<p class="Sp-text-1"><a id="c4-para-0578"/>    map(c =&gt; head(tail(c)), primitive_constants);</p>
<p><a id="c4-para-0579"/>To apply a primitive function, we simply apply the implementation function to the arguments, using the underlying JavaScript system:<a id="c4-fn-0018a"/><a href="#c4-fn-0018"><sup>18</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0580"/><b>function</b> apply_primitive_function(fun, arglist) {</p>
<p class="Sp-text-1"><a id="c4-para-0581"/>    <b>return</b> apply_in_underlying_javascript(</p>
<p class="Sp-text-1"><a id="c4-para-0582"/>               primitive_implementation(fun), arglist);</p>
<p class="Sp-text-1"><a id="c4-para-0583"/>}</p>
<p><a id="c4-para-0584"/>For convenience in running the metacircular evaluator, we provide a <i>driver loop</i> that models the read-evaluate-print loop of the underlying JavaScript system. It prints a <i>prompt</i> and reads an input program as a string. It transforms the program string into a tagged-list representation of the statement as described in section 4.1.2—a process called parsing and accomplished by the primitive function <span class="KeyTerm1">parse</span>. We precede each printed result by an <i>output prompt</i> so as to distinguish the value of the program from other output that may be printed. The driver loop gets the program environment of the previous program as argument. As described at the end of section 3.2.4, the driver loop treats the program as if it were in a block: It scans out the declarations, extends the given environment by a frame containing a binding of each name to <span class="KeyTerm1">"*unassigned*"</span>, and evaluates the program with respect to the extended environment, which is then passed as argument to the next iteration of the driver loop.</p>
<p class="Sp-text-1"><a id="c4-para-0596"/><b>const</b> input_prompt = "M-evaluate input: ";</p>
<p class="Sp-text-1"><a id="c4-para-0597"/><b>const</b> output_prompt = "M-evaluate value: ";</p>
<p class="Sp-text-1"><a id="c4-para-0598"/><b>function</b> driver_loop(env) {</p>
<p class="Sp-text-1"><a id="c4-para-0599"/>    <b>const</b> input = user_read(input_prompt);</p>
<p class="Sp-text-1"><a id="c4-para-0600"/>    <b>if</b> (is_null(input)) {</p>
<p class="Sp-text-1"><a id="c4-para-0601"/>       display("evaluator terminated");</p>
<p class="Sp-text-1"><a id="c4-para-0602"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0603"/>       <b>const</b> program = parse(input);</p>
<p class="Sp-text-1"><a id="c4-para-0604"/>       <b>const</b> locals = scan_out_declarations(program);</p>
<p class="Sp-text-1"><a id="c4-para-0605"/>       <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c4-para-0606"/>       <b>const</b> program_env = extend_environment(locals, unassigneds, env);</p>
<p class="Sp-text-1"><a id="c4-para-0607"/>       <b>const</b> output = evaluate(program, program_env);</p>
<p class="Sp-text-1"><a id="c4-para-0608"/>       user_print(output_prompt, output);</p>
<p class="Sp-text-1"><a id="c4-para-0609"/>       <b>return</b> driver_loop(program_env);</p>
<p class="Sp-text-1"><a id="c4-para-0610"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0611"/>}</p>
<p class="paracontinue"><a id="c4-para-0612"/>We use JavaScript's <span class="KeyTerm1">prompt</span> function to request and read the input string from the user:</p>
<p class="Sp-text-1"><a id="c4-para-0613"/><b>function</b> user_read(prompt_string) {</p>
<p class="Sp-text-1"><a id="c4-para-0614"/>    <b>return</b> prompt(prompt_string);</p>
<p class="Sp-text-1"><a id="c4-para-0615"/>}</p>
<p class="paracontinue"><a id="c4-para-0616"/>The function <span class="KeyTerm1">prompt</span> returns <span class="KeyTerm1"><b>null</b></span> when the user cancels the input. We use a special printing function <span class="KeyTerm1">user_print</span>, to avoid printing the environment part of a compound function, which may be a very long list (or may even contain cycles).</p>
<p class="Sp-text-1"><a id="c4-para-0617"/><b>function</b> user_print(string, object) {</p>
<p class="Sp-text-1"><a id="c4-para-0618"/>    <b>function</b> prepare(object) {</p>
<p class="Sp-text-1"><a id="c4-para-0619"/>        <b>return</b> is_compound_function(object)</p>
<p class="Sp-text-1"><a id="c4-para-0620"/>               ? "&lt; compound-function &gt;"</p>
<p class="Sp-text-1"><a id="c4-para-0621"/>               : is_primitive_function(object)</p>
<p class="Sp-text-1"><a id="c4-para-0622"/>               ? "&lt; primitive-function &gt;"</p>
<p class="Sp-text-1"><a id="c4-para-0623"/>               : is_pair(object)</p>
<p class="Sp-text-1"><a id="c4-para-0624"/>               ? pair(prepare(head(object)),</p>
<p class="Sp-text-1"><a id="c4-para-0625"/>                      prepare(tail(object)))</p>
<p class="Sp-text-1"><a id="c4-para-0626"/>               : object;</p>
<p class="Sp-text-1"><a id="c4-para-0627"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0628"/>    display(string + " " + stringify(prepare(object)));</p>
<p class="Sp-text-1"><a id="c4-para-0629"/>}</p>
<p><a id="c4-para-0630"/>Now all we need to do to run the evaluator is to initialize the global environment and start the driver loop. Here is a sample interaction:</p>
<p class="Sp-text-1"><a id="c4-para-0631"/><b>const</b> the_global_environment = setup_environment();</p>
<p class="Sp-text-1"><a id="c4-para-0632"/>driver_loop(the_global_environment);</p>
<p class="Sp-text-3"><a id="c4-para-0633"/><i>M-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-0634"/><b>function</b> append(xs, ys) {</p>
<p class="Sp-text-1"><a id="c4-para-0635"/>    <b>return</b> is_null(xs)</p>
<p class="Sp-text-1"><a id="c4-para-0636"/>           ? ys</p>
<p class="Sp-text-1"><a id="c4-para-0637"/>           : pair(head(xs), append(tail(xs), ys));</p>
<p class="Sp-text-1"><a id="c4-para-0638"/>}</p>
<p class="Sp-text-3"><a id="c4-para-0639"/><i>M-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-0640"/><i>undefined</i></p>
<p class="Sp-text-3"><a id="c4-para-0641"/><i>M-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-0642"/>append(list("a", "b", "c"), list("d", "e", "f"));</p>
<p class="Sp-text-3"><a id="c4-para-0643"/><i>M-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-0644"/><i>["a", ["b", ["c", ["d", ["e", ["f", null]]]]]]</i></p>
<section>
<h5><a id="c4-sec-0047"/><a id="c4-title-0048"/>Exercise 4.14</h5>
<p class="paraaftertitle"><a id="c4-para-0645"/>Eva Lu Ator and Louis Reasoner are each experimenting with the metacircular evaluator. Eva types in the definition of <span class="KeyTerm1">map</span>, and runs some test programs that use it. They work fine. Louis, in contrast, has installed the system version of <span class="KeyTerm1">map</span> as a primitive for the metacircular evaluator. When he tries it, things go terribly wrong. Explain why Louis's <span class="KeyTerm1">map</span> fails even though Eva's works.</p>
</section>
</section>
<section>
<h3><a id="c4-sec-0048"/><span>4.1.5</span> <a id="c4-title-0049"/>Data as Programs</h3>
<p class="paraaftertitle"><a id="c4-para-0646"/>In thinking about a JavaScript program that evaluates JavaScript statements and expressions, an analogy might be helpful. One operational view of the meaning of a program is that a program is a description of an abstract (perhaps infinitely large) machine. For example, consider the familiar program to compute factorials:</p>
<p class="Sp-text-1"><a id="c4-para-0647"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c4-para-0648"/>    <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c4-para-0649"/>           ? 1</p>
<p class="Sp-text-1"><a id="c4-para-0650"/>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c4-para-0651"/>}</p>
<p class="paracontinue"><a id="c4-para-0652"/>We may regard this program as the description of a machine containing parts that decrement, multiply, and test for equality, together with a two-position switch and another factorial machine. (The factorial machine is infinite because it contains another factorial machine within it.) <a id="c4-fig-0003a"/><a href="#c4-fig-0003">Figure 4.3</a> is a flow diagram for the factorial machine, showing how the parts are wired together.</p>
<figure id="c4-fig-0003"><img alt="c4-fig-0003.jpg" src="../images/c4-fig-0003.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0003a">Figure 4.3</a></span> <a id="c4-para-0653"/>The factorial program, viewed as an abstract machine.</p></figcaption></figure>
<p><a id="c4-para-0654"/>In a similar way, we can regard the evaluator as a very special machine that takes as input a description of a machine. Given this input, the evaluator configures itself to emulate the machine described. For example, if we feed our evaluator the definition of <span class="KeyTerm1">factorial</span>, as shown in <a id="c4-fig-0004a"/><a href="#c4-fig-0004">figure 4.4</a>, the evaluator will be able to compute factorials.</p>
<figure id="c4-fig-0004"><img alt="c4-fig-0004.jpg" src="../images/c4-fig-0004.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0004a">Figure 4.4</a></span> <a id="c4-para-0655"/>The evaluator emulating a factorial machine.</p></figcaption></figure>
<p><a id="c4-para-0656"/>From this perspective, our evaluator is seen to be a <i>universal machine</i>. It mimics other machines when these are described as JavaScript programs.<a id="c4-fn-0019a"/><a href="#c4-fn-0019"><sup>19</sup></a> This is striking. Try to imagine an analogous evaluator for electrical circuits. This would be a circuit that takes as input a signal encoding the plans for some other circuit, such as a filter. Given this input, the circuit evaluator would then behave like a filter with the same description. Such a universal electrical circuit is almost unimaginably complex. It is remarkable that the program evaluator is a rather simple program.<a id="c4-fn-0020a"/><a href="#c4-fn-0020"><sup>20</sup></a></p>
<p><a id="c4-para-0657"/>Another striking aspect of the evaluator is that it acts as a bridge between the data objects that are manipulated by our programming language and the programming language itself. Imagine that the evaluator program (implemented in JavaScript) is running, and that a user is typing programs to the evaluator and observing the results. From the perspective of the user, an input program such as <span class="KeyTerm1">x * x;</span> is a program in the programming language, which the evaluator should execute. From the perspective of the evaluator, however, the program is simply a string or—after parsing—a tagged-list representation that is to be manipulated according to a well-defined set of rules.</p>
<p><a id="c4-para-0658"/>That the user's programs are the evaluator's data need not be a source of confusion. In fact, it is sometimes convenient to ignore this distinction, and to give the user the ability to explicitly evaluate a string as a JavaScript statement, using JavaScript's primitive function <span class="KeyTerm1">eval</span> that takes as argument a string. It parses the string and—provided that it is syntactically correct—evaluates the resulting representation in the environment in which <span class="KeyTerm1">eval</span> is applied. Thus,</p>
<p class="Sp-text-1"><a id="c4-para-0659"/>eval("5 * 5;");</p>
<p class="paracontinue"><a id="c4-para-0660"/>and</p>
<p class="Sp-text-1"><a id="c4-para-0661"/>evaluate(parse("5 * 5;"), the_global_environment);</p>
<p class="paracontinue"><a id="c4-para-0662"/>will both return 25.<a id="c4-fn-0021a"/><a href="#c4-fn-0021"><sup>21</sup></a></p>
<section>
<h5><a id="c4-sec-0049"/><a id="c4-title-0050"/>Exercise 4.15</h5>
<p class="paraaftertitle"><a id="c4-para-0663"/>Given a one-argument function <span class="KeyTerm1">f</span> and an object <span class="KeyTerm1">a</span>, <span class="KeyTerm1">f</span> is said to “halt” on <span class="KeyTerm1">a</span> if evaluating the expression <span class="KeyTerm1">f(a)</span> returns a value (as opposed to terminating with an error message or running forever). Show that it is impossible to write a function <span class="KeyTerm1">halts</span> that correctly determines whether <span class="KeyTerm1">f</span> halts on <span class="KeyTerm1">a</span> for any function <span class="KeyTerm1">f</span> and object <span class="KeyTerm1">a</span>. Use the following reasoning: If you had such a function <span class="KeyTerm1">halts</span>, you could implement the following program:</p>
<p class="Sp-text-1"><a id="c4-para-0664"/><b>function</b> run_forever() { <b>return</b> run_forever(); }</p>
<p class="Sp-text-1"><a id="c4-para-0665"/><b>function</b> strange(f) {</p>
<p class="Sp-text-1"><a id="c4-para-0666"/>    <b>return</b> halts(f, f)</p>
<p class="Sp-text-1"><a id="c4-para-0667"/>           ? run_forever();</p>
<p class="Sp-text-1"><a id="c4-para-0668"/>           : "halted";</p>
<p class="Sp-text-1"><a id="c4-para-0669"/>}</p>
<p class="paracontinue"><a id="c4-para-0670"/>Now consider evaluating the expression <span class="KeyTerm1">strange(strange)</span> and show that any possible outcome (either halting or running forever) violates the intended behavior of <span class="KeyTerm1">halts</span>.<a id="c4-fn-0022a"/><a href="#c4-fn-0022"><sup>22</sup></a></p>
</section>
</section>
<section>
<h3><a id="c4-sec-0050"/><span>4.1.6</span> <a id="c4-title-0051"/>Internal Declarations</h3>
<p class="paraaftertitle"><a id="c4-para-0671"/>In JavaScript, the scope of a declaration is the entire block that immediately surrounds the declaration, not just the portion of the block starting at the point where the declaration occurs. This section takes a closer look at this design choice.</p>
<p><a id="c4-para-0672"/>Let us revisit the pair of mutually recursive functions <span class="KeyTerm1">is_even</span> and <span class="KeyTerm1">is_odd</span> from Section 3.2.4, declared locally in the body of a function <span class="KeyTerm1">f</span>.</p>
<p class="Sp-text-1"><a id="c4-para-0673"/><b>function</b> f(x) {</p>
<p class="Sp-text-1"><a id="c4-para-0674"/>    <b>function</b> is_even(n) {</p>
<p class="Sp-text-1"><a id="c4-para-0675"/>        <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c4-para-0676"/>               ? <b>true</b></p>
<p class="Sp-text-1"><a id="c4-para-0677"/>               : is_odd(n - 1);</p>
<p class="Sp-text-1"><a id="c4-para-0678"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0679"/>    <b>function</b> is_odd(n) {</p>
<p class="Sp-text-1"><a id="c4-para-0680"/>        <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c4-para-0681"/>               ? <b>false</b></p>
<p class="Sp-text-1"><a id="c4-para-0682"/>               : is_even(n - 1);</p>
<p class="Sp-text-1"><a id="c4-para-0683"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0684"/>    <b>return</b> is_even(x);</p>
<p class="Sp-text-1"><a id="c4-para-0685"/>}</p>
<p class="paracontinue"><a id="c4-para-0686"/>Our intention here is that the name <span class="KeyTerm1">is_odd</span> in the body of the function <span class="KeyTerm1">is_even</span> should refer to the function <span class="KeyTerm1">is_odd</span> that is declared after <span class="KeyTerm1">is_even</span>. The scope of the name <span class="KeyTerm1">is_odd</span> is the entire body block of <span class="KeyTerm1">f</span>, not just the portion of the body of <span class="KeyTerm1">f</span> starting at the point where the declaration of <span class="KeyTerm1">is_odd</span> occurs. Indeed, when we consider that <span class="KeyTerm1">is_odd</span> is itself defined in terms of <span class="KeyTerm1">is_even</span>—so that <span class="KeyTerm1">is_even</span> and <span class="KeyTerm1">is_odd</span> are mutually recursive functions—we see that the only satisfactory interpretation of the two declarations is to regard them as if the names <span class="KeyTerm1">is_even</span> and <span class="KeyTerm1">is_odd</span> were being added to the environment simultaneously. More generally, in block structure, the scope of a local name is the entire block in which the declaration is evaluated.</p>
<p><a id="c4-para-0687"/>The evaluation of blocks in the metacircular evaluator of section 4.1.1 achieves such a simultaneous scope for local names by scanning out the declarations in the block and extending the current environment with a frame containing bindings for all the declared names before evaluating the declarations. Thus the new environment in which the block body is evaluated already contains bindings for <span class="KeyTerm1">is_even</span> and <span class="KeyTerm1">is_odd</span>, and any occurrence of one of these names refers to the correct binding. Once their declarations are evaluated, these names are bound to their declared values, namely function objects that have the extended environment as their environment part. Thus, for example, by the time <span class="KeyTerm1">is_even</span> gets applied in the body of <span class="KeyTerm1">f</span>, its environment already contains the correct binding for the symbol <span class="KeyTerm1">is_odd</span>, and the evaluation of the name <span class="KeyTerm1">is_odd</span> in the body of <span class="KeyTerm1">is_even</span> retrieves the correct value.</p>
<section>
<h5><a id="c4-sec-0051"/><a id="c4-title-0052"/>Exercise 4.16</h5>
<p class="paraaftertitle"><a id="c4-para-0688"/>Consider the function <span class="KeyTerm1">f_3</span> of section 1.3.2:</p>
<p class="Sp-text-1"><a id="c4-para-0689"/><b>function</b> f_3(x, y) {</p>
<p class="Sp-text-1"><a id="c4-para-0690"/>    <b>const</b> a = 1 + x * y;</p>
<p class="Sp-text-1"><a id="c4-para-0691"/>    <b>const</b> b = 1 - y;</p>
<p class="Sp-text-1"><a id="c4-para-0692"/>    <b>return</b> x * square(a) + y * b + a * b;</p>
<p class="Sp-text-1"><a id="c4-para-0693"/>}</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0047"/><span>a. </span>Draw a diagram of the environment in effect during evaluation of the return expression of <span class="KeyTerm1">f_3</span>.</li>
<li><a id="c4-li-0048"/><span>b. </span>When evaluating a function application, the evaluator creates two frames: one for the parameters and one for the names declared <i>directly</i> in the function's body block, as opposed to in an inner block. Since all these names have the same scope, an implementation could combine the two frames. Change the evaluator such that the evaluation of the body block does not create a new frame. You may assume that this will not result in duplicate names in the frame (exercise 4.5 justifies this).</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0052"/><a id="c4-title-0053"/>Exercise 4.17</h5>
<p class="paraaftertitle"><a id="c4-para-0696"/>Eva Lu Ator is writing programs in which function declarations and other statements are interleaved. She needs to make sure that the declarations are evaluated before the functions are applied. She complains: “Why can't the evaluator take care of this chore, and hoist all function declarations to the beginning of the block in which they appear? Function declarations outside of blocks should be hoisted to the beginning of the program.”</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0049"/><span>a. </span>Modify the evaluator following Eva's suggestion.</li>
<li><a id="c4-li-0050"/><span>b. </span>The designers of JavaScript decided to follow Eva's approach. Discuss this decision.</li>
<li><a id="c4-li-0051"/><span>c. </span>In addition, the designers of JavaScript decided to allow the name declared by a function declaration to be reassigned using assignment. Modify your solution accordingly and discuss this decision.</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0053"/><a id="c4-title-0054"/>Exercise 4.18</h5>
<p class="paraaftertitle"><a id="c4-para-0700"/>Recursive functions are obtained in a roundabout way in our interpreter: First declare the name that will refer to the recursive function and assign to it the special value <span class="KeyTerm1">"*unassigned*"</span>; then define the recursive function in the scope of that name; and finally assign the defined function to the name. By the time the recursive function gets applied, any occurrences of the name in the body properly refer to the recursive function. Amazingly, it is possible to specify recursive functions without using declarations or assignment. The following program computes 10 factorial by applying a recursive factorial function:<a id="c4-fn-0023a"/><a href="#c4-fn-0023"><sup>23</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0701"/>(n =&gt; (fact =&gt; fact(fact, n))</p>
<p class="Sp-text-1"><a id="c4-para-0702"/>      ((ft, k) =&gt; k === 1</p>
<p class="Sp-text-1"><a id="c4-para-0703"/>                  ? 1</p>
<p class="Sp-text-1"><a id="c4-para-0704"/>                  : k * ft(ft, k - 1)))(10);</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0052"/><span>a. </span>Check (by evaluating the expression) that this really does compute factorials. Devise an analogous expression for computing Fibonacci numbers.</li>
<li><a id="c4-li-0053"/><span>b. </span>Consider the function <span class="KeyTerm1">f</span> given above:
<p class="Sp-text-1"><a id="c4-para-0707"/><b>function</b> f(x) {</p>
<p class="Sp-text-1"><a id="c4-para-0708"/>    <b>function</b> is_even(n) {</p>
<p class="Sp-text-1"><a id="c4-para-0709"/>        <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c4-para-0710"/>               ? <b>true</b></p>
<p class="Sp-text-1"><a id="c4-para-0711"/>               : is_odd(n - 1);</p>
<p class="Sp-text-1"><a id="c4-para-0712"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0713"/>    <b>function</b> is_odd(n) {</p>
<p class="Sp-text-1"><a id="c4-para-0714"/>        <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c4-para-0715"/>               ? <b>false</b></p>
<p class="Sp-text-1"><a id="c4-para-0716"/>               : is_even(n - 1);</p>
<p class="Sp-text-1"><a id="c4-para-0717"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0718"/>    <b>return</b> is_even(x);</p>
<p class="Sp-text-1"><a id="c4-para-0719"/>}</p>
<p class="paracontinue"><a id="c4-para-0720"/>Fill in the missing expressions to complete an alternative declaration of <span class="KeyTerm1">f</span>, which has no internal function declarations:</p>
<p class="Sp-text-1"><a id="c4-para-0721"/><b>function</b> f(x) {</p>
<p class="Sp-text-1"><a id="c4-para-0722"/>    <b>return</b> ((is_even, is_odd) =&gt; is_even(is_even, is_odd, x))</p>
<p class="Sp-text-1"><a id="c4-para-0723"/>           ((is_ev, is_od, n) =&gt; n === 0 ? <b>true</b> : is_od(〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉),</p>
<p class="Sp-text-1"><a id="c4-para-0724"/>            (is_ev, is_od, n) =&gt; n === 0 ? <b>false</b> : is_ev( 〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉, 〈<span class="KeyTerm2">??</span>〉));</p>
<p class="Sp-text-1"><a id="c4-para-0725"/><sub>}</sub></p></li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0054"/><a id="c4-title-0055"/>Sequential Declaration Processing</h5>
<p class="paraaftertitle"><a id="c4-para-0726"/>The design of our evaluator of section 4.1.1 imposes a runtime burden on the evaluation of blocks: It needs to scan the body of the block for locally declared names, extend the current environment with a new frame that binds those names, and evaluate the block body in this extended environment. Alternatively, the evaluation of a block could extend the current environment with an empty frame. The evaluation of each declaration in the block body would then add a new binding to that frame. To implement this design, we first simplify <span class="KeyTerm1">eval_block</span>:</p>
<p class="Sp-text-1"><a id="c4-para-0727"/><b>function</b> eval_block(component, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0728"/>    <b>const</b> body = block_body(component);</p>
<p class="Sp-text-1"><a id="c4-para-0729"/>    <b>return</b> evaluate(body, extend_environment(<b>null</b>, <b>null</b>, env);</p>
<p class="Sp-text-1"><a id="c4-para-0730"/>}</p>
<p class="paracontinue"><a id="c4-para-0731"/>The function <span class="KeyTerm1">eval_declaration</span> can no longer assume that the environment already has a binding for the name. Instead of using <span class="KeyTerm1">assign_symbol_value</span> to change an existing binding, it calls a new function, <span class="KeyTerm1">add_binding_to_frame</span>, to add to the first frame of the environment a binding of the name to the value of the value expression.</p>
<p class="Sp-text-1"><a id="c4-para-0732"/><b>function</b> eval_declaration(component, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0733"/>    add_binding_to_frame(</p>
<p class="Sp-text-1"><a id="c4-para-0734"/>        declaration_symbol(component),</p>
<p class="Sp-text-1"><a id="c4-para-0735"/>        evaluate(declaration_value_expression(component), env),</p>
<p class="Sp-text-1"><a id="c4-para-0736"/>        first_frame(env));</p>
<p class="Sp-text-1"><a id="c4-para-0737"/>    <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c4-para-0738"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0739"/><b>function</b> add_binding_to_frame(symbol, value, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-0740"/>    set_head(frame, pair(symbol, head(frame)));</p>
<p class="Sp-text-1"><a id="c4-para-0741"/>    set_tail(frame, pair(value, tail(frame)));</p>
<p class="Sp-text-1"><a id="c4-para-0742"/>}</p>
<p><a id="c4-para-0743"/>With sequential declaration processing, the scope of a declaration is no longer the entire block that immediately surrounds the declaration, but rather just the portion of the block starting at the point where the declaration occurs. Although we no longer have simultaneous scope, sequential declaration processing will evaluate calls to the function <span class="KeyTerm1">f</span> at the beginning of this section correctly, but for an “accidental” reason: Since the declarations of the internal functions come first, no calls to these functions will be evaluated until all of them have been declared. Hence, <span class="KeyTerm1">is_odd</span> will have been declared by the time <span class="KeyTerm1">is_even</span> is executed. In fact, sequential declaration processing will give the same result as our scanning-out-names evaluator in section 4.1.1 for any function in which the internal declarations come first in a body and evaluation of the value expressions for the declared names doesn't actually use any of the declared names. Exercise 4.19 shows an example of a function that doesn't obey these restrictions, so that the alternative evaluator isn't equivalent to our scanning-out-names evaluator.</p>
<p><a id="c4-para-0744"/>Sequential declaration processing is more efficient and easier to implement than scanning out names. However, with sequential processing, the declaration to which a name refers may depend on the order in which the statements in a block are evaluated. In exercise 4.19, we see that views may differ as to whether that is desirable.</p>
</section>
<section>
<h5><a id="c4-sec-0055"/><a id="c4-title-0056"/>Exercise 4.19</h5>
<p class="paraaftertitle"><a id="c4-para-0745"/>Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are arguing about the desired result of evaluating the program</p>
<p class="Sp-text-1"><a id="c4-para-0746"/><b>const</b> a = 1;</p>
<p class="Sp-text-1"><a id="c4-para-0747"/><b>function</b> f(x) {</p>
<p class="Sp-text-1"><a id="c4-para-0748"/>    <b>const</b> b = a + x;</p>
<p class="Sp-text-1"><a id="c4-para-0749"/>    <b>const</b> a = 5;</p>
<p class="Sp-text-1"><a id="c4-para-0750"/>    <b>return</b> a + b;</p>
<p class="Sp-text-1"><a id="c4-para-0751"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0752"/>f(10);</p>
<p class="paracontinue"><a id="c4-para-0753"/>Ben asserts that the result should be obtained using the sequential processing of declarations: <span class="KeyTerm1">b</span> is declared to be 11, then <span class="KeyTerm1">a</span> is declared to be 5, so the result is 16. Alyssa objects that mutual recursion requires the simultaneous scope rule for internal function declarations, and that it is unreasonable to treat function names differently from other names. Thus, she argues for the mechanism implemented in section 4.1.1. This would lead to <span class="KeyTerm1">a</span> being unassigned at the time that the value for <span class="KeyTerm1">b</span> is to be computed. Hence, in Alyssa's view the function should produce an error. Eva has a third opinion. She says that if the declarations of <span class="KeyTerm1">a</span> and <span class="KeyTerm1">b</span> are truly meant to be simultaneous, then the value 5 for <span class="KeyTerm1">a</span> should be used in evaluating <span class="KeyTerm1">b</span>. Hence, in Eva's view <span class="KeyTerm1">a</span> should be 5, <span class="KeyTerm1">b</span> should be 15, and the result should be 20. Which (if any) of these viewpoints do you support? Can you devise a way to implement internal declarations so that they behave as Eva prefers?<a id="c4-fn-0024a"/><a href="#c4-fn-0024"><sup>24</sup></a></p>
</section>
</section>
<section>
<h3><a id="c4-sec-0056"/><span>4.1.7</span> <a id="c4-title-0057"/>Separating Syntactic Analysis from Execution</h3>
<p class="paraaftertitle"><a id="c4-para-0754"/>The evaluator implemented above is simple, but it is very inefficient, because the syntactic analysis of components is interleaved with their execution. Thus if a program is executed many times, its syntax is analyzed many times. Consider, for example, evaluating <span class="KeyTerm1">factorial(4)</span> using the following definition of <span class="KeyTerm1">factorial</span>:</p>
<p class="Sp-text-1"><a id="c4-para-0755"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c4-para-0756"/>    <b>return</b> n === 1</p>
<p class="Sp-text-1"><a id="c4-para-0757"/>           ? 1</p>
<p class="Sp-text-1"><a id="c4-para-0758"/>           : factorial(n - 1) * n;</p>
<p class="Sp-text-1"><a id="c4-para-0759"/>}</p>
<p><a id="c4-para-0760"/>Each time <span class="KeyTerm1">factorial</span> is called, the evaluator must determine that the body is a conditional expression and extract the predicate. Only then can it evaluate the predicate and dispatch on its value. Each time it evaluates the expression <span class="KeyTerm1">factorial(n - 1) * n</span>, or the subexpressions <span class="KeyTerm1">factorial(n - 1)</span> and <span class="KeyTerm1">n - 1</span>, the evaluator must perform the case analysis in <span class="KeyTerm1">evaluate</span> to determine that the expression is an application, and must extract its function expression and argument expressions. This analysis is expensive. Performing it repeatedly is wasteful.</p>
<p><a id="c4-para-0761"/>We can transform the evaluator to be significantly more efficient by arranging things so that syntactic analysis is performed only once.<a id="c4-fn-0025a"/><a href="#c4-fn-0025"><sup>25</sup></a> We split <span class="KeyTerm1">evaluate</span>, which takes a component and an environment, into two parts. The function <span class="KeyTerm1">analyze</span> takes only the component. It performs the syntactic analysis and returns a new function, the <i>execution function</i>, that encapsulates the work to be done in executing the analyzed component. The execution function takes an environment as its argument and completes the evaluation. This saves work because <span class="KeyTerm1">analyze</span> will be called only once on a component, while the execution function may be called many times.</p>
<p><a id="c4-para-0762"/>With the separation into analysis and execution, <span class="KeyTerm1">evaluate</span> now becomes</p>
<p class="Sp-text-1"><a id="c4-para-0763"/><b>function</b> evaluate(component, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0764"/>    <b>return</b> analyze(component)(env);</p>
<p class="Sp-text-1"><a id="c4-para-0765"/>}</p>
<p><a id="c4-para-0766"/>The result of calling <span class="KeyTerm1">analyze</span> is the execution function to be applied to the environment. The <span class="KeyTerm1">analyze</span> function is the same case analysis as performed by the original <span class="KeyTerm1">evaluate</span> of section 4.1.1, except that the functions to which we dispatch perform only analysis, not full evaluation:</p>
<p class="Sp-text-1"><a id="c4-para-0767"/><b>function</b> analyze(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0768"/>    <b>return</b> is_literal(component)</p>
<p class="Sp-text-1"><a id="c4-para-0769"/>           ? analyze_literal(component)</p>
<p class="Sp-text-1"><a id="c4-para-0770"/>           : is_name(component)</p>
<p class="Sp-text-1"><a id="c4-para-0771"/>           ? analyze_name(component)</p>
<p class="Sp-text-1"><a id="c4-para-0772"/>           : is_application(component)</p>
<p class="Sp-text-1"><a id="c4-para-0773"/>           ? analyze_application(component)</p>
<p class="Sp-text-1"><a id="c4-para-0774"/>           : is_operator_combination(component)</p>
<p class="Sp-text-1"><a id="c4-para-0775"/>           ? analyze(operator_combination_to_application(component))</p>
<p class="Sp-text-1"><a id="c4-para-0776"/>           : is_conditional(component)</p>
<p class="Sp-text-1"><a id="c4-para-0777"/>           ? analyze_conditional(component)</p>
<p class="Sp-text-1"><a id="c4-para-0778"/>           : is_lambda_expression(component)</p>
<p class="Sp-text-1"><a id="c4-para-0779"/>           ? analyze_lambda_expression(component)</p>
<p class="Sp-text-1"><a id="c4-para-0780"/>           : is_sequence(component)</p>
<p class="Sp-text-1"><a id="c4-para-0781"/>           ? analyze_sequence(sequence_statements(component))</p>
<p class="Sp-text-1"><a id="c4-para-0782"/>           : is_block(component)</p>
<p class="Sp-text-1"><a id="c4-para-0783"/>           ? analyze_block(component)</p>
<p class="Sp-text-1"><a id="c4-para-0784"/>           : is_return_statement(component)</p>
<p class="Sp-text-1"><a id="c4-para-0785"/>           ? analyze_return_statement(component)</p>
<p class="Sp-text-1"><a id="c4-para-0786"/>           : is_function_declaration(component)</p>
<p class="Sp-text-1"><a id="c4-para-0787"/>           ? analyze(function_decl_to_constant_decl(component))</p>
<p class="Sp-text-1"><a id="c4-para-0788"/>           : is_declaration(component)</p>
<p class="Sp-text-1"><a id="c4-para-0789"/>           ? analyze_declaration(component)</p>
<p class="Sp-text-1"><a id="c4-para-0790"/>           : is_assignment(component)</p>
<p class="Sp-text-1"><a id="c4-para-0791"/>           ? analyze_assignment(component)</p>
<p class="Sp-text-1"><a id="c4-para-0792"/>           : error(component, "unknown syntax – analyze");</p>
<p class="Sp-text-1"><a id="c4-para-0793"/>}</p>
<p><a id="c4-para-0794"/>Here is the simplest syntactic analysis function, which handles literal expressions. It returns an execution function that ignores its environment argument and just returns the value of the literal:</p>
<p class="Sp-text-1"><a id="c4-para-0795"/><b>function</b> analyze_literal(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0796"/>    <b>return</b> env =&gt; literal_value(component);</p>
<p class="Sp-text-1"><a id="c4-para-0797"/>}</p>
<p><a id="c4-para-0798"/>Looking up the value of a name must still be done in the execution phase, since this depends upon knowing the environment.<a id="c4-fn-0026a"/><a href="#c4-fn-0026"><sup>26</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-0799"/><b>function</b> analyze_name(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0800"/>    <b>return</b> env =&gt; lookup_symbol_value(symbol_of_name(component), env);</p>
<p class="Sp-text-1"><a id="c4-para-0801"/>}</p>
<p><a id="c4-para-0802"/>To analyze an application, we analyze the function expression and argument expressions and construct an execution function that calls the execution function of the function expression (to obtain the actual function to be applied) and the argument-expression execution functions (to obtain the actual arguments). We then pass these to <span class="KeyTerm1">execute_application</span>, which is the analog of <span class="KeyTerm1">apply</span> in section 4.1.1. The function <span class="KeyTerm1">execute_application</span> differs from <span class="KeyTerm1">apply</span> in that the function body for a compound function has already been analyzed, so there is no need to do further analysis. Instead, we just call the execution function for the body on the extended environment.</p>
<p class="Sp-text-1"><a id="c4-para-0803"/><b>function</b> analyze_application(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0804"/>    <b>const</b> ffun = analyze(function_expression(component));</p>
<p class="Sp-text-1"><a id="c4-para-0805"/>    <b>const</b> afuns = map(analyze, arg_expressions(component));</p>
<p class="Sp-text-1"><a id="c4-para-0806"/>    <b>return</b> env =&gt; execute_application(ffun(env),</p>
<p class="Sp-text-1"><a id="c4-para-0807"/>                                      map(afun =&gt; afun(env), afuns));</p>
<p class="Sp-text-1"><a id="c4-para-0808"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0809"/><b>function</b> execute_application(fun, args) {</p>
<p class="Sp-text-1"><a id="c4-para-0810"/>    <b>if</b> (is_primitive_function(fun)) {</p>
<p class="Sp-text-1"><a id="c4-para-0811"/>        <b>return</b> apply_primitive_function(fun, args);</p>
<p class="Sp-text-1"><a id="c4-para-0812"/>    } <b>else if</b> (is_compound_function(fun)) {</p>
<p class="Sp-text-1"><a id="c4-para-0813"/>        <b>const</b> result = function_body(fun)</p>
<p class="Sp-text-1"><a id="c4-para-0814"/>                       (extend_environment(function_parameters(fun),</p>
<p class="Sp-text-1"><a id="c4-para-0815"/>                                           args,</p>
<p class="Sp-text-1"><a id="c4-para-0816"/>                                           function_environment(fun)));</p>
<p class="Sp-text-1"><a id="c4-para-0817"/>        <b>return</b> is_return_value(result)</p>
<p class="Sp-text-1"><a id="c4-para-0818"/>               ? return_value_content(result)</p>
<p class="Sp-text-1"><a id="c4-para-0819"/>               : undefined;</p>
<p class="Sp-text-1"><a id="c4-para-0820"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0821"/>        error(fun, "unknown function type – execute_application");</p>
<p class="Sp-text-1"><a id="c4-para-0822"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0823"/>}</p>
<p><a id="c4-para-0824"/>For conditionals, we extract and analyze the predicate, consequent, and alternative at analysis time.</p>
<p class="Sp-text-1"><a id="c4-para-0825"/><b>function</b> analyze_conditional(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0826"/>    <b>const</b> pfun = analyze(conditional_predicate(component));</p>
<p class="Sp-text-1"><a id="c4-para-0827"/>    <b>const</b> cfun = analyze(conditional_consequent(component));</p>
<p class="Sp-text-1"><a id="c4-para-0828"/>    <b>const</b> afun = analyze(conditional_alternative(component));</p>
<p class="Sp-text-1"><a id="c4-para-0829"/>    <b>return</b> env =&gt; is_truthy(pfun(env)) ? cfun(env) : afun(env);</p>
<p class="Sp-text-1"><a id="c4-para-0830"/>}</p>
<p><a id="c4-para-0831"/>Analyzing a lambda expression also achieves a major gain in efficiency: We analyze the lambda body only once, even though functions resulting from evaluation of the lambda expression may be applied many times.</p>
<p class="Sp-text-1"><a id="c4-para-0832"/><b>function</b> analyze_lambda_expression(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0833"/>    <b>const</b> params = lambda_parameter_symbols(component);</p>
<p class="Sp-text-1"><a id="c4-para-0834"/>    <b>const</b> bfun = analyze(lambda_body(component));</p>
<p class="Sp-text-1"><a id="c4-para-0835"/>    <b>return</b> env =&gt; make_function(params, bfun, env);</p>
<p class="Sp-text-1"><a id="c4-para-0836"/>}</p>
<p><a id="c4-para-0837"/>Analysis of a sequence of statements is more involved.<a id="c4-fn-0027a"/><a href="#c4-fn-0027"><sup>27</sup></a> Each statement in the sequence is analyzed, yielding an execution function. These execution functions are combined to produce an execution function that takes an environment as argument and sequentially calls each individual execution function with the environment as argument.</p>
<p class="Sp-text-1"><a id="c4-para-0838"/><b>function</b> analyze_sequence(stmts) {</p>
<p class="Sp-text-1"><a id="c4-para-0839"/>    <b>function</b> sequentially(fun1, fun2) {</p>
<p class="Sp-text-1"><a id="c4-para-0840"/>        <b>return</b> env =&gt; {</p>
<p class="Sp-text-1"><a id="c4-para-0841"/>                   <b>const</b> fun1_val = fun1(env);</p>
<p class="Sp-text-1"><a id="c4-para-0842"/>                   <b>return</b> is_return_value(fun1_val)</p>
<p class="Sp-text-1"><a id="c4-para-0843"/>                          ? fun1_val</p>
<p class="Sp-text-1"><a id="c4-para-0844"/>                          : fun2(env);</p>
<p class="Sp-text-1"><a id="c4-para-0845"/>               };</p>
<p class="Sp-text-1"><a id="c4-para-0846"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0847"/>    <b>function</b> loop(first_fun, rest_funs) {</p>
<p class="Sp-text-1"><a id="c4-para-0848"/>        <b>return</b> is_null(rest_funs)</p>
<p class="Sp-text-1"><a id="c4-para-0849"/>               ? first_fun</p>
<p class="Sp-text-1"><a id="c4-para-0850"/>               : loop(sequentially(first_fun, head(rest_funs)),</p>
<p class="Sp-text-1"><a id="c4-para-0851"/>                      tail(rest_funs));</p>
<p class="Sp-text-1"><a id="c4-para-0852"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0853"/>    <b>const</b> funs = map(analyze, stmts);</p>
<p class="Sp-text-1"><a id="c4-para-0854"/>    <b>return</b> is_null(funs)</p>
<p class="Sp-text-1"><a id="c4-para-0855"/>           ? env =&gt; undefined</p>
<p class="Sp-text-1"><a id="c4-para-0856"/>           : loop(head(funs), tail(funs));</p>
<p class="Sp-text-1"><a id="c4-para-0857"/>}</p>
<p><a id="c4-para-0858"/>The body of a block is scanned only once for local declarations. The bindings are installed in the environment when the execution function for the block is called.</p>
<p class="Sp-text-1"><a id="c4-para-0859"/><b>function</b> analyze_block(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0860"/>    <b>const</b> body = block_body(component);</p>
<p class="Sp-text-1"><a id="c4-para-0861"/>    <b>const</b> bfun = analyze(body);</p>
<p class="Sp-text-1"><a id="c4-para-0862"/>    <b>const</b> locals = scan_out_declarations(body);</p>
<p class="Sp-text-1"><a id="c4-para-0863"/>    <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c4-para-0864"/>    <b>return</b> env =&gt; bfun(extend_environment(locals, unassigneds, env));</p>
<p class="Sp-text-1"><a id="c4-para-0865"/>}</p>
<p><a id="c4-para-0866"/>For return statements, we analyze the return expression. The execution function for the return statement simply calls the execution function for the return expression and wraps the result in a return value.</p>
<p class="Sp-text-1"><a id="c4-para-0867"/><b>function</b> analyze_return_statement(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0868"/>    <b>const</b> rfun = analyze(return_expression(component));</p>
<p class="Sp-text-1"><a id="c4-para-0869"/>    <b>return</b> env =&gt; make_return_value(rfun(env));</p>
<p class="Sp-text-1"><a id="c4-para-0870"/>}</p>
<p><a id="c4-para-0871"/>The function <span class="KeyTerm1">analyze_assignment</span> must defer actually setting the variable until the execution, when the environment has been supplied. However, the fact that the assignment-value expression can be analyzed (recursively) during analysis is a major gain in efficiency, because the assignment-value expression will now be analyzed only once. The same holds true for constant and variable declarations.</p>
<p class="Sp-text-1"><a id="c4-para-0872"/><b>function</b> analyze_assignment(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0873"/>    <b>const</b> symbol = assignment_symbol(component);</p>
<p class="Sp-text-1"><a id="c4-para-0874"/>    <b>const</b> vfun = analyze(assignment_value_expression(component));</p>
<p class="Sp-text-1"><a id="c4-para-0875"/>    <b>return</b> env =&gt; {</p>
<p class="Sp-text-1"><a id="c4-para-0876"/>               <b>const</b> value = vfun(env);</p>
<p class="Sp-text-1"><a id="c4-para-0877"/>               assign_symbol_value(symbol, value, env);</p>
<p class="Sp-text-1"><a id="c4-para-0878"/>               <b>return</b> value;</p>
<p class="Sp-text-1"><a id="c4-para-0879"/>           };</p>
<p class="Sp-text-1"><a id="c4-para-0880"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0881"/><b>function</b> analyze_declaration(component) {</p>
<p class="Sp-text-1"><a id="c4-para-0882"/>    <b>const</b> symbol = declaration_symbol(component);</p>
<p class="Sp-text-1"><a id="c4-para-0883"/>    <b>const</b> vfun = analyze(declaration_value_expression(component));</p>
<p class="Sp-text-1"><a id="c4-para-0884"/>    <b>return</b> env =&gt; {</p>
<p class="Sp-text-1"><a id="c4-para-0885"/>               assign_symbol_value(symbol, vfun(env), env);</p>
<p class="Sp-text-1"><a id="c4-para-0886"/>               <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c4-para-0887"/>           };</p>
<p class="Sp-text-1"><a id="c4-para-0888"/>}</p>
<p><a id="c4-para-0889"/>Our new evaluator uses the same data structures, syntax functions, and runtime support functions as in sections 4.1.2, 4.1.3, and 4.1.4.</p>
<section>
<h5><a id="c4-sec-0057"/><a id="c4-title-0058"/>Exercise 4.20</h5>
<p class="paraaftertitle"><a id="c4-para-0890"/>Extend the evaluator in this section to support while loops. (See exercise 4.7.)</p>
</section>
<section>
<h5><a id="c4-sec-0058"/><a id="c4-title-0059"/>Exercise 4.21</h5>
<p class="paraaftertitle"><a id="c4-para-0891"/>Alyssa P. Hacker doesn't understand why <span class="KeyTerm1">analyze_sequence</span> needs to be so complicated. All the other analysis functions are straightforward transformations of the corresponding evaluation functions (or <span class="KeyTerm1">evaluate</span> clauses) in section 4.1.1. She expected <span class="KeyTerm1">analyze_sequence</span> to look like this:</p>
<p class="Sp-text-1"><a id="c4-para-0892"/><b>function</b> analyze_sequence(stmts) {</p>
<p class="Sp-text-1"><a id="c4-para-0893"/>    <b>function</b> execute_sequence(funs, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0894"/>        <b>if</b> (is_null(funs)) {</p>
<p class="Sp-text-1"><a id="c4-para-0895"/>            <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c4-para-0896"/>        } <b>else if</b> (is_null(tail(funs))) {</p>
<p class="Sp-text-1"><a id="c4-para-0897"/>            <b>return</b> head(funs)(env);</p>
<p class="Sp-text-1"><a id="c4-para-0898"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0899"/>            <b>const</b> head_val = head(funs)(env);</p>
<p class="Sp-text-1"><a id="c4-para-0900"/>            <b>return</b> is_return_value(head_val)</p>
<p class="Sp-text-1"><a id="c4-para-0901"/>                   ? head_val</p>
<p class="Sp-text-1"><a id="c4-para-0902"/>                   : execute_sequence(tail(funs), env);</p>
<p class="Sp-text-1"><a id="c4-para-0903"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-0904"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0905"/>    <b>const</b> funs = map(analyze, stmts);</p>
<p class="Sp-text-1"><a id="c4-para-0906"/>    <b>return</b> env =&gt; execute_sequence(funs, env);</p>
<p class="Sp-text-1"><a id="c4-para-0907"/>}</p>
<p class="paracontinue"><a id="c4-para-0908"/>Eva Lu Ator explains to Alyssa that the version in the text does more of the work of evaluating a sequence at analysis time. Alyssa's sequence-execution function, rather than having the calls to the individual execution functions built in, loops through the functions in order to call them: In effect, although the individual statements in the sequence have been analyzed, the sequence itself has not been.</p>
<p><a id="c4-para-0909"/>Compare the two versions of <span class="KeyTerm1">analyze_sequence</span>. For example, consider the common case (typical of function bodies) where the sequence has just one statement. What work will the execution function produced by Alyssa's program do? What about the execution function produced by the program in the text above? How do the two versions compare for a sequence with two expressions?</p>
</section>
<section>
<h5><a id="c4-sec-0059"/><a id="c4-title-0060"/>Exercise 4.22</h5>
<p class="paraaftertitle"><a id="c4-para-0910"/>Design and carry out some experiments to compare the speed of the original metacircular evaluator with the version in this section. Use your results to estimate the fraction of time that is spent in analysis versus execution for various functions.</p>
</section>
</section>
</section>
<section>
<h2><a id="c4-sec-0060"/><span>4.2</span> <a id="c4-title-0061"/>Lazy Evaluation</h2>
<p class="paraaftertitle"><a id="c4-para-0911"/>Now that we have an evaluator expressed as a JavaScript program, we can experiment with alternative choices in language design simply by modifying the evaluator. Indeed, new languages are often invented by first writing an evaluator that embeds the new language within an existing high-level language. For example, if we wish to discuss some aspect of a proposed modification to JavaScript with another member of the JavaScript community, we can supply an evaluator that embodies the change. The recipient can then experiment with the new evaluator and send back comments as further modifications. Not only does the high-level implementation base make it easier to test and debug the evaluator; in addition, the embedding enables the designer to snarf<a id="c4-fn-0028a"/><a href="#c4-fn-0028"><sup>28</sup></a> features from the underlying language, just as our embedded JavaScript evaluator uses primitives and control structure from the underlying JavaScript. Only later (if ever) need the designer go to the trouble of building a complete implementation in a low-level language or in hardware. In this section and the next we explore some variations on JavaScript that provide significant additional expressive power.</p>
<section>
<h3><a id="c4-sec-0061"/><span>4.2.1</span> <a id="c4-title-0062"/>Normal Order and Applicative Order</h3>
<p class="paraaftertitle"><a id="c4-para-0912"/>In section 1.1, where we began our discussion of models of evaluation, we noted that JavaScript is an <i>applicative-order</i> language, namely, that all the arguments to JavaScript functions are evaluated when the function is applied. In contrast, <i>normalorder</i> languages delay evaluation of function arguments until the actual argument values are needed. Delaying evaluation of function arguments until the last possible moment (e.g., until they are required by a primitive operation) is called <i>lazy evaluation</i>.<a id="c4-fn-0029a"/><a href="#c4-fn-0029"><sup>29</sup></a> Consider the function</p>
<p class="Sp-text-1"><a id="c4-para-0913"/><b>function</b> try_me(a, b) {</p>
<p class="Sp-text-1"><a id="c4-para-0914"/>    <b>return</b> a === 0 ? 1 : b;</p>
<p class="Sp-text-1"><a id="c4-para-0915"/>}</p>
<p class="paracontinue"><a id="c4-para-0916"/>Evaluating <span class="KeyTerm1">try_me(0, head(<b>null</b>));</span> signals an error in JavaScript. With lazy evaluation, there would be no error. Evaluating the statement would return 1, because the argument <span class="KeyTerm1">head(<b>null</b>)</span> would never be evaluated.</p>
<p><a id="c4-para-0917"/>An example that exploits lazy evaluation is the declaration of a function <span class="KeyTerm1">unless</span></p>
<p class="Sp-text-1"><a id="c4-para-0918"/><b>function</b> unless(condition, usual_value, exceptional_value) {</p>
<p class="Sp-text-1"><a id="c4-para-0919"/>    <b>return</b> condition ? exceptional_value : usual_value;</p>
<p class="Sp-text-1"><a id="c4-para-0920"/>}</p>
<p class="paracontinue"><a id="c4-para-0921"/>that can be used in statements such as</p>
<p class="Sp-text-1"><a id="c4-para-0922"/>unless(is_null(xs), head(xs), display("error: xs should not be null"));</p>
<p class="paracontinue"><a id="c4-para-0923"/>This won't work in an applicative-order language because both the usual value and the exceptional value will be evaluated before <span class="KeyTerm1">unless</span> is called (compare exercise 1.6). An advantage of lazy evaluation is that some functions, such as <span class="KeyTerm1">unless</span>, can do useful computation even if evaluation of some of their arguments would produce errors or would not terminate.</p>
<p><a id="c4-para-0924"/>If the body of a function is entered before an argument has been evaluated we say that the function is <i>non-strict</i> in that argument. If the argument is evaluated before the body of the function is entered we say that the function is <i>strict</i> in that argument.<a id="c4-fn-0030a"/><a href="#c4-fn-0030"><sup>30</sup></a> In a purely applicative-order language, all functions are strict in each argument. In a purely normal-order language, all compound functions are non-strict in each argument, and primitive functions may be either strict or non-strict. There are also languages (see exercise 4.29) that give programmers detailed control over the strictness of the functions they define.</p>
<p><a id="c4-para-0925"/>A striking example of a function that can usefully be made non-strict is <span class="KeyTerm1">pair</span> (or, in general, almost any constructor for data structures). One can do useful computation, combining elements to form data structures and operating on the resulting data structures, even if the values of the elements are not known. It makes perfect sense, for instance, to compute the length of a list without knowing the values of the individual elements in the list. We will exploit this idea in section 4.2.3 to implement the streams of chapter 3 as lists formed of non-strict pairs.</p>
<section>
<h5><a id="c4-sec-0062"/><a id="c4-title-0063"/>Exercise 4.23</h5>
<p class="paraaftertitle"><a id="c4-para-0926"/>Suppose that (in ordinary applicative-order JavaScript) we define <span class="KeyTerm1">unless</span> as shown above and then define <span class="KeyTerm1">factorial</span> in terms of <span class="KeyTerm1">unless</span> as</p>
<p class="Sp-text-1"><a id="c4-para-0927"/><b>function</b> factorial(n) {</p>
<p class="Sp-text-1"><a id="c4-para-0928"/>    <b>return</b> unless(n === 1,</p>
<p class="Sp-text-1"><a id="c4-para-0929"/>                  n * factorial(n - 1),</p>
<p class="Sp-text-1"><a id="c4-para-0930"/>                  1);</p>
<p class="Sp-text-1"><a id="c4-para-0931"/>}</p>
<p class="paracontinue"><a id="c4-para-0932"/>What happens if we attempt to evaluate <span class="KeyTerm1">factorial(5)</span>? Will our functions work in a normal-order language?</p>
</section>
<section>
<h5><a id="c4-sec-0063"/><a id="c4-title-0064"/>Exercise 4.24</h5>
<p class="paraaftertitle"><a id="c4-para-0933"/>Ben Bitdiddle and Alyssa P. Hacker disagree over the importance of lazy evaluation for implementing things such as <span class="KeyTerm1">unless</span>. Ben points out that it's possible to implement <span class="KeyTerm1">unless</span> in applicative order as a syntactic form. Alyssa counters that, if one did that, <span class="KeyTerm1">unless</span> would be merely syntax, not a function that could be used in conjunction with higher-order functions. Fill in the details on both sides of the argument. Show how to implement <span class="KeyTerm1">unless</span> as a derived component (like operator combination), by catching in <span class="KeyTerm1">evaluate</span> applications whose function expression is the name <span class="KeyTerm1">unless</span>. Give an example of a situation where it might be useful to have <span class="KeyTerm1">unless</span> available as a function, rather than as a syntactic form.</p>
</section>
</section>
<section>
<h3><a id="c4-sec-0064"/><span>4.2.2</span> <a id="c4-title-0065"/>An Interpreter with Lazy Evaluation</h3>
<p class="paraaftertitle"><a id="c4-para-0934"/>In this section we will implement a normal-order language that is the same as JavaScript except that compound functions are non-strict in each argument. Primitive functions will still be strict. It is not difficult to modify the evaluator of section 4.1.1 so that the language it interprets behaves this way. Almost all the required changes center around function application.</p>
<p><a id="c4-para-0935"/>The basic idea is that, when applying a function, the interpreter must determine which arguments are to be evaluated and which are to be delayed. The delayed arguments are not evaluated; instead, they are transformed into objects called <i>thunk</i>s.<a id="c4-fn-0031a"/><a href="#c4-fn-0031"><sup>31</sup></a> The thunk must contain the information required to produce the value of the argument when it is needed, as if it had been evaluated at the time of the application. Thus, the thunk must contain the argument expression and the environment in which the function application is being evaluated.</p>
<p><a id="c4-para-0936"/>The process of evaluating the expression in a thunk is called <i>forcing</i>.<a id="c4-fn-0032a"/><a href="#c4-fn-0032"><sup>32</sup></a> In general, a thunk will be forced only when its value is needed: when it is passed to a primitive function that will use the value of the thunk; when it is the value of a predicate of a conditional; and when it is the value of a function expression that is about to be applied as a function. One design choice we have available is whether or not to <i>memoize</i> thunks, similar to the optimization for streams in section 3.5.1. With memoization, the first time a thunk is forced, it stores the value that is computed. Subsequent forcings simply return the stored value without repeating the computation. We'll make our interpreter memoize, because this is more efficient for many applications. There are tricky considerations here, however.<a id="c4-fn-0033a"/><a href="#c4-fn-0033"><sup>33</sup></a></p>
<section>
<h5><a id="c4-sec-0065"/><a id="c4-title-0066"/>Modifying the evaluator</h5>
<p class="paraaftertitle"><a id="c4-para-0937"/>The main difference between the lazy evaluator and the one in section 4.1 is in the handling of function applications in <span class="KeyTerm1">evaluate</span> and <span class="KeyTerm1">apply</span>.</p>
<p><a id="c4-para-0938"/>The <span class="KeyTerm1">is_application</span> clause of <span class="KeyTerm1">evaluate</span> becomes</p>
<p class="Sp-text-1"><a id="c4-para-0939"/>: is_application(component)</p>
<p class="Sp-text-1"><a id="c4-para-0940"/>? apply(actual_value(function_expression(component), env),</p>
<p class="Sp-text-1"><a id="c4-para-0941"/>        arg_expressions(component), env)</p>
<p class="paracontinue"><a id="c4-para-0942"/>This is almost the same as the <span class="KeyTerm1">is_application</span> clause of <span class="KeyTerm1">evaluate</span> in section 4.1.1. For lazy evaluation, however, we call <span class="KeyTerm1">apply</span> with the argument expressions, rather than the arguments produced by evaluating them. Since we will need the environment to construct thunks if the arguments are to be delayed, we must pass this as well. We still evaluate the function expression, because <span class="KeyTerm1">apply</span> needs the actual function to be applied in order to dispatch on its type (primitive versus compound) and apply it.</p>
<p><a id="c4-para-0944"/>Whenever we need the actual value of an expression, we use</p>
<p class="Sp-text-1"><a id="c4-para-0945"/><b>function</b> actual_value(exp, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0946"/>   <b>return</b> force_it(evaluate(exp, env));</p>
<p class="Sp-text-1"><a id="c4-para-0947"/>}</p>
<p class="paracontinue"><a id="c4-para-0948"/>instead of just <span class="KeyTerm1">evaluate</span>, so that if the expression's value is a thunk, it will be forced.</p>
<p><a id="c4-para-0949"/>Our new version of <span class="KeyTerm1">apply</span> is also almost the same as the version in section 4.1.1. The difference is that <span class="KeyTerm1">evaluate</span> has passed in unevaluated argument expressions: For primitive functions (which are strict), we evaluate all the arguments before applying the primitive; for compound functions (which are non-strict) we delay all the arguments before applying the function.</p>
<p class="Sp-text-1"><a id="c4-para-0950"/><b>function</b> apply(fun, args, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0951"/>    <b>if</b> (is_primitive_function(fun)) {</p>
<p class="Sp-text-1"><a id="c4-para-0952"/>        <b>return</b> apply_primitive_function(</p>
<p class="Sp-text-1"><a id="c4-para-0953"/>                   fun,</p>
<p class="Sp-text-1"><a id="c4-para-0954"/>                   list_of_arg_values(args, env));              <span class="KeyTerm2"><i>// changed</i></span></p>
<p class="Sp-text-1"><a id="c4-para-0955"/>    } <b>else if</b> (is_compound_function(fun)) {</p>
<p class="Sp-text-1"><a id="c4-para-0956"/>        <b>const</b> result = evaluate(</p>
<p class="Sp-text-1"><a id="c4-para-0957"/>                           function_body(fun),</p>
<p class="Sp-text-1"><a id="c4-para-0958"/>                           extend_environment(</p>
<p class="Sp-text-1"><a id="c4-para-0959"/>                               function_parameters(fun),</p>
<p class="Sp-text-1"><a id="c4-para-0960"/>                               list_of_delayed_args(args, env), <span class="KeyTerm2"><i>// changed</i></span></p>
<p class="Sp-text-1"><a id="c4-para-0961"/>                               function_environment(fun)));</p>
<p class="Sp-text-1"><a id="c4-para-0962"/>        <b>return</b> is_return_value(result)</p>
<p class="Sp-text-1"><a id="c4-para-0963"/>               ? return_value_content(result)</p>
<p class="Sp-text-1"><a id="c4-para-0964"/>               : undefined;</p>
<p class="Sp-text-1"><a id="c4-para-0965"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0966"/>        error(fun, "unknown function type – apply");</p>
<p class="Sp-text-1"><a id="c4-para-0967"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0968"/>}</p>
<p class="paracontinue"><a id="c4-para-0969"/>The functions that process the arguments are just like <span class="KeyTerm1">list_of_values</span> from section 4.1.1, except that <span class="KeyTerm1">list_of_delayed_args</span> delays the arguments instead of evaluating them, and <span class="KeyTerm1">list_of_arg_values</span> uses <span class="KeyTerm1">actual_value</span> instead of <span class="KeyTerm1">evaluate</span>:</p>
<p class="Sp-text-1"><a id="c4-para-0970"/><b>function</b> list_of_arg_values(exps, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0971"/>    <b>return</b> map(exp =&gt; actual_value(exp, env), exps);</p>
<p class="Sp-text-1"><a id="c4-para-0972"/>}</p>
<p class="Sp-text-1"><a id="c4-para-0973"/><b>function</b> list_of_delayed_args(exps, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0974"/>    <b>return</b> map(exp =&gt; delay_it(exp, env), exps);</p>
<p class="Sp-text-1"><a id="c4-para-0975"/>}</p>
<p><a id="c4-para-0976"/>The other place we must change the evaluator is in the handling of conditionals, where we must use <span class="KeyTerm1">actual_value</span> instead of <span class="KeyTerm1">evaluate</span> to get the value of the predicate expression before testing whether it is true or false:</p>
<p class="Sp-text-1"><a id="c4-para-0977"/><b>function</b> eval_conditional(component, env) {</p>
<p class="Sp-text-1"><a id="c4-para-0978"/>    <b>return</b> is_truthy(actual_value(conditional_predicate(component), env))</p>
<p class="Sp-text-1"><a id="c4-para-0979"/>           ? evaluate(conditional_consequent(component), env)</p>
<p class="Sp-text-1"><a id="c4-para-0980"/>           : evaluate(conditional_alternative(component), env);</p>
<p class="Sp-text-1"><a id="c4-para-0981"/>}</p>
<p><a id="c4-para-0982"/>Finally, we must change the <span class="KeyTerm1">driver_loop</span> function (from section 4.1.4) to use <span class="KeyTerm1">actual_value</span> instead of <span class="KeyTerm1">evaluate</span>, so that if a delayed value is propagated back to the read-evaluate-print loop, it will be forced before being printed. We also change the prompts to indicate that this is the lazy evaluator:</p>
<p class="Sp-text-1"><a id="c4-para-0983"/><b>const</b> input_prompt = "L-evaluate input: ";</p>
<p class="Sp-text-1"><a id="c4-para-0984"/><b>const</b> output_prompt = "L-evaluate value: ";</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-0985"/><b>function</b> driver_loop(env) {</p>
<p class="Sp-text-1"><a id="c4-para-0986"/>    <b>const</b> input = user_read(input_prompt);</p>
<p class="Sp-text-1"><a id="c4-para-0987"/>    <b>if</b> (is_null(input)) {</p>
<p class="Sp-text-1"><a id="c4-para-0988"/>        display("evaluator terminated");</p>
<p class="Sp-text-1"><a id="c4-para-0989"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-0990"/>        <b>const</b> program = parse(input);</p>
<p class="Sp-text-1"><a id="c4-para-0991"/>        <b>const</b> locals = scan_out_declarations(program);</p>
<p class="Sp-text-1"><a id="c4-para-0992"/>        <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c4-para-0993"/>        <b>const</b> program_env = extend_environment(locals, unassigneds, env);</p>
<p class="Sp-text-1"><a id="c4-para-0994"/>        <b>const</b> output = actual_value(program, program_env);</p>
<p class="Sp-text-1"><a id="c4-para-0995"/>        user_print(output_prompt, output);</p>
<p class="Sp-text-1"><a id="c4-para-0996"/>        <b>return</b> driver_loop(program_env);</p>
<p class="Sp-text-1"><a id="c4-para-0997"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-0998"/>}</p>
<p><a id="c4-para-0999"/>With these changes made, we can start the evaluator and test it. The successful evaluation of the <span class="KeyTerm1">try_me</span> expression discussed in section 4.2.1 indicates that the interpreter is performing lazy evaluation:</p>
<p class="Sp-text-1"><a id="c4-para-1000"/><b>const</b> the_global_environment = setup_environment(); driver_loop(the_global_environment);</p>
<p class="Sp-text-3"><a id="c4-para-1001"/><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1002"/><b>function</b> try_me(a, b) {</p>
<p class="Sp-text-1"><a id="c4-para-1003"/>    <b>return</b> a === 0 ? 1 : b;</p>
<p class="Sp-text-1"><a id="c4-para-1004"/>}</p>
<p class="Sp-text-3"><a id="c4-para-1005"/><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1006"/><i>undefined</i></p>
<p class="Sp-text-3"><a id="c4-para-1007"/><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1008"/>try_me(0, head(<b>null</b>));</p>
<p class="Sp-text-3"><a id="c4-para-1009"/><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1010"/><i>1</i></p>
</section>
<section>
<h5><a id="c4-sec-0066"/><a id="c4-title-0067"/>Representing thunks</h5>
<p class="paraaftertitle"><a id="c4-para-1011"/>Our evaluator must arrange to create thunks when functions are applied to arguments and to force these thunks later. A thunk must package an expression together with the environment, so that the argument can be produced later. To force the thunk, we simply extract the expression and environment from the thunk and evaluate the expression in the environment. We use <span class="KeyTerm1">actual_value</span> rather than <span class="KeyTerm1">evaluate</span> so that in case the value of the expression is itself a thunk, we will force that, and so on, until we reach something that is not a thunk:</p>
<p class="Sp-text-1"><a id="c4-para-1012"/><b>function</b> force_it(obj) {</p>
<p class="Sp-text-1"><a id="c4-para-1013"/>    <b>return</b> is_thunk(obj)</p>
<p class="Sp-text-1"><a id="c4-para-1014"/>           ? actual_value(thunk_exp(obj), thunk_env(obj))</p>
<p class="Sp-text-1"><a id="c4-para-1015"/>           : obj;</p>
<p class="Sp-text-1"><a id="c4-para-1016"/>}</p>
<p><a id="c4-para-1017"/>One easy way to package an expression with an environment is to make a list containing the expression and the environment. Thus, we create a thunk as follows:</p>
<p class="Sp-text-1"><a id="c4-para-1018"/><b>function</b> delay_it(exp, env) {</p>
<p class="Sp-text-1"><a id="c4-para-1019"/>    <b>return</b> list("thunk", exp, env);</p>
<p class="Sp-text-1"><a id="c4-para-1020"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1021"/><b>function</b> is_thunk(obj) {</p>
<p class="Sp-text-1"><a id="c4-para-1022"/>    <b>return</b> is_tagged_list(obj, "thunk");</p>
<p class="Sp-text-1"><a id="c4-para-1023"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1024"/><b>function</b> thunk_exp(thunk) { <b>return</b> head(tail(thunk)); }</p>
<p class="Sp-text-1"><a id="c4-para-1025"/><b>function</b> thunk_env(thunk) { <b>return</b> head(tail(tail(thunk))); }</p>
<p><a id="c4-para-1026"/>Actually, what we want for our interpreter is not quite this, but rather thunks that have been memoized. When a thunk is forced, we will turn it into an evaluated thunk by replacing the stored expression with its value and changing the <span class="KeyTerm1">thunk</span> tag so that it can be recognized as already evaluated.<a id="c4-fn-0034a"/><a href="#c4-fn-0034"><sup>34</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-1027"/><b>function</b> is_evaluated_thunk(obj) {</p>
<p class="Sp-text-1"><a id="c4-para-1028"/>    <b>return</b> is_tagged_list(obj, "evaluated_thunk");</p>
<p class="Sp-text-1"><a id="c4-para-1029"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1030"/><b>function</b> thunk_value(evaluated_thunk) {</p>
<p class="Sp-text-1"><a id="c4-para-1031"/>    <b>return</b> head(tail(evaluated_thunk));</p>
<p class="Sp-text-1"><a id="c4-para-1032"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1033"/><b>function</b> force_it(obj) {</p>
<p class="Sp-text-1"><a id="c4-para-1034"/>    <b>if</b> (is_thunk(obj)) {</p>
<p class="Sp-text-1"><a id="c4-para-1035"/>        <b>const</b> result = actual_value(thunk_exp(obj), thunk_env(obj));</p>
<p class="Sp-text-1"><a id="c4-para-1036"/>        set_head(obj, "evaluated_thunk");</p>
<p class="Sp-text-1"><a id="c4-para-1037"/>        set_head(tail(obj), result); <i>//</i> <span class="KeyTerm2"><i>replace exp with its value</i></span></p>
<p class="Sp-text-1"><a id="c4-para-1038"/>        set_tail(tail(obj), <b>null</b>); <i>//</i> <span class="KeyTerm2"><i>forget unneeded env</i></span></p>
<p class="Sp-text-1"><a id="c4-para-1039"/>        <b>return</b> result;</p>
<p class="Sp-text-1"><a id="c4-para-1040"/>    } <b>else if</b> (is_evaluated_thunk(obj)) {</p>
<p class="Sp-text-1"><a id="c4-para-1041"/>        <b>return</b> thunk_value(obj);</p>
<p class="Sp-text-1"><a id="c4-para-1042"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-1043"/>        <b>return</b> obj;</p>
<p class="Sp-text-1"><a id="c4-para-1044"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-1045"/>}</p>
<p class="paracontinue"><a id="c4-para-1046"/>Notice that the same <span class="KeyTerm1">delay_it</span> function works both with and without memoization.</p>
</section>
<section>
<h5><a id="c4-sec-0067"/><a id="c4-title-0068"/>Exercise 4.25</h5>
<p class="paraaftertitle"><a id="c4-para-1047"/>Suppose we type in the following declarations to the lazy evaluator:</p>
<p class="Sp-text-1"><a id="c4-para-1048"/><b>let</b> count = 0;</p>
<p class="Sp-text-1"><a id="c4-para-1049"/><b>function</b> id(x) {</p>
<p class="Sp-text-1"><a id="c4-para-1050"/>    count = count + 1;</p>
<p class="Sp-text-1"><a id="c4-para-1051"/>    <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c4-para-1052"/>}</p>
<p class="paracontinue"><a id="c4-para-1053"/>Give the missing values in the following sequence of interactions, and explain your answers.<a id="c4-fn-0035a"/><a href="#c4-fn-0035"><sup>35</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-1054"/><b>const</b> w = id(id(10));</p>
<p class="Sp-text-3"><a id="c4-para-1055"/><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1056"/>count;</p>
<p class="Sp-text-3"><a id="c4-para-1057"/><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1058"/>〈<span class="KeyTerm2"><i>response</i></span>〉</p>
<p class="Sp-text-3"><a id="c4-para-1059"/><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1060"/>w;</p>
<p class="Sp-text-3"><a id="c4-para-1061"/><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1062"/>〈<span class="KeyTerm2"><i>response</i></span>〉</p>
<p class="Sp-text-3"><a id="c4-para-1063"/><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1064"/>count;</p>
<p class="Sp-text-3"><a id="c4-para-1065"/><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1066"/>〈<span class="KeyTerm2"><i>response</i></span>〉</p>
</section>
<section>
<h5><a id="c4-sec-0068"/><a id="c4-title-0069"/>Exercise 4.26</h5>
<p class="paraaftertitle"><a id="c4-para-1067"/>The function <span class="KeyTerm1">evaluate</span> uses <span class="KeyTerm1">actual_value</span> rather than <span class="KeyTerm1">evaluate</span> to evaluate the function expression before passing it to <span class="KeyTerm1">apply</span>, in order to force the value of the function expression. Give an example that demonstrates the need for this forcing.</p>
</section>
<section>
<h5><a id="c4-sec-0069"/><a id="c4-title-0070"/>Exercise 4.27</h5>
<p class="paraaftertitle"><a id="c4-para-1068"/>Exhibit a program that you would expect to run much more slowly without memoization than with memoization. Also, consider the following interaction, where the <span class="KeyTerm1">id</span> function is defined as in exercise 4.25 and <span class="KeyTerm1">count</span> starts at 0:</p>
<p class="Sp-text-1"><a id="c4-para-1069"/><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c4-para-1070"/>    <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c4-para-1071"/>}</p>
<p class="Sp-text-3"><a id="c4-para-1072"/><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1073"/>square(id(10));</p>
<p class="Sp-text-3"><a id="c4-para-1074"/><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1075"/>〈<span class="KeyTerm2"><i>response</i></span>〉</p>
<p class="Sp-text-3"><a id="c4-para-1076"/><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1077"/>count;</p>
<p class="Sp-text-3"><a id="c4-para-1078"/><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1079"/>〈<span class="KeyTerm2"><i>response</i></span>〉</p>
<p class="paracontinue"><a id="c4-para-1080"/>Give the responses both when the evaluator memoizes and when it does not.</p>
</section>
<section>
<h5><a id="c4-sec-0070"/><a id="c4-title-0071"/>Exercise 4.28</h5>
<p class="paraaftertitle"><a id="c4-para-1081"/>Cy D. Fect, a reformed C programmer, is worried that some side effects may never take place, because the lazy evaluator doesn't force the statements in a sequence. Since the value of a statement in a sequence may not be used (the statement may be there only for its effect, such as assigning to a variable or printing), there may be no subsequent use of this value (e.g., as an argument to a primitive function) that will cause it to be forced. Cy thus thinks that when evaluating sequences, we must force all statements in the sequence. He proposes to modify <span class="KeyTerm1">evaluate_sequence</span> from section 4.1.1 to use <span class="KeyTerm1">actual_value</span> rather than <span class="KeyTerm1">evaluate</span>:</p>
<p class="Sp-text-1"><a id="c4-para-1082"/><b>function</b> eval_sequence(stmts, env) {</p>
<p class="Sp-text-1"><a id="c4-para-1083"/>    <b>if</b> (is_empty_sequence(stmts)) {</p>
<p class="Sp-text-1"><a id="c4-para-1084"/>        <b>return</b> undefined;</p>
<p class="Sp-text-1"><a id="c4-para-1085"/>    } <b>else if</b> (is_last_statement(stmts)) {</p>
<p class="Sp-text-1"><a id="c4-para-1086"/>        <b>return</b> actual_value(first_statement(stmts), env);</p>
<p class="Sp-text-1"><a id="c4-para-1087"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-1088"/>        <b>const</b> first_stmt_value =</p>
<p class="Sp-text-1"><a id="c4-para-1089"/>            actual_value(first_statement(stmts), env);</p>
<p class="Sp-text-1"><a id="c4-para-1090"/>        <b>if</b> (is_return_value(first_stmt_value)) {</p>
<p class="Sp-text-1"><a id="c4-para-1091"/>            <b>return</b> first_stmt_value;</p>
<p class="Sp-text-1"><a id="c4-para-1092"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-1093"/>            <b>return</b> eval_sequence(rest_statements(stmts), env);</p>
<p class="Sp-text-1"><a id="c4-para-1094"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-1095"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-1096"/>}</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0054"/><span>a. </span>Ben Bitdiddle thinks Cy is wrong. He shows Cy the <span class="KeyTerm1">for_each</span> function described in exercise 2.23, which gives an important example of a sequence with side effects:
<p class="Sp-text-1"><a id="c4-para-1098"/><b>function</b> for_each(fun, items) {</p>
<p class="Sp-text-1"><a id="c4-para-1099"/>    <b>if</b> (is_null(items)){</p>
<p class="Sp-text-1"><a id="c4-para-1100"/>        <b>return</b> "done";</p>
<p class="Sp-text-1"><a id="c4-para-1101"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-1102"/>        fun(head(items));</p>
<p class="Sp-text-1"><a id="c4-para-1103"/>        for_each(fun, tail(items));</p>
<p class="Sp-text-1"><a id="c4-para-1104"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-1105"/>}</p>
<p class="paracontinue"><a id="c4-para-1106"/>He claims that the evaluator in the text (with the original <span class="KeyTerm1">eval_sequence</span>) handles this correctly:</p>
<p class="Sp-text-1"><a id="c4-para-1107"/><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1108"/>for_each(display, list(57, 321, 88));</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1109"/><i>57</i></p>
<p class="Sp-text-1"><a id="c4-para-1110"/><i>321</i></p>
<p class="Sp-text-1"><a id="c4-para-1111"/><i>88</i></p>
<p class="Sp-text-1"><a id="c4-para-1112"/><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1113"/><i>"done"</i></p>
<p class="paracontinue"><a id="c4-para-1114"/>Explain why Ben is right about the behavior of <span class="KeyTerm1">for_each</span>.</p></li>
<li><a id="c4-li-0055"/><span>b. </span>Cy agrees that Ben is right about the <span class="KeyTerm1">for_each</span> example, but says that that's not the kind of program he was thinking about when he proposed his change to <span class="KeyTerm1">eval_sequence</span>. He declares the following two functions in the lazy evaluator:
<p class="Sp-text-1"><a id="c4-para-1116"/><b>function</b> f1(x) {</p>
<p class="Sp-text-1"><a id="c4-para-1117"/>    x = pair(x, list(2));</p>
<p class="Sp-text-1"><a id="c4-para-1118"/>    <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c4-para-1119"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1120"/><b>function</b> f2(x) {</p>
<p class="Sp-text-1"><a id="c4-para-1121"/>    <b>function</b> f(e) { </p>
<p class="Sp-text-1"><a id="c4-para-1122"/>        e;</p>
<p class="Sp-text-1"><a id="c4-para-1123"/>        <b>return</b> x;</p>
<p class="Sp-text-1"><a id="c4-para-1124"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-1125"/>    <b>return</b> f(x = pair(x, list(2)));</p>
<p class="Sp-text-1"><a id="c4-para-1126"/>}</p>
<p class="paracontinue"><a id="c4-para-1127"/>What are the values of <span class="KeyTerm1">f1(1)</span> and <span class="KeyTerm1">f2(1)</span> with the original <span class="KeyTerm1">eval_sequence</span>? What would the values be with Cy's proposed change to <span class="KeyTerm1">eval_sequence</span>?</p></li>
<li><a id="c4-li-0056"/><span>c. </span>Cy also points out that changing <span class="KeyTerm1">eval_sequence</span> as he proposes does not affect the behavior of the example in part a. Explain why this is true.</li>
<li><a id="c4-li-0057"/><span>d. </span>How do you think sequences ought to be treated in the lazy evaluator? Do you like Cy's approach, the approach in the text, or some other approach?</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0071"/><a id="c4-title-0072"/>Exercise 4.29</h5>
<p class="paraaftertitle"><a id="c4-para-1130"/>The approach taken in this section is somewhat unpleasant, because it makes an incompatible change to JavaScript. It might be nicer to implement lazy evaluation as an <i>upward-compatible extension</i>, that is, so that ordinary JavaScript programs will work as before. We can do this by introducing optional parameter declaration as a new syntactic form inside function declarations to let the user control whether or not arguments are to be delayed. While we're at it, we may as well also give the user the choice between delaying with and without memoization. For example, the declaration</p>
<p class="Sp-text-1"><a id="c4-para-1131"/><b>function</b> f(a, b, c, d) {</p>
<p class="Sp-text-1"><a id="c4-para-1132"/>    parameters("strict", "lazy", "strict", "lazy_memo");</p>
<p class="Sp-text-1"><a id="c4-para-1133"/>    <i>. . .</i></p>
<p class="Sp-text-1"><a id="c4-para-1134"/>}</p>
<p class="paracontinue"><a id="c4-para-1135"/>would define <span class="KeyTerm1">f</span> to be a function of four arguments, where the first and third arguments are evaluated when the function is called, the second argument is delayed, and the fourth argument is both delayed and memoized. You can assume that the parameter declaration is always the first statement in the body of a function declaration, and if it is omitted, all parameters are strict. Thus, ordinary function declaration will produce the same behavior as ordinary JavaScript, while adding the <span class="KeyTerm1">"lazy_memo"</span> declaration to each parameter of every compound function will produce the behavior of the lazy evaluator defined in this section. Design and implement the changes required to produce such an extension to JavaScript. The <span class="KeyTerm1">parse</span> function will treat parameter declarations as function applications, so you need to modify <span class="KeyTerm1">apply</span> to dispatch to your implementation of the new syntactic form. You must also arrange for <span class="KeyTerm1">evaluate</span> or <span class="KeyTerm1">apply</span> to determine when arguments are to be delayed, and to force or delay arguments accordingly, and you must arrange for forcing to memoize or not, as appropriate.</p>
</section>
</section>
<section>
<h3><a id="c4-sec-0072"/><span>4.2.3</span> <a id="c4-title-0073"/>Streams as Lazy Lists</h3>
<p class="paraaftertitle"><a id="c4-para-1136"/>In section 3.5.1, we showed how to implement streams as delayed lists. We used a lambda expression to construct a “promise” to compute the tail of a stream, without actually fulfilling that promise until later. We were forced to create streams as a new kind of data object similar but not identical to lists, and this required us to reimplement many ordinary list operations (<span class="KeyTerm1">map</span>, <span class="KeyTerm1">append</span>, and so on) for use with streams.</p>
<p><a id="c4-para-1137"/>With lazy evaluation, streams and lists can be identical, so there is no need for separate list and stream operations. All we need to do is to arrange matters so that <span class="KeyTerm1">pair</span> is non-strict. One way to accomplish this is to extend the lazy evaluator to allow for non-strict primitives, and to implement <span class="KeyTerm1">pair</span> as one of these. An easier way is to recall (section 2.1.3) that there is no fundamental need to implement <span class="KeyTerm1">pair</span> as a primitive at all. Instead, we can represent pairs as functions:<a id="c4-fn-0036a"/><a href="#c4-fn-0036"><sup>36</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-1138"/><b>function</b> pair(x, y) {</p>
<p class="Sp-text-1"><a id="c4-para-1139"/>    <b>return</b> m =&gt; m(x, y);</p>
<p class="Sp-text-1"><a id="c4-para-1140"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1141"/><b>function</b> head(z) {</p>
<p class="Sp-text-1"><a id="c4-para-1142"/>    <b>return</b> z((p, q) =&gt; p);</p>
<p class="Sp-text-1"><a id="c4-para-1143"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1144"/><b>function</b> tail(z) {</p>
<p class="Sp-text-1"><a id="c4-para-1145"/>    <b>return</b> z((p, q) =&gt; q);</p>
<p class="Sp-text-1"><a id="c4-para-1146"/>}</p>
<p><a id="c4-para-1147"/>In terms of these basic operations, the standard definitions of the list operations will work with infinite lists (streams) as well as finite ones, and the stream operations can be implemented as list operations. Here are some examples:</p>
<p class="Sp-text-1"><a id="c4-para-1148"/><b>function</b> list_ref(items, n) {</p>
<p class="Sp-text-1"><a id="c4-para-1149"/>    <b>return</b> n === 0</p>
<p class="Sp-text-1"><a id="c4-para-1150"/>           ? head(items)</p>
<p class="Sp-text-1"><a id="c4-para-1151"/>           : list_ref(tail(items), n - 1);</p>
<p class="Sp-text-1"><a id="c4-para-1152"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1153"/><b>function</b> map(fun, items) {</p>
<p class="Sp-text-1"><a id="c4-para-1154"/>    <b>return</b> is_null(items)</p>
<p class="Sp-text-1"><a id="c4-para-1155"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c4-para-1156"/>           : pair(fun(head(items)),</p>
<p class="Sp-text-1"><a id="c4-para-1157"/>                  map(fun, tail(items)));</p>
<p class="Sp-text-1"><a id="c4-para-1158"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1159"/><b>function</b> scale_list(items, factor) {</p>
<p class="Sp-text-1"><a id="c4-para-1160"/>    <b>return</b> map(x =&gt; x * factor, items);</p>
<p class="Sp-text-1"><a id="c4-para-1161"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1162"/><b>function</b> add_lists(list1, list2) {</p>
<p class="Sp-text-1"><a id="c4-para-1163"/>    <b>return</b> is_null(list1)</p>
<p class="Sp-text-1"><a id="c4-para-1164"/>           ? list2</p>
<p class="Sp-text-1"><a id="c4-para-1165"/>           : is_null(list2)</p>
<p class="Sp-text-1"><a id="c4-para-1166"/>           ? list1</p>
<p class="Sp-text-1"><a id="c4-para-1167"/>           : pair(head(list1) + head(list2),</p>
<p class="Sp-text-1"><a id="c4-para-1168"/>                  add_lists(tail(list1), tail(list2)));</p>
<p class="Sp-text-1"><a id="c4-para-1169"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1170"/><b>const</b> ones = pair(1, ones);</p>
<p class="Sp-text-1"><a id="c4-para-1171"/><b>const</b> integers = pair(1, add_lists(ones, integers));</p>
<p class="Sp-text-3"><a id="c4-para-1172"/><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1173"/>list_ref(integers, 17);</p>
<p class="Sp-text-3"><a id="c4-para-1174"/><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1175"/><i>18</i></p>
<p><a id="c4-para-1176"/>Note that these lazy lists are even lazier than the streams of chapter 3: The head of the list, as well as the tail, is delayed.<a id="c4-fn-0037a"/><a href="#c4-fn-0037"><sup>37</sup></a> In fact, even accessing the <span class="KeyTerm1">head</span> or <span class="KeyTerm1">tail</span> of a lazy pair need not force the value of a list element. The value will be forced only when it is really needed—e.g., for use as the argument of a primitive, or to be printed as an answer.</p>
<p><a id="c4-para-1177"/>Lazy pairs also help with the problem that arose with streams in section 3.5.4, where we found that formulating stream models of systems with loops may require us to sprinkle our programs with additional lambda expressions for delays, beyond the ones required to construct a stream pair. With lazy evaluation, all arguments to functions are delayed uniformly. For instance, we can implement functions to integrate lists and solve differential equations as we originally intended in section 3.5.4:</p>
<p class="Sp-text-1"><a id="c4-para-1178"/><b>function</b> integral(integrand, initial_value, dt) {</p>
<p class="Sp-text-1"><a id="c4-para-1179"/>    <b>const</b> int = pair(initial_value,</p>
<p class="Sp-text-1"><a id="c4-para-1180"/>                     add_lists(scale_list(integrand, dt),</p>
<p class="Sp-text-1"><a id="c4-para-1181"/>                               int));</p>
<p class="Sp-text-1"><a id="c4-para-1182"/>    <b>return</b> int;</p>
<p class="Sp-text-1"><a id="c4-para-1183"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1184"/><b>function</b> solve(f, y0, dt) {</p>
<p class="Sp-text-1"><a id="c4-para-1185"/>    <b>const</b> y = integral(dy, y0, dt);</p>
<p class="Sp-text-1"><a id="c4-para-1186"/>    <b>const</b> dy = map(f, y);</p>
<p class="Sp-text-1"><a id="c4-para-1187"/>    <b>return</b> y;</p>
<p class="Sp-text-1"><a id="c4-para-1188"/>}</p>
<p class="Sp-text-3"><a id="c4-para-1189"/><i>L-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1190"/>list_ref(solve(x =&gt; x, 1, 0.001), 1000);</p>
<p class="Sp-text-3"><a id="c4-para-1191"/><i>L-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1192"/><i>2.716924</i></p>
<section>
<h5><a id="c4-sec-0073"/><a id="c4-title-0074"/>Exercise 4.30</h5>
<p class="paraaftertitle"><a id="c4-para-1193"/>Give some examples that illustrate the difference between the streams of chapter 3 and the “lazier” lazy lists described in this section. How can you take advantage of this extra laziness?</p>
</section>
<section>
<h5><a id="c4-sec-0074"/><a id="c4-title-0075"/>Exercise 4.31</h5>
<p class="paraaftertitle"><a id="c4-para-1194"/>Ben Bitdiddle tests the lazy list implementation given above by evaluating the expression</p>
<p class="Sp-text-1"><a id="c4-para-1195"/>head(list("a", "b", "c"));</p>
<p class="paracontinue"><a id="c4-para-1196"/>To his surprise, this produces an error. After some thought, he realizes that the “lists” obtained from the primitive <span class="KeyTerm1">list</span> function are different from the lists manipulated by the new definitions of <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span>. Modify the evaluator such that applications of the primitive <span class="KeyTerm1">list</span> function typed at the driver loop will produce true lazy lists.</p>
</section>
<section>
<h5><a id="c4-sec-0075"/><a id="c4-title-0076"/>Exercise 4.32</h5>
<p class="paraaftertitle"><a id="c4-para-1197"/>Modify the driver loop for the evaluator so that lazy pairs and lists will print in some reasonable way. (What are you going to do about infinite lists?) You may also need to modify the representation of lazy pairs so that the evaluator can identify them in order to print them.</p>
</section>
</section>
</section>
<section>
<h2><a id="c4-sec-0076"/><span>4.3</span> <a id="c4-title-0077"/>Nondeterministic Computing</h2>
<p class="paraaftertitle"><a id="c4-para-1198"/>In this section, we extend the JavaScript evaluator to support a programming paradigm called <i>nondeterministic computing</i> by building into the evaluator a facility to support automatic search. This is a much more profound change to the language than the introduction of lazy evaluation in section 4.2.</p>
<p><a id="c4-para-1199"/>Nondeterministic computing, like stream processing, is useful for “generate and test” applications. Consider the task of starting with two lists of positive integers and finding a pair of integers—one from the first list and one from the second list—whose sum is prime. We saw how to handle this with finite sequence operations in section 2.2.3 and with infinite streams in section 3.5.3. Our approach was to generate the sequence of all possible pairs and filter these to select the pairs whose sum is prime. Whether we actually generate the entire sequence of pairs first as in chapter 2, or interleave the generating and filtering as in chapter 3, is immaterial to the essential image of how the computation is organized.</p>
<p><a id="c4-para-1200"/>The nondeterministic approach evokes a different image. Imagine simply that we choose (in some way) a number from the first list and a number from the second list and require (using some mechanism) that their sum be prime. This is expressed by the following function:</p>
<p class="Sp-text-1"><a id="c4-para-1201"/><b>function</b> prime_sum_pair(list1, list2) {</p>
<p class="Sp-text-1"><a id="c4-para-1202"/>    <b>const</b> a = an_element_of(list1);</p>
<p class="Sp-text-1"><a id="c4-para-1203"/>    <b>const</b> b = an_element_of(list2);</p>
<p class="Sp-text-1"><a id="c4-para-1204"/>    require(is_prime(a + b));</p>
<p class="Sp-text-1"><a id="c4-para-1205"/>    <b>return</b> list(a, b);</p>
<p class="Sp-text-1"><a id="c4-para-1206"/>}</p>
<p class="paracontinue"><a id="c4-para-1207"/>It might seem as if this function merely restates the problem, rather than specifying a way to solve it. Nevertheless, this is a legitimate nondeterministic program.<a id="c4-fn-0038a"/><a href="#c4-fn-0038"><sup>38</sup></a></p>
<p><a id="c4-para-1208"/>The key idea here is that components in a nondeterministic language can have more than one possible value. For instance, <span class="KeyTerm1">an_element_of</span> might return any element of the given list. Our nondeterministic program evaluator will work by automatically choosing a possible value and keeping track of the choice. If a subsequent requirement is not met, the evaluator will try a different choice, and it will keep trying new choices until the evaluation succeeds, or until we run out of choices. Just as the lazy evaluator freed the programmer from the details of how values are delayed and forced, the nondeterministic program evaluator will free the programmer from the details of how choices are made.</p>
<p><a id="c4-para-1209"/>It is instructive to contrast the different images of time evoked by nondeterministic evaluation and stream processing. Stream processing uses lazy evaluation to decouple the time when the stream of possible answers is assembled from the time when the actual stream elements are produced. The evaluator supports the illusion that all the possible answers are laid out before us in a timeless sequence. With nondeterministic evaluation, a component represents the exploration of a set of possible worlds, each determined by a set of choices. Some of the possible worlds lead to dead ends, while others have useful values. The nondeterministic program evaluator supports the illusion that time branches, and that our programs have different possible execution histories. When we reach a dead end, we can revisit a previous choice point and proceed along a different branch.</p>
<p><a id="c4-para-1210"/>The nondeterministic program evaluator implemented below is called the <span class="KeyTerm1">amb</span> evaluator because it is based on a new syntactic form called <span class="KeyTerm1">amb</span>. We can type the above declaration of <span class="KeyTerm1">prime_sum_pair</span> at the <span class="KeyTerm1">amb</span> evaluator driver loop (along with declarations of <span class="KeyTerm1">is_prime</span>, <span class="KeyTerm1">an_element_of</span>, and <span class="KeyTerm1">require</span>) and run the function as follows:</p>
<p class="Sp-text-3"><a id="c4-para-1211"/><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1212"/>prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));</p>
<p class="Sp-text-3"><a id="c4-para-1213"/><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c4-para-1214"/><i>amb-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c4-para-1215"/><i>[3, [20, null]]</i></p>
<p class="paracontinue"><a id="c4-para-1216"/>The value returned was obtained after the evaluator repeatedly chose elements from each of the lists, until a successful choice was made.</p>
<p><a id="c4-para-1217"/>Section 4.3.1 introduces <span class="KeyTerm1">amb</span> and explains how it supports nondeterminism through the evaluator's automatic search mechanism. Section 4.3.2 presents examples of nondeterministic programs, and section 4.3.3 gives the details of how to implement the <span class="KeyTerm1">amb</span> evaluator by modifying the ordinary JavaScript evaluator.</p>
<section>
<h3><a id="c4-sec-0077"/><span>4.3.1</span> <a id="c4-title-0078"/>Search and <span class="KeyTerm1">amb</span></h3>
<p class="paraaftertitle"><a id="c4-para-1218"/>To extend JavaScript to support nondeterminism, we introduce a new syntactic form called <span class="KeyTerm1">amb</span>.<a id="c4-fn-0039a"/><a href="#c4-fn-0039"><sup>39</sup></a> The expression <span class="KeyTerm1">amb(</span><i>e</i><sub>1</sub>, <i>e</i><sub>2</sub>, <span class="KeyTerm1"><i>. . .</i></span> , <i>e<sub>n</sub></i><span class="KeyTerm1">)</span> returns the value of one of the <i>n</i> expressions <i>e<sub>i</sub></i> “ambiguously.” For example, the expression</p>
<p class="Sp-text-1"><a id="c4-para-1219"/>list(amb(1, 2, 3), amb("a", "b"));</p>
<p class="paracontinue"><a id="c4-para-1220"/>can have six possible values:</p>
<p class="Sp-text-1"><a id="c4-para-1221"/>list(1, "a") list(1, "b") list(2, "a")</p>
<p class="Sp-text-1"><a id="c4-para-1222"/>list(2, "b") list(3, "a") list(3, "b")</p>
<p class="paracontinue"><a id="c4-para-1223"/>An <span class="KeyTerm1">amb</span> expression with a single choice produces an ordinary (single) value.</p>
<p><a id="c4-para-1224"/>An <span class="KeyTerm1">amb</span> expression with no choices—the expression <span class="KeyTerm1">amb()</span>—is an expression with no acceptable values. Operationally, we can think of <span class="KeyTerm1">amb()</span> as an expression that when evaluated causes the computation to “fail”: The computation aborts and no value is produced. Using this idea, we can express the requirement that a particular predicate expression <span class="KeyTerm1">p</span> must be true as follows:</p>
<p class="Sp-text-1"><a id="c4-para-1225"/><b>function</b> require(p) {</p>
<p class="Sp-text-1"><a id="c4-para-1226"/>    <b>if</b> (! p) {</p>
<p class="Sp-text-1"><a id="c4-para-1227"/>        amb();</p>
<p class="Sp-text-1"><a id="c4-para-1228"/>    } <b>else</b> {}</p>
<p class="Sp-text-1"><a id="c4-para-1229"/>}</p>
<p><a id="c4-para-1230"/>With <span class="KeyTerm1">amb</span> and <span class="KeyTerm1">require</span>, we can implement the <span class="KeyTerm1">an_element_of</span> function used above:</p>
<p class="Sp-text-1"><a id="c4-para-1231"/><b>function</b> an_element_of(items) {</p>
<p class="Sp-text-1"><a id="c4-para-1232"/>    require(! is_null(items));</p>
<p class="Sp-text-1"><a id="c4-para-1233"/>    <b>return</b> amb(head(items), an_element_of(tail(items)));</p>
<p class="Sp-text-1"><a id="c4-para-1234"/>}</p>
<p class="paracontinue"><a id="c4-para-1235"/>An application of <span class="KeyTerm1">an_element_of</span> fails if the list is empty. Otherwise it ambiguously returns either the first element of the list or an element chosen from the rest of the list.</p>
<p><a id="c4-para-1236"/>We can also express infinite ranges of choices. The following function potentially returns any integer greater than or equal to some given <i>n</i>:</p>
<p class="Sp-text-1"><a id="c4-para-1237"/><b>function</b> an_integer_starting_from(n) {</p>
<p class="Sp-text-1"><a id="c4-para-1238"/>    <b>return</b> amb(n, an_integer_starting_from(n + 1));</p>
<p class="Sp-text-1"><a id="c4-para-1239"/>}</p>
<p class="paracontinue"><a id="c4-para-1240"/>This is like the stream function <span class="KeyTerm1">integers_starting_from</span> described in section 3.5.2, but with an important difference: The stream function returns an object that represents the sequence of all integers beginning with <i>n</i>, whereas the <span class="KeyTerm1">amb</span> function returns a single integer.<a id="c4-fn-0040a"/><a href="#c4-fn-0040"><sup>40</sup></a></p>
<p><a id="c4-para-1241"/>Abstractly, we can imagine that evaluating an <span class="KeyTerm1">amb</span> expression causes time to split into branches, where the computation continues on each branch with one of the possible values of the expression. We say that <span class="KeyTerm1">amb</span> represents a <i>nondeterministic choice point</i>. If we had a machine with a sufficient number of processors that could be dynamically allocated, we could implement the search in a straightforward way. Execution would proceed as in a sequential machine, until an <span class="KeyTerm1">amb</span> expression is encountered. At this point, more processors would be allocated and initialized to continue all of the parallel executions implied by the choice. Each processor would proceed sequentially as if it were the only choice, until it either terminates by encountering a failure, or it further subdivides, or it finishes.<a id="c4-fn-0041a"/><a href="#c4-fn-0041"><sup>41</sup></a></p>
<p><a id="c4-para-1242"/>On the other hand, if we have a machine that can execute only one process (or a few concurrent processes), we must consider the alternatives sequentially. One could imagine modifying an evaluator to pick at random a branch to follow whenever it encounters a choice point. Random choice, however, can easily lead to failing values. We might try running the evaluator over and over, making random choices and hoping to find a non-failing value, but it is better to <i>systematically search</i> all possible execution paths. The <span class="KeyTerm1">amb</span> evaluator that we will develop and work with in this section implements a systematic search as follows: When the evaluator encounters an application of <span class="KeyTerm1">amb</span>, it initially selects the first alternative. This selection may itself lead to a further choice. The evaluator will always initially choose the first alternative at each choice point. If a choice results in a failure, then the evaluator automagically<a id="c4-fn-0042a"/><a href="#c4-fn-0042"><sup>42</sup></a> <i>backtracks</i> to the most recent choice point and tries the next alternative. If it runs out of alternatives at any choice point, the evaluator will back up to the previous choice point and resume from there. This process leads to a search strategy known as <i>depth-first search</i> or <i>chronological backtracking</i>.<a id="c4-fn-0043a"/><a href="#c4-fn-0043"><sup>43</sup></a></p>
<section>
<h5><a id="c4-sec-0078"/><a id="c4-title-0079"/>Driver loop</h5>
<p class="paraaftertitle"><a id="c4-para-1243"/>The driver loop for the <span class="KeyTerm1">amb</span> evaluator has some unusual properties. It reads a program and prints the value of the first non-failing execution, as in the <span class="KeyTerm1">prime_sum_pair</span> example shown above. If we want to see the value of the next successful execution, we can ask the interpreter to backtrack and attempt to generate a second non-failing execution. This is signaled by typing <span class="KeyTerm1">retry</span>. If any other input except <span class="KeyTerm1">retry</span> is given, the interpreter will start a new problem, discarding the unexplored alternatives in the previous problem. Here is a sample interaction:</p>
<p class="Sp-text-3"><a id="c4-para-1244"/><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1245"/>prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));</p>
<p class="Sp-text-3"><a id="c4-para-1246"/><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c4-para-1247"/><i>amb-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c4-para-1248"/><i>[3, [20, null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-3"><a id="c4-para-1249"/><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1250"/>retry</p>
<p class="Sp-text-3"><a id="c4-para-1251"/><i>amb-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c4-para-1252"/><i>[3, [110, null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-3"><a id="c4-para-1253"/><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1254"/>retry</p>
<p class="Sp-text-3"><a id="c4-para-1255"/><i>amb-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c4-para-1256"/><i>[8, [35, null]]</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-3"><a id="c4-para-1257"/><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1258"/>retry</p>
<p class="Sp-text-3"><a id="c4-para-1259"/><i>There are no more values of</i></p>
<p class="Sp-text-3"><a id="c4-para-1260"/><i>prime_sum_pair([1, [3, [5, [8, null]]]], [20, [35, [110, null]]])</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-3"><a id="c4-para-1261"/><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1262"/>prime_sum_pair(list(19, 27, 30), list(11, 36, 58));</p>
<p class="Sp-text-3"><a id="c4-para-1263"/><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c4-para-1264"/><i>amb-evaluate value:</i></p>
<p class="Sp-text-3"><a id="c4-para-1265"/><i>[30, [11, null]]</i></p>
</section>
<section>
<h5><a id="c4-sec-0079"/><a id="c4-title-0080"/>Exercise 4.33</h5>
<p class="paraaftertitle"><a id="c4-para-1266"/>Write a function <span class="KeyTerm1">an_integer_between</span> that returns an integer between two given bounds. This can be used to implement a function that finds Pythagorean triples, i.e., triples of integers (<i>i</i>, <i>j</i>, <i>k</i>) between the given bounds such that <i>i ≤ j</i> and <i>i</i><sup>2</sup> + <i>j</i><sup>2</sup> = <i>k</i><sup>2</sup>, as follows:</p>
<p class="Sp-text-1"><a id="c4-para-1267"/><b>function</b> a_pythogorean_triple_between(low, high) {</p>
<p class="Sp-text-1"><a id="c4-para-1268"/>    <b>const</b> i = an_integer_between(low, high);</p>
<p class="Sp-text-1"><a id="c4-para-1269"/>    <b>const</b> j = an_integer_between(i, high);</p>
<p class="Sp-text-1"><a id="c4-para-1270"/>    <b>const</b> k = an_integer_between(j, high);</p>
<p class="Sp-text-1"><a id="c4-para-1271"/>    require(i * i + j * j === k * k);</p>
<p class="Sp-text-1"><a id="c4-para-1272"/>    <b>return</b> list(i, j, k);</p>
<p class="Sp-text-1"><a id="c4-para-1273"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0080"/><a id="c4-title-0081"/>Exercise 4.34</h5>
<p class="paraaftertitle"><a id="c4-para-1274"/>Exercise 3.69 discussed how to generate the stream of <i>all</i> Pythagorean triples, with no upper bound on the size of the integers to be searched. Explain why simply replacing <span class="KeyTerm1">an_integer_between</span> by <span class="KeyTerm1">an_integer_starting_from</span> in the function in exercise 4.33 is not an adequate way to generate arbitrary Pythagorean triples. Write a function that actually will accomplish this. (That is, write a function for which repeatedly typing <span class="KeyTerm1">retry</span> would in principle eventually generate all Pythagorean triples.)</p>
</section>
<section>
<h5><a id="c4-sec-0081"/><a id="c4-title-0082"/>Exercise 4.35</h5>
<p class="paraaftertitle"><a id="c4-para-1275"/>Ben Bitdiddle claims that the following method for generating Pythagorean triples is more efficient than the one in exercise 4.33. Is he correct? (Hint: Consider the number of possibilities that must be explored.)</p>
<p class="Sp-text-1"><a id="c4-para-1276"/><b>function</b> a_pythagorean_triple_between(low, high) {</p>
<p class="Sp-text-1"><a id="c4-para-1277"/>    <b>const</b> i = an_integer_between(low, high);</p>
<p class="Sp-text-1"><a id="c4-para-1278"/>    <b>const</b> hsq = high * high;</p>
<p class="Sp-text-1"><a id="c4-para-1279"/>    <b>const</b> j = an_integer_between(i, high);</p>
<p class="Sp-text-1"><a id="c4-para-1280"/>    <b>const</b> ksq = i * i + j * j;</p>
<p class="Sp-text-1"><a id="c4-para-1281"/>    require(hsq &gt;= ksq);</p>
<p class="Sp-text-1"><a id="c4-para-1282"/>    <b>const</b> k = math_sqrt(ksq);</p>
<p class="Sp-text-1"><a id="c4-para-1283"/>    require(is_integer(k));</p>
<p class="Sp-text-1"><a id="c4-para-1284"/>    <b>return</b> list(i, j, k);</p>
<p class="Sp-text-1"><a id="c4-para-1285"/>}</p>
</section>
</section>
<section>
<h3><a id="c4-sec-0082"/><span>4.3.2</span> <a id="c4-title-0083"/>Examples of Nondeterministic Programs</h3>
<p class="paraaftertitle"><a id="c4-para-1286"/>Section 4.3.3 describes the implementation of the <span class="KeyTerm1">amb</span> evaluator. First, however, we give some examples of how it can be used. The advantage of nondeterministic programming is that we can suppress the details of how search is carried out, thereby expressing our programs at a higher level of abstraction.</p>
<section>
<h5><a id="c4-sec-0083"/><a id="c4-title-0084"/>Logic Puzzles</h5>
<p class="paraaftertitle"><a id="c4-para-1287"/>The following puzzle (adapted from Dinesman 1968) is typical of a large class of simple logic puzzles:</p>
<blockquote class="quote">
<p class="quoteparafirst"><a id="c4-para-1288"/>The software company Gargle is expanding, and Alyssa, Ben, Cy, Lem, and Louis are moving into a row of five private offices in a new building. Alyssa does not move into the last office. Ben does not move into the first office. Cy takes neither the first nor the last office. Lem moves into an office after Ben's. Louis's office is not next to Cy's. Cy's office is not next to Ben's. Who moves into which office?</p></blockquote>

<p><a id="c4-para-1289"/>We can determine who moves into which office in a straightforward way by enumerating all the possibilities and imposing the given restrictions:<a id="c4-fn-0044a"/><a href="#c4-fn-0044"><sup>44</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-1290"/><b>function</b> office_move() {</p>
<p class="Sp-text-1"><a id="c4-para-1291"/>    <b>const</b> alyssa = amb(1, 2, 3, 4, 5);</p>
<p class="Sp-text-1"><a id="c4-para-1292"/>    <b>const</b> ben = amb(1, 2, 3, 4, 5);</p>
<p class="Sp-text-1"><a id="c4-para-1293"/>    <b>const</b> cy = amb(1, 2, 3, 4, 5);</p>
<p class="Sp-text-1"><a id="c4-para-1294"/>    <b>const</b> lem = amb(1, 2, 3, 4, 5);</p>
<p class="Sp-text-1"><a id="c4-para-1295"/>    <b>const</b> louis = amb(1, 2, 3, 4, 5);</p>
<p class="Sp-text-1"><a id="c4-para-1296"/>    require(distinct(list(alyssa, ben, cy, lem, louis)));</p>
<p class="Sp-text-1"><a id="c4-para-1297"/>    require(alyssa !== 5);</p>
<p class="Sp-text-1"><a id="c4-para-1298"/>    require(ben !== 1);</p>
<p class="Sp-text-1"><a id="c4-para-1299"/>    require(cy !== 5);</p>
<p class="Sp-text-1"><a id="c4-para-1300"/>    require(cy !== 1);</p>
<p class="Sp-text-1"><a id="c4-para-1301"/>    require(lem &gt; ben);</p>
<p class="Sp-text-1"><a id="c4-para-1302"/>    require(math_abs(louis - cy) !== 1);</p>
<p class="Sp-text-1"><a id="c4-para-1303"/>    require(math_abs(cy - ben) !== 1);</p>
<p class="Sp-text-1"><a id="c4-para-1304"/>    <b>return</b> list(list("alyssa", alyssa),</p>
<p class="Sp-text-1"><a id="c4-para-1305"/>                list("ben", ben),</p>
<p class="Sp-text-1"><a id="c4-para-1306"/>                list("cy", cy),</p>
<p class="Sp-text-1"><a id="c4-para-1307"/>                list("lem", lem),</p>
<p class="Sp-text-1"><a id="c4-para-1308"/>                list("louis", louis));</p>
<p class="Sp-text-1"><a id="c4-para-1309"/>}</p>
<p><a id="c4-para-1310"/>Evaluating the expression <span class="KeyTerm1">office_move()</span> produces the result</p>
<p class="Sp-text-1"><a id="c4-para-1311"/>list(list("alyssa", 3), list("ben", 2), list("cy", 4),</p>
<p class="Sp-text-1"><a id="c4-para-1312"/>     list("lem", 5), list("louis", 1))</p>
<p class="paracontinue"><a id="c4-para-1313"/>Although this simple function works, it is very slow. Exercises 4.37 and 4.38 discuss some possible improvements.</p>
</section>
<section>
<h5><a id="c4-sec-0084"/><a id="c4-title-0085"/>Exercise 4.36</h5>
<p class="paraaftertitle"><a id="c4-para-1314"/>Modify the office-move function to omit the requirement that Louis's office is not next to Cy's. How many solutions are there to this modified puzzle?</p>
</section>
<section>
<h5><a id="c4-sec-0085"/><a id="c4-title-0086"/>Exercise 4.37</h5>
<p class="paraaftertitle"><a id="c4-para-1315"/>Does the order of the restrictions in the office-move function affect the answer? Does it affect the time to find an answer? If you think it matters, demonstrate a faster program obtained from the given one by reordering the restrictions. If you think it does not matter, argue your case.</p>
</section>
<section>
<h5><a id="c4-sec-0086"/><a id="c4-title-0087"/>Exercise 4.38</h5>
<p class="paraaftertitle"><a id="c4-para-1325"/>In the office move problem, how many sets of assignments are there of people to offices, both before and after the requirement that office assignments be distinct? It is very inefficient to generate all possible assignments of people to offices and then leave it to backtracking to eliminate them. For example, most of the restrictions depend on only one or two of the person-office names, and can thus be imposed before offices have been selected for all the people. Write and demonstrate a much more efficient nondeterministic function that solves this problem based upon generating only those possibilities that are not already ruled out by previous restrictions.</p>
</section>
<section>
<h5><a id="c4-sec-0087"/><a id="c4-title-0088"/>Exercise 4.39</h5>
<p class="paraaftertitle"><a id="c4-para-1326"/>Write an ordinary JavaScript program to solve the office move puzzle.</p>
</section>
<section>
<h5><a id="c4-sec-0088"/><a id="c4-title-0089"/>Exercise 4.40</h5>
<p class="paraaftertitle"><a id="c4-para-1327"/>Solve the following “Liars” puzzle (adapted from Phillips 1934):</p>
<blockquote class="quote">
<p class="quoteparafirst"><a id="c4-para-1328"/>Alyssa, Cy, Eva, Lem, and Louis meet for a business lunch at SoSoService. Their meals arrive one after the other, a considerable time after they placed their orders. To entertain Ben, who expects them back at the office for a meeting, they decide to each make one true statement and one false statement about their orders:</p>
<p class="quoteparafirst"><a id="c4-para-1329"/></p>
<ul style="list-style-type:disc">
<li>Alyssa: “Lem's meal arrived second. Mine arrived third.”</li>
<li>Cy: “Mine arrived first. Eva's arrived second.”</li>
<li>Eva: “Mine arrived third, and poor Cy's arrived last.”</li>
<li>Lem: “Mine arrived second. Louis's arrived fourth.”</li>
<li>Louis: “Mine arrived fourth. Alyssa's meal arrived first.”</li>
</ul>

<p class="quoteparafirst"><a id="c4-para-1335"/>What was the real order in which the five diners received their meals?</p></blockquote>
</section>
<section>
<h5><a id="c4-sec-0089"/><a id="c4-title-0090"/>Exercise 4.41</h5>
<p class="paraaftertitle"><a id="c4-para-1336"/>Use the <span class="KeyTerm1">amb</span> evaluator to solve the following puzzle (adapted from Phillips 1961):</p>
<blockquote class="quote">
<p class="quoteparafirst"><a id="c4-para-1337"/>Alyssa, Ben, Cy, Eva, and Louis each pick a different chapter of SICP JS and solve all the exercises in that chapter. Louis solves the exercises in the “Functions” chapter, Alyssa the ones in the “Data” chapter, and Cy the ones in the “State” chapter. They decide to check each other's work, and Alyssa volunteers to check the exercises in the “Meta” chapter. The exercises in the “Register Machines” chapter are solved by Ben and checked by Louis. The person who checks the exercises in the “Functions” chapter solves the exercises that are checked by Eva. Who checks the exercises in the “Data” chapter?</p></blockquote>

<p class="paracontinue"><a id="c4-para-1338"/>Try to write the program so that it runs efficiently (see exercise 4.38). Also determine how many solutions there are if we are not told that Alyssa checks the exercises in the “Meta” chapter.</p>
</section>
<section>
<h5><a id="c4-sec-0090"/><a id="c4-title-0091"/>Exercise 4.42</h5>
<p class="paraaftertitle"><a id="c4-para-1339"/>Exercise 2.42 described the “eight-queens puzzle” of placing queens on a chessboard so that no two attack each other. Write a nondeterministic program to solve this puzzle.</p>
</section>
<section>
<h5><a id="c4-sec-0091"/><a id="c4-title-0092"/>Parsing natural language</h5>
<p class="paraaftertitle"><a id="c4-para-1340"/>Programs designed to accept natural language as input usually start by attempting to <i>parse</i> the input, that is, to match the input against some grammatical structure. For example, we might try to recognize simple sentences consisting of an article followed by a noun followed by a verb, such as “The cat eats.” To accomplish such an analysis, we must be able to identify the parts of speech of individual words. We could start with some lists that classify various words:<a id="c4-fn-0045a"/><a href="#c4-fn-0045"><sup>45</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-1341"/><b>const</b> nouns = list("noun", "student", "professor", "cat", "class");</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1342"/><b>const</b> verbs = list("verb", "studies", "lectures", "eats", "sleeps");</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1343"/><b>const</b> articles = list("article", "the", "a");</p>
<p class="paracontinue"><a id="c4-para-1344"/>We also need a <i>grammar</i>, that is, a set of rules describing how grammatical elements are composed from simpler elements. A very simple grammar might stipulate that a sentence always consists of two pieces—a noun phrase followed by a verb—and that a noun phrase consists of an article followed by a noun. With this grammar, the sentence “The cat eats” is parsed as follows:</p>
<p class="Sp-text-1"><a id="c4-para-1345"/>list("sentence",</p>
<p class="Sp-text-1"><a id="c4-para-1346"/>     list("noun-phrase", list("article", "the"), list("noun", "cat"),</p>
<p class="Sp-text-1"><a id="c4-para-1347"/>     list("verb", "eats"))</p>
<p><a id="c4-para-1348"/>We can generate such a parse with a simple program that has separate functions for each of the grammatical rules. To parse a sentence, we identify its two constituent pieces and return a list of these two elements, tagged with the symbol <span class="KeyTerm1">sentence</span>:</p>
<p class="Sp-text-1"><a id="c4-para-1349"/><b>function</b> parse_sentence() {</p>
<p class="Sp-text-1"><a id="c4-para-1350"/>    <b>return</b> list("sentence",</p>
<p class="Sp-text-1"><a id="c4-para-1351"/>                parse_noun_phrase(),</p>
<p class="Sp-text-1"><a id="c4-para-1352"/>                parse_word(verbs));</p>
<p class="Sp-text-1"><a id="c4-para-1353"/>}</p>
<p class="paracontinue"><a id="c4-para-1354"/>A noun phrase, similarly, is parsed by finding an article followed by a noun:</p>
<p class="Sp-text-1"><a id="c4-para-1355"/><b>function</b> parse_noun_phrase() {</p>
<p class="Sp-text-1"><a id="c4-para-1356"/>    <b>return</b> list("noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1357"/>                parse_word(articles),</p>
<p class="Sp-text-1"><a id="c4-para-1358"/>                parse_word(nouns));</p>
<p class="Sp-text-1"><a id="c4-para-1359"/>}</p>
<p><a id="c4-para-1360"/>At the lowest level, parsing boils down to repeatedly checking that the next not-yet-parsed word is a member of the list of words for the required part of speech. To implement this, we maintain a global variable <span class="KeyTerm1">not_yet_parsed</span>, which is the input that has not yet been parsed. Each time we check a word, we require that <span class="KeyTerm1">not_yet_parsed</span> must be nonempty and that it should begin with a word from the designated list. If so, we remove that word from <span class="KeyTerm1">not_yet_parsed</span> and return the word together with its part of speech (which is found at the head of the list):<a id="c4-fn-0046a"/><a href="#c4-fn-0046"><sup>46</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-1361"/><b>function</b> parse_word(word_list) {</p>
<p class="Sp-text-1"><a id="c4-para-1362"/>    require(! is_null(not_yet_parsed));</p>
<p class="Sp-text-1"><a id="c4-para-1363"/>    require(! is_null(member(head(not_yet_parsed), tail(word_list))));</p>
<p class="Sp-text-1"><a id="c4-para-1364"/>    <b>const</b> found_word = head(not_yet_parsed);</p>
<p class="Sp-text-1"><a id="c4-para-1365"/>    not_yet_parsed = tail(not_yet_parsed);</p>
<p class="Sp-text-1"><a id="c4-para-1366"/>    <b>return</b> list(head(word_list), found_word);</p>
<p class="Sp-text-1"><a id="c4-para-1367"/>}</p>
<p><a id="c4-para-1368"/>To start the parsing, all we need to do is set <span class="KeyTerm1">not_yet_parsed</span> to be the entire input, try to parse a sentence, and check that nothing is left over:</p>
<p class="Sp-text-1"><a id="c4-para-1369"/><b>let</b> not_yet_parsed = <b>null</b>;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1370"/><b>function</b> parse_input(input) {</p>
<p class="Sp-text-1"><a id="c4-para-1371"/>    not_yet_parsed = input;</p>
<p class="Sp-text-1"><a id="c4-para-1372"/>    <b>const</b> sent = parse_sentence();</p>
<p class="Sp-text-1"><a id="c4-para-1373"/>    require(is_null(not_yet_parsed));</p>
<p class="Sp-text-1"><a id="c4-para-1374"/>    <b>return</b> sent;</p>
<p class="Sp-text-1"><a id="c4-para-1375"/>}</p>
<p><a id="c4-para-1376"/>We can now try the parser and verify that it works for our simple test sentence:</p>
<p class="Sp-text-3"><a id="c4-para-1377"/><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1378"/>parse_input(list("the",  "cat",  "eats"));</p>
<p class="Sp-text-3"><a id="c4-para-1379"/><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c4-para-1380"/><i>amb-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1381"/><i>list("sentence",</i></p>
<p class="Sp-text-1"><a id="c4-para-1382"/>      <i>list("noun-phrase", list("article", "the"), list("noun", "cat")),</i></p>
<p class="Sp-text-1"><a id="c4-para-1383"/>      <i>list("verb", "eats"))</i></p>
<p><a id="c4-para-1384"/>The <span class="KeyTerm1">amb</span> evaluator is useful here because it is convenient to express the parsing constraints with the aid of <span class="KeyTerm1">require</span>. Automatic search and backtracking really pay off, however, when we consider more complex grammars where there are choices for how the units can be decomposed.</p>
<p><a id="c4-para-1385"/>Let's add to our grammar a list of prepositions:</p>
<p class="Sp-text-1"><a id="c4-para-1386"/><b>const</b> prepositions = list("prep", "for", "to", "in", "by", "with");</p>
<p class="paracontinue"><a id="c4-para-1387"/>and define a prepositional phrase (e.g., “for the cat”) to be a preposition followed by a noun phrase:</p>
<p class="Sp-text-1"><a id="c4-para-1388"/><b>function</b> parse_prepositional_phrase() {</p>
<p class="Sp-text-1"><a id="c4-para-1389"/>    <b>return</b> list("prep-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1390"/>                parse_word(prepositions),</p>
<p class="Sp-text-1"><a id="c4-para-1391"/>                parse_noun_phrase());</p>
<p class="Sp-text-1"><a id="c4-para-1392"/>}</p>
<p class="paracontinue"><a id="c4-para-1393"/>Now we can define a sentence to be a noun phrase followed by a verb phrase, where a verb phrase can be either a verb or a verb phrase extended by a prepositional phrase:<a id="c4-fn-0047a"/><a href="#c4-fn-0047"><sup>47</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-1394"/><b>function</b> parse_sentence() {</p>
<p class="Sp-text-1"><a id="c4-para-1395"/>    <b>return</b> list("sentence",</p>
<p class="Sp-text-1"><a id="c4-para-1396"/>                parse_noun_phrase(),</p>
<p class="Sp-text-1"><a id="c4-para-1397"/>                parse_verb_phrase());</p>
<p class="Sp-text-1"><a id="c4-para-1398"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1399"/><b>function</b> parse_verb_phrase() {</p>
<p class="Sp-text-1"><a id="c4-para-1400"/>    <b>function</b> maybe_extend(verb_phrase) {</p>
<p class="Sp-text-1"><a id="c4-para-1401"/>        <b>return</b> amb(verb_phrase,</p>
<p class="Sp-text-1"><a id="c4-para-1402"/>                   maybe_extend(list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1403"/>                                     verb_phrase,</p>
<p class="Sp-text-1"><a id="c4-para-1404"/>                                     parse_prepositional_phrase())));</p>
<p class="Sp-text-1"><a id="c4-para-1405"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-1406"/>    <b>return</b> maybe_extend(parse_word(verbs));</p>
<p class="Sp-text-1"><a id="c4-para-1407"/>}</p>
<p><a id="c4-para-1408"/>While we're at it, we can also elaborate the definition of noun phrases to permit such things as “a cat in the class.” What we used to call a noun phrase, we'll now call a simple noun phrase, and a noun phrase will now be either a simple noun phrase or a noun phrase extended by a prepositional phrase:</p>
<p class="Sp-text-1"><a id="c4-para-1409"/><b>function</b> parse_simple_noun_phrase() {</p>
<p class="Sp-text-1"><a id="c4-para-1410"/>    <b>return</b> list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1411"/>                parse_word(articles),</p>
<p class="Sp-text-1"><a id="c4-para-1412"/>                parse_word(nouns));</p>
<p class="Sp-text-1"><a id="c4-para-1413"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1414"/><b>function</b> parse_noun_phrase() {</p>
<p class="Sp-text-1"><a id="c4-para-1415"/>    <b>function</b> maybe_extend(noun_phrase) {</p>
<p class="Sp-text-1"><a id="c4-para-1416"/>        <b>return</b> amb(noun_phrase,</p>
<p class="Sp-text-1"><a id="c4-para-1417"/>                   maybe_extend(list("noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1418"/>                                     noun_phrase,</p>
<p class="Sp-text-1"><a id="c4-para-1419"/>                                     parse_prepositional_phrase())));</p>
<p class="Sp-text-1"><a id="c4-para-1420"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-1421"/>    <b>return</b> maybe_extend(parse_simple_noun_phrase());</p>
<p class="Sp-text-1"><a id="c4-para-1422"/>}</p>
<p><a id="c4-para-1423"/>Our new grammar lets us parse more complex sentences. For example</p>
<p class="Sp-text-1"><a id="c4-para-1424"/>parse_input(list("the", "student", "with", "the", "cat",</p>
<p class="Sp-text-1"><a id="c4-para-1425"/>                 "sleeps", "in", "the", "class"));</p>
<p class="paracontinue"><a id="c4-para-1426"/>produces</p>
<p class="Sp-text-1"><a id="c4-para-1427"/>list("sentence",</p>
<p class="Sp-text-1"><a id="c4-para-1428"/>     list("noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1429"/>          list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1430"/>               list("article", "the"), list("noun", "student")),</p>
<p class="Sp-text-1"><a id="c4-para-1431"/>          list("prep-phrase", list("prep", "with"),</p>
<p class="Sp-text-1"><a id="c4-para-1432"/>               list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1433"/>                    list("article", "the"),</p>
<p class="Sp-text-1"><a id="c4-para-1434"/>                    list("noun", "cat")))),</p>
<p class="Sp-text-1"><a id="c4-para-1435"/>     list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1436"/>          list("verb", "sleeps"),</p>
<p class="Sp-text-1"><a id="c4-para-1437"/>          list("prep-phrase", list("prep", "in"),</p>
<p class="Sp-text-1"><a id="c4-para-1438"/>               list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1439"/>                    list("article", "the"),</p>
<p class="Sp-text-1"><a id="c4-para-1440"/>                    list("noun", "class")))))</p>
<p><a id="c4-para-1441"/>Observe that a given input may have more than one legal parse. In the sentence “The professor lectures to the student with the cat,” it may be that the professor is lecturing with the cat, or that the student has the cat. Our nondeterministic program finds both possibilities:</p>
<p class="Sp-text-1"><a id="c4-para-1442"/>parse_input(list("the", "professor", "lectures",</p>
<p class="Sp-text-1"><a id="c4-para-1443"/>                 "to", "the", "student", "with", "the", "cat"));</p>
<p class="paracontinue"><a id="c4-para-1444"/>produces</p>
<p class="Sp-text-1"><a id="c4-para-1445"/>list("sentence",</p>
<p class="Sp-text-1"><a id="c4-para-1446"/>     list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1447"/>          list("article", "the"), list("noun", "professor")),</p>
<p class="Sp-text-1"><a id="c4-para-1448"/>     list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1449"/>          list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1450"/>               list("verb", "lectures"),</p>
<p class="Sp-text-1"><a id="c4-para-1451"/>               list("prep-phrase", list("prep", "to"),</p>
<p class="Sp-text-1"><a id="c4-para-1452"/>                    list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1453"/>                    list("article", "the"),</p>
<p class="Sp-text-1"><a id="c4-para-1454"/>                    list("noun", "student")))),</p>
<p class="Sp-text-1"><a id="c4-para-1455"/>          list("prep-phrase", list("prep", "with"),</p>
<p class="Sp-text-1"><a id="c4-para-1456"/>               list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1457"/>                    list("article", "the"),</p>
<p class="Sp-text-1"><a id="c4-para-1458"/>                    list("noun", "cat")))))</p>
<p class="paracontinue"><a id="c4-para-1459"/>Asking the evaluator to retry yields</p>
<p class="Sp-text-1"><a id="c4-para-1460"/>list("sentence",</p>
<p class="Sp-text-1"><a id="c4-para-1461"/>     list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1462"/>          list("article", "the"), list("noun", "professor")),</p>
<p class="Sp-text-1"><a id="c4-para-1463"/>     list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1464"/>          list("verb", "lectures"),</p>
<p class="Sp-text-1"><a id="c4-para-1465"/>          list("prep-phrase", list("prep", "to"),</p>
<p class="Sp-text-1"><a id="c4-para-1466"/>               list("noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1467"/>                    list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1468"/>                         list("article", "the"),</p>
<p class="Sp-text-1"><a id="c4-para-1469"/>                         list("noun", "student")),</p>
<p class="Sp-text-1"><a id="c4-para-1470"/>                    list("prep-phrase", list("prep", "with"),</p>
<p class="Sp-text-1"><a id="c4-para-1471"/>                         list("simple-noun-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1472"/>                         list("article", "the"),</p>
<p class="Sp-text-1"><a id="c4-para-1473"/>                         list("noun", "cat")))))))</p>
</section>
<section>
<h5><a id="c4-sec-0092"/><a id="c4-title-0093"/>Exercise 4.43</h5>
<p class="paraaftertitle"><a id="c4-para-1474"/>With the grammar given above, the following sentence can be parsed in five different ways: “The professor lectures to the student in the class with the cat.” Give the five parses and explain the differences in shades of meaning among them.</p>
</section>
<section>
<h5><a id="c4-sec-0093"/><a id="c4-title-0094"/>Exercise 4.44</h5>
<p class="paraaftertitle"><a id="c4-para-1475"/>The evaluators in sections 4.1 and 4.2 do not determine what order argument expressions are evaluated in. We will see that the <span class="KeyTerm1">amb</span> evaluator evaluates them from left to right. Explain why our parsing program wouldn't work if the argument expressions were evaluated in some other order.</p>
</section>
<section>
<h5><a id="c4-sec-0094"/><a id="c4-title-0095"/>Exercise 4.45</h5>
<p class="paraaftertitle"><a id="c4-para-1476"/>Louis Reasoner suggests that, since a verb phrase is either a verb or a verb phrase followed by a prepositional phrase, it would be much more straightforward to declare the function <span class="KeyTerm1">parse_verb_phrase</span> as follows (and similarly for noun phrases):</p>
<p class="Sp-text-1"><a id="c4-para-1477"/><b>function</b> parse_verb_phrase() {</p>
<p class="Sp-text-1"><a id="c4-para-1478"/>    <b>return</b> amb(parse_word(verbs),</p>
<p class="Sp-text-1"><a id="c4-para-1479"/>               list("verb-phrase",</p>
<p class="Sp-text-1"><a id="c4-para-1480"/>                   parse_verb_phrase(),</p>
<p class="Sp-text-1"><a id="c4-para-1481"/>                   parse_prepositional_phrase()));</p>
<p class="Sp-text-1"><a id="c4-para-1482"/>}</p>
<p class="paracontinue"><a id="c4-para-1483"/>Does this work? Does the program's behavior change if we interchange the order of expressions in the <span class="KeyTerm1">amb</span>?</p>
</section>
<section>
<h5><a id="c4-sec-0095"/><a id="c4-title-0096"/>Exercise 4.46</h5>
<p class="paraaftertitle"><a id="c4-para-1484"/>Extend the grammar given above to handle more complex sentences. For example, you could extend noun phrases and verb phrases to include adjectives and adverbs, or you could handle compound sentences.<a id="c4-fn-0048a"/><a href="#c4-fn-0048"><sup>48</sup></a></p>
</section>
<section>
<h5><a id="c4-sec-0096"/><a id="c4-title-0097"/>Exercise 4.47</h5>
<p class="paraaftertitle"><a id="c4-para-1485"/>Alyssa P. Hacker is more interested in generating interesting sentences than in parsing them. She reasons that by simply changing the function <span class="KeyTerm1">parse_word</span> so that it ignores the “input sentence” and instead always succeeds and generates an appropriate word, we can use the programs we had built for parsing to do generation instead. Implement Alyssa's idea, and show the first half-dozen or so sentences generated.<a id="c4-fn-0049a"/><a href="#c4-fn-0049"><sup>49</sup></a></p>
</section>
</section>
<section>
<h3><a id="c4-sec-0097"/><span>4.3.3</span> <a id="c4-title-0098"/>Implementing the <span class="KeyTerm1">amb</span> Evaluator</h3>
<p class="paraaftertitle"><a id="c4-para-1486"/>The evaluation of an ordinary JavaScript program may return a value, may never terminate, or may signal an error. In nondeterministic JavaScript the evaluation of a program may in addition result in the discovery of a dead end, in which case evaluation must backtrack to a previous choice point. The interpretation of nondeterministic JavaScript is complicated by this extra case.</p>
<p><a id="c4-para-1487"/>We will construct the <span class="KeyTerm1">amb</span> evaluator for nondeterministic JavaScript by modifying the analyzing evaluator of section 4.1.7.<a id="c4-fn-0050a"/><a href="#c4-fn-0050"><sup>50</sup></a> As in the analyzing evaluator, evaluation of a component is accomplished by calling an execution function produced by analysis of that component. The difference between the interpretation of ordinary JavaScript and the interpretation of nondeterministic JavaScript will be entirely in the execution functions.</p>
<section>
<h5><a id="c4-sec-0098"/><a id="c4-title-0099"/>Execution functions and continuations</h5>
<p class="paraaftertitle"><a id="c4-para-1488"/>Recall that the execution functions for the ordinary evaluator take one argument: the environment of execution. In contrast, the execution functions in the <span class="KeyTerm1">amb</span> evaluator take three arguments: the environment, and two functions called <i>continuation functions</i>. The evaluation of a component will finish by calling one of these two continuations: If the evaluation results in a value, the <i>success continuation</i> is called with that value; if the evaluation results in the discovery of a dead end, the <i>failure continuation</i> is called. Constructing and calling appropriate continuations is the mechanism by which the nondeterministic evaluator implements backtracking.</p>
<p><a id="c4-para-1489"/>It is the job of the success continuation to receive a value and proceed with the computation. Along with that value, the success continuation is passed another failure continuation, which is to be called subsequently if the use of that value leads to a dead end.</p>
<p><a id="c4-para-1490"/>It is the job of the failure continuation to try another branch of the nondeterministic process. The essence of the nondeterministic language is in the fact that components may represent choices among alternatives. The evaluation of such a component must proceed with one of the indicated alternative choices, even though it is not known in advance which choices will lead to acceptable results. To deal with this, the evaluator picks one of the alternatives and passes this value to the success continuation. Together with this value, the evaluator constructs and passes along a failure continuation that can be called later to choose a different alternative.</p>
<p><a id="c4-para-1491"/>A failure is triggered during evaluation (that is, a failure continuation is called) when a user program explicitly rejects the current line of attack (for example, a call to <span class="KeyTerm1">require</span> may result in execution of <span class="KeyTerm1">amb()</span>, an expression that always fails—see section 4.3.1). The failure continuation in hand at that point will cause the most recent choice point to choose another alternative. If there are no more alternatives to be considered at that choice point, a failure at an earlier choice point is triggered, and so on. Failure continuations are also invoked by the driver loop in response to a <span class="KeyTerm1">retry</span> request, to find another value of the program.</p>
<p><a id="c4-para-1492"/>In addition, if a side-effect operation (such as assignment to a variable) occurs on a branch of the process resulting from a choice, it may be necessary, when the process finds a dead end, to undo the side effect before making a new choice. This is accomplished by having the side-effect operation produce a failure continuation that undoes the side effect and propagates the failure.</p>
<p><a id="c4-para-1493"/>In summary, failure continuations are constructed by</p>
<ul style="list-style-type:disc">
<li><span class="KeyTerm1">amb</span> expressions—to provide a mechanism to make alternative choices if the current choice made by the <span class="KeyTerm1">amb</span> expression leads to a dead end;</li>
<li>the top-level driver—to provide a mechanism to report failure when the choices are exhausted;</li>
<li>assignments—to intercept failures and undo assignments during backtracking. </li>
</ul>

<p><a id="c4-para-1497"/>Failures are initiated only when a dead end is encountered. This occurs</p>
<ul style="list-style-type:disc">
<li>if the user program executes <span class="KeyTerm1">amb()</span>;</li>
<li>if the user types <span class="KeyTerm1">retry</span> at the top-level driver.</li>
</ul>

<p><a id="c4-para-1500"/>Failure continuations are also called during processing of a failure:</p>
<ul style="list-style-type:disc">
<li>When the failure continuation created by an assignment finishes undoing a side effect, it calls the failure continuation it intercepted, in order to propagate the failure back to the choice point that led to this assignment or to the top level.</li>
<li>When the failure continuation for an <span class="KeyTerm1">amb</span> runs out of choices, it calls the failure continuation that was originally given to the <span class="KeyTerm1">amb</span>, in order to propagate the failure back to the previous choice point or to the top level.</li>
</ul>
</section>
<section>
<h5><a id="c4-sec-0099"/><a id="c4-title-0100"/>Structure of the evaluator</h5>
<p class="paraaftertitle"><a id="c4-para-1503"/>The syntaxand data-representation functions for the <span class="KeyTerm1">amb</span> evaluator, and also the basic <span class="KeyTerm1">analyze</span> function, are identical to those in the evaluator of section 4.1.7, except for the fact that we need additional syntax functions to recognize the <span class="KeyTerm1">amb</span> syntactic form:</p>
<p class="Sp-text-1"><a id="c4-para-1504"/><b>function</b> is_amb(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1505"/>    <b>return</b> is_tagged_list(component, "application") &amp;&amp;</p>
<p class="Sp-text-1"><a id="c4-para-1506"/>           is_name(function_expression(component)) &amp;&amp;</p>
<p class="Sp-text-1"><a id="c4-para-1507"/>           symbol_of_name(function_expression(component)) === "amb";</p>
<p class="Sp-text-1"><a id="c4-para-1508"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1509"/><b>function</b> amb_choices(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1510"/>    <b>return</b> arg_expressions(component);</p>
<p class="Sp-text-1"><a id="c4-para-1511"/>}</p>
<p class="paracontinue"><a id="c4-para-1512"/>We continue to use the parse function of section 4.1.2, which doesn't support <span class="KeyTerm1">amb</span> as a syntactic form and instead treats <span class="KeyTerm1">amb(</span><span class="KeyTerm1"><i>. . .</i></span><span class="KeyTerm1">)</span> as a function application. The function <span class="KeyTerm1">is_amb</span> ensures that whenever the name <span class="KeyTerm1">amb</span> appears as the function expression of an application, the evaluator treats the “application” as a nondeterministic choice point.<a id="c4-fn-0051a"/><a href="#c4-fn-0051"><sup>51</sup></a></p>
<p><a id="c4-para-1513"/>We must also add to the dispatch in <span class="KeyTerm1">analyze</span> a clause that will recognize such expressions and generate an appropriate execution function:</p>
<p class="Sp-text-1"><a id="c4-para-1514"/><i>. . .</i></p>
<p class="Sp-text-1"><a id="c4-para-1515"/>: is_amb(component)</p>
<p class="Sp-text-1"><a id="c4-para-1516"/>? analyze_amb(component)</p>
<p class="Sp-text-1"><a id="c4-para-1517"/>: is_application(component)</p>
<p class="Sp-text-1"><a id="c4-para-1518"/><i>. . .</i></p>
<p><a id="c4-para-1519"/>The top-level function <span class="KeyTerm1">ambeval</span> (similar to the version of <span class="KeyTerm1">evaluate</span> given in section 4.1.7) analyzes the given component and applies the resulting execution function to the given environment, together with two given continuations:</p>
<p class="Sp-text-1"><a id="c4-para-1520"/><b>function</b> ambeval(component, env, succeed, fail) {</p>
<p class="Sp-text-1"><a id="c4-para-1521"/>    <b>return</b> analyze(component)(env, succeed, fail);</p>
<p class="Sp-text-1"><a id="c4-para-1522"/>}</p>
<p><a id="c4-para-1523"/>A success continuation is a function of two arguments: the value just obtained and another failure continuation to be used if that value leads to a subsequent failure. A failure continuation is a function of no arguments. So the general form of an execution function is</p>
<p class="Sp-text-1"><a id="c4-para-1524"/>(env, succeed, fail) =&gt; {</p>
<p class="Sp-text-1"><a id="c4-para-1525"/>    <i>//</i> succeed <span class="KeyTerm2"><i>is</i></span> (value, fail) =&gt; <i>. . .</i></p>
<p class="Sp-text-1"><a id="c4-para-1526"/>    <i>//</i> fail <span class="KeyTerm2"><i>is</i></span> () =&gt; <i>. . .</i></p>
<p class="Sp-text-1"><a id="c4-para-1527"/>    <i>. . .</i></p>
<p class="Sp-text-1"><a id="c4-para-1528"/>}</p>
<p><a id="c4-para-1529"/>For example, executing</p>
<p class="Sp-text-1"><a id="c4-para-1530"/>ambeval(<span class="KeyTerm2"><i>component</i></span>,</p>
<p class="Sp-text-1"><a id="c4-para-5531"/>        the_global_environment,</p>
<p class="Sp-text-1"><a id="c4-para-5532"/>        (value, fail) =&gt; value,</p>
<p class="Sp-text-1"><a id="c4-para-5533"/>        () =&gt; "failed");</p>
<p class="paracontinue"><a id="c4-para-1532"/>will attempt to evaluate the given component and will return either the component's value (if the evaluation succeeds) or the string <span class="KeyTerm1">"failed"</span> (if the evaluation fails). The call to <span class="KeyTerm1">ambeval</span> in the driver loop shown below uses much more complicated continuation functions, which continue the loop and support the <span class="KeyTerm1">retry</span> request.</p>
<p><a id="c4-para-1533"/>Most of the complexity of the <span class="KeyTerm1">amb</span> evaluator results from the mechanics of passing the continuations around as the execution functions call each other. In going through the following code, you should compare each of the execution functions with the corresponding function for the ordinary evaluator given in section 4.1.7.</p>
</section>
<section>
<h5><a id="c4-sec-0100"/><a id="c4-title-0101"/>Simple expressions</h5>
<p class="paraaftertitle"><a id="c4-para-1534"/>The execution functions for the simplest kinds of expressions are essentially the same as those for the ordinary evaluator, except for the need to manage the continuations. The execution functions simply succeed with the value of the expression, passing along the failure continuation that was passed to them.</p>
<p class="Sp-text-1"><a id="c4-para-1535"/><b>function</b> analyze_literal(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1536"/>    <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1537"/>             succeed(literal_value(component), fail);</p>
<p class="Sp-text-1"><a id="c4-para-1538"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1539"/><b>function</b> analyze_name(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1540"/>    <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1541"/>             succeed(lookup_symbol_value(symbol_of_name(component),</p>
<p class="Sp-text-1"><a id="c4-para-1542"/>                                         env),</p>
<p class="Sp-text-1"><a id="c4-para-1543"/>                    fail);</p>
<p class="Sp-text-1"><a id="c4-para-1544"/>}</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1545"/><b>function</b> analyze_lambda_expression(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1546"/>    <b>const</b> params = lambda_parameter_symbols(component);</p>
<p class="Sp-text-1"><a id="c4-para-1547"/>    <b>const</b> bfun = analyze(lambda_body(component));</p>
<p class="Sp-text-1"><a id="c4-para-1548"/>    <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1549"/>             succeed(make_function(params, bfun, env),</p>
<p class="Sp-text-1"><a id="c4-para-1550"/>                     fail);</p>
<p class="Sp-text-1"><a id="c4-para-1551"/>}</p>
<p><a id="c4-para-1552"/>Notice that looking up a name always “succeeds.” If <span class="KeyTerm1">lookup_symbol_value</span> fails to find the name, it signals an error, as usual. Such a “failure” indicates a program bug—a reference to an unbound name; it is not an indication that we should try another nondeterministic choice instead of the one that is currently being tried.</p>
</section>
<section>
<h5><a id="c4-sec-0101"/><a id="c4-title-0102"/>Conditionals and sequences</h5>
<p class="paraaftertitle"><a id="c4-para-1553"/>Conditionals are also handled in a similar way as in the ordinary evaluator. The execution function generated by <span class="KeyTerm1">analyze_conditional</span> invokes the predicate execution function pfun with a success continuation that checks whether the predicate value is true and goes on to execute either the consequent or the alternative. If the execution of pfun fails, the original failure continuation for the conditional expression is called.</p>
<p class="Sp-text-1"><a id="c4-para-1554"/><b>function</b> analyze_conditional(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1555"/>    <b>const</b> pfun = analyze(conditional_predicate(component));</p>
<p class="Sp-text-1"><a id="c4-para-1556"/>    <b>const</b> cfun = analyze(conditional_consequent(component));</p>
<p class="Sp-text-1"><a id="c4-para-1557"/>    <b>const</b> afun = analyze(conditional_alternative(component));</p>
<p class="Sp-text-1"><a id="c4-para-1558"/>    <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1559"/>             pfun(env,</p>
<p class="Sp-text-1"><a id="c4-para-1560"/>                  <i>//</i> <span class="KeyTerm2"><i>success continuation for evaluating the predicate</i></span></p>
<p class="Sp-text-1"><a id="c4-para-1561"/>                  <i>//</i> <span class="KeyTerm2"><i>to obtain</i></span> pred_value (pred_value, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1562"/>                    is_truthy(pred_value)</p>
<p class="Sp-text-1"><a id="c4-para-1563"/>                    ? cfun(env, succeed, fail2)</p>
<p class="Sp-text-1"><a id="c4-para-1564"/>                    : afun(env, succeed, fail2),</p>
<p class="Sp-text-1"><a id="c4-para-1565"/>                  <i>//</i> <span class="KeyTerm2"><i>failure continuation for evaluating the predicate</i></span></p>
<p class="Sp-text-1"><a id="c4-para-1566"/>                  fail);</p>
<p class="Sp-text-1"><a id="c4-para-1567"/>}</p>
<p><a id="c4-para-1568"/>Sequences are also handled in the same way as in the previous evaluator, except for the machinations in the subfunction <span class="KeyTerm1">sequentially</span> that are required for passing the continuations. Namely, to sequentially execute <span class="KeyTerm1">a</span> and then <span class="KeyTerm1">b</span>, we call <span class="KeyTerm1">a</span> with a success continuation that calls <span class="KeyTerm1">b</span>.</p>
<p class="Sp-text-1"><a id="c4-para-1569"/><b>function</b> analyze_sequence(stmts) {</p>
<p class="Sp-text-1"><a id="c4-para-1570"/>    <b>function</b> sequentially(a, b) {</p>
<p class="Sp-text-1"><a id="c4-para-1571"/>        <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1572"/>                 a(env,</p>
<p class="Sp-text-1"><a id="c4-para-1573"/>                   <i>//</i> <span class="KeyTerm2"><i>success continuation for calling</i></span> a</p>
<p class="Sp-text-1"><a id="c4-para-1574"/>                   (a_value, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1575"/>                     is_return_value(a_value)</p>
<p class="Sp-text-1"><a id="c4-para-1576"/>                     ? succeed(a_value, fail2)</p>
<p class="Sp-text-1"><a id="c4-para-1577"/>                     : b(env, succeed, fail2),</p>
<p class="Sp-text-1"><a id="c4-para-1578"/>                   <i>//</i> <span class="KeyTerm2"><i>failure continuation for calling</i></span></p>
<p class="Sp-text-1"><a id="c4-para-1579"/>                   a fail);</p>
<p class="Sp-text-1"><a id="c4-para-1580"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-1581"/>    <b>function</b> loop(first_fun, rest_funs) {</p>
<p class="Sp-text-1"><a id="c4-para-1582"/>        <b>return</b> is_null(rest_funs)</p>
<p class="Sp-text-1"><a id="c4-para-1583"/>               ? first_fun</p>
<p class="Sp-text-1"><a id="c4-para-1584"/>               : loop(sequentially(first_fun, head(rest_funs)),</p>
<p class="Sp-text-1"><a id="c4-para-1585"/>                      tail(rest_funs));</p>
<p class="Sp-text-1"><a id="c4-para-1586"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-1587"/>    <b>const</b> funs = map(analyze, stmts);</p>
<p class="Sp-text-1"><a id="c4-para-1588"/>    <b>return</b> is_null(funs)</p>
<p class="Sp-text-1"><a id="c4-para-1589"/>           ? env =&gt; undefined</p>
<p class="Sp-text-1"><a id="c4-para-1590"/>           : loop(head(funs), tail(funs));</p>
<p class="Sp-text-1"><a id="c4-para-1591"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0102"/><a id="c4-title-0103"/>Declarations and assignments</h5>
<p class="paraaftertitle"><a id="c4-para-1592"/>Declarations are another case where we must go to some trouble to manage the continuations, because it is necessary to evaluate the declaration-value expression before actually declaring the new name. To accomplish this, the declaration-value execution function <span class="KeyTerm1">vfun</span> is called with the environment, a success continuation, and the failure continuation. If the execution of <span class="KeyTerm1">vfun</span> succeeds, obtaining a value <span class="KeyTerm1">val</span> for the declared name, the name is declared and the success is propagated:</p>
<p class="Sp-text-1"><a id="c4-para-1593"/><b>function</b> analyze_declaration(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1594"/>    <b>const</b> symbol = declaration_symbol(component);</p>
<p class="Sp-text-1"><a id="c4-para-1595"/>    <b>const</b> vfun = analyze(declaration_value_expression(component));</p>
<p class="Sp-text-1"><a id="c4-para-1596"/>    <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1597"/>             vfun(env,</p>
<p class="Sp-text-1"><a id="c4-para-1598"/>                  (val, fail2) =&gt; {</p>
<p class="Sp-text-1"><a id="c4-para-1599"/>                      assign_symbol_value(symbol, val, env);</p>
<p class="Sp-text-1"><a id="c4-para-1600"/>                      <b>return</b> succeed(undefined, fail2);</p>
<p class="Sp-text-1"><a id="c4-para-1601"/>                  },</p>
<p class="Sp-text-1"><a id="c4-para-1602"/>                  fail);</p>
<p class="Sp-text-1"><a id="c4-para-1603"/>}</p>
<p><a id="c4-para-1604"/>Assignments are more interesting. This is the first place where we really use the continuations, rather than just passing them around. The execution function for assignments starts out like the one for declarations. It first attempts to obtain the new value to be assigned to the name. If this evaluation of <span class="KeyTerm1">vfun</span> fails, the assignment fails.</p>
<p><a id="c4-para-1605"/>If <span class="KeyTerm1">vfun</span> succeeds, however, and we go on to make the assignment, we must consider the possibility that this branch of the computation might later fail, which will require us to backtrack out of the assignment. Thus, we must arrange to undo the assignment as part of the backtracking process.<a id="c4-fn-0052a"/><a href="#c4-fn-0052"><sup>52</sup></a></p>
<p><a id="c4-para-1606"/>This is accomplished by giving <span class="KeyTerm1">vfun</span> a success continuation (marked with the comment “*1*” below) that saves the old value of the variable before assigning the new value to the variable and proceeding from the assignment. The failure continuation that is passed along with the value of the assignment (marked with the comment “*2*” below) restores the old value of the variable before continuing the failure. That is, a successful assignment provides a failure continuation that will intercept a subsequent failure; whatever failure would otherwise have called <span class="KeyTerm1">fail2</span> calls this function instead, to undo the assignment before actually calling <span class="KeyTerm1">fail2</span>.</p>
<p class="Sp-text-1"><a id="c4-para-1607"/><b>function</b> analyze_assignment(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1608"/>    <b>const</b> symbol = assignment_symbol(component);</p>
<p class="Sp-text-1"><a id="c4-para-1609"/>    <b>const</b> vfun = analyze(assignment_value_expression(component));</p>
<p class="Sp-text-1"><a id="c4-para-1610"/>    <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1611"/>             vfun(env,</p>
<p class="Sp-text-1"><a id="c4-para-1612"/>                  (val, fail2) =&gt; { <i>//</i> *<i>1</i>*</p>
<p class="Sp-text-1"><a id="c4-para-1613"/>                      <b>const</b> old_value = lookup_symbol_value(symbol,</p>
<p class="Sp-text-1"><a id="c4-para-1614"/>                                                            env);</p>
<p class="Sp-text-1"><a id="c4-para-1615"/>                      assign_symbol_value(symbol, val, env);</p>
<p class="Sp-text-1"><a id="c4-para-1616"/>                      <b>return</b> succeed(val,</p>
<p class="Sp-text-1"><a id="c4-para-1617"/>                                     () =&gt; { <i>//</i> *<i>2</i>*</p>
<p class="Sp-text-1"><a id="c4-para-1618"/>                                         assign_symbol_value(symbol,</p>
<p class="Sp-text-1"><a id="c4-para-1619"/>                                                             old_value,</p>
<p class="Sp-text-1"><a id="c4-para-1620"/>                                                             env);</p>
<p class="Sp-text-1"><a id="c4-para-1621"/>                                         <b>return</b> fail2();</p>
<p class="Sp-text-1"><a id="c4-para-1622"/>                                     });</p>
<p class="Sp-text-1"><a id="c4-para-1623"/>                  },</p>
<p class="Sp-text-1"><a id="c4-para-1624"/>                  fail);</p>
<p class="Sp-text-1"><a id="c4-para-1625"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0103"/><a id="c4-title-0104"/>Return statements and blocks</h5>
<p class="paraaftertitle"><a id="c4-para-1626"/>Analyzing return statements is straightforward. The return expression is analyzed to produce an execution function. The execution function for the return statement calls that execution function with a success continuation that wraps the return value in a return value object and passes it to the original success continuation.</p>
<p class="Sp-text-1"><a id="c4-para-1627"/><b>function</b> analyze_return_statement(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1628"/>    <b>const</b> rfun = analyze(return_expression(component));</p>
<p class="Sp-text-1"><a id="c4-para-1629"/>    <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1630"/>             rfun(env,</p>
<p class="Sp-text-1"><a id="c4-para-1631"/>                  (val, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1632"/>                    succeed(make_return_value(val), fail2),</p>
<p class="Sp-text-1"><a id="c4-para-1633"/>                  fail);</p>
<p class="Sp-text-1"><a id="c4-para-1634"/>}</p>
<p><a id="c4-para-1635"/>The execution function for blocks calls the body's execution function on an extended environment, without changing success or failure continuations.</p>
<p class="Sp-text-1"><a id="c4-para-1636"/><b>function</b> analyze_block(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1637"/>    <b>const</b> body = block_body(component);</p>
<p class="Sp-text-1"><a id="c4-para-1638"/>    <b>const</b> locals = scan_out_declarations(body);</p>
<p class="Sp-text-1"><a id="c4-para-1639"/>    <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c4-para-1640"/>    <b>const</b> bfun = analyze(body);</p>
<p class="Sp-text-1"><a id="c4-para-1641"/>    <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1642"/>             bfun(extend_environment(locals, unassigneds, env),</p>
<p class="Sp-text-1"><a id="c4-para-1643"/>                  succeed,</p>
<p class="Sp-text-1"><a id="c4-para-1644"/>                  fail);</p>
<p class="Sp-text-1"><a id="c4-para-1645"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0104"/><a id="c4-title-0105"/>Function applications</h5>
<p class="paraaftertitle"><a id="c4-para-1646"/>The execution function for applications contains no new ideas except for the technical complexity of managing the continuations. This complexity arises in <span class="KeyTerm1">analyze_ application</span>, due to the need to keep track of the success and failure continuations as we evaluate the argument expressions. We use a function <span class="KeyTerm1">get_args</span> to evaluate the list of argument expressions, rather than a simple <span class="KeyTerm1">map</span> as in the ordinary evaluator.</p>
<p class="Sp-text-1"><a id="c4-para-1647"/><b>function</b> analyze_application(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1648"/>    <b>const</b> ffun = analyze(function_expression(component));</p>
<p class="Sp-text-1"><a id="c4-para-1649"/>    <b>const</b> afuns = map(analyze, arg_expressions(component));</p>
<p class="Sp-text-1"><a id="c4-para-1650"/>    <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1651"/>             ffun(env,</p>
<p class="Sp-text-1"><a id="c4-para-1652"/>                  (fun, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1653"/>                    get_args(afuns,</p>
<p class="Sp-text-1"><a id="c4-para-1654"/>                             env,</p>
<p class="Sp-text-1"><a id="c4-para-1655"/>                             (args, fail3) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1656"/>                               execute_application(fun,</p>
<p class="Sp-text-1"><a id="c4-para-1657"/>                                                   args,</p>
<p class="Sp-text-1"><a id="c4-para-1658"/>                                                   succeed,</p>
<p class="Sp-text-1"><a id="c4-para-1659"/>                                                   fail3),</p>
<p class="Sp-text-1"><a id="c4-para-1660"/>                             fail2),</p>
<p class="Sp-text-1"><a id="c4-para-1661"/>                  fail);</p>
<p class="Sp-text-1"><a id="c4-para-1662"/>}</p>
<p><a id="c4-para-1663"/>In <span class="KeyTerm1">get_args</span>, notice how walking down the list of <span class="KeyTerm1">afun</span> execution functions and constructing the resulting list of <span class="KeyTerm1">args</span> is accomplished by calling each <span class="KeyTerm1">afun</span> in the list with a success continuation that recursively calls <span class="KeyTerm1">get_args</span>. Each of these recursive calls to <span class="KeyTerm1">get_args</span> has a success continuation whose value is the new list resulting from using <span class="KeyTerm1">pair</span> to adjoin the newly obtained argument to the list of accumulated arguments:</p>
<p class="Sp-text-1"><a id="c4-para-1664"/><b>function</b> get_args(afuns, env, succeed, fail) {</p>
<p class="Sp-text-1"><a id="c4-para-1665"/>    <b>return</b> is_null(afuns)</p>
<p class="Sp-text-1"><a id="c4-para-1666"/>           ? succeed(<b>null</b>, fail)</p>
<p class="Sp-text-1"><a id="c4-para-1667"/>           : head(afuns)(env,</p>
<p class="Sp-text-1"><a id="c4-para-1668"/>                         <i>//</i> <span class="KeyTerm2"><i>success continuation for this</i></span> afun</p>
<p class="Sp-text-1"><a id="c4-para-1669"/>                         (arg, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1670"/>                           get_args(tail(afuns),</p>
<p class="Sp-text-1"><a id="c4-para-1671"/>                                    env,</p>
<p class="Sp-text-1"><a id="c4-para-1672"/>                                    <i>//</i> <span class="KeyTerm2"><i>success continuation for</i></span></p>
<p class="Sp-text-1"><a id="c4-para-1673"/>                                    <i>//</i> <span class="KeyTerm2"><i>recursive call to</i></span> get_args</p>
<p class="Sp-text-1"><a id="c4-para-1674"/>                                    (args, fail3) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1675"/>                                      succeed(pair(arg, args),</p>
<p class="Sp-text-1"><a id="c4-para-1676"/>                                              fail3),</p>
<p class="Sp-text-1"><a id="c4-para-1677"/>                                    fail2),</p>
<p class="Sp-text-1"><a id="c4-para-1678"/>                         fail);</p>
<p class="Sp-text-1"><a id="c4-para-1679"/>}</p>
<p><a id="c4-para-1680"/>The actual function application, which is performed by <span class="KeyTerm1">execute_application</span>, is accomplished in the same way as for the ordinary evaluator, except for the need to manage the continuations.</p>
<p class="Sp-text-1"><a id="c4-para-1681"/><b>function</b> execute_application(fun, args, succeed, fail) {</p>
<p class="Sp-text-1"><a id="c4-para-1682"/>    <b>return</b> is_primitive_function(fun)</p>
<p class="Sp-text-1"><a id="c4-para-1683"/>           ? succeed(apply_primitive_function(fun, args),</p>
<p class="Sp-text-1"><a id="c4-para-1684"/>                     fail)</p>
<p class="Sp-text-1"><a id="c4-para-1685"/>           : is_compound_function(fun)</p>
<p class="Sp-text-1"><a id="c4-para-1686"/>           ? function_body(fun)(</p>
<p class="Sp-text-1"><a id="c4-para-1687"/>                 extend_environment(function_parameters(fun),</p>
<p class="Sp-text-1"><a id="c4-para-1688"/>                                    args,</p>
<p class="Sp-text-1"><a id="c4-para-1689"/>                                    function_environment(fun)),</p>
<p class="Sp-text-1"><a id="c4-para-1690"/>                 (body_result, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1691"/>                   succeed(is_return_value(body_result)</p>
<p class="Sp-text-1"><a id="c4-para-1692"/>                           ? return_value_content(body_result)</p>
<p class="Sp-text-1"><a id="c4-para-1693"/>                           : undefined,</p>
<p class="Sp-text-1"><a id="c4-para-1694"/>                           fail2),</p>
<p class="Sp-text-1"><a id="c4-para-1695"/>                 fail)</p>
<p class="Sp-text-1"><a id="c4-para-1696"/>           : error(fun, "unknown function type - execute_application");</p>
<p class="Sp-text-1"><a id="c4-para-1697"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0105"/><a id="c4-title-0106"/>Evaluating <span class="KeyTerm1"><b>amb</b></span> expressions</h5>
<p class="paraaftertitle"><a id="c4-para-1698"/>The <span class="KeyTerm1">amb</span> syntactic form is the key element in the nondeterministic language. Here we see the essence of the interpretation process and the reason for keeping track of the continuations. The execution function for <span class="KeyTerm1">amb</span> defines a loop <span class="KeyTerm1">try_next</span> that cycles through the execution functions for all the possible values of the <span class="KeyTerm1">amb</span> expression. Each execution function is called with a failure continuation that will try the next one. When there are no more alternatives to try, the entire <span class="KeyTerm1">amb</span> expression fails.</p>
<p class="Sp-text-1"><a id="c4-para-1699"/><b>function</b> analyze_amb(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1700"/>    <b>const</b> cfuns = map(analyze, amb_choices(component));</p>
<p class="Sp-text-1"><a id="c4-para-1701"/>    <b>return</b> (env, succeed, fail) =&gt; {</p>
<p class="Sp-text-1"><a id="c4-para-1702"/>               <b>function</b> try_next(choices) {</p>
<p class="Sp-text-1"><a id="c4-para-1703"/>                   <b>return</b> is_null(choices)</p>
<p class="Sp-text-1"><a id="c4-para-1704"/>                          ? fail()</p>
<p class="Sp-text-1"><a id="c4-para-1705"/>                          : head(choices)(env,</p>
<p class="Sp-text-1"><a id="c4-para-1706"/>                                          succeed,</p>
<p class="Sp-text-1"><a id="c4-para-1707"/>                                          () =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1708"/>                                            try_next(tail(choices)));</p>
<p class="Sp-text-1"><a id="c4-para-1709"/>               }</p>
<p class="Sp-text-1"><a id="c4-para-1710"/>               <b>return</b> try_next(cfuns);</p>
<p class="Sp-text-1"><a id="c4-para-1711"/>           };</p>
<p class="Sp-text-1"><a id="c4-para-1712"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0106"/><a id="c4-title-0107"/>Driver loop</h5>
<p class="paraaftertitle"><a id="c4-para-1713"/>The driver loop for the <span class="KeyTerm1">amb</span> evaluator is complex, due to the mechanism that permits the user to retry in evaluating a program. The driver uses a function called <span class="KeyTerm1">internal_loop</span>, which takes as argument a function <span class="KeyTerm1">retry</span>. The intent is that calling <span class="KeyTerm1">retry</span> should go on to the next untried alternative in the nondeterministic evaluation. The function <span class="KeyTerm1">internal_loop</span> either calls <span class="KeyTerm1">retry</span> in response to the user typing <span class="KeyTerm1">retry</span> at the driver loop, or else starts a new evaluation by calling <span class="KeyTerm1">ambeval</span>.</p>
<p><a id="c4-para-1714"/>The failure continuation for this call to <span class="KeyTerm1">ambeval</span> informs the user that there are no more values and reinvokes the driver loop.</p>
<p><a id="c4-para-1715"/>The success continuation for the call to <span class="KeyTerm1">ambeval</span> is more subtle. We print the obtained value and then reinvoke the internal loop with a <span class="KeyTerm1">retry</span> function that will be able to try the next alternative. This <span class="KeyTerm1">next_alternative</span> function is the second argument that was passed to the success continuation. Ordinarily, we think of this second argument as a failure continuation to be used if the current evaluation branch later fails. In this case, however, we have completed a successful evaluation, so we can invoke the “failure” alternative branch in order to search for additional successful evaluations.</p>
<p class="Sp-text-1"><a id="c4-para-1716"/><b>const</b> input_prompt = "amb-evaluate input:";</p>
<p class="Sp-text-1"><a id="c4-para-1717"/><b>const</b> output_prompt = "amb-evaluate value:";</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1718"/><b>function</b> driver_loop(env) {</p>
<p class="Sp-text-1"><a id="c4-para-1719"/>    <b>function</b> internal_loop(retry) {</p>
<p class="Sp-text-1"><a id="c4-para-1720"/>        <b>const</b> input = user_read(input_prompt);</p>
<p class="Sp-text-1"><a id="c4-para-1721"/>        <b>if</b> (is_null(input)) {</p>
<p class="Sp-text-1"><a id="c4-para-1722"/>            display("evaluator terminated");</p>
<p class="Sp-text-1"><a id="c4-para-1723"/>        } <b>else if</b> (input === "retry") {</p>
<p class="Sp-text-1"><a id="c4-para-1724"/>            <b>return</b> retry();</p>
<p class="Sp-text-1"><a id="c4-para-1725"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-1726"/>            display("Starting a new problem");</p>
<p class="Sp-text-1"><a id="c4-para-1727"/>            <b>const</b> program = parse(input);</p>
<p class="Sp-text-1"><a id="c4-para-1728"/>            <b>const</b> locals = scan_out_declarations(program);</p>
<p class="Sp-text-1"><a id="c4-para-1729"/>            <b>const</b> unassigneds = list_of_unassigned(locals);</p>
<p class="Sp-text-1"><a id="c4-para-1730"/>            <b>const</b> program_env = extend_environment(</p>
<p class="Sp-text-1"><a id="c4-para-1731"/>                                     locals, unassigneds, env);</p>
<p class="Sp-text-1"><a id="c4-para-1732"/>            <b>return</b> ambeval(</p>
<p class="Sp-text-1"><a id="c4-para-1733"/>                       program,</p>
<p class="Sp-text-1"><a id="c4-para-1734"/>                       program_env,</p>
<p class="Sp-text-1"><a id="c4-para-1735"/>                       <i>//</i> <span class="KeyTerm2"><i>ambeval success</i></span></p>
<p class="Sp-text-1"><a id="c4-para-1736"/>                       (val, next_alternative) =&gt; {</p>
<p class="Sp-text-1"><a id="c4-para-1737"/>                           user_print(output_prompt, val);</p>
<p class="Sp-text-1"><a id="c4-para-1738"/>                           <b>return</b> internal_loop(next_alternative);</p>
<p class="Sp-text-1"><a id="c4-para-1739"/>                       },</p>
<p class="Sp-text-1"><a id="c4-para-1740"/>                       <i>//</i> <span class="KeyTerm2"><i>ambeval failure</i></span></p>
<p class="Sp-text-1"><a id="c4-para-1741"/>                       () =&gt; {</p>
<p class="Sp-text-1"><a id="c4-para-1742"/>                           display("There are no more values of");</p>
<p class="Sp-text-1"><a id="c4-para-1743"/>                           display(input);</p>
<p class="Sp-text-1"><a id="c4-para-1744"/>                           <b>return</b> driver_loop(program_env);</p>
<p class="Sp-text-1"><a id="c4-para-1745"/>                       });</p>
<p class="Sp-text-1"><a id="c4-para-1746"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-1747"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-1748"/>    <b>return</b> internal_loop(() =&gt; {</p>
<p class="Sp-text-1"><a id="c4-para-1749"/>                             display("There is no current problem");</p>
<p class="Sp-text-1"><a id="c4-para-1750"/>                             <b>return</b> driver_loop(env);</p>
<p class="Sp-text-1"><a id="c4-para-1751"/>                         });</p>
<p class="Sp-text-1"><a id="c4-para-1752"/>}</p>
<p class="paracontinue"><a id="c4-para-1753"/>The initial call to <span class="KeyTerm1">internal_loop</span> uses a <span class="KeyTerm1">retry</span> function that complains that there is no current problem and restarts the driver loop. This is the behavior that will happen if the user types <span class="KeyTerm1">retry</span> when there is no evaluation in progress.</p>
<p><a id="c4-para-1754"/>We start the driver loop as usual, by setting up the global environment and passing it as the enclosing environment for the first iteration of <span class="KeyTerm1">driver_loop</span>.</p>
<p class="Sp-text-1"><a id="c4-para-1755"/><b>const</b> the_global_environment = setup_environment();</p>
<p class="Sp-text-1"><a id="c4-para-1756"/>driver_loop(the_global_environment);</p>
</section>
<section>
<h5><a id="c4-sec-0107"/><a id="c4-title-0108"/>Exercise 4.48</h5>
<p class="paraaftertitle"><a id="c4-para-1757"/>Implement a new syntactic form <span class="KeyTerm1">ramb</span> that is like <span class="KeyTerm1">amb</span> except that it searches alternatives in a random order, rather than from left to right. Show how this can help with Alyssa's problem in exercise 4.47.</p>
</section>
<section>
<h5><a id="c4-sec-0108"/><a id="c4-title-0109"/>Exercise 4.49</h5>
<p class="paraaftertitle"><a id="c4-para-1758"/>Change the implementation of assignment so that it is not undone upon failure. For example, we can choose two distinct elements from a list and count the number of trials required to make a successful choice as follows:</p>
<p class="Sp-text-1"><a id="c4-para-1759"/><b>let</b> count = 0;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1760"/><b>let</b> x = an_element_of("a", "b", "c");</p>
<p class="Sp-text-1"><a id="c4-para-1761"/><b>let</b> y = an_element_of("a", "b", "c"); count = count + 1;</p>
<p class="Sp-text-1"><a id="c4-para-1762"/>require(x !== y); list(x, y, count);</p>
<p class="Sp-text-1"><a id="c4-para-1763"/><i>Starting a new problem</i></p>
<p class="Sp-text-1"><a id="c4-para-1764"/><i>amb-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1765"/><i>["a", ["b", [2, null]]]</i></p>
<p class="Sp-text-3"><a id="c4-para-1766"/><i>amb-evaluate input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1767"/>retry</p>
<p class="Sp-text-3"><a id="c4-para-1768"/><i>amb-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1769"/><i>["a", ["c", [3, null]]]</i></p>
<p class="paracontinue"><a id="c4-para-1770"/>What values would have been displayed if we had used the original meaning of assignment rather than permanent assignment?</p>
</section>
<section>
<h5><a id="c4-sec-0109"/><a id="c4-title-0110"/>Exercise 4.50</h5>
<p class="paraaftertitle"><a id="c4-para-1771"/>We shall horribly abuse the syntax for conditional statements, by implementing a construct of the following form:</p>
<p class="Sp-text-1"><a id="c4-para-1772"/><b>if</b> (evaluation_succeeds_take) { <span class="KeyTerm2"><i>statement</i></span> } <b>else</b> { <span class="KeyTerm2"><i>alternative</i></span> }</p>
<p class="paracontinue"><a id="c4-para-1773"/>The construct permits the user to catch the failure of a statement. It evaluates the statement as usual and returns as usual if the evaluation succeeds. If the evaluation fails, however, the given alternative statement is evaluated, as in the following example:</p>
<p class="Sp-text-3"><a id="c4-para-1774"/>amb-evaluate input:</p>
<p class="Sp-text-1"><a id="c4-para-1775"/><b>if</b> (evaluation_succeeds_take) {</p>
<p class="Sp-text-1"><a id="c4-para-1776"/>    <b>const</b> x = an_element_of(list(1, 3, 5));</p>
<p class="Sp-text-1"><a id="c4-para-1777"/>    require(is_even(x));</p>
<p class="Sp-text-1"><a id="c4-para-1778"/>    x;</p>
<p class="Sp-text-1"><a id="c4-para-1779"/>} <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-1780"/>    "all odd";</p>
<p class="Sp-text-1"><a id="c4-para-1781"/>}</p>
<p class="Sp-text-3"><a id="c4-para-1782"/><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c4-para-1783"/><i>amb-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1784"/><i>"all odd"</i></p>
<p class="Sp-text-3"><a id="c4-para-1785"/>amb-evaluate input:</p>
<p class="Sp-text-1"><a id="c4-para-1786"/><b>if</b> (evaluation_succeeds_take) {</p>
<p class="Sp-text-1"><a id="c4-para-1787"/>    <b>const</b> x = an_element_of(list(1, 3, 5, 8));</p>
<p class="Sp-text-1"><a id="c4-para-1788"/>    require(is_even(x));</p>
<p class="Sp-text-1"><a id="c4-para-1789"/>    x;</p>
<p class="Sp-text-1"><a id="c4-para-1790"/>} <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-1791"/>    "all odd";</p>
<p class="Sp-text-1"><a id="c4-para-1792"/>}</p>
<p class="Sp-text-3"><a id="c4-para-1793"/><i>Starting a new problem</i></p>
<p class="Sp-text-3"><a id="c4-para-1794"/><i>amb-evaluate value:</i></p>
<p class="Sp-text-1"><a id="c4-para-1795"/><i>8</i></p>
<p class="paracontinue"><a id="c4-para-1796"/>Implement this construct by extending the <span class="KeyTerm1">amb</span> evaluator. Hint: The function <span class="KeyTerm1">is_amb</span> shows how to abuse the existing JavaScript syntax in order to implement a new syntactic form.</p>
</section>
<section>
<h5><a id="c4-sec-0110"/><a id="c4-title-0111"/>Exercise 4.51</h5>
<p class="paraaftertitle"><a id="c4-para-1797"/>With the new kind of assignment as described in exercise 4.49 and the construct</p>
<p class="Sp-text-1"><a id="c4-para-1798"/><b>if</b> (evaluation_succeeds_take) { <i>. . .</i> } <b>else</b> { <i>. . .</i> }</p>
<p class="paracontinue"><a id="c4-para-1799"/>as in exercise 4.50, what will be the result of evaluating</p>
<p class="Sp-text-1"><a id="c4-para-1800"/><b>let</b> pairs = <b>null</b>;</p>
<p class="Sp-text-1"><a id="c4-para-1801"/><b>if</b> (evaluation_succeeds_take) {</p>
<p class="Sp-text-1"><a id="c4-para-1802"/>    <b>const</b> p = prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));</p>
<p class="Sp-text-1"><a id="c4-para-1803"/>    pairs = pair(p, pairs); <i>//</i> <span class="KeyTerm2"><i>using permanent assignment</i></span></p>
<p class="Sp-text-1"><a id="c4-para-1804"/>    amb();</p>
<p class="Sp-text-1"><a id="c4-para-1805"/>} <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-1806"/>    pairs;</p>
<p class="Sp-text-1"><a id="c4-para-1807"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0111"/><a id="c4-title-0112"/>Exercise 4.52</h5>
<p class="paraaftertitle"><a id="c4-para-1808"/>If we had not realized that <span class="KeyTerm1">require</span> could be implemented as an ordinary function that uses <span class="KeyTerm1">amb</span>, to be defined by the user as part of a nondeterministic program, we would have had to implement it as a syntactic form. This would require syntax functions</p>
<p class="Sp-text-1"><a id="c4-para-1809"/><b>function</b> is_require(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1810"/>    <b>return</b> is_tagged_list(component, "require");</p>
<p class="Sp-text-1"><a id="c4-para-1811"/>}</p>
<p class="Sp-text-1"><a id="c4-para-1812"/><b>function</b> require_predicate(component) { <b>return</b> head(tail(component)); }</p>
<p class="paracontinue"><a id="c4-para-1813"/>and a new clause in the dispatch in <span class="KeyTerm1">analyze</span></p>
<p class="Sp-text-1"><a id="c4-para-1814"/>: is_require(component)</p>
<p class="Sp-text-1"><a id="c4-para-1815"/>? analyze_require(component)</p>
<p class="paracontinue"><a id="c4-para-1816"/>as well the function <span class="KeyTerm1">analyze_require</span> that handles <span class="KeyTerm1">require</span> expressions. Complete the following definition of <span class="KeyTerm1">analyze_require</span>.</p>
<p class="Sp-text-1"><a id="c4-para-1817"/><b>function</b> analyze_require(component) {</p>
<p class="Sp-text-1"><a id="c4-para-1818"/>    <b>const</b> pfun = analyze(require_predicate(component));</p>
<p class="Sp-text-1"><a id="c4-para-1819"/>    <b>return</b> (env, succeed, fail) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1820"/>            pfun(env,</p>
<p class="Sp-text-1"><a id="c4-para-1821"/>                 (pred_value, fail2) =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-1822"/>                   〈??〉</p>
<p class="Sp-text-1"><a id="c4-para-1823"/>                   ? 〈??〉</p>
<p class="Sp-text-1"><a id="c4-para-1824"/>                   : succeed("ok", fail2),</p>
<p class="Sp-text-1"><a id="c4-para-1825"/>                 fail);</p>
<p class="Sp-text-1"><a id="c4-para-1826"/>}</p>
</section>
</section>
</section>
<section>
<h2><a id="c4-sec-0112"/><span>4.4</span> <a id="c4-title-0113"/>Logic Programming</h2>
<p class="paraaftertitle"><a id="c4-para-1827"/>In chapter 1 we stressed that computer science deals with imperative (how to) knowledge, whereas mathematics deals with declarative (what is) knowledge. Indeed, programming languages require that the programmer express knowledge in a form that indicates the step-by-step methods for solving particular problems. On the other hand, high-level languages provide, as part of the language implementation, a substantial amount of methodological knowledge that frees the user from concern with numerous details of how a specified computation will progress.</p>
<p><a id="c4-para-1828"/>Most programming languages, including JavaScript, are organized around computing the values of mathematical functions. Expression-oriented languages (such as Lisp, C, Python, and JavaScript) capitalize on the “pun” that an expression that describes the value of a function may also be interpreted as a means of computing that value. Because of this, most programming languages are strongly biased toward unidirectional computations (computations with well-defined inputs and outputs). There are, however, radically different programming languages that relax this bias. We saw one such example in section 3.3.5, where the objects of computation were arithmetic constraints. In a constraint system the direction and the order of computation are not so well specified; in carrying out a computation the system must therefore provide more detailed “how to” knowledge than would be the case with an ordinary arithmetic computation. This does not mean, however, that the user is released altogether from the responsibility of providing imperative knowledge. There are many constraint networks that implement the same set of constraints, and the user must choose from the set of mathematically equivalent networks a suitable network to specify a particular computation.</p>
<p><a id="c4-para-1829"/>The nondeterministic program evaluator of section 4.3 also moves away from the view that programming is about constructing algorithms for computing unidirectional functions. In a nondeterministic language, expressions can have more than one value, and, as a result, the computation is dealing with relations rather than with single-valued functions. Logic programming extends this idea by combining a relational vision of programming with a powerful kind of symbolic pattern matching called <i>unification</i>.<a id="c4-fn-0053a"/><a href="#c4-fn-0053"><sup>53</sup></a></p>
<p><a id="c4-para-1830"/>This approach, when it works, can be a very powerful way to write programs. Part of the power comes from the fact that a single “what is” fact can be used to solve a number of different problems that would have different “how to” components. As an example, consider the <span class="KeyTerm1">append</span> operation, which takes two lists as arguments and combines their elements to form a single list. In a procedural language such as JavaScript, we could define <span class="KeyTerm1">append</span> in terms of the basic list constructor <span class="KeyTerm1">pair</span>, as we did in section 2.2.1:</p>
<p class="Sp-text-1"><a id="c4-para-1831"/><b>function</b> append(x, y) {</p>
<p class="Sp-text-1"><a id="c4-para-1832"/>    <b>return</b> is_null(x)</p>
<p class="Sp-text-1"><a id="c4-para-1833"/>           ? y</p>
<p class="Sp-text-1"><a id="c4-para-1834"/>           : pair(head(x), append(tail(x), y));</p>
<p class="Sp-text-1"><a id="c4-para-1835"/>}</p>
<p class="paracontinue"><a id="c4-para-1836"/>This function can be regarded as a translation into JavaScript of the following two rules, the first of which covers the case where the first list is empty and the second of which handles the case of a nonempty list, which is a <span class="KeyTerm1">pair</span> of two parts:</p>
<ul style="list-style-type:disc">
<li>For any list <span class="KeyTerm1">y</span>, the empty list and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">y</span>.</li>
<li>For any <span class="KeyTerm1">u</span>, <span class="KeyTerm1">v</span>, <span class="KeyTerm1">y</span>, and <span class="KeyTerm1">z</span>, <span class="KeyTerm1">pair(u, v)</span> and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">pair(u, z)</span> if <span class="KeyTerm1">v</span> and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">z</span>.<a id="c4-fn-0054a"/><a href="#c4-fn-0054"><sup>54</sup></a></li>
</ul>

<p class="paracontinue"><a id="c4-para-1839"/>Using the <span class="KeyTerm1">append</span> function, we can answer questions such as</p>
<p><a id="c4-para-5839"/>Find the <span class="KeyTerm1">append</span> of <span class="KeyTerm1">list("a", "b")</span> and <span class="KeyTerm1">list("c", "d")</span>.</p>
<p class="paracontinue"><a id="c4-para-1840"/>But the same two rules are also sufficient for answering the following sorts of questions, which the function can't answer:</p>
<p><a id="c4-para-1841"/>Find a list <span class="KeyTerm1">y</span> that <span class="KeyTerm1">append</span>s with <span class="KeyTerm1">list("a", "b")</span> to produce</p>
<p class="Sp-text-1"><a id="c4-para-1842"/>    list("a", "b", "c", "d").</p>
<p><a id="c4-para-1843"/>Find all <span class="KeyTerm1">x</span> and <span class="KeyTerm1">y</span> that <span class="KeyTerm1">append</span> to form <span class="KeyTerm1">list("a", "b", "c", "d")</span>.</p>
<p class="paracontinue"><a id="c4-para-1844"/>In a logic programming language, the programmer writes an <span class="KeyTerm1">append</span> “function” by stating the two rules about <span class="KeyTerm1">append</span> given above. “How to” knowledge is provided automatically by the interpreter to allow this single pair of rules to be used to answer all three types of questions about <span class="KeyTerm1">append</span>.<a id="c4-fn-0055a"/><a href="#c4-fn-0055"><sup>55</sup></a></p>
<p><a id="c4-para-1845"/>Contemporary logic programming languages (including the one we implement here) have substantial deficiencies, in that their general “how to” methods can lead them into spurious infinite loops or other undesirable behavior. Logic programming is an active field of research in computer science.<a id="c4-fn-0056a"/><a href="#c4-fn-0056"><sup>56</sup></a></p>
<p><a id="c4-para-1846"/>Earlier in this chapter we explored the technology of implementing interpreters and described the elements that are essential to an interpreter for a JavaScript-like language (indeed, to an interpreter for any conventional language). Now we will apply these ideas to discuss an interpreter for a logic programming language. We call this language the <i>query language</i>, because it is very useful for retrieving information from data bases by formulating <i>queries</i>, or questions, expressed in the language. Even though the query language is very different from JavaScript, we will find it convenient to describe the language in terms of the same general framework we have been using all along: as a collection of primitive elements, together with means of combination that enable us to combine simple elements to create more complex elements and means of abstraction that enable us to regard complex elements as single conceptual units. An interpreter for a logic programming language is considerably more complex than an interpreter for a language like JavaScript. Nevertheless, we will see that our query-language interpreter contains many of the same elements found in the interpreter of section 4.1. In particular, there will be an “evaluate” part that classifies expressions according to type and an “apply” part that implements the language's abstraction mechanism (functions in the case of JavaScript, and <i>rules</i> in the case of logic programming). Also, a central role is played in the implementation by a frame data structure, which determines the correspondence between symbols and their associated values. One additional interesting aspect of our query-language implementation is that we make substantial use of streams, which were introduced in chapter 3.</p>
<section>
<h3><a id="c4-sec-0113"/><span>4.4.1</span> <a id="c4-title-0114"/>Deductive Information Retrieval</h3>
<p class="paraaftertitle"><a id="c4-para-1847"/>Logic programming excels in providing interfaces to data bases for information retrieval. The query language we shall implement in this chapter is designed to be used in this way.</p>
<p><a id="c4-para-1848"/>In order to illustrate what the query system does, we will show how it can be used to manage the data base of personnel records for Gargle, a thriving high-technology company in the Boston area. The language provides pattern-directed access to personnel information and can also take advantage of general rules in order to make logical deductions.</p>
<section>
<h5><a id="c4-sec-0114"/><a id="c4-title-0115"/>A sample data base</h5>
<p class="paraaftertitle"><a id="c4-para-1849"/>The personnel data base for Gargle contains <i>assertions</i> about company personnel. Here is the information about Ben Bitdiddle, the resident computer wizard:</p>
<p class="Sp-text-1"><a id="c4-para-1850"/>address(list("Bitdiddle", "Ben"),</p>
<p class="Sp-text-1"><a id="c4-para-1851"/>        list("Slumerville", list("Ridge", "Road"), 10))</p>
<p class="Sp-text-1"><a id="c4-para-1852"/>job(list("Bitdiddle", "Ben"), list("computer", "wizard"))</p>
<p class="Sp-text-1"><a id="c4-para-1853"/>salary(list("Bitdiddle", "Ben"), 122000)</p>
<p class="paracontinue"><a id="c4-para-1854"/>Assertions look just like function applications in JavaScript, but they actually represent information in the data base. The first symbols—here <span class="KeyTerm1">address</span>, <span class="KeyTerm1">job</span> and <span class="KeyTerm1">salary</span>—describe the <i>kind of information</i> contained in the respective assertion, and the “arguments” are lists or primitive values such as strings and numbers. The first symbols do not need to be declared, as do constants or variables in JavaScript; their scope is global.</p>
<p><a id="c4-para-1855"/>As resident wizard, Ben is in charge of the company's computer division, and he supervises two programmers and one technician. Here is the information about them:</p>
<p class="Sp-text-1"><a id="c4-para-1856"/>address(list("Hacker", "Alyssa", "P"),</p>
<p class="Sp-text-1"><a id="c4-para-1857"/>        list("Cambridge", list("Mass", "Ave"), 78))</p>
<p class="Sp-text-1"><a id="c4-para-1858"/>job(list("Hacker", "Alyssa", "P"), list("computer", "programmer"))</p>
<p class="Sp-text-1"><a id="c4-para-1859"/>salary(list("Hacker", "Alyssa", "P"), 81000)</p>
<p class="Sp-text-1"><a id="c4-para-1860"/>supervisor(list("Hacker", "Alyssa", "P"), list("Bitdiddle", "Ben"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1861"/>address(list("Fect", "Cy", "D"),</p>
<p class="Sp-text-1"><a id="c4-para-1862"/>        list("Cambridge", list("Ames", "Street"), 3))</p>
<p class="Sp-text-1"><a id="c4-para-1863"/>job(list("Fect", "Cy", "D"), list("computer", "programmer"))</p>
<p class="Sp-text-1"><a id="c4-para-1864"/>salary(list("Fect", "Cy", "D"), 70000)</p>
<p class="Sp-text-1"><a id="c4-para-1865"/>supervisor(list("Fect", "Cy", "D"), list("Bitdiddle", "Ben"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1866"/>address(list("Tweakit", "Lem", "E"),</p>
<p class="Sp-text-1"><a id="c4-para-1867"/>        list("Boston", list("Bay", "State", "Road"), 22))</p>
<p class="Sp-text-1"><a id="c4-para-1868"/>job(list("Tweakit", "Lem", "E"), list("computer", "technician"))</p>
<p class="Sp-text-1"><a id="c4-para-1869"/>salary(list("Tweakit", "Lem", "E"), 51000)</p>
<p class="Sp-text-1"><a id="c4-para-1870"/>supervisor(list("Tweakit", "Lem", "E"), list("Bitdiddle", "Ben"))</p>
<p class="paracontinue"><a id="c4-para-1871"/>There is also a programmer trainee, who is supervised by Alyssa:</p>
<p class="Sp-text-1"><a id="c4-para-1872"/>address(list("Reasoner", "Louis"),</p>
<p class="Sp-text-1"><a id="c4-para-1873"/>        list("Slumerville", list("Pine", "Tree", "Road"), 80))</p>
<p class="Sp-text-1"><a id="c4-para-1874"/>job(list("Reasoner", "Louis"),</p>
<p class="Sp-text-1"><a id="c4-para-1875"/>        list("computer", "programmer", "trainee"))</p>
<p class="Sp-text-1"><a id="c4-para-1876"/>salary(list("Reasoner", "Louis"), 62000)</p>
<p class="Sp-text-1"><a id="c4-para-1877"/>supervisor(list("Reasoner", "Louis"), list("Hacker", "Alyssa", "P"))</p>
<p class="paracontinue"><a id="c4-para-1878"/>All these people are in the computer division, as indicated by the word <span class="KeyTerm1">"computer"</span> as the first item in their job descriptions.</p>
<p><a id="c4-para-1879"/>Ben is a high-level employee. His supervisor is the company's big wheel himself:</p>
<p class="Sp-text-1"><a id="c4-para-1880"/>supervisor(list("Bitdiddle", "Ben"), list("Warbucks", "Oliver"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1881"/>address(list("Warbucks", "Oliver"),</p>
<p class="Sp-text-1"><a id="c4-para-1882"/>        list("Swellesley", list("Top", "Heap", "Road")))</p>
<p class="Sp-text-1"><a id="c4-para-1883"/>job(list("Warbucks", "Oliver"), list("administration", "big", "wheel"))</p>
<p class="Sp-text-1"><a id="c4-para-1884"/>salary(list("Warbucks", "Oliver"), 314159)</p>
<p><a id="c4-para-1885"/>Besides the computer division supervised by Ben, the company has an accounting division, consisting of a chief accountant and his assistant:</p>
<p class="Sp-text-1"><a id="c4-para-1886"/>address(list("Scrooge", "Eben"),</p>
<p class="Sp-text-1"><a id="c4-para-1887"/>        list("Weston", list("Shady", "Lane"), 10))</p>
<p class="Sp-text-1"><a id="c4-para-1888"/>job(list("Scrooge", "Eben"), list("accounting", "chief", "accountant"))</p>
<p class="Sp-text-1"><a id="c4-para-1889"/>salary(list("Scrooge", "Eben"), 141421)</p>
<p class="Sp-text-1"><a id="c4-para-1890"/>supervisor(list("Scrooge", "Eben"), list("Warbucks", "Oliver"))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1891"/>address(list("Cratchit", "Robert"),</p>
<p class="Sp-text-1"><a id="c4-para-1892"/>        list("Allston", list("N", "Harvard", "Street"), 16))</p>
<p class="Sp-text-1"><a id="c4-para-1893"/>job(list("Cratchit", "Robert"), list("accounting", "scrivener"))</p>
<p class="Sp-text-1"><a id="c4-para-1894"/>salary(list("Cratchit", "Robert"), 26100)</p>
<p class="Sp-text-1"><a id="c4-para-1895"/>supervisor(list("Cratchit", "Robert"), list("Scrooge", "Eben"))</p>
<p class="paracontinue"><a id="c4-para-1896"/>There is also an administrative assistant for the big wheel:</p>
<p class="Sp-text-1"><a id="c4-para-1897"/>address(list("Aull", "DeWitt"),</p>
<p class="Sp-text-1"><a id="c4-para-1898"/>        list("Slumerville", list("Onion", "Square"), 5))</p>
<p class="Sp-text-1"><a id="c4-para-1899"/>job(list("Aull", "DeWitt"), list("administration", "assistant"))</p>
<p class="Sp-text-1"><a id="c4-para-1900"/>salary(list("Aull", "DeWitt"), 42195)</p>
<p class="Sp-text-1"><a id="c4-para-1901"/>supervisor(list("Aull", "DeWitt"), list("Warbucks", "Oliver"))</p>
<p><a id="c4-para-1902"/>The data base also contains assertions about which kinds of jobs can be done by people holding other kinds of jobs. For instance, a computer wizard can do the jobs of both a computer programmer and a computer technician:</p>
<p class="Sp-text-1"><a id="c4-para-1903"/>can_do_job(list("computer", "wizard"),</p>
<p class="Sp-text-1"><a id="c4-para-1904"/>           list("computer", "programmer"))</p>
<p class="Sp-text-1"><a id="c4-para-1905"/>can_do_job(list("computer", "wizard"),</p>
<p class="Sp-text-1"><a id="c4-para-1906"/>           list("computer", "technician"))</p>
<p class="paracontinue"><a id="c4-para-1907"/>A computer programmer could fill in for a trainee:</p>
<p class="Sp-text-1"><a id="c4-para-1908"/>can_do_job(list("computer", "programmer"),</p>
<p class="Sp-text-1"><a id="c4-para-1909"/>           list("computer", "programmer", "trainee"))</p>
<p class="paracontinue"><a id="c4-para-1910"/>Also, as is well known,</p>
<p class="Sp-text-1"><a id="c4-para-1911"/>can_do_job(list("administration", "assistant"),</p>
<p class="Sp-text-1"><a id="c4-para-1912"/>           list("administration", "big", "wheel"))</p>
</section>
<section>
<h5><a id="c4-sec-0115"/><a id="c4-title-0116"/>Simple queries</h5>
<p class="paraaftertitle"><a id="c4-para-1913"/>The query language allows users to retrieve information from the data base by posing queries in response to the system's prompt. For example, to find all computer programmers one can say</p>
<p class="Sp-text-3"><a id="c4-para-1914"/><i>Query input:</i></p>
<p class="Sp-text-1"><a id="c4-para-1915"/>job($x, list("computer", "programmer"))</p>
<p class="paracontinue"><a id="c4-para-1916"/>The system will respond with the following items:</p>
<p class="Sp-text-3"><a id="c4-para-1917"/><i>Query results:</i></p>
<p class="Sp-text-3"><a id="c4-para-1918"/><i>job(list("Hacker", "Alyssa", "P"), list("computer", "programmer"))</i></p>
<p class="Sp-text-3"><a id="c4-para-1919"/><i>job(list("Fect", "Cy", "D"), list("computer", "programmer"))</i></p>
<p><a id="c4-para-1920"/>The input query specifies that we are looking for entries in the data base that match a certain <i>pattern</i>. In this example, the pattern specifies <span class="KeyTerm1">job</span> as the kind of information that we are looking for. The first item can be anything, and the second is the literal list <span class="KeyTerm1">list("computer", "programmer")</span>. The “anything” that can be the first item in the matching assertion is specified by a <i>pattern variable</i>, <span class="KeyTerm1">$x</span>. As pattern variables, we use JavaScript names that start with a dollar sign. We will see below why it is useful to specify names for pattern variables rather than just putting a single symbol such as <span class="KeyTerm1">$</span> into patterns to represent “anything.” The system responds to a simple query by showing all entries in the data base that match the specified pattern.</p>
<p><a id="c4-para-1921"/>A pattern can have more than one variable. For example, the query</p>
<p class="Sp-text-1"><a id="c4-para-1922"/>address($x, $y)</p>
<p class="paracontinue"><a id="c4-para-1923"/>will list all the employees’ addresses.</p>
<p><a id="c4-para-1924"/>A pattern can have no variables, in which case the query simply determines whether that pattern is an entry in the data base. If so, there will be one match; if not, there will be no matches.</p>
<p><a id="c4-para-1925"/>The same pattern variable can appear more than once in a query, specifying that the same “anything” must appear in each position. This is why variables have names. For example,</p>
<p class="Sp-text-1"><a id="c4-para-1926"/>supervisor($x, $x)</p>
<p class="paracontinue"><a id="c4-para-1927"/>finds all people who supervise themselves (though there are no such assertions in our sample data base).</p>
<p><a id="c4-para-1928"/>The query</p>
<p class="Sp-text-1"><a id="c4-para-1929"/>job($x, list("computer", $type))</p>
<p class="paracontinue"><a id="c4-para-1930"/>matches all job entries whose second item is a two-element list whose first item is <span class="KeyTerm1">"computer"</span>:</p>
<p class="Sp-text-1"><a id="c4-para-1931"/>job(list("Bitdiddle", "Ben"), list("computer", "wizard"))</p>
<p class="Sp-text-1"><a id="c4-para-1932"/>job(list("Hacker", "Alyssa", "P"), list("computer", "programmer"))</p>
<p class="Sp-text-1"><a id="c4-para-1933"/>job(list("Fect", "Cy", "D"), list("computer", "programmer"))</p>
<p class="Sp-text-1"><a id="c4-para-1934"/>job(list("Tweakit", "Lem", "E"), list("computer", "technician"))</p>
<p class="paracontinue"><a id="c4-para-1935"/>This same pattern does <i>not</i> match</p>
<p class="Sp-text-1"><a id="c4-para-1936"/>job(list("Reasoner", "Louis"),</p>
<p class="Sp-text-1"><a id="c4-para-1937"/>    list("computer", "programmer", "trainee"))</p>
<p class="paracontinue"><a id="c4-para-1938"/>because the second item in the assertion is a list of three elements, and the pattern's second item specifies that there should be two elements. If we wanted to change the pattern so that the second item could be any list beginning with <span class="KeyTerm1">"computer"</span>, we could specify</p>
<p class="Sp-text-1"><a id="c4-para-1939"/>job($x, pair("computer", $type))</p>
<p class="paracontinue"><a id="c4-para-1940"/>For example,</p>
<p class="Sp-text-1"><a id="c4-para-1941"/>pair("computer", $type)</p>
<p class="paracontinue"><a id="c4-para-1942"/>matches the data</p>
<p class="Sp-text-1"><a id="c4-para-1943"/>list("computer", "programmer", "trainee")</p>
<p class="paracontinue"><a id="c4-para-1944"/>with <span class="KeyTerm1">$type</span> as <span class="KeyTerm1">list("programmer", "trainee")</span>. It also matches the data</p>
<p class="Sp-text-1"><a id="c4-para-1945"/>list("computer", "programmer")</p>
<p class="paracontinue"><a id="c4-para-1946"/>with <span class="KeyTerm1">$type</span> as <span class="KeyTerm1">list("programmer")</span>, and matches the data</p>
<p class="Sp-text-1"><a id="c4-para-1947"/>list("computer")</p>
<p class="paracontinue"><a id="c4-para-1948"/>with <span class="KeyTerm1">$type</span> as the empty list, <span class="KeyTerm1"><b>null</b></span>.</p>
<p><a id="c4-para-1949"/>We can describe the query language's processing of simple queries as follows:</p>
<ul style="list-style-type:disc">
<li>The system finds all assignments to variables in the query pattern that <i>satisfy</i> the pattern—that is, all sets of values for the variables such that if the pattern variables are <i>instantiated with</i> (replaced by) the values, the result is in the data base.</li>
<li>The system responds to the query by listing all instantiations of the query pattern with the variable assignments that satisfy it.</li>
</ul>

<p class="paracontinue"><a id="c4-para-1952"/>Note that if the pattern has no variables, the query reduces to a determination of whether that pattern is in the data base. If so, the empty assignment, which assigns no values to variables, satisfies that pattern for that data base.</p>
</section>
<section>
<h5><a id="c4-sec-0116"/><a id="c4-title-0117"/>Exercise 4.53</h5>
<p class="paraaftertitle"><a id="c4-para-1953"/>Give simple queries that retrieve the following information from the data base:</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0074"/><span>a. </span>all people supervised by Ben Bitdiddle;</li>
<li><a id="c4-li-0075"/><span>b. </span>the names and jobs of all people in the accounting division;</li>
<li><a id="c4-li-0076"/><span>c. </span>the names and addresses of all people who live in Slumerville.</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0117"/><a id="c4-title-0118"/>Compound queries</h5>
<p class="paraaftertitle"><a id="c4-para-1957"/>Simple queries form the primitive operations of the query language. In order to form compound operations, the query language provides means of combination. One thing that makes the query language a logic programming language is that the means of combination mirror the means of combination used in forming logical expressions: <span class="KeyTerm1">and</span>, <span class="KeyTerm1">or</span>, and <span class="KeyTerm1">not</span>.</p>
<p><a id="c4-para-1958"/>We can use <span class="KeyTerm1">and</span> as follows to find the addresses of all the computer programmers:</p>
<p class="Sp-text-1"><a id="c4-para-1959"/>and(job($person, list("computer", "programmer")),</p>
<p class="Sp-text-1"><a id="c4-para-1960"/>    address($person, $where))</p>
<p class="paracontinue"><a id="c4-para-1961"/>The resulting output is</p>
<p class="Sp-text-1"><a id="c4-para-1962"/><i>and(job(list("Hacker", "Alyssa", "P"), list("computer", "programmer")),</i></p>
<p class="Sp-text-1"><a id="c4-para-1963"/>    <i>address(list("Hacker", "Alyssa", "P"),</i></p>
<p class="Sp-text-1"><a id="c4-para-1964"/>            <i>list("Cambridge", list("Mass", "Ave"), 78)))</i></p>
<p class="Sp-text-1"><a id="c4-para-1965"/><i>and(job(list("Fect", "Cy", "D"), list("computer", "programmer")),</i></p>
<p class="Sp-text-1"><a id="c4-para-1966"/>    <i>address(list("Fect", "Cy", "D"),</i></p>
<p class="Sp-text-1"><a id="c4-para-1967"/>            <i>list("Cambridge", list("Ames", "Street"), 3)))</i></p>
<p class="paracontinue"><a id="c4-para-1968"/>In general,</p>
<p class="Sp-text-1"><a id="c4-para-1969"/>and(<span class="KeyTerm2"><i>query</i><sub>1</sub></span>, <span class="KeyTerm2"><i>query</i><sub>2</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>query<sub>n</sub></i></span>)</p>
<p class="paracontinue"><a id="c4-para-1970"/>is satisfied by all sets of values for the pattern variables that simultaneously satisfy <i>query</i><sub>1</sub>, <span class="KeyTerm1"><i>. . .</i></span> , <i>query<sub>n</sub></i>.</p>
<p><a id="c4-para-1971"/>As for simple queries, the system processes a compound query by finding all assignments to the pattern variables that satisfy the query, then displaying instantiations of the query with those values.</p>
<p><a id="c4-para-1972"/>Another means of constructing compound queries is through <span class="KeyTerm1">or</span>. For example,</p>
<p class="Sp-text-1"><a id="c4-para-1973"/>or(supervisor($x, list("Bitdiddle", "Ben")),</p>
<p class="Sp-text-1"><a id="c4-para-1974"/>   supervisor($x, list("Hacker", "Alyssa", "P")))</p>
<p class="paracontinue"><a id="c4-para-1975"/>will find all employees supervised by Ben Bitdiddle or Alyssa P. Hacker:</p>
<p class="Sp-text-1"><a id="c4-para-1976"/><i>or(supervisor(list("Hacker", "Alyssa", "P"),</i></p>
<p class="Sp-text-1"><a id="c4-para-1977"/>              <i>list("Bitdiddle", "Ben")),</i></p>
<p class="Sp-text-1"><a id="c4-para-1978"/>   <i>supervisor(list("Hacker", "Alyssa", "P"),</i></p>
<p class="Sp-text-1"><a id="c4-para-1979"/>              <i>list("Hacker", "Alyssa", "P")))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1980"/><i>or(supervisor(list("Fect", "Cy", "D"),</i></p>
<p class="Sp-text-1"><a id="c4-para-1981"/>              <i>list("Bitdiddle", "Ben")),</i></p>
<p class="Sp-text-1"><a id="c4-para-1982"/>   <i>supervisor(list("Fect", "Cy", "D"),</i></p>
<p class="Sp-text-1"><a id="c4-para-1983"/>              <i>list("Hacker", "Alyssa", "P")))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1984"/><i>or(supervisor(list("Tweakit", "Lem", "E"),</i></p>
<p class="Sp-text-1"><a id="c4-para-1985"/>              <i>list("Bitdiddle", "Ben")),</i></p>
<p class="Sp-text-1"><a id="c4-para-1986"/>   <i>supervisor(list("Tweakit", "Lem", "E"),</i></p>
<p class="Sp-text-1"><a id="c4-para-1987"/>              <i>list("Hacker", "Alyssa", "P")))</i></p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-1988"/><i>or(supervisor(list("Reasoner", "Louis"),</i></p>
<p class="Sp-text-1"><a id="c4-para-1989"/>              <i>list("Bitdiddle", "Ben")),</i></p>
<p class="Sp-text-1"><a id="c4-para-1990"/>   <i>supervisor(list("Reasoner", "Louis"),</i></p>
<p class="Sp-text-1"><a id="c4-para-1991"/>              <i>list("Hacker", "Alyssa", "P")))</i></p>
<p class="paracontinue"><a id="c4-para-1992"/>In general,</p>
<p class="Sp-text-1"><a id="c4-para-1993"/>or(<span class="KeyTerm2"><i>query</i><sub>1</sub></span>, <span class="KeyTerm2"><i>query</i><sub>2</sub></span>, <i>. . .</i>, <span class="KeyTerm2"><i>query<sub>n</sub></i></span>)</p>
<p class="paracontinue"><a id="c4-para-1994"/>is satisfied by all sets of values for the pattern variables that satisfy at least one of <i>query</i><sub>1</sub> <span class="KeyTerm1"><i>. . .</i></span> <i>query<sub>n</sub></i>.</p>
<p><a id="c4-para-1995"/>Compound queries can also be formed with <span class="KeyTerm1">not</span>. For example,</p>
<p class="Sp-text-1"><a id="c4-para-1996"/>and(supervisor($x, list("Bitdiddle", "Ben")),</p>
<p class="Sp-text-1"><a id="c4-para-1997"/>    not(job($x, list("computer", "programmer"))))</p>
<p class="paracontinue"><a id="c4-para-1998"/>finds all people supervised by Ben Bitdiddle who are not computer programmers. In general,</p>
<p class="Sp-text-1"><a id="c4-para-1999"/>not(<span class="KeyTerm2"><i>query</i><sub>1</sub></span>)</p>
<p class="paracontinue"><a id="c4-para-2000"/>is satisfied by all assignments to the pattern variables that do not satisfy <i>query</i><sub>1</sub>.<a id="c4-fn-0057a"/><a href="#c4-fn-0057"><sup>57</sup></a></p>
<p><a id="c4-para-2001"/>The final combining form starts with <span class="KeyTerm1">javascript_predicate</span> and contains a JavaScript predicate. In general,</p>
<p class="Sp-text-1"><a id="c4-para-2002"/>javascript_predicate(<span class="KeyTerm2"><i>predicate</i></span>)</p>
<p class="paracontinue"><a id="c4-para-2003"/>will be satisfied by assignments to the pattern variables in the <i>predicate</i> for which the instantiated <i>predicate</i> is true. For example, to find all people whose salary is greater than $50,000 we could write<a id="c4-fn-0058a"/><a href="#c4-fn-0058"><sup>58</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-2004"/>and(salary($person, $amount), javascript_predicate($amount &gt; 50000))</p>
</section>
<section>
<h5><a id="c4-sec-0118"/><a id="c4-title-0119"/>Exercise 4.54</h5>
<p class="paraaftertitle"><a id="c4-para-2005"/>Formulate compound queries that retrieve the following information:</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0077"/><span>a. </span>the names of all people who are supervised by Ben Bitdiddle, together with their addresses;</li>
<li><a id="c4-li-0078"/><span>b. </span>all people whose salary is less than Ben Bitdiddle's, together with their salary and Ben Bitdiddle's salary;</li>
<li><a id="c4-li-0079"/><span>c. </span>all people who are supervised by someone who is not in the computer division, together with the supervisor's name and job.</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0119"/><a id="c4-title-0120"/>Rules</h5>
<p class="paraaftertitle"><a id="c4-para-2009"/>In addition to primitive queries and compound queries, the query language provides means for abstracting queries. These are given by <i>rules</i>. The rule</p>
<p class="Sp-text-1"><a id="c4-para-2010"/>rule(lives_near($person_1, $person_2),</p>
<p class="Sp-text-1"><a id="c4-para-2011"/>    and(address($person_1, pair($town, $rest_1)),</p>
<p class="Sp-text-1"><a id="c4-para-2012"/>        address($person_2, pair($town, $rest_2)),</p>
<p class="Sp-text-1"><a id="c4-para-2013"/>        not(same($person_1, $person_2))))</p>
<p class="paracontinue"><a id="c4-para-2014"/>specifies that two people live near each other if they live in the same town. The final <span class="KeyTerm1">not</span> clause prevents the rule from saying that all people live near themselves. The <span class="KeyTerm1">same</span> relation is defined by a very simple rule:<a id="c4-fn-0059a"/><a href="#c4-fn-0059"><sup>59</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-2015"/>rule(same($x, $x))</p>
<p><a id="c4-para-2016"/>The following rule declares that a person is a “wheel” in an organization if he supervises someone who is in turn a supervisor:</p>
<p class="Sp-text-1"><a id="c4-para-2017"/>rule(wheel($person),</p>
<p class="Sp-text-1"><a id="c4-para-2018"/>     and(supervisor($middle_manager, $person),</p>
<p class="Sp-text-1"><a id="c4-para-2019"/>         supervisor($x, $middle_manager)))</p>
<p><a id="c4-para-2020"/>The general form of a rule is</p>
<p class="Sp-text-1"><a id="c4-para-2021"/>rule(<span class="KeyTerm2"><i>conclusion</i></span>, <span class="KeyTerm2"><i>body</i></span>)</p>
<p class="paracontinue"><a id="c4-para-2022"/>where <i>conclusion</i> is a pattern and <i>body</i> is any query.<a id="c4-fn-0060a"/><a href="#c4-fn-0060"><sup>60</sup></a> We can think of a rule as representing a large (even infinite) set of assertions, namely all instantiations of the rule conclusion with variable assignments that satisfy the rule body. When we described simple queries (patterns), we said that an assignment to variables satisfies a pattern if the instantiated pattern is in the data base. But the pattern needn't be explicitly in the data base as an assertion. It can be an implicit assertion implied by a rule. For example, the query</p>
<p class="Sp-text-1"><a id="c4-para-2023"/>lives_near($x, list("Bitdiddle", "Ben"))</p>
<p class="paracontinue"><a id="c4-para-2024"/>results in</p>
<p class="Sp-text-3"><a id="c4-para-2025"/><i>lives_near(list("Reasoner", "Louis"), list("Bitdiddle", "Ben"))</i></p>
<p class="Sp-text-3"><a id="c4-para-2026"/><i>lives_near(list("Aull", "DeWitt"), list("Bitdiddle", "Ben"))</i></p>
<p class="paracontinue"><a id="c4-para-2027"/>To find all computer programmers who live near Ben Bitdiddle, we can ask</p>
<p class="Sp-text-1"><a id="c4-para-2028"/>and(job($x, list("computer", "programmer")),</p>
<p class="Sp-text-1"><a id="c4-para-2029"/>    lives_near($x, list("Bitdiddle", "Ben")))</p>
<p><a id="c4-para-2030"/>As in the case of compound functions, rules can be used as parts of other rules (as we saw with the <span class="KeyTerm1">lives_near</span> rule above) or even be defined recursively. For instance, the rule</p>
<p class="Sp-text-1"><a id="c4-para-2031"/>rule(outranked_by($staff_person, $boss),</p>
<p class="Sp-text-1"><a id="c4-para-2032"/>     or(supervisor($staff_person, $boss),</p>
<p class="Sp-text-1"><a id="c4-para-2033"/>        and(supervisor($staff_person, $middle_manager),</p>
<p class="Sp-text-1"><a id="c4-para-2034"/>            outranked_by($middle_manager, $boss))))</p>
<p class="paracontinue"><a id="c4-para-2035"/>says that a staff person is outranked by a boss in the organization if the boss is the person's supervisor or (recursively) if the person's supervisor is outranked by the boss.</p>
</section>
<section>
<h5><a id="c4-sec-0120"/><a id="c4-title-0121"/>Exercise 4.55</h5>
<p class="paraaftertitle"><a id="c4-para-2036"/>Define a rule that says that person 1 can replace person 2 if either person 1 does the same job as person 2 or someone who does person 1's job can also do person 2's job, and if person 1 and person 2 are not the same person. Using your rule, give queries that find the following:</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0080"/><span>a. </span>all people who can replace Cy D. Fect;</li>
<li><a id="c4-li-0081"/><span>b. </span>all people who can replace someone who is being paid more than they are, together with the two salaries.</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0121"/><a id="c4-title-0122"/>Exercise 4.56</h5>
<p class="paraaftertitle"><a id="c4-para-2039"/>Define a rule that says that a person is a “big shot” in a division if the person works in the division but does not have a supervisor who works in the division.</p>
</section>
<section>
<h5><a id="c4-sec-0122"/><a id="c4-title-0123"/>Exercise 4.57</h5>
<p class="paraaftertitle"><a id="c4-para-2040"/>Ben Bitdiddle has missed one meeting too many. Fearing that his habit of forgetting meetings could cost him his job, Ben decides to do something about it. He adds all the weekly meetings of the firm to the Gargle data base by asserting the following:</p>
<p class="Sp-text-1"><a id="c4-para-2041"/>meeting("accounting", list("Monday", "9am"))</p>
<p class="Sp-text-1"><a id="c4-para-2042"/>meeting("administration", list("Monday", "10am"))</p>
<p class="Sp-text-1"><a id="c4-para-2043"/>meeting("computer", list("Wednesday", "3pm"))</p>
<p class="Sp-text-1"><a id="c4-para-2044"/>meeting("administration", list("Friday", "1pm"))</p>
<p class="paracontinue"><a id="c4-para-2045"/>Each of the above assertions is for a meeting of an entire division. Ben also adds an entry for the company-wide meeting that spans all the divisions. All of the company's employees attend this meeting.</p>
<p class="Sp-text-1"><a id="c4-para-2046"/>meeting("whole-company", list("Wednesday", "4pm"))</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0082"/><span>a. </span>On Friday morning, Ben wants to query the data base for all the meetings that occur that day. What query should he use?</li>
<li><a id="c4-li-0083"/><span>b. </span>Alyssa P. Hacker is unimpressed. She thinks it would be much more useful to be able to ask for her meetings by specifying her name. So she designs a rule that says that a person's meetings include all <span class="KeyTerm1">"whole-company"</span> meetings plus all meetings of that person's division. Fill in the body of Alyssa's rule.
<p class="Sp-text-1"><a id="c4-para-2049"/>rule(meeting_time($person, $day_and_time),</p>
<p class="Sp-text-1"><a id="c4-para-2050"/>     <span class="KeyTerm2"><i>rule</i>-<i>body</i></span>)</p></li>
<li><a id="c4-li-0084"/><span>c. </span>Alyssa arrives at work on Wednesday morning and wonders what meetings she has to attend that day. Having defined the above rule, what query should she make to find this out?</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0123"/><a id="c4-title-0124"/>Exercise 4.58</h5>
<p class="paraaftertitle"><a id="c4-para-2052"/>By giving the query</p>
<p class="Sp-text-1"><a id="c4-para-2053"/>lives_near($person, list("Hacker", "Alyssa", "P"))</p>
<p class="paracontinue"><a id="c4-para-2054"/>Alyssa P. Hacker is able to find people who live near her, with whom she can ride to work. On the other hand, when she tries to find all pairs of people who live near each other by querying</p>
<p class="Sp-text-1"><a id="c4-para-2055"/>lives_near($person_1, $person_2)</p>
<p class="paracontinue"><a id="c4-para-2056"/>she notices that each pair of people who live near each other is listed twice; for example,</p>
<p class="Sp-text-1"><a id="c4-para-2057"/>lives_near(list("Hacker", "Alyssa", "P"), list("Fect", "Cy", "D"))</p>
<p class="Sp-text-1"><a id="c4-para-2058"/>lives_near(list("Fect", "Cy", "D"), list("Hacker", "Alyssa", "P"))</p>
<p class="paracontinue"><a id="c4-para-2059"/>Why does this happen? Is there a way to find a list of people who live near each other, in which each pair appears only once? Explain.</p>
</section>
<section>
<h5><a id="c4-sec-0124"/><a id="c4-title-0125"/>Logic as programs</h5>
<p class="paraaftertitle"><a id="c4-para-2060"/>We can regard a rule as a kind of logical implication: <i>If</i> an assignment of values to pattern variables satisfies the body, <i>then</i> it satisfies the conclusion. Consequently, we can regard the query language as having the ability to perform <i>logical deductions</i> based upon the rules. As an example, consider the <span class="KeyTerm1">append</span> operation described at the beginning of section 4.4. As we said, <span class="KeyTerm1">append</span> can be characterized by the following two rules:</p>
<ul style="list-style-type:disc">
<li>For any list <span class="KeyTerm1">y</span>, the empty list and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">y</span>.</li>
<li>For any <span class="KeyTerm1">u</span>, <span class="KeyTerm1">v</span>, <span class="KeyTerm1">y</span>, and <span class="KeyTerm1">z</span>, <span class="KeyTerm1">pair(u, v)</span> and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">pair(u, z)</span> if <span class="KeyTerm1">v</span> and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">z</span>.</li>
</ul>

<p><a id="c4-para-2063"/>To express this in our query language, we define two rules for a relation</p>
<p class="Sp-text-1"><a id="c4-para-2064"/>append_to_form(x, y, z)</p>
<p class="paracontinue"><a id="c4-para-2065"/>which we can interpret to mean “<span class="KeyTerm1">x</span> and <span class="KeyTerm1">y append</span> to form <span class="KeyTerm1">z</span>”:</p>
<p class="Sp-text-1"><a id="c4-para-2066"/>rule(append_to_form(<b>null</b>, $y, $y))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-2067"/>rule(append_to_form(pair($u, $v), $y, pair($u, $z)),</p>
<p class="Sp-text-1"><a id="c4-para-2068"/>     append_to_form($v, $y, $z))</p>
<p class="paracontinue"><a id="c4-para-2069"/>The first rule has no body, which means that the conclusion holds for any value of <span class="KeyTerm1">$y</span>. Note how the second rule makes use of <span class="KeyTerm1">pair</span> to name the head and tail of a list.</p>
<p><a id="c4-para-2070"/>Given these two rules, we can formulate queries that compute the <span class="KeyTerm1">append</span> of two lists:</p>
<p class="Sp-text-3"><a id="c4-para-2071"/><i>Query input:</i></p>
<p class="Sp-text-1"><a id="c4-para-2072"/>append_to_form(list("a", "b"), list("c", "d"), $z)</p>
<p class="Sp-text-3"><a id="c4-para-2073"/><i>Query results:</i></p>
<p class="Sp-text-3"><a id="c4-para-2074"/><i>append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))</i></p>
<p class="paracontinue"><a id="c4-para-2075"/>What is more striking, we can use the same rules to ask the question “Which list, when <span class="KeyTerm1">append</span>ed to <span class="KeyTerm1">list("a", "b")</span>, yields <span class="KeyTerm1">list("a", "b", "c", "d")</span>? ” This is done as follows:</p>
<p class="Sp-text-3"><a id="c4-para-2076"/><i>Query input:</i></p>
<p class="Sp-text-1"><a id="c4-para-2077"/>append_to_form(list("a", "b"), $y, list("a", "b", "c", "d"))</p>
<p class="Sp-text-3"><a id="c4-para-2078"/><i>Query results:</i></p>
<p class="Sp-text-3"><a id="c4-para-2079"/><i>append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))</i></p>
<p class="paracontinue"><a id="c4-para-2080"/>We can ask for all pairs of lists that <span class="KeyTerm1">append</span> to form <span class="KeyTerm1">list("a", "b", "c", "d")</span>:</p>
<p class="Sp-text-3"><a id="c4-para-2081"/><i>Query input:</i></p>
<p class="Sp-text-1"><a id="c4-para-2082"/>append_to_form($x, $y, list("a", "b", "c", "d"))</p>
<p class="Sp-text-3"><a id="c4-para-2083"/><i>Query results:</i></p>
<p class="Sp-text-3"><a id="c4-para-2084"/><i>append_to_form(null, list("a", "b", "c", "d"), list("a", "b", "c", "d"))</i></p>
<p class="Sp-text-3"><a id="c4-para-2085"/><i>append_to_form(list("a"), list("b", "c", "d"), list("a", "b", "c", "d"))</i></p>
<p class="Sp-text-3"><a id="c4-para-2086"/><i>append_to_form(list("a", "b"), list("c", "d"), list("a", "b", "c", "d"))</i></p>
<p class="Sp-text-3"><a id="c4-para-2087"/><i>append_to_form(list("a", "b", "c"), list("d"), list("a", "b", "c", "d"))</i></p>
<p class="Sp-text-3"><a id="c4-para-2088"/><i>append_to_form(list("a", "b", "c", "d"), null, list("a", "b", "c", "d"))</i></p>
<p><a id="c4-para-2089"/>The query system may seem to exhibit quite a bit of intelligence in using the rules to deduce the answers to the queries above. Actually, as we will see in the next section, the system is following a well-determined algorithm in unraveling the rules. Unfortunately, although the system works impressively in the <span class="KeyTerm1">append</span> case, the general methods may break down in more complex cases, as we will see in section 4.4.3.</p>
</section>
<section>
<h5><a id="c4-sec-0125"/><a id="c4-title-0126"/>Exercise 4.59</h5>
<p class="paraaftertitle"><a id="c4-para-2090"/>The following rules implement a <span class="KeyTerm1">next_to_in</span> relation that finds adjacent elements of a list:</p>
<p class="Sp-text-1"><a id="c4-para-2091"/>rule(next_to_in($x, $y, pair($x, pair($y, $u))))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-2092"/>rule(next_to_in($x, $y, pair($v, $z)),</p>
<p class="Sp-text-1"><a id="c4-para-2093"/>     next_to_in($x, $y, $z))</p>
<p class="paracontinue"><a id="c4-para-2094"/>What will the response be to the following queries?</p>
<p class="Sp-text-1"><a id="c4-para-2095"/>next_to_in($x, $y, list(1, list(2, 3), 4))</p>
<p class="Sp-text-1"><a id="c4-para-2096"/>next_to_in($x, 1, list(2, 1, 3, 1))</p>
</section>
<section>
<h5><a id="c4-sec-0126"/><a id="c4-title-0127"/>Exercise 4.60</h5>
<p class="paraaftertitle"><a id="c4-para-2097"/>Define rules to implement the <span class="KeyTerm1">last_pair</span> operation of exercise 2.17, which returns a list containing the last element of a nonempty list. Check your rules on the following queries:</p>
<ul style="list-style-type:disc">
<li>last_pair(list(3), $x)</li>
<li>last_pair(list(1, 2, 3), $x)</li>
<li>last_pair(list(2, $x), list(3))</li>
</ul>

<p class="paracontinue"><a id="c4-para-2101"/>Do your rules work correctly on queries such as <span class="KeyTerm1">last_pair($x, list(3))</span>?</p>
</section>
<section>
<h5><a id="c4-sec-0127"/><a id="c4-title-0128"/>Exercise 4.61</h5>
<p class="paraaftertitle"><a id="c4-para-2102"/>The following data base (see Genesis 4) traces the genealogy of the descendants of Ada back to Adam, by way of Cain:</p>
<p class="Sp-text-1"><a id="c4-para-2103"/>son("Adam", "Cain")</p>
<p class="Sp-text-1"><a id="c4-para-2104"/>son("Cain", "Enoch")</p>
<p class="Sp-text-1"><a id="c4-para-2105"/>son("Enoch", "Irad")</p>
<p class="Sp-text-1"><a id="c4-para-2106"/>son("Irad", "Mehujael") son("Mehujael", "Methushael") son("Methushael", "Lamech") wife("Lamech", "Ada")</p>
<p class="Sp-text-1"><a id="c4-para-2107"/>son("Ada", "Jabal")</p>
<p class="Sp-text-1"><a id="c4-para-2108"/>son("Ada", "Jubal")</p>
<p class="paracontinue"><a id="c4-para-2109"/>Formulate rules such as “If <i>S</i> is the son of <i>F</i>, and <i>F</i> is the son of <i>G</i>, then <i>S</i> is the grandson of <i>G</i>” and “If <i>W</i> is the wife of <i>M</i>, and <i>S</i> is the son of <i>W</i>, then <i>S</i> is the son of <i>M</i>” (which was supposedly more true in biblical times than today) that will enable the query system to find the grandson of Cain; the sons of Lamech; the grandsons of Methushael. (See exercise 4.67 for some rules to deduce more complicated relationships.)</p>
</section>
</section>
<section>
<h3><a id="c4-sec-0128"/><span>4.4.2</span> <a id="c4-title-0129"/>How the Query System Works</h3>
<p class="paraaftertitle"><a id="c4-para-2110"/>In section 4.4.4 we will present an implementation of the query interpreter as a collection of functions. In this section we give an overview that explains the general structure of the system independent of low-level implementation details. After describing the implementation of the interpreter, we will be in a position to understand some of its limitations and some of the subtle ways in which the query language's logical operations differ from the operations of mathematical logic.</p>
<p><a id="c4-para-2111"/>It should be apparent that the query evaluator must perform some kind of search in order to match queries against facts and rules in the data base. One way to do this would be to implement the query system as a nondeterministic program, using the <span class="KeyTerm1">amb</span> evaluator of section 4.3 (see exercise 4.75). Another possibility is to manage the search with the aid of streams. Our implementation follows this second approach.</p>
<p><a id="c4-para-2112"/>The query system is organized around two central operations, called <i>pattern matching</i> and <i>unification</i>. We first describe pattern matching and explain how this operation, together with the organization of information in terms of streams of frames, enables us to implement both simple and compound queries. We next discuss unification, a generalization of pattern matching needed to implement rules. Finally, we show how the entire query interpreter fits together through a function that classifies queries in a manner analogous to the way <span class="KeyTerm1">evaluate</span> classifies expressions for the interpreter described in section 4.1.</p>
<section>
<h5><a id="c4-sec-0129"/><a id="c4-title-0130"/>Pattern matching</h5>
<p class="paraaftertitle"><a id="c4-para-2113"/>A <i>pattern matcher</i> is a program that tests whether some datum fits a specified pattern. For example, the datum <span class="KeyTerm1">list(list("a", "b"), "c", list("a", "b"))</span> matches the pattern <span class="KeyTerm1">list($x, "c", $x)</span> with the pattern variable <span class="KeyTerm1">$x</span> bound to <span class="KeyTerm1">list("a", "b")</span>. The same data list matches the pattern <span class="KeyTerm1">list($x, $y, $z)</span> with <span class="KeyTerm1">$x</span> and <span class="KeyTerm1">$z</span> both bound to <span class="KeyTerm1">list("a", "b")</span> and <span class="KeyTerm1">$y</span> bound to <span class="KeyTerm1">"c"</span>. It also matches the pattern <span class="KeyTerm1">list(list($x, $y), "c", list($x, $y))</span> with <span class="KeyTerm1">$x</span> bound to <span class="KeyTerm1">"a"</span> and <span class="KeyTerm1">$y</span> bound to <span class="KeyTerm1">"b"</span>. However, it does not match the pattern <span class="KeyTerm1">list($x, "a", $y)</span>, since that pattern specifies a list whose second element is the string <span class="KeyTerm1">"a"</span>.</p>
<p><a id="c4-para-2114"/>The pattern matcher used by the query system takes as inputs a pattern, a datum, and a <i>frame</i> that specifies bindings for various pattern variables. It checks whether the datum matches the pattern in a way that is consistent with the bindings already in the frame. If so, it returns the given frame augmented by any bindings that may have been determined by the match. Otherwise, it indicates that the match has failed.</p>
<p><a id="c4-para-2115"/>Using the pattern <span class="KeyTerm1">list($x, $y, $x)</span> to match <span class="KeyTerm1">list("a", "b", "a")</span> given an empty frame, for example, will return a frame specifying that <span class="KeyTerm1">$x</span> is bound to <span class="KeyTerm1">"a"</span> and <span class="KeyTerm1">$y</span> is bound to <span class="KeyTerm1">"b"</span>. Trying the match with the same pattern, the same datum, and a frame specifying that <span class="KeyTerm1">$y</span> is bound to <span class="KeyTerm1">"a"</span> will fail. Trying the match with the same pattern, the same datum, and a frame in which <span class="KeyTerm1">$y</span> is bound to <span class="KeyTerm1">"b"</span> and <span class="KeyTerm1">$x</span> is unbound will return the given frame augmented by a binding of <span class="KeyTerm1">$x</span> to <span class="KeyTerm1">"a"</span>.</p>
<p><a id="c4-para-2116"/>The pattern matcher is all the mechanism that is needed to process simple queries that don't involve rules. For instance, to process the query</p>
<p class="Sp-text-1"><a id="c4-para-2117"/>job($x, list("computer", "programmer"))</p>
<p class="paracontinue"><a id="c4-para-2118"/>we scan through all assertions in the data base and select those that match the pattern with respect to an initially empty frame. For each match we find, we use the frame returned by the match to instantiate the pattern with a value for <span class="KeyTerm1">$x</span>.</p>
</section>
<section>
<h5><a id="c4-sec-0130"/><a id="c4-title-0131"/>Streams of frames</h5>
<p class="paraaftertitle"><a id="c4-para-2119"/>The testing of patterns against frames is organized through the use of streams. Given a single frame, the matching process runs through the data-base entries one by one. For each data-base entry, the matcher generates either a special symbol indicating that the match has failed or an extension to the frame. The results for all the database entries are collected into a stream, which is passed through a filter to weed out the failures. The result is a stream of all the frames that extend the given frame via a match to some assertion in the data base.<a id="c4-fn-0061a"/><a href="#c4-fn-0061"><sup>61</sup></a></p>
<p><a id="c4-para-2120"/>In our system, a query takes an input stream of frames and performs the above matching operation for every frame in the stream, as indicated in <a id="c4-fig-0005a"/><a href="#c4-fig-0005">figure 4.5</a>. That is, for each frame in the input stream, the query generates a new stream consisting of all extensions to that frame by matches to assertions in the data base. All these streams are then combined to form one huge stream, which contains all possible extensions of every frame in the input stream. This stream is the output of the query.</p>
<figure id="c4-fig-0005"><img alt="c4-fig-0005.jpg" src="../images/c4-fig-0005.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0005a">Figure 4.5</a></span> <a id="c4-para-2121"/>A query processes a stream of frames.</p></figcaption></figure>
<p><a id="c4-para-2122"/>To answer a simple query, we use the query with an input stream consisting of a single empty frame. The resulting output stream contains all extensions to the empty frame (that is, all answers to our query). This stream of frames is then used to generate a stream of copies of the original query pattern with the variables instantiated by the values in each frame, and this is the stream that is finally printed.</p>
</section>
<section>
<h5><a id="c4-sec-0131"/><a id="c4-title-0132"/>Compound queries</h5>
<p class="paraaftertitle"><a id="c4-para-2123"/>The real elegance of the stream-of-frames implementation is evident when we deal with compound queries. The processing of compound queries makes use of the ability of our matcher to demand that a match be consistent with a specified frame. For example, to handle the <span class="KeyTerm1">and</span> of two queries, such as</p>
<p class="Sp-text-1"><a id="c4-para-2124"/>and(can_do_job($x, list("computer", "programmer", "trainee")),</p>
<p class="Sp-text-1"><a id="c4-para-2125"/>    job($person, $x))</p>
<p class="paracontinue"><a id="c4-para-2126"/>(informally, “Find all people who can do the job of a computer programmer trainee”), we first find all entries that match the pattern</p>
<p class="Sp-text-1"><a id="c4-para-2127"/>can_do_job($x, list("computer", "programmer", "trainee"))</p>
<p class="paracontinue"><a id="c4-para-2128"/>This produces a stream of frames, each of which contains a binding for <span class="KeyTerm1">$x</span>. Then for each frame in the stream we find all entries that match</p>
<p class="Sp-text-1"><a id="c4-para-2129"/>job($person, $x)</p>
<p class="paracontinue"><a id="c4-para-2130"/>in a way that is consistent with the given binding for <span class="KeyTerm1">$x</span>. Each such match will produce a frame containing bindings for <span class="KeyTerm1">$x</span> and <span class="KeyTerm1">$person</span>. The <span class="KeyTerm1">and</span> of two queries can be viewed as a series combination of the two component queries, as shown in <a id="c4-fig-0006a"/><a href="#c4-fig-0006">figure 4.6</a>. The frames that pass through the first query filter are filtered and further extended by the second query.</p>
<figure id="c4-fig-0006"><img alt="c4-fig-0006.jpg" src="../images/c4-fig-0006.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0006a">Figure 4.6</a></span> <a id="c4-para-2131"/>The <span class="KeyTerm1">and</span> combination of two queries is produced by operating on the stream of frames in series.</p></figcaption></figure>
<p><a id="c4-para-2132"/><a id="c4-fig-0007a"/><a href="#c4-fig-0007">Figure 4.7</a> shows the analogous method for computing the <span class="KeyTerm1">or</span> of two queries as a parallel combination of the two component queries. The input stream of frames is extended separately by each query. The two resulting streams are then merged to produce the final output stream.</p>
<figure id="c4-fig-0007"><img alt="c4-fig-0007.jpg" src="../images/c4-fig-0007.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0007a">Figure 4.7</a></span> <a id="c4-para-2133"/>The <span class="KeyTerm1">or</span> combination of two queries is produced by operating on the stream of frames in parallel and merging the results.</p></figcaption></figure>
<p><a id="c4-para-2134"/>Even from this high-level description, it is apparent that the processing of compound queries can be slow. For example, since a query may produce more than one output frame for each input frame, and each query in an <span class="KeyTerm1">and</span> gets its input frames from the previous query, an <span class="KeyTerm1">and</span> query could, in the worst case, have to perform a number of matches that is exponential in the number of queries (see exercise 4.73).<a id="c4-fn-0062a"/><a href="#c4-fn-0062"><sup>62</sup></a> Though systems for handling only simple queries are quite practical, dealing with complex queries is extremely difficult.<a id="c4-fn-0063a"/><a href="#c4-fn-0063"><sup>63</sup></a></p>
<p><a id="c4-para-2135"/>From the stream-of-frames viewpoint, the <span class="KeyTerm1">not</span> of some query acts as a filter that removes all frames for which the query can be satisfied. For instance, given the pattern</p>
<p class="Sp-text-1"><a id="c4-para-2136"/>not(job($x, list("computer", "programmer")))</p>
<p class="paracontinue"><a id="c4-para-2137"/>we attempt, for each frame in the input stream, to produce extension frames that satisfy <span class="KeyTerm1">job($x, list("computer", "programmer"))</span>. We remove from the input stream all frames for which such extensions exist. The result is a stream consisting of only those frames in which the binding for <span class="KeyTerm1">$x</span> does not satisfy <span class="KeyTerm1">job($x, list("computer", "programmer"))</span>. For example, in processing the query</p>
<p class="Sp-text-1"><a id="c4-para-2138"/>and(supervisor($x, $y),</p>
<p class="Sp-text-1"><a id="c4-para-2139"/>    not(job($x, list("computer", "programmer"))))</p>
<p class="paracontinue"><a id="c4-para-2140"/>the first clause will generate frames with bindings for <span class="KeyTerm1">$x</span> and <span class="KeyTerm1">$y</span>. The <span class="KeyTerm1">not</span> clause will then filter these by removing all frames in which the binding for <span class="KeyTerm1">$x</span> satisfies the restriction that <span class="KeyTerm1">$x</span> is a computer programmer.<a id="c4-fn-0064a"/><a href="#c4-fn-0064"><sup>64</sup></a></p>
<p><a id="c4-para-2141"/>The <span class="KeyTerm1">javascript_predicate</span> syntactic form is implemented as a similar filter on frame streams. We use each frame in the stream to instantiate any variables in the pattern, then apply the JavaScript predicate. We remove from the input stream all frames for which the predicate fails.</p>
</section>
<section>
<h5><a id="c4-sec-0132"/><a id="c4-title-0133"/>Unification</h5>
<p class="paraaftertitle"><a id="c4-para-2142"/>In order to handle rules in the query language, we must be able to find the rules whose conclusions match a given query pattern. Rule conclusions are like assertions except that they can contain variables, so we will need a generalization of pattern matching—called <i>unification</i>—in which both the “pattern” and the “datum” may contain variables.</p>
<p><a id="c4-para-2143"/>A unifier takes two patterns, each containing constants and variables, and determines whether it is possible to assign values to the variables that will make the two patterns equal. If so, it returns a frame containing these bindings. For example, unifying <span class="KeyTerm1">list($x, "a", $y)</span> and <span class="KeyTerm1">list($y, $z, "a")</span> will specify a frame in which <span class="KeyTerm1">$x</span>, <span class="KeyTerm1">$y</span>, and <span class="KeyTerm1">$z</span> must all be bound to <span class="KeyTerm1">"a"</span>. On the other hand, unifying <span class="KeyTerm1">list($x, $y, "a")</span> and <span class="KeyTerm1">list($x, "b", $y)</span> will fail, because there is no value for <span class="KeyTerm1">$y</span> that can make the two patterns equal. (For the second elements of the patterns to be equal, <span class="KeyTerm1">$y</span> would have to be <span class="KeyTerm1">"b"</span>; however, for the third elements to be equal, <span class="KeyTerm1">$y</span> would have to be <span class="KeyTerm1">"a"</span>.) The unifier used in the query system, like the pattern matcher, takes a frame as input and performs unifications that are consistent with this frame.</p>
<p><a id="c4-para-2144"/>The unification algorithm is the most technically difficult part of the query system. With complex patterns, performing unification may seem to require deduction. To unify</p>
<p class="Sp-text-1"><a id="c4-para-2145"/>list($x, $x) </p>
<p class="paracontinue"><a id="c4-para-2146"/>and</p>
<p class="Sp-text-1"><a id="c4-para-2147"/>list(list("a", $y, "c"), list("a", "b", $z))</p>
<p class="paracontinue"><a id="c4-para-2148"/>for example, the algorithm must infer that <span class="KeyTerm1">$x</span> should be <span class="KeyTerm1">list("a", "b", "c")</span>, <span class="KeyTerm1">$y</span> should be <span class="KeyTerm1">"b"</span>, and <span class="KeyTerm1">$z</span> should be <span class="KeyTerm1">"c"</span>. We may think of this process as solving a set of equations among the pattern components. In general, these are simultaneous equations, which may require substantial manipulation to solve.<a id="c4-fn-0065a"/><a href="#c4-fn-0065"><sup>65</sup></a> For example, unifying <span class="KeyTerm1">list($x, $x)</span> and <span class="KeyTerm1">list(list("a", $y, "c"), list("a", "b", $z))</span> may be thought of as specifying the simultaneous equations</p>
<p class="Sp-text-2"><a id="c4-para-2149"/><span class="KeyTerm1">$x = list("a", $y, "c")</span></p>
<p class="Sp-text-2"><a id="c4-para-2150"/><span class="KeyTerm1">$x = list("a", "b", $z)</span></p>
<p class="paracontinue"><a id="c4-para-2151"/>These equations imply that</p>
<p class="Sp-text-2"><a id="c4-para-2152"/><span class="KeyTerm1">list("a", $y, "c") = list("a", "b", $z)</span></p>
<p class="paracontinue"><a id="c4-para-2153"/>which in turn implies that</p>
<p class="Sp-text-2"><a id="c4-para-2154"/><span class="KeyTerm1">"a" = "a"</span>, <span class="KeyTerm1">$y = "b"</span>, <span class="KeyTerm1">"c" = $z</span></p>
<p class="paracontinue"><a id="c4-para-2155"/>and hence that</p>
<p class="Sp-text-2"><a id="c4-para-2156"/><span class="KeyTerm2">$x = list("a", "b", "c")</span></p>
<p><a id="c4-para-2157"/>In a successful pattern match, all pattern variables become bound, and the values to which they are bound contain only constants. This is also true of all the examples of unification we have seen so far. In general, however, a successful unification may not completely determine the variable values; some variables may remain unbound and others may be bound to values that contain variables.</p>
<p><a id="c4-para-2158"/>Consider the unification of <span class="KeyTerm1">list($x, "a")</span> and <span class="KeyTerm1">list(list("b", $y), $z)</span>. We can deduce that <span class="KeyTerm1">$x</span> = <span class="KeyTerm1">list("b", $y)</span> and <span class="KeyTerm1">"a"</span> = <span class="KeyTerm1">$z</span>, but we cannot further solve for <span class="KeyTerm1">$x</span> or <span class="KeyTerm1">$y</span>. The unification doesn't fail, since it is certainly possible to make the two patterns equal by assigning values to <span class="KeyTerm1">$x</span> and <span class="KeyTerm1">$y</span>. Since this match in no way restricts the values <span class="KeyTerm1">$y</span> can take on, no binding for <span class="KeyTerm1">$y</span> is put into the result frame. The match does, however, restrict the value of <span class="KeyTerm1">$x</span>. Whatever value <span class="KeyTerm1">$y</span> has, <span class="KeyTerm1">$x</span> must be <span class="KeyTerm1">list("b", $y)</span>. A binding of <span class="KeyTerm1">$x</span> to the pattern <span class="KeyTerm1">list("b", $y)</span> is thus put into the frame. If a value for <span class="KeyTerm1">$y</span> is later determined and added to the frame (by a pattern match or unification that is required to be consistent with this frame), the previously bound <span class="KeyTerm1">$x</span> will refer to this value.<a id="c4-fn-0066a"/><a href="#c4-fn-0066"><sup>66</sup></a></p>
</section>
<section>
<h5><a id="c4-sec-0133"/><a id="c4-title-0134"/>Applying rules</h5>
<p class="paraaftertitle"><a id="c4-para-2159"/>Unification is the key to the component of the query system that makes inferences from rules. To see how this is accomplished, consider processing a query that involves applying a rule, such as</p>
<p class="Sp-text-1"><a id="c4-para-2160"/>lives_near($x, list("Hacker", "Alyssa", "P"))</p>
<p class="paracontinue"><a id="c4-para-2161"/>To process this query, we first use the ordinary pattern-match function described above to see if there are any assertions in the data base that match this pattern. (There will not be any in this case, since our data base includes no direct assertions about who lives near whom.) The next step is to attempt to unify the query pattern with the conclusion of each rule. We find that the pattern unifies with the conclusion of the rule</p>
<p class="Sp-text-1"><a id="c4-para-2162"/>rule(lives_near($person_1, $person_2),</p>
<p class="Sp-text-1"><a id="c4-para-2163"/>     and(address($person_1, pair($town, $rest_1)),</p>
<p class="Sp-text-1"><a id="c4-para-2164"/>         address($person_2, list($town, $rest_2)),</p>
<p class="Sp-text-1"><a id="c4-para-2165"/>         not(same($person_1, $person_2))))</p>
<p class="paracontinue"><a id="c4-para-2166"/>resulting in a frame specifying that <span class="KeyTerm1">$x</span> should be bound to (have the same value as) <span class="KeyTerm1">$person_1</span> and that <span class="KeyTerm1">$person_2</span> is bound to <span class="KeyTerm1">list("Hacker", "Alyssa", "P")</span>. Now, relative to this frame, we evaluate the compound query given by the body of the rule. Successful matches will extend this frame by providing a binding for <span class="KeyTerm1">$person_1</span>, and consequently a value for <span class="KeyTerm1">$x</span>, which we can use to instantiate the original query pattern.</p>
<p><a id="c4-para-2167"/>In general, the query evaluator uses the following method to apply a rule when trying to establish a query pattern in a frame that specifies bindings for some of the pattern variables:</p>
<ul style="list-style-type:disc">
<li>Unify the query with the conclusion of the rule to form, if successful, an extension of the original frame.</li>
<li>Relative to the extended frame, evaluate the query formed by the body of the rule.</li>
</ul>

<p><a id="c4-para-2170"/>Notice how similar this is to the method for applying a function in the <span class="KeyTerm1">evaluate</span>/ <span class="KeyTerm1">apply</span> evaluator for JavaScript:</p>
<ul style="list-style-type:disc">
<li>Bind the function's parameters to its arguments to form a frame that extends the original function environment.</li>
<li>Relative to the extended environment, evaluate the expression formed by the body of the function.</li>
</ul>

<p class="paracontinue"><a id="c4-para-2173"/>The similarity between the two evaluators should come as no surprise. Just as function definitions are the means of abstraction in JavaScript, rule definitions are the means of abstraction in the query language. In each case, we unwind the abstraction by creating appropriate bindings and evaluating the rule or function body relative to these.</p>
</section>
<section>
<h5><a id="c4-sec-0134"/><a id="c4-title-0135"/>Simple queries</h5>
<p class="paraaftertitle"><a id="c4-para-2174"/>We saw earlier in this section how to evaluate simple queries in the absence of rules. Now that we have seen how to apply rules, we can describe how to evaluate simple queries by using both rules and assertions.</p>
<p><a id="c4-para-2175"/>Given the query pattern and a stream of frames, we produce, for each frame in the input stream, two streams:</p>
<ul style="list-style-type:disc">
<li>a stream of extended frames obtained by matching the pattern against all assertions in the data base (using the pattern matcher), and</li>
<li>a stream of extended frames obtained by applying all possible rules (using the unifier).<a id="c4-fn-0067a"/><a href="#c4-fn-0067"><sup>67</sup></a></li>
</ul>

<p class="paracontinue"><a id="c4-para-2178"/>Appending these two streams produces a stream that consists of all the ways that the given pattern can be satisfied consistent with the original frame. These streams (one for each frame in the input stream) are now all combined to form one large stream, which therefore consists of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern.</p>
</section>
<section>
<h5><a id="c4-sec-0135"/><a id="c4-title-0136"/>The query evaluator and the driver loop</h5>
<p class="paraaftertitle"><a id="c4-para-2179"/>Despite the complexity of the underlying matching operations, the system is organized much like an evaluator for any language. The function that coordinates the matching operations is called <span class="KeyTerm1">evaluate_query</span>, and it plays a role analogous to that of the <span class="KeyTerm1">evaluate</span> function for JavaScript. The function <span class="KeyTerm1">evaluate_query</span> takes as inputs a query and a stream of frames. Its output is a stream of frames, corresponding to successful matches to the query pattern, that extend some frame in the input stream, as indicated in <a href="#c4-fig-0005">figure 4.5</a>. Like <span class="KeyTerm1">evaluate</span>, <span class="KeyTerm1">evaluate_query</span> classifies the different types of expressions (queries) and dispatches to an appropriate function for each. There is a function for each syntactic form (<span class="KeyTerm1">and</span>, <span class="KeyTerm1">or</span>, <span class="KeyTerm1">not</span>, and <span class="KeyTerm1">javascript_predicate</span>) and one for simple queries.</p>
<p><a id="c4-para-2180"/>The driver loop, which is analogous to the <span class="KeyTerm1">driver_loop</span> function for the other evaluators in this chapter, reads queries typed by the user. For each query, it calls <span class="KeyTerm1">evaluate_query</span> with the query and a stream that consists of a single empty frame. This will produce the stream of all possible matches (all possible extensions to the empty frame). For each frame in the resulting stream, it instantiates the original query using the values of the variables found in the frame. This stream of instantiated queries is then printed.<a id="c4-fn-0068a"/><a href="#c4-fn-0068"><sup>68</sup></a></p>
<p><a id="c4-para-2181"/>The driver also checks for the special command <span class="KeyTerm1">assert</span>, which signals that the input is not a query but rather an assertion or rule to be added to the data base. For instance,</p>
<p class="Sp-text-1"><a id="c4-para-2182"/>assert(job(list("Bitdiddle", "Ben"), list("computer", "wizard")))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-2183"/>assert(rule(wheel($person),</p>
<p class="Sp-text-1"><a id="c4-para-2184"/>            and(supervisor($middle_manager, $person),</p>
<p class="Sp-text-1"><a id="c4-para-2185"/>                supervisor($x, $middle_manager))))</p>
</section>
</section>
<section>
<h3><a id="c4-sec-0136"/><span>4.4.3</span> <a id="c4-title-0137"/>Is Logic Programming Mathematical Logic?</h3>
<p class="paraaftertitle"><a id="c4-para-2186"/>The means of combination used in the query language may at first seem identical to the operations <span class="KeyTerm1">and</span>, <span class="KeyTerm1">or</span>, and <span class="KeyTerm1">not</span> of mathematical logic, and the application of querylanguage rules is in fact accomplished through a legitimate method of inference.<a id="c4-fn-0069a"/><a href="#c4-fn-0069"><sup>69</sup></a> This identification of the query language with mathematical logic is not really valid, though, because the query language provides a <i>control structure</i> that interprets the logical statements procedurally. We can often take advantage of this control structure. For example, to find all of the supervisors of programmers we could formulate a query in either of two logically equivalent forms:</p>
<p class="Sp-text-1"><a id="c4-para-2187"/>and(job($x, list("computer", "programmer")),</p>
<p class="Sp-text-1"><a id="c4-para-2188"/>    supervisor($x, $y))</p>
<p class="paracontinue"><a id="c4-para-2189"/>or</p>
<p class="Sp-text-1"><a id="c4-para-2190"/>and(supervisor($x, $y),</p>
<p class="Sp-text-1"><a id="c4-para-2191"/>    job($x, list("computer", "programmer")))</p>
<p class="paracontinue"><a id="c4-para-2192"/>If a company has many more supervisors than programmers, it is better to use the first form rather than the second, because the data base must be scanned for each intermediate result (frame) produced by the first clause of the <span class="KeyTerm1">and</span>.</p>
<p><a id="c4-para-2193"/>The aim of logic programming is to provide the programmer with techniques for decomposing a computational problem into two separate problems: “what” is to be computed, and “how” this should be computed. This is accomplished by selecting a subset of the statements of mathematical logic that is powerful enough to be able to describe anything one might want to compute, yet weak enough to have a controllable procedural interpretation. The intention here is that, on the one hand, a program specified in a logic programming language should be an effective program that can be carried out by a computer. Control (“how” to compute) is effected by using the order of evaluation of the language. We should be able to arrange the order of clauses and the order of subgoals within each clause so that the computation is done in an order deemed to be effective and efficient. At the same time, we should be able to view the result of the computation (“what” to compute) as a simple consequence of the laws of logic.</p>
<p><a id="c4-para-2194"/>Our query language can be regarded as just such a procedurally interpretable subset of mathematical logic. An assertion represents a simple fact (an atomic proposition). A rule represents the implication that the rule conclusion holds for those cases where the rule body holds. A rule has a natural procedural interpretation: To establish the conclusion of the rule, establish the body of the rule. Rules, therefore, specify computations. However, because rules can also be regarded as statements of mathematical logic, we can justify any “inference” accomplished by a logic program by asserting that the same result could be obtained by working entirely within mathematical logic.<a id="c4-fn-0070a"/><a href="#c4-fn-0070"><sup>70</sup></a></p>
<section>
<h5><a id="c4-sec-0137"/><a id="c4-title-0138"/>Infinite loops</h5>
<p class="paraaftertitle"><a id="c4-para-2195"/>A consequence of the procedural interpretation of logic programs is that it is possible to construct hopelessly inefficient programs for solving certain problems. An extreme case of inefficiency occurs when the system falls into infinite loops in making deductions. As a simple example, suppose we are setting up a data base of famous marriages, including</p>
<p class="Sp-text-1"><a id="c4-para-2196"/>assert(married("Minnie", "Mickey"))</p>
<p class="paracontinue"><a id="c4-para-2197"/>If we now ask</p>
<p class="Sp-text-1"><a id="c4-para-2198"/>married("Mickey", $who)</p>
<p class="paracontinue"><a id="c4-para-2199"/>we will get no response, because the system doesn't know that if <i>A</i> is married to <i>B</i>, then <i>B</i> is married to <i>A</i>. So we assert the rule</p>
<p class="Sp-text-1"><a id="c4-para-2200"/>assert(rule(married($x, $y),</p>
<p class="Sp-text-1"><a id="c4-para-2201"/>            married($y, $x)))</p>
<p class="paracontinue"><a id="c4-para-2202"/>and again query</p>
<p class="Sp-text-1"><a id="c4-para-2203"/>married("Mickey", $who)</p>
<p class="paracontinue"><a id="c4-para-2204"/>Unfortunately, this will drive the system into an infinite loop, as follows:</p>
<ul style="list-style-type:disc">
<li>The system finds that the <span class="KeyTerm1">married</span> rule is applicable; that is, the rule conclusion <span class="KeyTerm1">married($x, $y)</span> unifies with the query pattern <span class="KeyTerm1">married("Mickey", $who)</span> to produce a frame in which <span class="KeyTerm1">$x</span> is bound to <span class="KeyTerm1">"Mickey"</span> and <span class="KeyTerm1">$y</span> is bound to <span class="KeyTerm1">$who</span>. So the interpreter proceeds to evaluate the rule body <span class="KeyTerm1">married($y, $x)</span> in this frame—in effect, to process the query <span class="KeyTerm1">married($who, "Mickey")</span>.</li>
<li>One answer, <span class="KeyTerm1">married("Minnie", "Mickey")</span>, appears directly as an assertion in the data base.</li>
<li>The <span class="KeyTerm1">married</span> rule is also applicable, so the interpreter again evaluates the rule body, which this time is equivalent to <span class="KeyTerm1">married("Mickey", $who)</span>.</li>
</ul>

<p class="paracontinue"><a id="c4-para-2208"/>The system is now in an infinite loop. Indeed, whether the system will find the simple answer <span class="KeyTerm1">married("Minnie", "Mickey")</span> before it goes into the loop depends on implementation details concerning the order in which the system checks the items in the data base. This is a very simple example of the kinds of loops that can occur. Collections of interrelated rules can lead to loops that are much harder to anticipate, and the appearance of a loop can depend on the order of clauses in an <span class="KeyTerm1">and</span> (see exercise 4.62) or on low-level details concerning the order in which the system processes queries.<a id="c4-fn-0071a"/><a href="#c4-fn-0071"><sup>71</sup></a></p>
</section>
<section>
<h5><a id="c4-sec-0138"/><a id="c4-title-0139"/>Problems with <span class="KeyTerm1"><b>not</b></span></h5>
<p class="paraaftertitle"><a id="c4-para-2209"/>Another quirk in the query system concerns <span class="KeyTerm1">not</span>. Given the data base of section 4.4.1, consider the following two queries:</p>
<p class="Sp-text-1"><a id="c4-para-2210"/>and(supervisor($x, $y),</p>
<p class="Sp-text-1"><a id="c4-para-2211"/>    not(job($x, list("computer", "programmer"))))</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-2212"/>and(not(job($x, list("computer", "programmer"))),</p>
<p class="Sp-text-1"><a id="c4-para-2213"/>    supervisor($x, $y))</p>
<p class="paracontinue"><a id="c4-para-2214"/>These two queries do not produce the same result. The first query begins by finding all entries in the data base that match <span class="KeyTerm1">supervisor($x, $y)</span>, and then filters the resulting frames by removing the ones in which the value of <span class="KeyTerm1">$x</span> satisfies <span class="KeyTerm1">job($x, list("computer", "programmer"))</span>. The second query begins by filtering the incoming frames to remove those that can satisfy <span class="KeyTerm1">job($x, list("computer", "programmer"))</span>. Since the only incoming frame is empty, it checks the data base for patterns that satisfy <span class="KeyTerm1">job($x, list("computer", "programmer"))</span>. Since there generally are entries of this form, the <span class="KeyTerm1">not</span> clause filters out the empty frame and returns an empty stream of frames. Consequently, the entire compound query returns an empty stream.</p>
<p><a id="c4-para-2215"/>The trouble is that our implementation of <span class="KeyTerm1">not</span> really is meant to serve as a filter on values for the variables. If a <span class="KeyTerm1">not</span> clause is processed with a frame in which some of the variables remain unbound (as does <span class="KeyTerm1">$x</span> in the example above), the system will produce unexpected results. Similar problems occur with the use of <span class="KeyTerm1">javascript_predicate</span>—the JavaScript predicate can't work if some of its variables are unbound. See exercise 4.74.</p>
<p><a id="c4-para-2216"/>There is also a much more serious way in which the <span class="KeyTerm1">not</span> of the query language differs from the <span class="KeyTerm1">not</span> of mathematical logic. In logic, we interpret the statement “not <i>P</i>” to mean that <i>P</i> is not true. In the query system, however, “not <i>P</i>” means that <i>P</i> is not deducible from the knowledge in the data base. For example, given the personnel data base of section 4.4.1, the system would happily deduce all sorts of <span class="KeyTerm1">not</span> statements, such as that Ben Bitdiddle is not a baseball fan, that it is not raining outside, and that 2 + 2 is not 4.<a id="c4-fn-0072a"/><a href="#c4-fn-0072"><sup>72</sup></a> In other words, the <span class="KeyTerm1">not</span> of logic programming languages reflects the so-called <i>closed world assumption</i> that all relevant information has been included in the data base.<a id="c4-fn-0073a"/><a href="#c4-fn-0073"><sup>73</sup></a></p>
</section>
<section>
<h5><a id="c4-sec-0139"/><a id="c4-title-0140"/>Exercise 4.62</h5>
<p class="paraaftertitle"><a id="c4-para-2217"/>Louis Reasoner mistakenly deletes the <span class="KeyTerm1">outranked_by</span> rule (section 4.4.1) from the data base. When he realizes this, he quickly reinstalls it. Unfortunately, he makes a slight change in the rule, and types it in as</p>
<p class="Sp-text-1"><a id="c4-para-2218"/>rule(outranked_by($staff_person, $boss),</p>
<p class="Sp-text-1"><a id="c4-para-2219"/>     or(supervisor($staff_person, $boss),</p>
<p class="Sp-text-1"><a id="c4-para-2220"/>        and(outranked_by($middle_manager, $boss),</p>
<p class="Sp-text-1"><a id="c4-para-2221"/>            supervisor($staff_person, $middle_manager))))</p>
<p class="paracontinue"><a id="c4-para-2222"/>Just after Louis types this information into the system, DeWitt Aull comes by to find out who outranks Ben Bitdiddle. He issues the query</p>
<p class="Sp-text-1"><a id="c4-para-2223"/>outanked_by(list("Bitdiddle", "Ben"), $who)</p>
<p class="paracontinue"><a id="c4-para-2224"/>After answering, the system goes into an infinite loop. Explain why.</p>
</section>
<section>
<h5><a id="c4-sec-0140"/><a id="c4-title-0141"/>Exercise 4.63</h5>
<p class="paraaftertitle"><a id="c4-para-2225"/>Cy D. Fect, looking forward to the day when he will rise in the organization, gives a query to find all the wheels (using the <span class="KeyTerm1">wheel</span> rule of section 4.4.1):</p>
<p class="Sp-text-1"><a id="c4-para-2226"/>wheel($who)</p>
<p class="paracontinue"><a id="c4-para-2227"/>To his surprise, the system responds</p>
<p class="Sp-text-3"><a id="c4-para-2228"/><i>Query results:</i></p>
<p class="Sp-text-3"><a id="c4-para-2229"/><i>wheel(list("Warbucks", "Oliver"))</i></p>
<p class="Sp-text-3"><a id="c4-para-2230"/><i>wheel(list("Bitdiddle", "Ben"))</i></p>
<p class="Sp-text-3"><a id="c4-para-2231"/><i>wheel(list("Warbucks", "Oliver"))</i></p>
<p class="Sp-text-3"><a id="c4-para-2232"/><i>wheel(list("Warbucks", "Oliver"))</i></p>
<p class="Sp-text-3"><a id="c4-para-2233"/><i>wheel(list("Warbucks", "Oliver"))</i></p>
<p class="paracontinue"><a id="c4-para-2234"/>Why is Oliver Warbucks listed four times?</p>
</section>
<section>
<h5><a id="c4-sec-0141"/><a id="c4-title-0142"/>Exercise 4.64</h5>
<p class="paraaftertitle"><a id="c4-para-2235"/>Ben has been generalizing the query system to provide statistics about the company. For example, to find the total salaries of all the computer programmers one will be able to say</p>
<p class="Sp-text-1"><a id="c4-para-2236"/>sum($amount,</p>
<p class="Sp-text-1"><a id="c4-para-2237"/>    and(job($x, list("computer", "programmer")),</p>
<p class="Sp-text-1"><a id="c4-para-2238"/>        salary($x, $amount)))</p>
<p class="paracontinue"><a id="c4-para-2239"/>In general, Ben's new system allows expressions of the form</p>
<p class="Sp-text-1"><a id="c4-para-2240"/>accumulation_function(<span class="KeyTerm2"><i>variable</i></span>,</p>
<p class="Sp-text-1"><a id="c4-para-2241"/>                      <span class="KeyTerm2"><i>query</i>-<i>pattern</i></span>)</p>
<p class="paracontinue"><a id="c4-para-2242"/>where <span class="KeyTerm1">accumulation_function</span> can be things like <span class="KeyTerm1">sum</span>, <span class="KeyTerm1">average</span>, or <span class="KeyTerm1">maximum</span>. Ben reasons that it should be a cinch to implement this. He will simply feed the query pattern to <span class="KeyTerm1">evaluate_query</span>. This will produce a stream of frames. He will then pass this stream through a mapping function that extracts the value of the designated variable from each frame in the stream and feed the resulting stream of values to the accumulation function. Just as Ben completes the implementation and is about to try it out, Cy walks by, still puzzling over the <span class="KeyTerm1">wheel</span> query result in exercise 4.63. When Cy shows Ben the system's response, Ben groans, “Oh, no, my simple accumulation scheme won't work!”</p>
<p><a id="c4-para-2243"/>What has Ben just realized? Outline a method he can use to salvage the situation.</p>
</section>
<section>
<h5><a id="c4-sec-0142"/><a id="c4-title-0143"/>Exercise 4.65</h5>
<p class="paraaftertitle"><a id="c4-para-2244"/>Devise a way to install a loop detector in the query system so as to avoid the kinds of simple loops illustrated in the text and in exercise 4.62. The general idea is that the system should maintain some sort of history of its current chain of deductions and should not begin processing a query that it is already working on. Describe what kind of information (patterns and frames) is included in this history, and how the check should be made. (After you study the details of the query-system implementation in section 4.4.4, you may want to modify the system to include your loop detector.)</p>
</section>
<section>
<h5><a id="c4-sec-0143"/><a id="c4-title-0144"/>Exercise 4.66</h5>
<p class="paraaftertitle"><a id="c4-para-2245"/>Define rules to implement the <span class="KeyTerm1">reverse</span> operation of exercise 2.18, which returns a list containing the same elements as a given list in reverse order. (Hint: Use <span class="KeyTerm1">append_to_form</span>.) Can your rules answer both the query <span class="KeyTerm1">reverse(list(1, 2, 3), $x)</span> and the query <span class="KeyTerm1">reverse($x, list(1, 2, 3))</span>?</p>
</section>
<section>
<h5><a id="c4-sec-0144"/><a id="c4-title-0145"/>Exercise 4.67</h5>
<p class="paraaftertitle"><a id="c4-para-2246"/>Let us modify the data base and the rules of exercise 4.61 to add “great” to a grandson relationship. This should enable the system to deduce that Irad is the great-grandson of Adam, or that Jabal and Jubal are the great-great-great-great-great-grandsons of Adam.</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0099"/><span>a. </span>Change the assertions in the data base such that there is only one kind of relationship information, namely <span class="KeyTerm1">related</span>. The first item then describes the relationship. Thus, instead of <span class="KeyTerm1">son("Adam", "Cain")</span>, you would write <span class="KeyTerm1">related("son", "Adam", "Cain")</span>. Represent the fact about Irad, for example, as
<p class="paracontinue"><a id="c4-para-2248"/>related(list("great", "grandson"), "Adam", "Irad")</p></li>
<li><a id="c4-li-0100"/><span>b. </span>Write rules that determine if a list ends in the word <span class="KeyTerm1">"grandson"</span>.</li>
<li><a id="c4-li-0101"/><span>c. </span>Use this to express a rule that allows one to derive the relationship
<p class="paracontinue"><a id="c4-para-2251"/>list(pair("great", $rel), $x, $y)</p>
<p class="paracontinue"><a id="c4-para-2252"/>where <span class="KeyTerm1">$rel</span> is a list ending in <span class="KeyTerm1">"grandson"</span>.</p></li>
<li><a id="c4-li-0102"/><span>d. </span>Check your rules on the queries <span class="KeyTerm1">related(list("great", "grandson"), $g, $ggs)</span> and <span class="KeyTerm1">related($relationship, "Adam", "Irad")</span>.</li>
</ol>
</section>
</section>
<section>
<h3><a id="c4-sec-0145"/><span>4.4.4</span> <a id="c4-title-0146"/>Implementing the Query System</h3>
<p class="paraaftertitle"><a id="c4-para-2254"/>Section 4.4.2 described how the query system works. Now we fill in the details by presenting a complete implementation of the system.</p>
<section>
<h4><a id="c4-sec-0146"/><span>4.4.4.1</span> <a id="c4-title-0147"/>The Driver Loop</h4>
<p class="paraaftertitle"><a id="c4-para-2255"/>The driver loop for the query system repeatedly reads input expressions. If the expression is a rule or assertion to be added to the data base, then the information is added. Otherwise the expression is assumed to be a query. The driver passes this query to <span class="KeyTerm1">evaluate_query</span> together with an initial frame stream consisting of a single empty frame. The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base. These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is displayed:</p>
<p class="Sp-text-1"><a id="c4-para-2256"/><b>const</b> input_prompt = "Query input:";</p>
<p class="Sp-text-1"><a id="c4-para-2257"/><b>const</b> output_prompt = "Query results:";</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-2258"/><b>function</b> query_driver_loop() {</p>
<p class="Sp-text-1"><a id="c4-para-2259"/>    <b>const</b> input = user_read(input_prompt) + ";";</p>
<p class="Sp-text-1"><a id="c4-para-2260"/>    <b>if</b> (is_null(input)) {</p>
<p class="Sp-text-1"><a id="c4-para-2261"/>        display("evaluator terminated");</p>
<p class="Sp-text-1"><a id="c4-para-2262"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-2263"/>        <b>const</b> expression = parse(input);</p>
<p class="Sp-text-1"><a id="c4-para-2264"/>        <b>const</b> query = convert_to_query_syntax(expression);</p>
<p class="Sp-text-1"><a id="c4-para-2265"/>        <b>if</b> (is_assertion(query)) {</p>
<p class="Sp-text-1"><a id="c4-para-2266"/>            add_rule_or_assertion(assertion_body(query));</p>
<p class="Sp-text-1"><a id="c4-para-2267"/>            display("Assertion added to data base.");</p>
<p class="Sp-text-1"><a id="c4-para-2268"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-2269"/>            display(output_prompt);</p>
<p class="Sp-text-1"><a id="c4-para-2270"/>            display_stream(</p>
<p class="Sp-text-1"><a id="c4-para-2271"/>              stream_map(</p>
<p class="Sp-text-1"><a id="c4-para-2272"/>                 frame =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-2273"/>                   unparse(instantiate_expression(expression, frame)),</p>
<p class="Sp-text-1"><a id="c4-para-2274"/>                 evaluate_query(query, singleton_stream(<b>null</b>))));</p>
<p class="Sp-text-1"><a id="c4-para-2275"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-2276"/>        <b>return</b> query_driver_loop();</p>
<p class="Sp-text-1"><a id="c4-para-2277"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-2278"/>}</p>
<p class="paracontinue"><a id="c4-para-2279"/>Here, as in the other evaluators in this chapter, we use <span class="KeyTerm1">parse</span> to transform a component of the query language given as a string into a JavaScript syntax representation. (We append a semicolon to the input expression string because <span class="KeyTerm1">parse</span> expects a statement.) Then we further transform the syntax representation to a conceptual level appropriate for the query system using <span class="KeyTerm1">convert_to_query_syntax</span>, which is declared in section 4.4.4.7 along with the predicate <span class="KeyTerm1">is_assertion</span> and the selector <span class="KeyTerm1">assertion_body</span>. The function <span class="KeyTerm1">add_rule_or_assertion</span> is declared in section 4.4.4.5. The frames resulting from query evaluation are used to instantiate the syntax representation, and the result is unparsed into a string for display. The functions <span class="KeyTerm1">instantiate_expression</span> and <span class="KeyTerm1">unparse</span> are declared in section 4.4.4.7.</p>
</section>
<section>
<h4><a id="c4-sec-0147"/><span>4.4.4.2</span> <a id="c4-title-0148"/>The Evaluator</h4>
<p class="paraaftertitle"><a id="c4-para-2280"/>The <span class="KeyTerm1">evaluate_query</span> function, called by the <span class="KeyTerm1">query_driver_loop</span>, is the basic evaluator of the query system. It takes as inputs a query and a stream of frames, and it returns a stream of extended frames. It identifies syntactic forms by a data-directed dispatch using <span class="KeyTerm1">get</span> and <span class="KeyTerm1">put</span>, just as we did in implementing generic operations in chapter 2. Any query that is not identified as a syntactic form is assumed to be a simple query, to be processed by <span class="KeyTerm1">simple_query</span>.</p>
<p class="Sp-text-1"><a id="c4-para-2281"/><b>function</b> evaluate_query(query, frame_stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2282"/>    <b>const</b> qfun = get(type(query), "evaluate_query");</p>
<p class="Sp-text-1"><a id="c4-para-2283"/>    <b>return</b> is_undefined(qfun)</p>
<p class="Sp-text-1"><a id="c4-para-2284"/>           ? simple_query(query, frame_stream)</p>
<p class="Sp-text-1"><a id="c4-para-2285"/>           : qfun(contents(query), frame_stream);</p>
<p class="Sp-text-1"><a id="c4-para-2286"/>}</p>
<p class="paracontinue"><a id="c4-para-2287"/>The functions <span class="KeyTerm1">type</span> and <span class="KeyTerm1">contents</span>, defined in section 4.4.4.7, implement the abstract syntax of the syntactic forms.</p>
</section>
<section>
<h5><a id="c4-sec-0148"/><a id="c4-title-0149"/>Simple queries</h5>
<p class="paraaftertitle"><a id="c4-para-2288"/>The <span class="KeyTerm1">simple_query</span> function handles simple queries. It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query.</p>
<p class="Sp-text-1"><a id="c4-para-2289"/><b>function</b> simple_query(query_pattern, frame_stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2290"/>    <b>return</b> stream_flatmap(</p>
<p class="Sp-text-1"><a id="c4-para-2291"/>               frame =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-2292"/>                 stream_append_delayed(</p>
<p class="Sp-text-1"><a id="c4-para-2293"/>                     find_assertions(query_pattern, frame),</p>
<p class="Sp-text-1"><a id="c4-para-2294"/>                     () =&gt; apply_rules(query_pattern, frame)),</p>
<p class="Sp-text-1"><a id="c4-para-2295"/>               frame_stream);</p>
<p class="Sp-text-1"><a id="c4-para-2296"/>}</p>
<p><a id="c4-para-2297"/>For each frame in the input stream, we use <span class="KeyTerm1">find_assertions</span> (section 4.4.4.3) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use <span class="KeyTerm1">apply_rules</span> (section 4.4.4.4) to apply all possible rules, producing another stream of extended frames. These two streams are combined (using <span class="KeyTerm1">stream_append_delayed</span>, section 4.4.4.6) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see exercise 4.68). The streams for the individual input frames are combined using <span class="KeyTerm1">stream_flatmap</span> (section 4.4.4.6) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern.</p>
</section>
<section>
<h5><a id="c4-sec-0149"/><a id="c4-title-0150"/>Compound queries</h5>
<p class="paraaftertitle"><a id="c4-para-2298"/>We handle <span class="KeyTerm1">and</span> queries as illustrated in <a href="#c4-fig-0006">figure 4.6</a> with the <span class="KeyTerm1">conjoin</span> function, which takes as inputs the conjuncts and the frame stream and returns the stream of extended frames. First, <span class="KeyTerm1">conjoin</span> processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction. Then, using this as the new frame stream, it recursively applies <span class="KeyTerm1">conjoin</span> to the rest of the queries.</p>
<p class="Sp-text-1"><a id="c4-para-2299"/><b>function</b> conjoin(conjuncts, frame_stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2300"/>    <b>return</b> is_empty_conjunction(conjuncts)</p>
<p class="Sp-text-1"><a id="c4-para-2301"/>           ? frame_stream</p>
<p class="Sp-text-1"><a id="c4-para-2302"/>           : conjoin(rest_conjuncts(conjuncts),</p>
<p class="Sp-text-1"><a id="c4-para-2303"/>                     evaluate_query(first_conjunct(conjuncts),</p>
<p class="Sp-text-1"><a id="c4-para-2304"/>                                    frame_stream));</p>
<p class="Sp-text-1"><a id="c4-para-2305"/>}</p>
<p class="paracontinue"><a id="c4-para-2306"/>The statement</p>
<p class="Sp-text-1"><a id="c4-para-2307"/>put("and", "evaluate_query", conjoin);</p>
<p class="paracontinue"><a id="c4-para-2308"/>sets up <span class="KeyTerm1">evaluate_query</span> to dispatch to <span class="KeyTerm1">conjoin</span> when an <span class="KeyTerm1">and</span> is encountered.</p>
<p><a id="c4-para-2309"/>We handle <span class="KeyTerm1">or</span> queries similarly, as shown in <a href="#c4-fig-0007">figure 4.7</a>. The output streams for the various disjuncts of the <span class="KeyTerm1">or</span> are computed separately and merged using the <span class="KeyTerm1">interleave_delayed</span> function from section 4.4.4.6. (See exercises 4.68 and 4.69.)</p>
<p class="Sp-text-1"><a id="c4-para-2310"/><b>function</b> disjoin(disjuncts, frame_stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2311"/>    <b>return</b> is_empty_disjunction(disjuncts)</p>
<p class="Sp-text-1"><a id="c4-para-2312"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c4-para-2313"/>           : interleave_delayed(</p>
<p class="Sp-text-1"><a id="c4-para-2314"/>                evaluate_query(first_disjunct(disjuncts), frame_stream),</p>
<p class="Sp-text-1"><a id="c4-para-2315"/>                () =&gt; disjoin(rest_disjuncts(disjuncts), frame_stream));</p>
<p class="Sp-text-1"><a id="c4-para-2316"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2317"/>put("or", "evaluate_query", disjoin);</p>
<p><a id="c4-para-2318"/>The predicates and selectors for the representation of conjuncts and disjuncts are given in section 4.4.4.7.</p>
</section>
<section>
<h5><a id="c4-sec-0150"/><a id="c4-title-0151"/>Filters</h5>
<p class="paraaftertitle"><a id="c4-para-2319"/>The <span class="KeyTerm1">not</span> syntactic form is handled by the method outlined in section 4.4.2. We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended.</p>
<p class="Sp-text-1"><a id="c4-para-2320"/><b>function</b> negate(exps, frame_stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2321"/>    <b>return</b> stream_flatmap(</p>
<p class="Sp-text-1"><a id="c4-para-2322"/>               frame =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-2323"/>                 is_null(evaluate_query(negated_query(exps),</p>
<p class="Sp-text-1"><a id="c4-para-2324"/>                                        singleton_stream(frame)))</p>
<p class="Sp-text-1"><a id="c4-para-2325"/>                 ? singleton_stream(frame)</p>
<p class="Sp-text-1"><a id="c4-para-2326"/>                 : <b>null</b>, frame_stream);</p>
<p class="Sp-text-1"><a id="c4-para-2327"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2328"/>put("not", "evaluate_query", negate);</p>
<p><a id="c4-para-2329"/>The <span class="KeyTerm1">javascript_predicate</span> syntactic form is a filter similar to <span class="KeyTerm1">not</span>. Each frame in the stream is used to instantiate the variables in the predicate, the instantiated predicate is evaluated, and the frames for which the predicate evaluates to false are filtered out of the input stream. The instantiated predicate is evaluated using <span class="KeyTerm1">evaluate</span> from section 4.1 with <span class="KeyTerm1">the_global_environment</span> and thus can handle any JavaScript expression, as long as all pattern variables are instantiated prior to evaluation.</p>
<p class="Sp-text-1"><a id="c4-para-2330"/><b>function</b> javascript_predicate(exps, frame_stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2331"/>    <b>return</b> stream_flatmap(</p>
<p class="Sp-text-1"><a id="c4-para-2332"/>               frame =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-2333"/>                 evaluate(instantiate_expression(</p>
<p class="Sp-text-1"><a id="c4-para-2334"/>                              javascript_predicate_expression(exps),</p>
<p class="Sp-text-1"><a id="c4-para-2335"/>                              frame),</p>
<p class="Sp-text-1"><a id="c4-para-2336"/>                          the_global_environment)</p>
<p class="Sp-text-1"><a id="c4-para-2337"/>                 ? singleton_stream(frame)</p>
<p class="Sp-text-1"><a id="c4-para-2338"/>                 : <b>null</b>,</p>
<p class="Sp-text-1"><a id="c4-para-2339"/>               frame_stream);</p>
<p class="Sp-text-1"><a id="c4-para-2340"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2341"/>put("javascript_predicate", "evaluate_query", javascript_predicate);</p>
<p><a id="c4-para-2342"/>The <span class="KeyTerm1">always_true</span> syntactic form provides for a query that is always satisfied. It ignores its contents (normally empty) and simply passes through all the frames in the input stream. The <span class="KeyTerm1">rule_body</span> selector (section 4.4.4.7) uses <span class="KeyTerm1">always_true</span> to provide bodies for rules that were defined without bodies (that is, rules whose bodies are always satisfied).</p>
<p class="Sp-text-1"><a id="c4-para-2343"/><b>function</b> always_true(ignore, frame_stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2344"/>    <b>return</b> frame_stream;</p>
<p class="Sp-text-1"><a id="c4-para-2345"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2346"/>put("always_true", "evaluate_query", always_true);</p>
<p class="paracontinue"><a id="c4-para-2347"/>The selectors that define the syntax of <span class="KeyTerm1">not</span> and <span class="KeyTerm1">javascript_predicate</span> are given in section 4.4.4.7.</p>
</section>
<section>
<h4><a id="c4-sec-0151"/><span>4.4.4.3</span> <a id="c4-title-0152"/>Finding Assertions by Pattern Matching</h4>
<p class="paraaftertitle"><a id="c4-para-2348"/>The function <span class="KeyTerm1">find_assertions</span>, called by <span class="KeyTerm1">simple_query</span> (section 4.4.4.2), takes as input a pattern and a frame. It returns a stream of frames, each extending the given one by a data-base match of the given pattern. It uses <span class="KeyTerm1">fetch_assertions</span> (section 4.4.4.5) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame. The reason for <span class="KeyTerm1">fetch_ assertions</span> here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match. The system would still work if we eliminated <span class="KeyTerm1">fetch_assertions</span> and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher.</p>
<p class="Sp-text-1"><a id="c4-para-2349"/><b>function</b> find_assertions(pattern, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2350"/>    <b>return</b> stream_flatmap(</p>
<p class="Sp-text-1"><a id="c4-para-2351"/>                datum =&gt; check_an_assertion(datum, pattern, frame),</p>
<p class="Sp-text-1"><a id="c4-para-2352"/>                fetch_assertions(pattern, frame));</p>
<p class="Sp-text-1"><a id="c4-para-2353"/>}</p>
<p><a id="c4-para-2354"/>The function <span class="KeyTerm1">check_an_assertion</span> takes as arguments a data object (an assertion), a pattern, and a frame and returns either a one-element stream containing the extended frame or <span class="KeyTerm1"><b>null</b></span> if the match fails.</p>
<p class="Sp-text-1"><a id="c4-para-2355"/><b>function</b> check_an_assertion(assertion, query_pat, query_frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2356"/>    <b>const</b> match_result = pattern_match(query_pat, assertion,</p>
<p class="Sp-text-1"><a id="c4-para-2357"/>                                       query_frame);</p>
<p class="Sp-text-1"><a id="c4-para-2358"/>    <b>return</b> match_result === "failed"</p>
<p class="Sp-text-1"><a id="c4-para-2359"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c4-para-2360"/>           : singleton_stream(match_result);</p>
<p class="Sp-text-1"><a id="c4-para-2361"/>}</p>
<p class="paracontinue"><a id="c4-para-2362"/>The basic pattern matcher returns either the string <span class="KeyTerm1">"failed"</span> or an extension of the given frame. The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables. If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far. Otherwise, if the pattern is a variable (checked by the function <span class="KeyTerm1">is_variable</span> declared in section 4.4.4.7) we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame. If the pattern and the data are both pairs, we (recursively) match the head of the pattern against the head of the data to produce a frame; in this frame we then match the tail of the pattern against the tail of the data. If none of these cases are applicable, the match fails and we return the string <span class="KeyTerm1">"failed"</span>.</p>
<p class="Sp-text-1"><a id="c4-para-2363"/><b>function</b> pattern_match(pattern, data, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2364"/>    <b>return</b> frame === "failed"</p>
<p class="Sp-text-1"><a id="c4-para-2365"/>           ? "failed"</p>
<p class="Sp-text-1"><a id="c4-para-2366"/>           : equal(pattern, data)</p>
<p class="Sp-text-1"><a id="c4-para-2367"/>           ? frame</p>
<p class="Sp-text-1"><a id="c4-para-2368"/>           : is_variable(pattern)</p>
<p class="Sp-text-1"><a id="c4-para-2369"/>           ? extend_if_consistent(pattern, data, frame)</p>
<p class="Sp-text-1"><a id="c4-para-2370"/>           : is_pair(pattern) &amp;&amp; is_pair(data)</p>
<p class="Sp-text-1"><a id="c4-para-2371"/>           ? pattern_match(tail(pattern),</p>
<p class="Sp-text-1"><a id="c4-para-2372"/>                           tail(data),</p>
<p class="Sp-text-1"><a id="c4-para-2373"/>                           pattern_match(head(pattern),</p>
<p class="Sp-text-1"><a id="c4-para-2374"/>                                         head(data),</p>
<p class="Sp-text-1"><a id="c4-para-2375"/>                                         frame))</p>
<p class="Sp-text-1"><a id="c4-para-2376"/>           : "failed";</p>
<p class="Sp-text-1"><a id="c4-para-2377"/>}</p>
<p><a id="c4-para-2378"/>Here is the function that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame:</p>
<p class="Sp-text-1"><a id="c4-para-2379"/><b>function</b> extend_if_consistent(variable, data, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2380"/>    <b>const</b> binding = binding_in_frame(variable, frame);</p>
<p class="Sp-text-1"><a id="c4-para-2381"/>    <b>return</b> is_undefined(binding)</p>
<p class="Sp-text-1"><a id="c4-para-2382"/>           ? extend(variable, data, frame)</p>
<p class="Sp-text-1"><a id="c4-para-2383"/>           : pattern_match(binding_value(binding), data, frame);</p>
<p class="Sp-text-1"><a id="c4-para-2384"/>}</p>
<p class="paracontinue"><a id="c4-para-2385"/>If there is no binding for the variable in the frame, we simply add the binding of the variable to the data. Otherwise we match, in the frame, the data against the value of the variable in the frame. If the stored value contains only constants, as it must if it was stored during pattern matching by <span class="KeyTerm1">extend_if_consistent</span>, then the match simply tests whether the stored and new values are the same. If so, it returns the unmodified frame; if not, it returns a failure indication. The stored value may, however, contain pattern variables if it was stored during unification (see section 4.4.4.4). The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern. For example, suppose we have a frame in which <span class="KeyTerm1">$x</span> is bound to <span class="KeyTerm1">list("f", $y)</span> and <span class="KeyTerm1">$y</span> is unbound, and we wish to augment this frame by a binding of <span class="KeyTerm1">$x</span> to <span class="KeyTerm1">list("f", "b")</span>. We look up <span class="KeyTerm1">$x</span> and find that it is bound to <span class="KeyTerm1">list("f", $y)</span>. This leads us to match <span class="KeyTerm1">list("f", $y)</span> against the proposed new value <span class="KeyTerm1">list("f", "b")</span> in the same frame. Eventually this match extends the frame by adding a binding of <span class="KeyTerm1">$y</span> to <span class="KeyTerm1">"b"</span>. The variable <span class="KeyTerm1">$x</span> remains bound to <span class="KeyTerm1">list("f", $y)</span>. We never modify a stored binding and we never store more than one binding for a given variable.</p>
<p><a id="c4-para-2386"/>The functions used by <span class="KeyTerm1">extend_if_consistent</span> to manipulate bindings are defined in section 4.4.4.8.</p>
</section>
<section>
<h4><a id="c4-sec-0152"/><span>4.4.4.4</span> <a id="c4-title-0153"/>Rules and Unification</h4>
<p class="paraaftertitle"><a id="c4-para-2387"/>The function <span class="KeyTerm1">apply_rules</span> is the rule analog of <span class="KeyTerm1">find_assertions</span> (section 4.4.4.3). It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base. The function <span class="KeyTerm1">stream_flatmap</span> maps <span class="KeyTerm1">apply_a_ rule</span> down the stream of possibly applicable rules (selected by <span class="KeyTerm1">fetch_rules</span>, section 4.4.4.5) and combines the resulting streams of frames.</p>
<p class="Sp-text-1"><a id="c4-para-2388"/><b>function</b> apply_rules(pattern, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2389"/>    <b>return</b> stream_flatmap(rule =&gt; apply_a_rule(rule, pattern, frame),</p>
<p class="Sp-text-1"><a id="c4-para-2390"/>                          fetch_rules(pattern, frame));</p>
<p class="Sp-text-1"><a id="c4-para-2391"/>}</p>
<p><a id="c4-para-2392"/>The function <span class="KeyTerm1">apply_a_rule</span> applies a rule using the method outlined in section 4.4.2. It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame. If this succeeds, it evaluates the rule body in this new frame.</p>
<p><a id="c4-para-2393"/>Before any of this happens, however, the program renames all the variables in the rule with unique new names. The reason for this is to prevent the variables for different rule applications from becoming confused with each other. For instance, if two rules both use a variable named <span class="KeyTerm1">$x</span>, then each one may add a binding for <span class="KeyTerm1">$x</span> to the frame when it is applied. These two <span class="KeyTerm1">$x</span>'s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent. Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient. (See exercise 4.76.) Here is the <span class="KeyTerm1">apply_a_rule</span> function:</p>
<p class="Sp-text-1"><a id="c4-para-2394"/><b>function</b> apply_a_rule(rule, query_pattern, query_frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2395"/>    <b>const</b> clean_rule = rename_variables_in(rule);</p>
<p class="Sp-text-1"><a id="c4-para-2396"/>    <b>const</b> unify_result = unify_match(query_pattern,</p>
<p class="Sp-text-1"><a id="c4-para-2397"/>                                     conclusion(clean_rule),</p>
<p class="Sp-text-1"><a id="c4-para-2398"/>                                     query_frame);</p>
<p class="Sp-text-1"><a id="c4-para-2399"/>    <b>return</b> unify_result === "failed"</p>
<p class="Sp-text-1"><a id="c4-para-2400"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c4-para-2401"/>           : evaluate_query(rule_body(clean_rule),</p>
<p class="Sp-text-1"><a id="c4-para-2402"/>                            singleton_stream(unify_result));</p>
<p class="Sp-text-1"><a id="c4-para-2403"/>}</p>
<p class="paracontinue"><a id="c4-para-2404"/>The selectors <span class="KeyTerm1">rule_body</span> and <span class="KeyTerm1">conclusion</span> that extract parts of a rule are defined in section 4.4.4.7.</p>
<p><a id="c4-para-2405"/>We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names. For example, if the rule-application identifier is 7, we might change each <span class="KeyTerm1">$x</span> in the rule to <span class="KeyTerm1">$x_7</span> and each <span class="KeyTerm1">$y</span> in the rule to <span class="KeyTerm1">$y_7</span>. (The functions <span class="KeyTerm1">make_new_variable</span> and <span class="KeyTerm1">new_rule_application_id</span> are included with the syntax functions in section 4.4.4.7.)</p>
<p class="Sp-text-1"><a id="c4-para-2406"/><b>function</b> rename_variables_in(rule) {</p>
<p class="Sp-text-1"><a id="c4-para-2407"/>    <b>const</b> rule_application_id = new_rule_application_id();</p>
<p class="Sp-text-1"><a id="c4-para-2408"/>    <b>function</b> tree_walk(exp) {</p>
<p class="Sp-text-1"><a id="c4-para-2409"/>        <b>return</b> is_variable(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2410"/>               ? make_new_variable(exp, rule_application_id)</p>
<p class="Sp-text-1"><a id="c4-para-2411"/>               : is_pair(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2412"/>               ? pair(tree_walk(head(exp)),</p>
<p class="Sp-text-1"><a id="c4-para-2413"/>                      tree_walk(tail(exp)))</p>
<p class="Sp-text-1"><a id="c4-para-2414"/>               : exp;</p>
<p class="Sp-text-1"><a id="c4-para-2415"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-2416"/>    <b>return</b> tree_walk(rule);</p>
<p class="Sp-text-1"><a id="c4-para-2417"/>}</p>
<p><a id="c4-para-2418"/>The unification algorithm is implemented as a function that takes as inputs two patterns and a frame and returns either the extended frame or the string <span class="KeyTerm1">"failed"</span>. The unifier is like the pattern matcher except that it is symmetrical—variables are allowed on both sides of the match. The function <span class="KeyTerm1">unify_match</span> is basically the same as <span class="KeyTerm1">pattern_match</span>, except that there is an extra clause (marked “***” below) to handle the case where the object on the right side of the match is a variable.</p>
<p class="Sp-text-1"><a id="c4-para-2419"/><b>function</b> unify_match(p1, p2, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2420"/>    <b>return</b> frame === "failed"</p>
<p class="Sp-text-1"><a id="c4-para-2421"/>           ? "failed"</p>
<p class="Sp-text-1"><a id="c4-para-2422"/>           : equal(p1, p2)</p>
<p class="Sp-text-1"><a id="c4-para-2423"/>           ? frame</p>
<p class="Sp-text-1"><a id="c4-para-2424"/>           : is_variable(p1)</p>
<p class="Sp-text-1"><a id="c4-para-2425"/>           ? extend_if_possible(p1, p2, frame)</p>
<p class="Sp-text-1"><a id="c4-para-2426"/>           : is_variable(p2) <i>//</i> ***</p>
<p class="Sp-text-1"><a id="c4-para-2427"/>           ? extend_if_possible(p2, p1, frame) <i>//</i> ***</p>
<p class="Sp-text-1"><a id="c4-para-2428"/>           : is_pair(p1) &amp;&amp; is_pair(p2)</p>
<p class="Sp-text-1"><a id="c4-para-2429"/>           ? unify_match(tail(p1),</p>
<p class="Sp-text-1"><a id="c4-para-2430"/>                         tail(p2),</p>
<p class="Sp-text-1"><a id="c4-para-2431"/>                         unify_match(head(p1),</p>
<p class="Sp-text-1"><a id="c4-para-2432"/>                                     head(p2),</p>
<p class="Sp-text-1"><a id="c4-para-2433"/>                                     frame))</p>
<p class="Sp-text-1"><a id="c4-para-2434"/>           : "failed";</p>
<p class="Sp-text-1"><a id="c4-para-2435"/>}</p>
<p><a id="c4-para-2436"/>In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings. The function <span class="KeyTerm1">extend_if_possible</span> used in unification is the same as the function <span class="KeyTerm1">extend_if_consistent</span> used in pattern matching except for two special checks, marked “***” in the program below. In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value. If both parties to the match are unbound, we may bind either to the other.</p>
<p><a id="c4-para-2437"/>The second check deals with attempts to bind a variable to a pattern that includes that variable. Such a situation can occur whenever a variable is repeated in both patterns. Consider, for example, unifying the two patterns <span class="KeyTerm1">list($x, $x)</span> and <span class="KeyTerm1">list($y,</span> <i>expression involving</i> <span class="KeyTerm1">$y )</span> in a frame where both <span class="KeyTerm1">$x</span> and <span class="KeyTerm1">$y</span> are unbound. First <span class="KeyTerm1">$x</span> is matched against <span class="KeyTerm1">$y</span>, making a binding of <span class="KeyTerm1">$x</span> to <span class="KeyTerm1">$y</span>. Next, the same <span class="KeyTerm1">$x</span> is matched against the given expression involving <span class="KeyTerm1">$y</span>. Since <span class="KeyTerm1">$x</span> is already bound to <span class="KeyTerm1">$y</span>, this results in matching <span class="KeyTerm1">$y</span> against the expression. If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a <span class="KeyTerm1">$y</span> such that <span class="KeyTerm1">$y</span> is equal to the expression involving <span class="KeyTerm1">$y</span>. We reject such bindings; these cases are recognized by the predicate <span class="KeyTerm1">depends_on</span>.<a id="c4-fn-0074a"/><a href="#c4-fn-0074"><sup>74</sup></a> On the other hand, we do not want to reject attempts to bind a variable to itself. For example, consider unifying <span class="KeyTerm1">list($x, $x)</span> and <span class="KeyTerm1">list($y, $y)</span>. The second attempt to bind <span class="KeyTerm1">$x</span> to <span class="KeyTerm1">$y</span> matches <span class="KeyTerm1">$y</span> (the stored value of <span class="KeyTerm1">$x</span> ) against <span class="KeyTerm1">$y</span> (the new value of <span class="KeyTerm1">$x</span>). This is taken care of by the <span class="KeyTerm1">equal</span> clause of <span class="KeyTerm1">unify_match</span>.</p>
<p class="Sp-text-1"><a id="c4-para-2438"/><b>function</b> extend_if_possible(variable, value, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2439"/>    <b>const</b> binding = binding_in_frame(variable, frame);</p>
<p class="Sp-text-1"><a id="c4-para-2440"/>    <b>if</b> (! is_undefined(binding)) {</p>
<p class="Sp-text-1"><a id="c4-para-2441"/>        <b>return</b> unify_match(binding_value(binding),</p>
<p class="Sp-text-1"><a id="c4-para-2442"/>                            value, frame);</p>
<p class="Sp-text-1"><a id="c4-para-2443"/>    } <b>else if</b> (is_variable(value)) { <i>//</i> ***</p>
<p class="Sp-text-1"><a id="c4-para-2444"/>         <b>const</b> binding = binding_in_frame(value, frame);</p>
<p class="Sp-text-1"><a id="c4-para-2445"/>        <b>return</b> ! is_undefined(binding)</p>
<p class="Sp-text-1"><a id="c4-para-2446"/>               ? unify_match(variable,</p>
<p class="Sp-text-1"><a id="c4-para-2447"/>                             binding_value(binding),</p>
<p class="Sp-text-1"><a id="c4-para-2448"/>                             frame)</p>
<p class="Sp-text-1"><a id="c4-para-2449"/>               : extend(variable, value, frame);</p>
<p class="Sp-text-1"><a id="c4-para-2450"/>    } <b>else if</b> (depends_on(value, variable, frame)) { <i>//</i> ***</p>
<p class="Sp-text-1"><a id="c4-para-2451"/>        <b>return</b> "failed";</p>
<p class="Sp-text-1"><a id="c4-para-2452"/>    } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-2453"/>        <b>return</b> extend(variable, value, frame);</p>
<p class="Sp-text-1"><a id="c4-para-2454"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-2455"/>}</p>
<p><a id="c4-para-2456"/>The function <span class="KeyTerm1">depends_on</span> is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable. This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable. The structure of <span class="KeyTerm1">depends_on</span> is a simple recursive tree walk in which we substitute for the values of variables whenever necessary.</p>
<p class="Sp-text-1"><a id="c4-para-2457"/><b>function</b> depends_on(expression, variable, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2458"/>    <b>function</b> tree_walk(e) {</p>
<p class="Sp-text-1"><a id="c4-para-2459"/>        <b>if</b> (is_variable(e)) {</p>
<p class="Sp-text-1"><a id="c4-para-2460"/>            <b>if</b> (equal(variable, e)) {</p>
<p class="Sp-text-1"><a id="c4-para-2461"/>                <b>return true</b>;</p>
<p class="Sp-text-1"><a id="c4-para-2462"/>            } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-2463"/>                <b>const</b> b = binding_in_frame(e, frame);</p>
<p class="Sp-text-1"><a id="c4-para-2464"/>                <b>return</b> is_undefined(b)</p>
<p class="Sp-text-1"><a id="c4-para-2465"/>                       ? <b>false</b></p>
<p class="Sp-text-1"><a id="c4-para-2466"/>                       : tree_walk(binding_value(b));</p>
<p class="Sp-text-1"><a id="c4-para-2467"/>            }</p>
<p class="Sp-text-1"><a id="c4-para-2468"/>        } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-2469"/>            <b>return</b> is_pair(e)</p>
<p class="Sp-text-1"><a id="c4-para-2470"/>                   ? tree_walk(head(e)) || tree_walk(tail(e))</p>
<p class="Sp-text-1"><a id="c4-para-2471"/>                   : <b>false</b>;</p>
<p class="Sp-text-1"><a id="c4-para-2472"/>        }</p>
<p class="Sp-text-1"><a id="c4-para-2473"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-2474"/>    <b>return</b> tree_walk(expression);</p>
<p class="Sp-text-1"><a id="c4-para-2475"/>}</p>
</section>
<section>
<h4><a id="c4-sec-0153"/><span>4.4.4.5</span> <a id="c4-title-0154"/>Maintaining the Data Base</h4>
<p class="paraaftertitle"><a id="c4-para-2476"/>One important problem in designing logic programming languages is that of arranging things so that as few irrelevant data-base entries as possible will be examined in checking a given pattern. For this purpose, we will represent an assertion as a list whose head is a string that represents the kind of information of the assertion. We store the assertions in separate streams, one for each kind of information, in a table indexed by the kind. To fetch an assertion that may match a pattern, we return (to be tested using the matcher) all the stored assertions that have the same head (the same kind of information). Cleverer methods could also take advantage of information in the frame. We avoid building our criteria for indexing into the program; instead we call on predicates and selectors that embody our criteria.</p>
<p class="Sp-text-1"><a id="c4-para-2477"/><b>function</b> fetch_assertions(pattern, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2478"/>    <b>return</b> get_indexed_assertions(pattern);</p>
<p class="Sp-text-1"><a id="c4-para-2479"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2480"/><b>function</b> get_indexed_assertions(pattern) {</p>
<p class="Sp-text-1"><a id="c4-para-2481"/>    <b>return</b> get_stream(index_key_of(pattern), "assertion-stream");</p>
<p class="Sp-text-1"><a id="c4-para-2482"/>}</p>
<p class="paracontinue"><a id="c4-para-2483"/>The function <span class="KeyTerm1">get_stream</span> looks up a stream in the table and returns an empty stream if nothing is stored there.</p>
<p class="Sp-text-1"><a id="c4-para-2484"/><b>function</b> get_stream(key1, key2) {</p>
<p class="Sp-text-1"><a id="c4-para-2485"/>    <b>const</b> s = get(key1, key2);</p>
<p class="Sp-text-1"><a id="c4-para-2486"/>    <b>return</b> is_undefined(s) ? <b>null</b> : s;</p>
<p class="Sp-text-1"><a id="c4-para-2487"/>}</p>
<p><a id="c4-para-2488"/>Rules are stored similarly, using the head of the rule conclusion. A pattern can match rules whose conclusions have the same head. Thus, when fetching rules that might match a pattern we fetch all rules whose conclusions have the same head as the pattern.</p>
<p class="Sp-text-1"><a id="c4-para-2489"/><b>function</b> fetch_rules(pattern, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2490"/>    <b>return</b> get_indexed_rules(pattern);</p>
<p class="Sp-text-1"><a id="c4-para-2491"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2492"/><b>function</b> get_indexed_rules(pattern) {</p>
<p class="Sp-text-1"><a id="c4-para-2493"/>    <b>return</b> get_stream(index_key_of(pattern), "rule-stream");</p>
<p class="Sp-text-1"><a id="c4-para-2494"/>}</p>
<p><a id="c4-para-2495"/>The function <span class="KeyTerm1">add_rule_or_assertion</span> is used by <span class="KeyTerm1">query_driver_loop</span> to add assertions and rules to the data base. Each item is stored in the index.</p>
<p class="Sp-text-1"><a id="c4-para-2496"/><b>function</b> add_rule_or_assertion(assertion) {</p>
<p class="Sp-text-1"><a id="c4-para-2497"/>    <b>return</b> is_rule(assertion)</p>
<p class="Sp-text-1"><a id="c4-para-2498"/>           ? add_rule(assertion)</p>
<p class="Sp-text-1"><a id="c4-para-2499"/>           : add_assertion(assertion);</p>
<p class="Sp-text-1"><a id="c4-para-2500"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2501"/><b>function</b> add_assertion(assertion) {</p>
<p class="Sp-text-1"><a id="c4-para-2502"/>    store_assertion_in_index(assertion);</p>
<p class="Sp-text-1"><a id="c4-para-2503"/>    <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c4-para-2504"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2505"/><b>function</b> add_rule(rule) {</p>
<p class="Sp-text-1"><a id="c4-para-2506"/>    store_rule_in_index(rule);</p>
<p class="Sp-text-1"><a id="c4-para-2507"/>    <b>return</b> "ok";</p>
<p class="Sp-text-1"><a id="c4-para-2508"/>}</p>
<p><a id="c4-para-2509"/>To actually store an assertion or a rule, we store it in the appropriate stream.</p>
<p class="Sp-text-1"><a id="c4-para-2510"/><b>function</b> store_assertion_in_index(assertion) {</p>
<p class="Sp-text-1"><a id="c4-para-2511"/>    <b>const</b> key = index_key_of(assertion);</p>
<p class="Sp-text-1"><a id="c4-para-2512"/>    <b>const</b> current_assertion_stream =</p>
<p class="Sp-text-1"><a id="c4-para-2513"/>                get_stream(key, "assertion-stream");</p>
<p class="Sp-text-1"><a id="c4-para-2514"/>    put(key, "assertion-stream",</p>
<p class="Sp-text-1"><a id="c4-para-2515"/>        pair(assertion, () =&gt; current_assertion_stream));</p>
<p class="Sp-text-1"><a id="c4-para-2516"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2517"/><b>function</b> store_rule_in_index(rule) {</p>
<p class="Sp-text-1"><a id="c4-para-2518"/>    <b>const</b> pattern = conclusion(rule);</p>
<p class="Sp-text-1"><a id="c4-para-2519"/>    <b>const</b> key = index_key_of(pattern);</p>
<p class="Sp-text-1"><a id="c4-para-2520"/>    <b>const</b> current_rule_stream =</p>
<p class="Sp-text-1"><a id="c4-para-2521"/>                get_stream(key, "rule-stream");</p>
<p class="Sp-text-1"><a id="c4-para-2522"/>    put(key, "rule-stream",</p>
<p class="Sp-text-1"><a id="c4-para-2523"/>        pair(rule, () =&gt; current_rule_stream));</p>
<p class="Sp-text-1"><a id="c4-para-2524"/>}</p>
<p><a id="c4-para-2525"/>The key under which a pattern (an assertion or rule conclusion) is stored in the table is the string it starts with.</p>
<p class="Sp-text-1"><a id="c4-para-2526"/><b>function</b> index_key_of(pattern) { <b>return</b> head(pattern); }</p>
</section>
<section>
<h4><a id="c4-sec-0154"/><span>4.4.4.6</span> <a id="c4-title-0155"/>Stream Operations</h4>
<p class="paraaftertitle"><a id="c4-para-2527"/>The query system uses a few stream operations that were not presented in chapter 3. The functions <span class="KeyTerm1">stream_append_delayed</span> and <span class="KeyTerm1">interleave_delayed</span> are just like <span class="KeyTerm1">stream_append</span> and <span class="KeyTerm1">interleave</span> (section 3.5.3), except that they take a delayed argument (like the <span class="KeyTerm1">integral</span> function in section 3.5.4). This postpones looping in some cases (see exercise 4.68).</p>
<p class="Sp-text-1"><a id="c4-para-2528"/><b>function</b> stream_append_delayed(s1, delayed_s2) {</p>
<p class="Sp-text-1"><a id="c4-para-2529"/>    <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c4-para-2530"/>           ? delayed_s2()</p>
<p class="Sp-text-1"><a id="c4-para-2531"/>           : pair(head(s1),</p>
<p class="Sp-text-1"><a id="c4-para-2532"/>                  () =&gt; stream_append_delayed(stream_tail(s1),</p>
<p class="Sp-text-1"><a id="c4-para-2533"/>                                              delayed_s2));</p>
<p class="Sp-text-1"><a id="c4-para-2534"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2535"/><b>function</b> interleave_delayed(s1, delayed_s2) {</p>
<p class="Sp-text-1"><a id="c4-para-2536"/>    <b>return</b> is_null(s1)</p>
<p class="Sp-text-1"><a id="c4-para-2537"/>           ? delayed_s2()</p>
<p class="Sp-text-1"><a id="c4-para-2538"/>           : pair(head(s1),</p>
<p class="Sp-text-1"><a id="c4-para-2539"/>                  () =&gt; interleave_delayed(delayed_s2(),</p>
<p class="Sp-text-1"><a id="c4-para-2540"/>                                           () =&gt; stream_tail(s1)));</p>
<p class="Sp-text-1"><a id="c4-para-2541"/>}</p>
<p><a id="c4-para-2542"/>The function <span class="KeyTerm1">stream_flatmap</span>, which is used throughout the query evaluator to map a function over a stream of frames and combine the resulting streams of frames, is the stream analog of the <span class="KeyTerm1">flatmap</span> function introduced for ordinary lists in section 2.2.3. Unlike ordinary <span class="KeyTerm1">flatmap</span>, however, we accumulate the streams with an interleaving process, rather than simply appending them (see exercises 4.69 and 4.70).</p>
<p class="Sp-text-1"><a id="c4-para-2543"/><b>function</b> stream_flatmap(fun, s) {</p>
<p class="Sp-text-1"><a id="c4-para-2544"/>    <b>return</b> flatten_stream(stream_map(fun, s));</p>
<p class="Sp-text-1"><a id="c4-para-2545"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2546"/><b>function</b> flatten_stream(stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2547"/>    <b>return</b> is_null(stream)</p>
<p class="Sp-text-1"><a id="c4-para-2548"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c4-para-2549"/>           : interleave_delayed(</p>
<p class="Sp-text-1"><a id="c4-para-2550"/>                  head(stream),</p>
<p class="Sp-text-1"><a id="c4-para-2551"/>                  () =&gt; flatten_stream(stream_tail(stream)));</p>
<p class="Sp-text-1"><a id="c4-para-2552"/>}</p>
<p><a id="c4-para-2553"/>The evaluator also uses the following simple function to generate a stream consisting of a single element:</p>
<p class="Sp-text-1"><a id="c4-para-2554"/><b>function</b> singleton_stream(x) {</p>
<p class="Sp-text-1"><a id="c4-para-2555"/>    <b>return</b> pair(x, () =&gt; <b>null</b>);</p>
<p class="Sp-text-1"><a id="c4-para-2556"/>}</p>
</section>
<section>
<h4><a id="c4-sec-0155"/><span>4.4.4.7</span> <a id="c4-title-0156"/>Query Syntax Functions and Instantiation</h4>
<p class="paraaftertitle"><a id="c4-para-2557"/>We saw in section 4.4.4.1 that the driver loop first transforms an input string into the JavaScript syntax representation. The input is designed to look like a JavaScript expression so that we can use the <span class="KeyTerm1">parse</span> function from section 4.1.2 and also to support JavaScript notation in <span class="KeyTerm1">javascript_predicate</span>. For example,</p>
<p class="Sp-text-1"><a id="c4-para-2558"/>parse('job($x, list("computer", "wizard"));');</p>
<p class="paracontinue"><a id="c4-para-2559"/>yields</p>
<p class="Sp-text-1"><a id="c4-para-2560"/><i>list("application",</i></p>
<p class="Sp-text-1"><a id="c4-para-2561"/>     <i>list("name", "job"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2562"/>     <i>list(list("name", "$x"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2563"/>          <i>list("application",</i></p>
<p class="Sp-text-1"><a id="c4-para-2564"/>               <i>list("name", "list"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2565"/>               <i>list(list("literal", "computer"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2566"/>                    <i>list("literal", "wizard")))))</i></p>
<p class="paracontinue"><a id="c4-para-2567"/>The tag <span class="KeyTerm1">"application"</span> indicates that syntactically, the query would be treated as a function application in JavaScipt. The function <span class="KeyTerm1">unparse</span> transforms the syntax back into a string:</p>
<p class="Sp-text-1"><a id="c4-para-2568"/>unparse(parse('job($x, list("computer", "wizard"));'));</p>
<p class="Sp-text-1"><a id="c4-para-2569"/><i>'job($x, list("computer", "wizard"))'</i></p>
<p class="paracontinue"><a id="c4-para-2570"/>In the query processor, we assumed a query-language-specific representation of assertions, rules, and queries. The function <span class="KeyTerm1">convert_to_query_syntax</span> transforms the syntax representation into that representation. Using the same example,</p>
<p class="Sp-text-1"><a id="c4-para-2571"/>convert_to_query_syntax(parse('job($x, list("computer", "wizard"));'));</p>
<p class="paracontinue"><a id="c4-para-2572"/>yields</p>
<p class="Sp-text-3"><a id="c4-para-2573"/><i>list("job", list("name", "$x"), list("computer", "wizard"))</i></p>
<p class="paracontinue"><a id="c4-para-2574"/>Query-system functions such as <span class="KeyTerm1">add_rule_or_assertion</span> in section 4.4.4.5 and <span class="KeyTerm1">evaluate_query</span> in section 4.4.4.2 operate on the query-language-specific representation using selectors and predicates such as <span class="KeyTerm1">type</span>, <span class="KeyTerm1">contents</span>, <span class="KeyTerm1">is_rule</span>, and <span class="KeyTerm1">first_conjunct</span> declared below. <a id="c4-fig-0008a"/><a href="#c4-fig-0008">Figure 4.8</a> depicts the three abstraction barriers used by the query system and how the transformation functions <span class="KeyTerm1">parse</span>, <span class="KeyTerm1">unparse</span>, and <span class="KeyTerm1">convert_to_query_syntax</span> bridge them.</p>
<figure id="c4-fig-0008"><img alt="c4-fig-0008.jpg" src="../images/c4-fig-0008.jpg"/><figcaption class="figurecaption">
<p><span class="figureLabel"><a href="#c4-fig-0008a">Figure 4.8</a></span> <a id="c4-para-2575"/>Syntax abstraction in the query system.</p></figcaption></figure>
</section>
<section>
<h5><a id="c4-sec-0156"/><a id="c4-title-0157"/>Handling pattern variables</h5>
<p class="paraaftertitle"><a id="c4-para-2576"/>The predicate <span class="KeyTerm1">is_variable</span> is used on the query-language-specific representation during query processing and on the JavaScript syntax representation during instantiation to identify names that start with a dollar sign. We assume there is a function <span class="KeyTerm1">char_at</span> that returns a string containing only the character of the given string at the given position.<a id="c4-fn-0075a"/><a href="#c4-fn-0075"><sup>75</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-2577"/><b>function</b> is_variable(exp) {</p>
<p class="Sp-text-1"><a id="c4-para-2578"/>    <b>return</b> is_name(exp) &amp;&amp; char_at(symbol_of_name(exp), 0) === "$";</p>
<p class="Sp-text-1"><a id="c4-para-2579"/>}</p>
<p><a id="c4-para-2580"/>Unique variables are constructed during rule application (in section 4.4.4.4) by means of the following functions. The unique identifier for a rule application is a number, which is incremented each time a rule is applied.<a id="c4-fn-0076a"/><a href="#c4-fn-0076"><sup>76</sup></a></p>
<p class="Sp-text-1"><a id="c4-para-2581"/><b>let</b> rule_counter = 0;</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-2582"/><b>function</b> new_rule_application_id() { </p>
<p class="Sp-text-1"><a id="c4-para-5582"/>    rule_counter = rule_counter + 1;</p>
<p class="Sp-text-1"><a id="c4-para-2583"/>    <b>return</b> rule_counter;</p>
<p class="Sp-text-1"><a id="c4-para-2584"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2585"/><b>function</b> make_new_variable(variable, rule_application_id) {</p>
<p class="Sp-text-1"><a id="c4-para-2586"/>    <b>return</b> make_name(symbol_of_name(variable) + "_" +</p>
<p class="Sp-text-1"><a id="c4-para-2587"/>                     stringify(rule_application_id));</p>
<p class="Sp-text-1"><a id="c4-para-2588"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0157"/><a id="c4-title-0158"/>The function <span class="KeyTerm1"><b>convert_to_query_syntax</b></span></h5>
<p class="paraaftertitle"><a id="c4-para-2589"/>The function <span class="KeyTerm1">convert_to_query_syntax</span> recursively transforms the JavaScript syntax representation into the query-language-specific representation by simplifying assertions, rules, and queries such that the symbol of a name in a function expression of an application becomes a tag, except that if the symbol is <span class="KeyTerm1">"pair"</span> or <span class="KeyTerm1">"list"</span>, an (untagged) JavaScript pair or list is built. This means that <span class="KeyTerm1">convert_to_ query_syntax</span> interprets applications of the constructors <span class="KeyTerm1">pair</span> and <span class="KeyTerm1">list</span> during the transformation, and processing functions such as <span class="KeyTerm1">pattern_match</span> of section 4.4.4.3 and <span class="KeyTerm1">unify_match</span> of section 4.4.4.4 can operate directly on the intended pairs and lists rather than on the syntax representation generated by the parser. The (one-element) “argument” list of <span class="KeyTerm1">javascript_predicate</span> remains unprocessed, as explained below. A variable remains unchanged, and a literal is simplified to the primitive value it contains.</p>
<p class="Sp-text-1"><a id="c4-para-2590"/><b>function</b> convert_to_query_syntax(exp) {</p>
<p class="Sp-text-1"><a id="c4-para-2591"/>   <b>if</b> (is_application(exp)) {</p>
<p class="Sp-text-1"><a id="c4-para-2592"/>     <b>const</b> function_symbol = symbol_of_name(function_expression(exp));</p>
<p class="Sp-text-1"><a id="c4-para-2593"/>     <b>if</b> (function_symbol === "javascript_predicate") {</p>
<p class="Sp-text-1"><a id="c4-para-2594"/>       <b>return</b> pair(function_symbol, arg_expressions(exp));</p>
<p class="Sp-text-1"><a id="c4-para-2595"/>     } <b>else</b> {</p>
<p class="Sp-text-1"><a id="c4-para-2596"/>       <b>const</b> processed_args = map(convert_to_query_syntax,</p>
<p class="Sp-text-1"><a id="c4-para-2597"/>                                  arg_expressions(exp));</p>
<p class="Sp-text-1"><a id="c4-para-2598"/>       <b>return</b> function_symbol === "pair"</p>
<p class="Sp-text-1"><a id="c4-para-2599"/>              ? pair(head(processed_args), head(tail(processed_args)))</p>
<p class="Sp-text-1"><a id="c4-para-2600"/>              : function_symbol === "list"</p>
<p class="Sp-text-1"><a id="c4-para-2601"/>              ? processed_args</p>
<p class="Sp-text-1"><a id="c4-para-2602"/>              : pair(function_symbol, processed_args);</p>
<p class="Sp-text-1"><a id="c4-para-2603"/>     }</p>
<p class="Sp-text-1"><a id="c4-para-2604"/>   } <b>else if</b> (is_variable(exp)) {</p>
<p class="Sp-text-1"><a id="c4-para-2605"/>     <b>return</b> exp;</p>
<p class="Sp-text-1"><a id="c4-para-2606"/>   } <b>else</b> { <i>// exp is literal</i></p>
<p class="Sp-text-1"><a id="c4-para-2607"/>     <b>return</b> literal_value(exp);</p>
<p class="Sp-text-1"><a id="c4-para-2608"/>   }</p>
<p class="Sp-text-1"><a id="c4-para-2609"/>}</p>
<p><a id="c4-para-2610"/>An exception to this processing is <span class="KeyTerm1">javascript_predicate</span>. Since the instantiated JavaScript syntax representation of its predicate expression is passed to <span class="KeyTerm1">evaluate</span> of section 4.1.1, the original syntax representation coming from <span class="KeyTerm1">parse</span> needs to remain intact in the query-language-specific representation of the expression. In this example of section 4.4.1</p>
<p class="Sp-text-1"><a id="c4-para-2611"/>and(salary($person, $amount), javascript_predicate($amount &gt; 50000))</p>
<p class="paracontinue"><a id="c4-para-2612"/><span class="KeyTerm1">convert_to_query_syntax</span> produces a data structure in which a JavaScript syntax representation is embedded in a query-language-specific representation:</p>
<p class="Sp-text-1"><a id="c4-para-2613"/><i>list("and",</i></p>
<p class="Sp-text-1"><a id="c4-para-2614"/>     <i>list("salary", list("name", "$person"), list("name", "$amount")),</i></p>
<p class="Sp-text-1"><a id="c4-para-2615"/>     <i>list("javascript_predicate",</i></p>
<p class="Sp-text-1"><a id="c4-para-2616"/>          <i>list("binary_operator_combination",</i></p>
<p class="Sp-text-1"><a id="c4-para-2617"/>               <i>"&gt;",</i></p>
<p class="Sp-text-1"><a id="c4-para-2618"/>               <i>list("name", "$amount"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2619"/>               <i>list("literal", 50000))))</i></p>
<p class="paracontinue"><a id="c4-para-2620"/>In order to evaluate the <span class="KeyTerm1">javascript_predicate</span> subexpression of that processed query, the function <span class="KeyTerm1">javascript_predicate</span> in section 4.4.4.2 calls the function <span class="KeyTerm1">instantiate_expression</span> (below) on the embedded JavaScript syntax representation of <span class="KeyTerm1">$amount &gt; 50000</span> to replace the variable <span class="KeyTerm1">list("name", "$amount")</span> by a literal, for example <span class="KeyTerm1">list("literal", 70000)</span>, that represents the primitive value to which <span class="KeyTerm1">$amount</span> is bound, here 70000. The JavaScript evaluator can evaluate the instantiated predicate, which now represents <span class="KeyTerm1">70000 &gt; 50000</span>.</p>
</section>
<section>
<h5><a id="c4-sec-0158"/><a id="c4-title-0159"/>Instantiating an expression</h5>
<p class="paraaftertitle"><a id="c4-para-2621"/>The function <span class="KeyTerm1">javascript_predicate</span> of section 4.4.4.2 and the driver loop of section 4.4.4.1 call <span class="KeyTerm1">instantiate_expression</span> on an expression to obtain a copy in which any variable in the expression is replaced by its value in a given frame. The input and result expressions use the JavaScript syntax representation, so any value that results from instantiating a variable needs to be converted from its form in the binding to the JavaScript syntax representation.</p>
<p class="Sp-text-1"><a id="c4-para-2622"/><b>function</b> instantiate_expression(expression, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2623"/>   <b>return</b> is_variable(expression)</p>
<p class="Sp-text-1"><a id="c4-para-2624"/>          ? convert(instantiate_term(expression, frame))</p>
<p class="Sp-text-1"><a id="c4-para-2625"/>          : is_pair(expression)</p>
<p class="Sp-text-1"><a id="c4-para-2626"/>          ? pair(instantiate_expression(head(expression), frame),</p>
<p class="Sp-text-1"><a id="c4-para-2627"/>                 instantiate_expression(tail(expression), frame))</p>
<p class="Sp-text-1"><a id="c4-para-2628"/>          : expression;</p>
<p class="Sp-text-1"><a id="c4-para-2629"/>}</p>
<p class="paracontinue"><a id="c4-para-2630"/>The function <span class="KeyTerm1">instantiate_term</span> takes a variable, pair, or primitive value as first argument and a frame as second argument and recursively replaces the variables in the first argument by their values in the frame until a primitive value or an unbound variable is reached. When the process encounters a pair, a new pair is constructed whose parts are the instantiated versions of the original parts. For example, if <span class="KeyTerm1">$x</span> is bound to the pair [<span class="KeyTerm1">$y</span>, 5] in a frame <i>f</i> as the result of unification, and <span class="KeyTerm1">$y</span> is in turn bound to 3, the result of applying <span class="KeyTerm1">instantiate_term</span> to <span class="KeyTerm1">list("name", "$x")</span> and <i>f</i> is the pair [3, 5].</p>
<p class="Sp-text-1"><a id="c4-para-2631"/><b>function</b> instantiate_term(term, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2632"/>    <b>if</b> (is_variable(term)) {</p>
<p class="Sp-text-1"><a id="c4-para-2633"/>        <b>const</b> binding = binding_in_frame(term, frame);</p>
<p class="Sp-text-1"><a id="c4-para-2634"/>        <b>return</b> is_undefined(binding)</p>
<p class="Sp-text-1"><a id="c4-para-2635"/>              ? term <i>//</i> <span class="KeyTerm2"><i>leave unbound variable as is</i></span></p>
<p class="Sp-text-1"><a id="c4-para-2636"/>           : instantiate_term(binding_value(binding), frame);</p>
<p class="Sp-text-1"><a id="c4-para-2637"/>    } <b>else if</b> (is_pair(term)) {</p>
<p class="Sp-text-1"><a id="c4-para-2638"/>        <b>return</b> pair(instantiate_term(head(term), frame),</p>
<p class="Sp-text-1"><a id="c4-para-2639"/>                    instantiate_term(tail(term), frame));</p>
<p class="Sp-text-1"><a id="c4-para-2640"/>    } <b>else</b> { <i>//</i> term <span class="KeyTerm2"><i>is a primitive value</i></span></p>
<p class="Sp-text-1"><a id="c4-para-2641"/>        <b>return</b> term;</p>
<p class="Sp-text-1"><a id="c4-para-2642"/>    }</p>
<p class="Sp-text-1"><a id="c4-para-2643"/>}</p>
<p class="paracontinue"><a id="c4-para-2644"/>The function <span class="KeyTerm1">convert</span> constructs a JavaScript syntax representation for a variable, pair, or primitive value returned by <span class="KeyTerm1">instantiate_term</span>. A pair in the original becomes an application of JavaScript's pair constructor and a primitive value becomes a literal.</p>
<p class="Sp-text-1"><a id="c4-para-2645"/><b>function</b> convert(term) {</p>
<p class="Sp-text-1"><a id="c4-para-2646"/>    <b>return</b> is_variable(term)</p>
<p class="Sp-text-1"><a id="c4-para-2647"/>           ? term</p>
<p class="Sp-text-1"><a id="c4-para-2648"/>           : is_pair(term)</p>
<p class="Sp-text-1"><a id="c4-para-2649"/>           ? make_application(make_name("pair"),</p>
<p class="Sp-text-1"><a id="c4-para-2650"/>                              list(convert(head(term)),</p>
<p class="Sp-text-1"><a id="c4-para-2651"/>                                   convert(tail(term))))</p>
<p class="Sp-text-1"><a id="c4-para-2652"/>           : <i>//</i> term <span class="KeyTerm2"><i>is a primitive value</i></span></p>
<p class="Sp-text-1"><a id="c4-para-2653"/>             make_literal(term);</p>
<p class="Sp-text-1"><a id="c4-para-2654"/>}</p>
<p class="paracontinue"><a id="c4-para-2655"/>To illustrate these three functions, consider what happens when the query</p>
<p class="Sp-text-1"><a id="c4-para-2656"/>job($x, list("computer", "wizard"))</p>
<p class="paracontinue"><a id="c4-para-2657"/>whose JavaScript syntax representation is given at the beginning of section 4.4.4.7, is processed by the driver loop. Let's say a frame <i>g</i> of the result stream binds the variable <span class="KeyTerm1">$x</span> to the pair [<span class="KeyTerm1">"Bitdiddle"</span>, <span class="KeyTerm1">$y</span>] and the variable <span class="KeyTerm1">$y</span> to the pair [<span class="KeyTerm1">"Ben"</span>, <span class="KeyTerm1">null</span>]. Then</p>
<p class="Sp-text-1"><a id="c4-para-2658"/>instantiate_term(list("name", "$x"), <i>g</i>)</p>
<p class="paracontinue"><a id="c4-para-2659"/>returns the list</p>
<p class="Sp-text-1"><a id="c4-para-2660"/><i>list("Bitdiddle", "Ben")</i></p>
<p class="paracontinue"><a id="c4-para-2661"/>which <span class="KeyTerm1">convert</span> transforms into</p>
<p class="Sp-text-1"><a id="c4-para-2662"/><i>list("application",</i></p>
<p class="Sp-text-1"><a id="c4-para-2663"/>     <i>list("name", "pair"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2664"/>     <i>list(list("literal", "Bitdiddle"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2665"/>          <i>list("application",</i></p>
<p class="Sp-text-1"><a id="c4-para-2666"/>               <i>list("name", "pair"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2667"/>               <i>list(list("literal", "Ben"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2668"/>                    <i>list("literal", null)))))</i></p>
<p class="paracontinue"><a id="c4-para-2669"/>The result of instantiate_expression applied to the JavaScript syntax representation of the query and the frame <i>g</i> is:</p>
<p class="Sp-text-1"><a id="c4-para-2670"/><i>list("application",</i></p>
<p class="Sp-text-1"><a id="c4-para-2671"/>     <i>list("name", "job"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2672"/>     <i>list(list("application",</i></p>
<p class="Sp-text-1"><a id="c4-para-2673"/>               <i>list("name", "pair"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2674"/>               <i>list(list("literal", "Bitdiddle"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2675"/>                    <i>list("application",</i></p>
<p class="Sp-text-1"><a id="c4-para-2676"/>                         <i>list("name", "pair"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2677"/>                         <i>list(list("literal", "Ben"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2678"/>                              <i>list("literal", null))))),</i></p>
<p class="Sp-text-1"><a id="c4-para-2679"/>          <i>list("application",</i></p>
<p class="Sp-text-1"><a id="c4-para-2680"/>               <i>list("name", "list"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2681"/>               <i>list(list("literal", "computer"),</i></p>
<p class="Sp-text-1"><a id="c4-para-2682"/>                    <i>list("literal", "wizard")))))</i></p>
<p class="paracontinue"><a id="c4-para-2683"/>The driver loop unparses this representation and displays it as:</p>
<p class="Sp-text-3"><a id="c4-para-2684"/><i>'job(list("Bitdiddle", "Ben"), list("computer", "wizard"))'</i></p>
</section>
<section>
<h5><a id="c4-sec-0159"/><a id="c4-title-0160"/>The function <span class="KeyTerm1"><b>unparse</b></span></h5>
<p class="paraaftertitle"><a id="c4-para-2685"/>The function unparse transforms a component given in the JavaScript syntax representation into a string by applying the syntax rules of section 4.1.2. We describe <span class="KeyTerm1">unparse</span> only for those kinds of expressions that appear in the examples of section 4.4.1, leaving statements and the remaining kinds of expressions as exercise 4.2. A literal is transformed by <span class="KeyTerm1">stringifying</span> its value, and a name is transformed into its symbol. An application is formatted by unparsing the function expression, which we can assume to be a name here, followed by the comma-separated argument expression strings enclosed in parentheses. Binary operator combinations are formatted using infix notation.</p>
<p class="Sp-text-1"><a id="c4-para-2686"/><b>function</b> unparse(exp) {</p>
<p class="Sp-text-1"><a id="c4-para-2687"/>    <b>return</b> is_literal(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2688"/>           ? stringify(literal_value(exp))</p>
<p class="Sp-text-1"><a id="c4-para-2689"/>           : is_name(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2690"/>           ? symbol_of_name(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2691"/>           : is_list_construction(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2692"/>           ? unparse(make_application(make_name("list"),</p>
<p class="Sp-text-1"><a id="c4-para-2693"/>                                      element_expressions(exp)))</p>
<p class="Sp-text-1"><a id="c4-para-2694"/>           : is_application(exp) &amp;&amp; is_name(function_expression(exp))</p>
<p class="Sp-text-1"><a id="c4-para-2695"/>           ? symbol_of_name(function_expression(exp)) +</p>
<p class="Sp-text-1"><a id="c4-para-2696"/>                 "(" +</p>
<p class="Sp-text-1"><a id="c4-para-2697"/>                 comma_separated(map(unparse, arg_expressions(exp))) +</p>
<p class="Sp-text-1"><a id="c4-para-2698"/>                 ")"</p>
<p class="Sp-text-1"><a id="c4-para-2699"/>           : is_binary_operator_combination(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2700"/>           ? "(" + unparse(first_operand(exp)) +</p>
<p class="Sp-text-1"><a id="c4-para-2701"/>             " " + operator_symbol(exp) +</p>
<p class="Sp-text-1"><a id="c4-para-2702"/>             " " + unparse(second_operand(exp)) +</p>
<p class="Sp-text-1"><a id="c4-para-2703"/>             ")"</p>
<p class="Sp-text-1"><a id="c4-para-2704"/>           〈<span class="KeyTerm2"><i>unparsing other kinds of JavaScript components</i></span>〉</p>
<p class="Sp-text-1"><a id="c4-para-2705"/>           : error(exp, "unknown syntax – unparse");</p>
<p class="Sp-text-1"><a id="c4-para-2706"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2707"/><b>function</b> comma_separated(strings) {</p>
<p class="Sp-text-1"><a id="c4-para-2708"/>    <b>return</b> accumulate((s, acc) =&gt; s + (acc === "" ? "" : ", " + acc),</p>
<p class="Sp-text-1"><a id="c4-para-2709"/>                      "",</p>
<p class="Sp-text-1"><a id="c4-para-2710"/>                      strings);</p>
<p class="Sp-text-1"><a id="c4-para-2711"/>}</p>
<p><a id="c4-para-2712"/>The function <span class="KeyTerm1">unparse</span> would work fine without the clause</p>
<p class="Sp-text-1"><a id="c4-para-2713"/>: is_list_construction(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2714"/>? unparse(make_application(make_name("list"),</p>
<p class="Sp-text-1"><a id="c4-para-2715"/>                           element_expressions(exp)))</p>
<p class="paracontinue"><a id="c4-para-2716"/>but the output string would be unnecessarily verbose in cases where pattern variables are instantiated by lists. In the example above, where processing the query</p>
<p class="Sp-text-1"><a id="c4-para-2717"/>job($x, list("computer", "wizard"))</p>
<p class="paracontinue"><a id="c4-para-2718"/>yields a frame that binds <span class="KeyTerm1">$x</span> to [<span class="KeyTerm1">"Bitdiddle"</span>, [<span class="KeyTerm1">"Ben"</span>, <span class="KeyTerm1">null</span>]], <span class="KeyTerm1">unparse</span> produces</p>
<p class="Sp-text-3"><a id="c4-para-2719"/><i>'job(list("Bitdiddle", "Ben"), list("computer", "wizard"))'</i></p>
<p class="paracontinue"><a id="c4-para-2720"/>However, without the clause it would produce</p>
<p class="Sp-text-3"><a id="c4-para-2721"/><i>'job(pair("Bitdiddle", pair("Ben", null)), list("computer", "wizard"))'</i></p>
<p class="paracontinue"><a id="c4-para-2722"/>which explicitly constructs the two pairs that make up the first list. To achieve the more concise formatting used throughout section 4.4.1, we inserted the clause to check if the expression constructs a list, in which case we format it as a single application of <span class="KeyTerm1">list</span> to the list of element expressions that we extract from the expression. A list construction is the literal <span class="KeyTerm1"><b>null</b></span> or an application of <span class="KeyTerm1">pair</span> whose second argument is itself a list construction.</p>
<p class="Sp-text-1"><a id="c4-para-2723"/><b>function</b> is_list_construction(exp) {</p>
<p class="Sp-text-1"><a id="c4-para-2724"/>    <b>return</b> (is_literal(exp) &amp;&amp; is_null(literal_value(exp))) ||</p>
<p class="Sp-text-1"><a id="c4-para-2725"/>           (is_application(exp) &amp;&amp; is_name(function_expression(exp)) &amp;&amp;</p>
<p class="Sp-text-1"><a id="c4-para-2726"/>            symbol_of_name(function_expression(exp)) === "pair" &amp;&amp;</p>
<p class="Sp-text-1"><a id="c4-para-2727"/>            is_list_construction(head(tail(arg_expressions(exp)))));</p>
<p class="Sp-text-1"><a id="c4-para-2728"/>}</p>
<p class="paracontinue"><a id="c4-para-2729"/>Extracting the element expressions from a given list construction amounts to collecting the first arguments of applications of <span class="KeyTerm1">pair</span> until the literal <span class="KeyTerm1"><b>null</b></span> is reached.</p>
<p class="Sp-text-1"><a id="c4-para-2730"/><b>function</b> element_expressions(list_constr) {</p>
<p class="Sp-text-1"><a id="c4-para-2731"/>    <b>return</b> is_literal(list_constr)</p>
<p class="Sp-text-1"><a id="c4-para-2732"/>           ? <b>null</b> <i>//</i> list_constr <span class="KeyTerm2"><i>is literal</i></span> null</p>
<p class="Sp-text-1"><a id="c4-para-2733"/>           :      <i>//</i> list_constr <span class="KeyTerm2"><i>is application of</i></span> pair</p>
<p class="Sp-text-1"><a id="c4-para-2734"/>             pair(head(arg_expressions(list_constr)),</p>
<p class="Sp-text-1"><a id="c4-para-2735"/>                  element_expressions(</p>
<p class="Sp-text-1"><a id="c4-para-2736"/>                      head(tail(arg_expressions(list_constr)))));</p>
<p class="Sp-text-1"><a id="c4-para-2737"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0160"/><a id="c4-title-0161"/>Predicates and selectors for the query-language-specific representation</h5>
<p class="paraaftertitle"><a id="c4-para-2738"/>The functions <span class="KeyTerm1">type</span> and <span class="KeyTerm1">contents</span>, used by <span class="KeyTerm1">evaluate_query</span> (section 4.4.4.2), specify that a syntactic form of a query-language-specific representation is identified by the string in its head. They are the same as the <span class="KeyTerm1">type_tag</span> and <span class="KeyTerm1">contents</span> functions in section 2.4.2, except for the error message.</p>
<p class="Sp-text-1"><a id="c4-para-2739"/><b>function</b> type(exp) {</p>
<p class="Sp-text-1"><a id="c4-para-2740"/>    <b>return</b> is_pair(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2741"/>           ? head(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2742"/>           : error(exp, "unknown expression type");</p>
<p class="Sp-text-1"><a id="c4-para-2743"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2744"/><b>function</b> contents(exp) {</p>
<p class="Sp-text-1"><a id="c4-para-2745"/>    <b>return</b> is_pair(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2746"/>           ? tail(exp)</p>
<p class="Sp-text-1"><a id="c4-para-2747"/>           : error(exp, "unknown expression contents");</p>
<p class="Sp-text-1"><a id="c4-para-2748"/>}</p>
<p><a id="c4-para-2749"/>The following functions, used by <span class="KeyTerm1">query_driver_loop</span> (in section 4.4.4.1), specify that rules and assertions are added to the data base by an <span class="KeyTerm1">assert</span> command, which the function <span class="KeyTerm1">convert_to_query_syntax</span> transforms into a pair of the form <span class="KeyTerm1">["assert",</span> <i>rule</i>-<i>or</i>-<i>assertion</i><span class="KeyTerm1">]</span>:</p>
<p class="Sp-text-1"><a id="c4-para-2750"/><b>function</b> is_assertion(exp) {</p>
<p class="Sp-text-1"><a id="c4-para-2751"/>    <b>return</b> type(exp) === "assert";</p>
<p class="Sp-text-1"><a id="c4-para-2752"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2753"/><b>function</b> assertion_body(exp) { <b>return</b> head(contents(exp)); }</p>
<p><a id="c4-para-2754"/>Here are the declarations of the predicates and selectors for the <span class="KeyTerm1">and</span>, <span class="KeyTerm1">or</span>, <span class="KeyTerm1">not</span>, and <span class="KeyTerm1">javascript_predicate</span> syntactic forms (section 4.4.4.2):</p>
<p class="Sp-text-1"><a id="c4-para-2755"/><b>function</b> is_empty_conjunction(exps) { <b>return</b> is_null(exps); }</p>
<p class="Sp-text-1"><a id="c4-para-2756"/><b>function</b> first_conjunct(exps) { <b>return</b> head(exps); }</p>
<p class="Sp-text-1"><a id="c4-para-2757"/><b>function</b> rest_conjuncts(exps) { <b>return</b> tail(exps); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-2758"/><b>function</b> is_empty_disjunction(exps) { <b>return</b> is_null(exps); }</p>
<p class="Sp-text-1"><a id="c4-para-2759"/><b>function</b> first_disjunct(exps) { <b>return</b> head(exps); }</p>
<p class="Sp-text-1"><a id="c4-para-2760"/><b>function</b> rest_disjuncts(exps) { <b>return</b> tail(exps); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-2761"/><b>function</b> negated_query(exps) { <b>return</b> head(exps); }</p>
<p class="Sp-text-1"> </p>
<p class="Sp-text-1"><a id="c4-para-2762"/><b>function</b> javascript_predicate_expression(exps) { <b>return</b> head(exps); }</p>
<p><a id="c4-para-2763"/>The following three functions define the query-language-specific representation of rules:</p>
<p class="Sp-text-1"><a id="c4-para-2764"/><b>function</b> is_rule(assertion) {</p>
<p class="Sp-text-1"><a id="c4-para-2765"/>    <b>return</b> is_tagged_list(assertion, "rule");</p>
<p class="Sp-text-1"><a id="c4-para-2766"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2767"/><b>function</b> conclusion(rule) { <b>return</b> head(tail(rule)); }</p>
<p class="Sp-text-1"><a id="c4-para-2768"/><b>function</b> rule_body(rule) {</p>
<p class="Sp-text-1"><a id="c4-para-2769"/>    <b>return</b> is_null(tail(tail(rule)))</p>
<p class="Sp-text-1"><a id="c4-para-2770"/>           ? list("always_true")</p>
<p class="Sp-text-1"><a id="c4-para-2771"/>           : head(tail(tail(rule)));</p>
<p class="Sp-text-1"><a id="c4-para-2772"/>}</p>
</section>
<section>
<h4><a id="c4-sec-0161"/><span>4.4.4.8</span> <a id="c4-title-0162"/>Frames and Bindings</h4>
<p class="paraaftertitle"><a id="c4-para-2773"/>Frames are represented as lists of bindings, which are variable-value pairs:</p>
<p class="Sp-text-1"><a id="c4-para-2774"/><b>function</b> make_binding(variable, value) {</p>
<p class="Sp-text-1"><a id="c4-para-2775"/>    <b>return</b> pair(variable, value);</p>
<p class="Sp-text-1"><a id="c4-para-2776"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2777"/><b>function</b> binding_variable(binding) {</p>
<p class="Sp-text-1"><a id="c4-para-2778"/>    <b>return</b> head(binding);</p>
<p class="Sp-text-1"><a id="c4-para-2779"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2780"/><b>function</b> binding_value(binding) {</p>
<p class="Sp-text-1"><a id="c4-para-2781"/>    <b>return</b> tail(binding);</p>
<p class="Sp-text-1"><a id="c4-para-2782"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2783"/><b>function</b> binding_in_frame(variable, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2784"/>    <b>return</b> assoc(variable, frame);</p>
<p class="Sp-text-1"><a id="c4-para-2785"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2786"/><b>function</b> extend(variable, value, frame) {</p>
<p class="Sp-text-1"><a id="c4-para-2787"/>    <b>return</b> pair(make_binding(variable, value), frame);</p>
<p class="Sp-text-1"><a id="c4-para-2788"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0162"/><a id="c4-title-0163"/>Exercise 4.68</h5>
<p class="paraaftertitle"><a id="c4-para-2789"/>Louis Reasoner wonders why the <span class="KeyTerm1">simple_query</span> and <span class="KeyTerm1">disjoin</span> functions (section 4.4.4.2) are implemented using delayed expressions rather than being defined as follows:</p>
<p class="Sp-text-1"><a id="c4-para-2790"/><b>function</b> simple_query(query_pattern, frame_stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2791"/>    <b>return</b> stream_flatmap(</p>
<p class="Sp-text-1"><a id="c4-para-2792"/>               frame =&gt;</p>
<p class="Sp-text-1"><a id="c4-para-2793"/>                 stream_append(find_assertions(query_pattern, frame),</p>
<p class="Sp-text-1"><a id="c4-para-2794"/>                               apply_rules(query_pattern, frame)),</p>
<p class="Sp-text-1"><a id="c4-para-2795"/>               frame_stream);</p>
<p class="Sp-text-1"><a id="c4-para-2796"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2797"/><b>function</b> disjoin(disjuncts, frame_stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2798"/>    <b>return</b> is_empty_disjunction(disjuncts)</p>
<p class="Sp-text-1"><a id="c4-para-2799"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c4-para-2800"/>           : interleave(</p>
<p class="Sp-text-1"><a id="c4-para-2801"/>                  evaluate_query(first_disjunct(disjuncts), frame_stream),</p>
<p class="Sp-text-1"><a id="c4-para-2802"/>                  disjoin(rest_disjuncts(disjuncts), frame_stream));</p>
<p class="Sp-text-1"><a id="c4-para-2803"/>}</p>
<p class="paracontinue"><a id="c4-para-2804"/>Can you give examples of queries where these simpler definitions would lead to undesirable behavior?</p>
</section>
<section>
<h5><a id="c4-sec-0163"/><a id="c4-title-0164"/>Exercise 4.69</h5>
<p class="paraaftertitle"><a id="c4-para-2805"/>Why do <span class="KeyTerm1">disjoin</span> and <span class="KeyTerm1">stream_flatmap</span> interleave the streams rather than simply append them? Give examples that illustrate why interleaving works better. (Hint: Why did we use <span class="KeyTerm1">interleave</span> in section 3.5.3?)</p>
</section>
<section>
<h5><a id="c4-sec-0164"/><a id="c4-title-0165"/>Exercise 4.70</h5>
<p class="paraaftertitle"><a id="c4-para-2806"/>Why does <span class="KeyTerm1">flatten_stream</span> use a delayed expression in its body? What would be wrong with defining it as follows:</p>
<p class="Sp-text-1"><a id="c4-para-2807"/><b>function</b> flatten_stream(stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2808"/>    <b>return</b> is_null(stream)</p>
<p class="Sp-text-1"><a id="c4-para-2809"/>           ? <b>null</b></p>
<p class="Sp-text-1"><a id="c4-para-2810"/>           : interleave(head(stream),</p>
<p class="Sp-text-1"><a id="c4-para-2811"/>                        flatten_stream(stream_tail(stream)));</p>
<p class="Sp-text-1"><a id="c4-para-2812"/>}</p>
</section>
<section>
<h5><a id="c4-sec-0165"/><a id="c4-title-0166"/>Exercise 4.71</h5>
<p class="paraaftertitle"><a id="c4-para-2813"/>Alyssa P. Hacker proposes to use a simpler version of <span class="KeyTerm1">stream_flatmap</span> in <span class="KeyTerm1">negate</span>, <span class="KeyTerm1">javascript_predicate</span>, and <span class="KeyTerm1">find_assertions</span>. She observes that the function that is mapped over the frame stream in these cases always produces either the empty stream or a singleton stream, so no interleaving is needed when combining these streams.</p>
<ol class="BS_NumberListA">
<li><a id="c4-li-0103"/><span>a. </span>Fill in the missing expressions in Alyssa's program.
<p class="Sp-text-1"><a id="c4-para-2815"/><b>function</b> simple_stream_flatmap(fun, s) {</p>
<p class="Sp-text-1"><a id="c4-para-2816"/>    <b>return</b> simple_flatten(stream_map(fun, s));</p>
<p class="Sp-text-1"><a id="c4-para-2817"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2818"/><b>function</b> simple_flatten(stream) {</p>
<p class="Sp-text-1"><a id="c4-para-2819"/>    <b>return</b> stream_map(〈<span class="KeyTerm2">??</span>〉,</p>
<p class="Sp-text-1"><a id="c4-para-2820"/>                      stream_filter(〈<span class="KeyTerm2">??</span>〉, stream));</p>
<p class="Sp-text-1"><a id="c4-para-2821"/><sub>}</sub></p></li>
<li><a id="c4-li-0104"/><span>b. </span>Does the query system's behavior change if we change it in this way?</li>
</ol>
</section>
<section>
<h5><a id="c4-sec-0166"/><a id="c4-title-0167"/>Exercise 4.72</h5>
<p class="paraaftertitle"><a id="c4-para-2823"/>Implement for the query language a syntactic form called <span class="KeyTerm1">unique</span>. Applictions of <span class="KeyTerm1">unique</span> should succeed if there is precisely one item in the data base satisfying a specified query. For example,</p>
<p class="Sp-text-1"><a id="c4-para-2824"/>unique(job($x, list("computer", "wizard")))</p>
<p class="paracontinue"><a id="c4-para-2825"/>should print the one-item stream</p>
<p class="Sp-text-1"><a id="c4-para-2826"/>unique(job(list("Bitdiddle", "Ben"), list("computer", "wizard")))</p>
<p class="paracontinue"><a id="c4-para-2827"/>since Ben is the only computer wizard, and</p>
<p class="Sp-text-1"><a id="c4-para-2828"/>unique(job($x, list("computer", "programmer")))</p>
<p class="paracontinue"><a id="c4-para-2829"/>should print the empty stream, since there is more than one computer programmer. Moreover,</p>
<p class="Sp-text-1"><a id="c4-para-2830"/>and(job($x, $j), unique(job($anyone, $j)))</p>
<p class="paracontinue"><a id="c4-para-2831"/>should list all the jobs that are filled by only one person, and the people who fill them.</p>
<p><a id="c4-para-2832"/>There are two parts to implementing <span class="KeyTerm1">unique</span>. The first is to write a function that handles this syntactic form, and the second is to make <span class="KeyTerm1">evaluate_query</span> dispatch to that function. The second part is trivial, since <span class="KeyTerm1">evaluate_query</span> does its dispatching in a data-directed way. If your function is called <span class="KeyTerm1">uniquely_asserted</span>, all you need to do is</p>
<p class="Sp-text-1"><a id="c4-para-2833"/>put("unique", "evaluate_query", uniquely_asserted);</p>
<p class="paracontinue"><a id="c4-para-2834"/>and <span class="KeyTerm1">evaluate_query</span> will dispatch to this function for every query whose <span class="KeyTerm1">type</span> (head) is the string <span class="KeyTerm1">"unique"</span>.</p>
<p><a id="c4-para-2835"/>The real problem is to write the function <span class="KeyTerm1">uniquely_asserted</span>. This should take as input the <span class="KeyTerm1">contents</span> (tail) of the <span class="KeyTerm1">unique</span> query, together with a stream of frames. For each frame in the stream, it should use <span class="KeyTerm1">evaluate_query</span> to find the stream of all extensions to the frame that satisfy the given query. Any stream that does not have exactly one item in it should be eliminated. The remaining streams should be passed back to be accumulated into one big stream that is the result of the <span class="KeyTerm1">unique</span> query. This is similar to the implementation of the <span class="KeyTerm1">not</span> syntactic form.</p>
<p><a id="c4-para-2836"/>Test your implementation by forming a query that lists all people who supervise precisely one person.</p>
</section>
<section>
<h5><a id="c4-sec-0167"/><a id="c4-title-0168"/>Exercise 4.73</h5>
<p class="paraaftertitle"><a id="c4-para-2837"/>Our implementation of <span class="KeyTerm1">and</span> as a series combination of queries (<a href="#c4-fig-0006">figure 4.6</a>) is elegant, but it is inefficient because in processing the second query of the <span class="KeyTerm1">and</span> we must scan the data base for each frame produced by the first query. If the data base has <i>N</i> elements, and a typical query produces a number of output frames proportional to <i>N</i> (say <i>N</i>/<i>k</i>), then scanning the data base for each frame produced by the first query will require <i>N</i><sup>2</sup>/<i>k</i> calls to the pattern matcher. Another approach would be to process the two clauses of the <span class="KeyTerm1">and</span> separately, then look for all pairs of output frames that are compatible. If each query produces <i>N</i>/<i>k</i> output frames, then this means that we must perform <i>N</i><sup>2</sup>/<i>k</i><sup>2</sup> compatibility checks—a factor of <i>k</i> fewer than the number of matches required in our current method.</p>
<p><a id="c4-para-2838"/>Devise an implementation of <span class="KeyTerm1">and</span> that uses this strategy. You must implement a function that takes two frames as inputs, checks whether the bindings in the frames are compatible, and, if so, produces a frame that merges the two sets of bindings. This operation is similar to unification.</p>
</section>
<section>
<h5><a id="c4-sec-0168"/><a id="c4-title-0169"/>Exercise 4.74</h5>
<p class="paraaftertitle"><a id="c4-para-2839"/>In section 4.4.3 we saw that <span class="KeyTerm1">not</span> and <span class="KeyTerm1">javascript_predicate</span> can cause the query language to give “wrong” answers if these filtering operations are applied to frames in which variables are unbound. Devise a way to fix this shortcoming. One idea is to perform the filtering in a “delayed” manner by appending to the frame a “promise” to filter that is fulfilled only when enough variables have been bound to make the operation possible. We could wait to perform filtering until all other operations have been performed. However, for efficiency's sake, we would like to perform filtering as soon as possible so as to cut down on the number of intermediate frames generated.</p>
</section>
<section>
<h5><a id="c4-sec-0169"/><a id="c4-title-0170"/>Exercise 4.75</h5>
<p class="paraaftertitle"><a id="c4-para-2840"/>Redesign the query language as a nondeterministic program to be implemented using the evaluator of section 4.3, rather than as a stream process. In this approach, each query will produce a single answer (rather than the stream of all answers) and the user can type <span class="KeyTerm1">retry</span> to see more answers. You should find that much of the mechanism we built in this section is subsumed by nondeterministic search and backtracking. You will probably also find, however, that your new query language has subtle differences in behavior from the one implemented here. Can you find examples that illustrate this difference?</p>
</section>
<section>
<h5><a id="c4-sec-0170"/><a id="c4-title-0171"/>Exercise 4.76</h5>
<p class="paraaftertitle"><a id="c4-para-2841"/>When we implemented the JavaScript evaluator in section 4.1, we saw how to use local environments to avoid name conflicts between the parameters of functions. For example, in evaluating</p>
<p class="Sp-text-1"><a id="c4-para-2842"/><b>function</b> square(x) {</p>
<p class="Sp-text-1"><a id="c4-para-2843"/>    <b>return</b> x * x;</p>
<p class="Sp-text-1"><a id="c4-para-2844"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2845"/><b>function</b> sum_of_squares(x, y) {</p>
<p class="Sp-text-1"><a id="c4-para-2846"/>    <b>return</b> square(x) + square(y);</p>
<p class="Sp-text-1"><a id="c4-para-2847"/>}</p>
<p class="Sp-text-1"><a id="c4-para-2848"/>sum_of_squares(3, 4);</p>
<p class="paracontinue"><a id="c4-para-2849"/>there is no confusion between the <span class="KeyTerm1">x</span> in <span class="KeyTerm1">square</span> and the <span class="KeyTerm1">x</span> in <span class="KeyTerm1">sum_of_squares</span>, because we evaluate the body of each function in an environment that is specially constructed to contain bindings for the local names. In the query system, we used a different strategy to avoid name conflicts in applying rules. Each time we apply a rule we rename the variables with new names that are guaranteed to be unique. The analogous strategy for the JavaScript evaluator would be to do away with local environments and simply rename the variables in the body of a function each time we apply the function.</p>
<p><a id="c4-para-2850"/>Implement for the query language a rule-application method that uses environments rather than renaming. See if you can build on your environment structure to create constructs in the query language for dealing with large systems, such as the rule analog of block-structured functions. Can you relate any of this to the problem of making deductions in a context (e.g., “If I supposed that <i>P</i> were true, then I would be able to deduce <i>A</i> and <i>B</i>.”) as a method of problem solving? (This problem is open-ended.)</p>
</section>
</section>
</section>
</section>
<section class="BS_enoteSec">
<aside class="noteEntry"><a id="c4-fn-0001"/><a href="#c4-fn-0001a">1</a> The same idea is pervasive throughout all of engineering. For example, electrical engineers use many different languages for describing circuits. Two of these are the language of electrical <i>networks</i> and the language of electrical <i>systems</i>. The network language emphasizes the physical modeling of devices in terms of discrete electrical elements. The primitive objects of the network language are primitive electrical components such as resistors, capacitors, inductors, and transistors, which are characterized in terms of physical variables called voltage and current. When describing circuits in the network language, the engineer is concerned with the physical characteristics of a design. In contrast, the primitive objects of the system language are signal-processing modules such as filters and amplifiers. Only the functional behavior of the modules is relevant, and signals are manipulated without concern for their physical realization as voltages and currents. The system language is erected on the network language, in the sense that the elements of signal-processing systems are constructed from electrical networks. Here, however, the concerns are with the large-scale organization of electrical devices to solve a given application problem; the physical feasibility of the parts is assumed. This layered collection of languages is another example of the stratified design technique illustrated by the picture language of section 2.2.4.</aside>
<aside class="noteEntry"><a id="c4-fn-0002"/><a href="#c4-fn-0002a">2</a> The most important features that our evaluator leaves out are mechanisms for handling errors and supporting debugging. For a more extensive discussion of evaluators, see Friedman, Wand, and Haynes 1992, which gives an exposition of programming languages that proceeds via a sequence of evaluators written in the Scheme dialect of Lisp.</aside>
<aside class="noteEntry"><a id="c4-fn-0003"/><a href="#c4-fn-0003a">3</a> Even so, there will remain important aspects of the evaluation process that are not elucidated by our evaluator. The most important of these are the detailed mechanisms by which functions call other functions and return values to their callers. We will address these issues in chapter 5, where we take a closer look at the evaluation process by implementing the evaluator as a simple register machine.</aside>
<aside class="noteEntry"><a id="c4-fn-0004"/><a href="#c4-fn-0004a">4</a> If we grant ourselves the ability to apply primitives, then what remains for us to implement in the evaluator? The job of the evaluator is not to specify the primitives of the language, but rather to provide the connective tissue—the means of combination and the means of abstraction—that binds a collection of primitives to form a language. Specifically:<ul style="list-style-type:disc">
<li>The evaluator enables us to deal with nested expressions. For example, although simply applying primitives would suffice for evaluating the expression <span class="KeyTerm1">2 * 6</span>, it is not adequate for handling <span class="KeyTerm1">2 * (1 + 5)</span>. As far as the operator <span class="KeyTerm1">*</span> is concerned, its arguments must be numbers, and it would choke if we passed it the expression <span class="KeyTerm1">1 + 5</span> as an argument. One important role of the evaluator is to choreograph composition so that <span class="KeyTerm1">1 + 5</span> is reduced to 6 before being passed as an argument to <span class="KeyTerm1">*</span>.</li>
<li>The evaluator allows us to use names. For example, the addition operator has no way to deal with expressions such as <span class="KeyTerm1">x + 1</span>. We need an evaluator to keep track of names and obtain their values before invoking the operators.</li>
<li>The evaluator allows us to define compound functions. This involves knowing how to use these functions in evaluating expressions and providing a mechanism that enables functions to accept arguments.</li>
<li>The evaluator provides the other syntactic forms of the language such as conditionals and blocks.</li>
</ul></aside>
<aside class="noteEntry"><a id="c4-fn-0005"/><a href="#c4-fn-0005a">5</a> There is no need to distinguish between statements and expressions in our evaluator. For example, we do not differentiate between expressions and expression statements; we represent them identically and consequently they are handled in the same way by the <span class="KeyTerm1">evaluate</span> function. Similarly, our evaluator does not enforce JavaScript's syntactic restriction that statements cannot appear inside expressions other than lambda expressions.</aside>
<aside class="noteEntry"><a id="c4-fn-0006"/><a href="#c4-fn-0006a">6</a> This test is a deferred operation, and thus our evaluator will give rise to a recursive process even if the interpreted program should give rise to an iterative process according to the description in section 1.2.1. In other words, our metacircular evaluator implementation of JavaScript is not tail-recursive. Sections 5.4.2 and 5.5.3 show how to achieve tail recursion using a register machine.</aside>
<aside class="noteEntry"><a id="c4-fn-0007"/><a href="#c4-fn-0007a">7</a> We chose to implement <span class="KeyTerm1">list_of_values</span> using the higher-order function <span class="KeyTerm1">map</span>, and we will use <span class="KeyTerm1">map</span> in other places as well. However, the evaluator can be implemented without any use of higher-order functions (and thus could be written in a language that doesn't have higher-order functions), even though the language that it supports will include higher-order functions. For example, <span class="KeyTerm1">list_of_values</span> can be written without <span class="KeyTerm1">map</span> as follows:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> list_of_values(exps, env) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> is_null(exps)</span>
<br/><span class="BS_Sp-text-1_FN">           ? <b>null</b></span>
<br/><span class="BS_Sp-text-1_FN">           : pair(evaluate(head(exps), env),</span>
<br/><span class="BS_Sp-text-1_FN">                  list_of_values(tail(exps), env));</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c4-fn-0008"/><a href="#c4-fn-0008a">8</a> In this case, the language being implemented and the implementation language are the same. Contemplation of the meaning of <span class="KeyTerm1">is_truthy</span> here yields expansion of consciousness without the abuse of substance.</aside>
<aside class="noteEntry"><a id="c4-fn-0009"/><a href="#c4-fn-0009a">9</a> The treatment of return statements in <span class="KeyTerm1">eval_sequence</span> reflects the proper result of evaluating function applications in JavaScript, but the evaluator presented here does not comply with the ECMAScript specification for the value of a program that consists of a sequence of statements <i>outside of</i> any function body. Exercise 4.8 addresses this issue.</aside>
<aside class="noteEntry"><a id="c4-fn-0010"/><a href="#c4-fn-0010a">10</a> The application of the function <span class="KeyTerm1">make_return_value</span> to the result of evaluating the return expression creates a deferred operation, in addition to the deferred operation created by <span class="KeyTerm1">apply</span>. See footnote 6 for details.</aside>
<aside class="noteEntry"><a id="c4-fn-0011"/><a href="#c4-fn-0011a">11</a> These selectors for a list of statements are not intended as a data abstraction. They are introduced as mnemonic names for the basic list operations in order to make it easier to understand the explicit-control evaluator in section 5.4.</aside>
<aside class="noteEntry"><a id="c4-fn-0012"/><a href="#c4-fn-0012a">12</a> A parser implementation may decide to represent a block by just its statement sequence if none of the statements of the sequence are declarations, or to represent a sequence with only one statement by just that statement. The language processors in this chapter and in chapter 5 do not depend on these decisions.</aside>
<aside class="noteEntry"><a id="c4-fn-0013"/><a href="#c4-fn-0013a">13</a> In actual JavaScript, there are subtle differences between the two forms; see footnote 54 in chapter 1. Exercise 4.17 addresses these differences.</aside>
<aside class="noteEntry"><a id="c4-fn-0014"/><a href="#c4-fn-0014a">14</a> Conditionals in full JavaScript accept <i>any</i> value, not just a boolean, as the result of evaluating the “predicate” expression. JavaScript's notion of truthiness and falsiness is captured by the following variants of <span class="KeyTerm1">is_truthy</span> and <span class="KeyTerm1">is_falsy</span>:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> is_truthy(x) { <b>return</b> ! is_falsy(x); }</span>
<br/><span class="BS_Sp-text-1_FN"><b>function</b> is_falsy(x) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> (is_boolean(x) &amp;&amp; !x )                   ||</span>
<br/><span class="BS_Sp-text-1_FN">            (is_number(x) &amp;&amp; (x === 0 || x !== x )) ||</span>
<br/><span class="BS_Sp-text-1_FN">            (is_string(x) &amp;&amp; x === "")              ||</span>
<br/><span class="BS_Sp-text-1_FN">            is_null(x)                              ||</span>
<br/><span class="BS_Sp-text-1_FN">            is_undefined(x);</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>The test <span class="KeyTerm1">x !== x</span> is not a typo; the only JavaScript value for which <span class="KeyTerm1">x !== x</span> yields true is the value <span class="KeyTerm1">NaN</span> (“Not a Number”), which is considered to be a falsy number (also not a typo), along with 0. The numerical value <span class="KeyTerm1">NaN</span> is the result of certain arithmetic border cases such as <span class="KeyTerm1">0 / 0</span>.<br/>  The terms “truthy” and “falsy” were coined by Douglas Crockford, one of whose books (Crockford 2008) inspired this JavaScript adaptation.</aside>
<aside class="noteEntry"><a id="c4-fn-0015"/><a href="#c4-fn-0015a">15</a> Frames are not really a data abstraction: The function <span class="KeyTerm1">assign_symbol_value</span> below uses <span class="KeyTerm1">set_head</span> to directly modify the values in a frame. The purpose of the frame functions is to make the environment-manipulation functions easy to read.</aside>
<aside class="noteEntry"><a id="c4-fn-0016"/><a href="#c4-fn-0016a">16</a> The drawback of this representation (as well as the variant in exercise 4.9) is that the evaluator may have to search through many frames in order to find the binding for a given variable. (Such an approach is referred to as <i>deep binding</i>.) One way to avoid this inefficiency is to make use of a strategy called <i>lexical addressing</i>, which will be discussed in section 5.5.6.</aside>
<aside class="noteEntry"><a id="c4-fn-0017"/><a href="#c4-fn-0017a">17</a> Any function defined in the underlying JavaScript can be used as a primitive for the metacircular evaluator. The name of a primitive installed in the evaluator need not be the same as the name of its implementation in the underlying JavaScript; the names are the same here because the metacircular evaluator implements JavaScript itself. Thus, for example, we could put <span class="KeyTerm1">list("first", head)</span> or <span class="KeyTerm1">list("square", x =&gt; x * x)</span> in the list of <span class="KeyTerm1">primitive_functions</span>.</aside>
<aside class="noteEntry"><a id="c4-fn-0018"/><a href="#c4-fn-0018a">18</a> JavaScript's <span class="KeyTerm1">apply</span> method expects the function arguments in a <i>vector</i>. (Vectors are called “arrays” in JavaScript.) Thus, the <span class="KeyTerm1">arglist</span> is transformed into a vector—here using a while loop (see exercise 4.7):
<br/><span class="BS_Sp-text-1_FN"><b>function</b> apply_in_underlying_javascript(prim, arglist) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>const</b> arg_vector = []; <span class="KeyTerm2"><i>// empty vector</i></span></span>
<br/><span class="BS_Sp-text-1_FN">    <b>let</b> i = 0;</span>
<br/><span class="BS_Sp-text-1_FN">    <b>while</b> (!is_null(arglist)) {</span>
<br/><span class="BS_Sp-text-1_FN">        arg_vector[i] = head(arglist); <span class="KeyTerm2"><i>// store value at index</i></span> i</span>
<br/><span class="BS_Sp-text-1_FN">         i = i + 1;</span>
<br/><span class="BS_Sp-text-1_FN">        arglist = tail(arglist);</span>
<br/><span class="BS_Sp-text-1_FN">    }</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> prim.apply(prim, arg_vector); <i>//</i> apply <i>is accessed via</i> prim</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
<br/>We also made use of <span class="KeyTerm1">apply_in_underlying_javascript</span> to declare the function <span class="KeyTerm1">apply_ generic</span> in section 2.4.3.</aside>
<aside class="noteEntry"><a id="c4-fn-0019"/><a href="#c4-fn-0019a">19</a> The fact that the machines are described in JavaScript is inessential. If we give our evaluator a JavaScript program that behaves as an evaluator for some other language, say C, the JavaScript evaluator will emulate the C evaluator, which in turn can emulate any machine described as a C program. Similarly, writing a JavaScript evaluator in C produces a C program that can execute any JavaScript program. The deep idea here is that any evaluator can emulate any other. Thus, the notion of “what can in principle be computed” (ignoring practicalities of time and memory required) is independent of the language or the computer, and instead reflects an underlying notion of <i>computability</i>. This was first demonstrated in a clear way by Alan M. Turing (1912–1954), whose 1936 paper laid the foundations for theoretical computer science. In the paper, Turing presented a simple computational model—now known as a <i>Turing machine</i>—and argued that any “effective process” can be formulated as a program for such a machine. (This argument is known as the <i>Church–Turing thesis</i>.) Turing then implemented a universal machine, i.e., a Turing machine that behaves as an evaluator for Turing-machine programs. He used this framework to demonstrate that there are well-posed problems that cannot be computed by Turing machines (see exercise 4.15), and so by implication cannot be formulated as “effective processes.” Turing went on to make fundamental contributions to practical computer science as well. For example, he invented the idea of structuring programs using general-purpose subroutines. See Hodges 1983 for a biography of Turing.</aside>
<aside class="noteEntry"><a id="c4-fn-0020"/><a href="#c4-fn-0020a">20</a> Some people find it counterintuitive that an evaluator, which is implemented by a relatively simple function, can emulate programs that are more complex than the evaluator itself. The existence of a universal evaluator machine is a deep and wonderful property of computation. <i>Recursion theory</i>, a branch of mathematical logic, is concerned with logical limits of computation. Douglas Hofstadter's beautiful book <i>Gödel, Escher, Bach</i> (1979) explores some of these ideas.</aside>
<aside class="noteEntry"><a id="c4-fn-0021"/><a href="#c4-fn-0021a">21</a> Note that <span class="KeyTerm1">eval</span> may not be available in the JavaScript environment that you are using, or its use may be restricted for security reasons.</aside>
<aside class="noteEntry"><a id="c4-fn-0022"/><a href="#c4-fn-0022a">22</a> Although we stipulated that <span class="KeyTerm1">halts</span> is given a function object, notice that this reasoning still applies even if <span class="KeyTerm1">halts</span> can gain access to the function's text and its environment. This is Turing's celebrated <i>Halting Theorem</i>, which gave the first clear example of a <i>noncomputable</i> problem, i.e., a well-posed task that cannot be carried out as a computational function.</aside>
<aside class="noteEntry"><a id="c4-fn-0023"/><a href="#c4-fn-0023a">23</a> This example illustrates a programming trick for formulating recursive functions without using assignment. The most general trick of this sort is the <i>Y operator</i>, which can be used to give a “pure <i>λ</i>-calculus” implementation of recursion. (See Stoy 1977 for details on the lambda calculus, and Gabriel 1988 for an exposition of the <i>Y</i> operator in the language Scheme.)</aside>
<aside class="noteEntry"><a id="c4-fn-0024"/><a href="#c4-fn-0024a">24</a> The designers of JavaScript support Alyssa on the following grounds: Eva is in principle correct—the declarations should be regarded as simultaneous. But it seems difficult to implement a general, efficient mechanism that does what Eva requires. In the absence of such a mechanism, it is better to generate an error in the difficult cases of simultaneous declarations (Alyssa's notion) than to produce an incorrect answer (as Ben would have it).</aside>
<aside class="noteEntry"><a id="c4-fn-0025"/><a href="#c4-fn-0025a">25</a> This technique is an integral part of the compilation process, which we shall discuss in chapter 5. Jonathan Rees wrote a Scheme interpreter like this in about 1982 for the T project (Rees and Adams 1982). Marc Feeley 1986 (see also Feeley and Lapalme 1987) independently invented this technique in his master's thesis.</aside>
<aside class="noteEntry"><a id="c4-fn-0026"/><a href="#c4-fn-0026a">26</a> There is, however, an important part of the search for a name that <i>can</i> be done as part of the syntactic analysis. As we will show in section 5.5.6, one can determine the position in the environment structure where the value of the variable will be found, thus obviating the need to scan the environment for the entry that matches the variable.</aside>
<aside class="noteEntry"><a id="c4-fn-0027"/><a href="#c4-fn-0027a">27</a> See exercise 4.21 for some insight into the processing of sequences.</aside>
<aside class="noteEntry"><a id="c4-fn-0028"/><a href="#c4-fn-0028a">28</a> Snarf: “To grab, especially a large document or file for the purpose of using it either with or without the owner's permission.” Snarf down: “To snarf, sometimes with the connotation of absorbing, processing, or understanding.” (These definitions were snarfed from Steele et al. 1983. See also Raymond 1996.)</aside>
<aside class="noteEntry"><a id="c4-fn-0029"/><a href="#c4-fn-0029a">29</a> The difference between the “lazy” terminology and the “normal-order” terminology is somewhat fuzzy. Generally, “lazy” refers to the mechanisms of particular evaluators, while “normal-order” refers to the semantics of languages, independent of any particular evaluation strategy. But this is not a hard-and-fast distinction, and the two terminologies are often used interchangeably.</aside>
<aside class="noteEntry"><a id="c4-fn-0030"/><a href="#c4-fn-0030a">30</a> The “strict” versus “non-strict” terminology means essentially the same as “applicativeorder” versus “normal-order,” except that it refers to individual functions and arguments rather than to the language as a whole. At a conference on programming languages you might hear someone say, “The normal-order language Hassle has certain strict primitives. Other functions take their arguments by lazy evaluation.”</aside>
<aside class="noteEntry"><a id="c4-fn-0031"/><a href="#c4-fn-0031a">31</a> The word <i>thunk</i> was invented by an informal working group that was discussing the implementation of call-by-name in Algol 60. They observed that most of the analysis of (“thinking about”) the expression could be done at compile time; thus, at run time, the expression would already have been “thunk” about (Ingerman et al. 1960).</aside>
<aside class="noteEntry"><a id="c4-fn-0032"/><a href="#c4-fn-0032a">32</a> This is analogous to the forcing of the delayed objects that were introduced in chapter 3 to represent streams. The critical difference between what we are doing here and what we did in chapter 3 is that we are building delaying and forcing into the evaluator, and thus making this uniform and automatic throughout the language.</aside>
<aside class="noteEntry"><a id="c4-fn-0033"/><a href="#c4-fn-0033a">33</a> Lazy evaluation combined with memoization is sometimes referred to as <i>call-by-need</i> argument passing, in contrast to <i>call-by-name</i> argument passing. (Call-by-name, introduced in Algol 60, is similar to non-memoized lazy evaluation.) As language designers, we can build our evaluator to memoize, not to memoize, or leave this an option for programmers (exercise 4.29). As you might expect from chapter 3, these choices raise issues that become both subtle and confusing in the presence of assignments. (See exercises 4.25 and 4.27.) An excellent article by Clinger (1982) attempts to clarify the multiple dimensions of confusion that arise here.</aside>
<aside class="noteEntry"><a id="c4-fn-0034"/><a href="#c4-fn-0034a">34</a> Notice that we also erase the <span class="KeyTerm1">env</span> from the thunk once the expression's value has been computed. This makes no difference in the values returned by the interpreter. It does help save space, however, because removing the reference from the thunk to the <span class="KeyTerm1">env</span> once it is no longer needed allows this structure to be <i>garbage-collected</i> and its space recycled, as we will discuss in section 5.3.<br/>  Similarly, we could have allowed unneeded environments in the memoized delayed objects of section 3.5.1 to be garbage-collected, by having <span class="KeyTerm1">memo</span> do something like <span class="KeyTerm1">fun = <b>null</b>;</span> to discard the function <span class="KeyTerm1">fun</span> (which includes the environment in which the lambda expression that makes up the tail of the stream was evaluated) after storing its value.</aside>
<aside class="noteEntry"><a id="c4-fn-0035"/><a href="#c4-fn-0035a">35</a> This exercise demonstrates that the interaction between lazy evaluation and side effects can be very confusing. This is just what you might expect from the discussion in chapter 3.</aside>
<aside class="noteEntry"><a id="c4-fn-0036"/><a href="#c4-fn-0036a">36</a> This is the functional representation described in exercise 2.4. Essentially any functional representation (e.g., a message-passing implementation) would do as well. Notice that we can install these definitions in the lazy evaluator simply by typing them at the driver loop. If we had originally included <span class="KeyTerm1">pair</span>, <span class="KeyTerm1">head</span>, and <span class="KeyTerm1">tail</span> as primitives in the global environment, they will be redefined. (Also see exercises 4.31 and 4.32.)</aside>
<aside class="noteEntry"><a id="c4-fn-0037"/><a href="#c4-fn-0037a">37</a> This permits us to create delayed versions of more general kinds of list structures, not just sequences. Hughes 1990 discusses some applications of “lazy trees.”</aside>
<aside class="noteEntry"><a id="c4-fn-0038"/><a href="#c4-fn-0038a">38</a> We assume that we have previously defined a function <span class="KeyTerm1">is_prime</span> that tests whether numbers are prime. Even with <span class="KeyTerm1">is_prime</span> defined, the <span class="KeyTerm1">prime_sum_pair</span> function may look suspiciously like the unhelpful “pseudo-JavaScript” attempt to define the square-root function, which we described at the beginning of section 1.1.7. In fact, a square-root function along those lines can actually be formulated as a nondeterministic program. By incorporating a search mechanism into the evaluator, we are eroding the distinction between purely declarative descriptions and imperative specifications of how to compute answers. We'll go even farther in this direction in section 4.4.</aside>
<aside class="noteEntry"><a id="c4-fn-0039"/><a href="#c4-fn-0039a">39</a> The idea of <span class="KeyTerm1">amb</span> for nondeterministic programming was first described in 1961 by John McCarthy (see McCarthy 1967).</aside>
<aside class="noteEntry"><a id="c4-fn-0040"/><a href="#c4-fn-0040a">40</a> In actuality, the distinction between nondeterministically returning a single choice and returning all choices depends somewhat on our point of view. From the perspective of the code that uses the value, the nondeterministic choice returns a single value. From the perspective of the programmer designing the code, the nondeterministic choice potentially returns all possible values, and the computation branches so that each value is investigated separately.</aside>
<aside class="noteEntry"><a id="c4-fn-0041"/><a href="#c4-fn-0041a">41</a> One might object that this is a hopelessly inefficient mechanism. It might require millions of processors to solve some easily stated problem this way, and most of the time most of those processors would be idle. This objection should be taken in the context of history. Memory used to be considered just such an expensive commodity. In 1965 a megabyte of RAM cost about $400,000. Now every personal computer has many gigabytes of RAM, and most of the time most of that RAM is unused. It is hard to underestimate the cost of mass-produced electronics.</aside>
<aside class="noteEntry"><a id="c4-fn-0042"/><a href="#c4-fn-0042a">42</a> Automagically: “Automatically, but in a way which, for some reason (typically because it is too complicated, or too ugly, or perhaps even too trivial), the speaker doesn't feel like explaining.” (Steele 1983, Raymond 1996)</aside>
<aside class="noteEntry"><a id="c4-fn-0043"/><a href="#c4-fn-0043a">43</a> The integration of automatic search strategies into programming languages has had a long and checkered history. The first suggestions that nondeterministic algorithms might be elegantly encoded in a programming language with search and automatic backtracking came from Robert Floyd (1967). Carl Hewitt (1969) invented a programming language called Planner that explicitly supported automatic chronological backtracking, providing for a built-in depthfirst search strategy. Sussman, Winograd, and Charniak (1971) implemented a subset of this language, called MicroPlanner, which was used to support work in problem solving and robot planning. Similar ideas, arising from logic and theorem proving, led to the genesis in Edinburgh and Marseille of the elegant language Prolog (which we will discuss in section 4.4). After sufficient frustration with automatic search, McDermott and Sussman (1972) developed a language called Conniver, which included mechanisms for placing the search strategy under programmer control. This proved unwieldy, however, and Sussman and Stallman (1975) found a more tractable approach while investigating methods of symbolic analysis for electrical circuits. They developed a nonchronological backtracking scheme that was based on tracing out the logical dependencies connecting facts, a technique that has come to be known as <i>dependencydirected backtracking</i>. Although their method was complex, it produced reasonably efficient programs because it did little redundant search. Doyle (1979) and McAllester (1978, 1980) generalized and clarified the methods of Stallman and Sussman, developing a new paradigm for formulating search that is now called <i>truth maintenance</i>. Many problem-solving systems use some form of truth-maintenance system as a substrate. See Forbus and de Kleer 1993 for a discussion of elegant ways to build truth-maintenance systems and applications using truth maintenance. Zabih, McAllester, and Chapman 1987 describes a nondeterministic extension to Scheme that is based on <span class="KeyTerm1">amb</span>; it is similar to the interpreter described in this section, but more sophisticated, because it uses dependency-directed backtracking rather than chronological backtracking. Winston 1992 gives an introduction to both kinds of backtracking.</aside>
<aside class="noteEntry"><a id="c4-fn-0044"/><a href="#c4-fn-0044a">44</a> Our program uses the following function to determine if the elements of a list are distinct:
<br/><span class="BS_Sp-text-1_FN"><b>function</b> distinct(items) {</span>
<br/><span class="BS_Sp-text-1_FN">    <b>return</b> is_null(items)</span>
<br/><span class="BS_Sp-text-1_FN">           ? <b>true</b></span>
<br/><span class="BS_Sp-text-1_FN">           : is_null(tail(items))</span>
<br/><span class="BS_Sp-text-1_FN">           ? <b>true</b></span>
<br/><span class="BS_Sp-text-1_FN">           : is_null(member(head(items), tail(items)))</span>
<br/><span class="BS_Sp-text-1_FN">           ? distinct(tail(items))</span>
<br/><span class="BS_Sp-text-1_FN">           : <b>false</b>;</span>
<br/><span class="BS_Sp-text-1_FN">}</span>
</aside>
<aside class="noteEntry"><a id="c4-fn-0045"/><a href="#c4-fn-0045a">45</a> Here we use the convention that the first element of each list designates the part of speech for the rest of the words in the list.</aside>
<aside class="noteEntry"><a id="c4-fn-0046"/><a href="#c4-fn-0046a">46</a> Notice that <span class="KeyTerm1">parse_word</span> uses assignment to modify the not-yet-parsed input list. For this to work, our <span class="KeyTerm1">amb</span> evaluator must undo the effects of assignments when it backtracks.</aside>
<aside class="noteEntry"><a id="c4-fn-0047"/><a href="#c4-fn-0047a">47</a> Observe that this definition is recursive—a verb may be followed by any number of prepositional phrases.</aside>
<aside class="noteEntry"><a id="c4-fn-0048"/><a href="#c4-fn-0048a">48</a> This kind of grammar can become arbitrarily complex, but it is only a toy as far as real language understanding is concerned. Real natural-language understanding by computer requires an elaborate mixture of syntactic analysis and interpretation of meaning. On the other hand, even toy parsers can be useful in supporting flexible command languages for programs such as information-retrieval systems. Winston 1992 discusses computational approaches to real language understanding and also the applications of simple grammars to command languages.</aside>
<aside class="noteEntry"><a id="c4-fn-0049"/><a href="#c4-fn-0049a">49</a> Although Alyssa's idea works just fine (and is surprisingly simple), the sentences that it generates are a bit boring—they don't sample the possible sentences of this language in a very interesting way. In fact, the grammar is highly recursive in many places, and Alyssa's technique “falls into” one of these recursions and gets stuck. See exercise 4.48 for a way to deal with this.</aside>
<aside class="noteEntry"><a id="c4-fn-0050"/><a href="#c4-fn-0050a">50</a> We chose to implement the lazy evaluator in section 4.2 as a modification of the ordinary metacircular evaluator of section 4.1.1. In contrast, we will base the <span class="KeyTerm1">amb</span> evaluator on the analyzing evaluator of section 4.1.7, because the execution functions in that evaluator provide a convenient framework for implementing backtracking.</aside>
<aside class="noteEntry"><a id="c4-fn-0051"/><a href="#c4-fn-0051a">51</a> With this treatment, <span class="KeyTerm1">amb</span> is no longer a name with proper scoping. To avoid confusion, we must refrain from declaring <span class="KeyTerm1">amb</span> as a name in our nondeterministic programs.</aside>
<aside class="noteEntry"><a id="c4-fn-0052"/><a href="#c4-fn-0052a">52</a> We didn't worry about undoing declarations, since we assume that a name can't be used prior to the evaluation of its declaration, so its previous value doesn't matter.</aside>
<aside class="noteEntry"><a id="c4-fn-0053"/><a href="#c4-fn-0053a">53</a> Logic programming has grown out of a long history of research in automatic theorem proving. Early theorem-proving programs could accomplish very little, because they exhaustively searched the space of possible proofs. The major breakthrough that made such a search plausible was the discovery in the early 1960s of the <i>unification algorithm</i> and the <i>resolution principle</i> (Robinson 1965). Resolution was used, for example, by Green and Raphael (1968) (see also Green 1969) as the basis for a deductive question-answering system. During most of this period, researchers concentrated on algorithms that are guaranteed to find a proof if one exists. Such algorithms were difficult to control and to direct toward a proof. Hewitt (1969) recognized the possibility of merging the control structure of a programming language with the operations of a logic-manipulation system, leading to the work in automatic search mentioned in section 4.3.1 (footnote 43). At the same time that this was being done, Colmerauer, in Marseille, was developing rule-based systems for manipulating natural language (see Colmerauer et al. 1973). He invented a programming language called Prolog for representing those rules. Kowalski (1973; 1979) in Edinburgh, recognized that execution of a Prolog program could be interpreted as proving theorems (using a proof technique called linear Horn-clause resolution). The merging of the last two strands led to the logic-programming movement. Thus, in assigning credit for the development of logic programming, the French can point to Prolog's genesis at the University of Marseille, while the British can highlight the work at the University of Edinburgh. According to people at MIT, logic programming was developed by these groups in an attempt to figure out what Hewitt was talking about in his brilliant but impenetrable Ph.D. thesis. For a history of logic programming, see Robinson 1983.</aside>
<aside class="noteEntry"><a id="c4-fn-0054"/><a href="#c4-fn-0054a">54</a> To see the correspondence between the rules and the function, let <span class="KeyTerm1">x</span> in the function (where <span class="KeyTerm1">x</span> is nonempty) correspond to <span class="KeyTerm1">pair(u, v)</span> in the rule. Then <span class="KeyTerm1">z</span> in the rule corresponds to the <span class="KeyTerm1">append</span> of <span class="KeyTerm1">tail(x)</span> and <span class="KeyTerm1">y</span>.</aside>
<aside class="noteEntry"><a id="c4-fn-0055"/><a href="#c4-fn-0055a">55</a> This certainly does not relieve the user of the entire problem of how to compute the answer. There are many different mathematically equivalent sets of rules for formulating the <span class="KeyTerm1">append</span> relation, only some of which can be turned into effective devices for computing in any direction. In addition, sometimes “what is” information gives no clue “how to” compute an answer. For example, consider the problem of computing the <i>y</i> such that <i>y</i><sup>2</sup> = <i>x</i>.</aside>
<aside class="noteEntry"><a id="c4-fn-0056"/><a href="#c4-fn-0056a">56</a> Interest in logic programming peaked during the early 1980s when the Japanese government began an ambitious project aimed at building superfast computers optimized to run logic programming languages. The speed of such computers was to be measured in LIPS (Logical Inferences Per Second) rather than the usual FLOPS (FLoating-point Operations Per Second). Although the project succeeded in developing hardware and software as originally planned, the international computer industry moved in a different direction. See Feigenbaum and Shrobe 1993 for an overview evaluation of the Japanese project. The logic programming community has also moved on to consider relational programming based on techniques other than simple pattern matching, such as the ability to deal with numerical constraints such as the ones illustrated in the constraint-propagation system of section 3.3.5.</aside>
<aside class="noteEntry"><a id="c4-fn-0057"/><a href="#c4-fn-0057a">57</a> Actually, this description of <span class="KeyTerm1">not</span> is valid only for simple cases. The real behavior of <span class="KeyTerm1">not</span> is more complex. We will examine <span class="KeyTerm1">not</span>'s peculiarities in sections 4.4.2 and 4.4.3.</aside>
<aside class="noteEntry"><a id="c4-fn-0058"/><a href="#c4-fn-0058a">58</a> A query should use <span class="KeyTerm1">javascript_predicate</span> only to perform an operation not provided in the query language. In particular, <span class="KeyTerm1">javascript_predicate</span> should not be used to test equality (since that is what the matching in the query language is designed to do) or inequality (since that can be done with the <span class="KeyTerm1">same</span> rule shown below).</aside>
<aside class="noteEntry"><a id="c4-fn-0059"/><a href="#c4-fn-0059a">59</a> Notice that we do not need <span class="KeyTerm1">same</span> in order to make two things be the same: We just use the same pattern variable for each—in effect, we have one thing instead of two things in the first place. For example, see <span class="KeyTerm1">$town</span> in the <span class="KeyTerm1">lives_near</span> rule and <span class="KeyTerm1">$middle_manager</span> in the <span class="KeyTerm1">wheel</span> rule below. The <span class="KeyTerm1">same</span> relation is useful when we want to force two things to be different, such as <span class="KeyTerm1">$person_1</span> and <span class="KeyTerm1">$person_2</span> in the <span class="KeyTerm1">lives_near</span> rule. Although using the same pattern variable in two parts of a query forces the same value to appear in both places, using different pattern variables does not force different values to appear. (The values assigned to different pattern variables may be the same or different.)</aside>
<aside class="noteEntry"><a id="c4-fn-0060"/><a href="#c4-fn-0060a">60</a> We will also allow rules without bodies, as in <span class="KeyTerm1">same</span>, and we will interpret such a rule to mean that the rule conclusion is satisfied by any values of the variables.</aside>
<aside class="noteEntry"><a id="c4-fn-0061"/><a href="#c4-fn-0061a">61</a> Because matching is generally very expensive, we would like to avoid applying the full matcher to every element of the data base. This is usually arranged by breaking up the process into a fast, coarse match and the final match. The coarse match filters the data base to produce a small set of candidates for the final match. With care, we can arrange our data base so that some of the work of coarse matching can be done when the data base is constructed rather then when we want to select the candidates. This is called <i>indexing</i> the data base. There is a vast technology built around data-base-indexing schemes. Our implementation, described in section 4.4.4, contains a simpleminded form of such an optimization.</aside>
<aside class="noteEntry"><a id="c4-fn-0062"/><a href="#c4-fn-0062a">62</a> But this kind of exponential explosion is not common in <span class="KeyTerm1">and</span> queries because the added conditions tend to reduce rather than expand the number of frames produced.</aside>
<aside class="noteEntry"><a id="c4-fn-0063"/><a href="#c4-fn-0063a">63</a> There is a large literature on data-base-management systems that is concerned with how to handle complex queries efficiently.</aside>
<aside class="noteEntry"><a id="c4-fn-0064"/><a href="#c4-fn-0064a">64</a> There is a subtle difference between this filter implementation of <span class="KeyTerm1">not</span> and the usual meaning of <span class="KeyTerm1">not</span> in mathematical logic. See section 4.4.3.</aside>
<aside class="noteEntry"><a id="c4-fn-0065"/><a href="#c4-fn-0065a">65</a> In one-sided pattern matching, all the equations that contain pattern variables are explicit and already solved for the unknown (the pattern variable).</aside>
<aside class="noteEntry"><a id="c4-fn-0066"/><a href="#c4-fn-0066a">66</a> Another way to think of unification is that it generates the most general pattern that is a specialization of the two input patterns. This means that the unification of <span class="KeyTerm1">list($x, "a")</span> and <span class="KeyTerm1">list(list("b", $y), $z)</span> is <span class="KeyTerm1">list(list("b", $y), "a")</span> and that the unification of <span class="KeyTerm1">list($x, "a", $y)</span> and <span class="KeyTerm1">list($y, $z, "a")</span>, discussed above, is <span class="KeyTerm1">list("a", "a", "a")</span>. For our implementation, it is more convenient to think of the result of unification as a frame rather than a pattern.</aside>
<aside class="noteEntry"><a id="c4-fn-0067"/><a href="#c4-fn-0067a">67</a> Since unification is a generalization of matching, we could simplify the system by using the unifier to produce both streams. Treating the easy case with the simple matcher, however, illustrates how matching (as opposed to full-blown unification) can be useful in its own right.</aside>
<aside class="noteEntry"><a id="c4-fn-0068"/><a href="#c4-fn-0068a">68</a> The reason we use streams (rather than lists) of frames is that the recursive application of rules can generate infinite numbers of values that satisfy a query. The delayed evaluation embodied in streams is crucial here: The system will print responses one by one as they are generated, regardless of whether there are a finite or infinite number of responses.</aside>
<aside class="noteEntry"><a id="c4-fn-0069"/><a href="#c4-fn-0069a">69</a> That a particular method of inference is legitimate is not a trivial assertion. One must prove that if one starts with true premises, only true conclusions can be derived. The method of inference represented by rule applications is <i>modus ponens</i>, the familiar method of inference that says that if <i>A</i> is true and <i>A implies B</i> is true, then we may conclude that <i>B</i> is true.</aside>
<aside class="noteEntry"><a id="c4-fn-0070"/><a href="#c4-fn-0070a">70</a> We must qualify this statement by agreeing that, in speaking of the “inference” accomplished by a logic program, we assume that the computation terminates. Unfortunately, even this qualified statement is false for our implementation of the query language (and also false for programs in Prolog and most other current logic programming languages) because of our use of <span class="KeyTerm1">not</span> and <span class="KeyTerm1">javascript_predicate</span>. As we will describe below, the <span class="KeyTerm1">not</span> implemented in the query language is not always consistent with the <span class="KeyTerm1">not</span> of mathematical logic, and <span class="KeyTerm1">javascript_predicate</span> introduces additional complications. We could implement a language consistent with mathematical logic by simply removing <span class="KeyTerm1">not</span> and <span class="KeyTerm1">javascript_predicate</span> from the language and agreeing to write programs using only simple queries, <span class="KeyTerm1">and</span>, and <span class="KeyTerm1">or</span>. However, this would greatly restrict the expressive power of the language. One of the major concerns of research in logic programming was to find ways to achieve more consistency with mathematical logic without unduly sacrificing expressive power.</aside>
<aside class="noteEntry"><a id="c4-fn-0071"/><a href="#c4-fn-0071a">71</a> This is not a problem of the logic but one of the procedural interpretation of the logic provided by our interpreter. We could write an interpreter that would not fall into a loop here. For example, we could enumerate all the proofs derivable from our assertions and our rules in a breadth-first rather than a depth-first order. However, such a system makes it more difficult to take advantage of the order of deductions in our programs. One attempt to build sophisticated control into such a program is described in de Kleer et al. 1977. Another technique, which does not lead to such serious control problems, is to put in special knowledge, such as detectors for particular kinds of loops (exercise 4.65). However, there can be no general scheme for reliably preventing a system from going down infinite paths in performing deductions. Imagine a diabolical rule of the form “To show <i>P</i>(<i>x</i>) is true, show that <i>P</i>(<i>f</i> (<i>x</i>)) is true,” for some suitably chosen function <i>f</i> .</aside>
<aside class="noteEntry"><a id="c4-fn-0072"/><a href="#c4-fn-0072a">72</a> Consider the query <span class="KeyTerm1">not(baseball_fan(list("Bitdiddle", "Ben")))</span>. The system finds that <span class="KeyTerm1">baseball_fan(list("Bitdiddle", "Ben"))</span> is not in the data base, so the empty frame does not satisfy the pattern and is not filtered out of the initial stream of frames. The result of the query is thus the empty frame, which is used to instantiate the input query to produce <span class="KeyTerm1">not(baseball_fan(list("Bitdiddle", "Ben")))</span>.</aside>
<aside class="noteEntry"><a id="c4-fn-0073"/><a href="#c4-fn-0073a">73</a> A discussion and justification of this treatment of <span class="KeyTerm1">not</span> can be found in the article “Negation as Failure” by Clark (1978).</aside>
<aside class="noteEntry"><a id="c4-fn-0074"/><a href="#c4-fn-0074a">74</a> In general, unifying <span class="KeyTerm1">$y</span> with an expression involving <span class="KeyTerm1">$y</span> would require our being able to find a fixed point of the equation <span class="KeyTerm1">$y</span> = <i>expression involving</i> <span class="KeyTerm1">$y</span> . It is sometimes possible to syntactically form an expression that appears to be the solution. For example, <span class="KeyTerm1">$y</span> = <span class="KeyTerm1">list("f", $y)</span> seems to have the fixed point <span class="KeyTerm1">list("f", list("f", list("f",</span> . . . <span class="KeyTerm1">)))</span>, which we can produce by beginning with the expression <span class="KeyTerm1">list("f", $y)</span> and repeatedly substituting <span class="KeyTerm1">list("f", $y)</span> for <span class="KeyTerm1">$y</span>. Unfortunately, not every such equation has a meaningful fixed point. The issues that arise here are similar to the issues of manipulating infinite series in mathematics. For example, we know that 2 is the solution to the equation <i>y</i> = 1 + <i>y</i>/2. Beginning with the expression 1 + <i>y</i>/2 and repeatedly substituting 1 + <i>y</i>/2 for <i>y</i> gives
<br/>  2 = <i>y</i> = 1 + <i>y</i>/2 = 1 + (1 + <i>y</i>/2)/2 = 1 + 1/2 + <i>y</i>/4 = <span class="KeyTerm1"><i>· · ·</i></span> , 
<br/>which leads to
<br/>  2 = 1 + 1/2 + 1/4 + 1/8 + <span class="KeyTerm1"><i>· · ·</i></span> .
<br/>However, if we try the same manipulation beginning with the observation that –1 is the solution to the equation <i>y</i> = 1 + 2<i>y</i>, we obtain
<br/>  –1 = <i>y</i> = 1 + 2<i>y</i> = 1 + 2(1 + 2<i>y</i>) = 1 + 2 + 4<i>y</i> = <span class="KeyTerm1"><i>· · ·</i></span> ,which leads to
<br/>  –1 = 1 + 2 + 4 + 8 + · · · .
<br/>Although the formal manipulations used in deriving these two equations are identical, the first result is a valid assertion about infinite series but the second is not. Similarly, for our unification results, reasoning with an arbitrary syntactically constructed expression may lead to errors.
<br/>  Nevertheless, most logic programming systems today allow cyclic references, by accepting the cyclic data structure as the result of the match. This is justified theoretically using <i>rational trees</i> (Jaffar and Stuckey 1986). Accepting a cyclic data structure allows self-referential data, such as an employee data structure that refers to the employer, which in turn refers to the employee.</aside>
<aside class="noteEntry"><a id="c4-fn-0075"/><a href="#c4-fn-0075a">75</a> The actual way to get the string that contains the first character of a string <span class="KeyTerm1">s</span> in JavaScript is <span class="KeyTerm1">s.charAt(0)</span>.</aside>
<aside class="noteEntry"><a id="c4-fn-0076"/><a href="#c4-fn-0076a">76</a> Creating new variables with string concatenation and identifying variables by checking their first character during query processing is somewhat wasteful. A more efficient solution would mark pattern variables with a separate tag in the query-language-specific representation and use pair construction rather than string concatenation to create new variables. We chose the less efficient solution to simplify the presentation.</aside>
</section>
</section>
</body>
</html>